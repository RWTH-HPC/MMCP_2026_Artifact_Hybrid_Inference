// Copyright (C) 2024 The m-AIA AUTHORS
//
// This file is part of m-AIA (https://git.rwth-aachen.de/aia/m-AIA/m-AIA)
//
// SPDX-License-Identifier: LGPL-3.0-only

#include "fvcartesianbndrycndxd.h"

#include <cmath>
#include <cstring>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <iterator>
#include <stack>
#include "COMM/mpioverride.h"
#include "GEOM/geometryelement.h"
#include "GEOM/geometryintersection.h"
#include "IO/context.h"
#include "IO/parallelio.h"
#include "MEMORY/list.h"
#include "UTIL/hilbert.h"
#include "fvcartesianbndrycell.h"
#include "fvcartesiansolverxd.h"
#include "fvstg.h"
#include "fvstructuredsolver.h"
#include "property.h"

using namespace std;
using namespace maia::parallel_io;


template <MInt nDim, class SysEqn>
FvBndryCndXD<nDim, SysEqn>::FvBndryCndXD(FvCartesianSolverXD<nDim, SysEqn>* solver)
  : m_sysEqn(&solver->m_sysEqn),
    m_cells(solver->m_cells),
    m_surfaces(solver->m_surfaces),
    m_solverId(solver->m_solverId),
    CV(solver->CV),
    FV(solver->FV),
    PV(solver->PV),
    AV(solver->AV),
    m_minLevel(solver->minLevel()),
    m_maxLevel(solver->maxLevel()),
    m_createSpongeBoundary(solver->m_createSpongeBoundary),
    m_cellsInsideSpongeLayer(solver->m_cellsInsideSpongeLayer),
    m_noCellsInsideSpongeLayer(solver->m_noCellsInsideSpongeLayer),
    m_spongeBndryCndIds(solver->m_spongeBndryCndIds),
    m_spongeFactor(solver->m_spongeFactor),
    m_spongeDirections(solver->m_spongeDirections),
    m_sigmaSpongeBndryId(solver->m_sigmaSpongeBndryId),
    m_sigmaEndSpongeBndryId(solver->m_sigmaEndSpongeBndryId),
    m_spongeLayerThickness(solver->m_spongeLayerThickness),
    m_spongeLayerLayout(solver->m_spongeLayerLayout),
    m_spongeTimeDep(solver->m_spongeTimeDep),
    m_spongeStartIteration(solver->m_spongeStartIteration),
    m_spongeEndIteration(solver->m_spongeEndIteration),
    m_spongeTimeDependent(solver->m_spongeTimeDependent),
    m_noSpongeBndryCndIds(solver->m_noSpongeBndryCndIds),
    m_noMaxSpongeBndryCells(solver->m_noMaxSpongeBndryCells),
    m_spongeBeta(solver->m_spongeBeta),
    m_spongeCoord(solver->m_spongeCoord),
    m_radiusFlameTube(solver->m_radiusFlameTube),
    m_radiusVelFlameTube(solver->m_radiusVelFlameTube),
    m_shearLayerThickness(solver->m_shearLayerThickness),
    m_jetHeight(solver->m_jetHeight),
    m_primaryJetRadius(solver->m_primaryJetRadius),
    m_secondaryJetRadius(solver->m_secondaryJetRadius),
    m_targetVelocityFactor(solver->m_targetVelocityFactor),
    m_momentumThickness(solver->m_momentumThickness),
    m_shearLayerStrength(solver->m_shearLayerStrength),
    m_Ma(solver->m_Ma),
    m_noSpecies(solver->m_noSpecies),
    m_noRansEquations(solver->m_noRansEquations),
    m_combustion(solver->m_combustion),
    m_isEEGas(solver->m_isEEGas) {
  TRACE();

  const MLong oldAllocatedBytes = allocatedBytes();

  m_solver = solver;
  m_inflowTemperatureRatio = m_solver->m_inflowTemperatureRatio;

  // TODO labels:FV,COMM this is a workaround, needs fixing! initBndryCommunications() is called multiple times for
  // adaptation
  m_comm_bc_init = 0;
  m_comm_bcCo_init = 0;

  m_noDirs = 2 * nDim;

  m_noEdges = 2;
  for(MInt i = 1; i < nDim; i++) {
    m_noEdges *= (i + 1);
  }
  m_noLevelSetsUsedForMb = 1;
  m_complexBoundaryMB = false;
  m_cellCoordinatesCorrected = false;

  if(m_solver->m_levelSetMb) {
    /*! \page propertiesFV
      \section complexBoundaryForMb
      <code>MBool FvBndryCndXD::m_complexBoundaryMB </code>\n
      default = <code>0</code>\n \n
      This property triggers if complex boundaries should be considered in MB solver, i.e., cut cells are based on
      information from multiple level-set functions \n possible values are: <ul> <li>0 or 1 (false or true)</li>
      </ul>
      Keywords: <i>MOVING BOUNDARY, MULTIPLE LEVEL SET FUNCTIONS</i>
    */
    m_complexBoundaryMB =
        Context::getSolverProperty<MBool>("complexBoundaryForMb", m_solverId, AT_, &m_complexBoundaryMB);
    if(m_complexBoundaryMB)
      m_noLevelSetsUsedForMb =
          Context::getSolverProperty<MInt>("maxNoLevelSets", m_solverId, AT_, &m_noLevelSetsUsedForMb);
  }


  m_gridCutTest = "SAT";
  m_gridCutTest = Context::getSolverProperty<MString>("gridCutTest", m_solverId, AT_, &m_gridCutTest);

  /*! \page propertiesFV
    \section Bc3011WallTemperature
    <code>MFloat FvBndryCndXD::m_Bc3011WallTemperature </code>\n
    default = <code>(1 + 0.5(gamma - 1) * M_infinity^2)^(-1)</code>\n \n
    This property sets the wall temperature T/T_0 of the finite-volume isothermal wall boundary codition 3011:
    <ul>
    <li> All positive floating-point values greater than zero</li>
    </ul>
    Keywords: <i>FINITE VOLUME, BOUNDARY CONDITIONS</i>
  */
  m_Bc3011WallTemperature = sysEqn().temperature_IR(m_Ma);
  m_Bc3011WallTemperature =
      Context::getSolverProperty<MFloat>("Bc3011WallTemperature", m_solverId, AT_, &m_Bc3011WallTemperature);

  m_besselModes = 0;

  // small cell treatment
  m_createBoundaryAtCutoff = false;
  m_volumeLimitWall = F1B2;
  m_volumeLimitOther = F1B4;

  /*! \page propertiesFV
    \section sigmaNonRefl
    <code>MBool FvBndryCndXD::m_sigmaNonRefl </code>\n
    default = <code>1.0</code>\n \n
    Damping coefficient for partially reflecting boundary conditions cbc3091a, cbc1099_1091_local
    possible values are:
    <ul>
    <li>Floating point value above 0.0</li>
    </ul>
    Keywords: <i>FV, BOUNDARY, BC, NONREFLECTING</i>
  */
  m_sigmaNonRefl = F1;
  m_sigmaNonRefl = Context::getSolverProperty<MFloat>("sigmaNonRefl", m_solverId, AT_, &m_sigmaNonRefl);

  /*! \page propertiesFV
     \section sigmaNonReflInflow
     <code>MBool FvBndryCndXD::m_sigmaNonReflInflow </code>\n
     default = <code>1.0</code>\n \n
     Damping coefficient for subsonic partially reflecting characteristic turbulent inflow condition cbc3091a
     possible values are:
     <ul>
     <li>Floating point value above 0.0</li>
     </ul>
     Keywords: <i>FV, BOUNDARY, BC, NONREFLECTING</i>
   */
  m_sigmaNonReflInflow = F1;
  m_sigmaNonReflInflow =
      Context::getSolverProperty<MFloat>("sigmaNonReflInflow", m_solverId, AT_, &m_sigmaNonReflInflow);

  /*! \page propertiesFV
    \section createBoundaryAtCutoff
    <code>MBool FvBndCnd::m_createBoundaryAtCutoff</code>\n
    default = <code>false</code>\n\n
    Enables/Disables the use of cutoff boundaries; if true, the ids of the cutoff Boundarys have to be set
    (cutOffBndryIds) \n Possible values are:\n
    <ul><li>false, true</li>
    </ul>\n
    Keywords: <i>FINITE_VOLUME, CUTOFF, BOUNDARIES</i>
  */
  m_createBoundaryAtCutoff =
      Context::getSolverProperty<MBool>("createBoundaryAtCutoff", m_solverId, AT_, &m_createBoundaryAtCutoff);
  m_volumeLimitOther = Context::getSolverProperty<MFloat>("volumeLimitOther", m_solverId, AT_, &m_volumeLimitOther);

  /*! \page propertiesFV
    \section volumeLimitWall
    <code>MBool FvBndCnd::m_volumeLimitWall</code>\n
    default = <code>false</code>\n\n
    Check the small cell clusters. If a cluster has a volume big enough to be computed as a regular cell (security
    factor: 2 * volumeLimitWall), the biggest cell will be the master and looses its small state. Possible values are:\n
    <ul>\n
    <li>Floating point value above 0.0</li>
    </ul>\n
    Keywords: <i>FINITE_VOLUME, CUTOFF, BOUNDARIES</i>
  */
  m_volumeLimitWall = Context::getSolverProperty<MFloat>("volumeLimitWall", m_solverId, AT_, &m_volumeLimitWall);

  /*! \page propertiesFV
    \section m_smallCellRHSCorrection
    <code>MBool FvBndCnd::m_smallCellRHSCorrection</code>\n
    default = <code>false</code>\n\n
    Activates the newly developed smallCellRHSCorrection method and deactivates the previous small cell correction
    method <ul>\n <li>Floating point value above 0.0</li>
    </ul>\n
    Keywords: <i>FINITE_VOLUME, CUTOFF, BOUNDARIES</i>
  */
  m_smallCellRHSCorrection = false;
  m_smallCellRHSCorrection =
      Context::getSolverProperty<MBool>("smallCellRHSCorrection", m_solverId, AT_, &m_smallCellRHSCorrection);

  if(m_createBoundaryAtCutoff) {
    m_changeAdiabBCToTemp = false;
    m_changeAdiabBCToTemp =
        Context::getSolverProperty<MBool>("changeAdiabBCToTemp", m_solverId, AT_, &m_changeAdiabBCToTemp);
  }

  /*! \page propertiesFV
    \section multipleGhostCells
    <code>MInt FvBndryCndXD::m_multipleGhostCells </code>\n
    default = <code>0</code>\n \n
    The property is used to trigger the boundary handling for complex boundaries. Basically, a zero value indicates that
    only one ghost cell per cut cell is allowed. For other values, see below (more than one cut surface per boundary
    cell -> multiple ghost cells are used).\n \n possible values are: <ul> <li><code>0</code> (only one ghost cell per
    cut cell -> original formulation (see Hartmann papers))</li> <li><code>1</code> (complex boundaries with multiple
    ghost cells (simple formulation, see Eccomas paper Claudia Guenther) <- do not use this!)</li> <li><code>2</code>
    (complex boundaries with multiple ghost cells (MGC formulation, see Eccomas presentation Claudia Guenther) <- use
    this!)</li>
    </ul>
    Keywords: </i>FINITE_VOLUME, COMPLEX_BOUNDARIES</i>
  */
  m_multipleGhostCells = 0;
  m_multipleGhostCells = Context::getSolverProperty<MInt>("multipleGhostCells", m_solverId, AT_, &m_multipleGhostCells);

  m_ipVariableIterative = 0;
  m_noImagePointIterations = 0;
  m_surfaceGhostCell = 0;
  m_outputIGPoints = 0;

  if(m_multipleGhostCells != 0) {
    /*! \page propertiesFV
      \section ipVariableIterative
      <code>MInt FvBndryCndXD::m_ipVariableIterative </code>\n
      default = <code>0</code>\n \n
      The property is used to control the boundary handling (only valid with \ref multipleGhostCells == 2).
      If zero, the image point variables in multiple ghost cells formulation are not computed iteratively, otherwise,
      they are computed iteratively. The max. number of iterations is given in \ref noImagePointIterations. \n \n
      possible values are:
      <ul>
      <li><code>0</code> (not iterative)</li>
      <li><code>1</code> (iterative)</li>
      </ul>
      Keywords: <i>FINITE_VOLUME, COMPLEX_BOUNDARIES</i>
    */
    m_ipVariableIterative =
        Context::getSolverProperty<MInt>("ipVariableIterative", m_solverId, AT_, &m_ipVariableIterative);
    if(m_ipVariableIterative != 0) {
      /*! \page propertiesFV
        \section noImagePointIterations
        <code>MInt FvBndryCndXD::m_noImagePointIterations </code>\n
        default = <code>10</code>\n \n
        The property is used to control the max. number of iterations if \ref ipVariableIterative is turned on (=1). See
        \ref ipVariableIterative. \n \n possible values are: <ul> <li>any positve integer number</li>
        </ul>
        Keywords: <i>FINITE_VOLUME, COMPLEX_BOUNDARIES</i>
      */
      m_noImagePointIterations = 10;
      m_noImagePointIterations =
          Context::getSolverProperty<MInt>("noImagePointIterations", m_solverId, AT_, &m_noImagePointIterations);
    }

    /*! \page propertiesFV
      \section surfaceGhostCell
      <code>MInt FvBndryCndXD::m_surfaceGhostCell </code>\n
      default = <code>0</code>\n \n
      The property is used to control the location of the ghost cell on the boundary surface or away from it
      (mirroring). Only valid with \ref multipleGhostCells == 2. See also \ref multipleGhostCells.\n \n possible values
      are: <ul> <li><code>0</code> (ghost cell is located as usual (away from the surface))</li> <li><code>1</code>
      (ghost cell is located on the surface)</li>
      </ul>
      Keywords: FINITE_VOLUME, COMPLEX_BOUNDARIES
    */
    m_surfaceGhostCell = Context::getSolverProperty<MInt>("surfaceGhostCell", m_solverId, AT_, &m_surfaceGhostCell);

    /*! \page propertiesFV
      \section outputIGPoints
      <code>MInt FvBndryCndXD::m_surfaceGhostCell </code>\n
      default = <code>0</code>\n \n
      The property is used to trigger if imagePoints and ghostPoints are plotted as .vtk-file. Only valid with \ref
      multipleGhostCells == 2. See also multipleGhostCell.\n \n possible values are: <ul> <li><code>0</code> (off)</li>
      <li><code>1</code> (on)</li>
      </ul>
      Keywords: <i>FINITE_VOLUME, COMPLEX_BOUNDARIES, INPUT_OUTPUT</i>
    */
    m_outputIGPoints = Context::getSolverProperty<MBool>("outputIGPoints", m_solverId, AT_, &m_outputIGPoints);
  }

  /*! \page propertiesFV
    \section maxNoBndryCells
    <code> MInt FvCartesianSolverPar::m_maxNoBndryCells</code>  \n
    default = <code>""</code>\n \n
    Maximum number of boundary cells to be allocated. (Used for the cut-cell computation and the small- and sorted
    boundary-cell allocation) <ul> <li>Any positiv integer</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, ALLOCATION, GENERAL</i>
   */

  m_maxNoBndryCells = Context::getSolverProperty<MInt>("maxNoBndryCells", m_solverId, AT_);

  if(m_multipleGhostCells || m_solver->m_useCreateCutFaceMGC || (m_complexBoundaryMB && m_noLevelSetsUsedForMb == 1))
    mAlloc(m_bndryCells, m_maxNoBndryCells, nDim, m_noSpecies, m_noRansEquations, 3, 0, "m_bndryCells_3",
           AT_); // each boundary cell may have 3 surfaces
  else if(m_complexBoundaryMB)
    mAlloc(m_bndryCells, m_maxNoBndryCells, nDim, m_noSpecies, m_noRansEquations, 12, 0, "m_bndryCells_12",
           AT_); // each boundary cell may have 12 surfaces
  else
    mAlloc(m_bndryCells, m_maxNoBndryCells, nDim, m_noSpecies, m_noRansEquations, 1, 0, "m_bndryCells_1",
           AT_); // each boundary cell may only have one surface!

  // make sure that m_boundarySurfaces is intialized correctly!
  m_bndryCell = m_bndryCells->a;
  solver->m_bndryCells = m_bndryCells; // RUDIE particle code

  mAlloc(m_smallBndryCells, m_maxNoBndryCells, "m_smallBndryCells", -1, AT_);
  mAlloc(m_sortedBndryCells, m_maxNoBndryCells, "m_sortedBndryCells", -1, AT_);
  mAlloc(m_sortedSpongeBndryCells, mMax(1, m_noMaxSpongeBndryCells), "m_sortedSpongeBndryCells", -1, AT_);
  mAlloc(m_boundarySurfaces, nDim * m_maxNoBndryCells * FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces,
         "m_boundarySurfaces", -1, AT_);
  if(m_multipleGhostCells || m_solver->m_useCreateCutFaceMGC) {
    mAlloc(m_bndryNghbrs, m_maxNoBndryCells * m_noDirs * 2, "m_bndryNghbrs", -1, AT_);
  }


  /*! \page propertiesFV
  \section maxNoBndryCndIds
  <code>MInt FvBndryCndXD::m_maxNoBndryCndIds </code>\n
  default = <code>0</code>\n \n
  Maximum number of boundary condition Ids, mainly used to allocate memory related to boundary conditions
  <ul>
  <li> Positive integer value, which is at least as large as the number of different boundary conditions</li>
  </ul>
  Keywords: <i>FINITE_VOLUME, BOUNDARY CONDITION</i>
  */
  m_maxNoBndryCndIds = Context::getSolverProperty<MInt>("maxNoBndryCndIds", m_solverId, AT_);

  m_cellMerging = false;
  /*! \page propertiesFV
    \section cellMerging
    <code>MInt FvBndryCndXD::m_cellMerging </code>\n
    Activates Cell Merging but is used everywhere as if (!m_cellMerging)...

    default = <code> 0 </code>\n
    Keywords: <i>FINITE_VOLUME, BOUNDARY CONDITION</i>
  */
  m_cellMerging = Context::getSolverProperty<MBool>("cellMerging", m_solverId, AT_, &m_cellMerging);

  m_secondOrderRec = true;
  /*! \page propertiesFV
  \section secondOrderRec
  <code>MInt FvBndryCndXD::m_secondOrderRec </code>\n
  default = <code> 1 (true) </code>\n
  Activates the second order reconstruction
  Keywords: <i>FINITE_VOLUME, BOUNDARY CONDITION</i>
*/
  m_secondOrderRec = Context::getSolverProperty<MBool>("secondOrderRec", m_solverId, AT_, &m_secondOrderRec);

  /*! \page propertiesFV
    \section noFluxRedistributionLayers
    <code>MInt FvBndryCndXD::m_noFluxRedistributionLayers </code>\n
    Number of cell layers across which to redistribute the flux imbalance of small cut-cells when noCellMergin = 1.
    default = <code> 2 </code>\n
    Keywords: <i>FINITE_VOLUME, BOUNDARY CONDITION</i>
  */
  m_noFluxRedistributionLayers = 2;
  m_noFluxRedistributionLayers =
      Context::getSolverProperty<MInt>("noFluxRedistributionLayers", m_solverId, AT_, &m_noFluxRedistributionLayers);
  if(noDomains() > 1 && !m_cellMerging && (m_noFluxRedistributionLayers > m_solver->noHaloLayers())) {
    cerr << "Warning: noHalo layers smaller than flux redistribution layers!" << endl;
  }
  m_nearBoundaryWindowCells = nullptr;
  m_nearBoundaryHaloCells = nullptr;
  if(!m_cellMerging) {
    if(m_solver->noNeighborDomains() > 0) {
      mAlloc(m_nearBoundaryWindowCells, m_solver->noNeighborDomains(), "m_nearBoundaryWindowCells", AT_);
      mAlloc(m_nearBoundaryHaloCells, m_solver->noNeighborDomains(), "m_nearBoundaryHaloCells", AT_);
    }
  }

  // reconstruction
  mAlloc(m_reconstructionNghbrs, m_maxNoBndryCells, m_cells.noRecNghbrs(), "m_reconstructionNghbrs", -1, AT_);
  mAlloc(m_reconstructionConstants, m_maxNoBndryCells, nDim * m_cells.noRecNghbrs(), "m_reconstructionConstants_BND",
         F0, AT_);

  // initialize
  m_noBndryCndIds = 0;
  m_noCutOffBndryCndIds = 0;

  bndryCndHandlerVariables = 0;
  bndryCndHandlerCutOffVariables = 0;
  bndryCndHandlerCutOffInit = 0;
  bndryCndHandlerSpongeVariables = 0;
  //  nonReflectingBoundaryCondition = 0;
  nonReflectingCutOffBoundaryCondition = 0;
  nonReflectingBoundaryConditionAfterTreatmentCutOff = 0;
  bndryCndHandlerSlopesInviscid = 0;
  bndryCndHandlerCutOffSlopesInviscid = 0;
  bndryViscousSlopes = 0;
  bndryCutOffViscousSlopes = 0;
  bndryCndHandlerNeumann = 0;
  bndryCndHandlerInit = 0;

  /*
    m_bndryCndIds = new MInt[ m_maxNoBndryCndIds ];
    m_cutOffBndryCndIds = new MInt[ m_maxNoBndryCndIds ];
    for(MInt i = 0; i < m_maxNoBndryCndIds; i++){
      m_bndryCndIds[ i ] = 0;
      m_cutOffBndryCndIds[ i ]  = 0;
    }
    m_bndryCndCells = new MInt[ m_maxNoBndryCndIds+1 ];
    m_spongeBndryCells = new MInt[ m_maxNoBndryCndIds+1 ];
    for(MInt i = 0; i < m_maxNoBndryCndIds+1; i++){
      m_bndryCndCells[ i ] = 0;
      m_spongeBndryCells[ i ] = 0;
    }
  */
  mAlloc(m_bndryCndIds, m_maxNoBndryCndIds, "m_bndryCndIds", 0, AT_);
  mAlloc(m_cutOffBndryCndIds, m_maxNoBndryCndIds, "m_cutOffBndryCndIds", 0, AT_);
  mAlloc(m_bndryCndCells, m_maxNoBndryCndIds + 1, "m_bndryCndCells", 0, AT_);
  mAlloc(m_spongeBndryCells, m_maxNoBndryCndIds + 1, "m_spongeBndryCells", 0, AT_);

  /*! \page propertiesFV
   \section jetInletTurbulence
   <code> MBool FvBndryCnd::m_jetInletTurbulence </code>  \n
   default = <code>false</code>\n \n
   Activates jet inlet turbulence for random-eddy inflow boundary conditions, which
   introduces velocity fluctuations at the boundary.
   Keywords: <i>FINITE_VOLUME, BOUNDARY CONDITION</i>
  */
  m_jetInletTurbulence = false;
  m_jetInletTurbulence =
      Context::getSolverProperty<MBool>("jetInletTurbulence", m_solverId, AT_, &m_jetInletTurbulence);

  m_cutCandidates.clear();
  m_geometryIntersection = new GeometryIntersection<nDim>(&m_solver->grid(), m_solver->m_geometry);

  printAllocatedMemory(oldAllocatedBytes, "FvBndryCndXD", solver->globalMpiComm());
}


template <MInt nDim, class SysEqn>
FvBndryCndXD<nDim, SysEqn>::~FvBndryCndXD() {
  TRACE();

  // Clean up allocated memory
  mDeallocate(m_bndryCells);
  mDeallocate(m_smallBndryCells);
  mDeallocate(m_sortedBndryCells);
  mDeallocate(m_sortedSpongeBndryCells);
  mDeallocate(m_boundarySurfaces);
  mDeallocate(m_bndryNghbrs);
  mDeallocate(m_nearBoundaryWindowCells);
  mDeallocate(m_nearBoundaryHaloCells);
  mDeallocate(m_reconstructionNghbrs);
  mDeallocate(m_reconstructionConstants);
  mDeallocate(m_bndryCndIds);
  mDeallocate(m_cutOffBndryCndIds);
  mDeallocate(m_bndryCndCells);
  mDeallocate(m_spongeBndryCells);
}


//----------------------------------------------------------------------------


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::createSortedBndryCellList() {
  TRACE();

  MInt bc;
  MInt size;
  MInt noBndryCells = m_bndryCells->size();
  MBool append = false;
  //---

  m_bndryCndCells[m_noBndryCndIds] = noBndryCells;
  m_sortedBndryCells->setSize(0);
  size = 0;
  for(MInt bcId = 0; bcId < m_noBndryCndIds; bcId++) {
    m_bndryCndCells[bcId] = size;
    bc = m_bndryCndIds[bcId];
    for(MInt id = 0; id < noBndryCells; id++) {
      append = false;
      for(MInt srfc = 0; srfc < m_bndryCells->a[id].m_noSrfcs; srfc++) {
        if(m_bndryCells->a[id].m_srfcs[srfc]->m_bndryCndId == bc) {
          append = true;
          break;
        }
      }
      if(append) {
        m_sortedBndryCells->append();
        m_sortedBndryCells->a[size] = id;
        size++;
      }
      //    //Debug
      //    MInt cellId = m_bndryCells->a[ m_sortedBndryCells->a[ bcId ] ].m_cellId;
      //    std::cout << "createSortedBndryCellList CellTemp: " << m_solver->a_pvariable(cellId,PV->P) <<
      //    std::endl;
    }
  }
  m_bndryCndCells[m_noBndryCndIds] = size;
}


//-----------------------------------------------------------------------------


// resets the cell center coordinates of boundary cells to the grid cell position
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::correctCellCoordinates() {
  TRACE();

  MInt noCells = m_bndryCells->size();
  //---

  for(MInt id = 0; id < noCells; id++) {
    for(MInt i = 0; i < nDim; i++) {
      m_solver->a_coordinate(m_bndryCells->a[id].m_cellId, i) += m_bndryCells->a[id].m_coordinates[i];
    }
  }
  ASSERT(!m_cellCoordinatesCorrected, "Irregular sequence of cell-coordinate correction!");
  m_cellCoordinatesCorrected = true;
}


//-----------------------------------------------------------------------------


// resets the cell center coordinates of boundary cells to the boundary cell position
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::recorrectCellCoordinates() {
  TRACE();

  MInt smallCell = 0;
  MInt masterId;
  MInt noCells = m_bndryCells->size();
  MInt noSmallCells = m_smallBndryCells->size();
  //---

  for(MInt id = 0; id < noCells; id++) {
    for(MInt i = 0; i < nDim; i++) {
      m_solver->a_coordinate(m_bndryCells->a[id].m_cellId, i) -= m_bndryCells->a[id].m_coordinates[i];
    }
  }
  // recorrect all coordinates of internal master cells
  for(MInt smallId = 0; smallId < noSmallCells; smallId++) {
    smallCell = m_smallBndryCells->a[smallId];
    masterId = m_bndryCells->a[smallCell].m_linkedCellId;
    if(m_solver->a_bndryId(masterId) == -1) {
      for(MInt i = 0; i < nDim; i++) {
        m_solver->a_coordinate(masterId, i) = m_bndryCells->a[smallCell].m_masterCoordinates[i];
      }
    }
  }
  ASSERT(m_cellCoordinatesCorrected, "Irregular sequence of cell-coordinate correction!");
  m_cellCoordinatesCorrected = false;
}

// resets the cell center coordinates of boundary cells to the grid cell position
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::rerecorrectCellCoordinates() {
  TRACE();

  const MInt noCells = m_bndryCells->size();
  const MInt noSmallCells = m_smallBndryCells->size();
  //---

  for(MInt id = 0; id < noCells; id++) {
    for(MInt i = 0; i < nDim; i++) {
      m_solver->a_coordinate(m_bndryCells->a[id].m_cellId, i) += m_bndryCells->a[id].m_coordinates[i];
    }
  }
  // rerecorrect all coordinates of internal master cells
  for(MInt smallId = 0; smallId < noSmallCells; smallId++) {
    const MInt smallCell = m_smallBndryCells->a[smallId];
    const MInt smallCellId = m_bndryCells->a[smallCell].m_cellId;
    const MInt masterId = m_bndryCells->a[smallCell].m_linkedCellId;
    if(m_solver->a_bndryId(masterId) == -1) {
      for(MInt i = 0; i < nDim; i++) {
        m_solver->a_coordinate(masterId, i) = m_solver->a_coordinate(smallCellId, i);
      }
    }
  }
  ASSERT(!m_cellCoordinatesCorrected, "Irregular sequence of cell-coordinate correction!");
  m_cellCoordinatesCorrected = true;
}


// ------------------------------------------------------------------------


/**
 * \brief Creates a mapping (boundary cell id) -> (cell id) in m_bndryCellIds.
 *
 * \author Daniel Hartmann
 * \date May 2008
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::computeReverseMap() {
  TRACE();

  // initialize all cells as internal cells
  for(MInt id = 0; id < m_solver->a_noCells(); id++) {
    m_solver->a_bndryId(id) = -1;
  }

  // correct the entries of boundary cells
  for(MInt bndryId = 0; bndryId < m_bndryCells->size(); bndryId++) {
    m_solver->a_bndryId(m_bndryCells->a[bndryId].m_cellId) = bndryId;
  }
}


//-----------------------------------------------------------------------------------------


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::computeGhostCells() {
  TRACE();
  m_solver->m_associatedInternalCells.clear();
  m_solver->m_totalnoghostcells = 0;
  //---

  for(MInt bndryId = 0; bndryId < m_bndryCells->size(); bndryId++) {
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      // append a cell to the cell-collectors only!
      m_cells.append();
      m_solver->m_totalnoghostcells++;
      const MInt ghostCellId = m_solver->a_noCells() - 1;
      m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId = ghostCellId;

#ifdef mirroredGhostCell
      // calculate the global coordinates of the ghost point as a mirror image of
      // the center of gravity of the concerning boundary cell to the body surface
      // compute the connection vector between the center of the gravity of the
      // boundary cell and the center of the body surface
      for(MInt i = 0; i < nDim; i++) {
        connectionVctr[i] = m_solver->a_coordinate(m_bndryCells->a[bndryId].m_cellId, i)
                            - m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i];
      }

      // to compute the distance, project the connection vector into the normal
      // vector by using a scalar product
      distance = F0;
      for(MInt i = 0; i < nDim; i++) {
        distance += connectionVctr[i] * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
      }
      distance = fabs(distance);

      // the ghost coordinates are found if the double distance is added to the
      // center of gravity of the boundary cell in negative direction of the
      // normal vector of the body surface
      for(MInt i = 0; i < nDim; i++) {
        m_solver->a_coordinate(ghostCellId, i) =
            m_solver->a_coordinate(m_bndryCells->a[bndryId].m_cellId, i)
            - 2.0 * distance * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
      }
#else
      // compute the ghost cell coordinates (new version)
      for(MInt i = 0; i < nDim; i++) {
        m_solver->a_coordinate(ghostCellId, i) = F2 * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i]
                                                 - m_solver->a_coordinate(m_bndryCells->a[bndryId].m_cellId, i);
      }
#endif

      if(!m_cellMerging) {
        const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
        const MFloat cellHalfLength = F1B2 * m_solver->c_cellLengthAtCell(cellId);
        MFloat dn = F0;
        for(MInt i = 0; i < nDim; i++) {
          dn += m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i]
                * (m_solver->a_coordinate(cellId, i) - m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i]);
        }
        for(MInt i = 0; i < nDim; i++) {
          // m_solver->a_coordinate( ghostCellId ,  i ) = m_solver->a_coordinate( cellId ,  i ) - ( dn + cellHalfLength
          // ) * m_bndryCells->a[ bndryId ].m_srfcs[srfc]->m_normalVector[ i ]; use mirrored coords if dn > dx/2:
          m_solver->a_coordinate(ghostCellId, i) =
              m_solver->a_coordinate(cellId, i)
              - mMax(F2 * dn, dn + cellHalfLength) * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
        }
      }

      m_solver->a_noReconstructionNeighbors(ghostCellId) = 0;
      m_solver->a_level(ghostCellId) = m_solver->a_level(m_bndryCells->a[bndryId].m_cellId);

      // grid-cell properties:
      /*    m_solver->c_globalId(ghostCellId) = -1;

          // set all possible child ids of the newly created cell to -1
          for( MInt ccId = 0; ccId < IPOW2(nDim); ccId++)
            m_solver->c_childId( ghostCellId ,  ccId ) = -1;

          m_solver->c_parentId(ghostCellId) = -1;
      */
      // set pointer to cellId
      m_solver->m_associatedInternalCells.push_back(m_bndryCells->a[bndryId].m_cellId);

      // mark a ghost cell in m_bndryCellIds and the cell collector
      m_solver->a_bndryId(ghostCellId) = -2;
      m_solver->a_isBndryGhostCell(ghostCellId) = true;

      ASSERT(m_solver->a_level(ghostCellId) == m_solver->a_level(m_solver->getAssociatedInternalCell(ghostCellId)), "");
    }
  }
}


//-----------------------------------------------------------------------------------------


/** \brief Computes one ghost cell for each boundary surface
 *
 *  Works with multiple ghost cells for complex geometries.
 *  Ghost cells are located in normal direction to the surface from the
 *  surface centroids.
 *  Method also provides the image point locations. If necessary, the ghost
 *  and image points can be written in two separate .vtk files
 *
 *  \author Claudia Guenther, April 2010
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::computeGhostCellsMGC() {
  TRACE();

  MFloat dist = F0;
  ofstream ofl;
  ofstream ofl2;
  if(m_outputIGPoints) {
    const MChar* filename = "imagePoints_";
    stringstream filename2;
    filename2 << filename << domainId() << ".vtk";
    ofl.open((filename2.str()).c_str(), ofstream::trunc);
    const MChar* filename3 = "ghostPoints";
    stringstream filename4;
    filename4 << filename3 << domainId() << ".vtk";
    ofl2.open((filename4.str()).c_str(), ofstream::trunc);
  }

  MInt noImagePoints = 0;
  //---

  m_solver->m_associatedInternalCells.clear();
  m_solver->m_totalnoghostcells = 0;

  for(MInt bndryId = 0; bndryId < m_bndryCells->size(); bndryId++) {
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      // append a cell to the fv-cell-collectors
      m_cells.append();
      m_solver->m_totalnoghostcells++;

      // initialize m_bndryCellIds
      m_solver->a_bndryId(m_solver->a_noCells() - 1) = -2;

      const MInt ghostCellId = m_solver->a_noCells() - 1;

      m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId = ghostCellId;


      if(m_solver->a_hasProperty(m_bndryCells->a[bndryId].m_cellId, SolverCell::IsOnCurrentMGLevel)) {
        //         if(m_solver->a_hasProperty(m_bndryCells->a[ bndryId ].m_cellId, SolverCell::IsActive))
        MInt gridcellId = m_bndryCells->a[bndryId].m_cellId;
        if(m_solver->a_hasProperty(gridcellId, SolverCell::IsSplitClone)) {
          gridcellId = m_solver->m_splitChildToSplitCell.find(gridcellId)->second;
        }
        if(m_solver->c_noChildren(gridcellId) == 0) noImagePoints++;
      }

      // compute geometric data of the ghost cell

      // compute ImagePoint coordinates
      dist = F0;
      for(MInt i = 0; i < nDim; i++) {
        m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageCoordinates[i] =
            m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i];
        m_solver->a_coordinate(ghostCellId, i) = m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i];

        dist += m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i]
                * (m_solver->a_coordinate(m_bndryCells->a[bndryId].m_cellId, i)
                   - m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i]);
      }
      dist = fabs(dist);
      if(m_surfaceGhostCell != 0) {
        for(MInt i = 0; i < nDim; i++) {
          m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageCoordinates[i] +=
              m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i] * dist;
        }
      } else {
        for(MInt i = 0; i < nDim; i++) {
          m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageCoordinates[i] +=
              m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i] * dist;
          m_solver->a_coordinate(ghostCellId, i) -= m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i] * dist;
        }
      }

      // init Ghost cell properties
      m_solver->a_noReconstructionNeighbors(ghostCellId) = 0;
      m_solver->a_level(ghostCellId) = m_solver->a_level(m_bndryCells->a[bndryId].m_cellId);

      // set pointer to cellId
      m_solver->m_associatedInternalCells.push_back(m_bndryCells->a[bndryId].m_cellId);
      m_solver->a_isBndryGhostCell(ghostCellId) = true;
    }
  }

  // if required write out image and ghost points to a .vtk data file
  if(m_outputIGPoints) {
    if(ofl && ofl2) {
      ofl.setf(ios::fixed);
      ofl.precision(7);
      ofl2.setf(ios::fixed);
      ofl2.precision(7);

      ofl << "# vtk DataFile Version 3.0" << endl
          << "MAIAD imagePoints file" << endl
          << "ASCII" << endl
          << "DATASET POLYDATA" << endl
          << "POINTS " << noImagePoints << " float" << endl;

      ofl2 << "# vtk DataFile Version 3.0" << endl
           << "MAIAD ghostPoints file" << endl
           << "ASCII" << endl
           << "DATASET POLYDATA" << endl
           << "POINTS " << noImagePoints << " float" << endl;

      for(MInt bndryId = 0; bndryId < m_bndryCells->size(); bndryId++) {
        if(!m_solver->a_hasProperty(m_bndryCells->a[bndryId].m_cellId, SolverCell::IsOnCurrentMGLevel)) continue;
        //    if(!m_solver->a_hasProperty(m_bndryCells->a[ bndryId ].m_cellId, SolverCell::IsActive))
        //      continue;
        if(m_solver->c_noChildren(m_bndryCells->a[bndryId].m_cellId) > 0) continue;
        for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
          const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
          for(MInt i = 0; i < 3; i++) {
            ofl << m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageCoordinates[i] << " ";
            ofl2 << m_solver->a_coordinate(ghostCellId, i) << " ";
          }
          ofl << endl;
          ofl2 << endl;
        }
      }

      ofl << "VERTICES " << noImagePoints << " " << noImagePoints * 2 << endl;
      ofl2 << "VERTICES " << noImagePoints << " " << noImagePoints * 2 << endl;
      for(MInt i = 0; i < noImagePoints; i++) {
        ofl << "1 " << i << endl;
        ofl2 << "1 " << i << endl;
      }
    }

    ofl.close();
    ofl2.close();
  }
}


//-----------------------------------------------------------------------------------------


/*template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim,SysEqn>::correctGhostCells()
{
  TRACE();

  MInt cellId,ghostCellId;
  MInt direction,spaceId=0,sideId;
  const MInt noCells = m_bndryCells->size();
  MFloat dist;
  //---
  // Warning: produces slightly non symmetric field
  for( MInt bc=0; bc<noCells; bc++ ) {
    if( m_bndryCells->a[ bc ].m_srfcs[0]->m_bndryCndId == 3904 ) {
      cellId = m_bndryCells->a[ bc ].m_cellId;
      for( MInt i=0; i<nDim; i++ ) {
  m_solver->a_coordinate( cellId ,  i ) -= m_bndryCells->a[ bc ].m_coordinates[ i ];
  m_bndryCells->a[ bc ].m_coordinates[ i ] = F0;
      }
      dist = m_solver->c_cellLengthAtCell(cellId);
      ghostCellId = m_bndryCells->a[ bc ].m_srfcVariables[0]->m_ghostCellId;
      for( MInt d=0; d<m_noDirs; d++ ) {
  if( m_solver->a_hasNeighbor( cellId , d) > 0 )
    continue;
  direction = d;
  spaceId = direction / 2;
  sideId = direction % 2;
  dist *= (MFloat)( 2*sideId - 1 );
  break;
      }
      for( MInt i=0; i<nDim; i++ )
  if( i != spaceId )
    m_solver->a_coordinate( ghostCellId ,  i ) = m_solver->a_coordinate( cellId ,  i );
  else
    m_solver->a_coordinate( ghostCellId ,  i ) = m_solver->a_coordinate( cellId ,  i ) + dist;
    }
  }
}*/


//-----------------------------------------------------------------------------------------


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::computeMirrorCoordinates(MInt bndryId, MFloat* x) {
  //  TRACE();

  MFloat distance = 0;
  //---

  for(MInt i = 0; i < nDim; i++) {
    x[i] = m_solver->a_coordinate(m_bndryCells->a[bndryId].m_cellId, i)
           - m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[i];
  }

  for(MInt i = 0; i < nDim; i++) {
    distance += x[i] * m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i];
  }
  distance = fabs(distance);
  for(MInt i = 0; i < nDim; i++) {
    x[i] = m_solver->a_coordinate(m_bndryCells->a[bndryId].m_cellId, i)
           - F2 * distance * m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i];
  }
}

//-----------------------------------------------------------------------------------------


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::computeMirrorCoordinates(MInt bndryId, MFloat* x, MInt srfcId) {
  //  TRACE();

  MFloat distance = 0;
  //---

  for(MInt i = 0; i < nDim; i++) {
    x[i] = m_solver->a_coordinate(m_bndryCells->a[bndryId].m_cellId, i)
           - m_bndryCells->a[bndryId].m_srfcs[srfcId]->m_coordinates[i];
  }

  for(MInt i = 0; i < nDim; i++) {
    distance += x[i] * m_bndryCells->a[bndryId].m_srfcs[srfcId]->m_normalVector[i];
  }
  distance = fabs(distance);
  for(MInt i = 0; i < nDim; i++) {
    x[i] = m_solver->a_coordinate(m_bndryCells->a[bndryId].m_cellId, i)
           - F2 * distance * m_bndryCells->a[bndryId].m_srfcs[srfcId]->m_normalVector[i];
  }
}


//-----------------------------------------------------------------------------------------


/** \brief adds a surface for the ghost-boundary cell intersections
 *
 *   \author Daniel Hartmann, January 10, 2007
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::addBoundarySurfaces() {
  TRACE();

  MBool cellOk = false;
  MInt cellId, ghostCellId;
  MInt noCells = m_bndryCells->size();
  MInt srfcId = 0;
  MFloat epsilon = pow(10.0, -13.0);
  //---

  m_noBoundarySurfaces = 0;

  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    cellOk = false;

    for(MInt srfc = 0; srfc < FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces; srfc++) {
      for(MInt i = 0; i < nDim; i++)
        m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_srfcId[i] = -1;
    }

    // do not consider grid halo cells; only those which have a non-halo cell as master
    // do not consider small cells with a boundary cell as master
    if(m_solver->a_isHalo(m_bndryCells->a[bndryId].m_cellId)) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) {
        if(m_solver->a_bndryId(m_bndryCells->a[bndryId].m_linkedCellId) == -1
           && !m_solver->a_isHalo(m_bndryCells->a[bndryId].m_linkedCellId))
          cellOk = true;
      }
    } else {
      if(m_bndryCells->a[bndryId].m_linkedCellId == -1) {
        cellOk = true;
      } else {
        if(m_solver->a_bndryId(m_bndryCells->a[bndryId].m_linkedCellId) == -1) {
          cellOk = true;
        }
      }
    }

    if(cellOk) {
      ASSERT(m_bndryCells->a[bndryId].m_noSrfcs == 1, "noSrfc: " << m_bndryCells->a[bndryId].m_noSrfcs
                                                                 << " bndryId: " << bndryId << " noCutPoints "
                                                                 << m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints);
      cellId = m_bndryCells->a[bndryId].m_cellId;
      ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;
      if((m_solver->c_noChildren(cellId) == 0 && m_solver->a_level(cellId) <= m_solver->maxRefinementLevel())
         || (m_solver->c_noChildren(cellId) > 0 && m_solver->a_level(cellId) == m_solver->maxRefinementLevel())) {
        // create one surface per space direction
        for(MInt i = 0; i < nDim; i++) {
          // if the surface is inclined, replace it by its projections into the
          // Cartesian frame of reference
          if(fabs(m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i]) > epsilon) {
            m_surfaces.append();
            srfcId = m_solver->a_noSurfaces() - 1;

            // add the boundary surface
            m_boundarySurfaces[m_noBoundarySurfaces] = srfcId;
            m_noBoundarySurfaces++;

            // set the boundary condition
            m_solver->a_surfaceBndryCndId(srfcId) = m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;

            // the coordinates of the new surface are shifted...
            for(MInt j = 0; j < nDim; j++) {
              m_solver->a_surfaceCoordinate(srfcId, j) = m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[j];
            }

            // projection to compute the area of the surface
            m_solver->a_surfaceArea(srfcId) = m_bndryCells->a[bndryId].m_srfcs[0]->m_area
                                              * fabs(m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i]);

            // set the surface orientation
            m_solver->a_surfaceOrientation(srfcId) = i;

            ASSERT(ghostCellId > -1, "");

            // set the surface neigbors
            if(m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i] > F0) {
              m_solver->a_surfaceNghbrCellId(srfcId, 0) = ghostCellId;
              m_solver->a_surfaceNghbrCellId(srfcId, 1) = cellId;
            } else {
              m_solver->a_surfaceNghbrCellId(srfcId, 1) = ghostCellId;
              m_solver->a_surfaceNghbrCellId(srfcId, 0) = cellId;
            }

            // set the pointer from the body surface to the cartesian surfaces
            m_bndryCells->a[bndryId].m_srfcVariables[0]->m_srfcId[i] = srfcId;
          }
        }
      }
    }
  }
}


//-----------------------------------------------------------------------------------------


/** \brief adds a surface for the ghost-boundary cell intersections
 *
 * version is able to work with multiple boundary surfaces per cell
 * it adds one surface for each boundary surface
 *
 *   \author Claudia Guenther, April 2009
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::addBoundarySurfacesMGC() {
  TRACE();

  MBool cellOk;
  MInt cellId, ghostCellId;
  MInt noCells = m_bndryCells->size();
  MInt srfcId = 0;
  MFloat epsilon = pow(10.0, -20.0);
  //---

  m_noBoundarySurfaces = 0;

  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    cellOk = false;

    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      for(MInt i = 0; i < nDim; i++) {
        m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_srfcId[i] = -1;
      }
    }

    if(m_solver->a_hasProperty(m_bndryCells->a[bndryId].m_cellId, SolverCell::IsInvalid)) continue;

    // do not consider grid halo cells; only those which have a non-halo cell as master
    if(m_solver->a_isHalo(m_bndryCells->a[bndryId].m_cellId)) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) {
        if(!m_solver->a_isHalo(m_bndryCells->a[bndryId].m_linkedCellId)) cellOk = true;
      }
    } else {
      cellOk = true;
    }

    if(cellOk) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        cellId = m_bndryCells->a[bndryId].m_cellId;
        ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
        MInt gridcellId = cellId;
        if(m_solver->a_hasProperty(cellId, SolverCell::IsSplitClone)) {
          gridcellId = m_solver->m_splitChildToSplitCell.find(cellId)->second;
        }
        if((m_solver->c_noChildren(gridcellId) == 0 && m_solver->a_level(cellId) <= m_solver->maxRefinementLevel())
           || (m_solver->c_noChildren(gridcellId) > 0 && m_solver->a_level(cellId) == m_solver->maxRefinementLevel())) {
          // create one surface per space direction
          for(MInt i = 0; i < nDim; i++) {
            // if the surface is inclined, replace it by its projections into the
            // Cartesian frame of reference
            if(fabs(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i]) > epsilon) {
              m_surfaces.append();
              srfcId = m_solver->a_noSurfaces() - 1;

              // add the boundary surface
              m_boundarySurfaces[m_noBoundarySurfaces] = srfcId;
              m_noBoundarySurfaces++;

              // set the boundary condition
              m_solver->a_surfaceBndryCndId(srfcId) = m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId;

              // the coordinates of the new surface are shifted...
              for(MInt j = 0; j < nDim; j++) {
                m_solver->a_surfaceCoordinate(srfcId, j) = m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[j];
              }

              // projection to compute the area of the surface
              m_solver->a_surfaceArea(srfcId) = m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area
                                                * fabs(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i]);

              // set the surface orientation
              m_solver->a_surfaceOrientation(srfcId) = i;

              // set the surface neigbors
              if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i] > F0) {
                m_solver->a_surfaceNghbrCellId(srfcId, 0) = ghostCellId;
                m_solver->a_surfaceNghbrCellId(srfcId, 1) = cellId;
              } else {
                m_solver->a_surfaceNghbrCellId(srfcId, 1) = ghostCellId;
                m_solver->a_surfaceNghbrCellId(srfcId, 0) = cellId;
              }

              // set the pointer from the body surface to the cartesian surfaces
              m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_srfcId[i] = srfcId;
            }
          }
        }
      }
    }
  }
}


//-----------------------------------------------------------------------------------------

/** \brief corrects the left and right variables values on the boundary surface
 *
 *  values are set to ghost cell and image value, respectively
 *  (in comment: values are set to the arithmetic mean of ghost cell and image value)
 *
 *  version is able to work with multiple ghost cells. Used if ghost cells are
 *  located normal to boundary surface from surface centroid and ghost cells are
 *  not positioned directly on the surface.
 *
 *   \author Claudia Guenther, Mai 2010
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::correctBoundarySurfaceVariablesMGC() {
  TRACE();

  const MInt noBndrySurfaces = m_noBoundarySurfaces;
  const MInt noVars = CV->noVariables;
  const MInt surfaceVarMemory = m_solver->m_surfaceVarMemory;
  MFloat* surfaceVar = (MFloat*)(&(m_solver->a_surfaceVariable(0, 0, 0)));
  MInt nghbr0, nghbr1, bndryId, ghostSurf;
  //---

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt bs = 0; bs < noBndrySurfaces; bs++) {
    nghbr0 = m_solver->a_surfaceNghbrCellId(m_boundarySurfaces[bs], 0);
    nghbr1 = m_solver->a_surfaceNghbrCellId(m_boundarySurfaces[bs], 1);
    if(m_solver->a_isBndryGhostCell(nghbr0)) {
      bndryId = m_solver->a_bndryId(m_solver->getAssociatedInternalCell(nghbr0));
      ghostSurf = 0;
      for(MInt srfcId = 0; srfcId < m_bndryCells->a[bndryId].m_noSrfcs; srfcId++) {
        if(m_bndryCells->a[bndryId].m_srfcVariables[srfcId]->m_ghostCellId == nghbr0) {
          ghostSurf = srfcId;
          break;
        }
      }
      // set left an right value to ghost cell value and image value, respectively
      //       for( MInt var = 0; var < noVars; var++ ) {
      //        surfaceVar[ m_boundarySurfaces[bs]*surfaceVarMemory + var ] =
      //            m_solver->a_pvariable( nghbr0 ,  var );
      //        surfaceVar[ m_boundarySurfaces[bs]*surfaceVarMemory + noVars + var ] =
      //            m_bndryCells->a[bndryId].m_srfcVariables[ghostSurf]->m_imageVariables[var];
      //      }
      // set both left and right value to mean of ghost cell value and image value
      for(MInt var = 0; var < noVars; var++) {
        surfaceVar[m_boundarySurfaces[bs] * surfaceVarMemory + var] =
            F1B2
            * (m_solver->a_pvariable(nghbr0, var)
               + m_bndryCells->a[bndryId].m_srfcVariables[ghostSurf]->m_imageVariables[var]);
        surfaceVar[m_boundarySurfaces[bs] * surfaceVarMemory + noVars + var] =
            surfaceVar[m_boundarySurfaces[bs] * surfaceVarMemory + var];
      }
    } else if(m_solver->a_isBndryGhostCell(nghbr1)) {
      bndryId = m_solver->a_bndryId(m_solver->getAssociatedInternalCell(nghbr1));
      ghostSurf = 0;
      for(MInt srfcId = 0; srfcId < m_bndryCells->a[bndryId].m_noSrfcs; srfcId++) {
        if(m_bndryCells->a[bndryId].m_srfcVariables[srfcId]->m_ghostCellId == nghbr1) {
          ghostSurf = srfcId;
          break;
        }
      }
      // set right an left value to ghost cell value and image value, respectively
      //       for( MInt var = 0; var < noVars; var++ ) {
      //        surfaceVar[ m_boundarySurfaces[bs]*surfaceVarMemory + var ] =
      //            m_solver->a_pvariable(  nghbr1 ,  var );
      //        surfaceVar[ m_boundarySurfaces[bs]*surfaceVarMemory + noVars + var ] =
      //            m_bndryCells->a[bndryId].m_srfcVariables[ghostSurf]->m_imageVariables[var];
      //      }
      // set both left and right value to mean of ghost cell value and image value
      for(MInt var = 0; var < noVars; var++) {
        surfaceVar[m_boundarySurfaces[bs] * surfaceVarMemory + var] =
            F1B2
            * (m_solver->a_pvariable(nghbr1, var)
               + m_bndryCells->a[bndryId].m_srfcVariables[ghostSurf]->m_imageVariables[var]);
        surfaceVar[m_boundarySurfaces[bs] * surfaceVarMemory + noVars + var] =
            surfaceVar[m_boundarySurfaces[bs] * surfaceVarMemory + var];
      }
    } else
      cerr << "[ " << domainId() << " ]"
           << " Error in FvBndryCndXD::correctBoundarySurfaceVariablesMGC; This case should not occur! "
           << " surface " << m_boundarySurfaces[bs] << " has no ghost cell neighbor! "
           << "neighbors: " << nghbr0 << " " << nghbr1 << endl;
  }
}

//-----------------------------------------------------------------------------------------

/** \brief corrects the left and right variables values on the boundary surface
 *
 *  values are set equal to the ghost cell value
 *
 *  version is able to work with multiple ghost cells. Used if ghost cells are
 *  located normal to boundary surface from surface centroid and ghost cells are
 *  positioned directly on the surface.
 *
 *   \author Claudia Guenther, Mai 2010
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::correctBoundarySurfaceVariablesMGCSurface() {
  TRACE();

  const MInt noBndrySurfaces = m_noBoundarySurfaces;
  const MInt noVars = CV->noVariables;
  const MInt surfaceVarMemory = m_solver->m_surfaceVarMemory;
  MFloat* surfaceVar = (MFloat*)(&(m_solver->a_surfaceVariable(0, 0, 0)));
  MInt nghbr0, nghbr1;
  //---

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt bs = 0; bs < noBndrySurfaces; bs++) {
    nghbr0 = m_solver->a_surfaceNghbrCellId(m_boundarySurfaces[bs], 0);
    nghbr1 = m_solver->a_surfaceNghbrCellId(m_boundarySurfaces[bs], 1);
    if(m_solver->a_isBndryGhostCell(nghbr0)) {
      for(MInt var = 0; var < noVars; var++) {
        surfaceVar[m_boundarySurfaces[bs] * surfaceVarMemory + var] = m_solver->a_pvariable(nghbr0, var);
        surfaceVar[m_boundarySurfaces[bs] * surfaceVarMemory + noVars + var] = m_solver->a_pvariable(nghbr0, var);
      }
    } else if(m_solver->a_isBndryGhostCell(nghbr1)) {
      for(MInt var = 0; var < noVars; var++) {
        surfaceVar[m_boundarySurfaces[bs] * surfaceVarMemory + var] = m_solver->a_pvariable(nghbr1, var);
        surfaceVar[m_boundarySurfaces[bs] * surfaceVarMemory + noVars + var] = m_solver->a_pvariable(nghbr1, var);
      }
    } else
      cerr << "[ " << domainId() << " ]"
           << " Error in FvBndryCndXD::correctBoundarySurfaceVariablesMGCSurface; This case should not occur! "
           << " surface " << m_boundarySurfaces[bs] << " has no ghost cell neighbor! "
           << "neighbors: " << nghbr0 << " " << nghbr1 << endl;
  }
}


//-----------------------------------------------------------------------------


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::applyNeumannBoundaryCondition() {
  TRACE();

  // loop over all different boundary conditions
  for(MInt bcId = 0; bcId < m_noBndryCndIds; bcId++) {
    (this->*bndryCndHandlerNeumann[bcId])(bcId);
  }

  copySlopesToSmallCells();

  if(!m_cellMerging) storeBoundaryVariables();
}


//-----------------------------------------------------------------------------
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::storeBoundaryVariables() {
  TRACE();

  const MInt noBndryCells = m_bndryCells->size();
  const MInt noPVars = PV->noVariables;
#ifndef NDEBUG
  MInt nanCounter = 0;
  const MInt nanCounterMax = 5 * noPVars;
#endif

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
        for(MInt v = 0; v < noPVars; v++) {
          m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[v] =
              F1B2 * (m_solver->a_pvariable(ghostCellId, v) + m_solver->a_pvariable(cellId, v));
#ifndef NDEBUG
          if(std::isnan(m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[v]) && nanCounter < nanCounterMax) {
            cerr << domainId() << ": nan detected in boundary surface var " << v << " " << cellId << " ("
                 << m_solver->c_globalId(cellId) << ") " << ghostCellId << " halo:" << m_solver->a_isHalo(cellId)
                 << " (" << m_solver->a_hasProperty(cellId, SolverCell::IsNotGradient) << ")"
                 << " /vars " << m_solver->a_pvariable(ghostCellId, v) << " " << m_solver->a_pvariable(cellId, v) << " "
                 << m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[v] << " ("
                 << &m_solver->a_pvariable(cellId, v) << ")"
                 << " /coords " << m_solver->a_coordinate(cellId, 0) << " " << m_solver->a_coordinate(cellId, 1) << " "
                 << m_solver->a_coordinate(cellId, 2) << " /bndCnd " << m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId
                 << " /lvl " << m_solver->a_level(cellId) << " /halo " << m_solver->a_isHalo(cellId) << endl;
            nanCounter++;
            if(nanCounter == nanCounterMax) {
              cerr << domainId() << ": nan detected in boundary surface ... skipping further output" << std::endl;
            }
          }
#endif
        }

        ASSERT((approx(sysEqn().temperature_ES(m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->RHO],
                                               m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->P]),
                       m_Bc3011WallTemperature, F5 * MFloatEps))
                   || (m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId != 3011 || isDetChem<SysEqn>),
               "isothermal wall 3011 fail");
      }
#ifdef _OPENMP
#pragma omp critical
      {
#endif
        MFloatScratchSpace dummyPvariables(m_bndryCells->a[bndryId].m_noSrfcs, PV->noVariables, AT_, "dummyPvariables");
        for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
          // if ( m_bndryCell[ bndryId ].m_srfcs[srfc]->m_bndryCndId / 1000 != 3 ) continue;
          const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
          MFloat normal[3] = {F0, F0, F0};
          for(MInt i = 0; i < nDim; i++) {
            normal[i] = m_bndryCell[bndryId].m_srfcs[srfc]->m_normalVectorCentroid[i];
          }
          /*MFloat cnt = F0;
          for ( MInt i = 0; i < nDim; i++ ) {
            normal[i] = m_solver->a_coordinate( cellId ,  i ) - m_solver->a_coordinate( ghostCellId ,  i );
            cnt += POW2(normal[i]);
          }
          cnt = sqrt(cnt);
          for ( MInt i = 0; i < nDim; i++ ) {
            normal[i] /= cnt;
            }*/
          for(MInt v = 0; v < noPVars; v++) {
            if(m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[v] == BC_DIRICHLET) {
              for(MInt s = 0;
                  s < mMin((signed)m_bndryCell[bndryId].m_recNghbrIds.size(), m_bndryCells->a[bndryId].m_noSrfcs);
                  s++) {
                dummyPvariables(s, v) = m_bndryCell[bndryId].m_srfcVariables[s]->m_primVars[v];
              }
              MFloat imageVar = F0;
              for(MInt n = 0; n < (signed)m_bndryCell[bndryId].m_recNghbrIds.size(); n++) {
                const MInt nghbrId = m_bndryCell[bndryId].m_recNghbrIds[n];
                const MFloat nghbrPvariable = (n < m_bndryCells->a[bndryId].m_noSrfcs)
                                                  ? dummyPvariables(n, v)
                                                  : m_solver->a_pvariable(nghbrId, v);
                if(nghbrId < 0
                   || m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst.size()
                          != m_bndryCell[bndryId].m_recNghbrIds.size()) {
                  cerr << nghbrId << " " << m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst.size()
                       << " " << m_bndryCell[bndryId].m_recNghbrIds.size() << endl;
                }
                ASSERT(nghbrId > -1
                           && m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst.size()
                                  == m_bndryCell[bndryId].m_recNghbrIds.size(),
                       "");
                imageVar += m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst[n] * nghbrPvariable;
              }
              // MFloat vf = m_solver->a_cellVolume( cellId ) /
              // pow(m_solver->c_cellLengthAtCell(cellId),(MFloat)nDim); MFloat fac = maia::math::deltaFun( vf, 0.90, F1
              // ); imageVar = ( fac*m_solver->a_pvariable( cellId , v ) + (F1-fac)*imageVar );
              m_solver->a_pvariable(ghostCellId, v) =
                  F2 * m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[v] - imageVar;
            } else if(m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[v] == BC_NEUMANN) {
              MFloat dn0 = m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance;
              // MFloat dn0 = F0;
              MFloat dn = F0;
              for(MInt i = 0; i < nDim; i++) {
                // dn0 += ( m_solver->a_coordinate( cellId ,  i ) - m_bndryCell[ bndryId ].m_srfcs[srfc]->m_coordinates[
                // i ] ) * normal[ i ];
                dn += (m_solver->a_coordinate(cellId, i) - m_solver->a_coordinate(ghostCellId, i)) * normal[i];
              }
              m_solver->a_pvariable(ghostCellId, v) =
                  m_solver->a_pvariable(cellId, v) - dn * m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[v];
              m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[v] =
                  m_solver->a_pvariable(cellId, v) - dn0 * m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[v];
            } else if(m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[v] == BC_ROBIN) {
              MFloat phi = m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance;
              MFloat dn = F0;
              for(MInt i = 0; i < nDim; i++) {
                phi += (m_solver->a_coordinate(cellId, i) - m_bndryCell[bndryId].m_srfcs[srfc]->m_coordinates[i])
                       * normal[i];
                // dn += ( m_bndryCell[ bndryId ].m_srfcs[srfc]->m_coordinates[ i ] - m_solver->a_coordinate(
                // ghostCellId , i )) * normal[ i ];
                dn += (m_solver->a_coordinate(cellId, i) - m_solver->a_coordinate(ghostCellId, i)) * normal[i];
              }
              dn -= m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance;
              if(dn + phi < 1e-8) {
                cerr << domainId() << ": warning very small distance " << m_solver->c_globalId(cellId) << " " << phi
                     << " " << dn << " " << normal[0] << " " << normal[1] << " " << normal[2] << endl;
              }
              const MFloat beta = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_robinFactor;
              const MFloat delta = m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[v];
              // const MFloat fac = ( F1 + beta*dn ) / ( F1 - beta*phi );
              const MFloat fac = (F1 + F1B2 * beta * (dn + phi)) / (F1 - F1B2 * beta * (dn + phi));
              // const MFloat fac2 = ( dn + phi ) / ( F1 - beta*phi );
              const MFloat fac2 = (dn + phi) / (F1 - F1B2 * beta * (dn + phi));
              m_solver->a_pvariable(ghostCellId, v) = fac * m_solver->a_pvariable(cellId, v) - fac2 * delta;
              m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[v] =
                  (dn * m_solver->a_pvariable(cellId, v) + phi * m_solver->a_pvariable(ghostCellId, v)) / (dn + phi);

              if(m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId == 3007) {
                MFloat imageVar = F0;
                for(MInt s = 0;
                    s < mMin((signed)m_bndryCell[bndryId].m_recNghbrIds.size(), m_bndryCells->a[bndryId].m_noSrfcs);
                    s++) {
                  dummyPvariables(s, v) = m_solver->a_pvariable(cellId, v);
                }
                for(MInt n = 0; n < (signed)m_bndryCell[bndryId].m_recNghbrIds.size(); n++) {
                  const MInt nghbrId = m_bndryCell[bndryId].m_recNghbrIds[n];
                  const MFloat nghbrPvariable = (n < m_bndryCells->a[bndryId].m_noSrfcs)
                                                    ? dummyPvariables(n, v)
                                                    : m_solver->a_pvariable(nghbrId, v);
                  imageVar += m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst[n] * nghbrPvariable;
                }

                m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[v] =
                    F0; //( imageVar - m_bndryCell[ bndryId ].m_srfcVariables[srfc]->m_primVars[v] ) / dn
                //+ beta * m_bndryCell[ bndryId ].m_srfcVariables[srfc]->m_primVars[v];
                m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[v] = imageVar;

                // imageVar = F2*m_solver->a_pvariable(cellId, v)  - imageVar;
                // m_bndryCell[ bndryId ].m_srfcVariables[srfc]->m_primVars[v] = imageVar;
              }
            } else if(m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[v] == BC_ISOTHERMAL) {
              continue;
            } else {
              mTerm(1, AT_,
                    "Unknown BC type: " + to_string(m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId) + "/"
                        + to_string(v) + "/" + to_string(m_bndryCells->a[bndryId].m_noSrfcs) + "/"
                        + to_string(m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[v]) + " "
                        + to_string(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area) + " "
                        + to_string(m_solver->a_hasProperty(cellId, SolverCell::IsCutOff)));
            }
          }
          if(m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->RHO] == BC_ISOTHERMAL) {
            // const MFloat Ts = bodyTemperatureRatio * m_solver->m_TInfinity;
            const MFloat Ts = sysEqn().temperature_ES(m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->RHO],
                                                      m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->P]);

            // if ( true) cerr << "bc: " << Ts/m_solver->m_TInfinity << endl;
            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->RHO] =
                sysEqn().density_ES(m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->P], Ts);
            for(MInt s = 0;
                s < mMin((signed)m_bndryCell[bndryId].m_recNghbrIds.size(), m_bndryCells->a[bndryId].m_noSrfcs);
                s++) {
              for(MInt vv = 0; vv < noPVars; vv++) {
                dummyPvariables(s, vv) = m_bndryCell[bndryId].m_srfcVariables[s]->m_primVars[vv];
              }
            }

            MFloat dn00 = m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance;
            // MFloat dn00 = F0;
            // MFloat dn0 = F0;
            MFloat dn = F0;
            for(MInt i = 0; i < nDim; i++) {
              // dn0 += ( m_bndryCell[ bndryId ].m_srfcs[srfc]->m_coordinates[ i ] - m_solver->a_coordinate( ghostCellId
              // , i )) * normal[ i ];
              dn += (m_solver->a_coordinate(cellId, i) - m_solver->a_coordinate(ghostCellId, i)) * normal[i];
              // dn00 += (m_solver->a_coordinate( cellId ,  i ) - m_bndryCell[ bndryId ].m_srfcs[srfc]->m_coordinates[ i
              // ])
              // * normal[ i ];
            }
            MFloat dn0 = dn - dn00;

            MFloat imageVar = F0;
            for(MInt n = 0; n < (signed)m_bndryCell[bndryId].m_recNghbrIds.size(); n++) {
              const MInt nghbrId = m_bndryCell[bndryId].m_recNghbrIds[n];
              const MFloat nghbrPvariableP = (n < m_bndryCells->a[bndryId].m_noSrfcs)
                                                 ? dummyPvariables(n, PV->P)
                                                 : m_solver->a_pvariable(nghbrId, PV->P);
              imageVar += m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst[n] * nghbrPvariableP;
            }
            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->P] = m_solver->a_pvariable(cellId, PV->P);
            m_solver->a_pvariable(ghostCellId, PV->P) =
                F2 * m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->P] - imageVar;
            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[PV->P] =
                (imageVar - m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->P]) / dn0;
            imageVar = F0;
            for(MInt n = 0; n < (signed)m_bndryCell[bndryId].m_recNghbrIds.size(); n++) {
              const MInt nghbrId = m_bndryCell[bndryId].m_recNghbrIds[n];
              const MInt noSrfcs = m_bndryCells->a[bndryId].m_noSrfcs;
              const MFloat nghbrPvariableP =
                  (n < noSrfcs) ? dummyPvariables(n, PV->P) : m_solver->a_pvariable(nghbrId, PV->P);
              const MFloat nghbrPvariableRho =
                  (n < noSrfcs) ? dummyPvariables(n, PV->RHO) : m_solver->a_pvariable(nghbrId, PV->RHO);
              if(nghbrId < 0
                 || m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst.size()
                        != m_bndryCell[bndryId].m_recNghbrIds.size()) {
                cerr << nghbrId << " " << m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst.size() << " "
                     << m_bndryCell[bndryId].m_recNghbrIds.size() << endl;
              }
              ASSERT(nghbrId > -1
                         && m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst.size()
                                == m_bndryCell[bndryId].m_recNghbrIds.size(),
                     "");
              imageVar += m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst[n]
                          * sysEqn().temperature_ES(nghbrPvariableRho, nghbrPvariableP);
            }

            MFloat dTdn = (imageVar - Ts) / dn0;

            const MInt noNghbrIds = m_solver->a_noReconstructionNeighbors(cellId);

            MInt maxIter = 100;
            MFloat res = 99999.9;
            MInt iter = 0;
            while(iter < maxIter && res > 1e-8) {
              MFloat pg = m_solver->a_pvariable(ghostCellId, PV->P);
              MFloat ps = m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->P];
              for(MInt i = 0; i < nDim; i++) {
                m_solver->a_slope(cellId, PV->P, i) = F0;
                for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
                  const MInt nghbrId = m_solver->a_reconstructionNeighborId(cellId, nghbr);
                  const MInt offset0 = m_solver->a_reconstructionData(cellId) + nghbr;
                  m_solver->a_slope(cellId, PV->P, i) +=
                      m_solver->m_reconstructionConstants[nDim * offset0 + i]
                      * (m_solver->a_pvariable(nghbrId, PV->P) - m_solver->a_pvariable(cellId, PV->P));
                }
              }
              m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);
              m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->P] = m_solver->a_pvariable(cellId, PV->P);
              m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[PV->P] = F0;
              for(MInt i = 0; i < nDim; i++) {
                m_solver->a_pvariable(ghostCellId, PV->P) +=
                    (m_solver->a_coordinate(ghostCellId, i) - m_solver->a_coordinate(cellId, i))
                    * m_solver->a_slope(cellId, PV->P, i);
                m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->P] +=
                    (m_bndryCell[bndryId].m_srfcs[srfc]->m_coordinates[i] - m_solver->a_coordinate(cellId, i))
                    * m_solver->a_slope(cellId, PV->P, i);
                m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[PV->P] +=
                    m_solver->a_slope(cellId, PV->P, i) * normal[i];
              }
              m_solver->a_pvariable(ghostCellId, PV->P) =
                  m_solver->a_pvariable(cellId, PV->P)
                  - dn * m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[PV->P];
              m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->P] =
                  m_solver->a_pvariable(cellId, PV->P)
                  - dn00 * m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[PV->P];

              res = mMax(fabs(m_solver->a_pvariable(ghostCellId, PV->P) - pg),
                         fabs(m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->P] - ps));
              iter++;
            }

            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->RHO] =
                sysEqn().density_ES(m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->P], Ts);

            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[PV->RHO] =
                sysEqn().density_ES(m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[PV->P], Ts)
                - (m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->RHO] * dTdn) / Ts;

            m_solver->a_pvariable(ghostCellId, PV->RHO) =
                m_solver->a_pvariable(cellId, PV->RHO)
                - dn * m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[PV->RHO];
          }
        }
#ifdef _OPENMP
      }
#endif
    }
  }
}


//-----------------------------------------------------------------------------


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::updateGhostCellVariables() {
  TRACE();
  for(MInt bcId = 0; bcId < m_noBndryCndIds; bcId++) {
    (this->*bndryCndHandlerVariables[bcId])(bcId);
  }
}


//-----------------------------------------------------------------------------


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::updateCutOffCellVariables() {
  TRACE();

  for(MInt bcId = 0; bcId < m_noCutOffBndryCndIds; bcId++)
    (this->*bndryCndHandlerCutOffVariables[bcId])(bcId);
}


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::initCutOffBndryCnds() {
  TRACE();

  // calls functions to initialize boundary conditions
  for(MInt bcId = 0; bcId < m_noCutOffBndryCndIds; bcId++) {
    (this->*(bndryCndHandlerCutOffInit[bcId]))(bcId);
  }
}

//-----------------------------------------------------------------------------

template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::createBoundaryAtCutoff() {
  TRACE();

  MInt noCells = m_solver->noInternalCells();
  std::set<std::tuple<MInt, MInt, MInt, MBool>> cutOffBndryDirections;

  if(!Context::propertyExists("cutOffBndryIds", m_solverId) && !m_solver->m_cutOffInterface.size()) {
    mTerm(1, AT_,
          "createBoundaryAtCutoff is set but no cutOff boundary condition is set in cutOffBndryIds or "
          "cutOffInterface, fix your property file");
  }

  // add cutOffDirection boundary conditions
  if(Context::propertyExists("cutOffBndryIds", m_solverId)) {
    /*! \page propertiesFV
        \section cutOffBndryIds
        <code>cutOffBndryIds </code>\n
        default = <code>none</code>\n \n
        Create cut off boundary with the respective bndryId. Only works together with property cutOffDirections
        <ul>
        <li> any existing cut off bndryId </li>
        </ul>
        Keywords: <i> FINITE_VOLUME, CUTOFF </i>
      */
    MInt noCutOffBndryIds = Context::propertyLength("cutOffBndryIds", m_solverId);
    /*! \page propertiesFV
        \section cutOffDirections
        <code>cutOffDirections </code>\n
        default = <code>none</code>\n \n
        Create cut off boundary at the respective border of the domain (0: create cut off bndry in -x direction, and so
       on). Only works together with property cutOffBndryIds <ul> <li> 0, 1, 2, 3, 4 (2D), 5 (3D) </li>
        </ul>
        Keywords: <i> FINITE_VOLUME, CUTOFF </i>
      */
    MInt noCutOffDirections = Context::propertyLength("cutOffDirections", m_solverId);
    if(noCutOffDirections != noCutOffBndryIds)
      mTerm(1, AT_,
            "Wrong number of cut off directions. Must be identical to number of cut off bndryIds! Please check!");
    std::set<MInt> diffBcs;
    for(MInt i = 0; i < noCutOffBndryIds; i++) {
      MInt cutOffBndryIdTmp = Context::getSolverProperty<MInt>("cutOffBndryIds", m_solverId, AT_, i);
      MInt cutOffDirectionTmp = Context::getSolverProperty<MInt>("cutOffDirections", m_solverId, AT_, i);
      if(m_solver->m_cutOffInterface.find(cutOffBndryIdTmp) != m_solver->m_cutOffInterface.end()) {
        mTerm(1, AT_, "same cut off bc in cutOffBndryIds and cutOffInterface");
      }
      // Store wether the cutOffBndry is inside the cut-off box or not
      MInt cutOffInside = 0;
      if(Context::propertyExists("cutOffInside", m_solverId)) {
        cutOffInside = Context::getSolverProperty<MBool>("cutOffInside", m_solverId, AT_, i);
      }
      cutOffBndryDirections.insert(make_tuple(cutOffBndryIdTmp, cutOffDirectionTmp, i, cutOffInside));
      diffBcs.insert(cutOffBndryIdTmp);
    }

    // clusters the boundary conditions:
    // using one bcId for more directions results in one entry in m_sortedCutOffCells
    /*! \page propertiesFV
      \section clusterCutOffBcs
      <code>MInt FvBndryCndXD<nDim,SysEqn>::m_clusterCutOffBcs</code>\n
      default = <code>0</code>\n\n
      Enables/Disables the clustering of the boundary conditions\n
      Possible values are:
      <ul>
      <li>0; 1</li>
      </ul>
      Keywords: <i>FINITE_VOLUME, BOUNDARIES</i>
    */
    m_clusterCutOffBcs = false;
    m_clusterCutOffBcs = Context::getSolverProperty<MBool>("clusterCutOffBcs", m_solverId, AT_, &m_clusterCutOffBcs);
    if(m_clusterCutOffBcs)
      m_noCutOffBndryCndIds = diffBcs.size();
    else
      m_noCutOffBndryCndIds = noCutOffBndryIds;
  }
  // add cutOffInterface boundary conditions
  m_noCutOffBndryCndIds += m_solver->m_cutOffInterface.size();
  //---
  allocateCutOffMemory();

  // Read the cut-off box. This can be used to prescribe different cut-off BCs and the same cartedian grid cut-off
  MFloatScratchSpace cutOffInsideBox(2 * nDim, AT_, "cutOffInsideBox");
  if(Context::propertyExists("cutOffInside", m_solverId)) {
    for(MInt d = 0; d < 2 * nDim; d++) {
      cutOffInsideBox[d] = Context::getSolverProperty<MFloat>("cutOffInsideBox", m_solverId, AT_, d);
    }
  } else {
    cutOffInsideBox.fill(F0);
  }

  m_log << "*************************" << endl;
  m_log << "Creating cut-off boundary" << endl;
  m_log << "*************************" << endl;

  MInt bc = 0;
  // add cells to cutOffDirection boundary conditions
  for(auto it = cutOffBndryDirections.begin(); it != cutOffBndryDirections.end(); it++) {
    MInt bcId = get<0>(*it);
    MInt direction = get<1>(*it);
    MBool cutOffInside = get<3>(*it);

    // search cells in cut off direction
    for(MInt cellId = 0; cellId < noCells; cellId++) {
      if(m_solver->a_isHalo(cellId)) continue;
      if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
      if(m_solver->a_hasNeighbor(cellId, direction, false) != 0) continue;
      if(m_solver->a_bndryId(cellId) > -1 && m_bndryCells->a[m_solver->a_bndryId(cellId)].m_externalFaces[direction])
        continue;
      if(m_solver->c_parentId(cellId) > -1) {
        if(m_solver->a_hasNeighbor(m_solver->c_parentId(cellId), direction, false) != 0) {
          continue;
        }
      }

      if(m_solver->m_engineSetup && m_solver->m_noGapRegions > 2) {
        if(bcId == 209199 && m_solver->a_coordinate(cellId, 2) > 0) continue;
        if(bcId == 309199 && m_solver->a_coordinate(cellId, 2) < 0) continue;
      }

      m_solver->a_hasProperty(cellId, SolverCell::IsCutOff) = true;

      // If cell is cut-off cell, check wether cell should be added to current cut-off BCs
      MBool insideCutOffBox = true;
      for(MInt d = 0; d < nDim; d++) {
        if(m_solver->c_coordinate(cellId, d) < cutOffInsideBox[d]
           || m_solver->c_coordinate(cellId, d) > cutOffInsideBox[nDim + d]) {
          insideCutOffBox = false;
        }
      }

      if(insideCutOffBox != cutOffInside) continue;

      m_sortedCutOffCells[bc]->a[m_sortedCutOffCells[bc]->size()] = cellId;
      m_sortedCutOffCells[bc]->append();
    }
    if(!m_clusterCutOffBcs || std::next(it) == cutOffBndryDirections.end() || bcId != get<0>(*(std::next(it)))) {
      m_cutOffBndryCndIds[bc] = bcId;
      m_log << bc << ": " << m_cutOffBndryCndIds[bc] << " is cutOffDirection boundary condition" << endl;
      if(m_cbcCutOff) {
        // Map bcId to cbcId
        m_cbcBndryCndIds[bc] = get<2>(*it);
      }
      bc++;
    }
  }

  // add cells to cutOffInterface boundary conditions
  for(auto it = m_solver->m_cutOffInterface.begin(); it != m_solver->m_cutOffInterface.end(); it++, bc++) {
    m_cutOffBndryCndIds[bc] = *it;
    m_log << bc << ": " << m_cutOffBndryCndIds[bc] << " is cutOffInterface boundary condition" << endl;
    for(MInt cellId = 0; cellId < noCells; cellId++) {
      if(m_solver->a_hasProperty(cellId, SolverCell::IsCutOff)) continue;
      if(!m_solver->a_isInterface(cellId)) continue;
      if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
      if(m_solver->a_isHalo(cellId)) continue;
      if(m_cutOffBndryCndIds[bc] != isCutOffInterface(cellId)) continue;

      m_solver->a_hasProperty(cellId, SolverCell::IsCutOff) = true;
      m_sortedCutOffCells[bc]->a[m_sortedCutOffCells[bc]->size()] = cellId;
      m_sortedCutOffCells[bc]->append();
    }
  }

  exchangeCutOffBoundaryCells();
}
//-----------------------------------------------------------------------------

/** \brief allocates the cut off list memory
 *
 * \author Stephan Schlimpert
 * \date April 2014
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::allocateCutOffMemory() {
  TRACE();
  if(m_createBoundaryAtCutoff) {
    // ASSERT(m_noCutOffBndryCndIds>0,"noCutOffBndryCndIds ==0");
    if(m_noCutOffBndryCndIds == 0) TERMM(1, "cut off is on, but no boundary conditions are available! ");

    if(m_noCutOffBndryCndIds >= m_maxNoBndryCndIds) TERMM(1, "too many cut off bndryIds! ");

    // Cleanup anything already present in m_sortedCutOffCells
    for(auto& i : m_sortedCutOffCells) {
      delete i;
    }
    m_sortedCutOffCells.clear();

    m_log << "no cut off bcs " << m_noCutOffBndryCndIds << endl;
    for(MInt n = 0; n < m_noCutOffBndryCndIds; n++) {
      auto* sortedList = new List<MInt>(m_maxNoBndryCells);
      sortedList->setSize(0);
      m_sortedCutOffCells.push_back(sortedList);
    }

    m_cbcCutOff = false;
    m_cbcCutOff = Context::getSolverProperty<MBool>("cutOffcbc", m_solverId, AT_, &m_cbcCutOff);

    m_cbcSmallCellCorrection = false;
    m_cbcSmallCellCorrection =
        Context::getSolverProperty<MBool>("cbcSmallCellCorrection", m_solverId, AT_, &m_cbcSmallCellCorrection);

    if(m_cbcCutOff) {
      m_cbcDir.resize(m_noCutOffBndryCndIds);
      m_cbcRelax.resize(m_noCutOffBndryCndIds);
      m_cbcLref.resize(m_noCutOffBndryCndIds);
      m_cbcInflowArea.resize(m_noCutOffBndryCndIds);
      m_cbcReferencePoint.resize(m_noCutOffBndryCndIds);
      m_dirNormal.resize(m_noCutOffBndryCndIds);
      m_dirTangent.resize(m_noCutOffBndryCndIds);
      m_cbcDomainMin.resize(m_noCutOffBndryCndIds);
      m_cbcBndryCndIds.resize(m_noCutOffBndryCndIds, -1);
    }
  }
}

//-----------------------------------------------------------------------------

/** \brief exchanges the cut off boundary cells and adds them to the accordings cut off boundary lists
 *
 * \author Stephan Schlimpert
 * \date April 2014
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::exchangeCutOffBoundaryCells() {
  TRACE();
  // exchange cells for all cut off boundary condition and add them to the corresponding lists
  for(MInt bcId = 0; bcId < m_noCutOffBndryCndIds; bcId++) {
    MInt bcIdNr = m_cutOffBndryCndIds[bcId];
    MInt noInternalCutOffCells = m_sortedCutOffCells[bcId]->size();
    m_log << "processing bcIdNr " << bcIdNr << " with " << noInternalCutOffCells << " internal cut off cells...";
    MIntScratchSpace intSendRecBuffers(m_solver->a_noCells(), AT_, "intSendRecBuffers");
    intSendRecBuffers.fill(0);
    // gather b_properties[SolverCell::IsCutOff] only for current cut off bc
    MInt cnt = 0;
    for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
      MInt cellId = m_sortedCutOffCells[bcId]->a[id];
      intSendRecBuffers[cellId] = m_solver->a_hasProperty(cellId, SolverCell::IsCutOff);
      if(intSendRecBuffers[cellId] > 0 && m_solver->a_isWindow(cellId)) cnt++;
    }
    m_log << "... " << cnt << " window cut off cells to exchange to all domains ... ";
    // exchange b_properties only on window cells and receive corresponding data on halo cells
    m_solver->exchangeData(intSendRecBuffers.getPointer(), 1);
    // scatter data to cell collector and append halo cell to the cut off boundary collector
    for(MInt i = 0; i < m_solver->noNeighborDomains(); i++) {
      for(MInt j = 0; j < m_solver->noHaloCells(i); j++) {
        MInt thishaloCellId = m_solver->haloCellId(i, j);
        if(!m_solver->a_hasProperty(thishaloCellId, SolverCell::IsOnCurrentMGLevel)) continue;
        if(m_solver->a_hasProperty(thishaloCellId, SolverCell::IsCutOff)) continue;
        m_solver->a_hasProperty(thishaloCellId, SolverCell::IsCutOff) = intSendRecBuffers[thishaloCellId];
        if(m_solver->a_hasProperty(thishaloCellId, SolverCell::IsCutOff)) {
          m_sortedCutOffCells[bcId]->a[m_sortedCutOffCells[bcId]->size()] = thishaloCellId;
          m_sortedCutOffCells[bcId]->append();
        }
      }
    }
    // Note: Azimuthal window and halo cells might not be on same grid level. Therefore, intSendRecBuffers are modified
    // for parent data
    if(m_solver->grid().azimuthalPeriodicity()) {
      MInt axDir = m_solver->grid().raw().m_azimuthalAxialDir;
      // Modify parent data
      for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
        MInt cellId = m_sortedCutOffCells[bcId]->a[id];
        if(m_solver->a_hasProperty(cellId, SolverCell::IsCutOff)) {
          if(m_solver->c_parentId(cellId) > -1) {
            intSendRecBuffers[m_solver->c_parentId(cellId)] = true;
          }
        }
      }
      m_solver->exchangeDataAzimuthal(intSendRecBuffers.getPointer(), 1);
      for(MInt i = 0; i < m_solver->grid().noAzimuthalNeighborDomains(); i++) {
        for(MInt j = 0; j < m_solver->grid().noAzimuthalHaloCells(i); j++) {
          MInt thishaloCellId = m_solver->grid().azimuthalHaloCell(i, j);
          if(!m_solver->a_hasProperty(thishaloCellId, SolverCell::IsOnCurrentMGLevel)) continue;
          if(m_solver->a_hasProperty(thishaloCellId, SolverCell::IsCutOff)) continue;
          if(intSendRecBuffers[thishaloCellId] > 0) {
            if(!m_solver->a_hasNeighbor(thishaloCellId, axDir)) {
              if(m_solver->c_parentId(thishaloCellId) < 0
                 || (m_solver->c_parentId(thishaloCellId) > -1
                     && !m_solver->a_hasNeighbor(m_solver->c_parentId(thishaloCellId), axDir))) {
                m_solver->a_hasProperty(thishaloCellId, SolverCell::IsCutOff) = intSendRecBuffers[thishaloCellId];
              }
            } else if(!m_solver->a_hasNeighbor(thishaloCellId, axDir + 1)) {
              if(m_solver->c_parentId(thishaloCellId) < 0
                 || (m_solver->c_parentId(thishaloCellId) > -1
                     && !m_solver->a_hasNeighbor(m_solver->c_parentId(thishaloCellId), axDir + 1))) {
                m_solver->a_hasProperty(thishaloCellId, SolverCell::IsCutOff) = intSendRecBuffers[thishaloCellId];
              }
            }
          }
          if(m_solver->a_hasProperty(thishaloCellId, SolverCell::IsCutOff)) {
            m_sortedCutOffCells[bcId]->a[m_sortedCutOffCells[bcId]->size()] = thishaloCellId;
            m_sortedCutOffCells[bcId]->append();
          }
        }
      }
      for(MUint i = 0; i < m_solver->m_azimuthalRemappedNeighborDomains.size(); i++) {
        for(MUint j = 0; j < m_solver->m_azimuthalRemappedHaloCells[i].size(); j++) {
          MInt thishaloCellId = m_solver->m_azimuthalRemappedHaloCells[i][j];
          if(!m_solver->a_hasProperty(thishaloCellId, SolverCell::IsOnCurrentMGLevel)) continue;
          if(m_solver->a_hasProperty(thishaloCellId, SolverCell::IsCutOff)) continue;
          if(intSendRecBuffers[thishaloCellId]
             && (!m_solver->a_hasNeighbor(thishaloCellId, axDir)
                 || !m_solver->a_hasNeighbor(thishaloCellId, axDir + 1))) {
            m_solver->a_hasProperty(thishaloCellId, SolverCell::IsCutOff) = intSendRecBuffers[thishaloCellId];
          }
          if(m_solver->a_hasProperty(thishaloCellId, SolverCell::IsCutOff)) {
            m_sortedCutOffCells[bcId]->a[m_sortedCutOffCells[bcId]->size()] = thishaloCellId;
            m_sortedCutOffCells[bcId]->append();
          }
        }
      }
    }
    m_log << " finished. " << endl
          << " number received cut off cells = " << m_sortedCutOffCells[bcId]->size() - noInternalCutOffCells
          << " for current bcId = " << bcIdNr << endl;
  }
}

//-----------------------------------------------------------------------------

/*
 * \author Tim Wegmann, Juli. 2019
 *
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::markCutOff(MIntScratchSpace& cutOffCells) {
  TRACE();

  MInt noCutOffDirections = Context::propertyLength("cutOffDirections", m_solverId);

  // add cells to cutOffDirection noundary conditions
  for(MInt dir = 0; dir < noCutOffDirections; dir++) {
    MInt direction = Context::getSolverProperty<MInt>("cutOffDirections", m_solverId, AT_, dir);
    // search cells in cut off direction
    for(MInt cellId = 0; cellId < m_solver->noInternalCells(); cellId++) {
      if(m_solver->c_noChildren(cellId) > 0) continue;
      if(m_solver->a_hasNeighbor(cellId, direction) != 0) continue;
      if(m_solver->a_isInterface(cellId)) continue;
      if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

      if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;

      if(m_solver->c_parentId(cellId) > -1) {
        const MInt parent = m_solver->c_parentId(cellId);
        if(m_solver->a_hasNeighbor(parent, direction) != 0) continue;
        if(m_solver->a_isInterface(parent)) continue;
      }
      cutOffCells(cellId) = 1;
      MInt parentId = m_solver->c_parentId(cellId);
      while(parentId > -1 && parentId < m_solver->a_noCells()) {
        cutOffCells(parentId) = 1;
        parentId = m_solver->c_parentId(parentId);
      }
    }
  }

  m_solver->exchangeData(&cutOffCells(0), 1);
}

//-----------------------------------------------------------------------------

/*
 * \author Thomas Schiden, Feb. 2016
 *
 */
template <MInt nDim, class SysEqn>
MInt FvBndryCndXD<nDim, SysEqn>::isCutOffInterface(MInt cellId) {
  if(!m_solver->m_cutOffInterface.size()) return 0;

  // a. Create target for check
  const MFloat cellHalfLength = m_solver->c_cellLengthAtCell(cellId) / F2;
  MFloat target[6];
  std::vector<MInt> nodeList;

  for(MInt j = 0; j < nDim; j++) {
    target[j] = m_solver->a_coordinate(cellId, j) - cellHalfLength;
    target[j + nDim] = m_solver->a_coordinate(cellId, j) + cellHalfLength;
  }

  // b. Do the intersection test
  if(m_gridCutTest == "SAT")
    m_solver->m_geometry->getIntersectionElements(target, nodeList, cellHalfLength, &m_solver->a_coordinate(cellId, 0));
  else
    m_solver->m_geometry->getIntersectionElements(target, nodeList);

  const MInt noNodes = nodeList.size();
  if(noNodes == 0) return 0;

  // c. check for the lowest bcId
  MInt bndCndId = m_solver->m_geometry->elements[nodeList[0]].m_bndCndId;
  for(MInt n = 1; n < noNodes; n++) {
    bndCndId = mMin(m_solver->m_geometry->elements[nodeList[n]].m_bndCndId, bndCndId);
  }
  if(m_solver->m_cutOffInterface.find(bndCndId) == m_solver->m_cutOffInterface.end())
    return 0;
  else
    return bndCndId;
}

//-----------------------------------------------------------------------------

// template <MInt nDim, class SysEqn>
// void FvBndryCndXD<nDim,SysEqn>::applyNonReflectingBC()
//{
//  TRACE();
//
//  for( MInt bcId = 0;  bcId < m_noBndryCndIds;  bcId++ )
//    (this->*nonReflectingBoundaryCondition[bcId]) (bcId);
//}


//-----------------------------------------------------------------------------


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::applyNonReflectingBCCutOff() {
  TRACE();

  for(MInt bcId = 0; bcId < m_noCutOffBndryCndIds; bcId++)
    (this->*nonReflectingCutOffBoundaryCondition[bcId])(bcId);
}


//-----------------------------------------------------------------------------


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::applyNonReflectingBCAfterTreatmentCutOff() {
  TRACE();

  for(MInt bcId = 0; bcId < m_noCutOffBndryCndIds; bcId++)
    (this->*nonReflectingBoundaryConditionAfterTreatmentCutOff[bcId])(bcId);
}


//-----------------------------------------------------------------------------


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::updateGhostCellSlopesInviscid() {
  TRACE();

  // loop over all different boundary conditions
  for(MInt bcId = 0; bcId < m_noBndryCndIds; bcId++) {
    (this->*bndryCndHandlerSlopesInviscid[bcId])(bcId);
  }
}


//-----------------------------------------------------------------------------


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::updateCutOffSlopesInviscid() {
  TRACE();

  // loop over all different boundary conditions
  for(MInt bcId = 0; bcId < m_noCutOffBndryCndIds; bcId++) {
    (this->*bndryCndHandlerCutOffSlopesInviscid[bcId])(bcId);
  }
}


//-----------------------------------------------------------------------------


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::updateGhostCellSlopesViscous() {
  TRACE();

  NEW_TIMER_GROUP_STATIC(tg_initTimer, "updateGhostCellSlopesViscous");
  NEW_TIMER_STATIC(t_timertotal, "total", tg_initTimer);
  NEW_SUB_TIMER_STATIC(t_viscSlopes, "bndryViscousSlopes", t_timertotal);
  NEW_SUB_TIMER_STATIC(t_cghost, "correctGhostCellSlopesViscous", t_timertotal);

  RECORD_TIMER_START(t_timertotal);
  RECORD_TIMER_START(t_viscSlopes);
  for(MInt bcId = 0; bcId < m_noBndryCndIds; bcId++) {
    (this->*bndryViscousSlopes[bcId])(bcId);
  }
  RECORD_TIMER_STOP(t_viscSlopes);

  RECORD_TIMER_START(t_cghost);
  if(!m_cellMerging) {
    correctGhostCellSlopesViscous();
  }
  RECORD_TIMER_STOP(t_cghost);
  RECORD_TIMER_STOP(t_timertotal);
}


//-----------------------------------------------------------------------------


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::correctGhostCellSlopesViscous() {
  TRACE();

  const MInt noBndryCells = m_bndryCells->size();
  const MInt noPVars = PV->noVariables;

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      continue;
    }
    if(m_solver->a_isHalo(cellId)) {
      continue;
    }
    if(m_bndryCell[bndryId].m_recNghbrIds.size() == 0) {
      continue;
    }
    if(m_solver->a_hasProperty(cellId, SolverCell::IsCutOff)) {
      continue;
    }

    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
      MFloat normal[3] = {F0, F0, F0};
      for(MInt i = 0; i < nDim; i++) {
        normal[i] = m_bndryCell[bndryId].m_srfcs[srfc]->m_normalVectorCentroid[i];
      }
      MFloat dng = F0;
      for(MInt i = 0; i < nDim; i++) {
        dng += (m_solver->a_coordinate(cellId, i) - m_solver->a_coordinate(ghostCellId, i)) * normal[i];
      }
      dng -= m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance;

      for(MInt v = 0; v < noPVars; v++) {
        switch(m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[v]) {
          case BC_DIRICHLET:
            // case BC_ISOTHERMAL:
          case BC_UNSET:
            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[v] =
                (m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[v] - m_solver->a_pvariable(ghostCellId, v))
                / dng;
            // m_bndryCell[ bndryId ].m_srfcVariables[srfc]->m_normalDeriv[v] = ( m_solver->a_pvariable( cellId , v) -
            // m_solver->a_pvariable( ghostCellId , v) ) / dng;
            for(MInt i = 0; i < nDim; i++) {
              m_solver->a_slope(ghostCellId, v, i) =
                  m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[v] * normal[i];
              // m_solver->a_slope( ghostCellId , v, i) = m_solver->a_slope( cellId , v, i); //use this if local density
              // peaks/drops occur
            }
            break;

          case BC_NEUMANN:
          case BC_ISOTHERMAL:
            for(MInt i = 0; i < nDim; i++) {
              m_solver->a_slope(ghostCellId, v, i) =
                  m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[v] * normal[i];
            }
            break;

          case BC_ROBIN:
            for(MInt i = 0; i < nDim; i++) {
              m_solver->a_slope(ghostCellId, v, i) =
                  normal[i]
                  * (m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[v]
                     - m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_robinFactor
                           * m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[v]);
            }
            break;

          default: {
            stringstream errorMessage;
            errorMessage << "ERROR: Invalid BC type with value = "
                         << m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[v] << ", variable number" << v
                         << ", at bc = " << m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId;
            mTerm(1, AT_, errorMessage.str());
          }
        }

        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_slope(ghostCellId, v, i) =
              2.0 * m_solver->a_slope(ghostCellId, v, i) - m_solver->a_slope(cellId, v, i);
        }
      }
    }
  }
}

//-----------------------------------------------------------------------------

template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::updateCutOffSlopesViscous() {
  TRACE();

  for(MInt bcId = 0; bcId < m_noCutOffBndryCndIds; bcId++) {
    (this->*bndryCutOffViscousSlopes[bcId])(bcId);
  }
}

template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::initBndryCnds() {
  TRACE();

  for(MInt bcId = 0; bcId < m_noBndryCndIds; bcId++) {
    (this->*bndryCndHandlerInit[bcId])(bcId);
  }

  if(!m_cellMerging) setBCTypes();

  if(m_solver->m_wmLES) {
    initWMSurfaces();
  }
}


//-------------------------------------------------------------------------------


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::setBCTypes(MInt updateOnlyBndryCndId) {
  TRACE();
  const MInt noPVars = PV->noVariables;
  set<MInt> unhandledBCs;

  for(MInt bcId = 0; bcId < m_noBndryCndIds; bcId++) {
    if((updateOnlyBndryCndId > -1) && (m_bndryCndIds[bcId] != updateOnlyBndryCndId)) {
      continue;
    }

    for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
      MInt bndryId = m_sortedBndryCells->a[id];

      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        ASSERT(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId > -1, "");
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId != m_bndryCndIds[bcId]) {
          continue;
        }

        // initialization: Dirichlet type and zero normal derivatives, individual specifications below
        for(MInt v = 0; v < noPVars; v++) {
          m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[v] = BC_DIRICHLET;
          m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[v] = F0;
        }
        m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_robinFactor = F0;

        // set species variable to BC_NEUMANN
        for(MInt s = 0; s < m_noSpecies; s++) {
          m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->Y[s]] = BC_NEUMANN;
        }

        switch(m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId) {
          //---
          // supersonic inflow conditions
          //---
          case 0:
          case 1091:
          case 1092:
          case 1101:
          case 1102:
            //---
            // STG
            //---
          case 7909:
          case 7910:
          case 7911:
          case 7912:
          case 7913:
            // do nothing, all Dirichlet is correct
            break;

            //---
            // subsonic inflow conditions
            //---
          case 1001:
          case 1009:
          case 1011:
          case 1021:
          case 2011:
            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->P] = BC_NEUMANN;
            if(m_isEEGas || isDetChem<SysEqn>) {
              for(MInt s = 0; s < m_noSpecies; s++) {
                m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->Y[s]] = BC_DIRICHLET;
              }
            }
            break;

          case 2907:
          case 3011: // isothermal wall
            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->P] = BC_NEUMANN;
            if(m_isEEGas) {
              for(MInt s = 0; s < m_noSpecies; s++) {
                m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->Y[s]] = BC_DIRICHLET;
              }
            }
            break;

            //---
            // subsonic outflow condition
            //---
          case 1002:
          case 1012:
          case 1022:
          case 1099:
            for(MInt i = 0; i < nDim; i++) {
              m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->VV[i]] = BC_NEUMANN;
            }
            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->RHO] = BC_NEUMANN;
            if(m_isEEGas) {
              for(MInt s = 0; s < m_noSpecies; s++) {
                m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->Y[s]] = BC_DIRICHLET;
              }
            }
            IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
              for(MInt r = 0; r < m_solver->m_noRansEquations; ++r) {
                m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->NN[r]] = BC_NEUMANN;
              }
            }
            break;

            //---
            // supersonic outflow conditions
            //---
            //---
            // adiabatic fixed wall conditions
            //---
          case 3002:
          case 30021:
          case 3003:
          case 3009:
          case 3399: // wall-modeling based on viscous fluxes
          case 3466:
          case 3600:
          case 4000:
            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->RHO] = BC_NEUMANN;
            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->P] = BC_NEUMANN;
            break;

            //---
            // isothermal moving wall condition
            //---
          case 3008:
            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->P] = BC_NEUMANN;
            // labels:FV BC_ISOTHERMAL is a hack for MB
            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->RHO] = BC_ISOTHERMAL;
            break;

            //---
            // adiabatic moving wall conditions
            //---
          case 3006:
          case 3067: // labels:FV euler/non euler hack
          case 3007: // labels:FV euler hack
          case 3060:
          case 3010:
            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->RHO] = BC_ROBIN;
            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->P] = BC_ROBIN;
            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_robinFactor = F0;
            break;

            //---
            // symmetry condition about x-axis
            //---
          case 100100:
            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->P] = BC_NEUMANN;
            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->RHO] = BC_NEUMANN;
            m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->U] = BC_NEUMANN;

            IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
              for(MInt r = 0; r < m_solver->m_noRansEquations; ++r) {
                m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->NN[r]] = BC_NEUMANN;
              }
            }
            break;

            //---
            // undefined -> reset to BC_UNSET
            //---
          default:
            for(MInt v = 0; v < noPVars; v++) {
              m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[v] = BC_UNSET;
            }
            unhandledBCs.insert(m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId);
            break;
        }
      }
    }
  }
  if(m_firstUseSetBCTypes) {
    for(MInt unhandledBC : unhandledBCs) {
      cerr0 << "Boundary condition " << unhandledBC << " not handled in FvBndryCndXD::setBCTypes(). "
            << "Defaulting to Dirichlet-type behavior - but on occurrence of a small cell an error will be thrown."
            << endl;
      m_log << "Boundary condition " << unhandledBC << " not handled in FvBndryCndXD::setBCTypes(). "
            << "Defaulting to Dirichlet-type behavior - but on occurrence of a small cell an error will be thrown."
            << endl;
    }
    if(unhandledBCs.empty()) {
      m_log << "All boundary conditions handled in FvBndryCndXD::setBCTypes()." << endl;
    }
    m_firstUseSetBCTypes = false;
  }
}

//-------------------------------------------------------------------------------


/** \brief creates pointers to the boundary conditions
 *
 * \authors Daniel Hartmann, Stephan Schlimpert
 * \date, 22.12.2006, Januar 2011
 *
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::createBndryCndHandler() {
  TRACE();
  mDeallocate(bndryCndHandlerVariables);
  mAlloc(bndryCndHandlerVariables, m_maxNoBndryCndIds, "bndryCndHandlerVariables", AT_);

  mDeallocate(bndryCndHandlerSpongeVariables);
  mAlloc(bndryCndHandlerSpongeVariables, mMax(1, m_noSpongeBndryCndIds), "bndryCndHandlerSpongeVariables", AT_);

  mDeallocate(bndryCndHandlerCutOffVariables);
  mAlloc(bndryCndHandlerCutOffVariables, m_maxNoBndryCndIds, "bndryCndHandlerCutOffVariables", AT_);

  mDeallocate(bndryCndHandlerCutOffInit);
  mAlloc(bndryCndHandlerCutOffInit, m_maxNoBndryCndIds, "bndryCndHandlerCutOffInit", &FvBndryCndXD::bc0, AT_);

  //  mDeallocate( nonReflectingBoundaryCondition );
  //  mAlloc( nonReflectingBoundaryCondition, m_maxNoBndryCndIds, "nonReflectingBoundaryCondition", AT_ );

  mDeallocate(nonReflectingCutOffBoundaryCondition);
  mAlloc(nonReflectingCutOffBoundaryCondition, m_maxNoBndryCndIds, "nonReflectingCutOffBoundaryCondition", AT_);

  mDeallocate(nonReflectingBoundaryConditionAfterTreatmentCutOff);
  mAlloc(nonReflectingBoundaryConditionAfterTreatmentCutOff, m_maxNoBndryCndIds,
         "nonReflectingBoundaryConditionAfterTreatmentCutOff", AT_);

  mDeallocate(bndryCndHandlerCutOffSlopesInviscid);
  mAlloc(bndryCndHandlerCutOffSlopesInviscid, m_maxNoBndryCndIds, "bndryCndHandlerCutOffSlopesInviscid", AT_);

  mDeallocate(bndryCndHandlerSlopesInviscid);
  mAlloc(bndryCndHandlerSlopesInviscid, m_maxNoBndryCndIds, "bndryCndHandlerSlopesInviscid", AT_);

  mDeallocate(bndryViscousSlopes);
  mAlloc(bndryViscousSlopes, m_maxNoBndryCndIds, "bndryViscousSlopes", AT_);

  mDeallocate(bndryCutOffViscousSlopes);
  mAlloc(bndryCutOffViscousSlopes, m_maxNoBndryCndIds, "bndryCutOffViscousSlopes", AT_);

  mDeallocate(bndryCndHandlerInit);
  mAlloc(bndryCndHandlerInit, m_maxNoBndryCndIds, "bndryCndHandlerInit", AT_);

  mDeallocate(bndryCndHandlerNeumann);
  mAlloc(bndryCndHandlerNeumann, m_maxNoBndryCndIds, "bndryCndHandlerNeumann", AT_);

  for(MInt bcId = 0; bcId < m_noCutOffBndryCndIds; bcId++) {
    bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
    nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::bc0;
    bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
    bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
    nonReflectingBoundaryConditionAfterTreatmentCutOff[bcId] = &FvBndryCndXD::bc0;

    switch(m_cutOffBndryCndIds[bcId]) {
      case 0: // do nothing
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        break;

      case 10910: // parabolic inflow - y-direction
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc10910;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc1000co;
        break;

      case 109100:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc1091;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
        break;

      case 109101: // subsonic characteristic inflow -> partially reflecting, T0, u, v is prescribed, incl. transverse
                   // terms
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc1091a;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
        break;

      case 309101: // subsonic characteristic turbulent inflow -> partially reflecting, T0, u, v is prescribed, incl.
                   // transverse terms
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc3091a;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
        break;

      case 209101: // subsonic characteristic inflow -> partially reflecting, T0, u, v is prescribed, incl. transverse
                   // terms
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc2091a;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
        break;

      case 209102: // subsonic characteristic inflow ->fully reflecting, T0, u, v is prescribed, incl. transverse terms
                   // + forcing
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc2091b;
        nonReflectingBoundaryConditionAfterTreatmentCutOff[bcId] = &FvBndryCndXD::cbc2091b_after;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
        break;

      case 109103: // subsonic characteristic inflow ->fully reflecting,  p0,T0,v is prescribed, incl. shear and
                   // transverse terms
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc1091c;
        nonReflectingBoundaryConditionAfterTreatmentCutOff[bcId] = &FvBndryCndXD::cbc1091c_after;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
        break;

      case 109104: // subsonic characteristic inflow -> partially reflecting, p0,T0,v is prescribed, incl. shear and
                   // transverse terms, profile of u1 is prescribed
      case 1091040:
      case 1091041:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc1091d;
        nonReflectingBoundaryConditionAfterTreatmentCutOff[bcId] = &FvBndryCndXD::cbc1091d_after;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
        break;

      case 209104: // subsonic characteristic inflow -> partially reflecting, p0,T0,v is prescribed, incl. shear and
                   // transverse terms, profile of u1 is prescribed
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc2091d;
        nonReflectingBoundaryConditionAfterTreatmentCutOff[bcId] = &FvBndryCndXD::cbc2091d_after;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
        break;

      case 109105: // subsonic characteristic inflow ->fully reflecting, p, u, v is prescribed, incl. transverse terms
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc1091e;
        nonReflectingBoundaryConditionAfterTreatmentCutOff[bcId] = &FvBndryCndXD::cbc1091e_after;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
        break;

      case 109199: // subsonic characteristic inflow/outflow switch -> uses 109104 and 109900 methods
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc1099_1091d;
        nonReflectingBoundaryConditionAfterTreatmentCutOff[bcId] = &FvBndryCndXD::cbc1099_1091d_after;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
        break;
      case 109198: // subsonic characteristic inflow/outflow switch -> uses 109104 and 109900 methods
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co; // bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;            // bc0;
        nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc1099_1091_local;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
        break;

      case 209198: // subsonic characteristic inflow/outflow switch -> uses 109104 and 109900 methods
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc1099_1091_local_comb;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
        break;

      case 309198: // subsonic characteristic inflow/outflow switch -> uses 109104 and 109900 methods
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc2099_1091_local_comb;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
        break;

      // subsonic characteristic inflow/outflow switch by crank-angle
      case 209199: // combined inflow with 309199
      case 309199:
      case 409199: // single outflow
      case 509199: // single inflow
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        if(!m_solver->m_engineSetup) {
          nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc1099_1091_engine;
          bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
        } else {
          IF_CONSTEXPR(nDim == 3) {
            nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc1099_1091_engineOld;
          }
          else {
            nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc1099_1091_engine;
            bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
          }
        }
        break;

      case 109900:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc1099;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
        break;
      case 109910:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc109910;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
        break;
      case 109911:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc109911;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
        break;

      case 109901: // subsonic characteristic outflow -> fully reflecting, p is prescribed, incl. shear and transverse
                   // terms
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        nonReflectingCutOffBoundaryCondition[bcId] = &FvBndryCndXD::cbc1099a;
        nonReflectingBoundaryConditionAfterTreatmentCutOff[bcId] = &FvBndryCndXD::cbc1099a_after;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInitCbc;
        break;

      case 10990: // simple outflow, fixed pressure
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc10990;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc1000co;
        break;

      case 10970: // simple outflow, fixed pressure
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc10970;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc1000co;
        break;

      case 10980: // simple inflow, x-direction, fixed pressure
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc10980;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc1000co;
        break;

      case 11110: // inflow/outflow from RANS
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc11110;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co; // TODO labels:FV
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;            // TODO labels:FV
        break;

      // characteristic inflow b.c. - x/y/z direction - top hat velocity profile - progress variable
      // for forced response
      case 17516:
      case 17616:
      case 17716:
      case 17816:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc17516;
        break;

      case 1251:
      case 1261:
      case 1271:
      case 1281:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc1251;
        break;

      // Round Jet inflow b.c. - x/y/z direction - parabolic velocity profile
      case 19516:
      case 19616:
      case 19716:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc19516;
        break;

      // simple outflow b.c. - x/y/z direction - progress variable
      case 17530: ///< outflow b.c - x- direction
      case 17531: ///< outflow b.c + x- direction
      case 17532: ///< outflow b.c - y- direction
      case 17533: ///< outflow b.c + y- direction
      case 17534: ///< outflow b.c - z- direction
      case 17535: ///< outflow b.c + z- direction
      case 1743: ///< outflow b.c - x+ direction
      case 1753: ///< outflow b.c - x- direction
      case 1763: ///< outflow b.c - y+ direction
      case 1773: ///< outflow b.c - y- direction
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc1753;
        break;

      // simple outflow b.c. pressure infinity - x/y/z direction - progress variable
      case 1745: ///< outflow b.c - x+ direction
      case 1755: ///< outflow b.c - x- direction
      case 1765: ///< outflow b.c - y+ direction
      case 1775: ///< outflow b.c - y- direction
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc1755;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;
        break;

      // linear shear flow (initial condition 466)
      case 17110:
      case 17111:
      case 17112:
      case 17113:
      case 17114:
      case 17115:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc17110;
        break;

      // simple outflow b.c. - pos. x/y/z direction - passive scalar
      case 1952:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc1952;
        break;

      // non-reflecting outflow b.c. - species
      case 19520:
      case 19720:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc19520;
        break;

      // simple inflow b.c. - x/y/z direction - passive scalar
      case 1156:
      case 1166:
      case 1176:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc1156;
        break;

      // supersonic inflow with acoustic and entropy waves
      case 2700:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc2700;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInit2700;
        break;
      // supersonic inflow with acoustic and entropy waves, single modes
      case 2800:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc2700;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInit2700;
        break;

      case 2770:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc2770;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInit2770;
        break;

      // extrapolation of all variables and slopes
      case 2710:
      case 2711:
      case 2712:
      case 2713:
      case 2714:
      case 2715:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc2710;
        //      bndryCndHandlerCutOffSlopesInviscid[bcId] =
        //          &FvBndryCndXD::bc2710s;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc2710co;
        break;

      // extrapolation of all variables and slopes
      case 2720:
      case 2721:
      case 2722:
      case 2723:
      case 2724:
      case 2725:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc2720;
        //      bndryCndHandlerCutOffSlopesInviscid[bcId] =
        //          &FvBndryCndXD::bc2710s;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc2720co;
        break;

      // Euler cut-off boundary condition
      case 29053:
      case 29052:
      case 29050:
      case 29051:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc29050;
        /*
        bndryCndHandlerCutOffSlopesInviscid[bcId] =
            &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] =
        &FvBndryCndXD::sbc00co;*/
        break;

      // random-eddy inflow cut-off boundary condition
      case 1601:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc1601;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInit1601;
        break;
      // random-eddy inflow cut-off boundary condition with a velocity profile (turbulent slot flame)
      case 1602:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc1602;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInit1601;
        break;
      // random-eddy inflow cut-off boundary condition with mean velocity profile for 3D round jet
      case 1603:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc1603;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInit1601;
        break;
      // random-eddy inflow cut-off BC with mean velocity profile for 3D round jet (1603 updated)
      case 1604:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc1604;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInit1601;
        break;
      // random-eddy inflow cut-off boundary condition with mean velocity profile for 3D chevron jet
      case 1606:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc1606;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInit1601;
        break;

      case 1791:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc1791;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;
        break;


      case 1792:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc1792;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;
        break;

      // outflow cut-off
      case 16010:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc16010;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;
        break;
      case 16011:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc16011;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;
        break;

      // Euler cut-off boundary condition
      case 16012:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc16012;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;
        break;
      case 16013:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc16013;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;
        break;
      case 16014:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc16014;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;
        break;
      case 16015:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc16015;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;
        break;

      //---Zonal BC---
      case 7901:
        IF_CONSTEXPR(hasPV_N<SysEqn>::value) {
          bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc7901;
          bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInit7901;
        }
        break;
      case 7902:
        IF_CONSTEXPR(hasPV_N<SysEqn>::value) {
          bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc7902;
          bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInit7902;
        }
        else mTerm(1, AT_, "BC7902 only works with a SysEqn that has PV->N");
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;
        break;
      case 7905:
        IF_CONSTEXPR(hasPV_N<SysEqn>::value) {
          bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc7905;
          bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInit7905;
        }
        else mTerm(1, AT_, "BC7905 only works with a SysEqn that has PV->N");
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;
        break;
      case 7903:
        IF_CONSTEXPR(!hasPV_N<SysEqn>::value)
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        else mTerm(1, AT_, "BC7908 only works for LES");
        break;
      case 7909:
        IF_CONSTEXPR(!hasPV_N<SysEqn>::value) {
          bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc7809;
          bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInit7809;
        }
        else mTerm(1, AT_, "BC7908 only works for LES");
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;
        break;
      case 30022:
        bndryCndHandlerCutOffVariables[bcId] = &FvBndryCndXD::bc30022;
        bndryCndHandlerCutOffSlopesInviscid[bcId] = &FvBndryCndXD::sbc00co;
        bndryCutOffViscousSlopes[bcId] = &FvBndryCndXD::sbc00co;
        bndryCndHandlerCutOffInit[bcId] = &FvBndryCndXD::bcInit30022;
        break;

      default: {
        stringstream errorMessage;
        errorMessage << "ERROR: Switch variable 'm_cutOffBndryCndIds[ bcId ]' with value " << m_cutOffBndryCndIds[bcId]
                     << " not matching any case." << endl;
        mTerm(1, AT_, errorMessage.str());
      }
    }
  }
  // set the pointer to the corresponding bc functions
  for(MInt bcId = 0; bcId < m_noBndryCndIds; bcId++) {
    switch(m_bndryCndIds[bcId]) {
      case 0:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1000;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc1000;
        break;

      case 1:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc01;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc1000;
        break;

        // Symmetry boundary condition about x-axis
      case 100100:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc100100;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1002;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc1002;
        break;

        // simple inflow b.c. - x direction
      case 1001:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1001;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2001<0>;
        break;
      case 1009:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1009;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2001<0>;
        break;
        // simple inflow b.c. - y direction
      case 1011:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1001;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2001<1>;
        break;

        // simple inflow b.c. - y direction
      case 2011:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1001coflowY;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2001<1>;
        break;
        // combined jet inflow/wall boundary condition
      case 1401:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1401;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2001<0>;
        break;
        // simple inflow b.c. - x direction - species
      case 1801:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1801;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2901<0>;
        break;
        // simple inflow b.c. - y direction - passive scalar
      case 1901:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1901;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2901<0>;
        break;
        // simple inflow b.c. - y direction - passive scalar
      case 1911:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1901;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2901<1>;
        break;
        // simple inflow b.c. - z direction - passive scalar
      case 1921:
        IF_CONSTEXPR(nDim == 3) {
          bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1901;
          //        nonReflectingBoundaryCondition[bcId] = &FvBndryCndXD::bc0;
          bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
          bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
          bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
          bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2901<2>;
        }
        else {
          TERM(-1);
        }
        break;
        // simple outflow b.c.
      case 1002:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1002;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2001<0>;
        break;

      case 1012:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1002;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2001<1>;
        break;
      case 1021:
        IF_CONSTEXPR(nDim == 3) {
          bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1001;
          //        nonReflectingBoundaryCondition[bcId] = &FvBndryCndXD::bc0;
          bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
          bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
          bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
          bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2001<2>;
        }
        else {
          TERM(-1);
        }
        break;

      case 1022:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1002;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2001<2>;
        break;

      case 1003:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1003;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2001<0>;
        break;

      case 1004:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1004;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2001<0>;
        break;

      case 1005:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1005;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2001<0>;
        break;

      // laminar tube inflow b.c. - normal direction
      case 1091:
      case 1092:
        if(m_multipleGhostCells) {
          bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1091MGC;
        } else {
          bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1091;
        }
        //        nonReflectingBoundaryCondition[bcId] = &FvBndryCndXD::bc0;
        if(m_multipleGhostCells) {
          bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0002<true>;
        } else {
          bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0002<false>;
        }
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc1000;
        break;

      // simple outflow b.c. normal direction
      case 1098:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1102;
        //      nonReflectingBoundaryCondition[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0002<false>;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc1000;
        break;
      case 1099:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1099MGC;
        //      nonReflectingBoundaryCondition[bcId] = &FvBndryCndXD::bc0;
        if(m_multipleGhostCells) {
          bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0002<true>;
        } else {
          bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0002<false>;
        }
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc1000;
        break;
      case 2001:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc2001;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2000<false>;
        break;

      case 2002:
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc2002;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc1000;
        break;

      case 2003:
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0002<false>;
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bcNeumann;
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc2003;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc1000;
        break;


      // solid wall Euler b.c.
      case 3002:
        if(m_multipleGhostCells) {
          bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0002<true>;
        } else {
          bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0002<false>;
        }

        //        nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bcNeumann;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;

        if(m_multipleGhostCells) {
          bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2000<true>;
        } else {
          bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2000<false>;
        }

        if(m_bndryCndIds[bcId] == 3002) {
          bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc3002;
        }
        break;
      case 30021:
        if(m_multipleGhostCells) {
          bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0002<true>;
        } else {
          bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0002<false>;
        }

        //        nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bcNeumann;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;

        if(m_multipleGhostCells) {
          bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2000<true>;
        } else {
          bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2000<false>;
        }

        if(m_bndryCndIds[bcId] == 30021) {
          bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc30021;
        }
        break;
      case 3399: // spalding wall model adiabatic no slip b.c. using precomputed mue_wm
        if(m_multipleGhostCells) {
          bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0002<true>;
          bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
          bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc3399<true>;
          bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2000<true>;
        } else {
          bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0002<false>;
          bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bcNeumann;
          bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc3399<false>;
          bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2000<false>;
        }
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        break;


      // solid wall b.c.
      case 3003:
      case 3009:
      case 4003: // not used for force calculation etc.
      case 3037:
      case 3905:
      case 30040:
      case 30050:
      case 4000:
      case 4001:
        if(m_multipleGhostCells) {
          bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0002<true>;
        } else {
          bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0002<false>;
        }
        //        nonReflectingBoundaryCondition[bcId] = &FvBndryCndXD::bc0;
        if(m_multipleGhostCells) {
          bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        } else {
          bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bcNeumann;
        }
        if(m_multipleGhostCells) {
          if(m_bndryCndIds[bcId] == 3003 || m_bndryCndIds[bcId] == 3009) {
            bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc3003<true>;
          } else if(m_bndryCndIds[bcId] == 3037) {
            bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc3037MGC;
          }
        } else {
          if(m_bndryCndIds[bcId] == 4000) {
            bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc4000;
            bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit4000<true>;
          } else if(m_bndryCndIds[bcId] == 4001) {
            bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc4001;
            bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit4000<true>;
          } else {
            bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc3003<false>;
          }
        }
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        if(m_multipleGhostCells) {
          bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2000<true>;
        } else {
          bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2000<false>;
        }
        break;

      case 3004:
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0002<false>;
        //        nonReflectingBoundaryCondition[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2000<false>;
        break;

      case 3005:
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0004;
        //        nonReflectingBoundaryCondition[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2000<false>;
        break;


        // isothermal solid wall b.c.
      case 3011:
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0002<false>;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bcNeumannIso;
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc3011;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        if(m_multipleGhostCells) {
          bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2000<true>;
        } else {
          bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2000<false>;
        }
        break;


      case 3006: // moving wall b.c. adiabatic
      case 3010: // moving wall b.c. isothermal
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bcNeumannMb;
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc3006;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        break;

        // moving wall b.c. without boundary slopes
      case 3060:
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bcNeumannMb;
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc3006;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::bc0;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        break;

        // moving wall euler b.c.
      case 3007:
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bcNeumannMb;
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc3007;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000; // bc0;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        break;

        // moving wall euler b.c. isothermal without slopes and Neumann-Type
      case 3008:
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bcNeumannMb;
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc3006;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::bc0; // sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        break;

        // simple and fast solid fixed adiabatic wall b.c. for non-merging small cell treatment

      case 3600:
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bc0;
        //      nonReflectingBoundaryCondition[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bcNeumann3600;
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc3600;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        break;

        // simple shear flow (initialCondition 466)
      case 3466:
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bc0;
        //      nonReflectingBoundaryCondition[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc3466;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::bc0;
        break;


        // no-slip wall b.c. (x direction) - passive scalar
      case 2907:
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0002<false>;
        //      nonReflectingBoundaryCondition[bcId] = &FvBndryCndXD::bc0;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc2907;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc1000;
        break;

        // combustion
        // (do not compute species ghost cell gradients according to sbc2000)
      case 1101:
      case 1102:
        if(m_bndryCndIds[bcId] == 1101) {
          bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1101;
        } else if(m_bndryCndIds[bcId] == 1102) {
          bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1102;
        }
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2001<0>;
        break;

      case 1111:
      case 1112:
        if(m_bndryCndIds[bcId] == 1111) {
          bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1101;
        } else if(m_bndryCndIds[bcId] == 1112) {
          bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1102;
        }
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2001<1>;
        break;

      case 1121:
      case 1122:
        if(m_bndryCndIds[bcId] == 1121) {
          bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1101;
        } else if(m_bndryCndIds[bcId] == 1122) {
          bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc1102;
        }
        //      nonReflectingBoundaryCondition[bcId] =  &FvBndryCndXD::bc0;
        bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit0001;
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc2001<2>;
        break;

      case 7909:
      case 7910:
      case 7911:
      case 7912:
      case 7913:
        // stg
        IF_CONSTEXPR(!hasPV_N<SysEqn>::value) {
          bndryCndHandlerVariables[bcId] = &FvBndryCndXD::bc7909;
          bndryCndHandlerInit[bcId] = &FvBndryCndXD::bcInit7909;
        }
        else mTerm(1, AT_, to_string(m_cutOffBndryCndIds[bcId]) + " only works for LES");
        bndryCndHandlerNeumann[bcId] = &FvBndryCndXD::bc0Var;
        bndryCndHandlerSlopesInviscid[bcId] = &FvBndryCndXD::sbc1000;
        bndryViscousSlopes[bcId] = &FvBndryCndXD::sbc1000;
        break;

      case 4100:
        mTerm(1, AT_,
              "This boundary condition id was only used for the ghost fluid solver, which has been removed in Nov. "
              "2012. There is an alternative b.c. id that uses the same methods (minus the GF stuff): 4000");
        break;

      case 4101:
        mTerm(1, AT_,
              "This boundary condition id was only used for the ghost fluid solver, which has been removed in Nov. "
              "2012. There is an alternative b.c. id that uses the same methods (minus the GF stuff): 4001");
        break;

      default: {
        std::stringstream errorMsg;
        errorMsg << "FvBndryCndXD::initBndryCells error" << std::endl
                 << "#" << bcId << " Unknown Boundary Condition Id: " << m_bndryCndIds[bcId] << std::endl;
        mTerm(1, AT_, errorMsg.str());
      }
    }
  }
}


// ---------------------------------------------------------------------------------


/** \brief creates Sponge Cells at spongeBndryCnds
 *
 * \author Stephan Schlimpert
 * \date Januar 2011, Oktober, 2011
 *
 * the sponge cells are automatically defined between the boundary edges (=sponge edges)
 * d = direction for determing songe  cells (1..5)
 * s1,s3 = directions for determing edges of sponge boundaries (or maximum sponge coordinates within domain)
 * s2 = direction for setting maximum sponge coordinate with the sponge Factor -> spongeCoord
 * sponge cells "S" determined e.g. for NEGATIVE_XWALL (o = normal cells)

 *      |                 .                |
 *      |                 .                |
 *      |                 .                |
 *      |oooooooooooooooooooooooooooooooooo|
 *      |oooooooooooooooooooooooooooooooooo|
 *      |oooooSSSSSSSSSSSSSSSSSSSSSSSoooooo|
 *      |____ SSSSSSSSSSSSSSSSSSSSSSS _____|
 *           |SSSSSSSSSSSSSSSSSSSSSSS|
 *           |SSSSSSSSSSSSSSSSSSSSSSS|
 *           |SSSSSSSSSSSSSSSSSSSSSSS|                ^
 *           |SSSSSSSSSSSSSSSSSSSSSSS|                |
 * d=0,s1=0  |_______________________|
 *
 * last change: 3D + parallel version
 *
 * \todo labels:FV radial version, sponge region at outer edges (inner edges possible), general parallel version without
 normal restriction
 *
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::createSpongeAtSpongeBndryCnds() {
  TRACE();

  MBool spongeCellsFound = false;
  MBool append = false;
  MInt bcSpId, spongeCellId;
  MInt noBndryCells = m_bndryCells->size();
  MInt s1 = -1, s2 = -1, s3 = -1; // for sponge coordinate area directions
  MFloat spongeCoordMin2 = F0, spongeCoordMax2 = F0, spongeCoordMin = F0, spongeCoordMax = F0, spongeCoordFace = F0;
  MInt cellId, currentSpongeCellId, oldSortedSpongeBndryCellsSize;
  MFloat maxSpongeFactor = 0.0, minSpongeFactor = 100.0, maxSpongeFactorOverlap = 0.0, minSpongeFactorOverlap = 100.0;
  MFloat cellFaceCoordinate = -11111.0;
  MFloat halfCellWidth = F1B2 * m_solver->c_cellLengthAtLevel(m_solver->maxRefinementLevel());
  MInt count = 0; // number of sponge cells laying in three sponge zones
  MInt cntHalo = 0;
  MInt cntHaloInside = 0;
  MFloatScratchSpace distance(m_solver->a_noCells(), AT_, "distance");
  //---

  m_solver->m_noCellsInsideSpongeLayer = 0;
  m_sortedSpongeBndryCells->setSize(0);
  for(MInt bcId = 0; bcId < m_noSpongeBndryCndIds; bcId++)
    m_spongeBndryCells[bcId] = 0;

  // reseting sponge information
  for(MInt c = 0; c < m_solver->a_noCells(); c++) {
    m_solver->a_hasProperty(c, SolverCell::IsInSpongeLayer) = false;
    m_solver->a_spongeFactor(c) = F0;
  }

  std::vector<MFloat> minSpongeCoords(2 * m_noSpongeBndryCndIds);
  std::vector<MFloat> maxSpongeCoords(2 * m_noSpongeBndryCndIds);

  // find sponge cells at boundary (see "at cut off" below)
  for(MInt bcId = 0; bcId < m_noSpongeBndryCndIds; bcId++) {
    bcSpId = m_spongeBndryCndIds[bcId];
    spongeCellsFound = false;
    spongeCoordMin = 10000;
    spongeCoordMax = -10000;
    spongeCoordMin2 = 10000;
    spongeCoordMax2 = -10000;
    spongeCoordFace = -99999999.0;
    m_spongeCoord[bcId] = -99999999.0;
    cellFaceCoordinate = -11111.0;
    m_log << "*************************************************************" << endl;
    m_log << "Information for sponge boundary Id: " << bcSpId << endl;
    m_log << "*************************************************************" << endl;

    for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
      append = false;
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == bcSpId) {
          append = true;
          break; // append spongeCellId and go to next boundary cell
        }
      }
      if(append) {
        spongeCellId = m_bndryCells->a[bndryId].m_cellId;
        m_sortedSpongeBndryCells->a[m_sortedSpongeBndryCells->size()] = spongeCellId;
        m_sortedSpongeBndryCells->append();
        spongeCellsFound = true;
        m_solver->a_hasProperty(spongeCellId, SolverCell::IsInSpongeLayer) = true;
      }
    }
    if(spongeCellsFound) {
      m_log << "Collecting " << m_sortedSpongeBndryCells->size() - m_spongeBndryCells[bcId]
            << " sponge cells at the boundary ... ";
      m_spongeBndryCells[bcId + 1] = m_sortedSpongeBndryCells->size();
      m_log << " ok" << endl;
    }

    if(!spongeCellsFound) {
      // find sponge cells at cut off
      for(MInt bcCut = 0; bcCut < m_noCutOffBndryCndIds; bcCut++) {
        if(bcSpId != m_cutOffBndryCndIds[bcCut]) continue;
        spongeCellsFound = true; // not used here but for information that sponge cells are found here
        m_log << "Collecting ";
        for(MInt id = 0; id < m_sortedCutOffCells[bcCut]->size(); id++) {
          spongeCellId = m_sortedCutOffCells[bcCut]->a[id];
          m_sortedSpongeBndryCells->a[m_sortedSpongeBndryCells->size()] = spongeCellId;
          m_sortedSpongeBndryCells->append();
          m_solver->a_hasProperty(spongeCellId, SolverCell::IsInSpongeLayer) = true;
        }
        m_spongeBndryCells[bcId + 1] = m_sortedSpongeBndryCells->size();
        m_log << m_sortedSpongeBndryCells->size() - m_spongeBndryCells[bcId]
              << " sponge cells at the cut-off boundary ... ";
        m_log << " ok" << endl;
        break;
      }
    }

    if(!spongeCellsFound || ((m_sortedSpongeBndryCells->size() - m_spongeBndryCells[bcId]) == 0)) {
      m_log << "sponge cells not yet found on domain " << domainId() << endl;
      m_spongeBndryCells[bcId + 1] = m_spongeBndryCells[bcId];
    }
    // reset the sponge factor to a positive value
    m_spongeFactor[bcId] = abs(m_spongeFactor[bcId]);

    MInt vz = -1;
    switch(m_spongeDirections[bcId]) {
      case 1:
        m_log << "POSITIVE_XWALL" << endl;
        s1 = 1;
        s2 = 0;
        s3 = 2;
        vz = 0;
        m_spongeFactor[bcId] = -m_spongeFactor[bcId];
        break;
      case 0:
        m_log << "NEGATIVE_XWALL" << endl;
        s1 = 1;
        s2 = 0;
        s3 = 2;
        vz = 1;
        break;
      case 3:
        m_log << "POSITIVE_YWALL" << endl;
        s1 = 0;
        s2 = 1;
        s3 = 2;
        vz = 0;
        m_spongeFactor[bcId] = -m_spongeFactor[bcId];
        break;
      case 2:
        m_log << "NEGATIVE_YWALL" << endl;
        s1 = 0;
        s2 = 1;
        s3 = 2;
        vz = 1;
        break;
      case 5:
        m_log << "POSITIVE_ZWALL" << endl;
        s1 = 0;
        s2 = 2;
        s3 = 1;
        vz = 0;
        m_spongeFactor[bcId] = -m_spongeFactor[bcId];
        break;
      case 4:
        m_log << "NEGATIVE_ZWALL" << endl;
        s1 = 0;
        s2 = 2;
        s3 = 1;
        vz = 1;
        break;
      default: {
        mTerm(1, AT_, "wrong sponge direction selected");
      }
    }
    TERMM_IF_COND(vz != 0 && vz != 1, "ERROR: invalid coordinate orientation of sponge vz = " + std::to_string(vz));

    IF_CONSTEXPR(nDim == 3) {
      // find min sponge edge - only for information
      for(MInt id = m_spongeBndryCells[bcId]; id < m_spongeBndryCells[bcId + 1]; id++) {
        cellId = m_sortedSpongeBndryCells->a[id];
        cellFaceCoordinate = m_solver->a_coordinate(cellId, s3) - F1B2 * m_solver->c_cellLengthAtCell(cellId);
        spongeCoordMin2 = mMin(spongeCoordMin2, cellFaceCoordinate);
      }

      // find max sponge edge - only for information
      for(MInt id = m_spongeBndryCells[bcId]; id < m_spongeBndryCells[bcId + 1]; id++) {
        cellId = m_sortedSpongeBndryCells->a[id];
        cellFaceCoordinate = m_solver->a_coordinate(cellId, s3) + F1B2 * m_solver->c_cellLengthAtCell(cellId);
        spongeCoordMax2 = mMax(spongeCoordMax2, cellFaceCoordinate);
      }

      // find min sponge edge - only for information
      for(MInt id = m_spongeBndryCells[bcId]; id < m_spongeBndryCells[bcId + 1]; id++) {
        cellId = m_sortedSpongeBndryCells->a[id];
        cellFaceCoordinate = m_solver->a_coordinate(cellId, s1) - F1B2 * m_solver->c_cellLengthAtCell(cellId);
        spongeCoordMin = mMin(spongeCoordMin, cellFaceCoordinate);
      }

      // find max sponge edge - only for information and define max sponge area in spongeCoordDirection
      for(MInt id = m_spongeBndryCells[bcId]; id < m_spongeBndryCells[bcId + 1]; id++) {
        cellId = m_sortedSpongeBndryCells->a[id];
        halfCellWidth = F1B2 * m_solver->c_cellLengthAtCell(cellId);
        cellFaceCoordinate = m_solver->a_coordinate(cellId, s1) + halfCellWidth;
        if(spongeCoordMax < cellFaceCoordinate) {
          spongeCoordMax = cellFaceCoordinate;
          if(m_spongeFactor[bcId] > 0) {
            m_spongeCoord[bcId] =
                m_solver->a_coordinate(cellId, s2) + m_spongeLayerThickness * m_spongeFactor[bcId] - halfCellWidth;
            spongeCoordFace = m_solver->a_coordinate(cellId, s2) - halfCellWidth;
          } else {
            m_spongeCoord[bcId] =
                m_solver->a_coordinate(cellId, s2) + m_spongeLayerThickness * m_spongeFactor[bcId] + halfCellWidth;
            spongeCoordFace = m_solver->a_coordinate(cellId, s2) + halfCellWidth;
          }
        }
      }

      if(noDomains() == 1) {
        if(approx(spongeCoordMin2, 10000.0, MFloatEps) || approx(spongeCoordMax2, -10000.0, MFloatEps)
           || approx(spongeCoordMin, 10000.0, MFloatEps) || approx(spongeCoordMax, -10000.0, MFloatEps)
           || approx(m_spongeCoord[bcId], -111111.0, MFloatEps)) {
          cerr << "Warning: sponge boundary Id " << bcSpId << " info ( rank " << domainId() << " ): " << endl;
          cerr << "Warning: boundary cell edge couldn't be found" << endl;
          cerr << "sponge edge coordinate[" << s3 << "] = " << spongeCoordMin2 << endl;
          cerr << "sponge edge coordinate[" << s3 << "] = " << spongeCoordMax2 << endl;
          cerr << "sponge edge coordinate[" << s1 << "] = " << spongeCoordMin << endl;
          cerr << "sponge edge coordinate[" << s1 << "] = " << spongeCoordMax << endl;
          cerr << "sponge cells defined up to coordinate[" << s2 << "] = " << m_spongeCoord[bcId] << endl;
          mTerm(1, AT_, "Warning: boundary cell edge couldn't be found");
        }
      }
    }
    else { // 2D code
      // find min sponge edge - only for information
      for(MInt id = m_spongeBndryCells[bcId]; id < m_spongeBndryCells[bcId + 1]; id++) {
        cellId = m_sortedSpongeBndryCells->a[id];
        cellFaceCoordinate = m_solver->a_coordinate(cellId, s1) - F1B2 * m_solver->c_cellLengthAtCell(cellId);
        spongeCoordMin = mMin(spongeCoordMin, cellFaceCoordinate);
      }

      // find max sponge edge - only for information and define max sponge area in spongeCoordDirection
      for(MInt id = m_spongeBndryCells[bcId]; id < m_spongeBndryCells[bcId + 1]; id++) {
        cellId = m_sortedSpongeBndryCells->a[id];
        halfCellWidth = F1B2 * m_solver->c_cellLengthAtCell(cellId);
        cellFaceCoordinate = m_solver->a_coordinate(cellId, s1) + halfCellWidth;
        if(spongeCoordMax < cellFaceCoordinate) {
          spongeCoordMax = cellFaceCoordinate;
          if(m_spongeFactor[bcId] > 0) {
            m_spongeCoord[bcId] =
                m_solver->a_coordinate(cellId, s2) + m_spongeLayerThickness * m_spongeFactor[bcId] - halfCellWidth;
            spongeCoordFace = m_solver->a_coordinate(cellId, s2) - halfCellWidth;
          } else {
            m_spongeCoord[bcId] =
                m_solver->a_coordinate(cellId, s2) + m_spongeLayerThickness * m_spongeFactor[bcId] + halfCellWidth;
            spongeCoordFace = m_solver->a_coordinate(cellId, s2) + halfCellWidth;
          }
        }
      }
      if(noDomains() == 1) {
        if(approx(spongeCoordMin, 10000.0, MFloatEps) || approx(spongeCoordMax, -10000.0, MFloatEps)
           || approx(m_spongeCoord[bcId], -111111.0, MFloatEps)) {
          mTerm(1, AT_, " boundary cell edge couldn't be found");
        }
      }
    }


    // MPI exchange of sponge coordinates + sponge boundary Id + algorithm going over all cells
    MPI_Allreduce(MPI_IN_PLACE, &spongeCoordMin, 1, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE",
                  "spongeCoordMin");
    MPI_Allreduce(MPI_IN_PLACE, &spongeCoordMax, 1, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                  "spongeCoordMax");
    IF_CONSTEXPR(nDim == 3) {
      MPI_Allreduce(MPI_IN_PLACE, &spongeCoordMin2, 1, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE",
                    "spongeCoordMin2");
      MPI_Allreduce(MPI_IN_PLACE, &spongeCoordMax2, 1, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                    "spongeCoordMax2");
    }
    MPI_Allreduce(MPI_IN_PLACE, &m_spongeCoord[bcId], 1, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                  "m_spongeCoord[ bcId ]");
    MPI_Allreduce(MPI_IN_PLACE, &spongeCoordFace, 1, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                  "spongeCoordFace");

    IF_CONSTEXPR(nDim == 3) {
      m_log << "sponge edge coordinate[" << s3 << "] = " << spongeCoordMin2 << endl;
      m_log << "sponge edge coordinate[" << s3 << "] = " << spongeCoordMax2 << endl;
    }
    m_log << "sponge edge coordinate[" << s1 << "] = " << spongeCoordMin << endl;
    m_log << "sponge edge coordinate[" << s1 << "] = " << spongeCoordMax << endl;
    m_log << "sponge face coordinate[" << s2 << "] = " << spongeCoordFace << endl;
    m_log << "sponge cells defined up to coordinate[" << s2 << "] = " << m_spongeCoord[bcId] << endl;

    minSpongeCoords[2 * bcId] = spongeCoordMin;
    minSpongeCoords[2 * bcId + 1] = spongeCoordMin2;
    maxSpongeCoords[2 * bcId] = spongeCoordMax;
    maxSpongeCoords[2 * bcId + 1] = spongeCoordMax2;

    // Check for a previous sponge boundary in the same direction and prevent overwriting its
    // values Note: this does not work properly for more than 2 sponge boundaries in one direction
    const MInt dir = m_spongeDirections[bcId];
    MBool isAdditionalSpongeInDir = false;
    MInt firstSpongeBcIdInDir = -1;
    MInt firstSpongeIdInDir = -1;
    for(MInt i = 0; i < bcId; i++) {
      if(m_spongeDirections[i] == dir) {
        isAdditionalSpongeInDir = true;
        firstSpongeBcIdInDir = m_spongeBndryCndIds[i];
        firstSpongeIdInDir = i;
        break;
      }
    }
    if(isAdditionalSpongeInDir) {
      m_log << "additional sponge in direction " << dir << ", skipping cells with BC " << firstSpongeBcIdInDir
            << " intersection" << std::endl;
    }

    // determine sponge cells
    m_log << "Creating ";
    oldSortedSpongeBndryCellsSize = m_spongeBndryCells[bcId + 1];

    for(MInt id = 0; id < m_solver->a_noCells(); id++) {
      // continue for sponge cells at boundary, already in list
      if(m_solver->a_hasProperty(id, SolverCell::IsInSpongeLayer)) continue;
      if(m_solver->c_noChildren(id) > 0) continue;

      if(vz == 0 && m_solver->a_coordinate(id, s2) < m_spongeCoord[bcId]) continue;
      if(vz == 1 && m_solver->a_coordinate(id, s2) > m_spongeCoord[bcId]) continue;

      if(m_solver->a_coordinate(id, s1) > spongeCoordMax) continue;
      if(m_solver->a_coordinate(id, s1) < spongeCoordMin) continue;
      IF_CONSTEXPR(nDim == 3) {
        if(m_solver->a_coordinate(id, s3) > spongeCoordMax2) continue;
        if(m_solver->a_coordinate(id, s3) < spongeCoordMin2) continue;
      }

      // Check for a bcId intersection if this an additional sponge in this direction
      if(isAdditionalSpongeInDir) {
        std::set<MInt> bcIds;
        MFloat line[2 * nDim];
        const MFloat halfLength = 0.5 * m_solver->c_cellLengthAtCell(id);

        MBool skip = false;

        // TODO labels:FV speedup by checking bounding box of additional sponge in direction
        MBool insideBox = true;
        {
          const MFloat pos1 = m_solver->a_coordinate(id, s1);
          const MFloat pos2 = m_solver->a_coordinate(id, s3);
          const MInt offset = 2 * firstSpongeIdInDir;
          if(pos1 + halfLength < minSpongeCoords[offset] || pos1 - halfLength > maxSpongeCoords[offset]) {
            insideBox = false;
          } else if(pos2 + halfLength < minSpongeCoords[offset + 1]
                    || pos2 - halfLength > maxSpongeCoords[offset + 1]) {
            insideBox = false;
          }
        }

        // Loop over all cell corner coordinates in the boundary plane
        if(insideBox) {
          const MFloat outDir = (vz == 0) ? 1.0 : -1.0;
          for(MInt i = 0; i < 2 && !skip; i++) {
            for(MInt j = 0; j < (nDim - 1) && !skip; j++) {
              std::copy_n(&m_solver->a_coordinate(id, 0), nDim, &line[0]);
              std::copy_n(&m_solver->a_coordinate(id, 0), nDim, &line[nDim]);
              // Second point lies outside the geometry
              line[s2] = line[s2] + outDir * 2 * m_solver->c_cellLengthAtLevel(0);

              line[s1] -= pow(-1.0, i) * halfLength;
              line[s1 + nDim] = line[s1];

              IF_CONSTEXPR(nDim == 3) {
                line[s3] -= pow(-1.0, j) * halfLength;
                line[s3 + nDim] = line[s3];
              }

              // Get boundary condition ids cut by the line from the cell corner through the
              // boundary plane and check if the first sponge-bc id is present and skip if so
              m_solver->m_geometry->getLineIntersectingElementsBcIds(line, bcIds);
              if(bcIds.size() > 0 && (bcIds.count(firstSpongeBcIdInDir) > 0)) {
                skip = true;
              }
            }
          }
        }
        if(skip) continue;
      }

      m_sortedSpongeBndryCells->a[m_sortedSpongeBndryCells->size()] = id;
      m_sortedSpongeBndryCells->append();
    }
    m_spongeBndryCells[bcId + 1] = m_sortedSpongeBndryCells->size();
    // reseting property 14, will be set later and needed for spongefactor calculation
    for(MInt id = m_spongeBndryCells[bcId]; id < m_spongeBndryCells[bcId + 1]; id++) {
      currentSpongeCellId = m_sortedSpongeBndryCells->a[id];
      m_solver->a_hasProperty(currentSpongeCellId, SolverCell::IsInSpongeLayer) = false;
    }

    if(noDomains() == 0) {
      if(oldSortedSpongeBndryCellsSize == m_sortedSpongeBndryCells->size()) {
        m_log << "Warning: Only first row of sponge boundary ID " << m_spongeBndryCndIds[bcId]
              << " was identified as sponge cells" << endl;
        m_log << "         Possible reason could be that the spongeFactor has to be multiplied by -1" << endl;
        m_log << "       Possible reason could be wrong sponge coordinates communicated" << endl;
        cerr << "Warning: Only first row of sponge boundary ID " << m_spongeBndryCndIds[bcId]
             << " was identified as sponge cells" << endl;
        cerr << "         Possible reason could be that the spongeFactor has to be multiplied by -1" << endl;
        cerr << "         Possible reason could be wrong sponge coordinates communicated" << endl;
      }
    }
    m_log << m_sortedSpongeBndryCells->size() - oldSortedSpongeBndryCellsSize << " additional sponge cells ... ";
    m_log << " ok" << endl;
    m_spongeBndryCells[bcId + 1] = m_sortedSpongeBndryCells->size();
    m_log << "total number of sponge cells " << m_spongeBndryCells[bcId + 1] - m_spongeBndryCells[bcId] << endl;
    m_log << "*************************************************" << endl << endl;
    MInt startBcId = 0;
    MInt endBcId = bcId;

    // setting sponge information for all other sponge boundary ids, which were already identified to identifiy
    // overlapping sponge cells and sponge boundary ids
    for(MInt id = m_spongeBndryCells[startBcId]; id < m_spongeBndryCells[endBcId]; id++) {
      spongeCellId = m_sortedSpongeBndryCells->a[id];
      m_solver->a_hasProperty(spongeCellId, SolverCell::IsInSpongeLayer) = true;
    }

    switch(m_spongeLayerLayout) {
      case 0: {
        const MFloat spongeThicknessEpsilon = m_spongeLayerThickness / 10000000.0;
        MFloat spongeEpsilon = m_solver->c_cellLengthAtLevel(m_solver->maxRefinementLevel()) / 1000.0;
        MFloat beta = m_spongeBeta;
        MFloat constant;
        MFloat spongeFactorBcId = m_spongeLayerThickness * abs(m_spongeFactor[bcId]);
        MFloat spongeDistanceFactor = F1 / (mMax(spongeEpsilon, spongeFactorBcId));
        MFloat spongeDistance = F0;

        for(MInt id = m_spongeBndryCells[bcId]; id < m_spongeBndryCells[bcId + 1]; id++) {
          bcSpId = m_spongeBndryCndIds[bcId];
          spongeCellId = m_sortedSpongeBndryCells->a[id];
          if(m_solver->a_isHalo(spongeCellId)) cntHalo++;
          // compute the max sigma sponge value if already identified in one sponge area
          if(m_solver->a_hasProperty(spongeCellId, SolverCell::IsInSpongeLayer)) {
            // compute the distance to the spongeCoordinate
            spongeDistance = abs(m_solver->a_coordinate(spongeCellId, s2) - m_spongeCoord[bcId]) * spongeDistanceFactor;
            distance.p[spongeCellId] = mMax(distance.p[spongeCellId], spongeDistance);
            // compute the dissipation function...
            //    if(bcSpId==17616)
            //  constant = tanh(distance.p[spongeCellId]*5.0);
            // else
            constant = pow(distance.p[spongeCellId], beta);
            constant *= m_sigmaSpongeBndryId[bcId];

            // if distance to small than sponge cell keeps the spongeFactor that it already owns
            if(distance.p[spongeCellId] > spongeThicknessEpsilon) {
              if(m_solver->a_spongeBndryId(spongeCellId, 1) == -1) {
                // second sponge Id of the sponge cell which lays in two sponge areas
                m_solver->a_spongeBndryId(spongeCellId, 1) = bcSpId;
                // compute the max sponge Factor for sponge cells which are laying in two sponge areas
                m_solver->a_spongeFactor(spongeCellId) = mMax(constant, m_solver->a_spongeFactor(spongeCellId));
              } else if(nDim == 3 && m_solver->a_spongeBndryId(spongeCellId, 2) == -1) {
                // third sponge Id of the sponge cell which lays in third sponge areas (only possible for 3 dimensional
                // cases)
                m_solver->a_spongeBndryId(spongeCellId, 2) = bcSpId;
                m_solver->a_spongeFactor(spongeCellId) = mMax(constant, m_solver->a_spongeFactor(spongeCellId));
                if(!m_solver->a_isHalo(spongeCellId)) count++;
                IF_CONSTEXPR(nDim == 2) {
                  cerr << "ERROR: three sponge boundary Ids: " << m_solver->a_spongeBndryId(spongeCellId, 0) << ", "
                       << m_solver->a_spongeBndryId(spongeCellId, 1) << ", ";
                  cerr << m_solver->a_spongeBndryId(spongeCellId, 2)
                       << "founded for one cell -> not possible for 2 dimensional case" << endl;
                  stringstream errorMessage;
                  errorMessage << " three sponge boundary Ids: " << m_solver->a_spongeBndryId(spongeCellId, 0) << ", "
                               << m_solver->a_spongeBndryId(spongeCellId, 1) << ", "
                               << m_solver->a_spongeBndryId(spongeCellId, 2)
                               << "founded for one cell -> not possible for 2 dimensional case";
                  mTerm(1, AT_, errorMessage.str());
                }
              } else {
                stringstream errorMessage;
                IF_CONSTEXPR(nDim == 3) {
                  errorMessage << "four sponge boundary Ids: " << m_solver->a_spongeBndryId(spongeCellId, 0) << ", "
                               << m_solver->a_spongeBndryId(spongeCellId, 1) << ", "
                               << m_solver->a_spongeBndryId(spongeCellId, 2) << ", " << bcSpId
                               << "founded for one cell -> not possible for 3 dimensional case";
                }
                else {
                  errorMessage << "three sponge boundary Ids: " << m_solver->a_spongeBndryId(spongeCellId, 0) << ", "
                               << m_solver->a_spongeBndryId(spongeCellId, 1) << ", " << bcSpId
                               << "founded for one cell -> not possible for 2 dimensional case";
                }
                mTerm(1, AT_, errorMessage.str());
              }
              if(m_solver->m_spongeTimeDependent[bcId] > 0)
                m_solver->a_spongeFactorStart(spongeCellId) = m_solver->a_spongeFactor(spongeCellId);

              maxSpongeFactorOverlap = mMax(maxSpongeFactorOverlap, m_solver->a_spongeFactor(spongeCellId));
              minSpongeFactorOverlap = mMin(minSpongeFactorOverlap, m_solver->a_spongeFactor(spongeCellId));
              // if(!(m_solver->a_spongeFactor(spongeCellId))<=0 && !(m_solver->a_spongeFactor(spongeCellId)) >=0)
              //  cerr << m_solver->a_spongeFactor(spongeCellId)<< endl;
            }
          } else { // cells which are not already identified as sponge cells

            m_solver->a_spongeFactor(spongeCellId) = F0;
            // compute the distance to the spongeCoordinate
            distance.p[spongeCellId] =
                abs(m_solver->a_coordinate(spongeCellId, s2) - m_spongeCoord[bcId]) * spongeDistanceFactor;
            // compute the dissipation function...
            // if(bcSpId==17616)
            //  constant = tanh(distance.p[spongeCellId]*5.0);
            // else
            constant = pow(distance.p[spongeCellId], beta);
            constant *= m_sigmaSpongeBndryId[bcId];

            if(distance.p[spongeCellId] > spongeThicknessEpsilon) {
              m_solver->m_cellsInsideSpongeLayer[m_solver->m_noCellsInsideSpongeLayer] = spongeCellId;
              m_solver->m_noCellsInsideSpongeLayer++;
              if(m_solver->a_isHalo(spongeCellId)) cntHaloInside++;

              m_solver->a_hasProperty(spongeCellId, SolverCell::IsInSpongeLayer) = true;
              m_solver->a_spongeFactor(spongeCellId) = constant;
              if(m_solver->m_spongeTimeDependent[bcId] > 0) m_solver->a_spongeFactorStart(spongeCellId) = constant;

              m_solver->a_spongeBndryId(spongeCellId, 0) = bcSpId;
              m_solver->a_spongeBndryId(spongeCellId, 1) =
                  -1; // second possible sponge Id if the cell is laying in two sponge areas
              // for 3 dimensional case
              IF_CONSTEXPR(nDim == 3) {
                m_solver->a_spongeBndryId(spongeCellId, 2) =
                    -1; // third possible sponge Id if the cell is laying in two sponge areas
              }
              //   if(!(m_solver->a_spongeFactor( spongeCellId ))<=0 && !(m_solver->a_spongeFactor( spongeCellId )) >=0)
              //   {
              //  cerr << m_solver->a_spongeFactor( spongeCellId ) << endl;
              //  mTerm(1,AT_);
              // }
              maxSpongeFactor = mMax(maxSpongeFactor, m_solver->a_spongeFactor(spongeCellId));
              minSpongeFactor = mMin(minSpongeFactor, m_solver->a_spongeFactor(spongeCellId));
            }
          }
        }
        break;
      }
        // tanh function for sponge forcing
      case 10: {
        const MFloat spongeThicknessEpsilon = m_spongeLayerThickness / 10000000.0;
        MFloat spongeEpsilon = m_solver->c_cellLengthAtLevel(m_solver->maxRefinementLevel()) / 1000.0;
        MFloat constant;
        MFloat spongeFactorBcId = m_spongeLayerThickness * abs(m_spongeFactor[bcId]);
        MFloat spongeDistanceFactor = F1 / (mMax(spongeEpsilon, spongeFactorBcId));
        MFloat spongeDistance = F0;
        /*
          if(m_spongeBndryCndIds[bcId]==17616 && m_solver->m_spongeTimeDependent[bcId]>0){
          MString errorMessage="check code for bcId 17616 and sponge time dependent because tanh function for
          spongeFactor calc is used"; mTerm(AT_,1,errorMessage);
          }
        */
        for(MInt id = m_spongeBndryCells[bcId]; id < m_spongeBndryCells[bcId + 1]; id++) {
          bcSpId = m_spongeBndryCndIds[bcId];
          spongeCellId = m_sortedSpongeBndryCells->a[id];
          if(m_solver->a_isHalo(spongeCellId)) cntHalo++;
          // compute the max sigma sponge value if already identified in one sponge area
          if(m_solver->a_hasProperty(spongeCellId, SolverCell::IsInSpongeLayer)) {
            // compute the distance to the spongeCoordinate
            spongeDistance = abs(m_solver->a_coordinate(spongeCellId, s2) - m_spongeCoord[bcId]) * spongeDistanceFactor;
            distance.p[spongeCellId] = mMax(distance.p[spongeCellId], spongeDistance);
            // compute the dissipation function...
            constant = F1 - F1B2 * tanh(5.0) + F1B2 * tanh((F2 * (distance.p[spongeCellId]) - F1) * 5.0);
            constant *= m_sigmaSpongeBndryId[bcId];
            // if distance to small than sponge cell keeps the spongeFactor that it already owns
            if(distance.p[spongeCellId] > spongeThicknessEpsilon) {
              if(m_solver->a_spongeBndryId(spongeCellId, 1) == -1) {
                // second sponge Id of the sponge cell which lays in two sponge areas
                m_solver->a_spongeBndryId(spongeCellId, 1) = bcSpId;
                // compute the max sponge Factor for sponge cells which are laying in two sponge areas
                m_solver->a_spongeFactor(spongeCellId) = mMax(constant, m_solver->a_spongeFactor(spongeCellId));
              } else if(nDim == 3 && m_solver->a_spongeBndryId(spongeCellId, 2) == -1) {
                // third sponge Id of the sponge cell which lays in third sponge areas (only possible for 3 dimensional
                // cases)
                m_solver->a_spongeBndryId(spongeCellId, 2) = bcSpId;
                m_solver->a_spongeFactor(spongeCellId) = mMax(constant, m_solver->a_spongeFactor(spongeCellId));
                if(!m_solver->a_isHalo(spongeCellId)) count++;
                IF_CONSTEXPR(nDim == 2) {
                  cerr << "ERROR: three sponge boundary Ids: " << m_solver->a_spongeBndryId(spongeCellId, 0) << ", "
                       << m_solver->a_spongeBndryId(spongeCellId, 1) << ", ";
                  cerr << m_solver->a_spongeBndryId(spongeCellId, 2)
                       << "founded for one cell -> not possible for 2 dimensional case" << endl;
                  mTerm(1, AT_);
                }
              } else {
                cerr << "ERROR: four sponge boundary Ids: " << m_solver->a_spongeBndryId(spongeCellId, 0) << ", "
                     << m_solver->a_spongeBndryId(spongeCellId, 1) << ", ";
                cerr << m_solver->a_spongeBndryId(spongeCellId, 2) << ", " << bcSpId
                     << "founded for one cell -> not possible for 3 dimensional case" << endl;
                mTerm(1, AT_);
              }

              if(m_solver->m_spongeTimeDependent[bcId] > 0)
                m_solver->a_spongeFactorStart(spongeCellId) = m_solver->a_spongeFactor(spongeCellId);

              maxSpongeFactorOverlap = mMax(maxSpongeFactorOverlap, m_solver->a_spongeFactor(spongeCellId));
              minSpongeFactorOverlap = mMin(minSpongeFactorOverlap, m_solver->a_spongeFactor(spongeCellId));
              // if(!(m_solver->a_spongeFactor( spongeCellId))<=0 && !(m_solver->a_spongeFactor( spongeCellId)) >=0)
              //  cerr << m_solver->a_spongeFactor(spongeCellId) << endl;
            }
          } else { // cells which are not already identified as sponge cells

            m_solver->a_spongeFactor(spongeCellId) = F0;
            // compute the distance to the spongeCoordinate
            distance.p[spongeCellId] =
                abs(m_solver->a_coordinate(spongeCellId, s2) - m_spongeCoord[bcId]) * spongeDistanceFactor;
            // compute the dissipation function...
            constant =
                F1 - F1B2 * tanh(5.0) + F1B2 * tanh((F2 * (distance.p[spongeCellId]) - F1) * 5.0); // stephans tanh
            // constant = POW2(distance.p[spongeCellId]); // standard x^2
            // constant = F1B2 - F1B2*cos(PI*distance.p[spongeCellId]);

            constant *= m_sigmaSpongeBndryId[bcId];

            if(distance.p[spongeCellId] > spongeThicknessEpsilon) {
              m_solver->m_cellsInsideSpongeLayer[m_solver->m_noCellsInsideSpongeLayer] = spongeCellId;
              m_solver->m_noCellsInsideSpongeLayer++;
              if(m_solver->a_isHalo(spongeCellId)) cntHaloInside++;

              m_solver->a_hasProperty(spongeCellId, SolverCell::IsInSpongeLayer) = true;
              m_solver->a_spongeFactor(spongeCellId) = constant;
              if(m_solver->m_spongeTimeDependent[bcId] > 0) m_solver->a_spongeFactorStart(spongeCellId) = constant;

              m_solver->a_spongeBndryId(spongeCellId, 0) = bcSpId;
              m_solver->a_spongeBndryId(spongeCellId, 1) =
                  -1; // second possible sponge Id if the cell is laying in two sponge areas
              // for 3 dimensional case
              IF_CONSTEXPR(nDim == 3) {
                m_solver->a_spongeBndryId(spongeCellId, 2) =
                    -1; // third possible sponge Id if the cell is laying in two sponge areas
              }
              //   if(!(m_solver->a_spongeFactor( spongeCellId ))<=0 && !(m_solver->a_spongeFactor( spongeCellId )) >=0)
              //   {
              //  cerr << m_solver->a_spongeFactor( spongeCellId ) << endl;
              //  mTerm(1,AT_);
              // }
              maxSpongeFactor = mMax(maxSpongeFactor, m_solver->a_spongeFactor(spongeCellId));
              minSpongeFactor = mMin(minSpongeFactor, m_solver->a_spongeFactor(spongeCellId));
            }
          }
        }
        break;
      }
      default: {
        stringstream errorMessage;
        errorMessage << "ERROR: spongeLayerLayout " << m_spongeLayerLayout << " does not exist!" << endl;
        mTerm(1, AT_, errorMessage.str());
      }
    }
    // reseting sponge information of all boundary Ids to identifiy overlapping sponge cells at more than one boundary
    for(MInt id = m_spongeBndryCells[startBcId]; id < m_spongeBndryCells[bcId + 1]; id++) {
      spongeCellId = m_sortedSpongeBndryCells->a[id];
      m_solver->a_hasProperty(spongeCellId, SolverCell::IsInSpongeLayer) = false;
    }
  }
  MInt noHaloSpongeCells = cntHalo;
  MInt noSpongeCells = m_spongeBndryCells[m_noSpongeBndryCndIds] - cntHalo;
  MInt noInternalSpongeCells = m_solver->m_noCellsInsideSpongeLayer - cntHaloInside;
  MInt noOverlappingSpongeCells3d = count;

  MPI_Allreduce(MPI_IN_PLACE, &noHaloSpongeCells, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "noHaloSpongeCells");
  MPI_Allreduce(MPI_IN_PLACE, &noSpongeCells, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "noSpongeCells");
  MPI_Allreduce(MPI_IN_PLACE, &noInternalSpongeCells, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "noInternalSpongeCells");

  IF_CONSTEXPR(nDim == 3)
  MPI_Allreduce(MPI_IN_PLACE, &noOverlappingSpongeCells3d, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "noOverlappingSpongeCells3d");
  MPI_Allreduce(MPI_IN_PLACE, &maxSpongeFactor, 1, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                "maxSpongeFactor");
  MPI_Allreduce(MPI_IN_PLACE, &minSpongeFactor, 1, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE",
                "minSpongeFactor");
  MPI_Allreduce(MPI_IN_PLACE, &maxSpongeFactorOverlap, 1, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                "maxSpongeFactorOverlap");
  MPI_Allreduce(MPI_IN_PLACE, &minSpongeFactorOverlap, 1, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE",
                "minSpongeFactorOverlap");

  m_log << "*********************" << endl;
  m_log << "Sponge cell summary" << endl;
  m_log << "*********************" << endl;
  m_log << noSpongeCells << " sponge cells + " << endl;
  m_log << noHaloSpongeCells << " sponge halo cells created" << endl;
  m_log << "with " << noInternalSpongeCells << " internal sponge cells and " << endl;
  m_log << "with " << noSpongeCells - noInternalSpongeCells - noOverlappingSpongeCells3d
        << " sponge cells laying in 2 sponge areas and " << endl;
  m_log << "with " << noOverlappingSpongeCells3d << " sponge cells laying in 3 sponge areas " << endl;
  m_log << "max sponge factor: " << maxSpongeFactor << endl;
  m_log << "min sponge factor: " << minSpongeFactor << endl;
  m_log << "max sponge factor overlap: " << maxSpongeFactorOverlap << endl;
  m_log << "min sponge factor overlap: " << minSpongeFactorOverlap << endl;
  m_log << endl;
  if((!(maxSpongeFactor >= F0) && !(maxSpongeFactor <= F0)) || (!(minSpongeFactor >= F0) && !(minSpongeFactor <= F0))) {
    mTerm(1, AT_, "error: maximum sponge factor is nan");
  }
  if(maxSpongeFactor < 0 || minSpongeFactor < 0) {
    mTerm(1, AT_, "sponge Factor is negative");
  }
  if(m_spongeTimeDep) {
    m_log << "***********************************" << endl;
    m_log << "Time dependent sponge cell summary" << endl;
    m_log << "***********************************" << endl;
    for(MInt bcId = 0; bcId < m_noSpongeBndryCndIds; bcId++) {
      bcSpId = m_spongeBndryCndIds[bcId];
      if(m_spongeTimeDependent[bcId] < 1) continue;
      if(m_spongeTimeDependent[bcId] == 1) {
        m_log << "time dependent sponge decreasing function at sponge boundary " << bcSpId << endl;
        m_log << "sponge decreasing start at iteration: " << m_spongeStartIteration[bcId] << endl;
        m_log << "sponge decreasing end at iteration: " << m_spongeEndIteration[bcId] << endl;
        m_log << "sponge start value: " << m_sigmaSpongeBndryId[bcId] << endl;
        m_log << "sponge end value will be zero" << endl << endl;
      } else if(m_spongeTimeDependent[bcId] == 2) {
        m_log << "time dependent sponge increasing function at sponge boundary " << bcSpId << endl;
        m_log << "sponge increasing start at iteration: " << m_spongeStartIteration[bcId] << endl;
        m_log << "sponge increasing end at iteration: " << m_spongeEndIteration[bcId] << endl << endl;
      } else if(m_spongeTimeDependent[bcId] == 3) {
        m_log << "time dependent sponge decreasing function at sponge boundary " << bcSpId << endl;
        m_log << "sponge decreasing start at iteration: " << m_spongeStartIteration[bcId] << endl;
        m_log << "sponge decreasing end at iteration: " << m_spongeEndIteration[bcId] << endl;
        m_log << "sponge start value: " << m_sigmaSpongeBndryId[bcId] << endl;
        m_log << "sponge end value: " << m_sigmaEndSpongeBndryId[bcId] << endl << endl;
      }
    }
  }

  // setting property 14 for all sponge cells
  for(MInt bcId = 0; bcId < m_noSpongeBndryCndIds; bcId++) {
    for(MInt id = m_spongeBndryCells[bcId]; id < m_spongeBndryCells[bcId + 1]; id++) {
      spongeCellId = m_sortedSpongeBndryCells->a[id];
      m_solver->a_hasProperty(spongeCellId, SolverCell::IsInSpongeLayer) = true;
    }
  }

  // this following line should be removed if we switch to a use of function pointers to the specific sponge bounary
  // condition
  m_sortedSpongeBndryCells->setSize(0);
}

// --------------------------------------------------------------------


/** \brief Sets up the reconstruction stencil for boundary cells
 *
 * \author Daniel Hartmann
 *
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bcInit0001(MInt bcId) {
  TRACE();

  MInt noDirs = 2 * nDim;
  MInt cellId;
  MInt bndryId;
  MInt nghbrId;
  MInt ghostCellId;
  MInt temp;
  MInt bnd;
  MInt id;
  MInt linkedCell;
  MInt noReconstructIds = 0;
  ScratchSpace<MInt> reconstructIds(100, AT_, "reconstructIds");
  //---

  for(MInt bc = m_bndryCndCells[bcId]; bc < m_bndryCndCells[bcId + 1]; bc++) {
    bndryId = m_sortedBndryCells->a[bc];
    cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      if(m_bndryCells->a[bndryId].m_linkedCellId == -1) {
        // reset
        noReconstructIds = 0;

        // add the ghost cell
        ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;
        reconstructIds[noReconstructIds] = ghostCellId;
        noReconstructIds++;

        // add all neighbors
        for(MInt c = m_solver->m_identNghbrIds[cellId * noDirs]; c < m_solver->m_identNghbrIds[(cellId + 1) * noDirs];
            c++) {
          reconstructIds[noReconstructIds] = m_solver->m_storeNghbrIds[c];
          noReconstructIds++;
        }

        // identify boundary neighbors: add their internal neighbors
        temp = noReconstructIds;
        for(MInt k = 0; k < temp; k++) {
          id = reconstructIds[k];
          bnd = m_solver->a_bndryId(id);
          if(bnd > -1) {
            for(MInt c = m_solver->m_identNghbrIds[id * noDirs]; c < m_solver->m_identNghbrIds[(id + 1) * noDirs];
                c++) {
              nghbrId = m_solver->m_storeNghbrIds[c];
              if(m_solver->a_bndryId(nghbrId) == -1) {
                reconstructIds[noReconstructIds] = nghbrId;
                noReconstructIds++;
              }
            }
          }
        }

        // replace slave neighbors by their master cells
        // if master==cellId add all neighbors of the slave cell
        temp = noReconstructIds;
        for(MInt k = 0; k < temp; k++) {
          id = reconstructIds[k];
          bnd = m_solver->a_bndryId(id);
          if(bnd > -1) {
            linkedCell = m_bndryCells->a[bnd].m_linkedCellId;
            if(linkedCell > -1) {
              reconstructIds[k] = linkedCell;
              if(linkedCell == cellId) {
                for(MInt c = m_solver->m_identNghbrIds[id * noDirs]; c < m_solver->m_identNghbrIds[(id + 1) * noDirs];
                    c++) {
                  nghbrId = m_solver->m_storeNghbrIds[c];
                  if(m_solver->a_bndryId(nghbrId) > -1) {
                    if(m_bndryCells->a[m_solver->a_bndryId(nghbrId)].m_linkedCellId == -1) {
                      reconstructIds[noReconstructIds] = nghbrId;
                      noReconstructIds++;
                    } else {
                      reconstructIds[noReconstructIds] = m_bndryCells->a[m_solver->a_bndryId(nghbrId)].m_linkedCellId;
                      noReconstructIds++;
                    }
                  } else {
                    reconstructIds[noReconstructIds] = nghbrId;
                    noReconstructIds++;
                  }
                }
              }
            }
          }
        }

        // remove cellId from list
        temp = noReconstructIds;
        for(MInt k = temp - 1; k > -1; k--) {
          if(reconstructIds[k] == cellId) {
            noReconstructIds--;
            reconstructIds[k] = reconstructIds[noReconstructIds];
          }
        }

        // sort the list
        maia::math::quickSort(reconstructIds.begin(), 0, noReconstructIds - 1);
        m_solver->a_noReconstructionNeighbors(cellId) =
            mMin(m_cells.noRecNghbrs(), maia::math::removeDoubleEntries(reconstructIds.begin(), noReconstructIds));

        for(MInt k = 0; k < m_solver->a_noReconstructionNeighbors(cellId); k++) {
          m_solver->a_reconstructionNeighborId(cellId, k) = reconstructIds[k];
        }
      }
    }
  }
}


//---------------------------------------------------------------------------------------------


/** \brief Sets up the reconstruction stencil for boundary cells
 *
 *         Sets up the reconstruction stencil for the modified Neumann bc
 *         and stores the necessary data in the ghost cell
 *
 *         IF MGC
 *          Adds all ghost cells belonging to all boundary surfaces of both master and small cells to the masters
 * reconstruction stencil
 *
 * \author Daniel Hartmann, Sven Berger
 *
 */
template <MInt nDim, class SysEqn>
template <MBool MGC>
void FvBndryCndXD<nDim, SysEqn>::bcInit0002(MInt bcId) {
  TRACE();

  static constexpr MInt noDirs = 2 * nDim;
  MInt temp = 0;
  MInt noReconstructIds = 0;
  MIntScratchSpace reconstructIds(MGC ? 100 : noDirs + 1, AT_, "reconstructIds");
  //---

  // loop over all non-slave boundary cells
  for(MInt bc = m_bndryCndCells[bcId]; bc < m_bndryCndCells[bcId + 1]; bc++) {
    const MInt bndryId = m_sortedBndryCells->a[bc];
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInvalid)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      if((!MGC && m_bndryCells->a[bndryId].m_linkedCellId == -1)
         || (MGC && m_bndryCells->a[bndryId].m_linkedCellId > -1)) {
        // reset
        noReconstructIds = 0;

        if(MGC) {
          // add the ghost cell
          for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
            reconstructIds[noReconstructIds] = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
            noReconstructIds++;
          }
        } else {
          // add the ghost cell
          reconstructIds.p[noReconstructIds] = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;
          noReconstructIds = 1;
        }

        // add all neighbors
        for(MInt c = m_solver->m_identNghbrIds[cellId * noDirs]; c < m_solver->m_identNghbrIds[(cellId + 1) * noDirs];
            c++) {
          reconstructIds.p[noReconstructIds] = m_solver->m_storeNghbrIds[c];
          noReconstructIds++;
        }

        // replace slave neighbors by their master cells
        // if master==cellId add all neighbors of the slave cell
        temp = noReconstructIds;
        for(MInt k = 0; k < temp; k++) {
          const MInt id = reconstructIds.p[k];
          if(m_solver->a_bndryId(id) > -1) {
            const MInt linkedCell = m_bndryCells->a[m_solver->a_bndryId(id)].m_linkedCellId;
            if(linkedCell > -1) {
              reconstructIds.p[k] = linkedCell;
              if(linkedCell == cellId) {
                for(MInt c = m_solver->m_identNghbrIds[id * noDirs]; c < m_solver->m_identNghbrIds[(id + 1) * noDirs];
                    c++) {
                  const MInt nghbrId = m_solver->m_storeNghbrIds[c];
                  if(m_solver->a_bndryId(nghbrId) > -1) {
                    if(m_bndryCells->a[m_solver->a_bndryId(nghbrId)].m_linkedCellId == -1) {
                      reconstructIds.p[noReconstructIds] = nghbrId;
                      noReconstructIds++;
                    } else {
                      reconstructIds.p[noReconstructIds] = m_bndryCells->a[m_solver->a_bndryId(nghbrId)].m_linkedCellId;
                      noReconstructIds++;
                    }
                  } else {
                    reconstructIds.p[noReconstructIds] = nghbrId;
                    noReconstructIds++;
                  }
                }
                if(MGC) {
                  MInt bnd = m_solver->a_bndryId(id);
                  // add other ghost-cells to the reconstruction stencil
                  for(MInt srfcSM = 0; srfcSM < m_bndryCells->a[bnd].m_noSrfcs; srfcSM++) {
                    reconstructIds[noReconstructIds] = m_bndryCells->a[bnd].m_srfcVariables[srfcSM]->m_ghostCellId;
                    noReconstructIds++;
                  }
                }
              }
            }
          }
        }

        // remove cellId from list
        temp = noReconstructIds;
        for(MInt k = temp - 1; k > -1; k--) {
          if(reconstructIds.p[k] == cellId) {
            noReconstructIds--;
            reconstructIds.p[k] = reconstructIds.p[noReconstructIds];
          }
        }

        // sort the list
        maia::math::quickSort(reconstructIds.getPointer(), 0, noReconstructIds - 1);
        m_solver->a_noReconstructionNeighbors(cellId) =
            maia::math::removeDoubleEntries(reconstructIds.getPointer(), noReconstructIds);

        for(MInt k = 0; k < m_solver->a_noReconstructionNeighbors(cellId); k++) {
          m_solver->a_reconstructionNeighborId(cellId, k) = reconstructIds.p[k];
        }
      }
    }
  }

  // compute the least-squares constants k_i for the ghost cell (Neumann bc)
  if(!MGC) {
    computeNeumannLSConstants(bcId);
  }
}


//---------------------------------------------------------------------------------------------


/** \brief Sets up the reconstruction stencil for boundary cells (quadratic least-squares reconstruction)
 *
 *         Sets up the reconstruction stencil for the modified Neumann bc
 *         and stores the necessary data in the ghost cell
 *
 * \author Daniel Hartmann
 *
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bcInit0004(MInt bcId) {
  TRACE();

  MInt noDirs = 2 * nDim;
  MInt requiredNoCells, tmpCell;
  IF_CONSTEXPR(nDim == 2) requiredNoCells = 7;
  IF_CONSTEXPR(nDim == 3) requiredNoCells = 9;
  MInt cellId, bndryId, nghbrId, ghostCellId, temp, bnd, id, linkedCell;
  MInt noReconstructIds;
  MIntScratchSpace reconstructIds(100, AT_, "reconstructIds");
  stack<MInt> tmpStack;
  //---

  // loop over all non-slave boundary cells
  for(MInt bc = m_bndryCndCells[bcId]; bc < m_bndryCndCells[bcId + 1]; bc++) {
    bndryId = m_sortedBndryCells->a[bc];
    cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      if(m_bndryCells->a[bndryId].m_linkedCellId == -1) {
        // reset
        noReconstructIds = 0;

        // add the ghost cell
        ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;
        reconstructIds[noReconstructIds] = ghostCellId;
        noReconstructIds++;

        // add all neighbors
        for(MInt c = m_solver->m_identNghbrIds[cellId * noDirs]; c < m_solver->m_identNghbrIds[(cellId + 1) * noDirs];
            c++) {
          reconstructIds[noReconstructIds] = m_solver->m_storeNghbrIds[c];
          noReconstructIds++;
          tmpStack.push(m_solver->m_storeNghbrIds[c]);
        }

        while(noReconstructIds < requiredNoCells) {
          // put all cells on s stack
          for(MInt n = 0; n < noReconstructIds; n++) {
            tmpStack.push(reconstructIds[n]);
          }

          // add all neighbors of reconstructIds
          while(!tmpStack.empty()) {
            tmpCell = tmpStack.top();
            tmpStack.pop();
            for(MInt c = m_solver->m_identNghbrIds[tmpCell * noDirs];
                c < m_solver->m_identNghbrIds[(tmpCell + 1) * noDirs];
                c++) {
              reconstructIds[noReconstructIds] = m_solver->m_storeNghbrIds[c];
              noReconstructIds++;
            }
          }

          // replace slave neighbors by their master cells
          // a) if master==cellId add all neighbors of the slave cell
          temp = noReconstructIds;
          for(MInt k = 0; k < temp; k++) {
            id = reconstructIds[k];
            bnd = m_solver->a_bndryId(id);
            if(bnd > -1) {
              linkedCell = m_bndryCells->a[bnd].m_linkedCellId;
              if(linkedCell > -1) {
                reconstructIds[k] = linkedCell;
                if(linkedCell == cellId) {
                  for(MInt c = m_solver->m_identNghbrIds[id * noDirs]; c < m_solver->m_identNghbrIds[(id + 1) * noDirs];
                      c++) {
                    nghbrId = m_solver->m_storeNghbrIds[c];
                    if(m_solver->a_bndryId(nghbrId) > -1) {
                      if(m_bndryCells->a[m_solver->a_bndryId(nghbrId)].m_linkedCellId == -1) {
                        reconstructIds[noReconstructIds] = nghbrId;
                        noReconstructIds++;
                      } else {
                        reconstructIds[noReconstructIds] = m_bndryCells->a[m_solver->a_bndryId(nghbrId)].m_linkedCellId;
                        noReconstructIds++;
                      }
                    } else {
                      reconstructIds[noReconstructIds] = nghbrId;
                      noReconstructIds++;
                    }
                  }
                }
              }
            }
          }
          // b) remove all the small cells
          temp = noReconstructIds;
          for(MInt k = 0; k < temp; k++) {
            id = reconstructIds[k];
            bnd = m_solver->a_bndryId(id);
            if(bnd > -1) {
              linkedCell = m_bndryCells->a[bnd].m_linkedCellId;
              if(linkedCell > -1) reconstructIds[k] = linkedCell;
            }
          }

          // remove cellId from list
          temp = noReconstructIds;
          for(MInt k = temp - 1; k > -1; k--) {
            if(reconstructIds[k] == cellId) {
              noReconstructIds--;
              reconstructIds[k] = reconstructIds[noReconstructIds];
            }
          }

          // sort the list
          maia::math::quickSort(reconstructIds.begin(), 0, noReconstructIds - 1);
          m_solver->a_noReconstructionNeighbors(cellId) =
              maia::math::removeDoubleEntries(reconstructIds.begin(), noReconstructIds);

          for(MInt k = 0; k < m_solver->a_noReconstructionNeighbors(cellId); k++)
            m_solver->a_reconstructionNeighborId(cellId, k) = reconstructIds[k];
        }
      }
    }
  }

  // compute the least-squares constants k_i for the ghost cell (Neumann bc)
  computeNeumannLSConstants(bcId);
}

/**
 * \fn FvBndryCndXD::bc1251()
 * TODO
 * \fvcutoffbc{FvBndryCndXD::bc1251(), fvbc1251, BC 1251}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1251(MInt bcId) {
  TRACE();

  m_bc1251ForcingAmplitude =
      Context::getSolverProperty<MFloat>("bc1251ForcingAmplitude", m_solverId, AT_, &m_bc1251ForcingAmplitude);
  m_bc1251ForcingWavelength =
      Context::getSolverProperty<MFloat>("bc1251ForcingWavelength", m_solverId, AT_, &m_bc1251ForcingWavelength);
  m_bc1251ForcingDirection =
      Context::getSolverProperty<MInt>("bc1251ForcingDirection", m_solverId, AT_, &m_bc1251ForcingDirection);

  const MFloat inletSoundSpeed = sysEqn().speedOfSound(m_solver->m_rhoInfinity, m_solver->m_PInfinity);
  m_bc1251ForcingFrequency = inletSoundSpeed / m_bc1251ForcingWavelength;

  MInt cellId, nghbrId, d = 0;
  const MFloat time = m_solver->m_time;

  switch(m_cutOffBndryCndIds[bcId]) {
    case 1251:
      d = 0;
      break;
    case 1261:
      d = 1;
      break;
    case 1271:
      d = 2;
      break;
    case 1281:
      d = 3;
      break;
    default: {
      stringstream errorMessage;
      errorMessage << "ERROR: switch variable 'm_cutOffBndryCndIds[ bcId ]' with value " << m_cutOffBndryCndIds[bcId]
                   << " not matching any case." << endl;
      mTerm(1, AT_, errorMessage.str());
    }
  }

  const MInt mainVelocityDirection = (d == 0 || d == 1) ? 0 : 1;
  const MInt secondaryVelocityDirection = (d == 0 || d == 1) ? 1 : 0;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    cellId = m_sortedCutOffCells[bcId]->a[id];
    nghbrId = m_solver->c_neighborId(cellId, d);

    m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);

    m_solver->a_pvariable(cellId, PV->RHO) = m_solver->m_rhoInfinity;

    m_solver->a_pvariable(cellId, PV->VV[mainVelocityDirection]) =
        (F1 + m_bc1251ForcingAmplitude * sin(2.0 * PI * m_bc1251ForcingFrequency * time))
        * m_solver->m_VVInfinity[mainVelocityDirection];

    m_solver->a_pvariable(cellId, PV->VV[secondaryVelocityDirection]) = 0;

    IF_CONSTEXPR(isDetChem<SysEqn>) {
      for(MInt s = 0; s < m_noSpecies; s++) {
        m_solver->a_pvariable(cellId, PV->Y[s]) = m_solver->m_YInfinity[s];
      }
    }
  }
}


//------------------------------------------------------------------------------

/**
 * \fn FvBndryCndXD::bc17516()
 * Characteristic inflow b.c. (top hat velocity profile applied, density, and c are prescribed)
 * forced flame response - wide domain \n \n
 * non reflecting boundaries
 * \author Stephan Schlimpert
 * \date July 2010
 * \fvcutoffbc{FvBndryCndXD::bc17516(), fvbc17516, BC 17516}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc17516(MInt bcId) {
  TRACE();

  MInt forcing = m_solver->m_forcing;
  MInt cellId, nghbrId, d = 0; // s=0,dir=-1;
  MFloat time = m_solver->m_time;
  MFloat St = m_solver->m_flameStrouhal;
  MFloat ampl = m_solver->m_forcingAmplitude;
  //  MFloat massFlux = F0, density = F0, pressure = F0, velocity = F0, count = 0;
  //  MFloat maxXCoord = F0, minXCoord = F0, area = F0;
  MFloat xPlus, xNegative;
  // MFloat integrateFactor = m_solver->m_velocityMagnitudeFactor;
  //---
  // MFloat vz = F1;
  //  MFloat yOffsetInject = F0;
  //  static MInt opposite[6] = {1,0,3,2,5,4};

  switch(m_cutOffBndryCndIds[bcId]) {
    case 17516:
      d = 1; //,vz=F1;//dir=1;s=0;
      break;
    case 17616:
      d = 3; //,vz=F1;//dir=0;s=1;
      break;
    case 17716:
      d = 5; //,vz=F1;//dir=2;s=2;
      break;
    case 17816:
      d = 0; //,vz=-F1;//dir=1;s=0;
      break;
    default: {
      stringstream errorMessage;
      errorMessage << "ERROR: switch variable 'm_cutOffBndryCndIds[ bcId ]' with value " << m_cutOffBndryCndIds[bcId]
                   << " not matching any case." << endl;
      mTerm(1, AT_, errorMessage.str());
    }
  }

  if(!forcing) {
    // loop over all concerning cells
    for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
      cellId = m_sortedCutOffCells[bcId]->a[id];
      nghbrId = m_solver->c_neighborId(cellId, d);

      // compute the pressure gradient with internal cells
      //      slope = m_solver->a_pvariable( nghbrId2 ,  PV->P ) - m_solver->a_pvariable( nghbrId ,
      //      PV->P ) ;

      m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P); // + slope;

      // compute the density from inside of the domain using the pressure
      m_solver->a_pvariable(cellId, PV->RHO) =
          sysEqn().density_ES(m_solver->a_pvariable(cellId, PV->P), m_solver->m_TInfinity);

      /*
            // set the velocities
            for( MInt i=0; i<nDim; i++ ){
        xPlus = m_solver->a_coordinate( cellId , opposite[i]) + radius + yOffsetInject;
        xNegative = m_solver->a_coordinate( cellId , opposite[i]) - radius + yOffsetInject;
        m_solver->a_pvariable( cellId ,  PV->VV[i] ) =
        vz*m_solver->m_VVInfinity[i]*(F1B2*(F1+tanh(xPlus*m_shearLayerStrength))*(F1-tanh(xNegative*m_shearLayerStrength))-F1);
            }
      */

      // set the velocities
      m_solver->a_pvariable(cellId, PV->VV[0]) = 0;

      xPlus = m_solver->a_coordinate(cellId, 0) + m_radiusVelFlameTube;
      xNegative = m_solver->a_coordinate(cellId, 0) - m_radiusVelFlameTube;

      m_solver->a_pvariable(cellId, PV->VV[1]) =
          m_solver->m_VInfinity
          * (F1B2 * (F1 + tanh(xPlus * m_shearLayerStrength)) * (F1 - tanh(xNegative * m_shearLayerStrength)) - F1);
      //      m_solver->a_pvariable( cellId ,  PV->VV[1] ) = m_solver->m_VInfinity*(tanh(5.0)-F1B2*tanh(5.0) +
      //      F1B2*tanh((neg2*xNegative - 0.05)*5.0/0.05))*(tanh(5.0)-F1B2*tanh(5.0) +  F1B2*tanh((F2*xPlus -
      //      0.05)*5.0/0.05));

      //     m_solver->a_pvariable( cellId ,  PV->VV[1] ) =
      //     F1B4*(1+tanh(xPlus*100.0))*(1-tanh(xNegative*100.0))*m_solver->m_VInfinity;//*integrateFactor;

      // set the progress variable
      IF_CONSTEXPR(hasPV_C<SysEqn>::value) m_solver->a_pvariable(cellId, PV->C) = F0;
      /*
  if(!m_solver->a_isHalo( nghbrId ))
  if(m_solver->m_massFlux || m_solver->m_plenumWall) {

  // mass flux
  massFlux += m_solver->a_pvariable( nghbrId ,  PV->VV[1] ) * m_solver->a_pvariable( nghbrId , PV->RHO
  );

  // velocity
  velocity+= m_solver->a_pvariable( nghbrId ,  PV->VV[1] );

  // pressure
  pressure += m_solver->a_pvariable( nghbrId ,  PV->P );

  // density
  density += m_solver->a_pvariable( nghbrId ,  PV->RHO );

  count++;

      }
      */
    }
  } else {
    // loop over all concerning cells
    for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
      cellId = m_sortedCutOffCells[bcId]->a[id];
      nghbrId = m_solver->c_neighborId(cellId, d);

      // compute the pressure gradient with internal cells
      // slope = m_solver->a_pvariable( nghbrId2 ,  PV->P ) - m_solver->a_pvariable( nghbrId ,  PV->P
      // ) ;

      m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P); // + slope;

      // compute the density from inside of the domain using the pressure
      m_solver->a_pvariable(cellId, PV->RHO) =
          sysEqn().density_ES(m_solver->a_pvariable(cellId, PV->P), m_solver->m_TInfinity);

      // set the velocities
      m_solver->a_pvariable(cellId, PV->VV[0]) = 0;

      xPlus = m_solver->a_coordinate(cellId, 0) + m_radiusVelFlameTube;
      xNegative = m_solver->a_coordinate(cellId, 0) - m_radiusVelFlameTube;

      m_solver->a_pvariable(cellId, PV->VV[1]) =
          m_solver->m_VInfinity
          * (F1B2 * (F1 + tanh(xPlus * m_shearLayerStrength)) * (F1 - tanh(xNegative * m_shearLayerStrength)) - F1);
      m_solver->a_pvariable(cellId, PV->VV[1]) *= (F1 + ampl * sin(St * time));

      //      m_solver->a_pvariable( cellId ,  PV->VV[1] ) = m_solver->m_VInfinity*(tanh(5.0)-F1B2*tanh(5.0) +
      //      F1B2*tanh((neg2*xNegative - 0.05)*5.0/0.05))*(tanh(5.0)-F1B2*tanh(5.0) +  F1B2*tanh((F2*xPlus -
      //      0.05)*5.0/0.05)); m_solver->a_pvariable( cellId ,  PV->VV[1] ) =
      //      F1B4*(1+tanh(xPlus*100.0))*(1-tanh(xNegative*100.0))*m_solver->m_VInfinity*( F1 + ampl * sin( St * time
      //      ));//* integrateFactor ;

      // set the progress variable
      IF_CONSTEXPR(hasPV_C<SysEqn>::value) m_solver->a_pvariable(cellId, PV->C) = F0;
      /*
  if(!m_solver->a_isHalo( nghbrId ))
      if(m_solver->m_massFlux || m_solver->m_plenumWall) {

  // mass flux
  massFlux += m_solver->a_pvariable( nghbrId ,  PV->VV[1] ) * m_solver->a_pvariable( nghbrId , PV->RHO
  );

  // velocity
  velocity+= m_solver->a_pvariable( nghbrId ,  PV->VV[1] );

  // pressure
  pressure += m_solver->a_pvariable( nghbrId ,  PV->P );

  // density
  density += m_solver->a_pvariable( nghbrId ,  PV->RHO );

  count++;

  // calculate maximum y coordinate
  maxXCoord = mMax(maxXCoord,m_solver->a_coordinate( cellId , 0));

  // calculate minimum y coordinate
  minXCoord = mMin(minXCoord,m_solver->a_coordinate( cellId , 0));
      }
      */
    }
  }
  /*
  if((m_solver->m_massFlux || m_solver->m_plenumWall) && m_solver->m_RKStep == (m_solver->m_noRKSteps-1)) {
    density = density/count;
    pressure = pressure/count;
    velocity = velocity/count;
    massFlux = massFlux/count;
    area = abs(maxXCoord) + abs(minXCoord) + m_solver->c_cellLengthAtLevel(m_solver->maxRefinementLevel());
    massFlux *= area;

    //    cerr << area << endl;

    FILE* datei;
    datei = fopen("massFluxInflow", "a+");
    fprintf(datei, " %d", globalTimeStep);
    fprintf(datei, " %f", m_solver->m_time);
    fprintf(datei, " %-10.10f", massFlux );
    fprintf(datei, " %-10.10f", velocity );
    fprintf(datei, " %-10.10f", density );
    fprintf(datei, " %-10.10f", pressure );
    fprintf(datei, "\n");
    fclose(datei);
  }
  */
}

//------------------------------------------------------------------------------

/**
 * \fn FvBndryCndXD::bc19516()
 * Inflow b.c. (Hyperbolic tangent velocity with shear layer thickness parameter, 3D round jet) \n
 * Velocity profile ref: "Effects of Inflow Conditions and Forcing on Subsonic Jet Flows and Noise AIAA 2005" Bogey
 * and Bailly.
 * \author Onur Cetin
 * \date February 2013
 * \fvcutoffbc{FvBndryCndXD::bc19516(), fvbc19516, BC 19516}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc19516(MInt bcId) {
  TRACE();
  MInt cellId, nghbrId, d = 0; // s=0,dir=-1;
  MFloat radius, jet;          // rnd, fi, psi, Str;
  switch(m_cutOffBndryCndIds[bcId]) {
    case 19516:
      d = 1; // s=0;dir=1;
      break;
    case 19616:
      d = 3; // s=1;dir=0;
      break;
    case 19716:
      d = 5; // s=2;dir=2;
      break;
    default: {
      stringstream errorMessage;
      errorMessage << "ERROR: switch variable 'm_cutOffBndryCndIds[ bcId ]' with value " << m_cutOffBndryCndIds[bcId]
                   << " not matching any case." << endl;
      mTerm(1, AT_, errorMessage.str());
    }
  }
  // if( !forcing) {
  // loop over all concerning cells
  // loop over all concerning cells
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    cellId = m_sortedCutOffCells[bcId]->a[id];
    nghbrId = m_solver->c_neighborId(cellId, d);

    // set the temperature
    // m_solver->a_pvariable( cellId ,  PV->T ) = PV->TInfinity;

    // compute the radial position
    radius = F0;
    for(MInt i = 0; i < nDim; i++)
      if(i != d / 2) radius += POW2(m_solver->a_coordinate(cellId, i));
    radius = sqrt(radius);

    // Jet mean velocity profile
    jet = F1B2 * (1 + tanh((m_jetHeight - radius) / (2 * m_momentumThickness)));

    // Inflow mean density profile (Crocco-Busemann)
    m_solver->a_pvariable(cellId, PV->RHO) = m_solver->m_rhoInfinity * (1 / (sysEqn().CroccoBusemann(m_Ma, jet)));
    // m_solver->a_pvariable( cellId ,  PV->RHO ) = m_solver->m_rhoInfinity;
    m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
    // Choose 0.05 for momentum thickness ref: Bogey&Bailly
    if(radius <= m_jetHeight) {
      // The following line is the original line from Onur which contains an error that was fixed below
      // m_solver->a_pvariable(cellId, PV->VV[0]) =F1B2* m_targetVelocityFactor*
      // (1+tanh((m_jetHeight-radius)/(2*m_momentumThickness)));
      m_solver->a_pvariable(cellId, PV->VV[0]) =
          F1B2 * m_solver->m_VVInfinity[0] * (1 + tanh((m_jetHeight - radius) / (2 * m_momentumThickness)));
      m_solver->a_pvariable(cellId, PV->VV[1]) = m_solver->m_VVInfinity[1];
      m_solver->a_pvariable(cellId, PV->VV[2]) = m_solver->m_VVInfinity[2];
    } else {
      m_solver->a_pvariable(cellId, PV->VV[0]) = F0;
      m_solver->a_pvariable(cellId, PV->VV[1]) = F0;
      m_solver->a_pvariable(cellId, PV->VV[2]) = F0;
    }
  }
}

//--------------------------------------------------------------------------------

/**
 * \fn FvBndryCndXD::bc1753()
 * Subsonic outflow boundary condition (applied directly to the (boundary) cell) \n
 * Set of variables: Standard PV + progress variable \n \n
 * nD version
 * \author Stephan Schlimpert
 * \date Dezember 2010
 * \fvcutoffbc{FvBndryCndXD::bc1753(), fvbc1753, BC 1753}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1753(MInt bcId) {
  TRACE();

  MInt forcing = m_solver->m_forcing;
  MInt cellId, nghbrId, d = 0;
  MFloat massFlux = F0, density = F0, pressure = F0, velocity = F0, count = 0;
  MFloat maxXCoord = F0, minXCoord = F0, area = F0;
  MFloat refPressure = m_solver->m_PInfinity;
  if(m_solver->m_combustion) {
    refPressure = m_solver->m_pressureFlameTube;
  }
  // --- end of initialization

  switch(m_cutOffBndryCndIds[bcId]) {
    case 17530: ///< outflow b.c - x- direction
      d = 1;
      break;
    case 17531: ///< outflow b.c + x- direction
      d = 0;
      break;
    case 17532: ///< outflow b.c - y- direction
      d = 3;
      break;
    case 17533: ///< outflow b.c + y- direction
      d = 2;
      break;
    case 17534: ///< outflow b.c - z- direction
      d = 5;
      break;
    case 17535: ///< outflow b.c + z- direction
      d = 4;
      break;
    case 1743:
      d = 0;
      break;
    case 1753:
      d = 1;
      break;
    case 1763:
      d = 2;
      break;
    case 1773:
      d = 4;
      break;
    default: {
      stringstream errorMessage;
      errorMessage << "ERROR: switch variable 'm_cutOffBndryCndIds[ bcId ]' with value " << m_cutOffBndryCndIds[bcId]
                   << " not matching any case." << endl;
      mTerm(1, AT_, errorMessage.str());
    }
  }

  if(!forcing) {
    // loop over all concerning cells
    for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
      cellId = m_sortedCutOffCells[bcId]->a[id];
      nghbrId = m_solver->c_neighborId(cellId, d);

      // zero-gradient density
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->a_pvariable(nghbrId, PV->RHO);

      // zero-gradient velocity
      for(MInt i = 0; i < nDim; i++)
        m_solver->a_pvariable(cellId, PV->VV[i]) = m_solver->a_pvariable(nghbrId, PV->VV[i]);

      // set the pressure
      m_solver->a_pvariable(cellId, PV->P) = F2 * refPressure - m_solver->a_pvariable(nghbrId, PV->P);

      // zero-gradient progress variable
      for(MInt s = 0; s < m_noSpecies; s++)
        m_solver->a_pvariable(cellId, PV->Y[s]) = m_solver->a_pvariable(nghbrId, PV->Y[s]);

      if(!m_solver->a_isHalo(nghbrId))
        if(m_solver->m_combustion) {
          if(m_solver->m_massFlux || m_solver->m_plenumWall) {
            // mass flux
            massFlux += m_solver->a_pvariable(nghbrId, PV->VV[1]) * m_solver->a_pvariable(nghbrId, PV->RHO);

            // velocity
            velocity += m_solver->a_pvariable(nghbrId, PV->VV[1]);

            // pressure
            pressure += m_solver->a_pvariable(nghbrId, PV->P);

            // density
            density += m_solver->a_pvariable(nghbrId, PV->RHO);

            count++;

            // calculate maximum y coordinate
            maxXCoord = mMax(maxXCoord, m_solver->a_coordinate(cellId, 0));

            // calculate minimum y coordinate
            minXCoord = mMin(minXCoord, m_solver->a_coordinate(cellId, 0));
          }
        }
    }
  } else {
    //  MFloat factorSurface = 0.5686867;
    for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
      cellId = m_sortedCutOffCells[bcId]->a[id];
      nghbrId = m_solver->c_neighborId(cellId, d);

      // zero-gradient density
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->a_pvariable(nghbrId, PV->RHO);

      // zero-gradient velocity
      for(MInt i = 0; i < nDim; i++)
        m_solver->a_pvariable(cellId, PV->VV[i]) = m_solver->a_pvariable(nghbrId, PV->VV[i]);

      // TOutlet = 1.0 / ( 1.0 + 0.5 * gammaMinusOne *
      // POW2(m_Ma*factorSurface*m_solver->m_rhoInfinity/m_solver->a_pvariable(nghbrId, PV->RHO)*( F1 + ampl *
      // sin( St * time ))));

      // POutlet = sysEqn().pressure_IR(TOutlet);

      m_solver->a_pvariable(cellId, PV->P) = F2 * refPressure - m_solver->a_pvariable(nghbrId, PV->P);

      // zero-gradient progress variable
      for(MInt i = 0; i < m_noSpecies; i++)
        m_solver->a_pvariable(cellId, PV->Y[i]) = m_solver->a_pvariable(nghbrId, PV->Y[i]);

      if(!m_solver->a_isHalo(nghbrId))
        if(m_solver->m_combustion) {
          if(m_solver->m_massFlux || m_solver->m_plenumWall) {
            // mass flux
            massFlux += m_solver->a_pvariable(nghbrId, PV->VV[1]) * m_solver->a_pvariable(nghbrId, PV->RHO);

            // velocity
            velocity += m_solver->a_pvariable(nghbrId, PV->VV[1]);

            // pressure
            pressure += m_solver->a_pvariable(nghbrId, PV->P);

            // density
            density += m_solver->a_pvariable(nghbrId, PV->RHO);

            count++;

            // calculate maximum y coordinate
            maxXCoord = mMax(maxXCoord, m_solver->a_coordinate(cellId, 0));

            // calculate minimum y coordinate
            minXCoord = mMin(minXCoord, m_solver->a_coordinate(cellId, 0));
          }
        }
    }
  }
  if(m_solver->m_combustion) {
    if((m_solver->m_massFlux || m_solver->m_plenumWall) && m_solver->m_RKStep == (m_solver->m_noRKSteps - 1)) {
      if(noDomains() > 1) mTerm(1, AT_, "parallize mass flux computation in bc1753");
      density = density / count;
      pressure = pressure / count;
      velocity = velocity / count;
      massFlux = massFlux / count;
      area = abs(maxXCoord) + abs(minXCoord) + m_solver->c_cellLengthAtLevel(m_solver->maxRefinementLevel());
      massFlux *= area;

      //    cerr << area << endl;

      FILE* datei;
      datei = fopen("massFluxOutflow", "a+");
      fprintf(datei, " %d", globalTimeStep);
      fprintf(datei, " %f", m_solver->m_time);
      fprintf(datei, " %-10.10f", massFlux);
      fprintf(datei, " %-10.10f", velocity);
      fprintf(datei, " %-10.10f", density);
      fprintf(datei, " %-10.10f", pressure);
      fprintf(datei, "\n");
      fclose(datei);
    }
  }
}

//------------------------------------------------------------------------------


/**
 * \fn FvBndryCndXD::bc1755()
 * Subsonic outflow boundary condition (applied directly to the (boundary) cell) \n
 * Set of variables: Standard PV + progress variable \n \n
 * nD version
 * \author Stephan Schlimpert
 * \date 19.10.2011
 * \fvcutoffbc{FvBndryCndXD::bc1755(), fvbc1755, BC 1755}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1755(MInt bcId) {
  TRACE();

  MInt cellId = -1, nghbrId = -1, d = 0;
  MFloat pressure = m_solver->m_PInfinity;
  if(m_solver->m_jet) pressure = m_solver->m_jetPressure;

  // --- end of initialization

  switch(m_cutOffBndryCndIds[bcId]) {
    case 1745:
      d = 1;
      break;
    case 1755:
      d = 0;
      break;
    case 1765:
      d = 2;
      break;
    case 1775:
      d = 4;
      break;
    default: {
      stringstream errorMessage;
      errorMessage << "ERROR: switch variable 'm_cutOffBndryCndIds[ bcId ]' with value " << m_cutOffBndryCndIds[bcId]
                   << " not matching any case." << endl;
      mTerm(1, AT_, errorMessage.str());
    }
  }

  // loop over all concerning cells
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    cellId = m_sortedCutOffCells[bcId]->a[id];
    nghbrId = m_solver->c_neighborId(cellId, d);

    // zero-gradient density
    m_solver->a_pvariable(cellId, PV->RHO) = m_solver->a_pvariable(nghbrId, PV->RHO);

    // zero-gradient velocity
    for(MInt i = 0; i < nDim; i++)
      m_solver->a_pvariable(cellId, PV->VV[i]) = m_solver->a_pvariable(nghbrId, PV->VV[i]);

    // zero gradient pressure
    m_solver->a_pvariable(cellId, PV->P) = F2 * pressure - m_solver->a_pvariable(nghbrId, PV->P);

    // zero-gradient progress variable
    for(MInt s = 0; s < m_noSpecies; s++) {
      m_solver->a_pvariable(cellId, PV->Y[s]) = m_solver->a_pvariable(nghbrId, PV->Y[s]);
    }
  }
}

//------------------------------------------------------------------------------


/**
 * \fn FvBndryCndXD::bc3003
 * no-slip adiabatic wall boundary condition \n
 * u=v=w=0; drho/dn=dp/dn=0;
 * \fvbc{FvBndryCndXD::bc3003(), fvbc3003, BC 3003}
 */
template <MInt nDim, class SysEqn>
template <MBool MGC>
void FvBndryCndXD<nDim, SysEqn>::bc3003(MInt bcId) {
  TRACE();
  const MInt noSpecies = m_noSpecies;

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt bndryId = m_sortedBndryCells->a[id];
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == m_bndryCndIds[bcId]) {
          const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;

          for(MInt i = 0; i < nDim; i++) {
            if(MGC) {
              if(m_surfaceGhostCell) {
                m_solver->a_pvariable(ghostCellId, PV->VV[i]) = 0.0;
              } else {
                m_solver->a_pvariable(ghostCellId, PV->VV[i]) =
                    -m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->VV[i]];
              }
            } else {
              m_solver->a_pvariable(ghostCellId, PV->VV[i]) = -m_solver->a_pvariable(cellId, PV->VV[i]);
            }
          }
          if(MGC) {
            m_solver->a_pvariable(ghostCellId, PV->RHO) =
                m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->RHO];
            m_solver->a_pvariable(ghostCellId, PV->P) =
                m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->P];
          } else {
            // simplified Neumann: assuming the line boundary-ghost is normal to the boundary surface)
            m_solver->a_pvariable(ghostCellId, PV->RHO) = m_solver->a_pvariable(cellId, PV->RHO);
            m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);
          }

          IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
            IF_CONSTEXPR(SysEqn::m_ransModel == RANS_SA_DV || SysEqn::m_ransModel == RANS_FS) {
              if(MGC) {
                if(m_surfaceGhostCell) {
                  m_solver->a_pvariable(ghostCellId, PV->N) = 0.0;
                } else {
                  m_solver->a_pvariable(ghostCellId, PV->N) =
                      -m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->N];
                }
              } else {
                m_solver->a_pvariable(ghostCellId, PV->N) = -m_solver->a_pvariable(cellId, PV->N);
              }
            }
            IF_CONSTEXPR(SysEqn::m_ransModel == RANS_KOMEGA || SysEqn::m_ransModel == RANS_SST) {
              // k
              m_solver->a_pvariable(ghostCellId, PV->K) = -m_solver->a_pvariable(cellId, PV->K);
              // omega
              const MFloat rRe = F1 / sysEqn().m_Re0;
              const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
              const MFloat p = m_solver->a_pvariable(cellId, PV->P);
              const MFloat omega = m_solver->a_pvariable(cellId, PV->OMEGA);
              const MFloat T = sysEqn().temperature_ES(rho, p);
              const MFloat mue = sysEqn().sutherlandLaw(T);
              const MFloat nu = mue / rho;
              const MFloat beta1 = RM_KOMEGA::beta0;
              MFloat d = sqrt(POW2(m_solver->a_coordinate(cellId, 0) - m_solver->a_coordinate(ghostCellId, 0))
                              + POW2(m_solver->a_coordinate(cellId, 1) - m_solver->a_coordinate(ghostCellId, 1)));
              IF_CONSTEXPR(nDim == 3) {
                d = sqrt(POW2(m_solver->a_coordinate(cellId, 0) - m_solver->a_coordinate(ghostCellId, 0))
                         + POW2(m_solver->a_coordinate(cellId, 1) - m_solver->a_coordinate(ghostCellId, 1))
                         + POW2(m_solver->a_coordinate(cellId, 2) - m_solver->a_coordinate(ghostCellId, 2)));
              }
              const MFloat nu_surface = nu - m_solver->a_slope(cellId, PV->N, 1) * d;
              const MFloat omega_surface = pow(rRe, 2.0) * 60 * nu_surface / (beta1 * POW2(d));
              m_solver->a_pvariable(ghostCellId, PV->OMEGA) = F2 * omega_surface - omega;
            }
          }

          for(MInt s = 0; s < noSpecies; s++) {
            if(MGC) {
              m_solver->a_pvariable(ghostCellId, PV->Y[s]) =
                  m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->Y[s]];
            } else {
              m_solver->a_pvariable(ghostCellId, PV->Y[s]) = m_solver->a_pvariable(cellId, PV->Y[s]);
            }
          }
        }
      }
    }
  }
}

template <MInt nDim, class SysEqn>
template <MBool MGC>
void FvBndryCndXD<nDim, SysEqn>::bcInit4000(MInt) {
  TRACE();

  m_4000timeStepOffset = Context::getSolverProperty<MInt>("bc4000timeStepOffset", m_solverId, AT_);
  m_4000timeInterval = Context::getSolverProperty<MInt>("bc4000timeInterval", m_solverId, AT_);
  m_wFactor = Context::getSolverProperty<MFloat>("wFactor", m_solverId, AT_);
}

/**
 * \fn FvBndryCndXD::bc4000
 * no-slip adiabatic wall boundary condition with velocity component in periodic direction \n
 * u=v, w=factor*u_in; drho/dn=dp/dn=0;
 * \fvbc{FvBndryCndXD::bc4000(), fvbc4000, BC 4000}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc4000(MInt bcId) {
  TRACE();

  const MFloat G = m_wFactor * m_solver->m_UInfinity;

  MFloat factor = F1;
  if(m_4000timeStepOffset > 0) {
    if(globalTimeStep > m_4000timeStepOffset) {
      factor = tanh((MFloat)(globalTimeStep - m_4000timeStepOffset) / m_4000timeInterval * PI);
    }
  }


#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt bndryId = m_sortedBndryCells->a[id];
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == m_bndryCndIds[bcId]) {
          const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;

          m_solver->a_pvariable(ghostCellId, PV->U) = -m_solver->a_pvariable(cellId, PV->U);
          m_solver->a_pvariable(ghostCellId, PV->V) = -m_solver->a_pvariable(cellId, PV->V);
          m_solver->a_pvariable(ghostCellId, PV->W) = 2.0 * factor * G - m_solver->a_pvariable(cellId, PV->W);

          IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
            for(MInt r = 0; r < m_solver->m_noRansEquations; ++r) {
              m_solver->a_pvariable(ghostCellId, PV->NN[r]) = -m_solver->a_pvariable(cellId, PV->NN[r]);
            }
          }

          m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);

          for(MInt s = 0; s < m_noSpecies; s++) {
            m_solver->a_pvariable(ghostCellId, PV->Y[s]) = m_solver->a_pvariable(cellId, PV->Y[s]);
          }
        }
      }
    }
  }
}

/**
 * \fn FvBndryCndXD::bc4001
 * no-slip adiabatic wall boundary condition \n
 * u=v=w=0; drho/dn=dp/dn=0;
 * \fvbc{FvBndryCndXD::bc4001(), fvbc4001, BC 4001}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc4001(MInt bcId) {
  TRACE();

  const MFloat G = m_wFactor * m_solver->m_UInfinity;
  const MInt timeStepOffset = m_4000timeStepOffset;

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt bndryId = m_sortedBndryCells->a[id];
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == m_bndryCndIds[bcId]) {
          const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;

          m_solver->a_pvariable(ghostCellId, PV->U) = -m_solver->a_pvariable(cellId, PV->U);
          m_solver->a_pvariable(ghostCellId, PV->V) = -m_solver->a_pvariable(cellId, PV->V);

          MFloat factor = F1;

          if(globalTimeStep < m_4000timeStepOffset) {
            factor = 1 - cos(PI / (MFloat)timeStepOffset * (globalTimeStep - m_solver->m_restartTimeStep));
          }

          IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
            for(MInt r = 0; r < m_solver->m_noRansEquations; ++r) {
              m_solver->a_pvariable(ghostCellId, PV->NN[r]) = -m_solver->a_pvariable(cellId, PV->NN[r]);
            }
          }

          m_solver->a_pvariable(ghostCellId, PV->W) = 2.0 * factor * G - m_solver->a_pvariable(cellId, PV->W);
        }
      }
    }
  }
}


/**
 * \fn FvBndryCndXD::bc3011
 * no-slip isothermal wall boundary condition \n
 * u=v=w=0; drho/dn=dp/dn=0;
 * \fvbc{FvBndryCndXD::bc3011(), fvbc3011, BC 3011}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc3011(MInt bcId) {
  TRACE();

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt bndryId = m_sortedBndryCells->a[id];
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == m_bndryCndIds[bcId]) {
          const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;

          for(MInt i = 0; i < nDim; i++) {
            m_solver->a_pvariable(ghostCellId, PV->VV[i]) = -m_solver->a_pvariable(cellId, PV->VV[i]);
          }
          const MFloat pressure = m_solver->a_pvariable(cellId, PV->P);

          m_solver->a_pvariable(ghostCellId, PV->P) = pressure;
          // 2 * density of the set temperature - density of the cell
          m_solver->a_pvariable(ghostCellId, PV->RHO) =
              2 * sysEqn().density_ES(pressure, m_Bc3011WallTemperature) - m_solver->a_pvariable(cellId, PV->RHO);

          IF_CONSTEXPR(isDetChem<SysEqn>)
          m_solver->a_pvariable(ghostCellId, PV->RHO) =
              F2 * m_solver->a_avariable(cellId, AV->W_MEAN) * pressure
                  / (m_solver->m_gasConstant * m_Bc3011WallTemperature)
              - m_solver->a_pvariable(cellId, PV->RHO); // to do: needs to be checked

          for(MInt s = 0; s < m_noSpecies; s++) {
            m_solver->a_pvariable(ghostCellId, PV->Y[s]) = m_solver->a_pvariable(cellId, PV->Y[s]);
          }
        }
      }
    }
  }
}

/**
 * \fn FvBndryCndXD::bc3002()
 * slip adiabatic wall boundary condition \n
 * u_n=0; du_t/dn=0; drho/dn=dp/dn=0 \n
 * dp/dn=0 is only valid for walls without streamwise curvature!
 * \fvbc{FvBndryCndXD::bc3002(), fvbc3002, BC 3002}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc3002(MInt bcId) {
  TRACE();

  const MInt noSpecies = m_noSpecies;

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt bndryId = m_sortedBndryCells->a[id];
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == m_bndryCndIds[bcId]) {
          const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;

          MFloat wallNormalVelocity = F0;

          for(MInt i = 0; i < nDim; i++)
            wallNormalVelocity +=
                m_solver->a_pvariable(cellId, PV->VV[i]) * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];

          for(MInt i = 0; i < nDim; i++)
            m_solver->a_pvariable(ghostCellId, PV->VV[i]) =
                m_solver->a_pvariable(cellId, PV->VV[i])
                - F2 * wallNormalVelocity * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];

          m_solver->a_pvariable(ghostCellId, PV->RHO) = m_solver->a_pvariable(cellId, PV->RHO);
          m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);

          IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
            for(MInt r = 0; r < m_solver->m_noRansEquations; ++r) {
              m_solver->a_pvariable(ghostCellId, PV->NN[r]) = m_solver->a_pvariable(cellId, PV->NN[r]);
            }
          }

          for(MInt s = 0; s < noSpecies; s++)
            m_solver->a_pvariable(ghostCellId, PV->Y[s]) = m_solver->a_pvariable(cellId, PV->Y[s]);
        }
      }
    }
  }
}


/**
 * \fn FvBndryCndXD::30021
 * slip adiabatic wall boundary condition. \n
 * u_n=0; du_t/dn=0; drho/dn=dp/dn=0 \n
 * dp/dn=0 is only valid for walls without streamwise curvature!
 * \fvbc{FvBndryCndXD::bc30021 fvbc30021, BC 30021}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc30021(MInt bcId) {
  TRACE();

  const MInt noSpecies = m_noSpecies;

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt bndryId = m_sortedBndryCells->a[id];
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == m_bndryCndIds[bcId]) {
          const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;

          MFloat wallNormalVelocity = F0;

          for(MInt i = 0; i < nDim; i++)
            wallNormalVelocity +=
                m_solver->a_pvariable(cellId, PV->VV[i]) * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];

          for(MInt i = 0; i < nDim; i++)
            m_solver->a_pvariable(ghostCellId, PV->VV[i]) = m_solver->a_pvariable(cellId, PV->VV[i]);
          // - F2 * wallNormalVelocity * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];

          m_solver->a_pvariable(ghostCellId, PV->RHO) = m_solver->a_pvariable(cellId, PV->RHO);
          m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);

          IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
            for(MInt r = 0; r < m_noRansEquations; ++r) {
              m_solver->a_pvariable(ghostCellId, PV->N) = m_solver->a_pvariable(cellId, PV->N);
            }
          }

          for(MInt s = 0; s < noSpecies; s++)
            m_solver->a_pvariable(ghostCellId, PV->Y[s]) = m_solver->a_pvariable(cellId, PV->Y[s]);
        }
      }
    }
  }
}


/* Computes the p and rho slopes on boundary cells using the least-squares method
 *
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bcNeumann(MInt bcId) {
  TRACE();

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt bndryId = m_sortedBndryCells->a[id];
    const MInt linkedCell = m_bndryCells->a[bndryId].m_linkedCellId;
    const MInt cellId = (linkedCell > -1) ? linkedCell : m_bndryCells->a[bndryId].m_cellId;
    const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      if(linkedCell == -1 || m_solver->a_bndryId(linkedCell) == -1) {
        // reset the slopes
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_slope(cellId, PV->RHO, i) = F0;
          m_solver->a_slope(cellId, PV->P, i) = F0;
        }

        for(MInt nghbr = 0; nghbr < m_solver->a_noReconstructionNeighbors(cellId); nghbr++) {
          const MInt nghbrId = m_solver->a_reconstructionNeighborId(cellId, nghbr);
          for(MInt i = 0; i < nDim; i++) {
            m_solver->a_slope(cellId, PV->RHO, i) +=
                m_reconstructionConstants[bndryId][nghbr * nDim + i]
                * (m_solver->a_pvariable(nghbrId, PV->RHO) - m_solver->a_pvariable(cellId, PV->RHO));
            m_solver->a_slope(cellId, PV->P, i) +=
                m_reconstructionConstants[bndryId][nghbr * nDim + i]
                * (m_solver->a_pvariable(nghbrId, PV->P) - m_solver->a_pvariable(cellId, PV->P));
          }
        }

        // apply the Neumann bc
        m_solver->a_pvariable(ghostCellId, PV->RHO) = m_solver->a_pvariable(cellId, PV->RHO);
        m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);
        for(MInt i = 0; i < nDim; i++) {
          const MFloat dx = m_solver->a_coordinate(ghostCellId, i) - m_solver->a_coordinate(cellId, i);
          m_solver->a_pvariable(ghostCellId, PV->RHO) += dx * m_solver->a_slope(cellId, PV->RHO, i);
          m_solver->a_pvariable(ghostCellId, PV->P) += dx * m_solver->a_slope(cellId, PV->P, i);
        }
      }
    }
  }
}

/* Computes the p and rho slopes on boundary cells using the least-squares method
 *
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bcNeumannIso(MInt bcId) {
  TRACE();

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt bndryId = m_sortedBndryCells->a[id];
    const MInt linkedCell = m_bndryCells->a[bndryId].m_linkedCellId;
    const MInt cellId = (linkedCell > -1) ? linkedCell : m_bndryCells->a[bndryId].m_cellId;
    const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      if(linkedCell == -1 || m_solver->a_bndryId(linkedCell) == -1) {
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_slope(cellId, PV->P, i) = F0;
        }

        for(MInt nghbr = 0; nghbr < m_solver->a_noReconstructionNeighbors(cellId); nghbr++) {
          const MInt nghbrId = m_solver->a_reconstructionNeighborId(cellId, nghbr);
          for(MInt i = 0; i < nDim; i++) {
            m_solver->a_slope(cellId, PV->P, i) +=
                m_reconstructionConstants[bndryId][nghbr * nDim + i]
                * (m_solver->a_pvariable(nghbrId, PV->P) - m_solver->a_pvariable(cellId, PV->P));
          }
        }

        // apply the Neumann bc
        m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);
        MFloat dp = F0;
        for(MInt i = 0; i < nDim; i++) {
          dp += (m_solver->a_coordinate(ghostCellId, i) - m_solver->a_coordinate(cellId, i))
                * m_solver->a_slope(cellId, PV->P, i);
        }
        m_solver->a_pvariable(ghostCellId, PV->P) += dp;

        // change surface density according to wall temperature and dp
        IF_CONSTEXPR(isDetChem<SysEqn>) {
          m_solver->a_pvariable(ghostCellId, PV->RHO) +=
              m_solver->a_avariable(cellId, AV->W_MEAN) * dp / (m_Bc3011WallTemperature * m_solver->m_gasConstant);
        }
        else {
          m_solver->a_pvariable(ghostCellId, PV->RHO) += sysEqn().density_ES(dp, m_Bc3011WallTemperature);
        }
      }
    }
  }
}

/**
 * \fn FvBndryCndXD::bc17110()
 * Linear shear flow, initial condition 466
 * \fvcutoffbc{FvBndryCndXD::bc17110(), fvbc17110, BC 17110}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc17110(MInt bcId) {
  TRACE();

  MInt d = 0, cellId, nghbrId;
  //---

  switch(m_cutOffBndryCndIds[bcId]) {
    case 17110:
      d = 1;
      break;
    case 17111:
      d = 0;
      break;
    case 17112:
      d = 3;
      break;
    case 17113:
      d = 2;
      break;
    case 17114:
      d = 5;
      break;
    case 17115:
      d = 4;
      break;
    default: {
      stringstream errorMessage;
      errorMessage << "ERROR: switch variable 'm_cutOffBndryCndIds[ bcId ]' with value " << m_cutOffBndryCndIds[bcId]
                   << " not matching any case." << endl;
      mTerm(1, AT_, errorMessage.str());
    }
  }

  MFloat bbox[6] = {F0, F0, F0, F0, F0, F0};
  m_solver->m_geometry->getBoundingBox(bbox);
  const MFloat deltaY = bbox[1 + nDim] - bbox[1];
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    cellId = m_sortedCutOffCells[bcId]->a[id];
    MFloat vel[3] = {F0, F0, F0};
    MFloat dy = m_solver->a_coordinate(cellId, 1) / deltaY;
    vel[0] = F2 * m_solver->m_UInfinity * dy;
    nghbrId = m_solver->c_neighborId(cellId, d);
    if((dy > F0 && d == 1) || (dy < F0 && d == 0)) { // inflow
      for(MInt i = 0; i < nDim; i++)
        m_solver->a_pvariable(cellId, PV->VV[i]) = vel[i];
      m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->a_pvariable(nghbrId, PV->RHO);
    } else { // outflow
      for(MInt v = 0; v < PV->noVariables; v++)
        m_solver->a_pvariable(cellId, v) = m_solver->a_pvariable(nghbrId, v);
      m_solver->a_pvariable(cellId, PV->P) = m_solver->m_PInfinity;
    }
  }
}

//-----------------------------------------------------------------------------

template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::copyRHSIntoGhostCells() {
  TRACE();

  MInt noCells = m_bndryCells->size();

  for(MInt id = 0; id < noCells; id++) {
    for(MInt srfc = 0; srfc < m_bndryCells->a[id].m_noSrfcs; srfc++) {
      MInt ghostCellId = m_bndryCells->a[id].m_srfcVariables[srfc]->m_ghostCellId;
      MInt cellId = m_bndryCells->a[id].m_cellId;
      for(MInt i = 0; i < FV->noVariables; i++) {
        m_solver->a_rightHandSide(ghostCellId, i) = m_solver->a_rightHandSide(cellId, i);
      }
    }
  }
}


//----------------------------------------------------------------------

/** \brief inits the commnicators for the boundaries
 *
 * \author ?, Andreas Lintermann
 * \date ?, 07.05.2019
 *
 * Function is called from creatBndCells().
 *
 **/
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::initBndryCommunications() {
  TRACE();

  // find out global number and kind of boundary conditions...
  MIntScratchSpace comm_allBndryIds_scratch(m_maxNoBndryCndIds, AT_, "comm_allBndryIds_scratch");
  MIntScratchSpace comm_allBndryIds_result_scratch(noDomains() * m_maxNoBndryCndIds, AT_,
                                                   "comm_allBndryIds_result_scratch");
  MInt* comm_allBndryIds = comm_allBndryIds_scratch.getPointer();
  MInt* comm_allBndryIds_result = comm_allBndryIds_result_scratch.getPointer();
  for(MInt i = 0; i < noDomains() * m_maxNoBndryCndIds; i++) {
    comm_allBndryIds_result[i] = -1;
  }

  MPI_Group world_group;
  MPI_Comm_group(mpiComm(), &world_group, AT_, "world_group");

  for(MInt bcId = 0; bcId < m_noBndryCndIds; bcId++) {
    comm_allBndryIds[bcId] = m_bndryCndIds[bcId];
  }
  for(MInt bcId = m_noBndryCndIds; bcId < m_maxNoBndryCndIds; bcId++) {
    comm_allBndryIds[bcId] = -1;
  }

  MPI_Allgather(comm_allBndryIds, m_maxNoBndryCndIds, MPI_INT, comm_allBndryIds_result, m_maxNoBndryCndIds, MPI_INT,
                mpiComm(), AT_, "comm_allBndryIds", "comm_allBndryIds_result");

  MIntScratchSpace sortedBndryCndIds_scratch(m_maxNoBndryCndIds, AT_, "sortedBndryCndIds_scratch");
  MInt* sortedBndryCndIds = sortedBndryCndIds_scratch.getPointer();
  MInt realNoBndryCndIds = 0;
  for(MInt i = 0; i < m_maxNoBndryCndIds * noDomains(); i++) {
    if(comm_allBndryIds_result[i] > -1) sortedBndryCndIds[realNoBndryCndIds++] = comm_allBndryIds_result[i];
  }
  maia::math::quickSort(sortedBndryCndIds, 0, realNoBndryCndIds - 1);
  realNoBndryCndIds = maia::math::removeDoubleEntries(sortedBndryCndIds, realNoBndryCndIds);

  MIntScratchSpace procs_bcId_scratch(realNoBndryCndIds * noDomains(), AT_, "procs_bcId_scratch");
  MInt* procs_bcId = procs_bcId_scratch.getPointer();
  MIntScratchSpace noProcs_scratch(realNoBndryCndIds, AT_, "noProcs_scratch");
  MInt* noProcs = noProcs_scratch.getPointer();

  // this is just a workaround, needs fixing! allocation should be placed in the constructor or so!
  // needs to be done by every rank, also those that become inactive! -> moved to resetBndryCommunication()
  // if(m_comm_bc_init > 0)
  //  {
  //    for( MInt i = 0; i < m_comm_bc_init; i++ )
  //      {
  //        if(m_comm_bc[ i ] != MPI_COMM_NULL && m_comm_bc[i] != globalMaiaCommWorld())
  //          MPI_Comm_free(&m_comm_bc[ i ], AT_, "m_comm_bc[i]");
  //  }
  //}
  mDeallocate(m_comm_bc);
  if(realNoBndryCndIds > 0) {
    mAlloc(m_comm_bc, realNoBndryCndIds, "m_comm_bc", AT_);
  }

  mDeallocate(m_bc_comm_pointer);
  mAlloc(m_bc_comm_pointer, m_maxNoBndryCndIds, "m_bc_comm_pointer", -1, AT_);

  for(MInt i = 0; i < realNoBndryCndIds; i++) {
    noProcs[i] = 0;
    for(MInt p = 0; p < noDomains(); p++) {
      for(MInt j = 0; j < m_maxNoBndryCndIds; j++) {
        if(comm_allBndryIds_result[p * m_maxNoBndryCndIds + j] == sortedBndryCndIds[i]) {
          procs_bcId[noProcs[i]++] = p;
        }
      }
    }
    MPI_Group bc_group;
    MPI_Group_incl(world_group, noProcs[i], procs_bcId, &bc_group, AT_);

    MPI_Comm_create(mpiComm(), bc_group, &m_comm_bc[i], AT_, "m_comm_bc[i]");

    MPI_Group_free(&bc_group, AT_);
  }

  // set the current numnber of communicators (for next call)
  m_comm_bc_init = realNoBndryCndIds;

  for(MInt bcId = 0; bcId < m_noBndryCndIds; bcId++) {
    for(MInt i = 0; i < realNoBndryCndIds; i++) {
      if(m_bndryCndIds[bcId] == sortedBndryCndIds[i]) {
        m_bc_comm_pointer[bcId] = i;
      }
    }
  }


  IF_CONSTEXPR(nDim == 3) {
    if(m_solver->m_vtuGeometryOutput.empty()) {
      m_log << "VTU geometry output for boundaryIds: ";
      for(MInt i = 0; i < realNoBndryCndIds; i++) {
        if((sortedBndryCndIds[i] >= 3000 && sortedBndryCndIds[i] < 4000)
           || string2enum(m_solver->m_outputFormat) == VTP) {
          m_solver->m_vtuGeometryOutput.insert(sortedBndryCndIds[i]);
          m_log << sortedBndryCndIds[i] << " ";
        }
      }
      m_log << endl;
    }
  }


  // find out global number and kind of cutOff boundary conditions...
  for(MInt bcId = 0; bcId < m_noCutOffBndryCndIds; bcId++) {
    if(m_sortedCutOffCells[bcId]->size() > 0) {
      comm_allBndryIds[bcId] = m_cutOffBndryCndIds[bcId];
    } else {
      comm_allBndryIds[bcId] = -1;
    }
  }
  for(MInt bcId = m_noCutOffBndryCndIds; bcId < m_maxNoBndryCndIds; bcId++) {
    comm_allBndryIds[bcId] = -1;
  }
  for(MInt i = 0; i < noDomains() * m_maxNoBndryCndIds; i++) {
    comm_allBndryIds_result[i] = -1;
  }

  MPI_Allgather(comm_allBndryIds, m_maxNoBndryCndIds, MPI_INT, comm_allBndryIds_result, m_maxNoBndryCndIds, MPI_INT,
                mpiComm(), AT_, "comm_allBndryIds", "comm_allBndryIds_result");

  realNoBndryCndIds = 0;
  for(MInt i = 0; i < m_maxNoBndryCndIds * noDomains(); i++) {
    if(comm_allBndryIds_result[i] > -1) sortedBndryCndIds[realNoBndryCndIds++] = comm_allBndryIds_result[i];
  }
  maia::math::quickSort(sortedBndryCndIds, 0, realNoBndryCndIds - 1);
  realNoBndryCndIds = maia::math::removeDoubleEntries(sortedBndryCndIds, realNoBndryCndIds);

  if(realNoBndryCndIds == 0) {
    return;
  }

  MIntScratchSpace procs_bcIdCo_scratch(realNoBndryCndIds * noDomains(), AT_, "procs_bcIdCo_scratch");
  procs_bcId = procs_bcIdCo_scratch.getPointer();
  MIntScratchSpace noProcsCo_scratch(realNoBndryCndIds, AT_, "noProcsCo_scratch");
  noProcs = noProcsCo_scratch.getPointer();


  // this is just a workaround, needs fixing! allocation should be placed in the constructor or so!
  // needs to be done by every rank, also those that become inactive! -> moved to resetBndryCommunication()
  // if(m_comm_bcCo_init > 0)
  //  {
  //    for( MInt i = 0; i < m_comm_bcCo_init; i++ )
  //      {
  //        if(m_comm_bcCo[ i ] != MPI_COMM_NULL && m_comm_bcCo[i] != globalMaiaCommWorld())
  //          MPI_Comm_free(&m_comm_bcCo[ i ], AT_, "m_comm_bcCo[]i");
  //  }
  //}
  mDeallocate(m_comm_bcCo);
  if(realNoBndryCndIds > 0) {
    mAlloc(m_comm_bcCo, realNoBndryCndIds, "m_comm_bcCo", AT_);
  }

  mDeallocate(m_bcCo_comm_pointer);
  mAlloc(m_bcCo_comm_pointer, m_maxNoBndryCndIds, "m_bcCo_comm_pointer", -1, AT_);

  for(MInt i = 0; i < realNoBndryCndIds; i++) {
    noProcs[i] = 0;
    for(MInt p = 0; p < noDomains(); p++) {
      for(MInt j = 0; j < m_maxNoBndryCndIds; j++) {
        if(comm_allBndryIds_result[p * m_maxNoBndryCndIds + j] == sortedBndryCndIds[i]) {
          procs_bcId[noProcs[i]++] = p;
        }
      }
    }
    MPI_Group bc_group;
    MPI_Group_incl(world_group, noProcs[i], procs_bcId, &bc_group, AT_);

    MPI_Comm_create(mpiComm(), bc_group, &m_comm_bcCo[i], AT_, "m_comm_bcCo[i]");

    MPI_Group_free(&bc_group, AT_);
  }

  // set the number communicators for next call
  m_comm_bcCo_init = realNoBndryCndIds;

  for(MInt bcId = 0; bcId < m_noCutOffBndryCndIds; bcId++) {
    if(m_sortedCutOffCells[bcId]->size() == 0) continue;

    for(MInt i = 0; i < realNoBndryCndIds; i++) {
      if(m_cutOffBndryCndIds[bcId] == sortedBndryCndIds[i]) {
        m_bcCo_comm_pointer[bcId] = i;
      }
    }
  }

  MPI_Group_free(&world_group, AT_);
}

////////////////////////////////////////////////////////////////////////////////
/// Bc1601Class functions:

template <MInt nDim>
void Bc1601Class<nDim>::generateAndCommRandomNumbers() {
  if(loadRandomNumbers()) return;

  m_log << " generate Random Numbers ..." << endl;

  // obtain random numbers from Mersenne Twister and calculate derived values
  MFloat d1;
  MFloat d2;
  MFloat d3;
  MFloat xi1;
  MFloat xi2;
  MFloat xi3;
  MFloat zeta1;
  MFloat zeta2;
  MFloat zeta3;
  MFloat vc;
  for(MInt n = 0; n < m_noOfModes; n++) {
    std::normal_distribution<> dist{1.0, 1.0};
    m_omega[n] = dist(randNumGen);

    std::normal_distribution<> dist2{0.0, 0.5};
    d1 = dist2(randNumGen);
    d2 = dist2(randNumGen);
    d3 = dist2(randNumGen);

    std::normal_distribution<> dist3{0.0, 1.0};
    xi1 = dist3(randNumGen);
    xi2 = dist3(randNumGen);
    xi3 = dist3(randNumGen);
    zeta1 = dist3(randNumGen);
    zeta2 = dist3(randNumGen);
    zeta3 = dist3(randNumGen);

    // calculate derived vars
    m_p1[n] = zeta2 * d3 - zeta3 * d2;
    m_p2[n] = zeta3 * d1 - zeta1 * d3;
    m_p3[n] = zeta1 * d2 - zeta2 * d1;
    m_q1[n] = xi2 * d3 - xi3 * d2;
    m_q2[n] = xi3 * d1 - xi1 * d3;
    m_q3[n] = xi1 * d2 - xi2 * d1;

    // ---------------------------------------------------
    // Beginning of Modification by Shin
    // Scaling by vc is not necessary.
    //
    if(smirnov == 1) {
      vc = 1; // The scaling comes later with c1, c2, and c3.
    } else {
      vc = sqrt(1.5
                * ((uuref * d1 * d1 + vvref * d2 * d2 + wwref * d3 * d3
                    + 2.0 * (uvref * d1 * d2 + uwref * d1 * d3 + vwref * d2 * d3))
                   / (d1 * d1 + d2 * d2 + d3 * d3)));
    }

    m_dhat1[n] = d1 * m_v_b / vc;
    m_dhat2[n] = d2 * m_v_b / vc;
    m_dhat3[n] = d3 * m_v_b / vc;
    //
    // End of Modification by Shin
    // ---------------------------------------------------
  }

  // in case of multisolver, the random numbers from solver 0 are broadcast to all solvers
  if(m_commValues) {
    ScratchSpace<MFloat> sendRecvBuffer(m_noOfModes * 10, AT_, "sendRecvBuffer");
    if(m_rank_bc1601 == 0) {
      for(MInt n = 0; n < m_noOfModes; n++) {
        sendRecvBuffer[n + 0 * m_noOfModes] = m_omega[n];
      }
      for(MInt n = 0; n < m_noOfModes; n++) {
        sendRecvBuffer[n + 1 * m_noOfModes] = m_p1[n];
      }
      for(MInt n = 0; n < m_noOfModes; n++) {
        sendRecvBuffer[n + 2 * m_noOfModes] = m_p2[n];
      }
      for(MInt n = 0; n < m_noOfModes; n++) {
        sendRecvBuffer[n + 3 * m_noOfModes] = m_p3[n];
      }
      for(MInt n = 0; n < m_noOfModes; n++) {
        sendRecvBuffer[n + 4 * m_noOfModes] = m_q1[n];
      }
      for(MInt n = 0; n < m_noOfModes; n++) {
        sendRecvBuffer[n + 5 * m_noOfModes] = m_q2[n];
      }
      for(MInt n = 0; n < m_noOfModes; n++) {
        sendRecvBuffer[n + 6 * m_noOfModes] = m_q3[n];
      }
      for(MInt n = 0; n < m_noOfModes; n++) {
        sendRecvBuffer[n + 7 * m_noOfModes] = m_dhat1[n];
      }
      for(MInt n = 0; n < m_noOfModes; n++) {
        sendRecvBuffer[n + 8 * m_noOfModes] = m_dhat2[n];
      }
      for(MInt n = 0; n < m_noOfModes; n++) {
        sendRecvBuffer[n + 9 * m_noOfModes] = m_dhat3[n];
      }
    }

    MPI_Bcast(&sendRecvBuffer[0], 10 * m_noOfModes, MPI_DOUBLE, 0, m_comm_bc1601, AT_, "sendRecvBuffer[0]");

    if(m_rank_bc1601 != 0) {
      for(MInt n = 0; n < m_noOfModes; n++) {
        m_omega[n] = sendRecvBuffer[n];
      }
      for(MInt n = 0; n < m_noOfModes; n++) {
        m_p1[n] = sendRecvBuffer[n + 1 * m_noOfModes];
      }
      for(MInt n = 0; n < m_noOfModes; n++) {
        m_p2[n] = sendRecvBuffer[n + 2 * m_noOfModes];
      }
      for(MInt n = 0; n < m_noOfModes; n++) {
        m_p3[n] = sendRecvBuffer[n + 3 * m_noOfModes];
      }
      for(MInt n = 0; n < m_noOfModes; n++) {
        m_q1[n] = sendRecvBuffer[n + 4 * m_noOfModes];
      }
      for(MInt n = 0; n < m_noOfModes; n++) {
        m_q2[n] = sendRecvBuffer[n + 5 * m_noOfModes];
      }
      for(MInt n = 0; n < m_noOfModes; n++) {
        m_q3[n] = sendRecvBuffer[n + 6 * m_noOfModes];
      }
      for(MInt n = 0; n < m_noOfModes; n++) {
        m_dhat1[n] = sendRecvBuffer[n + 7 * m_noOfModes];
      }
      for(MInt n = 0; n < m_noOfModes; n++) {
        m_dhat2[n] = sendRecvBuffer[n + 8 * m_noOfModes];
      }
      for(MInt n = 0; n < m_noOfModes; n++) {
        m_dhat3[n] = sendRecvBuffer[n + 9 * m_noOfModes];
      }
    }
  }

  if((m_rank_bc1601 == 0) || (!m_commValues)) { // write the random numbers into a file (only domain 0)
    ofstream writeRnd;
    MString file = "randVars";
    if(!m_commValues) {
      stringstream test;
      test << file;
      struct stat st {};
      if(stat((test.str()).c_str(), &st) != 0) {
#if defined(MAIA_MS_COMPILER)
#pragma message("WARNING: Not compatible")
        mTerm(0, "ERROR: Not implemented!");
#else
        mkdir((test.str()).c_str(), 0744);
#endif
        m_log << endl << "creating folder " << test.str() << " for random numbers" << endl;
      }
      test << "/" << file << "_D" << m_domainId;
      file.clear();
      file.append(test.str());
    }
    writeRnd.open(file.c_str(), ios_base::out | ios_base::trunc | ios_base::binary);

    MFloat fnumber;

    for(MInt n = 0; n < m_noOfModes; n++) {
      fnumber = m_omega[n];
#ifdef SWAP_ENDIAN
      fnumber = doubleSwap(fnumber);
#endif
      writeRnd.write(reinterpret_cast<char*>(&fnumber), sizeof(MFloat));
      fnumber = m_p1[n];
#ifdef SWAP_ENDIAN
      fnumber = doubleSwap(fnumber);
#endif
      writeRnd.write(reinterpret_cast<char*>(&fnumber), sizeof(MFloat));
      fnumber = m_p2[n];
#ifdef SWAP_ENDIAN
      fnumber = doubleSwap(fnumber);
#endif
      writeRnd.write(reinterpret_cast<char*>(&fnumber), sizeof(MFloat));
      fnumber = m_p3[n];
#ifdef SWAP_ENDIAN
      fnumber = doubleSwap(fnumber);
#endif
      writeRnd.write(reinterpret_cast<char*>(&fnumber), sizeof(MFloat));
      fnumber = m_q1[n];
#ifdef SWAP_ENDIAN
      fnumber = doubleSwap(fnumber);
#endif
      writeRnd.write(reinterpret_cast<char*>(&fnumber), sizeof(MFloat));
      fnumber = m_q2[n];
#ifdef SWAP_ENDIAN
      fnumber = doubleSwap(fnumber);
#endif
      writeRnd.write(reinterpret_cast<char*>(&fnumber), sizeof(MFloat));
      fnumber = m_q3[n];
#ifdef SWAP_ENDIAN
      fnumber = doubleSwap(fnumber);
#endif
      writeRnd.write(reinterpret_cast<char*>(&fnumber), sizeof(MFloat));
      fnumber = m_dhat1[n];
#ifdef SWAP_ENDIAN
      fnumber = doubleSwap(fnumber);
#endif
      writeRnd.write(reinterpret_cast<char*>(&fnumber), sizeof(MFloat));
      fnumber = m_dhat2[n];
#ifdef SWAP_ENDIAN
      fnumber = doubleSwap(fnumber);
#endif
      writeRnd.write(reinterpret_cast<char*>(&fnumber), sizeof(MFloat));
      fnumber = m_dhat3[n];
#ifdef SWAP_ENDIAN
      fnumber = doubleSwap(fnumber);
#endif
      writeRnd.write(reinterpret_cast<char*>(&fnumber), sizeof(MFloat));
    }
    writeRnd.close();
  }
}

template <MInt nDim>
MBool Bc1601Class<nDim>::loadRandomNumbers() {
  ifstream readRnd;
  MString file = "randVars";
  if(!m_commValues) {
    stringstream test;
    test << file << "/" << file << "_D" << m_domainId;
    file.clear();
    file.append(test.str());
  }
  readRnd.open(file.c_str(), ios_base::in | ios_base::binary);

  if(!readRnd) {
    return false;
  }

  m_log << " read Random numbers from restartFile " << file << " ..." << endl;

  MFloat fnumber;

  for(MInt n = 0; n < m_noOfModes; n++) {
    readRnd.read((char*)(&fnumber), sizeof(MFloat));
#ifdef SWAP_ENDIAN
    fnumber = doubleSwap(fnumber);
#endif
    m_omega[n] = fnumber;
    readRnd.read((char*)(&fnumber), sizeof(MFloat));
#ifdef SWAP_ENDIAN
    fnumber = doubleSwap(fnumber);
#endif
    m_p1[n] = fnumber;
    readRnd.read((char*)(&fnumber), sizeof(MFloat));
#ifdef SWAP_ENDIAN
    fnumber = doubleSwap(fnumber);
#endif
    m_p2[n] = fnumber;
    readRnd.read((char*)(&fnumber), sizeof(MFloat));
#ifdef SWAP_ENDIAN
    fnumber = doubleSwap(fnumber);
#endif
    m_p3[n] = fnumber;
    readRnd.read((char*)(&fnumber), sizeof(MFloat));
#ifdef SWAP_ENDIAN
    fnumber = doubleSwap(fnumber);
#endif
    m_q1[n] = fnumber;
    readRnd.read((char*)(&fnumber), sizeof(MFloat));
#ifdef SWAP_ENDIAN
    fnumber = doubleSwap(fnumber);
#endif
    m_q2[n] = fnumber;
    readRnd.read((char*)(&fnumber), sizeof(MFloat));
#ifdef SWAP_ENDIAN
    fnumber = doubleSwap(fnumber);
#endif
    m_q3[n] = fnumber;
    readRnd.read((char*)(&fnumber), sizeof(MFloat));
#ifdef SWAP_ENDIAN
    fnumber = doubleSwap(fnumber);
#endif
    m_dhat1[n] = fnumber;
    readRnd.read((char*)(&fnumber), sizeof(MFloat));
#ifdef SWAP_ENDIAN
    fnumber = doubleSwap(fnumber);
#endif
    m_dhat2[n] = fnumber;
    readRnd.read((char*)(&fnumber), sizeof(MFloat));
#ifdef SWAP_ENDIAN
    fnumber = doubleSwap(fnumber);
#endif
    m_dhat3[n] = fnumber;
  }
  readRnd.close();

  return true;
}

template <MInt nDim>
Bc1601Class<nDim>::Bc1601Class(MPI_Comm& communicator, const MInt m_solverId, const MInt domainId, MFloat& u_total,
                               MFloat& invSigmaSponge)
  : m_domainId(domainId) {
  m_comm_bc1601 = communicator;
  MPI_Comm_rank(m_comm_bc1601, &m_rank_bc1601);
  m_invSigmaSponge = invSigmaSponge;

  // read properties
  /*! \page propertiesFV
    \section bc1601Lb
    <code>MFloat Bc1601Class::m_bc1601Lb</code>\n
    no default \n \n
    Length scale L_b for random-eddy inflow bc1601 \n
    Keywords: <i>FINITE_VOLUME</i>
  */
  m_l_b = Context::getSolverProperty<MFloat>("bc1601Lb", m_solverId, AT_);

  /*! \page propertiesFV
    \section noOfRandomModes
    <code>MFloat Bc1601Class::m_noOfModes</code>\n
    default = <code> 0 </code> \n \n
    Sets the number of random modes for random-eddy inflow bc1601 \n
    Keywords: <i>FINITE_VOLUME</i>
  */
  m_noOfModes = 0;
  m_noOfModes = Context::getSolverProperty<MInt>("noOfRandomModes", m_solverId, AT_, &m_noOfModes);
  /*! \page propertiesFV
    \section bc1601OldMode
    <code>MFloat Bc1601Class::m_oldMode</code>\n
    default = <code> 0 </code> \n \n
    Sets old mode for random-eddy inflow bc1601 \n
    Keywords: <i>FINITE_VOLUME</i>
  */
  m_oldMode = 0;
  m_oldMode = Context::getSolverProperty<MInt>("bc1601OldMode", m_solverId, AT_, &m_oldMode);

  if(m_oldMode) {
    m_commValues = false;
  } else {
    m_commValues = true;
  }
  /*! \page propertiesFV
  \section bc1601CommValues
  <code>MBool FvBndryCndXD::bc1601CommValues </code>\n
  default = <code>false</code>\n
  In the boundary condition 1601, in case of multisolver, \n
  the random numbers from solver 0 are broadcast to all solvers  \n
  Keywords: <i>FINITE_VOLUME</i>
  */
  m_commValues = Context::getSolverProperty<MBool>("bc1601CommValues", m_solverId, AT_, &m_commValues);

  /*! \page propertiesFV
  \section bc1601UseUnif
  <code>MInt FvBndryCndXD::m_useUnif </code>\n
  default = <code> 0 (false) </code>\n
  In the boundary condition 1601 use the value of U_infinity as reference velocity.
  Keywords: <i>FINITE_VOLUME</i>
  */
  m_useUnif = false;
  m_useUnif = Context::getSolverProperty<MBool>("bc1601UseUnif", m_solverId, AT_, &m_useUnif);

  MBool restart = false;
  restart = Context::getSolverProperty<MBool>("restartFile", m_solverId, AT_, &restart);

  /*! \page propertiesFV
    \section bc1601RegenerateSeeding
    <code>MInt Bc1601Class::m_regenerateSeeding</code>\n
    Controls the generation and communication of random numbers.
    default = <code>0</code> \n \n
    \n
    Keywords: <i>FINITE_VOLUME, RANDOM SEEDS</i>
  */
  m_regenerateSeeding = false;
  m_regenerateSeeding =
      Context::getSolverProperty<MBool>("bc1601RegenerateSeeding", m_solverId, AT_, &m_regenerateSeeding);

  /*! \page propertiesFV
    \section bc1601RegenerationInterval
    <code>MInt Bc1601Class::m_regenerationInterval</code>\n
    default = <code>10</code>\n \n
    interval to regenerate random number for bc1601
    Possible values are:
    <ul>
      <li> int  </li>
    </ul>
    Keywords: <i>bc1601</i>
  */
  m_regenerationInterval = 10;
  m_regenerationInterval =
      Context::getSolverProperty<MInt>("bc1601RegenerationInterval", m_solverId, AT_, &m_regenerationInterval);

  m_regenerationCounter = 0;

  /*! \page propertiesFV
    \section uuref uvref uwref vvref vwref wwref
    <code>MFloat Bc1601Class::uuref</code>\n
    default = <code>0.0</code> for all \n \n
    These values represent constant reference values for the Reynolds stress tensor \n
    in the random-eddy inflow bc1601. \n
    Keywords: <i>FINITE_VOLUME</i>
  */
  uuref = 0.0, uvref = 0.0, uwref = 0.0;
  vvref = 0.0, vwref = 0.0, wwref = 0.0;
  uuref = Context::getSolverProperty<MFloat>("uuref", m_solverId, AT_, &uuref);
  uvref = Context::getSolverProperty<MFloat>("uvref", m_solverId, AT_, &uvref);
  uwref = Context::getSolverProperty<MFloat>("uwref", m_solverId, AT_, &uwref);
  vvref = Context::getSolverProperty<MFloat>("vvref", m_solverId, AT_, &vvref);
  vwref = Context::getSolverProperty<MFloat>("vwref", m_solverId, AT_, &vwref);
  wwref = Context::getSolverProperty<MFloat>("wwref", m_solverId, AT_, &wwref);

  // Shin's modification
  smirnov = false;
  /*! \page propertiesFV
    \section smirnov
    <code>MInt FvBndryCndXD::Bc1601Class::smirnov</code>\n
    default = <code>0</code> \n
    Defines if Shin method is used for turbulence injection.\n
    Possible values are;
    <ul>
    <li> 0: false </li>
    <li> 1: true </li>
    </ul>
    Keywords: <i>FINITE_VOLUME, SYNTHETIC TURBULENCE, BC1601</i>
  */
  smirnov = Context::getSolverProperty<MBool>("smirnov", m_solverId, AT_, &smirnov);


  // ------------------------------------------
  // Beginning of Shin's modification
  // Use smirnov to activate the Shin's modification
  //
  // For reference, remember the following lines in fvbndrycnd3d.cpp
  //
  // dummyTime = m_solver->m_time / m_bc1601->m_tau_b;
  // that = 2.0 * PI * dummyTime;
  // twopioverlb = 2.0 * PI / m_bc1601->m_l_b;
  // xhat = twopioverlb * m_solver->a_coordinate( cellId , 0);
  // yhat = twopioverlb * m_solver->a_coordinate( cellId , 1);
  // zhat = twopioverlb * m_solver->a_coordinate( cellId , 2);

  if(smirnov == 1) {
    m_log << " Use Shin method for synthetic turbulence injection..." << endl;
    m_log << " It used Taylor hypothesis for temporal part" << endl;

    m_v_b = sqrt(0.5 * (uuref + vvref + wwref));
    m_tau_b = m_l_b / u_total; // Always use Taylor's hypothesis
  } else {
    m_log << "It is not using Shin method for synthetic turbulence injection..." << endl;

    // calculate time and velocity scales
    if(m_oldMode) {
      m_v_b = sqrt(0.5 * (uuref + vvref + wwref));
      m_tau_b = m_l_b / u_total;
    } else {
      if(m_useUnif) {
        m_v_b = u_total;
      } else {
        m_v_b = sqrt(0.5 * (uuref + vvref + wwref));
      }
      m_tau_b = m_l_b / m_v_b;
    }
  }
  // End of Shin's modification
  // ------------------------------------------


  // cholesky decompostion of reynolds stress tensor
  mAlloc(aa, 6, "aa", AT_);
  if(uuref <= 0.0) cerr << "WARNING in proc " << m_domainId << ": a11^2 <= 0 in bcInit1601" << endl;
  aa[0] = sqrt(uuref);
  aa[1] = uvref / aa[0];
  aa[2] = uwref / aa[0];
  if((vvref - aa[1] * aa[1]) <= 0.0) cerr << "WARNING in proc " << m_domainId << ": a22^2 <= 0 in bcInit1601" << endl;
  aa[3] = sqrt(vvref - aa[1] * aa[1]);
  aa[4] = (vwref - aa[1] * aa[2]) / aa[3];
  if((wwref - aa[2] * aa[2] - aa[4] * aa[4]) <= 0.0) {
    cerr << "WARNING in proc " << m_domainId << ": a33^2 <= 0 in bcInit1601" << endl;
  }
  aa[5] = sqrt(wwref - aa[2] * aa[2] - aa[4] * aa[4]);

  // ---------------------------------------------------
  // Beginning of Shin's modification
  // Need to evaluate the eigenvectors and eigenvalues


  if(smirnov == 1) {
    MFloat Rey_str[3][3]; // Shin's modification
    MFloat eigval[3];     // Shin's modification

    //  eigvec  = new MFloat[3][3];   // defined in fvbndrycndxd.h

    Rey_str[0][0] = uuref;
    Rey_str[1][0] = uvref;
    Rey_str[2][0] = uwref;
    Rey_str[0][1] = uvref;
    Rey_str[1][1] = vvref;
    Rey_str[2][1] = vwref;
    Rey_str[0][2] = uwref;
    Rey_str[1][2] = vwref;
    Rey_str[2][2] = wwref;

    maia::math::calcEigenVectors(Rey_str, eigvec, eigval); // defined in maiamath.h

    c1 = sqrt(eigval[0]); // c1, c2, c3 are defined in fvbndrycndxd.h
    c2 = sqrt(eigval[1]);
    c3 = sqrt(eigval[2]);

    //     m_log << "Shin method eigen values are" << endl;
    //     m_log << eigval[0] << ",   " << eigval[1] << ",   " << eigval[2] << endl;
    //
    //     m_log << "Shin method eigen vectors are" << endl;
    //     m_log << eigvec[0][0] << ",   " << eigvec[0][1] << ",   "  << eigvec[0][2] << endl;
    //     m_log << eigvec[1][0] << ",   " << eigvec[1][1] << ",   "  << eigvec[1][2] << endl;
    //     m_log << eigvec[2][0] << ",   " << eigvec[2][1] << ",   "  << eigvec[2][2] << endl;
  }
  // End of Shin's modification
  // ---------------------------------------------------


  // reserve memory
  if(m_noOfModes > 0) {
    mAlloc(m_omega, m_noOfModes, "m_omega", AT_);
    mAlloc(m_p1, m_noOfModes, "m_p1", AT_);
    mAlloc(m_p2, m_noOfModes, "m_p2", AT_);
    mAlloc(m_p3, m_noOfModes, "m_p3", AT_);
    mAlloc(m_q1, m_noOfModes, "m_q1", AT_);
    mAlloc(m_q2, m_noOfModes, "m_q2", AT_);
    mAlloc(m_q3, m_noOfModes, "m_q3", AT_);
    mAlloc(m_dhat1, m_noOfModes, "m_dhat1", AT_);
    mAlloc(m_dhat2, m_noOfModes, "m_dhat2", AT_);
    mAlloc(m_dhat3, m_noOfModes, "m_dhat3", AT_);
  }

  if(m_noOfModes > 0) {
    m_log << "Initialize 1601 random inflow with " << m_noOfModes << " random modes..." << endl;

    if(restart) {
      if(!loadRandomNumbers()) mTerm(1, AT_, "Error opening random-variables file randVars");
    } else {
      generateAndCommRandomNumbers();
    }

    m_log << "ok" << endl;
  }
}


template <MInt nDim>
Bc1601Class<nDim>::~Bc1601Class() {
  mDeallocate(aa);
  mDeallocate(m_omega);
  mDeallocate(m_p1);
  mDeallocate(m_p2);
  mDeallocate(m_p3);
  mDeallocate(m_q1);
  mDeallocate(m_q2);
  mDeallocate(m_q3);
  mDeallocate(m_dhat1);
  mDeallocate(m_dhat2);
  mDeallocate(m_dhat3);
}


template <MInt nDim>
void Bc1601Class<nDim>::calculateFlucts(const MFloat that, const MFloat xhat, const MFloat yhat, const MFloat zhat,
                                        MFloat* fluctChol) {
  MFloat xfluct = 0.0;
  MFloat yfluct = 0.0;
  MFloat zfluct = 0.0;
  MFloat tmpVar;
  MFloat B;
  MFloat D;

  // -----------------------------------------
  // Beginning of Shin's modification
  //
  if(smirnov == 1) {
    MFloat xx;
    MFloat yy;
    MFloat zz;

    for(MInt n = 0; n < m_noOfModes; n++) {
      // Counter-rotate the coordinate
      // * eigvec, c1, c2, c3 are defined in fvbndrycndxd.h
      //    and evaluated in Bc1601Class::Bc1601Class
      xx = eigvec[0][0] * (xhat - that) + eigvec[1][0] * yhat + eigvec[2][0] * zhat;
      yy = eigvec[0][1] * (xhat - that) + eigvec[1][1] * yhat + eigvec[2][1] * zhat;
      zz = eigvec[0][2] * (xhat - that) + eigvec[1][2] * yhat + eigvec[2][2] * zhat;

      // Here the anisotropic scaling is applied through c1, c2, and c3.
      tmpVar = m_dhat1[n] / c1 * xx + m_dhat2[n] / c2 * yy + m_dhat3[n] / c3 * zz;
      B = cos(tmpVar);
      D = sin(tmpVar);

      xfluct += m_p1[n] * B + m_q1[n] * D;
      yfluct += m_p2[n] * B + m_q2[n] * D;
      zfluct += m_p3[n] * B + m_q3[n] * D;
    }
  } else {
    for(MInt n = 0; n < m_noOfModes; n++) {
      tmpVar = m_dhat1[n] * xhat + m_dhat2[n] * yhat + m_dhat3[n] * zhat + m_omega[n] * that;

      B = cos(tmpVar);
      D = sin(tmpVar);

      xfluct += m_p1[n] * B + m_q1[n] * D;
      yfluct += m_p2[n] * B + m_q2[n] * D;
      zfluct += m_p3[n] * B + m_q3[n] * D;
    }
  }
  //
  // End of Shin's modification
  // -----------------------------------------


  if(m_noOfModes > 0) {
    xfluct *= sqrt(2.0 / ((MFloat)m_noOfModes));
    yfluct *= sqrt(2.0 / ((MFloat)m_noOfModes));
    zfluct *= sqrt(2.0 / ((MFloat)m_noOfModes));
  } else {
    xfluct = 0.0;
    yfluct = 0.0;
    zfluct = 0.0;
  }

  // -----------------------------------------------
  // Beginning of Shin's modification
  // Need to apply scaling and rotation by
  // eigenvalues and eigenvectors
  if(smirnov == 1) {
    MFloat w1;
    MFloat w2;
    MFloat w3;

    w1 = c1 * xfluct; // w1, w2, w3 are defined locally
    w2 = c2 * yfluct; // c1, c2, c3 are defined in fvbndrycndxd.h
    w3 = c3 * zfluct;

    // The following fluctChol means fluctuation by Smirnov's method.
    // * Lazy to change the variable names.
    // * eigvec are defined in fvbndrycndxd.h
    // and evaluated in Bc1601Class::Bc1601Class
    fluctChol[0] = eigvec[0][0] * w1 + eigvec[0][1] * w2 + eigvec[0][2] * w3;
    fluctChol[1] = eigvec[1][0] * w1 + eigvec[1][1] * w2 + eigvec[1][2] * w3;
    fluctChol[2] = eigvec[2][0] * w1 + eigvec[2][1] * w2 + eigvec[2][2] * w3;

  } else {
    fluctChol[0] = xfluct * aa[0];
    fluctChol[1] = xfluct * aa[1] + yfluct * aa[3];
    fluctChol[2] = xfluct * aa[2] + yfluct * aa[4] + zfluct * aa[5];
  }
  // End of Shin's modification
  // -----------------------------------------------
}

template <MInt nDim>
void Bc1601Class<nDim>::checkRegeneration(const MFloat time) { // time = m_solver->m_time / m_bc1601->m_tau_b;
  if(m_regenerateSeeding) {
    MInt dummy = floor(time / m_regenerationInterval);
    if(dummy > m_regenerationCounter) {
      m_regenerationCounter = dummy;
      generateAndCommRandomNumbers();
    }
  }
}


/**
 * Solid wall Navier-Stokes boundary condition - adiabatic wall \n
 * Computes ghost cell slopes for the viscous flux computation \n
 * See 3D-paper \n
 * Uses precomputed plane vectors and Jacobian
 * \author Daniel Hartmann, Sven Berger
 */
template <MInt nDim, class SysEqn>
template <MBool MGC>
void FvBndryCndXD<nDim, SysEqn>::sbc2000(MInt bcId) {
  TRACE();

  const MInt noPVars = PV->noVariables;

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt bndryId = m_sortedBndryCells->a[id];
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;

    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == m_bndryCndIds[bcId]) {
          const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;

          MFloat preFactor = NAN;
          IF_CONSTEXPR(nDim == 3) {
            if(MGC) {
              // compute the distance between ghost and boundary cell (MGC formulation -> image Point)
              preFactor = 1.0
                          / sqrt(POW2(m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageCoordinates[0]
                                      - m_solver->a_coordinate(ghostCellId, 0))
                                 + POW2(m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageCoordinates[1]
                                        - m_solver->a_coordinate(ghostCellId, 1))
                                 + POW2(m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageCoordinates[2]
                                        - m_solver->a_coordinate(ghostCellId, 2)))
                          * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_FJacobian;
            } else {
              // compute the distance between ghost and boundary cell and multiply with inverse Jacobian
              preFactor = 1.0
                          / sqrt(POW2(m_solver->a_coordinate(cellId, 0) - m_solver->a_coordinate(ghostCellId, 0))
                                 + POW2(m_solver->a_coordinate(cellId, 1) - m_solver->a_coordinate(ghostCellId, 1))
                                 + POW2(m_solver->a_coordinate(cellId, 2) - m_solver->a_coordinate(ghostCellId, 2)))
                          * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_FJacobian;
            }
          }
          else {
            if(MGC) {
              // compute the distance between ghost and boundary cell (MGC formulation -> image Point)
              preFactor = 1.0
                          / sqrt(POW2(m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageCoordinates[0]
                                      - m_solver->a_coordinate(ghostCellId, 0))
                                 + POW2(m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageCoordinates[1]
                                        - m_solver->a_coordinate(ghostCellId, 1)))
                          * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_FJacobian;

            } else {
              // compute the distance between ghost and boundary cell and multiply with inverse Jacobian
              preFactor = 1.0
                          / sqrt(POW2(m_solver->a_coordinate(cellId, 0) - m_solver->a_coordinate(ghostCellId, 0))
                                 + POW2(m_solver->a_coordinate(cellId, 1) - m_solver->a_coordinate(ghostCellId, 1)))
                          * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_FJacobian;
            }
          }

          MFloat const1;
          MFloat const2;
          MFloat const3;

          IF_CONSTEXPR(nDim == 3) {
            // compute the surface slopes
            const1 = (m_bndryCells->a[bndryId].m_srfcs[srfc]->m_planeVector0[1]
                          * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_planeVector1[2]
                      - m_bndryCells->a[bndryId].m_srfcs[srfc]->m_planeVector1[1]
                            * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_planeVector0[2])
                     * preFactor;

            const2 = (m_bndryCells->a[bndryId].m_srfcs[srfc]->m_planeVector0[2]
                          * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_planeVector1[0]
                      - m_bndryCells->a[bndryId].m_srfcs[srfc]->m_planeVector1[2]
                            * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_planeVector0[0])
                     * preFactor;

            const3 = (m_bndryCells->a[bndryId].m_srfcs[srfc]->m_planeVector0[0]
                          * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_planeVector1[1]
                      - m_bndryCells->a[bndryId].m_srfcs[srfc]->m_planeVector1[0]
                            * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_planeVector0[1])
                     * preFactor;
          }
          else {
            const1 = preFactor * m_bndryCells->a[bndryId].m_srfcs[0]->m_planeVector0[1];
            const2 = -preFactor * m_bndryCells->a[bndryId].m_srfcs[0]->m_planeVector0[0];
            const3 = 0;
          }

          // compute the slopes on the ghost cell
          for(MInt i = 0; i < nDim; i++) {
            MFloat factor = NAN;
            if(MGC) {
              factor = (m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->VV[i]]
                        - m_solver->a_pvariable(ghostCellId, PV->VV[i]));
            } else {
              factor = (m_solver->a_pvariable(cellId, PV->VV[i]) - m_solver->a_pvariable(ghostCellId, PV->VV[i]));
            }
            m_solver->a_slope(ghostCellId, PV->VV[i], 0) =
                2.0 * factor * const1 - m_solver->a_slope(cellId, PV->VV[i], 0);
            m_solver->a_slope(ghostCellId, PV->VV[i], 1) =
                2.0 * factor * const2 - m_solver->a_slope(cellId, PV->VV[i], 1);
            IF_CONSTEXPR(nDim == 3) {
              m_solver->a_slope(ghostCellId, PV->VV[i], 2) =
                  2.0 * factor * const3 - m_solver->a_slope(cellId, PV->VV[i], 2);
            }
          }


          for(MInt varId = nDim; varId < noPVars; varId++) {
            for(MInt i = 0; i < nDim; i++) {
              m_solver->a_slope(ghostCellId, varId, i) = -m_solver->a_slope(cellId, varId, i);
            }
          }
        }
      }
    }
  }
}


/** \brief Solid wall Navier-Stokes boundary condition
 *        Computes ghost cell slopes for the viscous flux computation
 *        Set of variables: primitive (u,v,rho,p,Z)
 *
 * \author Daniel Hartmann, Sven Berger
 */
template <MInt nDim, class SysEqn>
template <MInt dir>
void FvBndryCndXD<nDim, SysEqn>::sbc2001(MInt bcId) {
  TRACE();
  static_assert(dir <= nDim, "ERROR: Invalid direction!");

  const MInt noPVars = PV->noVariables;

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt bndryId = m_sortedBndryCells->a[id];
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;

      for(MInt v = 0; v < noPVars; v++) {
        if(dir == 0) {
          m_solver->a_slope(ghostCellId, v, 0) =
              (m_solver->a_pvariable(cellId, v) - m_solver->a_pvariable(ghostCellId, v))
              / (m_solver->a_coordinate(cellId, 0) - m_solver->a_coordinate(ghostCellId, 0));
        } else {
          m_solver->a_slope(ghostCellId, v, 0) = m_solver->a_slope(cellId, v, 0);
        }

        if(dir == 1) {
          m_solver->a_slope(ghostCellId, v, 1) =
              (m_solver->a_pvariable(cellId, v) - m_solver->a_pvariable(ghostCellId, v))
              / (m_solver->a_coordinate(cellId, 1) - m_solver->a_coordinate(ghostCellId, 1));
        } else {
          m_solver->a_slope(ghostCellId, v, 1) = m_solver->a_slope(cellId, v, 1);
        }

        IF_CONSTEXPR(nDim == 3) {
          if(dir == 2) {
            m_solver->a_slope(ghostCellId, v, 2) =
                (m_solver->a_pvariable(cellId, v) - m_solver->a_pvariable(ghostCellId, v))
                / (m_solver->a_coordinate(cellId, 2) - m_solver->a_coordinate(ghostCellId, 2));
          } else {
            m_solver->a_slope(ghostCellId, v, 2) = m_solver->a_slope(cellId, v, 2);
          }
        }
      }

      // compute the slopes on the ghost cell
      for(MInt v = 0; v < noPVars; v++) {
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_slope(ghostCellId, v, i) =
              2.0 * m_solver->a_slope(ghostCellId, v, i) - m_solver->a_slope(cellId, v, i);
        }
      }
    }
  }
}

/**
 * Solid wall Navier-Stokes boundary condition \n
 * Computes ghost cell slopes for the viscous flux computation \n
 * Set of variables: primitive (u,v,rho,p,Z)
 * \author Daniel Hartmann, Sven Berger
 */
template <MInt nDim, class SysEqn>
template <MInt dir>
void FvBndryCndXD<nDim, SysEqn>::sbc2901(MInt bcId) {
  TRACE();
  static_assert(dir <= nDim, "ERROR: Invalid direction!");


  const MInt noPVars = PV->noVariables;
  ScratchSpace<MFloat> PVbndry(noPVars, AT_, "PVbndry");
  ScratchSpace<MFloat> PVghost(noPVars, AT_, "PVghost");

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt bndryId = m_sortedBndryCells->a[id];
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;

      // determine the primitive variables on the boundary and on the ghost cell
      const MFloat Frho = 1.0 / m_solver->a_variable(cellId, CV->RHO);
      const MFloat FrhoGhost = 1.0 / m_solver->a_variable(ghostCellId, CV->RHO);
      // velocitites
      for(MInt i = 0; i < nDim; i++) {
        PVbndry[i] = m_solver->a_variable(cellId, CV->RHO_VV[i]) * Frho;
        PVghost[i] = m_solver->a_variable(ghostCellId, CV->RHO_VV[i]) * FrhoGhost;
      }

      // density
      PVbndry[PV->RHO] = m_solver->a_variable(cellId, CV->RHO);
      PVghost[PV->RHO] = m_solver->a_variable(ghostCellId, CV->RHO);

      // pressure
      MFloat rhoU2 = 0.0;
      for(MInt i = 0; i < nDim; i++) {
        rhoU2 += POW2(m_solver->a_variable(cellId, CV->RHO_VV[i]));
      }
      PVbndry[PV->P] =
          sysEqn().pressure(m_solver->a_variable(cellId, CV->RHO), rhoU2, m_solver->a_variable(cellId, CV->RHO_E));

      rhoU2 = F0;
      for(MInt i = 0; i < nDim; i++) {
        rhoU2 += POW2(m_solver->a_variable(ghostCellId, CV->RHO_VV[i]));
      }
      PVghost[PV->P] = sysEqn().pressure(m_solver->a_variable(ghostCellId, CV->RHO), rhoU2,
                                         m_solver->a_variable(ghostCellId, CV->RHO_E));

      // passive scalar
      for(MInt s = 0; s < m_noSpecies; s++) {
        PVbndry[PV->Y[s]] = m_solver->a_variable(cellId, CV->RHO_Y[s]) * Frho;
        PVghost[PV->Y[s]] = m_solver->a_variable(ghostCellId, CV->RHO_Y[s]) * FrhoGhost;
      }

      for(MInt var = 0; var < noPVars; var++) {
        if(dir == 0) {
          m_solver->a_slope(ghostCellId, var, 0) =
              (PVbndry[var] - PVghost[var])
              / (m_solver->a_coordinate(cellId, 0) - m_solver->a_coordinate(ghostCellId, 0));
        } else {
          m_solver->a_slope(ghostCellId, var, 0) = m_solver->a_slope(cellId, var, 0);
        }

        if(dir == 1) {
          m_solver->a_slope(ghostCellId, var, 1) =
              (PVbndry[var] - PVghost[var])
              / (m_solver->a_coordinate(cellId, 1) - m_solver->a_coordinate(ghostCellId, 1));
        } else {
          m_solver->a_slope(ghostCellId, var, 1) = m_solver->a_slope(cellId, var, 1);
        }

        IF_CONSTEXPR(nDim == 3) {
          if(dir == 2) {
            m_solver->a_slope(ghostCellId, var, 2) =
                (PVbndry[var] - PVghost[var])
                / (m_solver->a_coordinate(cellId, 2) - m_solver->a_coordinate(ghostCellId, 2));
          } else {
            m_solver->a_slope(ghostCellId, var, 2) = m_solver->a_slope(cellId, var, 2);
          }
        }
      }

      // compute the slopes on the ghost cell
      for(MInt varId = 0; varId < noPVars; varId++) {
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_slope(ghostCellId, varId, i) =
              2.0 * m_solver->a_slope(ghostCellId, varId, i) - m_solver->a_slope(cellId, varId, i);
        }
      }
    }
  }
}
//------------------------------------------------------------------------------

// Regular no slip condition is applied
template <MInt nDim, class SysEqn>
template <MBool MGC>
void FvBndryCndXD<nDim, SysEqn>::bc3399(MInt bcId) {
  TRACE();
  const MInt noSpecies = m_noSpecies;

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt bndryId = m_sortedBndryCells->a[id];
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == m_bndryCndIds[bcId]) {
          const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;

          for(MInt i = 0; i < nDim; i++) {
            if(MGC) {
              if(m_surfaceGhostCell) {
                m_solver->a_pvariable(ghostCellId, PV->VV[i]) = 0.0;
              } else {
                m_solver->a_pvariable(ghostCellId, PV->VV[i]) =
                    -m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->VV[i]];
              }
            } else {
              m_solver->a_pvariable(ghostCellId, PV->VV[i]) = -m_solver->a_pvariable(cellId, PV->VV[i]);
            }
          }
          if(MGC) {
            m_solver->a_pvariable(ghostCellId, PV->RHO) =
                m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->RHO];
            m_solver->a_pvariable(ghostCellId, PV->P) =
                m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->P];
          } else {
            // simplified Neumann: assuming the line boundary-ghost is normal to the boundary surface)
            m_solver->a_pvariable(ghostCellId, PV->RHO) = m_solver->a_pvariable(cellId, PV->RHO);
            m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);
          }

          IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
            for(MInt r = 0; r < m_solver->m_noRansEquations; ++r) {
              if(MGC) {
                if(m_surfaceGhostCell) {
                  m_solver->a_pvariable(ghostCellId, PV->NN[r]) = 0.0;
                } else {
                  m_solver->a_pvariable(ghostCellId, PV->NN[r]) =
                      -m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->NN[r]];
                }
              } else {
                m_solver->a_pvariable(ghostCellId, PV->NN[r]) = m_solver->a_pvariable(cellId, PV->NN[r]);
              }
            }
          }
          for(MInt s = 0; s < noSpecies; s++) {
            if(MGC) {
              m_solver->a_pvariable(ghostCellId, PV->Y[s]) =
                  m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->Y[s]];
            } else {
              m_solver->a_pvariable(ghostCellId, PV->Y[s]) = m_solver->a_pvariable(cellId, PV->Y[s]);
            }
          }
        }
      }
    }
  }
}

template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::initWMSurfaces() {
  TRACE();

  m_solver->m_wmSurfaces.clear();

  if(PV->noVariables > 5) mTerm(1, AT_, "WMLES not implemented for noPVars > 5");

  const MFloat utau = sqrt(m_solver->m_UInfinity / m_solver->m_wmDistance / sysEqn().m_Re0);

  for(MInt bcId = 0; bcId < m_noBndryCndIds; bcId++) {
    MInt bc = m_bndryCndIds[bcId];
    switch(bc) {
      case 3399:
        for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
          const MInt bndryId = m_sortedBndryCells->a[id];
          const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
          if(m_solver->a_hasProperty(cellId, SolverCell::IsHalo)) continue;
          if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;

          m_bndryCells->a[bndryId].m_isWMCell = true;

          for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
            m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_wmSrfcId = (MInt)m_solver->m_wmSurfaces.size();
            m_solver->m_wmSurfaces.push_back(FvWMSurface<nDim>());
            m_solver->m_wmSurfaces.back().init(bndryId, srfc, utau);
            m_solver->m_wmSurfaces.back().m_wmUII = m_solver->m_UInfinity;
            if(std::isnan(m_solver->m_wmSurfaces.back().m_wmUTAU)) {
              MLong gId = m_solver->c_globalId(cellId);
              cerr << "utau is nan at globalId = " << gId << " bndryId = " << bndryId << " surfaceId = " << srfc
                   << endl;
              m_log << "utau is nan at globalId = " << gId << " bndryId = " << bndryId << " surfaceId = " << srfc
                    << endl;
            }
          }
        }
        break;
      default:
        break;
    }
  }
}


/** \brief supersonic inflow with imposed onlique shock wave
 * version: cut-off boundary condition
 * author: Thomas Schilden, 7.3.2016
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::addModes(MInt bcId) {
  TRACE();
  const MFloat time = m_solver->m_time;
  const MInt bcNum = m_cutOffBndryCndIds[bcId];

  for(MInt mode = 0; mode < m_modes; mode++) {
    const MFloat modeEtaMin = m_modeEtaMin[mode];
    const MFloat modePhi = m_modePhi[mode];
    const MFloat modeOmega = m_modeOmega[mode];

    // 0. set the end of the wave(s)
    const MFloat modeEtaMax = -(MFloat)(m_nmbrOfModes[mode]) * PI;

    // 1. pressure
    const MFloat pressure_f = m_modeAmp[mode] * m_solver->m_PInfinity * (MFloat)(m_modeType[mode]);

    // 2. density
    const MFloat a = sysEqn().speedOfSound(m_solver->m_TInfinity);
    const MFloat density_f = m_modeType[mode] ? pressure_f / POW2(a) : m_modeAmp[mode] * m_solver->m_rhoInfinity;

    // 3. velocity
    MFloat K = F0;
    for(MInt i = 0; i < nDim; i++) {
      K += pow(m_modeK[mode][i], 2);
    }
    K = sqrt(K);
    const MFloat acImp = a * m_solver->m_rhoInfinity;
    const MFloat modeVelocity = (MFloat)(m_modeType[mode]) * pressure_f / acImp;
    MFloat velocity_f[3];
    for(MInt i = 0; i < nDim; i++) {
      velocity_f[i] = (m_modeK[mode][i] * modeVelocity) / K;
    }

    for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
      const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
      if(bcNum == 2770) {
        if(m_solver->a_coordinate(cellId, 1)
           < m_ys + (tan(m_solver->m_angle[0] + m_sigmaShock) * m_solver->a_coordinate(cellId, 0))) {
          continue;
        }
      }
      // 1. calculate cell dependant trigonometry
      MFloat trigTerm = F0;
      for(MInt i = 0; i < nDim; i++) {
        trigTerm += m_modeK[mode][i] * m_solver->a_coordinate(cellId, i);
      }
      trigTerm -= modeOmega * time;
      trigTerm += modePhi;

      // 2. filter the wave
      if(bcNum == 2800) {
        // 2.a calculate the difference to the reference starting min value (trigTerm decreases in time)
        trigTerm -= modeEtaMin;

        // 2.b apply the filter to the phase
        if(trigTerm > F0 || trigTerm < modeEtaMax) {
          trigTerm = F0;
        }
      }

      // 3. convert phase to amplitude
      trigTerm = sin(trigTerm);

      // 4. add fluctuations
      // density
      m_solver->a_pvariable(cellId, PV->RHO) += trigTerm * density_f;

      // velocities
      for(MInt dim = 0; dim < m_solver->nDim; dim++) {
        m_solver->a_pvariable(cellId, PV->VV[dim]) += trigTerm * velocity_f[dim];
      }

      // pressure
      m_solver->a_pvariable(cellId, PV->P) += trigTerm * pressure_f;
    }
  }
}


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::initModes(MInt bcId) {
  const MInt bcNum = m_cutOffBndryCndIds[bcId];
  m_log << endl << "initializing plane modes for bcId " << bcId << endl;
  m_log << " running for " << bcNum << endl;

  const MFloat time = m_solver->m_restart ? m_solver->m_time : F0;

  // 1. check the modes and allocate memory
  /*! \page propertiesFV
    \section modeType
    <code>MInt* FvBndrycndXd::m_modeType </code>\n
    default = <code>none</code>\n \n
    A list of integers defining disturbances, i.e., plane entropy or acoustic waves, superimposed to the freestream\n
    Possible values are:
    <ul>
      <li>-1 for a slow acoustic wave</li>
      <li>0 for an entropy wave</li>
      <li>1 for a fast acoustic wave</li>
    </ul>
    Keywords: <i>TUNNEL NOISE, RECEPTIVITY, bc2800</i>
  */
  m_modes = Context::propertyLength("modeType", m_solverId);
  mAlloc(m_modeType, m_modes, "m_modeType", 0, AT_);
  for(MInt i = 0; i < m_modes; i++) {
    m_modeType[i] = Context::getSolverProperty<MInt>("modeType", m_solverId, AT_, i);
  }
  /*! \page propertiesFV
    \section modeAmp
    <code>MFloat* FvBndrycndXd::m_modeAmp </code>\n
    default = <code>none</code>\n \n
    A list of doubles defining the amplitude of the disturbances in modeType, must have the same length as modeType\n
    Possible values are:
    <ul>
      <li>small values of about 0.001 to remain in the scope of the linearized euler equations </li>
    </ul>
    Keywords: <i>TUNNEL NOISE, RECEPTIVITY, bc2800</i>
  */
  if(m_modes != Context::propertyLength("modeAmp", m_solverId)) mTerm(1, AT_, "modeAmp does not fit modeType");
  mAlloc(m_modeAmp, m_modes, "m_modeAmp", F0, AT_);
  for(MInt i = 0; i < m_modes; i++) {
    m_modeAmp[i] = Context::getSolverProperty<MFloat>("modeAmp", m_solverId, AT_, i);
  }
  /*! \page propertiesFV
    \section modePhi
    <code>MFloat* FvBndrycndXd::m_modePhi </code>\n
    default = <code>none</code>\n \n
    A list of phase differences of the disturbances in modeType with respect to the lowest argument found in the
    computational domain, must have the same length as modeType\n Possible values are: <ul> <li>0 - 2*pi make sense
    </li>
    </ul>
    Keywords: <i>TUNNEL NOISE, RECEPTIVITY, bc2800</i>
  */
  if(m_modes != Context::propertyLength("modePhi", m_solverId)) mTerm(1, AT_, "modePhi does not fit modeType");
  mAlloc(m_modePhi, m_modes, "m_modePhi", F0, AT_);
  for(MInt i = 0; i < m_modes; i++) {
    m_modePhi[i] = Context::getSolverProperty<MFloat>("modePhi", m_solverId, AT_, i) * PI / 180.0;
  }
  /*! \page propertiesFV
    \section modeAngle
    <code>MFloat** FvBndrycndXd::m_modeK </code>\n
    default = <code>none</code>\n \n
    A list of angles for the plane waves of modeType with respect to the x axis (as angle for the flow), must have twice
    the length as modeType\n Possible values are: <ul> <li>depends on the dispersion relation of the mode type</li>
    </ul>
    Keywords: <i>TUNNEL NOISE, RECEPTIVITY, bc2800</i>
  */
  if(m_modes * 2 != Context::propertyLength("modeAngle", m_solverId)) mTerm(1, AT_, "modeAngle does not fit modeType");
  MFloatScratchSpace modeAngle(m_modes, 2, AT_, "modeAngle");
  modeAngle.fill(F0);
  mAlloc(m_modeK, m_modes, nDim, "m_modeK", F0, AT_);
  for(MInt mode = 0; mode < m_modes; mode++) {
    for(MInt j = 0; j < nDim - 1; j++) {
      modeAngle(mode, j) = Context::getSolverProperty<MFloat>("modeAngle", m_solverId, AT_, mode * 2 + j) * PI / 180.0;
    }
    m_modeK[mode][0] = cos(modeAngle(mode, 0)) * cos(modeAngle(mode, 1));
    m_modeK[mode][1] = sin(modeAngle(mode, 0)) * cos(modeAngle(mode, 1));
    IF_CONSTEXPR(nDim == 3) m_modeK[mode][2] = sin(modeAngle(mode, 1));
  }

  /*! \page propertiesFV
    \section nmbrOfModes
    <code>MInt* FvBndrycndXd::m_nmbrOfModes </code>\n
    default = <code>none</code>\n \n
    A list of number of oscillations (0 to 2*pi) of the plane waves from modeType, must have the same length as
    modeType\n Possible values are: <ul> <li>0 - whatever</li>
    </ul>
    Keywords: <i>TUNNEL NOISE, RECEPTIVITY, bc2800</i>
  */
  if(m_modes != Context::propertyLength("nmbrOfModes", m_solverId)) mTerm(1, AT_, "nmbrOfModes does not fit modeType");
  mAlloc(m_nmbrOfModes, m_modes, "m_nmbrOfModes", 0, AT_);
  for(MInt i = 0; i < m_modes; i++) {
    m_nmbrOfModes[i] = Context::getSolverProperty<MInt>("nmbrOfModes", m_solverId, AT_, i);
  }
  MFloatScratchSpace modeSr(m_modes, AT_, "modeSr");
  MFloat UInfinity = F0;
  for(MInt i = 0; i < nDim; i++) {
    UInfinity += POW2(m_solver->m_VVInfinity[i]);
  }
  UInfinity = sqrt(UInfinity);

  MFloat lambdaParN = F0;
  for(MInt i = 0; i < nDim; i++) {
    if(m_solver->grid().periodicCartesianDir(i) > 0) {
      if(lambdaParN > F0) mTerm(1, AT_, "more then two periodic directions in initModes");
      lambdaParN += m_solver->grid().periodicCartesianLength(i);
    }
  }
  m_log << "periodic length " << lambdaParN << endl;
  if(lambdaParN > F0) {
    m_log << "periodicCartesianDir: calculating modeSr from nmbrPeriodicModes" << endl;
    MFloatScratchSpace nmbrPeriodicModes(m_modes, AT_, "nmbrPeriodicModes");
    /*! \page propertiesFV
      \section nmbrPeriodicModes
      <code>MInt* FvBndrycndXd::m_modeSr </code>\n
      default = <code>none</code>\n \n
      In case of cartesian periodicity, a List of integers defining the number of wave length to fit into the width of
      the periodic domain for the plane waves of modeType, must have the same length as modeType, see modeSr\n Possible
      values are: <ul> <li>1 - whatever</li>
      </ul>
      Keywords: <i>TUNNEL NOISE, RECEPTIVITY, bc2800</i>
    */
    if(m_modes != Context::propertyLength("nmbrPeriodicModes", m_solverId)) {
      mTerm(1, AT_, "nmbrPeriodicModes does not fit modeType");
    }

    for(MInt i = 0; i < m_modes; i++) {
      nmbrPeriodicModes(i) = Context::getSolverProperty<MInt>("nmbrPeriodicModes", m_solverId, AT_, i);
    }
    // compute Sr number
    for(MInt mode = 0; mode < m_modes; mode++) {
      MFloat Uk = F0;
      for(MInt i = 0; i < nDim; i++) {
        Uk += m_solver->m_VVInfinity[i] * m_modeK[mode][i];
      }

      MFloat lambdaDotKnorm = F0;
      for(MInt i = 0; i < nDim; i++) {
        if(m_solver->grid().periodicCartesianDir(i) > 0) {
          if(lambdaDotKnorm > F0) mTerm(1, AT_, "more then two periodic directions in initModes");
          lambdaDotKnorm += m_solver->grid().periodicCartesianLength(i) * m_modeK[mode][i];
        }
      }

      if(lambdaDotKnorm / lambdaParN < pow(10, -3)) {
        m_log << " modeSr(" << mode << ") from property file" << endl;
        if(m_modes != Context::propertyLength("modeSr", m_solverId)) mTerm(1, AT_, "modeType does not fit modeSr");
        modeSr(mode) = Context::getSolverProperty<MInt>("modeSr", m_solverId, AT_, mode);
      } else {
        modeSr(mode) = nmbrPeriodicModes(mode) * m_solver->m_referenceLength
                       * abs((MFloat)(m_modeType[mode]) * sysEqn().speedOfSound(m_solver->m_TInfinity) + Uk)
                       / (UInfinity * abs(lambdaDotKnorm));
      }
      m_log << "modeSr(" << mode << ") = " << modeSr(mode) << endl;
    }
  } else {
    /*! \page propertiesFV
      \section modeSr
      <code>MFloat* FvBndrycndXd::m_modeSr </code>\n
      default = <code>none</code>\n \n
      List of Strouhal numbers (nondimensional frequency build with the freestream velocity and m_referenceLength) for
      the plane waves of modeType, must have the same length as modeType\n In case of cartesian periodicity, the
      Strouhal numbers are calculated from the wave vector and the width of the periodic domain\n Possible values are:
      <ul>
        <li>0 - whatever</li>
      </ul>
      Keywords: <i>TUNNEL NOISE, RECEPTIVITY, bc2800</i>
    */
    if(m_modes != Context::propertyLength("modeSr", m_solverId)) mTerm(1, AT_, "modeType does not fit modeSr");
    for(MInt i = 0; i < m_modes; i++) {
      modeSr(i) = Context::getSolverProperty<MFloat>("modeSr", m_solverId, AT_, i);
    }
  }
  // time considerations
  MFloat initTime;
  if(m_solver->m_restartBc2800) {
    initTime = m_solver->m_restartTimeBc2800;
  } else {
    initTime = time;
    m_solver->m_restartTimeBc2800 = time;
  }
  m_log << "time        = " << time << endl;
  m_log << "initTime    = " << initTime << endl;

  // further memberVariables
  mAlloc(m_modeOmega, m_modes, "m_modeOmega", F0, AT_);
  mAlloc(m_modeEtaMin, m_modes, "m_modeEtaMin", F0, AT_);
  // fill the member variables
  for(MInt mode = 0; mode < m_modes; mode++) {
    m_log << "-- mode " << mode << " --" << endl;
    m_log << "   modeType = " << m_modeType[mode] << endl;
    m_log << "   modeSr = " << modeSr(mode) << endl;
    m_log << "   modeAmp = " << m_modeAmp[mode] << endl;
    m_log << "   modePhi = " << m_modePhi[mode] << endl;
    m_log << "   nmbrOfModes= " << m_nmbrOfModes[mode] << endl;
    for(MInt i = 0; i < (nDim - 1); i++) {
      m_log << "   modeAngle(" << i << ") = " << modeAngle(mode, i) << " (rad)" << endl;
    }
    // 3. calculate nondimensional mode properties
    // 3.1 omega
    m_modeOmega[mode] = F2 * PI * modeSr(mode) * UInfinity / m_solver->m_referenceLength;
    // 3.2 complete wave vector modeK
    MFloat Uk = F0;
    for(MInt i = 0; i < nDim; i++) {
      Uk += m_solver->m_VVInfinity[i] * m_modeK[mode][i];
    }
    const MFloat propVel = (MFloat)(m_modeType[mode]) * sysEqn().speedOfSound(m_solver->m_TInfinity);
    const MFloat K = m_modeOmega[mode] / abs(Uk + propVel);
    for(MInt i = 0; i < nDim; i++) {
      m_modeK[mode][i] *= K;
    }
    // output omega and k
    m_log << "   Uk = " << Uk << endl;
    m_log << "   modeOmega = " << m_modeOmega[mode] << endl;
    m_log << "   K = " << K << endl;
    for(MInt i = 0; i < nDim; i++) {
      m_log << "   modeK[" << i << "] = " << m_modeK[mode][i] << endl;
    }
    // 4. get the min wave phase
    MFloat modeEtaMin = std::numeric_limits<MFloat>::max();
    for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
      MInt cellId = m_sortedCutOffCells[bcId]->a[id];
      if(m_solver->a_isHalo(cellId)) continue;
      if(bcNum == 2770) {
        if(m_solver->a_coordinate(cellId, 1)
           < m_ys /* + (tan(m_solver->m_angle[0] + m_sigmaShock) * m_solver->a_coordinate(cellId , 0))*/) {
          continue;
        }
      }

      MFloat eta = F0;
      for(MInt i = 0; i < nDim; i++) {
        eta += m_solver->a_coordinate(cellId, i) * m_modeK[mode][i];
      }
      eta -= m_modeOmega[mode] * initTime;

      modeEtaMin = mMin(modeEtaMin, eta);
    }
    m_modeEtaMin[mode] = modeEtaMin;
    // 5. communicate the etaMin
    MPI_Allreduce(MPI_IN_PLACE, &(m_modeEtaMin[mode]), 1, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE",
                  "(m_modeEtaMin[mode])");

    m_log << "   modeEtaMin = " << m_modeEtaMin[mode] << endl;
  }
  m_log << " mode initialisation finished" << endl;
}


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::initBesselModes(MInt bcId) {
  const MInt bcNum = m_cutOffBndryCndIds[bcId];
  m_log << endl << "initializing bessel modes for bcId " << bcId << endl;
  m_log << " running for " << bcNum << endl;

  const MFloat time = m_solver->m_restart ? m_solver->m_time : F0;

  /*! \page propertiesFV
    \section modeType
    <code>MInt* FvBndrycndXd::m_modeType </code>\n
    default = <code>none</code>\n \n
    A list of integers defining disturbances, i.e., plane entropy or acoustic waves, superimposed to the freestream\n
    Possible values are:
    <ul>
      <li>-1 for a slow acoustic wave</li>
      <li>0 for an entropy wave</li>
      <li>1 for a fast acoustic wave</li>
    </ul>
    Keywords: <i>TUNNEL NOISE, RECEPTIVITY, bc2800</i>
  */
  m_modes = Context::propertyLength("modeType", m_solverId);
  mAlloc(m_modeType, m_modes, "m_modeType", 0, AT_);
  for(MInt i = 0; i < m_modes; i++) {
    m_modeType[i] = Context::getSolverProperty<MInt>("modeType", m_solverId, AT_, i);
  }

  /*! \page propertiesFV
    \section modeAmp
    <code>MFloat* FvBndrycndXd::m_modeAmp </code>\n
    default = <code>none</code>\n \n
    A list of doubles defining the amplitude of the disturbances in modeType, must have the same length as modeType\n
    Possible values are:
    <ul>
      <li>small values of about 0.001 to remain in the scope of the linearized euler equations </li>
    </ul>
    Keywords: <i>TUNNEL NOISE, RECEPTIVITY, bc2800</i>
  */
  if(m_modes != Context::propertyLength("modeAmp", m_solverId)) mTerm(1, AT_, "modeAmp does not fit modeType");
  mAlloc(m_modeAmp, m_modes, "m_modeAmp", F0, AT_);
  for(MInt i = 0; i < m_modes; i++) {
    m_modeAmp[i] = Context::getSolverProperty<MFloat>("modeAmp", m_solverId, AT_, i);
  }

  /*! \page propertiesFV
    \section modeAngle
    <code>MFloat** FvBndrycndXd::m_modeK </code>\n
    default = <code>none</code>\n \n
    A list of angles for the plane waves of modeType with respect to the x axis (as angle for the flow)\n
    Possible values are:
    <ul>
      <li>depends on the dispersion relation of the mode type</li>
    </ul>
    Keywords: <i>TUNNEL NOISE, RECEPTIVITY, bc2800</i>
  */
  if(m_modes != Context::propertyLength("modeAngle", m_solverId)) mTerm(1, AT_, "modeAngle does not fit modeType");
  MFloatScratchSpace modeAngle(m_modes, AT_, "modeAngle");
  for(MInt i = 0; i < m_modes; i++) {
    modeAngle(i) = Context::getSolverProperty<MFloat>("modeAnlge", m_solverId, AT_, i) * PI / 180.0;
    if(bcNum == 2800 && modeAngle(i) < F0) {
      mTerm(1, AT_,
            "error in modeAngle property: correct implementation of circumferential integrals not tested for "
            "negative radial wave numbers, switch sign");
    }
  }

  /*! \page propertiesFV
    \section modeSr
    <code>MFloat* FvBndrycndXd::m_modeSr </code>\n
    default = <code>none</code>\n \n
    List of Strouhal numbers (nondimensional frequency build with the freestream velocity and m_referenceLength) for the
    plane waves of modeType, must have the same length as modeType\n In case of cartesian periodicity, the Strouhal
    numbers are calculated from the wave vector and the width of the periodic domain\n Possible values are: <ul> <li>0 -
    whatever</li>
    </ul>
    Keywords: <i>TUNNEL NOISE, RECEPTIVITY, bc2800</i>
  */
  if(m_modes != Context::propertyLength("modeSr", m_solverId)) mTerm(1, AT_, "modeType does not fit modeSr");
  MFloatScratchSpace modeSr(m_modes, AT_, "modeSr");
  for(MInt i = 0; i < m_modes; i++) {
    modeSr(i) = Context::getSolverProperty<MFloat>("modeSr", m_solverId, AT_, i);
  }

  /*! \page propertiesFV
    \section nmbrOfModes
    <code>MInt* FvBndrycndXd::m_nmbrOfModes </code>\n
    default = <code>none</code>\n \n
    A list of number of oscillations (0 to 2*pi) of the plane waves from modeType, must have the same length as
    modeType\n Possible values are: <ul> <li>0 - whatever</li>
    </ul>
    Keywords: <i>TUNNEL NOISE, RECEPTIVITY, bc2800</i>
  */
  if(m_modes != Context::propertyLength("nmbrOfModes", m_solverId)) mTerm(1, AT_, "nmbrOfModes does not fit modeType");
  mAlloc(m_nmbrOfModes, m_modes, "m_nmbrOfModes", 0, AT_);
  for(MInt i = 0; i < m_modes; i++) {
    m_nmbrOfModes[i] = Context::getSolverProperty<MInt>("nmbrOfModes", m_solverId, AT_, i);
  }

  // further memberVariables
  mAlloc(m_modeOmega, m_modes, "m_modeOmega", F0, AT_);
  mAlloc(m_modeK, m_modes, 2, "m_modeK", F0, AT_);
  mAlloc(m_modeEtaMin, m_modes, "m_modeEtaMin", F0, AT_);
  // storage for the results of the circumferential integrals, +0 is pressure, +1 is radial velocity
  mAlloc(m_besselTrig, m_modes * 2 * m_sortedCutOffCells[bcId]->size(), "m_besselTrig", F0, AT_);

  // time considerations
  MFloat initTime;
  if(m_solver->m_restartBc2800) {
    initTime = m_solver->m_restartTimeBc2800;
  } else {
    initTime = time;
    m_solver->m_restartTimeBc2800 = time;
  }
  m_log << "time        = " << time << endl;
  m_log << "initTime    = " << initTime << endl;

  // fill the member variables
  for(MInt mode = 0; mode < m_modes; mode++) {
    m_log << "   modeType = " << m_modeType[mode] << endl;
    m_log << "   modeSr = " << modeSr(mode) << endl;
    m_log << "   modeAmp = " << m_modeAmp[mode] << endl;
    m_log << "   modeAngle = " << modeAngle(mode) << " (rad)" << endl;

    // omega
    m_modeOmega[mode] = F2 * PI * modeSr(mode) * m_solver->m_VVInfinity[0] / m_solver->m_referenceLength;

    // wave vector modeK
    m_modeK[mode][0] = cos(modeAngle(mode)); // axial
    m_modeK[mode][1] = sin(modeAngle(mode)); // radial
    MFloat Uk = m_solver->m_VVInfinity[0] * m_modeK[mode][0];
    const MFloat propVel = (MFloat)(m_modeType[mode]) * sysEqn().speedOfSound(m_solver->m_TInfinity);
    const MFloat K = m_modeOmega[mode] / abs(Uk + propVel);
    for(MInt i = 0; i < 2; i++) {
      m_modeK[mode][i] *= K;
    }

    // output
    m_log << "   Uk = " << Uk << endl;
    m_log << "   modeOmega = " << m_modeOmega[mode] << endl;
    m_log << "   K = " << K << endl;
    for(MInt i = 0; i < 2; i++) {
      m_log << "   modeK[" << i << "] = " << m_modeK[mode][i] << endl;
    }

    // get the min wave phase
    MFloat modeEtaMin = std::numeric_limits<MFloat>::max();
    for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
      const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
      if(m_solver->a_isHalo(cellId)) continue;
      const MFloat x = m_solver->a_coordinate(cellId, 0);
      const MFloat r = sqrt(POW2(m_solver->a_coordinate(cellId, 1)) + POW2(m_solver->a_coordinate(cellId, 2)));

      const MFloat eta = x * m_modeK[mode][0] - r * m_modeK[mode][1] - m_modeOmega[mode] * initTime - PIB2;

      modeEtaMin = mMin(modeEtaMin, eta);
    }
    // communicate the etaMin
    MPI_Allreduce(MPI_IN_PLACE, &modeEtaMin, 1, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE", "modeEtaMin");
    m_modeEtaMin[mode] = modeEtaMin;
    m_log << "   modeEtaMin = " << m_modeEtaMin[mode] << endl;
  }
  m_log << " mode initialisation finished" << endl;
}


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::precomputeBesselTrigonometry(MInt bcId) {
  TRACE();
  const MFloat time = m_solver->m_time;
  const MBool isFiltered = m_cutOffBndryCndIds[bcId] == 2800 ? true : false;
  const MInt noCutOffCells = m_sortedCutOffCells[bcId]->size();

  for(MInt mode = 0; mode < m_modes; mode++) {
    const MFloat modeOmega = m_modeOmega[mode];
    const MFloat modeEtaMin = m_modeEtaMin[mode];
    const MFloat dphi = m_nmbrOfModes[mode] * PI;

    for(MInt id = 0; id < noCutOffCells; id++) {
      const MInt cellId = m_sortedCutOffCells[bcId]->a[id];

      // polar coords
      const MFloat dy = m_solver->a_coordinate(cellId, 1);
      const MFloat dz = m_solver->a_coordinate(cellId, 2);
      const MFloat r = sqrt(POW2(dy) + POW2(dz));

      // argument
      const MFloat xkxmot = m_modeK[mode][0] * m_solver->a_coordinate(cellId, 0) - modeOmega * time;
      const MFloat rkr = r * m_modeK[mode][1];

      const MInt offset = mode * noCutOffCells + 2 * id;

      if(isFiltered) {
        calcBesselFractions(xkxmot - modeEtaMin, rkr, dphi, m_besselTrig[offset], m_besselTrig[offset + 1]);
      } else {
        m_besselTrig[offset] = cos(xkxmot) * maia::math::besselJ0(rkr);
        m_besselTrig[offset + 1] = cos(xkxmot + PIB2) * maia::math::besselJ1(rkr);
      }
    }
  }
}


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::addBesselModes(MInt bcId) {
  TRACE();
  const MInt noCutOffCells = m_sortedCutOffCells[bcId]->size();

  for(MInt mode = 0; mode < m_modes; mode++) {
    // speed of sound
    const MFloat a = sysEqn().speedOfSound(m_solver->m_TInfinity);

    // 1. pressure
    const MFloat pressure_f = m_modeAmp[mode] * m_solver->m_PInfinity * (MFloat)(m_modeType[mode]);

    // 2. density
    const MFloat density_f = m_modeType[mode] ? pressure_f / POW2(a) : m_modeAmp[mode] * m_solver->m_rhoInfinity;

    // 3. velocity
    const MFloat acImp = a * m_solver->m_rhoInfinity;
    const MFloat velocity_f = (MFloat)(m_modeType[mode]) * pressure_f / acImp;
    const MFloat cosIncl = cos(atan2(m_modeK[mode][1], m_modeK[mode][0]));
    const MFloat sinIncl = sin(atan2(m_modeK[mode][1], m_modeK[mode][0]));

    for(MInt id = 0; id < noCutOffCells; id++) {
      const MInt cellId = m_sortedCutOffCells[bcId]->a[id];

      const MFloat phi = atan2(m_solver->a_coordinate(cellId, 1), m_solver->a_coordinate(cellId, 2));

      const MInt offset = mode * noCutOffCells + 2 * id;
      const MFloat trig_P_RHO_U = m_besselTrig[offset];
      const MFloat trig_V_W = m_besselTrig[offset + 1];

      // density
      m_solver->a_pvariable(cellId, PV->RHO) += density_f * trig_P_RHO_U;

      // axial velocity
      m_solver->a_pvariable(cellId, PV->U) += velocity_f * cosIncl * trig_P_RHO_U;

      // radial velocity
      const MFloat radialVelocity = velocity_f * sinIncl * trig_V_W;
      m_solver->a_pvariable(cellId, PV->V) += radialVelocity * sin(phi);
      m_solver->a_pvariable(cellId, PV->W) += radialVelocity * cos(phi);

      // pressure
      m_solver->a_pvariable(cellId, PV->P) += pressure_f * trig_P_RHO_U;
    }
  }
}


// xkxmot already accounts for modeEtaMin
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::calcBesselFractions(const MFloat xkxmot, const MFloat rkr, const MFloat dphi,
                                                     MFloat& trig_P_RHO_U, MFloat& trig_V_W) {
  TRACE();
  const MFloat phiMax = xkxmot + rkr;
  const MFloat phiMin = xkxmot - rkr;
  const MFloat PIB2MinusDdhi = PIB2 - dphi;
  // numerics
  const MFloat DPSI = PI / 180; // resolution in circumferential direction
  const MInt MINN = 10;         // minimal number of integration steps
  const MFloat INTDEC = PIB2;   // do i calc (f) or (bessel - f~)
  if(phiMin >= PIB2 || phiMax <= PIB2MinusDdhi) {
    // rkr*cos(\hat{psi}) is not inside the kxmowt range
    trig_V_W = F0;
    trig_P_RHO_U = F0;
  } else if(phiMin >= PIB2MinusDdhi && phiMax <= PIB2) {
    // rkr*cos(\hat{psi}) is completely inside the kxmowt range
    trig_V_W = cos(xkxmot + PIB2) * maia::math::besselJ1(rkr);
    trig_P_RHO_U = cos(xkxmot) * maia::math::besselJ0(rkr);
  } else if(phiMin < PIB2MinusDdhi && phiMax > PIB2) {
    // rkr*cos(\hat{psi}) extends both limits of the kxmowt range
    const MFloat psihatmax = acos((PIB2 - xkxmot) / rkr);
    const MFloat psihatmin = acos((PIB2MinusDdhi - xkxmot) / rkr);
    if(psihatmin - psihatmax < INTDEC) {
      // from first intersection at psihatmax to second intersection at psihatmin
      const MInt noSeg = mMax((MInt)ceil((psihatmin - psihatmax) / DPSI), MINN);
      const MFloat dpsi = (psihatmin - psihatmax) / noSeg;
      MFloat firstValB1 = F0;
      MFloat resultB1 = F0;
      MFloat firstValB2 = F0;
      MFloat resultB2 = F0;
      for(MInt cnt = 1; cnt <= noSeg; cnt++) {
        const MFloat secondValB1 = maia::math::lincos(xkxmot + rkr * maia::math::lincos(psihatmax + cnt * dpsi));
        const MFloat secondValB2 = maia::math::lincos(psihatmax + cnt * dpsi) * secondValB1;
        resultB1 += F1B2 * (firstValB1 + secondValB1) * dpsi;
        resultB2 += F1B2 * (firstValB2 + secondValB2) * dpsi;
        firstValB1 = secondValB1;
        firstValB2 = secondValB2;
      }
      trig_P_RHO_U = resultB1 / PI;
      trig_V_W = resultB2 / PI;
    } else {
      // from zero to first intersection at psihatmax
      const MInt noSeg1 = mMax((MInt)ceil(psihatmax / DPSI), MINN);
      const MFloat dpsi1 = psihatmax / noSeg1;
      MFloat firstValB1 = maia::math::lincos(phiMax);
      MFloat firstValB2 = maia::math::lincos(phiMax);
      MFloat resultB1 = F0;
      MFloat resultB2 = F0;
      for(MInt cnt = 1; cnt <= noSeg1; cnt++) {
        const MFloat secondValB1 = maia::math::lincos(xkxmot + rkr * maia::math::lincos(cnt * dpsi1));
        const MFloat secondValB2 = maia::math::lincos(cnt * dpsi1) * secondValB1;
        resultB1 += F1B2 * (firstValB1 + secondValB1) * dpsi1;
        resultB2 += F1B2 * (firstValB2 + secondValB2) * dpsi1;
        firstValB1 = secondValB1;
        firstValB2 = secondValB2;
      }
      // from second intersection at psihatmin to PI
      const MInt noSeg2 = mMax((MInt)ceil((PI - psihatmin) / DPSI), MINN);
      const MFloat dpsi2 = (PI - psihatmin) / noSeg2;
      firstValB1 = F0;
      firstValB2 = F0;
      for(MInt cnt = 1; cnt <= noSeg2; cnt++) {
        const MFloat secondValB1 = maia::math::lincos(xkxmot + rkr * maia::math::lincos(psihatmin + cnt * dpsi2));
        const MFloat secondValB2 = maia::math::lincos(psihatmin + cnt * dpsi2) * secondValB1;
        resultB1 += F1B2 * (firstValB1 + secondValB1) * dpsi2;
        resultB2 += F1B2 * (firstValB2 + secondValB2) * dpsi2;
        firstValB1 = secondValB1;
        firstValB2 = secondValB2;
      }
      trig_P_RHO_U = cos(xkxmot) * maia::math::besselJ0(rkr) - resultB1 / PI;
      trig_V_W = cos(xkxmot + PIB2) * maia::math::besselJ1(rkr) - resultB2 / PI;
    }
  } else {
    // rkr*cos(\hat{psi}) extends at least one limit of the kxmowt range, the other one might be on the limit
    const MFloat psihatintersec = acos((((phiMax > PIB2) ? PIB2 : PIB2MinusDdhi) - xkxmot) / rkr);
    if(psihatintersec < INTDEC) {
      // from zero to intersection
      const MInt noSeg = mMax((MInt)ceil(psihatintersec / DPSI), MINN);
      const MFloat dpsi = psihatintersec / noSeg;
      MFloat firstValB1 = maia::math::lincos(phiMax);
      MFloat firstValB2 = maia::math::lincos(phiMax);
      MFloat resultB1 = F0;
      MFloat resultB2 = F0;
      for(MInt cnt = 1; cnt <= noSeg; cnt++) {
        const MFloat secondValB1 = maia::math::lincos(xkxmot + rkr * maia::math::lincos(cnt * dpsi));
        const MFloat secondValB2 = maia::math::lincos(cnt * dpsi) * secondValB1;
        resultB1 += F1B2 * (firstValB1 + secondValB1) * dpsi;
        resultB2 += F1B2 * (firstValB2 + secondValB2) * dpsi;
        firstValB1 = secondValB1;
        firstValB2 = secondValB2;
      }
      if(phiMax > PIB2) {
        trig_P_RHO_U = cos(xkxmot) * maia::math::besselJ0(rkr) - resultB1 / PI;
        trig_V_W = cos(xkxmot + PIB2) * maia::math::besselJ1(rkr) - resultB2 / PI;
      } else {
        trig_P_RHO_U = resultB1 / PI;
        trig_V_W = resultB2 / PI;
      }
    } else {
      // from intersection to PI
      const MInt noSeg = mMax((MInt)ceil((PI - psihatintersec) / DPSI), MINN);
      const MFloat dpsi = (PI - psihatintersec) / noSeg;
      MFloat firstValB1 = F0;
      MFloat firstValB2 = F0;
      MFloat resultB1 = F0;
      MFloat resultB2 = F0;
      for(MInt cnt = 1; cnt <= noSeg; cnt++) {
        const MFloat secondValB1 = maia::math::lincos(xkxmot + rkr * maia::math::lincos(psihatintersec + cnt * dpsi));
        const MFloat secondValB2 = maia::math::lincos(psihatintersec + cnt * dpsi) * secondValB1;
        resultB1 += F1B2 * (firstValB1 + secondValB1) * dpsi;
        resultB2 += F1B2 * (firstValB2 + secondValB2) * dpsi;
        firstValB1 = secondValB1;
        firstValB2 = secondValB2;
      }
      if(phiMax > PIB2) {
        trig_P_RHO_U = resultB1 / PI;
        trig_V_W = resultB2 / PI;
      } else {
        trig_P_RHO_U = cos(xkxmot) * maia::math::besselJ0(rkr) - resultB1 / PI;
        trig_V_W = cos(xkxmot + PIB2) * maia::math::besselJ1(rkr) - resultB2 / PI;
      }
    }
  }
}


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::checkBoundaryCells() {
  TRACE();

  MInt noCells = m_bndryCells->size();

  // check boundary cell volumes
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    if(m_bndryCells->a[bndryId].m_volume <= 0) {
      cerr << "Cell " << m_bndryCells->a[bndryId].m_cellId << " at level "
           << m_solver->a_level(m_bndryCells->a[bndryId].m_cellId) << " has volume "
           << m_bndryCells->a[bndryId].m_volume << endl;
      cerr << "Cut points of cell " << m_bndryCells->a[bndryId].m_cellId << ":" << endl;
      for(MInt point = 0; point < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; point++) {
        for(MInt i = 0; i < nDim; i++) {
          cerr << point << " x" << i << " " << m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[point][i] << endl;
        }
      }
    }
    /*
    if( m_bndryCells->a[ bndryId ].m_srfcs[0]->m_noCutPoints != 2 ) {
      cerr << "Cell "
     << m_bndryCells->a[ bndryId ].m_cellId
     << " at level "
     << m_solver->a_level( m_bndryCells->a[ bndryId ].m_cellId )
     << " does not have 2 cut points " << endl;
    }
    //check neighbors
    MInt counter = 0;
    for( MInt dirId = 0; dirId < 2*nDim; dirId++ ) {
      if( m_bndryCells->a[ bndryId ].m_noNghbrIds[ dirId ] > 0 ) {
  counter += m_bndryCells->a[ bndryId ].m_noNghbrIds[ dirId ];
      }
    }
    MInt bndryIdNghbr;
    if( counter < 2 || counter > 3 ) {
      cerr << "At level (direction 0) " << m_solver->a_level( m_bndryCells->a[ bndryId ].m_cellId ) << endl;
      cerr << "Number of boundary cell neighbors of " << m_bndryCells->a[ bndryId ].m_cellId << ": " << counter << endl;
      cerr << m_solver->a_coordinate( m_bndryCells->a[ bndryId ].m_cellId ,  0 ) << " "
     << m_solver->a_coordinate( m_bndryCells->a[ bndryId ].m_cellId ,  1 ) << " "
     << m_solver->c_cellLengthAtCell(m_bndryCells->a[ bndryId ].m_cellId ) << endl;
      cerr << "Number of cut points " << m_bndryCells->a[ bndryId ].m_srfcs[0]->m_noCutPoints << endl;
      for( MInt i = 0; i < m_bndryCells->a[ bndryId ].m_srfcs[0]->m_noCutPoints; i++ ) {
  cerr << m_bndryCells->a[ bndryId ].m_srfcs[0]->m_cutCoordinates[ i ][ 0 ] << " "
       << m_bndryCells->a[ bndryId ].m_srfcs[0]->m_cutCoordinates[ i ][ 1 ] << endl;
      }
      cerr << "Boundary cell neighbor information:" << endl;
      for( MInt dirId = 0; dirId < m_noDirs; dirId++ ) {
  if( m_bndryCells->a[ bndryId ].m_noNghbrIds[ dirId ] > 0 ) {
    cerr << "+++++" << endl;
    cerr << "Neighbor in " << dirId << " direction..." << endl;
    bndryIdNghbr = m_bndryCells->a[ bndryId ].m_nghbrIds[ dirId ][ 0 ];
    cerr << "...at level (direction 0) " << m_solver->a_level( m_bndryCells->a[ bndryIdNghbr ].m_cellId ) << endl;
    cerr << m_solver->a_coordinate( m_bndryCells->a[ bndryIdNghbr ].m_cellId ,  0 ) << " "
         << m_solver->a_coordinate( m_bndryCells->a[ bndryIdNghbr ].m_cellId ,  1 ) << " "
         << m_solver->c_cellLengthAtCell( m_bndryCells->a[ bndryIdNghbr ].m_cellId )]) << endl;
    cerr << "Number of cut points " << m_bndryCells->a[ bndryIdNghbr ].m_srfcs[0]->m_noCutPoints << endl;
    for( MInt i = 0; i < m_bndryCells->a[ bndryIdNghbr ].m_srfcs[0]->m_noCutPoints; i++ ) {
      cerr << m_bndryCells->a[ bndryIdNghbr ].m_srfcs[0]->m_cutCoordinates[ i ][ 0 ] << " "
     << m_bndryCells->a[ bndryIdNghbr ].m_srfcs[0]->m_cutCoordinates[ i ][ 1 ] << endl;
    }
    cerr << endl;
  }
  cerr << "+++++" << endl;
      }
      cerr << "-------------------------------" << endl;
    }
    */
  }
  // cout << "*** all boundary cells checked ***" << endl;
}


/**
 * \fn void FvBndryCndXD<nDim, SysEqn>::detectSmallBndryCells()
 * \brief Detects small cells and identifies a master cell
 * Calls mergeCell to merge master and small cell
 *
 * Master setting for lower levels commented out!!!
 *
 * Cell arrays used for temporary data storage:
 *    slope[0][0] : flags whether the boundary cell is a small cell
 *    slope[0][1] : flags whether treatment for the boundary cell is finished
 *    slope[1][0] : stores the internal neighbor
 *    slope[1][1] : stores a potential master cell
 *
 *
 * \author: Daniel Hartmann, April 27, 2006
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::detectSmallBndryCells() {
  TRACE();

  MInt noCells = m_bndryCells->size();
  MInt counter;
  MInt countChained;
  MInt formerMasterBnd;
  MInt cellId;
  MInt nghbrId;
  MInt count1;
  MInt count2;
  MInt primaryDirection = 0;
  MFloat maxComponent;
  MBool wall = false;
  //---

  // reset collector of small cells
  m_smallBndryCells->setSize(0);

  m_log << "Small cell treatment " << endl;
  m_log << "using " << m_volumeLimitWall << " " << m_volumeLimitOther << endl;

  counter = 0;
  // set small cell flag
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    m_solver->a_slope(bndryId, 0, 0) = (MFloat) false;
    m_solver->a_slope(bndryId, 0, 1) = (MFloat) false;
    cellId = m_bndryCell[bndryId].m_cellId;
    wall = false;
    for(MInt srfcId = 0; srfcId < m_bndryCells->a[m_solver->a_bndryId(cellId)].m_noSrfcs; srfcId++) {
      if(m_bndryCell[bndryId].m_srfcs[srfcId]->m_bndryCndId / 1000 == 3) {
        wall = true;
        break;
      }
    }
    if(wall) {
      if(m_bndryCell[bndryId].m_volume / m_solver->grid().gridCellVolume(m_solver->a_level(cellId))
         < m_volumeLimitWall) {
        m_solver->a_slope(bndryId, 0, 0) = (MFloat) true;
        m_bndryCell[bndryId].m_linkedCellId = cellId;
        counter++;
      }
    } else {
      if(m_bndryCell[bndryId].m_volume / m_solver->grid().gridCellVolume(m_solver->a_level(cellId))
         < m_volumeLimitOther) {
        m_solver->a_slope(bndryId, 0, 0) = (MFloat) true;
        m_bndryCell[bndryId].m_linkedCellId = cellId;
        counter++;
      }
    }
  }

  // check for potential master cells
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    m_solver->a_slope(bndryId, 1, 0) = (MFloat)(-1);
    m_solver->a_slope(bndryId, 1, 1) = (MFloat)(-1);
    if((MInt)m_solver->a_slope(bndryId, 0, 0)) {
      // set primary direction
      maxComponent = F0;
      for(MInt i = 0; i < nDim; i++) {
        if(fabs(m_bndryCell[bndryId].m_srfcs[0]->m_normalVector[i]) > maxComponent) {
          maxComponent = fabs(m_bndryCell[bndryId].m_srfcs[0]->m_normalVector[i]);
          if(m_bndryCell[bndryId].m_srfcs[0]->m_normalVector[i] < F0) {
            primaryDirection = 2 * i;
          } else {
            primaryDirection = 2 * i + 1;
          }
        }
      }
      //
      cellId = m_bndryCell[bndryId].m_cellId;
      if(m_solver->a_hasNeighbor(cellId, primaryDirection) > 0) {
        nghbrId = m_solver->c_neighborId(cellId, primaryDirection);
        if(m_solver->a_bndryId(nghbrId) > -1) {
          m_solver->a_slope(bndryId, 1, 1) = (MFloat)nghbrId;
        } else {
          m_solver->a_slope(bndryId, 1, 0) = (MFloat)nghbrId;
        }
      }
    }
  }

  m_log << "Small cell treatment..." << endl;
  m_log << counter << " small cells to link" << endl;

  count1 = 0;
  count2 = 0;
  countChained = 0;

  // 1. connect small cells to internal master cells
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    if(!(MInt)m_solver->a_slope(bndryId, 0, 0)) continue;
    if((MInt)m_solver->a_slope(bndryId, 1, 0) == -1) continue;
    m_bndryCell[bndryId].m_linkedCellId = (MInt)m_solver->a_slope(bndryId, 1, 0);
    m_solver->a_slope(bndryId, 0, 1) = (MFloat) true;
    counter--;
    count1++;
  }

  // 2. connect all small cells with at least one possible master cell
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    if(!(MInt)m_solver->a_slope(bndryId, 0, 0)) continue;
    if((MInt)m_solver->a_slope(bndryId, 0, 1)) continue;
    if((MInt)m_solver->a_slope(bndryId, 1, 1) == -1) continue;
    m_bndryCell[bndryId].m_linkedCellId = (MInt)m_solver->a_slope(bndryId, 1, 1);
    m_solver->a_slope(bndryId, 0, 1) = (MFloat) true;
    counter--;
    count2++;
  }

  // 3. connect small cells the master of which is also a small cell to the master's master
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    if(!(MInt)m_solver->a_slope(bndryId, 0, 0)) continue;
    if(!(MInt)m_solver->a_slope(bndryId, 0, 1)) continue;
    if(m_solver->a_bndryId(m_bndryCell[bndryId].m_linkedCellId) == -1) continue;
    if(!(MInt)m_solver->a_slope(m_solver->a_bndryId(m_bndryCell[bndryId].m_linkedCellId), 0, 0)) continue;
    formerMasterBnd = m_solver->a_bndryId(m_bndryCell[bndryId].m_linkedCellId);
    m_bndryCell[bndryId].m_linkedCellId = m_bndryCell[formerMasterBnd].m_linkedCellId;
    countChained++;
  }

  m_log << "Master cell statistics:  " << endl;
  m_log << "__________________________________" << endl << endl;
  m_log << " * links to internal cells  " << count1 << endl;
  m_log << " * links to boundary cells  " << count2 << endl;
  m_log << " * chained links            " << countChained << endl;
  m_log << "__________________________________" << endl;

  // create small cells
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    if((MInt)m_solver->a_slope(bndryId, 0, 0) && (MInt)m_solver->a_slope(bndryId, 0, 1)) {
      m_smallBndryCells->append();
      m_smallBndryCells->a[m_smallBndryCells->size() - 1] = bndryId;
    }
  }

  // fill the lists smallCellIds and masterCellIds
  noCells = m_smallBndryCells->size();
  for(MInt s = 0; s < noCells; s++) {
    m_solver->m_smallCellIds[s] = m_bndryCell[m_smallBndryCells->a[s]].m_cellId;
    m_solver->m_masterCellIds[s] = m_bndryCell[m_smallBndryCells->a[s]].m_linkedCellId;
  }
}


/**
 * \fn void FvBndryCndXD<nDim, SysEqn>::detectSmallBndryCellsMGC()
 * \brief Detects small cells and identifies a master cell
 * Calls mergeCell to merge master and small cell
 *
 * Is able to handle multiple cut surfaces and complex geometries.
 * Some special settings for test cases included;
 * If a cell hast several cut surfaces, master cell related to
 * wall boundary condition is prefered if not specified otherwise.
 *
 * Cell arrays used for temporary data storage:
 *    slope[0][0] : flags whether the boundary cell is a small cell
 *    slope[0][1] : flags whether treatment for the boundary cell is finished
 *    slope[1][0] : stores the internal neighbor
 *    slope[1][1] : stores a potential master cell
 *    slope[2][0] : stores the ID of a small cell cluster with no simple master
 *
 *
 * \author: Claudia Guenther, November 2011
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::detectSmallBndryCellsMGC() {
  TRACE();

  MInt noCells = m_bndryCells->size();
  MInt counter;
  MInt countChained;
  MInt cellId;
  MInt nghbrId;
  MInt count1;
  MInt count2;
  MInt primaryDirection = -1;
  MInt secondaryDirection = -1;
  MInt thirdDirection = -1;
  MFloat maxComponent;
  MBool wall = false;
  MInt srfc;
  MBool MGCPreferWallBoundaries = false;
  // claudia  Achtung neu - alte claudia Testfaelle anpassen!
  // TINA_TC: MGC_preferWallBoundaries = true;
  // SUZI_TC: MGC_preferWallBoundaries = false;

  /*! \page propertiesFV
    \section MGC_preferWallBoundaries
    <code>MBool MGCPreferWallBoundaries </code>\n
    default = <code>false</code>\n
    For MGC, enables/disables preferring Wall boundary surfaces when determining the master cell to which the current
    small cut-cell should be linked.\n Possible values are: <ul> <li>false: don't prefer wall boundaries</li> <li>true:
    prefer wall boundaries</li>
    </ul>
    Keywords: <i>FINITE VOLUME, BOUNDARY CONDITIONS, MGC, TINA, SUZI</i>
  */
  MGCPreferWallBoundaries =
      Context::getSolverProperty<MBool>("MGC_preferWallBoundaries", m_solverId, AT_, &MGCPreferWallBoundaries);
  //---

  // reset collector of small cells
  m_smallBndryCells->setSize(0);

  m_log << "Small cell treatment " << endl;
  m_log << "using " << m_volumeLimitWall << " " << m_volumeLimitOther << endl;

  counter = 0;
  // set small cell flag
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    m_solver->a_slope(bndryId, 0, 0) = (MFloat) false;
    m_solver->a_slope(bndryId, 0, 1) = (MFloat) false;
    m_solver->a_slope(bndryId, 2, 0) = (MFloat)(-1);
    m_solver->a_slope(bndryId, 2, 1) = (MFloat) false;
    cellId = m_bndryCell[bndryId].m_cellId;
    m_bndryCell[bndryId].m_linkedCellId = -1;
    wall = false;
    for(MInt srfcId = 0; srfcId < m_bndryCells->a[m_solver->a_bndryId(cellId)].m_noSrfcs; srfcId++) {
      if(m_bndryCell[bndryId].m_srfcs[srfcId]->m_bndryCndId >= 3000
         && m_bndryCell[bndryId].m_srfcs[srfcId]->m_bndryCndId < 4000) {
        wall = true;
        break;
      }
    }
    if(m_solver->c_noChildren(cellId) > 0) continue;
    if(wall) {
      if(m_bndryCell[bndryId].m_volume / m_solver->grid().gridCellVolume(m_solver->a_level(cellId))
         < m_volumeLimitWall) {
        m_solver->a_slope(bndryId, 0, 0) = (MFloat) true;
        m_bndryCell[bndryId].m_linkedCellId = cellId;
        counter++;
      }
    } else {
      if(m_bndryCell[bndryId].m_volume / m_solver->grid().gridCellVolume(m_solver->a_level(cellId))
         < m_volumeLimitOther) {
        m_solver->a_slope(bndryId, 0, 0) = (MFloat) true;
        m_bndryCell[bndryId].m_linkedCellId = cellId;
        counter++;
      }
    }
  }

  // check for potential master cells
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    m_solver->a_slope(bndryId, 1, 0) = (MFloat)(-1);
    m_solver->a_slope(bndryId, 1, 1) = (MFloat)(-1);
    if((MInt)m_solver->a_slope(bndryId, 0, 0)) {
      srfc = 0;
      // if there is a prefered boundary surface on which the search for the master cell should be based, take this one
      for(MInt srfcId = 0; srfcId < m_bndryCells->a[bndryId].m_noSrfcs; srfcId++) {
        // prefer wall boundaries
        if(m_bndryCells->a[bndryId].m_srfcs[srfcId]->m_bndryCndId == 3003
           || m_bndryCells->a[bndryId].m_srfcs[srfcId]->m_bndryCndId == 3005) {
          srfc = srfcId;
          if(MGCPreferWallBoundaries) break;
        } else if(!MGCPreferWallBoundaries) {
          srfc = srfcId;
          break;
        }
      }

      // set primary direction
      maxComponent = F0;
      primaryDirection = -1;
      for(MInt i = 0; i < nDim; i++) {
        if(fabs(m_bndryCell[bndryId].m_srfcs[srfc]->m_normalVector[i]) > maxComponent) {
          maxComponent = fabs(m_bndryCell[bndryId].m_srfcs[srfc]->m_normalVector[i]);
          thirdDirection = secondaryDirection;
          secondaryDirection = primaryDirection;
          if(m_bndryCell[bndryId].m_srfcs[srfc]->m_normalVector[i] < F0) {
            primaryDirection = 2 * i;
          } else {
            primaryDirection = 2 * i + 1;
          }
        }
      }
      cellId = m_bndryCell[bndryId].m_cellId;
      // only valid for 3D...
      m_solver->a_slope(bndryId, 3, 0) = -1; // primary master
      m_solver->a_slope(bndryId, 3, 1) = -1; // secondary master
      m_solver->a_slope(bndryId, 3, 2) = -1; // third master
      if(primaryDirection > -1
         && m_solver->m_identNghbrIds[cellId * m_noDirs + primaryDirection]
                < m_solver->m_identNghbrIds[cellId * m_noDirs + primaryDirection + 1]) {
        nghbrId = m_solver->m_storeNghbrIds[m_solver->m_identNghbrIds[cellId * m_noDirs + primaryDirection]];
        m_solver->a_slope(bndryId, 3, 0) = (MFloat)nghbrId;
      }
      if(secondaryDirection > -1
         && m_solver->m_identNghbrIds[cellId * m_noDirs + secondaryDirection]
                < m_solver->m_identNghbrIds[cellId * m_noDirs + secondaryDirection + 1]) {
        nghbrId = m_solver->m_storeNghbrIds[m_solver->m_identNghbrIds[cellId * m_noDirs + secondaryDirection]];
        m_solver->a_slope(bndryId, 3, 1) = (MFloat)nghbrId;
      }
      if(thirdDirection > -1
         && m_solver->m_identNghbrIds[cellId * m_noDirs + thirdDirection]
                < m_solver->m_identNghbrIds[cellId * m_noDirs + thirdDirection + 1]) {
        nghbrId = m_solver->m_storeNghbrIds[m_solver->m_identNghbrIds[cellId * m_noDirs + thirdDirection]];
        m_solver->a_slope(bndryId, 3, 2) = (MFloat)nghbrId;
      }

      nghbrId = m_solver->a_slope(bndryId, 3, 0);
      if(nghbrId > -1) {
        if(m_solver->a_bndryId(nghbrId) > -1) {
          m_solver->a_slope(bndryId, 1, 1) = (MFloat)nghbrId;
        } else {
          m_solver->a_slope(bndryId, 1, 0) = (MFloat)nghbrId;
        }
      } else {
        nghbrId = m_solver->a_slope(bndryId, 3, 1);
        if(nghbrId > -1) {
          if(m_solver->a_bndryId(nghbrId) > -1) {
            m_solver->a_slope(bndryId, 1, 1) = (MFloat)nghbrId;
          } else {
            m_solver->a_slope(bndryId, 1, 0) = (MFloat)nghbrId;
          }
        } else {
          nghbrId = m_solver->a_slope(bndryId, 3, 2);
          if(nghbrId > -1) {
            if(m_solver->a_bndryId(nghbrId) > -1) {
              m_solver->a_slope(bndryId, 1, 1) = (MFloat)nghbrId;
            } else {
              m_solver->a_slope(bndryId, 1, 0) = (MFloat)nghbrId;
            }
          } else {
            cerr << " " << domainId() << " " << cellId << " " << primaryDirection << " " << m_solver->c_parentId(cellId)
                 << " " << m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId << endl;
            cerr << "Coordinates: " << m_solver->a_coordinate(cellId, 0) << " " << m_solver->a_coordinate(cellId, 1)
                 << " " << m_solver->a_coordinate(cellId, 2) << endl;
            cerr << "Normal vector: " << m_bndryCell[bndryId].m_srfcs[srfc]->m_normalVector[0] << " "
                 << m_bndryCell[bndryId].m_srfcs[srfc]->m_normalVector[1] << " "
                 << m_bndryCell[bndryId].m_srfcs[srfc]->m_normalVector[2] << endl;
            cerr << m_solver->a_hasNeighbor(cellId, 0) << " " << m_solver->a_hasNeighbor(cellId, 1) << " "
                 << m_solver->a_hasNeighbor(cellId, 2) << " " << m_solver->a_hasNeighbor(cellId, 3) << " ";
            IF_CONSTEXPR(nDim == 3) {
              cerr << m_solver->a_hasNeighbor(cellId, 4) << " " << m_solver->a_hasNeighbor(cellId, 5) << endl;
            }
            else cerr << endl;
            cerr << m_solver->c_neighborId(cellId, 0) << " " << m_solver->c_neighborId(cellId, 1) << " "
                 << m_solver->c_neighborId(cellId, 2) << " " << m_solver->c_neighborId(cellId, 3) << " ";
            IF_CONSTEXPR(nDim == 3) {
              cerr << m_solver->c_neighborId(cellId, 4) << " " << m_solver->c_neighborId(cellId, 5) << endl;
            }
            else cerr << endl;
            cerr << "[" << domainId() << "]: Error in small cell treatment: No neighbor in any direction" << endl;
            if(m_solver->a_isHalo(cellId)) {
              m_solver->a_hasProperty(cellId, SolverCell::IsDummy) = true;
              m_solver->a_isBndryGhostCell(cellId) = false;
              m_solver->a_hasProperty(cellId, SolverCell::IsInterface) = false;
              m_solver->a_isPeriodic(cellId) = false;
              m_solver->a_hasProperty(cellId, SolverCell::IsCutOff) = false;
              m_solver->a_hasProperty(cellId, SolverCell::IsInvalid) = true;
              m_solver->a_hasProperty(cellId, SolverCell::IsFlux) = false;
              m_solver->a_hasProperty(cellId, SolverCell::IsActive) = false;
              m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = false;
              m_solver->a_hasProperty(cellId, SolverCell::IsInSpongeLayer) = false;
              m_solver->a_slope(bndryId, 0, 0) = (MFloat) false;
              cerr << " cell inactive"
                   << ", cellId: " << cellId << endl;

              // this deletes all relations of the cell with neighbors, parents etc. but the cell itself remains in the
              // collector to prevent inconsistencies
              // Timw: deleting the cell is not allowed in the multisolver-concept!
              // m_solver->grid().deleteCell_MGC( cellId );
              m_solver->a_level(cellId) = -1;
            } else {
              cerr << "cell is no multi solver halo cell! " << endl;
            }
          }
        }
      }
    }
  }

  m_log << "Small cell treatment..." << endl;
  m_log << counter << " small cells to link" << endl;

  MInt invalidCounter = 0;
  stringstream filename;


  // 0. perform a check of the cells to be linked. Filter out invalid cells and check if any cell has an invalid cell as
  // potential master cell
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    cellId = m_bndryCell[bndryId].m_cellId;
    if(!(MInt)m_solver->a_slope(bndryId, 0, 0)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInvalid)) {
      invalidCounter++;
      cerr << " found invalid small cell. Please check! CellId is " << cellId << " bndryId is " << bndryId
           << " counter is " << invalidCounter << ". Cell is no set to be non-small." << endl;
      filename.str("");
      filename << cellId << "_invalidSmall.stl";

      m_solver->a_slope(bndryId, 0, 0) = (MFloat) false;
    }
    if((MInt)m_solver->a_slope(bndryId, 1, 0) > -1) {
      if(m_solver->a_hasProperty((MInt)m_solver->a_slope(bndryId, 1, 0), SolverCell::IsInvalid)) {
        cerr << " found small cell with invalid internal master. Please check! CellId is " << cellId << " bndryId is "
             << bndryId << ", master is " << (MInt)m_solver->a_slope(bndryId, 1, 0)
             << ". Cell is no set to be non-small." << endl;
        filename.str("");
        filename << cellId << "_smallInvalidMaster.stl";
        filename.str("");
        filename << (MInt)m_solver->a_slope(bndryId, 1, 0) << "_invalidMaster.stl";

        m_solver->a_slope(bndryId, 0, 0) = (MFloat) false;
      }
    } else {
      if((MInt)m_solver->a_slope(bndryId, 1, 1) == -1) {
        cerr << " found small cell with no master. Please check! CellId is " << cellId << " bndryId is " << bndryId
             << ". Cell is no set to be non-small." << endl;
        filename.str("");
        filename << cellId << "_smallNoMaster.stl";

        m_solver->a_slope(bndryId, 0, 0) = (MFloat) false;
      } else {
        if(m_solver->a_hasProperty((MInt)m_solver->a_slope(bndryId, 1, 1), SolverCell::IsInvalid)) {
          cerr << " found small cell with invalid bndry master. Please check! CellId is " << cellId << " bndryId is "
               << bndryId << ", master is " << (MInt)m_solver->a_slope(bndryId, 1, 1)
               << ". Cell is no set to be non-small." << endl;
          filename.str("");
          filename << cellId << "_smallInvalidMaster.stl";
          filename.str("");
          filename << (MInt)m_solver->a_slope(bndryId, 1, 1) << "_invalidMaster.stl";

          m_solver->a_slope(bndryId, 0, 0) = (MFloat) false;
        }
      }
    }
  }


  count1 = 0;
  count2 = 0;
  countChained = 0;
  MInt countBigCluster = 0;
  MInt countSpecialcluster = 0;
  MInt master = -1;
  MInt masterBndryId = -1;

  // 1. connect small cells to internal master cells -> direct connection
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    cellId = m_bndryCell[bndryId].m_cellId;
    if(!(MInt)m_solver->a_slope(bndryId, 0, 0)) continue;
    if((MInt)m_solver->a_slope(bndryId, 1, 0) == -1) continue;
    m_bndryCell[bndryId].m_linkedCellId = (MInt)m_solver->a_slope(bndryId, 1, 0);
    m_solver->a_slope(bndryId, 0, 1) = (MFloat) true;
    count1++;
  }

  // 2. connect remaining small cells which have a big boundary cell as master -> direct connection, first round
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    if(!(MInt)m_solver->a_slope(bndryId, 0, 0)) continue;
    if((MInt)m_solver->a_slope(bndryId, 0, 1)) continue;
    if((MInt)m_solver->a_slope(bndryId, 1, 1) == -1) continue;

    master = (MInt)m_solver->a_slope(bndryId, 1, 1);
    masterBndryId = m_solver->a_bndryId(master);
    // only connect to big cells
    if((MInt)m_solver->a_slope(masterBndryId, 0, 0)) continue;

    m_bndryCell[bndryId].m_linkedCellId = master;
    m_solver->a_slope(bndryId, 0, 1) = (MFloat) true;
    count2++;
  }

  // 3. connect remaining small cells with a small master to the masters master, if the small master is aleady tagged as
  // OK. Repeat until no cell with OK master remains with the OK tag
  MBool reconnected = true;
  while(reconnected) {
    reconnected = false;
    for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
      if(!(MInt)m_solver->a_slope(bndryId, 0, 0)) continue;
      if((MInt)m_solver->a_slope(bndryId, 0, 1)) continue;
      if((MInt)m_solver->a_slope(bndryId, 1, 1) == -1) continue;

      master = (MInt)m_solver->a_slope(bndryId, 1, 1);
      masterBndryId = m_solver->a_bndryId(master);
      // only connect to OK cells
      if((MInt)m_solver->a_slope(masterBndryId, 0, 0)) {
        if((MInt)m_solver->a_slope(masterBndryId, 0, 1)) {
          m_bndryCell[bndryId].m_linkedCellId = m_bndryCell[masterBndryId].m_linkedCellId;
          m_solver->a_slope(bndryId, 0, 1) = (MFloat) true;
          countChained++;
          reconnected = true;
        }
      }
    }
  }


  // Now, only problematic small cells are left which would lead to infinity chains if treated as usual
  // 4. Identify clusters of connected small cells and give them a cluster number
  // collect all small cells belonging to one cluster in an array
  stack<MInt> clusterStack;
  MInt startCellId = -1;
  MInt currentCell = -1;
  MInt clusterColor = -1;
  MInt nghbrBndryId = -1;
  MIntScratchSpace clusterCells(counter, AT_, "clusterCells");
  MIntScratchSpace clusterCounter(counter / 2, AT_, "clusterCounter");
  MIntScratchSpace clusterFinished(counter / 2, AT_, "clusterFinished");
  MInt noClusterCells = 0;
  MInt checkMasterId;
  MBool changedColor = true;
  MInt checkMasterBndryId;
  MBool masterGrey;
  for(MInt i = 0; i < (MInt)counter / 2; i++) {
    clusterCounter[i] = 0;
    clusterFinished[i] = 0;
  }

  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    if(!(MInt)m_solver->a_slope(bndryId, 0, 0)) continue;
    if((MInt)m_solver->a_slope(bndryId, 0, 1)) continue;
    if((MInt)m_solver->a_slope(bndryId, 2, 0) > -1) continue;
    startCellId = bndryId;
    checkMasterBndryId = startCellId;
    clusterColor++;
    m_solver->a_slope(startCellId, 2, 0) = (MFloat)clusterColor;
    clusterCells[noClusterCells++] = startCellId;
    clusterCounter[clusterColor]++;
    masterGrey = true;
    while(masterGrey) {
      checkMasterId = (MInt)m_solver->a_slope(checkMasterBndryId, 1, 1);
      checkMasterBndryId = m_solver->a_bndryId(checkMasterId);
      if((MInt)m_solver->a_slope(checkMasterBndryId, 2, 0) < 0) {
        m_solver->a_slope(checkMasterBndryId, 2, 0) = (MFloat)clusterColor;
        clusterCells[noClusterCells++] = checkMasterBndryId;
        clusterCounter[clusterColor]++;
      } else {
        masterGrey = false;
      }
    }
    changedColor = true;
    while(changedColor) {
      changedColor = false;
      for(MInt checkBndryId = 0; checkBndryId < noCells; checkBndryId++) {
        if(!(MInt)m_solver->a_slope(checkBndryId, 0, 0)) continue;
        if((MInt)m_solver->a_slope(checkBndryId, 0, 1)) continue;
        if((MInt)m_solver->a_slope(checkBndryId, 2, 0) > -1) continue;
        checkMasterId = (MInt)m_solver->a_slope(checkBndryId, 1, 1);
        checkMasterBndryId = m_solver->a_bndryId(checkMasterId);
        if((MInt)m_solver->a_slope(checkMasterBndryId, 2, 0) > -1) {
          m_solver->a_slope(checkBndryId, 2, 0) = m_solver->a_slope(checkMasterBndryId, 2, 0);
          clusterCells[noClusterCells++] = checkBndryId;
          clusterCounter[clusterColor]++;
          changedColor = true;
        }
      }
    }
  }

  // 5. Check the small cell clusters. If a cluster has a volume big enough to be computed as a regular cell (security
  // factor: 2 * volumeLimitWall), the biggest cell will be the master and looses its small state. all other cells in
  // the cluster will point to the biggest cell.
  MFloat clusterVolume = F0;
  MInt maxVolumeCell = -1;
  MFloat maxVolume = F0;
  MInt minClusterLevel = 1000;
  MInt index = 0;

  clusterColor++;
  for(MInt color = 0; color < clusterColor; color++) {
    clusterVolume = F0;
    maxVolume = F0;
    maxVolumeCell = -1;
    minClusterLevel = 1000;
    for(MInt cC = 0; cC < clusterCounter[color]; cC++) {
      currentCell = clusterCells[cC + index];
      cellId = m_bndryCells->a[currentCell].m_cellId;
      clusterVolume += m_bndryCell[currentCell].m_volume;
      if(m_bndryCell[currentCell].m_volume > maxVolume) {
        maxVolume = m_bndryCells->a[currentCell].m_volume;
        maxVolumeCell = currentCell;
      }
      if(m_solver->a_level(cellId) < minClusterLevel) minClusterLevel = m_solver->a_level(cellId);
    }

    if(clusterVolume / m_solver->grid().gridCellVolume(minClusterLevel) >= /*F2 **/ m_volumeLimitWall) {
      // set maxVolumeCell as master cell with sufficient volume
      m_solver->a_slope(maxVolumeCell, 0, 0) = (MFloat) false;
      m_solver->a_slope(maxVolumeCell, 0, 1) = (MFloat) true;
      m_solver->a_slope(maxVolumeCell, 1, 0) = (MFloat)-1;
      m_solver->a_slope(maxVolumeCell, 1, 1) = (MFloat)-1;
      m_bndryCell[maxVolumeCell].m_linkedCellId = -1;
      counter--;
      countBigCluster++;

      for(MInt cC = 0; cC < clusterCounter[color]; cC++) {
        currentCell = clusterCells[cC + index];
        if(currentCell == maxVolumeCell) {
          continue;
        }
        cellId = m_bndryCells->a[currentCell].m_cellId;
        m_solver->a_slope(currentCell, 0, 1) = (MFloat) true;
        m_solver->a_slope(currentCell, 1, 1) = (MFloat)m_bndryCells->a[maxVolumeCell].m_cellId;

        m_bndryCell[currentCell].m_linkedCellId = m_bndryCell[maxVolumeCell].m_cellId;

        counter--;
        countBigCluster++;
      }
      index += clusterCounter[color];
      clusterFinished[color] = 1;
    } else {
      index += clusterCounter[color];
    }
  }


  // 6. For all remaining clusters, a suitable master must be identified.
  // First, identify all possible neighbors which are OK (either small tagged with OK or big or internal neighbors)
  // Then, search for the best one
  // Connect all cluster cells to this master cell.
  const MInt maxNeighbors = 20;
  MInt clusterNeighbors[maxNeighbors];
  MInt noClusterNeighbors = 0;
  MInt clusterCentroid[3] = {0, 0, 0};
  MFloat minDist = 1000000000.0;
  MInt minDistNghbr = -1;
  MFloat dist = F0;
  index = 0;
  for(MInt color = 0; color < clusterColor; color++) {
    noClusterNeighbors = 0;
    clusterCentroid[0] = F0;
    clusterCentroid[1] = F0;
    clusterCentroid[2] = F0;
    if(clusterFinished[color]) {
      index += clusterCounter[color];
      continue;
    }
    for(MInt cC = 0; cC < clusterCounter[color]; cC++) {
      currentCell = clusterCells[cC + index];
      cellId = m_bndryCells->a[currentCell].m_cellId;
      for(MInt i = 0; i < nDim; i++) {
        clusterCentroid[i] += m_bndryCell[currentCell].m_volume * m_solver->a_coordinate(cellId, i);
      }
      for(MInt dir = 0; dir < m_noDirs; dir++) {
        for(MInt nghbrID = m_solver->m_identNghbrIds[cellId * m_noDirs + dir];
            nghbrID < m_solver->m_identNghbrIds[cellId * m_noDirs + dir + 1];
            nghbrID++) {
          nghbrId = m_solver->m_storeNghbrIds[nghbrID];
          nghbrBndryId = m_solver->a_bndryId(nghbrId);
          if(nghbrBndryId < 0) {
            clusterNeighbors[noClusterNeighbors++] = nghbrId;
          } else if(!(MInt)m_solver->a_slope(nghbrBndryId, 0, 0)) {
            clusterNeighbors[noClusterNeighbors++] = nghbrId;
          } else if((MInt)m_solver->a_slope(nghbrBndryId, 0, 1) && (!(MInt)m_solver->a_slope(nghbrBndryId, 2, 1))) {
            clusterNeighbors[noClusterNeighbors++] = nghbrId;
          } else {
            continue;
          }
        }
      }
    }

    if(noClusterNeighbors == 0) {
      cerr << " cluster with no neighbors found. this should not happen. isolated small cell island - ... " << endl;
      for(MInt cC = 0; cC < clusterCounter[color]; cC++) {
        currentCell = clusterCells[cC + index];
        cellId = m_bndryCells->a[currentCell].m_cellId;
        filename.str("");
        filename << cellId << "_cluster_" << color << ".stl";
        recorrectCellCoordinates();
        writeStlFileOfCell(cellId, (filename.str()).c_str());
        rerecorrectCellCoordinates();
      }
      for(MInt cC = 0; cC < clusterCounter[color]; cC++) {
        currentCell = clusterCells[cC + index];
        cellId = m_bndryCells->a[currentCell].m_cellId;

        m_solver->a_hasProperty(cellId, SolverCell::IsInvalid) = true;
        cerr << " cell inactive"
             << ", cellId: " << cellId << endl;

        // this deletes all relations of the cell with neighbors, parents etc. but the cell itself remains in the
        // collector to prevent inconsistencies
        // Timw: deleting the cell is not allowed in the multisolver-concept!
        // m_solver->grid().deleteCell_MGC( cellId );
        m_solver->a_level(cellId) = -1;
        m_solver->a_hasProperty(cellId, SolverCell::IsInactive) = true;
        m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = false;
        m_solver->a_hasProperty(cellId, SolverCell::IsFlux) = false;
        m_solver->a_hasProperty(cellId, SolverCell::IsActive) = false;
        m_solver->a_isBndryGhostCell(cellId) = false;
      }
      index += clusterCounter[color];
      continue;
    }

    minDist = 1000000000.0;
    minDistNghbr = -1;

    for(MInt cN = 0; cN < noClusterNeighbors; cN++) {
      dist = F0;
      for(MInt i = 0; i < nDim; i++)
        dist += (m_solver->a_coordinate(clusterNeighbors[cN], i) - clusterCentroid[i])
                * (m_solver->a_coordinate(clusterNeighbors[cN], i) - clusterCentroid[i]);
      dist = sqrt(dist);
      if(dist < minDist) {
        minDist = dist;
        minDistNghbr = clusterNeighbors[cN];
      }
    }
    if(minDistNghbr == -1) {
      cerr << " cluster with no suitable neighbor found. this should not happen. cluster has " << noClusterNeighbors
           << " neighbors - exiting... " << endl;

      index += clusterCounter[color];
      continue;
    }

    for(MInt cC = 0; cC < clusterCounter[color]; cC++) {
      currentCell = clusterCells[cC + index];
      cellId = m_bndryCells->a[currentCell].m_cellId;
      master = minDistNghbr;
      masterBndryId = m_solver->a_bndryId(master);
      if(masterBndryId > -1 && (MInt)m_solver->a_slope(masterBndryId, 0, 0)) {
        master = m_bndryCells->a[masterBndryId].m_linkedCellId;
        masterBndryId = m_solver->a_bndryId(master);
      }
      m_solver->a_slope(currentCell, 0, 1) = (MFloat) true;
      m_solver->a_slope(currentCell, 1, 1) = (MFloat)master;
      m_solver->a_slope(currentCell, 2, 1) = (MFloat) true;

      m_bndryCell[currentCell].m_linkedCellId = master;

      counter--;
      countSpecialcluster++;
    }
    index += clusterCounter[color];
    clusterFinished[color] = 1;
  }


  m_log << "Master cell statistics:  " << endl;
  m_log << "__________________________________" << endl << endl;
  m_log << " * links to internal cells      " << count1 << endl;
  m_log << " * links to boundary cells      " << count2 << endl;
  m_log << " * chained links                " << countChained << endl;
  m_log << " * chained biggest cluster cell " << countBigCluster << endl;
  m_log << " * chained to special master    " << countSpecialcluster << endl;
  m_log << "__________________________________" << endl;

  // create small cells
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    if((MInt)m_solver->a_slope(bndryId, 0, 0) && (MInt)m_solver->a_slope(bndryId, 0, 1)) {
      cellId = m_bndryCells->a[bndryId].m_cellId;
      if(!m_solver->a_hasProperty(cellId, SolverCell::IsInvalid)) {
        m_smallBndryCells->append();
        m_smallBndryCells->a[m_smallBndryCells->size() - 1] = bndryId;
      }
    }
  }


  // fill the lists smallCellIds and masterCellIds
  noCells = m_smallBndryCells->size();
  for(MInt s = 0; s < noCells; s++) {
    m_solver->m_smallCellIds[s] = m_bndryCell[m_smallBndryCells->a[s]].m_cellId;
    m_solver->m_masterCellIds[s] = m_bndryCell[m_smallBndryCells->a[s]].m_linkedCellId;
  }
}


/**
 * merges master and small cells
 *
 * Master cell coordinates, volume, and the coordinates, area and
 * orientation of its body surface are updated
 * Small cell coordinates are updated; volume and body
 * surface remain unchanged
 *
 * Cell arrays used for temporary data storage:
 *    slope[0][i] : original coordinates
 *    slope[1][0] : volumes
 *
 *
 * \author: Daniel Hartmann, April 20, 2006
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::mergeCells() {
  TRACE();

  MInt smallCell;
  MInt smallCellId;
  MInt master;
  MInt masterId;
  MInt noCells = m_solver->a_noCells();
  MInt noSmallCells = m_smallBndryCells->size();
  MFloat area;
  MFloat factor;
  MFloat totalVolume;
  MFloat coordinates;
  MFloat avrgCoordinates;
  MFloatScratchSpace oldNormalVector_scratch(nDim, AT_, "oldNormalVector_scratch");
  MFloat* oldNormalVector = oldNormalVector_scratch.getPointer();
  //---

  // store all original coordinates, reset volumes
  for(MInt id = 0; id < noCells; id++) {
    m_solver->a_slope(id, 1, 0) = m_solver->grid().gridCellVolume(m_solver->a_level(id));
    for(MInt i = 0; i < nDim; i++) {
      m_solver->a_slope(id, 0, i) = m_solver->a_coordinate(id, i);
    }
  }

  for(MInt smallId = 0; smallId < noSmallCells; smallId++) {
    smallCell = m_smallBndryCells->a[smallId];
    smallCellId = m_bndryCell[smallCell].m_cellId;
    masterId = m_bndryCell[smallCell].m_linkedCellId;
    master = m_solver->a_bndryId(masterId);

    if(master > -1) {
      // first case: master cell is a boundary cell
      // ------------------------------------------

      totalVolume = m_bndryCell[master].m_volume + m_bndryCell[smallCell].m_volume;

      for(MInt v = 0; v < CV->noVariables; v++) {
        m_solver->a_variable(masterId, v) = (m_solver->a_variable(masterId, v) * m_bndryCell[master].m_volume
                                             + m_solver->a_variable(smallCellId, v) * m_bndryCell[smallCell].m_volume)
                                            / totalVolume;
        m_solver->a_variable(smallCellId, v) = m_solver->a_variable(masterId, v);
      }
      for(MInt v = 0; v < PV->noVariables; v++) {
        m_solver->a_pvariable(masterId, v) = (m_solver->a_pvariable(masterId, v) * m_bndryCell[master].m_volume
                                              + m_solver->a_pvariable(smallCellId, v) * m_bndryCell[smallCell].m_volume)
                                             / totalVolume;
        m_solver->a_pvariable(smallCellId, v) = m_solver->a_pvariable(masterId, v);
      }


      for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
        // update coordinates of the...
        coordinates = (m_solver->a_coordinate(masterId, spaceId) * m_bndryCell[master].m_volume
                       + m_solver->a_coordinate(smallCellId, spaceId) * m_bndryCell[smallCell].m_volume)
                      / totalVolume;
        // ...master cell
        m_bndryCell[master].m_coordinates[spaceId] += (coordinates - m_solver->a_coordinate(masterId, spaceId));
        m_solver->a_coordinate(masterId, spaceId) = coordinates;

        // update surface coordinates
        // --------------------------
        // the new surface coordinates are the area-average of the small cell and
        // master cell body surfaces
        avrgCoordinates =
            (m_bndryCell[master].m_srfcs[0]->m_coordinates[spaceId] * m_bndryCell[master].m_srfcs[0]->m_area
             + m_bndryCell[smallCell].m_srfcs[0]->m_coordinates[spaceId] * m_bndryCell[smallCell].m_srfcs[0]->m_area)
            / (m_bndryCell[master].m_srfcs[0]->m_area + m_bndryCell[smallCell].m_srfcs[0]->m_area);

        m_bndryCell[master].m_srfcs[0]->m_coordinates[spaceId] = avrgCoordinates;

        // update surface orientation
        // --------------------------
        oldNormalVector[spaceId] = m_bndryCell[master].m_srfcs[0]->m_normalVector[spaceId];
        m_bndryCell[master].m_srfcs[0]->m_normalVector[spaceId] =
            m_bndryCell[master].m_srfcs[0]->m_normalVector[spaceId] * m_bndryCell[master].m_srfcs[0]->m_area
            + m_bndryCell[smallCell].m_srfcs[0]->m_normalVector[spaceId] * m_bndryCell[smallCell].m_srfcs[0]->m_area;
      }
      factor = 0;
      for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
        factor += POW2(m_bndryCell[master].m_srfcs[0]->m_normalVector[spaceId]);
      }
      factor = sqrt(factor);
      for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
        m_bndryCell[master].m_srfcs[0]->m_normalVector[spaceId] =
            m_bndryCell[master].m_srfcs[0]->m_normalVector[spaceId] / factor;
      }

      // update surface area
      area = 0;
      for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
        area += m_bndryCell[master].m_srfcs[0]->m_normalVector[spaceId]
                * (oldNormalVector[spaceId] * m_bndryCell[master].m_srfcs[0]->m_area
                   + m_bndryCell[smallCell].m_srfcs[0]->m_normalVector[spaceId]
                         * m_bndryCell[smallCell].m_srfcs[0]->m_area);
      }

      m_bndryCell[master].m_srfcs[0]->m_area = area;

      // update cell volume = master cell volume + small cell volume
      m_bndryCell[master].m_volume = totalVolume;

    } else {
      // second case: master is an internal cell
      // ---------------------------------------
      totalVolume = m_solver->a_slope(masterId, 1, 0) + m_bndryCell[smallCell].m_volume;

      for(MInt v = 0; v < CV->noVariables; v++) {
        m_solver->a_variable(masterId, v) = (m_solver->a_variable(masterId, v) * m_solver->a_slope(masterId, 1, 0)
                                             + m_solver->a_variable(smallCellId, v) * m_bndryCell[smallCell].m_volume)
                                            / totalVolume;
        m_solver->a_variable(smallCellId, v) = m_solver->a_variable(masterId, v);
      }
      for(MInt v = 0; v < PV->noVariables; v++) {
        m_solver->a_pvariable(masterId, v) = (m_solver->a_pvariable(masterId, v) * m_solver->a_slope(masterId, 1, 0)
                                              + m_solver->a_pvariable(smallCellId, v) * m_bndryCell[smallCell].m_volume)
                                             / totalVolume;
        m_solver->a_pvariable(smallCellId, v) = m_solver->a_pvariable(masterId, v);
      }


      for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
        // update coordinates of the...
        coordinates = (m_solver->a_coordinate(masterId, spaceId) * m_solver->a_slope(masterId, 1, 0)
                       + m_solver->a_coordinate(smallCellId, spaceId) * m_bndryCell[smallCell].m_volume)
                      / totalVolume;
        // ...master cell
        m_solver->a_coordinate(masterId, spaceId) = coordinates;
      }
      m_solver->a_slope(masterId, 1, 0) = totalVolume;
    }
  }

  // small cells are moved to the final position of their master cell
  // small cells with an internal master receive its original position
  for(MInt smallId = 0; smallId < noSmallCells; smallId++) {
    smallCell = m_smallBndryCells->a[smallId];
    smallCellId = m_bndryCell[smallCell].m_cellId;
    masterId = m_bndryCell[smallCell].m_linkedCellId;
    master = m_solver->a_bndryId(masterId);

    for(MInt i = 0; i < nDim; i++) {
      m_bndryCell[smallCell].m_coordinates[i] +=
          (m_solver->a_coordinate(masterId, i) - m_solver->a_coordinate(smallCellId, i));
      m_solver->a_coordinate(smallCellId, i) = m_solver->a_coordinate(masterId, i);
    }

    if(master == -1) {
      for(MInt i = 0; i < nDim; i++) {
        m_bndryCell[smallCell].m_masterCoordinates[i] = m_solver->a_slope(masterId, 0, i);
      }
    }
  }
}


/**
 * \brief merges master and small cells - for multiple ghost cells formulation
 *
 * Master cell coordinates, volume, and the coordinates, area and
 * orientation of its body surface are updated
 * Small cell coordinates are updated; volume and body
 * surface remain unchanged
 *
 * Cell arrays used for temporary data storage:
 *    slope[0][i] : original coordinates
 *    slope[1][0] : volumes
 *
 * Contrary to original formulation the bondary surfaces of master and
 * small cells are kept unchanged
 *
 * \author: Claudia Guenther, April 2009
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::mergeCellsMGC() {
  TRACE();

  MInt smallCell;
  MInt smallCellId;
  MInt master;
  MInt masterId;
  MInt noCells = m_solver->a_noCells();
  MInt noSmallCells = m_smallBndryCells->size();
  MFloat totalVolume;
  MFloat coordinates;
  //---

  // store all original coordinates, reset volumes
  for(MInt id = 0; id < noCells; id++) {
    m_solver->a_slope(id, 1, 0) = m_solver->grid().gridCellVolume(m_solver->a_level(id));
    for(MInt i = 0; i < nDim; i++) {
      m_solver->a_slope(id, 0, i) = m_solver->a_coordinate(id, i);
    }
  }

  for(MInt smallId = 0; smallId < noSmallCells; smallId++) {
    smallCell = m_smallBndryCells->a[smallId];
    smallCellId = m_bndryCell[smallCell].m_cellId;
    masterId = m_bndryCell[smallCell].m_linkedCellId;
    master = m_solver->a_bndryId(masterId);

    if(master > -1) {
      // first case: master cell is a boundary cell
      // ------------------------------------------

      totalVolume = m_bndryCell[master].m_volume + m_bndryCell[smallCell].m_volume;

      for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
        // update coordinates of the...
        coordinates = (m_solver->a_coordinate(masterId, spaceId) * m_bndryCell[master].m_volume
                       + m_solver->a_coordinate(smallCellId, spaceId) * m_bndryCell[smallCell].m_volume)
                      / totalVolume;
        // ...master cell
        m_bndryCell[master].m_coordinates[spaceId] += (coordinates - m_solver->a_coordinate(masterId, spaceId));
        m_solver->a_coordinate(masterId, spaceId) = coordinates;
      }

      // update cell volume = master cell volume + small cell volume
      m_bndryCell[master].m_volume = totalVolume;

    } else {
      // second case: master is an internal cell
      // ---------------------------------------
      totalVolume = m_solver->a_slope(masterId, 1, 0) + m_bndryCell[smallCell].m_volume;

      for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
        // update coordinates of the...
        coordinates = (m_solver->a_coordinate(masterId, spaceId) * m_solver->a_slope(masterId, 1, 0)
                       + m_solver->a_coordinate(smallCellId, spaceId) * m_bndryCell[smallCell].m_volume)
                      / totalVolume;
        // ...master cell
        m_solver->a_coordinate(masterId, spaceId) = coordinates;
      }

      // if master has multiple small cells, volume must be updated!
      m_solver->a_slope(masterId, 1, 0) = totalVolume;
    }
  }

  // small cells are moved to the final position of their master cell
  // small cells with an internal master receive its original position
  //             in the masterCoordinates variable
  for(MInt smallId = 0; smallId < noSmallCells; smallId++) {
    smallCell = m_smallBndryCells->a[smallId];
    smallCellId = m_bndryCell[smallCell].m_cellId;
    masterId = m_bndryCell[smallCell].m_linkedCellId;
    master = m_solver->a_bndryId(masterId);

    for(MInt i = 0; i < nDim; i++) {
      m_bndryCell[smallCell].m_coordinates[i] +=
          (m_solver->a_coordinate(masterId, i) - m_solver->a_coordinate(smallCellId, i));
      m_solver->a_coordinate(smallCellId, i) = m_solver->a_coordinate(masterId, i);
    }

    if(master == -1) {
      for(MInt i = 0; i < nDim; i++) {
        m_bndryCell[smallCell].m_masterCoordinates[i] = m_solver->a_slope(masterId, 0, i);
      }
    }
  }
}


/**
 * corrects the volume and the center of gravity of the boundary cells
 * using fine cell information
 * creates body surfaces using fine cell information
 * does not work correctly with multipleGhostCell formulation (claudia)!
 *
 * it is required that small and master cells are not yet merged!!!
 * NOTE: not doing anything in the new multi-level as multi-solver approach!
 *
 * \author Daniel Hartmann, March 10, 2006
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::correctCoarseBndryCells() {
  TRACE();

  MInt cellId;
  MInt noChildren;
  MInt childCellId;
  MInt noCells = m_bndryCells->size();
  MFloat bndryCellVolumes;
  MFloat childVolume;
  MFloat volume;
  MFloatScratchSpace bndryXyz_scratch(nDim, AT_, "bndryXyz_scratch");
  MFloat* bndryXyz = bndryXyz_scratch.getPointer();
  MFloatScratchSpace cellXyz_scratch(nDim, AT_, "cellXyz_scratch");
  MFloat* cellXyz = cellXyz_scratch.getPointer();
  MFloatScratchSpace srfcXyz_scratch(nDim, AT_, "srfcXyz_scratch");
  MFloat* srfcXyz = srfcXyz_scratch.getPointer();
  MFloat srfcArea;

  // ------------- end of initialization --------------

  // loop over all levels
  for(MInt level = m_solver->maxRefinementLevel() - 1; level > 0; level--) {
    // loop over all boundary cells
    for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
      // choose only those boundary cells at the current level
      cellId = m_bndryCells->a[bndryId].m_cellId;
      if(m_solver->a_level(cellId) == level) {
        noChildren = m_solver->c_noChildren(cellId);

        if(noChildren > 0) {
          // reset temp. variables
          volume = 0;
          bndryCellVolumes = 0;
          srfcArea = 0;
          for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
            bndryXyz[spaceId] = 0;
            cellXyz[spaceId] = 0;
            srfcXyz[spaceId] = 0;
          }

          // -------- average children cell coordinates and volumes ---------
          for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
            if(m_solver->c_childId(cellId, childId) == -1) continue;

            childCellId = m_solver->c_childId(cellId, childId);

            if(m_solver->a_bndryId(childCellId) > -1) {
              volume += m_bndryCells->a[m_solver->a_bndryId(childCellId)].m_volume;
              bndryCellVolumes += m_bndryCells->a[m_solver->a_bndryId(childCellId)].m_volume;

              for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
                bndryXyz[spaceId] += m_solver->a_coordinate(childCellId, spaceId)
                                     * m_bndryCells->a[m_solver->a_bndryId(childCellId)].m_volume;
              }

              // average body surface of children
              srfcArea += m_bndryCells->a[m_solver->a_bndryId(childCellId)].m_srfcs[0]->m_area;
              for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
                srfcXyz[spaceId] += m_bndryCells->a[m_solver->a_bndryId(childCellId)].m_srfcs[0]->m_coordinates[spaceId]
                                    * m_bndryCells->a[m_solver->a_bndryId(childCellId)].m_srfcs[0]->m_area;
              }

            } else {
              childVolume = m_solver->c_cellLengthAtCell(childCellId);
              for(MInt spaceId = 1; spaceId < nDim; spaceId++) {
                childVolume *= m_solver->c_cellLengthAtCell(childCellId);
              }
              volume += childVolume;
              for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
                cellXyz[spaceId] += m_solver->a_coordinate(childCellId, spaceId) * childVolume;
              }
            }
          }

          for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
            cellXyz[spaceId] += bndryXyz[spaceId];
            cellXyz[spaceId] = cellXyz[spaceId] / volume;
            bndryXyz[spaceId] = bndryXyz[spaceId] / bndryCellVolumes;
            srfcXyz[spaceId] = srfcXyz[spaceId] / srfcArea;
          }

          // ----------------------------------------------------------------

          // correct the coordinate shift of the boundary cell
          // set the coordinates of the boundary cell
          for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
            m_bndryCells->a[bndryId].m_coordinates[spaceId] +=
                cellXyz[spaceId] - m_solver->a_coordinate(cellId, spaceId);
            m_solver->a_coordinate(cellId, spaceId) = cellXyz[spaceId];
            m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[spaceId] = srfcXyz[spaceId];
          }

          // update coarse cell volume
          m_bndryCells->a[bndryId].m_volume = volume;
        }
      }
    }
  }
}


/**
 * update RHS of small and corresponding master cells
 *
 *
 * \author Daniel Hartmann, March 29, 2006
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::updateRHSSmallCells() {
  TRACE();

  MInt bndryId;
  MInt cellId;
  MInt noCVars = CV->noVariables;
  MInt noFVars = FV->noVariables;
  MInt noCells = m_smallBndryCells->size();
  //---

  for(MInt smallCellId = 0; smallCellId < noCells; smallCellId++) {
    bndryId = m_smallBndryCells->a[smallCellId];
    cellId = m_bndryCells->a[bndryId].m_cellId;

    for(MInt varId = 0; varId < noCVars; varId++) {
      m_solver->a_tau(cellId, varId) = 0;
    }
    for(MInt varId = 0; varId < noFVars; varId++) {
      m_solver->a_rightHandSide(cellId, varId) = 0;
    }
  }
}


/// \brief Copies the slopes from the master cells to the small cells
///
/// NOTE: this is an inner-most loop of MAIA
/// Don't modify it unless you _REALLY_ know what you are doing.
template <MInt nDim, class SysEqn>
inline void FvBndryCndXD<nDim, SysEqn>::copySlopesToSmallCells() {
  const MUint noVars = PV->noVariables;
  const MUint noSlopes = nDim * noVars;
  const MUint noSmallCells = m_smallBndryCells->size();
  const MInt* const RESTRICT smallCellIds = m_solver->m_smallCellIds;
  const MInt* const RESTRICT masterCellIds = m_solver->m_masterCellIds;
  MFloat* const RESTRICT slope = &m_solver->a_slope(0, 0, 0);

  for(MUint c = 0; c < noSmallCells; ++c) {
    const MUint scId = smallCellIds[c];
    const MUint mcId = masterCellIds[c];
    MFloat* const RESTRICT smallCellSlopes = slope + scId * noSlopes;
    const MFloat* const RESTRICT masterCellSlopes = slope + mcId * noSlopes;
    for(MUint slopeId = 0; slopeId < noSlopes; ++slopeId) {
      smallCellSlopes[slopeId] = masterCellSlopes[slopeId];
    }
  }
}

/// \brief Corrects the left and right variables values on the boundary surface
///
/// NOTE: this is an inner-most loop of MAIA
/// Don't modify it unless you _REALLY_ know what you are doing.
/// \author Daniel Hartmann, January 10, 2007
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::correctBoundarySurfaceVariables() {
  const MUint noBndrySurfaces = m_noBoundarySurfaces;
  const MUint noVars = PV->noVariables;
  const MUint surfaceVarMemory = 2 * noVars;
  MFloat* const RESTRICT surfaceVar = &m_solver->a_surfaceVariable(0, 0, 0);
  const MInt* const RESTRICT nghbrCellIds = &m_solver->a_surfaceNghbrCellId(0, 0);
  const MFloat* const RESTRICT vars = &m_solver->a_pvariable(0, 0);

  if(m_cellMerging) {
    for(MUint bs = 0; bs < noBndrySurfaces; ++bs) {
      const MUint srfcId = m_boundarySurfaces[bs];
      const MUint srfcOffset = srfcId * surfaceVarMemory;
      const MFloat* const RESTRICT vars0 = vars + nghbrCellIds[srfcId * 2] * noVars;
      const MFloat* const RESTRICT vars1 = vars + nghbrCellIds[srfcId * 2 + 1] * noVars;
      MFloat* const RESTRICT surfaceVar0 = surfaceVar + srfcOffset;
      MFloat* const RESTRICT surfaceVar1 = surfaceVar0 + noVars;
      for(MUint v = 0; v < noVars; ++v) {
        const MFloat tmp = F1B2 * (vars0[v] + vars1[v]);
        surfaceVar0[v] = tmp;
        surfaceVar1[v] = tmp;
      }
    }
  } else {
    const MInt noBndryCells = m_bndryCells->size();
    for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
      const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
      if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        for(MInt i = 0; i < nDim; i++) {
          const MInt srfcId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_srfcId[i];
          if(srfcId < 0) continue;
          const MUint srfcOffset = srfcId * surfaceVarMemory;
          MFloat* const RESTRICT surfaceVar0 = surfaceVar + srfcOffset;
          MFloat* const RESTRICT surfaceVar1 = surfaceVar0 + noVars;
          for(MUint v = 0; v < noVars; ++v) {
            surfaceVar0[v] = m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[v];
            surfaceVar1[v] = m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[v];
          }
        }
      }
    }
  }
}


/**
 * \brief Interpolates variables of surrounding boundary cells to those small cells
 * that are considered at the highest level
 * small cells at lower levels receive a copy/average of the children cell
 * variables (children may be small cells, but do not have to be!)
 *
 * Master cells are required to be boundary cells!
 *
 * Daniel Hartmann, April 12, 2006
 *
 */
/// NOTE: this is an inner-most loop of MAIA
/// Don't modify it unless you _REALLY_ know what you are doing.
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::copyVarsToSmallCells() {
  const MUint noSmallCells = m_smallBndryCells->size();
  const MUint noVars = CV->noVariables;
  const MInt* const RESTRICT smallIds = &m_smallBndryCells->a[0];
  const FvBndryCell<nDim, SysEqn>* const bCells = &m_bndryCells->a[0];
  MFloat* const RESTRICT vars = &m_solver->a_variable(0, 0);

  // loop over all small boundary cells
  for(MUint smallId = 0; smallId < noSmallCells; ++smallId) {
    const MUint smallCell = smallIds[smallId];
    const MUint smallCellId = bCells[smallCell].m_cellId;
    const MUint masterId = bCells[smallCell].m_linkedCellId;

    // copy the variables from master to slave cells
    MFloat* const RESTRICT smallCellVars = vars + smallCellId * noVars;
    const MFloat* const RESTRICT masterCellVars = vars + masterId * noVars;
    for(MUint v = 0; v < noVars; ++v) {
      smallCellVars[v] = masterCellVars[v];
    }
  }
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::setNearBoundaryRecNghbrs(MInt updateOnlyBndryCndId) {
  TRACE();

  const MInt noBndryCells = m_bndryCells->size();
  const MInt maxNoNghbrs = 200;
  const MInt noLayersStencil = m_noFluxRedistributionLayers;
  if(noDomains() > 1 && noLayersStencil > mMin(m_noFluxRedistributionLayers, m_solver->noHaloLayers())) {
    cerr << "Warning: noLayersStencil smaller than flux redistribution layers!" << endl;
  }

  MIntScratchSpace nghbrList(maxNoNghbrs, AT_, "nghbrList");
  MIntScratchSpace layerId(maxNoNghbrs, AT_, "layerId");
  MIntScratchSpace dummyIds(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, AT_, "dummyIds");

  for(MInt s = 0; s < FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces; s++) {
    dummyIds(s) = m_solver->maxNoGridCells() - FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces + s;
    if(dummyIds(s) < (m_solver->a_noCells())) {
      mTerm(1, AT_,
            "Increase cell collector! " + to_string(m_solver->a_noCells()) + " "
                + to_string(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces));
    }
  }

  if(updateOnlyBndryCndId < 0) {
    for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
      m_bndryCell[bndryId].m_recNghbrIds.resize(0);
      m_bndryCell[bndryId].m_cellVarsRecConst.resize(0);
      m_bndryCell[bndryId].m_cellDerivRecConst.resize(0);
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst.resize(0);
      }
    }
  } else {
    for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
      const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
      if(m_solver->a_isPeriodic(cellId) || m_solver->a_isHalo(cellId)) {
        m_bndryCell[bndryId].m_cellVarsRecConst.resize(0);
        m_bndryCell[bndryId].m_cellDerivRecConst.resize(0);
      }
      MBool skip = false;
      // if( m_solver->a_isPeriodic( cellId ) ) skip = true;
      if(m_solver->a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
      if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) skip = true;
      if(m_solver->a_hasProperty(cellId, SolverCell::IsNotGradient)) skip = true;
      if(m_solver->a_hasProperty(cellId, SolverCell::IsSplitCell)) skip = true;
      if(m_solver->c_noChildren(cellId) > 0) skip = true;
      if(skip) {
        m_bndryCell[bndryId].m_recNghbrIds.resize(0);
        m_bndryCell[bndryId].m_cellVarsRecConst.resize(0);
        m_bndryCell[bndryId].m_cellDerivRecConst.resize(0);
        for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
          m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst.resize(0);
        }
      }
    }
  }

  for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    const MInt noSrfcs = m_bndryCells->a[bndryId].m_noSrfcs;
    MInt gridcellId = cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsSplitClone)) {
      gridcellId = m_solver->m_splitChildToSplitCell.find(cellId)->second;
    }

    // if( m_solver->a_isPeriodic( cellId ) ) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsSplitChild) && m_solver->c_noChildren(gridcellId) > 0) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;

    MBool skip = false;
    if(updateOnlyBndryCndId > -1) {
      skip = true;
      for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
        if(m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId == updateOnlyBndryCndId) skip = false;
      }
    }
    if(skip) continue;

    m_bndryCell[bndryId].m_recNghbrIds.resize(0);
    m_bndryCell[bndryId].m_cellVarsRecConst.resize(0);
    m_bndryCell[bndryId].m_cellDerivRecConst.resize(0);
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst.resize(0);
    }

    nghbrList.fill(-1);
    const MInt rootCell = (m_solver->a_hasProperty(cellId, SolverCell::IsSplitChild)
                           || m_solver->a_hasProperty(cellId, SolverCell::IsSplitClone))
                              ? m_solver->getAssociatedInternalCell(cellId)
                              : cellId;
    ASSERT(rootCell > -1 && rootCell < m_solver->a_noCells(), "");
    const MInt addPoints = noSrfcs + 1;
    const MInt recSize = m_solver->template getAdjacentLeafCells<1, true>(rootCell, noLayersStencil, nghbrList, layerId)
                         + addPoints; // my neighbors + my boundary-surface centroids + myself

    if(recSize > maxNoNghbrs) {
      mTerm(1, AT_,
            "too many nghbrs " + to_string(recSize) + " " + to_string(cellId) + " "
                + to_string(m_solver->a_isHalo(cellId)));
    }
    if(recSize < nDim + 2) {
      cerr << "not enough neighbors " + to_string(recSize) + " " + to_string(recSize - addPoints) + " "
                  + to_string(cellId)
           << " " << m_solver->a_isHalo(cellId) << endl;
      continue;
    }
    for(MInt k = recSize - 1; k >= addPoints; k--) {
      ASSERT(k - addPoints > -1, "");
      ASSERT(nghbrList(k - addPoints) > -1 && nghbrList(k - addPoints) < m_solver->a_noCells(), "");
      nghbrList(k) = nghbrList(k - addPoints);
      layerId(k) = layerId(k - addPoints);
    }
    for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
      nghbrList(srfc) = dummyIds(srfc);
      layerId(srfc) = 0;
    }
    nghbrList(noSrfcs) = cellId;
    layerId(noSrfcs) = 0;

    m_bndryCell[bndryId].m_recNghbrIds.resize(recSize);
    m_bndryCell[bndryId].m_cellVarsRecConst.resize(recSize);
    for(MInt k = 0; k < recSize; k++) {
      m_bndryCell[bndryId].m_recNghbrIds[k] = nghbrList(k);
      m_bndryCell[bndryId].m_cellVarsRecConst[k] = (MFloat)layerId(k);
    }
  }
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::computeImagePointRecConst(MInt updateOnlyBndryCndId) {
  TRACE();

  const MInt minRecDim = nDim + 1;
  // const MInt medRecDim = m_secondOrderRec ? 2*nDim + 1 : minRecDim;
  const MInt maxRecDim = m_secondOrderRec ? (IPOW2(nDim) + 2) : minRecDim;
  const MInt noBndryCells = m_bndryCells->size();
  const MInt maxNoSrfcs = 14;
  if(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces > maxNoSrfcs) {
    mTerm(1, AT_, "Increase maxNoSrfcs. " + to_string(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces));
  }
  const MInt maxNoNghbrs = 200;
  const MInt noLayersStencil = m_noFluxRedistributionLayers;
  const MFloat condNumThreshold = 1e7;
  MBool& firstRun = m_static_computeImagePointRecConst_firstRun;
  if(noDomains() > 1 && noLayersStencil > mMin(m_noFluxRedistributionLayers, m_solver->noHaloLayers())) {
    cerr << "Warning: noLayersStencil smaller than flux redistribution layers!" << endl;
  }

  MIntScratchSpace layerId(maxNoNghbrs, AT_, "layerId");
  MFloatScratchSpace normal(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, nDim, AT_, "normal");
  MFloatScratchSpace deltaXSurf(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, nDim, AT_, "deltaXSurf");
  MFloatScratchSpace imagePoint(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, nDim, AT_, "imagePoint");
  MFloatScratchSpace surfCoords(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, nDim, AT_, "surfCoords");
  MFloatScratchSpace deltaXSurfProj(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, nDim, AT_, "deltaXSurfProj");
  MFloatScratchSpace deltaNSurf(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, AT_, "deltaNSurf");
  MFloatScratchSpace backup(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, maxRecDim, AT_, "backup");
  MFloatScratchSpace mat(maxNoNghbrs, maxRecDim, AT_, "mat_imagePoint");
  MFloatScratchSpace matInv(maxRecDim, maxNoNghbrs, AT_, "matInv");
  MFloatScratchSpace weights(maxNoNghbrs, AT_, "weights");

  MFloat maxCondNum0 = F0;
  MFloat maxCondNum1 = F0;
  MFloat avgCondNum0 = F0;
  MFloat avgCondNum1 = F0;
  MFloat condCnt0 = F0;
  MFloat condCnt1 = F0;

  for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    const MInt noSrfcs = m_bndryCells->a[bndryId].m_noSrfcs;
    MInt gridcellId = cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsSplitClone)) {
      gridcellId = m_solver->m_splitChildToSplitCell.find(cellId)->second;
    }

    // if( m_solver->a_isPeriodic( cellId ) ) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsSplitChild) && m_solver->c_noChildren(gridcellId) > 0) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;
    if(m_bndryCell[bndryId].m_recNghbrIds.size() == 0) continue;
    MBool skip = false;
    if(updateOnlyBndryCndId > -1) {
      skip = true;
      for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
        if(m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId == updateOnlyBndryCndId) skip = false;
      }
    }
    if(skip) continue;

    const MFloat normalizationFactor =
        FPOW2(m_solver->a_level(cellId))
        / m_solver->c_cellLengthAtLevel(0); // scaling factor to reduce the condition number of the resulting eq. sys.

    for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
      // const MInt ghostCellId = m_bndryCells->a[ bndryId ].m_srfcVariables[srfc]->m_ghostCellId;
      // ASSERT( ghostCellId > -1, "" );
      deltaNSurf[srfc] = m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance;
      for(MInt i = 0; i < nDim; i++) {
        // normal(srfc,i) = m_bndryCell[ bndryId ].m_srfcs[srfc]->m_normalVector[ i ];
        normal(srfc, i) = m_bndryCell[bndryId].m_srfcs[srfc]->m_normalVectorCentroid[i];
      }
      /*deltaNSurf[srfc] = F0;
      for ( MInt i = 0; i < nDim; i++ ) {
        normal(srfc,i) = m_bndryCell[ bndryId ].m_srfcs[srfc]->m_normalVector[ i ];
        deltaNSurf[srfc] += normal(srfc,i) * ( m_solver->a_coordinate( cellId ,  i ) - m_bndryCell[ bndryId
      ].m_srfcs[srfc]->m_coordinates[ i ] );
      }
     */
    }

    MFloatScratchSpace dummyCoordinates(noSrfcs, nDim, AT_, "dummyCoordinates");
    MIntScratchSpace dummyLevel(noSrfcs, AT_, "dummyLevel");
    MFloatScratchSpace dummyCellVolume(noSrfcs, AT_, "dummyLevel");
    for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
      for(MInt i = 0; i < nDim; i++) {
        // deltaXSurf(srfc,i) = m_bndryCell[ bndryId ].m_srfcs[srfc]->m_coordinates[ i ] - m_solver->a_coordinate(
        // cellId ,  i );
        deltaXSurfProj(srfc, i) = -deltaNSurf[srfc] * normal(srfc, i);
        deltaXSurf(srfc, i) = deltaXSurfProj(srfc, i);
        // imagePoint(srfc,i) = m_solver->a_coordinate( cellId ,  i ) + ( F1B2 *
        // m_solver->c_cellLengthAtLevel(m_solver->a_level( cellId )) - deltaNSurf[srfc] ) * normal(srfc,i);
        // imagePoint(srfc,i) = m_solver->a_coordinate( cellId ,  i ) + mMax( F0, ( F1B2 *
        // m_solver->c_cellLengthAtLevel(m_solver->a_level( cellId )) - deltaNSurf[srfc] ) ) * normal(srfc,i); if
        // dn>dx/2 use cell coordinates, otherwise fixed wall distance of dx/2, i.e., the image point is never closer to
        // the surface than the corresponding cell:
        imagePoint(srfc, i) =
            m_solver->a_coordinate(cellId, i)
            + mMax(F0, (mMax(deltaNSurf[srfc], F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId)))
                        - deltaNSurf[srfc]))
                  * normal(srfc, i);
        surfCoords(srfc, i) = m_solver->a_coordinate(cellId, i) - deltaNSurf[srfc] * normal(srfc, i);
      }

      const MInt dummyId = m_bndryCell[bndryId].m_recNghbrIds[srfc]; // dummyIds(srfc);
      dummyLevel[srfc] = m_solver->a_level(cellId);
      dummyCellVolume(srfc) = m_solver->grid().gridCellVolume(m_solver->a_level(cellId));
      m_solver->a_bndryId(dummyId) = -1;
      for(MInt i = 0; i < nDim; i++) {
        dummyCoordinates(srfc, i) = m_solver->a_coordinate(cellId, i) + deltaXSurfProj(srfc, i);
      }
    }

    const MInt recSize = m_bndryCell[bndryId].m_recNghbrIds.size();
    const MInt noNghbrIds = recSize;
    for(MInt k = 0; k < noNghbrIds; k++) {
      layerId(k) = (MInt)m_bndryCell[bndryId].m_cellVarsRecConst[k];
      if(k <= noSrfcs && layerId(k) != 0) {
        mTerm(1, AT_, "FvBndryCndXD<nDim, SysEqn>::computeImagePointRecConst: Inconsistency 0.");
      }
      if(k > noSrfcs && (layerId(k) < 1 || layerId(k) > noLayersStencil)) {
        mTerm(1, AT_, "FvBndryCndXD::computeImagePointRecConst: Inconsistency 0b.");
      }
    }
    m_bndryCell[bndryId].m_cellVarsRecConst.resize(0);

    mat.fill(F0);
    weights.fill(F0);

    // image point reconstruction constants
    for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
      m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst.resize(recSize);
      ASSERT(m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst.size()
                 == m_bndryCell[bndryId].m_recNghbrIds.size(),
             "");
      for(MInt k = 0; k < noNghbrIds; k++) {
        const MInt nghbrId = m_bndryCell[bndryId].m_recNghbrIds[k];
        const MFloat* const nghbrCoord =
            (k < noSrfcs) ? &dummyCoordinates(k, 0) : &(m_solver->a_coordinate(nghbrId, 0));
        const MInt nghbrLevel = (k < noSrfcs) ? dummyLevel[k] : m_solver->a_level(nghbrId);
        const MFloat nghbrCellVolume = (k < noSrfcs) ? dummyCellVolume(k) : m_solver->a_cellVolume(nghbrId);
        mat(k, 0) = F1;
        MFloat dx = F0;
        for(MInt i = 0; i < nDim; i++) {
          mat(k, 1 + i) = (nghbrCoord[i] - imagePoint(srfc, i)) * normalizationFactor;
          dx += POW2(nghbrCoord[i] - imagePoint(srfc, i));
        }
        weights(k) = maia::math::RBF(dx, POW2(m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId))))
                     * maia::math::deltaFun(nghbrCellVolume / m_solver->grid().gridCellVolume(nghbrLevel), 1e-6, 0.1);
        // weights(k) = maia::math::RBF( dx, POW2( m_solver->c_cellLengthAtLevel( m_solver->a_level( cellId ) ) ) );
        // //no additional weights (may be useful for fixed boundaries)

        if(layerId(k) > 1) {
          weights(k) = F0; // stencil is required also on the first halo layer from which only one additional layer is
        }
                           // accessible, otherwise three halo layers are required for unique results
      }

      const MInt recDim = minRecDim;
      maia::math::invert(mat, weights, matInv, noNghbrIds, recDim);
      const MFloat condNum = maia::math::frobeniusMatrixNormSquared(mat, noNghbrIds, recDim);
      maxCondNum0 = mMax(maxCondNum0, condNum);
      avgCondNum0 += condNum;
      condCnt0 += F1;
      if(condNum < F0 || condNum > condNumThreshold) {
        cerr << "() Warning: Image-point SVD failed (" << condNum << ") cell " << cellId << " ("
             << m_solver->c_globalId(cellId) << ") "
             << ", " << recSize << "x" << nDim + 1 << " vfrac "
             << m_bndryCells->a[bndryId].m_volume / m_solver->grid().gridCellVolume(m_solver->a_level(cellId))
             << " at timestep " << globalTimeStep << endl;
        for(MInt k = 0; k < recSize; k++) {
          cerr << m_bndryCell[bndryId].m_recNghbrIds[k] << " ";
        }
        cerr << endl;
        for(MInt k = 0; k < recSize; k++) {
          cerr << weights(k) << " ";
        }
        cerr << endl;
        for(MInt k = 0; k < recSize; k++) {
          const MFloat nghbrCellVolume =
              (k < noSrfcs) ? dummyCellVolume(k) : m_solver->a_cellVolume(m_bndryCell[bndryId].m_recNghbrIds[k]);
          cerr << nghbrCellVolume << " ";
        }
        cerr << endl;
        // for ( MInt k = 0; k < recSize; k++ ) { cerr << layerId(k) << " "; } cerr << endl;
        // for ( MInt k = 0; k < recSize; k++ ) { cerr << m_solver->a_level( m_bndryCell[ bndryId ].m_recNghbrIds[k] )
        // << " "; } cerr << endl; for ( MInt k = 0; k < recSize; k++ ) { cerr << m_solver->a_hasProperty( m_bndryCell[
        // bndryId ].m_recNghbrIds[k] , SolverCell::IsOnCurrentMGLevel) << " "; } cerr << endl;
      }
      for(MInt k = 0; k < noNghbrIds; k++) {
        for(MInt i = 0; i < nDim; i++) {
          matInv(1 + i, k) *= normalizationFactor;
        }
      }
      for(MInt k = 0; k < noNghbrIds; k++) {
        m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst[k] = matInv(0, k);
      }

      MFloat phiSum = m_bndryCells->a[bndryId].m_gapDistance;

      const MFloat dx0 = F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId));
      const MFloat dx1 = F2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId));
      const MFloat gapInd =
          F1 - mMax(F0, mMin(F1, (phiSum - dx0) / (dx1 - dx0))); // narrow gap indicator, reduce interpolation
                                                                 // order to increase stability
      if(gapInd > 1e-12) {
        for(MInt k = 0; k < noNghbrIds; k++) {
          m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst[k] *= (F1 - gapInd);
        }
        m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst[noSrfcs] += gapInd;
      }
      /*
      MBool reduceOrder = ( noSrfcs > 1 ) || ( phiSum < F2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId))) ;
      if ( reduceOrder ) { //|| m_bndryCell[ bndryId ].m_srfcs[srfc]->m_bndryCndId / 1000 != 3 ) {
        for ( MInt k = 0; k < noNghbrIds; k++ ) {
          m_bndryCell[ bndryId ].m_srfcVariables[srfc]->m_imagePointRecConst[k] = F0;
        }
        m_bndryCell[ bndryId ].m_srfcVariables[srfc]->m_imagePointRecConst[noSrfcs] = F1;
      } */
    }
  }
  if(firstRun || globalTimeStep % 100 == 0) {
    m_log << "Image point average (maximum) condition number: " << avgCondNum0 / condCnt0 << " (" << maxCondNum0
          << "), normal stress: " << avgCondNum1 / condCnt1 << " (" << maxCondNum1 << ")." << endl;
  }

#ifndef NDEBUG
  for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
    const MInt noSrfcs = m_bndryCells->a[bndryId].m_noSrfcs;
    for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
      if(m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst.size()
         != m_bndryCell[bndryId].m_recNghbrIds.size()) {
        cerr << domainId() << ": " << bndryId << " " << srfc << " " << m_bndryCell[bndryId].m_recNghbrIds.size() << " "
             << m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst.size() << endl;
        mTerm(1, AT_, "FvBndryCndXD::computeImagePointRecConst: Inconsistency 1.");
      }
    }
  }
#endif

  firstRun = false;
}


/**
 * \brief Initialize the small-cell correction for the flux-redistribution method
 *        The cell vars are computed using a weighted least squares approach
 *        For details see Schneiders,Hartmann,Meinke,Schrder, J.Comput.Phys. 235 (2013)
 *        For more details see the dissertation of Lennart Schneiders, "Particle-Resolved
 *        Analysis of Turbulent Multiphase Flow by a Cut-Cell Method" Chapter 3.4
 *        If bndryCndId is specified (standard value=-1) only boundary cells corresponding
 *        to the stated boundary are initialized
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::initSmallCellCorrection(MInt updateOnlyBndryCndId) {
  TRACE();

  if(m_smallCellRHSCorrection) {
    return;
  }

  const MInt minRecDim = nDim + 1;
  const MInt medRecDim = 2 * nDim + 1;
  const MInt maxRecDim = m_secondOrderRec ? (IPOW2(nDim) + 2) : minRecDim;
  const MInt noBndryCells = m_bndryCells->size();
  const MInt maxNoSrfcs = 14;
  const MInt volFactor = nDim == 3 ? 4 : 2;
  if(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces > maxNoSrfcs) {
    mTerm(1, AT_, "Increase maxNoSrfcs. " + to_string(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces));
  }
  const MInt maxNoNghbrs = 200;
  const MInt noLayersStencil = m_noFluxRedistributionLayers;
  const MFloat condNumThreshold = 1e7;
  MBool& firstRun = m_static_initSmallCellCorrection_firstRun;
  if(noLayersStencil > mMin(m_noFluxRedistributionLayers, m_solver->noHaloLayers())) {
    cerr << "Warning: noLayersStencil smaller than flux redistribution layers!" << endl;
  }
  if(firstRun) m_log << "Initializing small cell treatment." << endl;

  MFloatScratchSpace normal(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, nDim, AT_, "normal");
  MFloatScratchSpace deltaXSurf(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, nDim, AT_, "deltaXSurf");
  MFloatScratchSpace deltaXSurfProj(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, nDim, AT_, "deltaXSurfProj");
  MFloatScratchSpace deltaNSurf(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, AT_, "deltaNSurf");
  MFloatScratchSpace backup(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, maxRecDim, AT_, "backup");
  MFloatScratchSpace mat(maxNoNghbrs, maxRecDim, AT_, "mat_smallCells");
  MFloatScratchSpace matInv(maxRecDim, maxNoNghbrs, AT_, "matInv");
  MFloatScratchSpace weights(maxNoNghbrs, AT_, "weights");

  MFloat maxCondNum0 = F0;
  MFloat maxCondNum1 = F0;
  MFloat avgCondNum0 = F0;
  MFloat avgCondNum1 = F0;
  MFloat condCnt0 = F0;
  MFloat condCnt1 = F0;

  m_smallCutCells.clear();
  for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    const MInt noSrfcs = m_bndryCells->a[bndryId].m_noSrfcs;
    MInt gridcellId = cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsSplitClone)) {
      gridcellId = m_solver->m_splitChildToSplitCell.find(cellId)->second;
    }

    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsSplitChild) && m_solver->c_noChildren(gridcellId) > 0) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;
    if(m_solver->a_isPeriodic(cellId)) continue;
    if(m_solver->a_isHalo(cellId)) continue;

    // commented version also applies smallCellCorrection for cutCells on lower levels, however
    // they only need to be stabilised if their volume falls below the threshold of the fines cells!
    // maxLevelChange
    const MFloat vfrac =
        (m_solver->m_localTS)
            ? m_solver->a_cellVolume(cellId) / m_solver->grid().gridCellVolume(m_solver->a_level(cellId))
            : m_solver->a_cellVolume(cellId) / m_solver->grid().gridCellVolume(m_solver->maxLevel());
    MBool atWall = false;
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      if(m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId / 1000 == 3) atWall = true;
    }
    MFloat volumeLimit = atWall ? m_volumeLimitWall : m_volumeLimitOther;

    if(m_solver->a_level(cellId) < m_solver->maxLevel() && m_solver->m_bndryLevelJumps) {
      volumeLimit = volumeLimit * volFactor * (m_solver->maxLevel() - m_solver->a_level(cellId));
    }

    if(vfrac < volumeLimit) {
      m_smallCutCells.push_back(bndryId);
    } else {
      //      continue;
    }

    MBool skip = false;
    if(updateOnlyBndryCndId > -1) {
      skip = true;
      for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
        if(m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId == updateOnlyBndryCndId) skip = false;
      }
    }
    if(skip && vfrac < volumeLimit
       && m_bndryCell[bndryId].m_cellVarsRecConst.size()
              != IPOW2(noSrfcs) * m_bndryCell[bndryId].m_recNghbrIds.size()) {
      cerr << domainId() << ": strange skip " << cellId << " " << m_solver->c_globalId(cellId) << endl;
    }
    if(skip) continue;

    const MFloat normalizationFactor =
        FPOW2(m_solver->a_level(cellId))
        / m_solver->c_cellLengthAtLevel(0); // scaling factor to reduce the condition number of the resulting eq. sys.
    const MInt recSize = m_bndryCell[bndryId].m_recNghbrIds.size();
    ASSERT(recSize > 0, "");

    MFloatScratchSpace dummyCoordinates(noSrfcs, nDim, AT_, "dummyCoordinates");
    MIntScratchSpace dummyLevel(noSrfcs, AT_, "dummyLevel");
    MFloatScratchSpace dummyCellVolume(noSrfcs, AT_, "dummyCellVolume");

    for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
      deltaNSurf[srfc] = F0;
      for(MInt i = 0; i < nDim; i++) {
        normal(srfc, i) = m_bndryCell[bndryId].m_srfcs[srfc]->m_normalVector[i];
        deltaNSurf[srfc] +=
            normal(srfc, i)
            * (m_solver->a_coordinate(cellId, i) - m_bndryCell[bndryId].m_srfcs[srfc]->m_coordinates[i]);
      }
      for(MInt i = 0; i < nDim; i++) {
        deltaXSurf(srfc, i) = m_bndryCell[bndryId].m_srfcs[srfc]->m_coordinates[i]
                              - m_solver->a_coordinate(cellId, i); // Futile, see lines below!
        deltaXSurfProj(srfc, i) = -mMax(1e-12, deltaNSurf[srfc]) * normal(srfc, i);
        deltaXSurf(srfc, i) = deltaXSurfProj(srfc, i);
      }

      const MInt dummyId = m_bndryCell[bndryId].m_recNghbrIds[srfc]; // dummyIds(srfc);
      dummyLevel[srfc] = m_solver->a_level(cellId);
      dummyCellVolume(srfc) = m_solver->grid().gridCellVolume(m_solver->a_level(cellId));
      m_solver->a_bndryId(dummyId) = -1;
      for(MInt i = 0; i < nDim; i++) {
        dummyCoordinates(srfc, i) = m_solver->a_coordinate(cellId, i) + deltaXSurfProj(srfc, i);
      }
    }

    mat.fill(F0);
    weights.fill(F0);

    MFloat counter = F0;
    for(MInt k = 0; k < recSize; k++) {
      const MInt nghbrId = m_bndryCell[bndryId].m_recNghbrIds[k];
      const MInt nghbrLevel = (k < noSrfcs) ? dummyLevel[k] : m_solver->a_level(nghbrId);
      const MFloat nghbrCellVolume = (k < noSrfcs) ? dummyCellVolume(k) : m_solver->a_cellVolume(nghbrId);
      counter += (m_solver->a_bndryId(nghbrId) > -1)
                     ? maia::math::deltaFun(nghbrCellVolume / m_solver->grid().gridCellVolume(nghbrLevel), 1e-8, F1)
                     : F1;
    }
    const MInt recDim = mMax(
        minRecDim, (counter > (MFloat)maxRecDim) ? maxRecDim : ((counter > (MFloat)medRecDim) ? medRecDim : minRecDim));
    // const MInt recDim = maxRecDim;
    const MInt recDim2 = minRecDim;
    ASSERT(minRecDim, "");
    ASSERT(medRecDim, "");

    for(MInt k = 0; k < recSize; k++) {
      const MInt nghbrId = m_bndryCell[bndryId].m_recNghbrIds[k]; // nghbrList(k);
      const MFloat* const nghbrCoord = (k < noSrfcs) ? &dummyCoordinates(k, 0) : &(m_solver->a_coordinate(nghbrId, 0));
      const MInt nghbrLevel = (k < noSrfcs) ? dummyLevel[k] : m_solver->a_level(nghbrId);
      const MFloat nghbrCellVolume = (k < noSrfcs) ? dummyCellVolume(k) : m_solver->a_cellVolume(nghbrId);
      MFloat deltaX[3];
      MFloat dx = F0;
      for(MInt i = 0; i < nDim; i++) {
        deltaX[i] = (nghbrCoord[i] - m_solver->a_coordinate(cellId, i)) * normalizationFactor;
        dx += POW2(nghbrCoord[i] - m_solver->a_coordinate(cellId, i));
      }

      MFloat nfac = F1;
      for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
        MFloat dn = F0;
        for(MInt i = 0; i < nDim; i++) {
          dn += (nghbrCoord[i] - m_bndryCell[bndryId].m_srfcs[srfc]->m_coordinates[i]) * normal(srfc, i);
        }
        MFloat deltan = 0.1 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId));
        nfac *= mMin(F1, mMax(F0, (dn + deltan) / deltan));
        // nfac *= mMin( F1, mMax( F0, (dn+deltan)/(F2*deltan) ) );
      }
      if(noSrfcs > 1) nfac = F1;
      // nfac=F1;

      weights(k) = maia::math::RBF(dx, POW2(m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId))))
                   * maia::math::deltaFun(nghbrCellVolume / m_solver->grid().gridCellVolume(nghbrLevel), 1e-8, 1.0);

      if(k > noSrfcs) weights(k) *= nfac; // do not remove (stability)!

      MInt cnt = 0;
      mat(k, cnt) = F1;
      cnt++;
      for(MInt i = 0; i < nDim; i++) {
        mat(k, cnt) = deltaX[i];
        cnt++;
      }
      for(MInt i = 0; i < nDim; i++) {
        if(cnt >= recDim) continue;
        mat(k, cnt) = F1B2 * POW2(deltaX[i]);
        cnt++;
      }
      for(MInt i = 0; i < nDim; i++) {
        for(MInt j = i + 1; j < nDim; j++) {
          if(cnt >= recDim) continue;
          mat(k, cnt) = deltaX[i] * deltaX[j];
          cnt++;
        }
      }
    }


    maia::math::invert(mat, weights, matInv, recSize, recDim);
    const MFloat condNum = maia::math::frobeniusMatrixNormSquared(mat, recSize, recDim);

    maxCondNum0 = mMax(maxCondNum0, condNum);
    avgCondNum0 += condNum;
    condCnt0 += F1;
    if(condNum < F0 || condNum > condNumThreshold) {
      cerr << "(1) Warning: SVD failed (" << condNum << ") cell " << cellId << " (" << m_solver->c_globalId(cellId)
           << ") "
           << ", " << recSize << "x" << recDim << " vfrac " << setprecision(14)
           << m_bndryCells->a[bndryId].m_volume / m_solver->grid().gridCellVolume(m_solver->a_level(cellId))
           << setprecision(6) << ", p13: " << m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)
           << ", p15: " << m_solver->a_isHalo(cellId) << " at timestep " << globalTimeStep
           << ", coords: " << m_solver->a_coordinate(cellId, 0) << " " << m_solver->a_coordinate(cellId, 10) << " "
           << m_solver->a_coordinate(cellId, mMin(nDim - 1, 2)) << endl;
      // for ( MInt k = 0; k < recSize; k++ ) cerr << nghbrList(k) << " "; cerr << endl;
      // for ( MInt k = 0; k < recSize; k++ ) cerr << weights(k) << " "; cerr << endl;

      const MFloat rank = maia::math::invertR(mat, weights, matInv, recSize, minRecDim);
      if(rank >= min(recSize, minRecDim)) {
        cerr << "Succeeded using reduced-order reconstruction." << endl;
      } else {
        cerr << "Failed also with reduced-order reconstruction, using fallback solution." << endl;
      }
    }

    for(MInt k = 0; k < recSize; k++) {
      MInt cnt = 1;
      for(MInt i = 0; i < nDim; i++) {
        matInv(cnt, k) *= normalizationFactor;
        cnt++;
      }
      for(cnt = nDim + 1; cnt < recDim; cnt++) {
        matInv(cnt, k) *= POW2(normalizationFactor);
      }
    }

    // for single boundary surface there is a Dirichlet and a Neumann stencil for the different
    // boundary conditions for multiple boundary surfaces, there can be combinations of
    // Neumann-Dirichlet or Dirichlet-Neumann boundary conditions, e.g., when a solid wall and an
    // outflow boundary intersect the cell, therefore IPOW2(noSrfcs) combinations
    m_bndryCell[bndryId].m_cellVarsRecConst.resize(recSize * IPOW2(noSrfcs));
    for(MInt p = 0; p < recSize; p++) {
      m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * p] = matInv(0, p);
    }

    // first and second derivatives at the cell centroid
    MInt noDerivs = maxRecDim - 1;
    m_bndryCell[bndryId].m_cellDerivRecConst.resize(noDerivs * recSize);
    std::fill_n(m_bndryCell[bndryId].m_cellDerivRecConst.begin(), noDerivs * recSize, F0);
    for(MInt k = 1; k < recDim; k++) {
      MInt id = k - 1;
      for(MInt p = 0; p < recSize; p++) {
        m_bndryCell[bndryId].m_cellDerivRecConst[noDerivs * p + id] = matInv(k, p);
      }
    }

    if(condNum < F0 || condNum > condNumThreshold) {
      MFloat sumcnt = F0;
      for(MInt k = 0; k < recSize; k++) {
        const MInt nghbrId = m_bndryCell[bndryId].m_recNghbrIds[k]; // nghbrList(k);
        m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * k] = F0;
        if(nghbrId == cellId) continue;
        MFloat dx = F0;
        for(MInt i = 0; i < nDim; i++) {
          dx += POW2(m_solver->a_coordinate(nghbrId, i) - m_solver->a_coordinate(cellId, i));
        }
        MFloat volume = m_solver->a_cellVolume(nghbrId);
        MFloat fac =
            maia::math::deltaFun(volume / m_solver->grid().gridCellVolume(m_solver->a_level(nghbrId)), 1e-8, 1.0);
        m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * k] = fac / mMax(1e-14, sqrt(dx));
        sumcnt += m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * k];
      }
      for(MInt k = 0; k < recSize; k++) {
        m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * k] /= sumcnt;
      }
    }


    // backup Dirichlet stencil above
    for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
      for(MInt k = 0; k < recDim; k++) {
        backup(srfc, k) = mat(srfc, k);
      }

      // !!!!!!!!!!!!!!!!!!!!!!!
      // !!!!!!!!!!!!!!!!!!!!!!!
      if(m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[PV->RHO] == BC_ISOTHERMAL) {
        weights(srfc) = F0; // !!!!!!!!!!!!!!!!!!!!!!! (extrapolation)
      }
      // !!!!!!!!!!!!!!!!!!!!!!!
      // !!!!!!!!!!!!!!!!!!!!!!!
    }
    for(MInt s = 1; s < IPOW2(noSrfcs); s++) { // zero'th bitset corresponds to full Dirichlet stencil determined above
      bitset<maxNoSrfcs> NeumannCode(s);
      for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
        if(NeumannCode.test(srfc)) {
          MFloat deltaX[3];
          MInt cnt = 1;
          const MFloat beta = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_robinFactor;
          if(std::isnan(beta)) cerr << "nan" << endl;
          // mat(srfc,0) = F0 ;
          mat(srfc, 0) = beta;
          for(MInt i = 0; i < nDim; i++) {
            deltaX[i] = deltaXSurfProj(srfc, i) * normalizationFactor;
            // mat( srfc , cnt ) = normal(srfc,i);
            mat(srfc, cnt) = normal(srfc, i) + beta * deltaX[i]; // Old line
            // mat(srfc, cnt) = normal(srfc, i) * normalizationFactor + beta * deltaX[i]; //TODO:Verify
            cnt++;
          }
          for(MInt i = 0; i < nDim; i++) {
            if(cnt >= recDim2) continue;
            // mat( srfc , cnt ) = normal(srfc,i) * deltaX[ i ];
            mat(srfc, cnt) = normal(srfc, i) * deltaX[i] + beta * F1B2 * POW2(deltaX[i]); // Old line
            // mat(srfc, cnt) = normal(srfc, i) * normalizationFactor * deltaX[i] + beta * F1B2 * POW2(deltaX[i]);
            cnt++;
          }
          for(MInt i = 0; i < nDim; i++) {
            for(MInt j = i + 1; j < nDim; j++) {
              if(cnt >= recDim2) continue;
              // mat( srfc , cnt ) = normal(srfc,i) * deltaX[ j ] + normal(srfc,j) * deltaX[ i ];
              // TODO: check
              // mat(srfc, cnt) = normal(srfc, i) * normalizationFactor * deltaX[j] + normal(srfc, j) *
              // normalizationFactor * deltaX[i] + beta * deltaX[i] * deltaX[j];
              mat(srfc, cnt) = normal(srfc, i) * deltaX[j] + normal(srfc, j) * deltaX[i] + beta * deltaX[i] * deltaX[j];
              cnt++;
            }
          }
        } else {
          for(MInt k = 0; k < recDim; k++) {
            mat(srfc, k) = backup(srfc, k);
          }
        }
      }

      ASSERT(recDim2 <= recDim, "");
      maia::math::invert(mat, weights, matInv, recSize, recDim2);
      const MFloat condNum2 = maia::math::frobeniusMatrixNormSquared(mat, recSize, recDim2);
      maxCondNum1 = mMax(maxCondNum1, condNum2);
      avgCondNum1 += condNum;
      condCnt1 += F1;
      if(condNum2 < F0 || condNum2 > condNumThreshold) {
        cerr << "(2) Warning: SVD failed (" << condNum2 << ") cell " << cellId << " (" << m_solver->c_globalId(cellId)
             << ") "
             << ", " << recSize << "x" << recDim2 << " vfrac "
             << m_bndryCells->a[bndryId].m_volume / m_solver->grid().gridCellVolume(m_solver->a_level(cellId)) << endl;
      }

      for(MInt k = 0; k < recSize; k++) {
        MInt cnt = 1;
        for(MInt i = 0; i < nDim; i++) {
          matInv(cnt, k) *= normalizationFactor;
          cnt++;
        }
        for(cnt = nDim + 1; cnt < recDim2; cnt++) {
          matInv(cnt, k) *= POW2(normalizationFactor);
        }
      }
      for(MInt p = 0; p < recSize; p++) {
        m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * p + s] = matInv(0, p);
      }

      // fallback solution: inverse distance weighting
      if(condNum2 < F0 || condNum2 > condNumThreshold) {
        MFloat sumcnt = F0;
        for(MInt k = 0; k < recSize; k++) {
          const MInt nghbrId = m_bndryCell[bndryId].m_recNghbrIds[k]; // nghbrList(k);
          m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * k + s] = F0;
          if(nghbrId == cellId) continue;
          if(k < noSrfcs) continue;
          MFloat dx = F0;
          for(MInt i = 0; i < nDim; i++) {
            dx += POW2(m_solver->a_coordinate(nghbrId, i) - m_solver->a_coordinate(cellId, i));
          }
          MFloat volume = m_solver->a_cellVolume(nghbrId);
          MFloat fac =
              maia::math::deltaFun(volume / m_solver->grid().gridCellVolume(m_solver->a_level(nghbrId)), 1e-8, 1.0);
          m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * k + s] = fac / mMax(1e-14, sqrt(dx));
          sumcnt += m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * k + s];
        }
        for(MInt k = 0; k < recSize; k++) {
          m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * k + s] /= sumcnt;
        }
      }
    }
  }
  if(firstRun || globalTimeStep % 100 == 0) {
    m_log << "Small cell treatment average (maximum) condition numbers == Dirichlet stencil: " << avgCondNum0 / condCnt0
          << " (" << maxCondNum0 << "), Neumann stencil: " << avgCondNum1 / condCnt1 << " (" << maxCondNum1 << ")."
          << endl;
  }

  MLong smallCells = m_smallCutCells.size();
  MPI_Allreduce(MPI_IN_PLACE, &smallCells, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "smallCells");

  if(firstRun || globalTimeStep % 100 == 0) {
    m_log << "Number of small cut cells for flux redistribution: " << m_smallCutCells.size() << "; global "
          << smallCells << endl;
  }
#ifndef NDEBUG
  /*
      for( MInt bndryId = 0; bndryId < noBndryCells; bndryId++ ) {
        const MInt noSrfcs = m_bndryCells->a[bndryId].m_noSrfcs;
        for(MInt srfc = 0; srfc < noSrfcs; srfc++){
          if ( m_bndryCell[ bndryId ].m_srfcVariables[srfc]->m_imagePointRecConst.size() !=
     m_bndryCell[ bndryId ].m_recNghbrIds.size() ) { cerr << domainId() << ": " << bndryId << " " <<
     srfc << " " << m_bndryCell[ bndryId ].m_recNghbrIds.size()
                 << " " << m_bndryCell[ bndryId ].m_srfcVariables[srfc]->m_imagePointRecConst.size()
     << endl; mTerm(1,AT_, "FvBndryCndXD::bcInitSmallCellCorrection: Inconsistency 1.");
          }
        }
      }*/
  for(MUint smallc = 0; smallc < m_smallCutCells.size(); smallc++) {
    const MInt bndryId = m_smallCutCells[smallc];
    const MInt noSrfcs = m_bndryCells->a[bndryId].m_noSrfcs;
    if(m_bndryCell[bndryId].m_cellVarsRecConst.size() != IPOW2(noSrfcs) * m_bndryCell[bndryId].m_recNghbrIds.size()) {
      cerr << m_bndryCell[bndryId].m_cellVarsRecConst.size() << " "
           << IPOW2(noSrfcs) * m_bndryCell[bndryId].m_recNghbrIds.size() << " "
           << m_solver->a_isHalo(m_bndryCells->a[bndryId].m_cellId) << endl;
      mTerm(1, AT_, "FvBndryCndXD::initSmallCellCorrection: Inconsistency 1.");
    }
  }
#endif

  firstRun = false;
}


/** \brief checks if all corners of a cell are located in the computational domain
 *
 * returns true if all eight corners of the cell are located in the fluid region
 * important to decide if a former cut cell can be deleted if it has only "invalid" cut points
 * (e.g. two on the same edge) or if it has to be kept as regular, non-boundary cell
 *
 * \author Claudia Guenther, June 2009
 */
template <MInt nDim, class SysEqn>
MBool FvBndryCndXD<nDim, SysEqn>::checkInside(MInt cellId) {
  TRACE();

  static constexpr MInt cornerIndices[8][3] = {{-1, -1, -1}, {1, -1, -1}, {-1, 1, -1}, {1, 1, -1},
                                               {-1, -1, 1},  {1, -1, 1},  {-1, 1, 1},  {1, 1, 1}};
  MFloat corner[3] = {0, 0, 0};
  MBool inside = true;
  MFloat cellHalfLength = F1B2 * m_solver->c_cellLengthAtCell(cellId);

  for(MInt i = 0; i < m_noCorners; i++) {
    for(MInt dim = 0; dim < nDim; dim++) {
      corner[dim] = m_solver->c_coordinate(cellId, dim) + cornerIndices[i][dim] * cellHalfLength;
    }
    IF_CONSTEXPR(nDim == 2) {
      if((MBool)m_solver->m_geometry->pointIsInside(corner)) {
        inside = false; // pointIsInside == true if Point is outside fluid domain
      }
    }
    else {
      if((MBool)m_solver->m_geometry->pointIsInside2(corner)) {
        inside = false; // pointIsInside == true if Point is outside fluid domain
      }
    }
  }

  return inside;
}

template <MInt nDim, class SysEqn>
MBool FvBndryCndXD<nDim, SysEqn>::checkOutside(MInt cellId) {
  TRACE();
  static constexpr MInt cornerIndices[8][3] = {{-1, -1, -1}, {1, -1, -1}, {-1, 1, -1}, {1, 1, -1},
                                               {-1, -1, 1},  {1, -1, 1},  {-1, 1, 1},  {1, 1, 1}};
  MFloat corner[3] = {0, 0, 0};
  MBool outside = true;
  MFloat cellHalfLength = F1B2 * m_solver->c_cellLengthAtCell(cellId);

  for(MInt i = 0; i < m_noCorners; i++) {
    for(MInt dim = 0; dim < nDim; dim++) {
      corner[dim] = m_solver->c_coordinate(cellId, dim) + cornerIndices[i][dim] * cellHalfLength;
    }
    IF_CONSTEXPR(nDim == 2) {
      if(!m_solver->m_geometry->pointIsInside(corner)) {
        outside = false; // pointIsInside == true if Point is outside fluid domain
      }
    }
    else {
      if(!m_solver->m_geometry->pointIsInside2(corner)) {
        outside = false; // pointIsInside == true if Point is outside fluid domain
      }
    }
  }
  return outside;
}

template <MInt nDim, class SysEqn>
MBool FvBndryCndXD<nDim, SysEqn>::checkOutside(const MFloat* coords, const MInt level) {
  TRACE();
  static constexpr MInt cornerIndices[8][3] = {{-1, -1, -1}, {1, -1, -1}, {-1, 1, -1}, {1, 1, -1},
                                               {-1, -1, 1},  {1, -1, 1},  {-1, 1, 1},  {1, 1, 1}};
  MFloat corner[3] = {0, 0, 0};
  MBool outside = true;
  MFloat cellHalfLength = F1B2 * m_solver->c_cellLengthAtLevel(level);

  for(MInt i = 0; i < m_noCorners; i++) {
    for(MInt dim = 0; dim < nDim; dim++) {
      corner[dim] = coords[dim] + cornerIndices[i][dim] * cellHalfLength;
    }
    IF_CONSTEXPR(nDim == 2) {
      if(!m_solver->m_geometry->pointIsInside(corner)) {
        outside = false; // pointIsInside == true if Point is outside fluid domain
      }
    }
    else {
      if(!m_solver->m_geometry->pointIsInside2(corner)) {
        outside = false; // pointIsInside == true if Point is outside fluid domain
      }
    }
  }
  return outside;
}


/**
 * \fn void FvBndryCndXD<nDim, SysEqn>::computeCutPoints()
 * \brief computes the cut points where a boundary cell intersects with the geometry
 * computes the following boundary cell member variables:
 *  - m_srfcs->m_bndryCndId (the one with the smallest Id of all intersecting elements)
 *  - m_srfcs->m_noCutPoints
 *  - m_srfcs->m_cutCoordinates
 *
 * \author Daniel Hartmann, 22.12.2006, Claudia Guenther 08/2013, Sohel Herff 2016
 *
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::computeCutPoints() {
  TRACE();

  /*! \page propertiesFV
    \section bndryRfnJump
    <code>void FvBndryCndXD::computeCutPoints</code>\n
    default = <code>0</code>\n \n
    This trigger enables a cut point correction for grid refinement jumps along boundaries.
    Split cells and multiple ghost cells are not supported.
    Possible values are:
    <ul>
    <li>0: deactivated</li>
    <li>1: activated</li>
    </ul>
    Keywords: <i>CUT_POINTS, BOUNDARY_REFINEMENT</i>
  */

  MBool bndryRfnJump = false;
  bndryRfnJump = Context::getSolverProperty<MBool>("bndryRfnJump", m_solverId, AT_, &bndryRfnJump);

  const MBool redirect = true;
  if(redirect && !bndryRfnJump) {
    m_cutCandidates.clear();
    m_cutCandidates.reserve((signed)m_bndryCells->size());


    for(MInt bndryId = 0; bndryId < (signed)m_bndryCells->size(); bndryId++) {
      const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
      ASSERT((signed)m_cutCandidates.size() == bndryId, "");
      m_cutCandidates.emplace_back();
      m_cutCandidates[bndryId].cellId = cellId;
      m_solver->assertValidGridCellId(cellId);
    }

    ASSERT((signed)m_cutCandidates.size() == (signed)m_bndryCells->size(), "");

    m_noBndryCndIds = 0;
    m_noCutOffBndryCndIds = 0;

    m_geometryIntersection->computeCutPointsFromSTL(m_cutCandidates);

    // copy to bndrycnd-data

    for(MInt cndt = 0; cndt < (signed)m_cutCandidates.size(); cndt++) {
      const MInt bndryCndId = m_cutCandidates[cndt].associatedBodyIds[0];

      if(bndryCndId > 9999999) {
        m_bndryCells->a[cndt].m_srfcs[0]->m_bndryCndId = 9999999;
        m_bndryCells->a[cndt].m_srfcs[0]->m_noCutPoints = 0;
        ASSERT(m_cutCandidates[cndt].noCutPoints == 0, "");
        continue;
      }

      // check if its a new bndryCndId:
      MBool newBndryCnd = true;
      for(MInt j = 0; j < m_noBndryCndIds; j++) {
        if(m_bndryCndIds[j] == bndryCndId) {
          newBndryCnd = false;
          break;
        }
      }
      if(newBndryCnd) {
        m_bndryCndIds[m_noBndryCndIds] = bndryCndId;
        m_noBndryCndIds++;
      }

      const MInt noCutPoints = m_cutCandidates[cndt].noCutPoints;
      m_bndryCells->a[cndt].m_srfcs[0]->m_noCutPoints = noCutPoints;
      IF_CONSTEXPR(nDim == 2) { ASSERT(noCutPoints <= 2, ""); }

      m_bndryCells->a[cndt].m_srfcs[0]->m_bndryCndId = bndryCndId;

      for(MInt cutPoint = 0; cutPoint < noCutPoints; cutPoint++) {
        m_bndryCells->a[cndt].m_srfcs[0]->m_cutEdge[cutPoint] = m_cutCandidates[cndt].cutEdges[cutPoint];
        m_bndryCells->a[cndt].m_srfcs[0]->m_bodyId[cutPoint] = m_cutCandidates[cndt].cutBodyIds[cutPoint];
        for(MInt i = 0; i < nDim; i++) {
          m_bndryCells->a[cndt].m_srfcs[0]->m_cutCoordinates[cutPoint][i] =
              m_cutCandidates[cndt].cutPoints[cutPoint][i];
        }
      }
    }

    if(m_solver->m_geometry->m_parallelGeometry) {
      checkCutPointsValidityParGeom();
    } else {
      checkCutPointsValidity();
    }

    // sort m_bndryCndIds for multiple stg BC to prevent MPI error
    if(m_solver->m_zonal) {
      ScratchSpace<MFloat> sorting(m_noBndryCndIds, "sorting", FUN_);
      vector<int> sortingIndex(m_noBndryCndIds);
      for(MInt i = 0; i < m_noBndryCndIds; i++) {
        sorting[i] = m_bndryCndIds[i];
      }
      int x = 0;
      std::iota(sortingIndex.begin(), sortingIndex.end(), x++); // Initializing
      sort(sortingIndex.begin(), sortingIndex.end(), [&](int i, int j) { return sorting[i] < sorting[j]; });

      for(MInt bcId = 0; bcId < m_noBndryCndIds; bcId++) {
        m_bndryCndIds[bcId] = sorting[sortingIndex[bcId]];
      }
    }

    return;
  }

  const MInt DOFStencil[12] = {1, 1, 0, 0, 1, 1, 0, 0, 2, 2, 2, 2};
  const MFloat signStencil[8][3] = {{-F1, -F1, -F1}, {F1, -F1, -F1}, {-F1, F1, -F1}, {F1, F1, -F1},
                                    {-F1, -F1, F1},  {F1, -F1, F1},  {-F1, F1, F1},  {F1, F1, F1}};

  const MInt nodeStencil[2][12] = {{0, 1, 0, 2, 4, 5, 4, 6, 0, 1, 2, 3}, {2, 3, 1, 3, 6, 7, 5, 7, 4, 5, 6, 7}};
  const MInt noCells = m_bndryCells->size();
  const MFloat epsilon = 0.00000000001;
  const MInt maxNoCutPointsPerEdge = 10;
  MFloatScratchSpace a(nDim, AT_, "a_scratch");
  MFloatScratchSpace b(nDim, AT_, "b_scratch");
  MFloatScratchSpace c(nDim, AT_, "c_scratch");
  MFloatScratchSpace d(nDim, AT_, "d_scratch");
  MFloatScratchSpace e(nDim, AT_, "e_scratch");
  MFloatScratchSpace pP(nDim, AT_, "pP_scratch");
  MFloat target[6] = {0, 0, 0, 0, 0, 0};
  MFloatScratchSpace cutPointsEdge(maxNoCutPointsPerEdge, nDim, AT_, "cutPointsEdge");
  MFloatScratchSpace corners(m_noCorners, nDim, AT_, "corners");
  MFloatScratchSpace center(nDim, AT_, "center");
  //--- end of initialization

  m_noBndryCndIds = 0;
  m_noCutOffBndryCndIds = 0;

  // first loop over all bndry cells
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints = 0;
    m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId = 9999999;

    if(m_solver->c_noChildren(cellId) > 0) continue;

    MFloat cellHalfLength = F1B2 * m_solver->c_cellLengthAtCell(cellId);

    // compute cell corners -> will be used for cut point computation
    for(MInt i = 0; i < nDim; i++) {
      center[i] = m_solver->a_coordinate(cellId, i);
    }
    for(MInt n = 0; n < m_noCorners; n++) {
      for(MInt i = 0; i < nDim; i++) {
        corners(n, i) = center[i] + signStencil[n][i] * cellHalfLength;
      }
    }

    // Define corners of current cell in target
    for(MInt i = 0; i < nDim; i++) {
      target[i] = center[i] - cellHalfLength * 1.05;
      target[i + nDim] = center[i] + cellHalfLength * 1.05;
    }
    MFloat eps = m_solver->c_cellLengthAtCell(cellId) / 10000000.0;

    // get all triangles in currentCell (target)
    std::vector<MInt> nodeList;
    if(m_gridCutTest == "SAT") {
      m_solver->m_geometry->getIntersectionElements(target, nodeList, cellHalfLength,
                                                    &m_solver->a_coordinate(cellId, 0));
    } else {
      m_solver->m_geometry->getIntersectionElements(target, nodeList);
    }

    // loop over all edges
    for(MInt edge = 0; edge < m_noEdges; edge++) {
      const MInt edgeDOF = DOFStencil[edge]; // edge's degree of freedom

      MInt noCutPointsEdge = 0;
      MBool edgeCut = false;

      // compute end points of edge
      for(MInt i = 0; i < nDim; i++) {
        d[i] = corners(nodeStencil[0][edge], i);
        e[i] = corners(nodeStencil[1][edge], i);
      }

      // check for edge-triangle intersection
      for(MInt n = 0; n < (signed)nodeList.size(); n++) {
        MBool cutsEdge = false;
        // const MInt bndryCndId = m_solver->m_geometry->elements[nodeList[n]].m_bndCndId;

        IF_CONSTEXPR(nDim == 3) {
          const MInt spaceId = (edgeDOF + 1) % nDim;
          const MInt spaceId1 = (edgeDOF + 2) % nDim;
          const MInt spaceId2 = edgeDOF;
          // find out if element cuts edge; if yes, compute cut point -> 3D part
          MFloat p = F0;
          MFloat q = F0;
          for(MInt k = 0; k < nDim; k++) {
            a[k] = m_solver->m_geometry->elements[nodeList[n]].m_vertices[0][k];
            b[k] = m_solver->m_geometry->elements[nodeList[n]].m_vertices[1][k];
            c[k] = m_solver->m_geometry->elements[nodeList[n]].m_vertices[2][k];
          }
          if(approx(a[spaceId1], b[spaceId1], MFloatEps) && !approx(a[spaceId1], c[spaceId1], MFloatEps)) {
            // aspaceId != bspaceId, otherwise a and b would be the same point
            q = (d[spaceId1] - a[spaceId1]) / (c[spaceId1] - a[spaceId1]);
            p = (d[spaceId] - a[spaceId] - q * (c[spaceId] - a[spaceId])) / (b[spaceId] - a[spaceId]);
          } else {
            if(!approx(a[spaceId1], b[spaceId1], MFloatEps) && approx(a[spaceId1], c[spaceId1], MFloatEps)) {
              // aspaceId != cspaceId, otherwise a and c would be the same point
              p = (d[spaceId1] - a[spaceId1]) / (b[spaceId1] - a[spaceId1]);
              q = (d[spaceId] - a[spaceId] - p * (b[spaceId] - a[spaceId])) / (c[spaceId] - a[spaceId]);
            } else {
              if(approx(a[spaceId], b[spaceId], MFloatEps) && !approx(a[spaceId], c[spaceId], MFloatEps)) {
                // aspaceId1 != bspaceId1, otherwise a and b would be the same point
                q = (d[spaceId] - a[spaceId]) / (c[spaceId] - a[spaceId]);
                p = (d[spaceId1] - a[spaceId1] - q * (c[spaceId1] - a[spaceId1])) / (b[spaceId1] - a[spaceId1]);
              } else {
                if(!approx(a[spaceId], b[spaceId], MFloatEps) && approx(a[spaceId], c[spaceId], MFloatEps)) {
                  // aspaceId1 != cspaceId1, otherwise a and c would be the same point
                  p = (d[spaceId] - a[spaceId]) / (b[spaceId] - a[spaceId]);
                  q = (d[spaceId1] - a[spaceId1] - p * (b[spaceId1] - a[spaceId1])) / (c[spaceId1] - a[spaceId1]);
                } else {
                  // aspaceId1 != bspaceId1 && aspaceId1 != cspaceId1 && aspaceId != bspaceId && aspaceId != cspaceId
                  q = ((d[spaceId1] - a[spaceId1]) * (b[spaceId] - a[spaceId])
                       - (b[spaceId1] - a[spaceId1]) * (d[spaceId] - a[spaceId]))
                      / ((c[spaceId1] - a[spaceId1]) * (b[spaceId] - a[spaceId])
                         - (b[spaceId1] - a[spaceId1]) * (c[spaceId] - a[spaceId]));
                  p = (d[spaceId] - a[spaceId] - q * (c[spaceId] - a[spaceId])) / (b[spaceId] - a[spaceId]);
                }
              }
            }
          }


          if(p * q >= 0 || p * q < 0) {
            // compute s
            MFloat gamma = a[spaceId2] + p * (b[spaceId2] - a[spaceId2]) + q * (c[spaceId2] - a[spaceId2]);
            MFloat s = (gamma - d[spaceId2]) / (e[spaceId2] - d[spaceId2]);

            if(s < -epsilon || s > F1 + epsilon || p < -epsilon || q < -epsilon || (p + q) > F1 + epsilon) {
            } else {
              cutsEdge = true;
              // cut point pP
              if(noCutPointsEdge < 10) {
                for(MInt k = 0; k < nDim; k++) {
                  pP[k] = d[k] + s * (e[k] - d[k]);
                  cutPointsEdge(noCutPointsEdge, k) = pP[k];
                }
              } else {
                mTerm(1, AT_, " Too many cut points on edge...");
              }
            }
          }
        }
        else { // 2D code
          if(m_solver->m_geometry->edgeTriangleIntersection(m_solver->m_geometry->elements[nodeList[n]].m_vertices[0],
                                                            m_solver->m_geometry->elements[nodeList[n]].m_vertices[1],
                                                            0, d.getPointer(), e.getPointer())) {
            for(MInt k = 0; k < nDim; k++) {
              a[k] = m_solver->m_geometry->elements[nodeList[n]].m_vertices[0][k];
              b[k] = m_solver->m_geometry->elements[nodeList[n]].m_vertices[1][k];
            }

            MFloat gamma = (b[0] - a[0]) * (d[1] - e[1]) - (d[0] - e[0]) * (b[1] - a[1]);
            if(ABS(gamma) < 0.0000000000001) continue;
            MFloat s1 = ((d[0] - e[0]) * (a[1] - d[1]) - (d[1] - e[1]) * (a[0] - d[0])) / gamma;
            MFloat s2 = ((b[0] - a[0]) * (d[1] - a[1]) - (d[0] - a[0]) * (b[1] - a[1])) / gamma;

            cutsEdge = true;

            // cut point pP
            if(noCutPointsEdge < 10) {
              for(MInt k = 0; k < nDim; k++) {
                if(s1 * s1 < s2 * s2) {
                  pP[k] = d[k] + s2 * (e[k] - d[k]);
                } else {
                  pP[k] = a[k] + s1 * (b[k] - a[k]);
                }
                cutPointsEdge(noCutPointsEdge, k) = pP[k];
              }
            } else {
              mTerm(1, AT_, " Too many cut points on edge...");
            }
          }
        }

        if(cutsEdge) {
          // store cut point
          if(m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints < m_noEdges) {
            // set boundary condition (the one with the lowest Id
            if(m_solver->m_geometry->elements[nodeList[n]].m_bndCndId
               < m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId) {
              m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId =
                  m_solver->m_geometry->elements[nodeList[n]].m_bndCndId;
              MBool newBndryCnd = true;
              for(MInt j = 0; j < m_noBndryCndIds; j++) {
                if(m_bndryCndIds[j] == m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId) {
                  newBndryCnd = false;
                  break;
                }
              }
              if(newBndryCnd) {
                m_bndryCndIds[m_noBndryCndIds] = m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
                if(m_noBndryCndIds < m_maxNoBndryCndIds) {
                  m_noBndryCndIds++;
                } else {
                  mTerm(1, AT_, "Too many different boundary conditions...");
                }
              }
            }

            // if this edge has already one cut point, check if the new cut point is a different one
            if(edgeCut) {
              // if the cut point is identical to onother one, special treatment is needed

              MBool newCutPoint = true;
              for(MInt i = 0; i < noCutPointsEdge; i++) {
                MBool equal = (ABS(pP[0] - cutPointsEdge(i, 0)) < eps && ABS(pP[1] - cutPointsEdge(i, 1)) < eps);
                IF_CONSTEXPR(nDim == 3) equal = (equal && (ABS(pP[2] - cutPointsEdge(i, 2)) < eps));
                if(equal) {
                  newCutPoint = false;
                  break;
                }
              }

              if(newCutPoint) {
                m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints--;
                m_log << "removing two cut points, cell " << cellId << " edge " << edge << endl;
                m_log << m_solver->a_coordinate(cellId, 0) << " " << m_solver->a_coordinate(cellId, 1) << " ";
                IF_CONSTEXPR(nDim == 3) m_log << m_solver->a_coordinate(cellId, 2) << endl;
                edgeCut = false;
                noCutPointsEdge++;
              } else {
                // coinciding cut points
                // ignoring one cut point
              }
            } else {
              // check, if cut point is really new!
              MBool newCutPoint = true;
              for(MInt i = 0; i < noCutPointsEdge; i++) {
                MBool equal = (ABS(pP[0] - cutPointsEdge(i, 0)) <= eps && ABS(pP[1] - cutPointsEdge(i, 1)) <= eps);
                IF_CONSTEXPR(nDim == 3) equal = (equal && (ABS(pP[2] - cutPointsEdge(i, 2)) <= eps));
                if(equal) {
                  newCutPoint = false;
                }
              }
              if(newCutPoint) {
                edgeCut = true;
                // store cut points in the data structure
                MInt cutPointNo = m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
                m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cutPointNo] = edge;
                m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[cutPointNo] = 0; // bndryCndId;
                for(MInt i = 0; i < nDim; i++) {
                  m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPointNo][i] = pP[i];
                }
                m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints++;
                noCutPointsEdge++;
              }
            }
          } else {
            cerr << "** Warning fvbndrycndxd: " << endl;
            cerr << "cell " << cellId << endl;
            cerr << " -> Boundary cell " << bndryId << " has more than " << m_noEdges << " cut points" << endl;
            cerr << " -> Additional cut points are neglected" << endl;
            cerr << cellId << " " << m_solver->a_coordinate(cellId, 0) << " " << m_solver->a_coordinate(cellId, 1)
                 << " ";
            IF_CONSTEXPR(nDim == 3) cerr << m_solver->a_coordinate(cellId, 2) << " ";
            cerr << m_solver->a_level(cellId) << endl;
            mTerm(1, AT_, "Boundary cell has more than m_noEdges cut points");
          }
        }
      }
    }
  } // end of first loop over all bndry cells

  if(!bndryRfnJump) {
    if(m_solver->m_geometry->m_parallelGeometry) {
      checkCutPointsValidityParGeom();
    } else {
      checkCutPointsValidity();
    }

    IF_CONSTEXPR(nDim == 2) {
      // cells should not have more than two cut points in 2D without special treatment
      for(MInt bndryId = noCells - 1; bndryId > -1; bndryId--) {
        MInt cellId = m_bndryCells->a[bndryId].m_cellId;

        if(m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints > 2) {
          cerr << "** Fatal error fvbndrycndxd: " << endl;
          cerr << " -> 2D Boundary cell " << bndryId << "(" << cellId << ") has more than 2 cut points" << endl;
          cerr << m_solver->a_coordinate(cellId, 0) << " " << m_solver->a_coordinate(cellId, 1) << endl;
          for(MInt cp = 0; cp < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cp++) {
            cerr << m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp][0] << " "
                 << m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp][1] << endl;
          }
          mTerm(1, AT_, "Boundary cell has more than 2 cut points");
        }
      }
    }
    return;
  }


  ASSERT(bndryRfnJump, "");

  // m_bndryRfnJumpInformation initiation
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] = -1;
    m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 1] = -1;
    m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 2] = -1;
    m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 3] = -1;
  }

  MBool newCutPointAdjustment = false; // true;

  m_log << "Boundary refinement jump method is active" << endl;
  m_log << "WARNING: Make sure you have correctly activated the halo cells in cartesiangrid.cpp; it is wrong on "
           "default because otherwise a lot of testcases 'break'."
        << endl;
  if(domainId() == 0) {
    cerr << "Boundary refinement jump method is active" << endl;
    cerr << "Make sure you have correctly activated the halo cells in cartesiangrid.cpp; it is wrong on default "
            "because otherwise a lot of testcases 'break'."
         << endl;
  }
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    MInt cellId = m_bndryCells->a[bndryId].m_cellId;

    if(m_solver->c_noChildren(cellId) > 0) continue;

    // halo cells can't be deactivated even though an exchange from window to halo cells is used to transfer the correct
    // cut points if(m_solver->a_isHalo(cellId)) continue;

    for(MInt direction = 0; direction < m_noDirs; direction++) {
      MBool problemCell = false;

      if(m_solver->a_hasNeighbor(cellId, direction) == 0) {
        MInt parentId = m_solver->c_parentId(cellId);
        if(parentId > -1) {
          if(m_solver->a_hasNeighbor(parentId, direction) == 1) {
            problemCell = true;
          }
        }
      }

      // problemCells are all fine bndryCells at the leveljump

      if(m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints == 0 && direction == 5 && problemCell == 0
         && m_solver->a_bndryId(cellId) != -5) {
        m_solver->a_bndryId(cellId) = -5;
        if(!checkInside(cellId)) {
          m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = false;
          m_solver->a_hasProperty(cellId, SolverCell::IsInvalid) = true;
        }
        cerr << "cell activation/deactivation in m1 loop; isonmg and isinvalid: "
             << m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) << " "
             << m_solver->a_hasProperty(cellId, SolverCell::IsInvalid) << " cell id: " << cellId << endl;
      }

      // loop over all bndryCells with leveljumps
      if(problemCell == true) {
        MInt parentId = m_solver->c_parentId(cellId);
        MInt nghbrId = m_solver->c_neighborId(parentId, direction);
        MInt nghbrbndryId = -1;
        MFloat cellHalfLengthParent = F1B2 * m_solver->c_cellLengthAtCell(parentId);
        MFloatScratchSpace cornersParent(m_noCorners, nDim, AT_, "corners");
        MFloatScratchSpace centerParent(nDim, AT_, "center");

        MInt noCutPoints1 = m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
        if(noCutPoints1 == 0) {
          // cerr << "no cut points on this cell after problem cell was found" << endl;
        }
        nghbrbndryId = m_solver->a_bndryId(nghbrId);
        if(nghbrbndryId == -1) {
          continue;
        }
        MInt noCutPointsNeighbor = m_bndryCells->a[nghbrbndryId].m_srfcs[0]->m_noCutPoints;
        if(noCutPointsNeighbor == 0) continue;

        for(MInt i = 0; i < nDim; i++) {
          centerParent[i] = m_solver->a_coordinate(parentId, i);
        }
        for(MInt n = 0; n < m_noCorners; n++) {
          for(MInt i = 0; i < nDim; i++) {
            cornersParent(n, i) = centerParent[i] + signStencil[n][i] * cellHalfLengthParent;
          }
        }

        MFloat cellHalfLengthNeighbor = F1B2 * m_solver->c_cellLengthAtCell(nghbrId);
        MFloatScratchSpace cornersNeighbor(m_noCorners, nDim, AT_, "corners");
        MFloatScratchSpace centerNeighbor(nDim, AT_, "center");

        for(MInt i = 0; i < nDim; i++) {
          centerNeighbor[i] = m_solver->a_coordinate(nghbrId, i);
        }
        for(MInt n = 0; n < m_noCorners; n++) {
          for(MInt i = 0; i < nDim; i++) {
            cornersNeighbor(n, i) = centerNeighbor[i] + signStencil[n][i] * cellHalfLengthNeighbor;
          }
        }

        MFloat cellHalfLengthCell = F1B2 * m_solver->c_cellLengthAtCell(cellId);
        MFloatScratchSpace cornersCell(m_noCorners, nDim, AT_, "corners");
        MFloatScratchSpace centerCell(nDim, AT_, "center");


        for(MInt i = 0; i < nDim; i++) {
          centerCell[i] = m_solver->a_coordinate(cellId, i);
        }
        for(MInt n = 0; n < m_noCorners; n++) {
          for(MInt i = 0; i < nDim; i++) {
            cornersCell(n, i) = centerCell[i] + signStencil[n][i] * cellHalfLengthCell;
          }
        }

        const MInt cornerDirectionStencil[8][3] = {{0, 2, 4}, {1, 2, 4}, {0, 3, 4}, {1, 3, 4},
                                                   {0, 2, 5}, {1, 2, 5}, {0, 3, 5}, {1, 3, 5}};

        // maybe change eps to be dependend on cell length
        const MFloat eps = 0.0000001;
        MBool directionMatchesCorner = false;
        MInt cornerId = -1;
        for(MInt n = 0; n < m_noCorners; n++) {
          if(abs(cornersParent(n, 0) - cornersCell(n, 0)) < eps && abs(cornersParent(n, 1) - cornersCell(n, 1)) < eps
             && abs(cornersParent(n, 2) - cornersCell(n, 2)) < eps) {
            cornerId = n;
          }
        }
        for(MInt i = 0; i < 3; i++) {
          if(cornerDirectionStencil[cornerId][i] == direction) {
            directionMatchesCorner = true;
          }
        }

        if(directionMatchesCorner == false) {
          cerr << "Direction does not match corner1111; this ERROR should not occur. Check your grid." << endl;
          continue;
        }

        MFloatScratchSpace dParent(nDim, AT_, "d_scratch");
        MFloatScratchSpace eParent(nDim, AT_, "e_scratch");
        MFloatScratchSpace dNeighbor(nDim, AT_, "d_scratch");
        MFloatScratchSpace eNeighbor(nDim, AT_, "e_scratch");
        MFloatScratchSpace dCell(nDim, AT_, "d_scratch");
        MFloatScratchSpace eCell(nDim, AT_, "e_scratch");

        for(MInt edge = 0; edge < m_noEdges; edge++) {
          for(MInt i = 0; i < nDim; i++) {
            dParent[i] = cornersParent(nodeStencil[0][edge], i);
            eParent[i] = cornersParent(nodeStencil[1][edge], i);
            dNeighbor[i] = cornersNeighbor(nodeStencil[0][edge], i);
            eNeighbor[i] = cornersNeighbor(nodeStencil[1][edge], i);
            dCell[i] = cornersCell(nodeStencil[0][edge], i);
            eCell[i] = cornersCell(nodeStencil[1][edge], i);
          }
        }
        const MInt directionEdgesStencil[6][4] = {{0, 4, 8, 10},  {1, 5, 9, 11}, {2, 6, 8, 9},
                                                  {3, 7, 10, 11}, {0, 1, 2, 3},  {4, 5, 6, 7}};

        const MInt directionEdgesStencilNeighbor[6][4] = {{1, 5, 9, 11}, {0, 4, 8, 10}, {3, 7, 10, 11},
                                                          {2, 6, 8, 9},  {4, 5, 6, 7},  {0, 1, 2, 3}};
        MInt noEdgesCut = 0;
        MInt edgesCut[2] = {0, 0};
        if(noEdgesCut == 12341234) {
          cerr << edgesCut[1] << endl;
        }
        MInt edgesCutRm[2] = {-1, -1};
        MInt newEdgeCut[2] = {-1, -1};
        MFloat cutPointCoordinatesNeighbor[3][2] = {{0, 0}, {0, 0}, {0, 0}};
        for(MInt i = 0; i < noCutPointsNeighbor; i++) {
          for(MInt j = 0; j < 4; j++) {
            if(m_bndryCells->a[nghbrbndryId].m_srfcs[0]->m_cutEdge[i] == directionEdgesStencilNeighbor[direction][j]) {
              edgesCut[noEdgesCut] = m_bndryCells->a[nghbrbndryId].m_srfcs[0]->m_cutEdge[i];
              for(MInt k = 0; k < 3; k++) {
                cutPointCoordinatesNeighbor[k][noEdgesCut] =
                    m_bndryCells->a[nghbrbndryId].m_srfcs[0]->m_cutCoordinates[i][k];
              }
              noEdgesCut++;
            }
          }
        }

        if(noEdgesCut != 2 && noEdgesCut != 0) {
          cerr << "ERROR: noEdgesCut is not 0 or 2; Check if split cells are occuring." << endl;
        }

        // noEdgesCut has to be equal to 2, otherwise the cell is a split cell and needs special treatment
        if(noEdgesCut == 2) {
          MInt noCutPoints = m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
          if(noCutPoints == 0) {
            cerr << "No cut points on this cell right now" << endl;
          }
          if(noCutPoints == 1) {
            cerr << "There is only 1 cut points in total on this cell: cellId: " << cellId << endl;
          }
          if(noCutPoints == 2) {
            cerr << "There are only 2 cut points in total on this cell: cellId: " << cellId << endl;
          }

          for(MInt i = 0; i < noCutPoints; i++) {
            MBool removed = false;
            for(MInt j = 0; j < 4; j++) {
              if(m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[i]
                 == directionEdgesStencil[direction][j]) {                          // delete cut point
                MInt rmCutEdge = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[i]; // removed cut edge
                for(MInt k = i; k < noCutPoints; k++) {
                  m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[k] =
                      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[k + 1]; // remove cut edge
                  m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[k] =
                      m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[k + 1]; // remove bndryId
                  for(MInt l = 0; l < 3; l++) {
                    m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[k][l] =
                        m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[k + 1][l]; // remove cut point coordinates
                  }
                }

                m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints--; // reduce number of cut points
                noCutPoints--;
                removed = true;
                if(edgesCutRm[0] != -1) {
                  edgesCutRm[1] = rmCutEdge; // safe information about the removed edge
                }
                if(edgesCutRm[0] == -1) {
                  edgesCutRm[0] = rmCutEdge; // safe information about the removed edge
                }
              }
            }
            if(removed == true) i--;
          }

          if(m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints == 0) {
            cerr << "nocutpoints is zero for this cellid even though it should be at least 1: " << cellId << endl;
          }
          MFloat dP[3];
          MFloat cutPointOne[3] = {0, 0, 0};
          MFloat cutPointTwo[3] = {0, 0, 0};
          MFloat edgePointOne[3] = {0, 0, 0};
          MFloat edgePointTwo[3] = {0, 0, 0};
          MInt divisorPosition = -1;
          MFloat lineOne[3] = {0, 0, 0};
          MFloat lineTwo[3] = {0, 0, 0};
          MFloat cutPoint[3] = {0, 0, 0};
          MFloat divisor = 0;
          MInt noNewCutPoints = 0;
          for(MInt i = 0; i < 3; i++) {
            cutPointOne[i] = cutPointCoordinatesNeighbor[i][0];
            cutPointTwo[i] = cutPointCoordinatesNeighbor[i][1];
          }
          for(MInt i = 0; i < 4; i++) {
            MBool newCutPoint = false;
            MInt edge = directionEdgesStencil[direction][i];
            for(MInt j = 0; j < 3; j++) {
              edgePointOne[j] = cornersCell(nodeStencil[0][edge], j);
              edgePointTwo[j] = cornersCell(nodeStencil[1][edge], j);
            }

            MBool zero = false;
            for(MInt l = 0; l < 3; l++) {
              for(MInt k = 0; k < 3; k++) {
                if(l == k) continue;
                if(zero == true) continue;
                if(abs(edgePointOne[l] - 0.0) < eps && abs(edgePointTwo[l] - 0.0) < eps
                   && abs(edgePointOne[k] - edgePointTwo[k]) < eps
                   && (!(abs(edgePointOne[k] - 0.0) < eps) || !(abs(edgePointTwo[k] - 0.0) < eps))) {
                  zero = true; // special treatment for cells that have coordinates close or equal to zero because
                               // otherwise this can cause division by 0
                  divisorPosition = k;
                }
              }
            }

            for(MInt l = 0; l < 3; l++) {
              for(MInt k = 0; k < 3; k++) {
                if(l == k) continue;
                if(zero == true) continue;
                if(abs(edgePointOne[l] - 0.0) < eps && abs(edgePointTwo[l] - 0.0) < eps
                   && abs(edgePointOne[k] - edgePointTwo[k]) < eps
                   && ((abs(edgePointOne[k] - 0.0) < eps) && (abs(edgePointTwo[k] - 0.0) < eps))) {
                  zero = true;
                  divisorPosition = k;
                }
              }
            }

            if(zero == true) {
              for(MInt l = 0; l < 3; l++) {
                cutPointOne[l] = cutPointOne[l] + 1;
                cutPointTwo[l] = cutPointTwo[l] + 1;
                edgePointOne[l] = edgePointOne[l] + 1;
                edgePointTwo[l] = edgePointTwo[l] + 1;
              }
            }

            lineOne[0] = (cutPointOne[1] * cutPointTwo[2] - cutPointOne[2] * cutPointTwo[1]);
            lineOne[1] = (cutPointOne[2] * cutPointTwo[0] - cutPointOne[0] * cutPointTwo[2]);
            lineOne[2] = (cutPointOne[0] * cutPointTwo[1] - cutPointOne[1] * cutPointTwo[0]);

            lineTwo[0] = (edgePointOne[1] * edgePointTwo[2] - edgePointOne[2] * edgePointTwo[1]);
            lineTwo[1] = (edgePointOne[2] * edgePointTwo[0] - edgePointOne[0] * edgePointTwo[2]);
            lineTwo[2] = (edgePointOne[0] * edgePointTwo[1] - edgePointOne[1] * edgePointTwo[0]);

            cutPoint[0] = (lineOne[1] * lineTwo[2] - lineOne[2] * lineTwo[1]);
            cutPoint[1] = (lineOne[2] * lineTwo[0] - lineOne[0] * lineTwo[2]);
            cutPoint[2] = (lineOne[0] * lineTwo[1] - lineOne[1] * lineTwo[0]);

            dP[0] = cutPoint[0];
            dP[1] = cutPoint[1];
            dP[2] = cutPoint[2];

            if(zero == true) {
              for(MInt l = 0; l < 3; l++) {
                cutPointOne[l] = cutPointOne[l] - 1;
                cutPointTwo[l] = cutPointTwo[l] - 1;
                edgePointTwo[l] = edgePointTwo[l] - 1;
              }
            }

            if(zero == false) {
              for(MInt l = 0; l < 3; l++) {
                if(abs(cutPointOne[l] - cutPointTwo[l]) < eps && abs(cutPointOne[l] - edgePointOne[l]) < eps
                   && abs(cutPointOne[l] - edgePointTwo[l]) < eps && abs(cutPointTwo[l] - edgePointTwo[l]) < eps) {
                  divisorPosition = l;
                }
              }
            }

            if(divisorPosition == -1) {
              cerr << "divisorPosition is -1; This ERROR shouldn't be able to occur. Maybe adjust 'eps'" << endl;
              for(MInt l = 0; l < 3; l++) {
                cerr << l << ": coordinate;"
                     << "cutPointOne: " << cutPointOne[l] << " -- cutPointTwo: " << cutPointTwo[l]
                     << " -- edgePointOne: " << edgePointOne[l] << " -- edgePointTwo: " << edgePointTwo[l] << endl;
              }
              cerr << "direction: " << direction << endl;

              for(MInt n = 0; n < m_noCorners; n++) {
                cerr << "corner: " << n << endl;
                for(MInt l = 0; l < 3; l++) {
                  cerr << "cornersCell: " << cornersCell(n, l) << endl;
                }
              }

              for(MInt n = 0; n < m_noCorners; n++) {
                cerr << "corner neighbor: " << n << endl;
                for(MInt l = 0; l < 3; l++) {
                  cerr << "cornersNeighbor: " << cornersNeighbor(n, l) << endl;
                }
              }

              for(MInt l = 0; l < noCutPointsNeighbor; l++) {
                cerr << "----------------------------" << endl;
                cerr << "neighborcutpointnumber: " << l << endl;
                for(MInt k = 0; k < 3; k++) {
                  cerr << m_bndryCells->a[nghbrbndryId].m_srfcs[0]->m_cutCoordinates[l][k] << endl;
                }
                noEdgesCut++;
              }
            }

            divisor = cutPoint[divisorPosition];
            divisor = divisor / edgePointOne[divisorPosition];

            MBool continueing = false;
            for(MInt k = 0; k < 3; k++) {
              cutPoint[k] = cutPoint[k] / divisor;
              if(std::isnan(cutPoint[k])) {
                cerr << "ERROR: NAN. Divisor: " << divisor << " cut point k: " << cutPoint[k] << " zero: " << zero
                     << endl;
                cerr << "k: " << k << " edgepointone: " << edgePointOne[k] << " edgepointtwo: " << edgePointTwo[k]
                     << endl;
                cerr << "k: " << k << " cutpointone:  " << cutPointOne[k] << " cutpointtwo:  " << cutPointTwo[k]
                     << endl;
                cerr << "divisorPosition: " << divisorPosition << endl;
                cerr << "dP0: " << dP[0] << "dP1: " << dP[1] << "dP2: " << dP[2] << endl;
                cerr << "cut points are probably parallel to the edge. continue";
                continueing = true;
              }
            }
            if(continueing == true) {
              continueing = false;
              continue;
            }

            if(zero == true) {
              for(MInt l = 0; l < 3; l++) {
                cutPoint[l] = cutPoint[l] - 1;
                edgePointOne[l] = edgePointOne[l] - 1;
              }
            }


            if(newCutPointAdjustment == true) {
              for(MInt m = 0; m < 3; m++) {
                if(abs(edgePointOne[m] - cutPoint[m]) < 0.00000001) {
                  cutPoint[m] = edgePointOne[m];
                }
              }
            }

            for(MInt n = 0; n < 3; n++) {
              if(edgePointTwo[n] > edgePointOne[n] && abs(edgePointOne[n] - cutPoint[n]) > epsilon
                 && (edgePointTwo[n] - edgePointOne[n]) > (edgePointTwo[n] - cutPoint[n])
                 && (edgePointTwo[n] - cutPoint[n]) > 0) {
                // cut point is on the edge
                newCutPoint = true;
              }
              if(edgePointTwo[n] < edgePointOne[n] && abs(edgePointOne[n] - cutPoint[n]) > epsilon
                 && (edgePointOne[n] - edgePointTwo[n]) > (edgePointOne[n] - cutPoint[n])
                 && (edgePointOne[n] - cutPoint[n]) > 0) {
                // cut point is on the edge
                newCutPoint = true;
              }
            }

            if(newCutPoint == false) {
              continue;
            }

            if(newEdgeCut[0] != -1) {
              newEdgeCut[1] = edge; // safe information about the new edge that gets cut
            }
            if(newEdgeCut[0] == -1) {
              newEdgeCut[0] = edge; // safe information about the new edge that gets cut
            }
            noNewCutPoints++;
            // store cut points in the data structure
            MInt cutPointNo = m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
            m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cutPointNo] = edge;
            m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[cutPointNo] =
                m_bndryCells->a[nghbrbndryId]
                    .m_srfcs[0]
                    ->m_bodyId[0]; // bndry condition of the cut points is set to be equal to one of the neighbor cut
                                   // point's bndry condition
            for(MInt x = 0; x < nDim; x++) {
              m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPointNo][x] = cutPoint[x];
            }
            m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints++;
          }

          // in certain cases an additional cut point needs to be added
          for(MInt noOldEdge = 0; noOldEdge < 2; noOldEdge++) {
            MInt additionalCutEdge = -1;
            MFloat pointDifference[3] = {0, 0, 0};
            MFloat cutCoordinates[3] = {0, 0, 0};

            const MInt edgeFaceStencil[6][4] = {{8, 10, 0, 4},  {9, 11, 1, 5}, {2, 6, 8, 9},
                                                {3, 7, 10, 11}, {0, 1, 2, 3},  {4, 5, 6, 7}};

            const MInt edgeInCorner[8][3] = {{0, 2, 8}, {1, 2, 9}, {0, 3, 10}, {1, 3, 11},
                                             {4, 6, 8}, {5, 6, 9}, {4, 7, 10}, {5, 7, 11}};

            for(MInt i = 0; i < 8; i++) {
              MInt additionalCutPoint = -1;
              MInt counter = 0;
              for(MInt j = 0; j < 3; j++) {
                // recent change: '&& edgesCutRm[1-noOldEdge]==newedg....'
                if(edgesCutRm[noOldEdge] != newEdgeCut[0] && edgesCutRm[1 - noOldEdge] == newEdgeCut[1]) {
                  if(edgeInCorner[i][j] == edgesCutRm[noOldEdge]) {
                    counter++;
                  }
                  if(edgeInCorner[i][j] == newEdgeCut[0]) {
                    counter++;
                  }
                  if(counter == 2) {
                    additionalCutPoint = 0;
                  }
                }
              }
              counter = 0;
              // recent change: '&& edgesCutRm[1-noOldEdge]==newedg....'
              for(MInt j = 0; j < 3; j++) {
                if(edgesCutRm[noOldEdge] != newEdgeCut[1] && edgesCutRm[1 - noOldEdge] == newEdgeCut[0]
                   && additionalCutPoint == -1) {
                  if(edgeInCorner[i][j] == edgesCutRm[noOldEdge]) {
                    counter++;
                  }
                  if(edgeInCorner[i][j] == newEdgeCut[1]) {
                    counter++;
                  }
                  if(counter == 2) {
                    additionalCutPoint = 1;
                  }
                }
              }
              counter = 0;

              for(MInt j = 0; j < 3; j++) {
                if(edgeInCorner[i][j] != edgesCutRm[noOldEdge]
                   && edgeInCorner[i][j] != newEdgeCut[additionalCutPoint]) {
                  additionalCutEdge = edgeInCorner[i][j];
                }
              }

              if(edgesCutRm[0] == -1 && edgesCutRm[1] == -1 && noOldEdge == 1) {
                for(MInt j = 0; j < 3; j++) {
                  if(additionalCutPoint != -1) {
                    cerr << "ERROR in the additional cut point computation" << endl;
                  }
                  if(edgeInCorner[i][j] == newEdgeCut[0]) {
                    counter++;
                  }
                  if(edgeInCorner[i][j] == newEdgeCut[1]) {
                    counter++;
                  }
                  if(counter == 2) {
                    additionalCutPoint = 2;
                  }
                }
                counter = 0;

                for(MInt j = 0; j < 3; j++) {
                  if(additionalCutPoint == 2 && edgeInCorner[i][j] != newEdgeCut[0]
                     && edgeInCorner[i][j] != newEdgeCut[1]) {
                    additionalCutEdge = edgeInCorner[i][j];
                  }
                }
              }
              if(additionalCutPoint != -1 && edgesCutRm[noOldEdge] != newEdgeCut[0]
                 && edgesCutRm[noOldEdge] != newEdgeCut[1]) {
                // safe information about the corner that is no longer inside/outside of the geometry but was before
                // (for createCutFace)
                m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 1] = i;

                // the additional cut point is currently placed into the middle of the edge
                // this could be improved by calculating a more accurate position
                for(MInt j = 0; j < 3; j++) {
                  edgePointOne[j] = cornersCell(nodeStencil[0][additionalCutEdge], j);
                  edgePointTwo[j] = cornersCell(nodeStencil[1][additionalCutEdge], j);
                  pointDifference[j] = edgePointTwo[j] - edgePointOne[j];
                  pointDifference[j] = pointDifference[j] / 2;
                  cutCoordinates[j] = edgePointOne[j] + pointDifference[j];
                }

                MBool skip = false;
                // if on the edge for the additional cut point a cut point already exists, it needs to be removed
                // instead
                for(MInt x = 0; x < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; x++) {
                  MBool removed = false;

                  if(m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[x] == additionalCutEdge
                     && additionalCutEdge != -1) {
                    // delete cut edge
                    for(MInt k = x; k < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; k++) {
                      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[k] =
                          m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[k + 1];
                      // remove bndry condition
                      m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[k] =
                          m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[k + 1];
                      for(MInt l = 0; l < 3; l++) {
                        m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[k][l] =
                            m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[k + 1][l];
                      }
                    }

                    m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints--;
                    noCutPoints--;
                    removed = true;
                  }
                  if(removed == true) {
                    skip = true;
                    x--;
                  }
                }

                if(skip == false) {
                  noNewCutPoints++;
                  // store cut points in the data structure
                  MInt cutPointNo = m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
                  m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cutPointNo] = additionalCutEdge;
                  m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[cutPointNo] =
                      m_bndryCells->a[nghbrbndryId].m_srfcs[0]->m_bodyId[0];
                  for(MInt x = 0; x < nDim; x++) {
                    m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPointNo][x] = cutCoordinates[x];
                  }
                  m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints++;
                }

                // safe the problem face for createCutFace function
                for(MInt k = 0; k < 6; k++) {
                  counter = 0;
                  MInt problemFace = -1;

                  for(MInt l = 0; l < 4; l++) {
                    if(additionalCutEdge == edgeFaceStencil[k][l]) {
                      counter++;
                    }
                    if(edgesCutRm[0] == newEdgeCut[0] || edgesCutRm[1] == newEdgeCut[0]) {
                      if(newEdgeCut[1] == edgeFaceStencil[k][l]) {
                        counter++;
                      }
                    }
                    if(edgesCutRm[0] == newEdgeCut[1] || edgesCutRm[1] == newEdgeCut[1]) {
                      if(newEdgeCut[0] == edgeFaceStencil[k][l]) {
                        counter++;
                      }
                    }

                    if(counter == 2
                       && m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] != -1) {
                      problemFace = k;
                      m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 2] = k;
                    }

                    if(counter == 2
                       && m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] == -1) {
                      problemFace = k;
                      m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] = k;
                    }
                    if(counter > 2) {
                      cerr << "counter error 1: " << problemFace << endl;
                    }
                  }
                }

                // recently added:
                for(MInt k = 0; k < 6; k++) {
                  counter = 0;
                  MInt problemFace = -1;

                  for(MInt l = 0; l < 4; l++) {
                    if(additionalCutEdge == edgeFaceStencil[k][l]) {
                      counter++;
                    }
                    if(edgesCutRm[0] != newEdgeCut[0] && edgesCutRm[0] != newEdgeCut[1]) {
                      if(edgesCutRm[0] == edgeFaceStencil[k][l]) {
                        counter++;
                      }
                    }
                    if(edgesCutRm[1] != newEdgeCut[0] && edgesCutRm[1] != newEdgeCut[1]) {
                      if(edgesCutRm[1] == edgeFaceStencil[k][l]) {
                        counter++;
                      }
                    }

                    if(counter == 2
                       && m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] != -1) {
                      problemFace = k;
                      m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 2] = k;
                    }

                    if(counter == 2
                       && m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] == -1) {
                      problemFace = k;
                      m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] = k;
                    }

                    if(counter > 2) {
                      cerr << "counter ERROR 1: " << problemFace << endl;
                    }
                  }
                }

                // recently added:
                if(additionalCutPoint == 2) {
                  for(MInt k = 0; k < 6; k++) {
                    counter = 0;
                    MInt problemFace = -1;
                    for(MInt l = 0; l < 4; l++) {
                      if(additionalCutEdge == edgeFaceStencil[k][l]) {
                        counter++;
                      }
                    }
                    for(MInt l = 0; l < 4; l++) {
                      if(counter == 1) {
                        if(newEdgeCut[0] == edgeFaceStencil[k][l]) {
                          counter++;
                        }
                        if(newEdgeCut[1] == edgeFaceStencil[k][l]) {
                          counter++;
                        }
                      }

                      if(counter == 2
                         && m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] != -1
                         && m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 2] != -1) {
                        cerr << "error: third face is found1; first face: "
                             << m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0]
                             << " second face: "
                             << m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 2]
                             << " current face: " << k << " additionalcutedge: " << additionalCutEdge
                             << " this should be ok if the additional cut edge is on the second face AND the current "
                                "face"
                             << endl;
                      }

                      if(counter == 2
                         && m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] != -1) {
                        problemFace = k;
                        m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 2] = k;
                        counter = 0;
                      }

                      if(counter == 2
                         && m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] == -1) {
                        problemFace = k;
                        m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] = k;
                        counter = 0;
                      }

                      if(counter > 2) {
                        cerr << "counter error 1: " << problemFace << endl;
                      }
                    }
                  }
                }

                if(m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] != -1
                   && m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 2] != -1) {
                  if(m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 3] != -1) {
                    cerr << "a second direction is found: " << direction << " currently saved direction: "
                         << m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 3]
                         << "first face: "
                         << m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0]
                         << " second face: "
                         << m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 2]
                         << " corner: "
                         << m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 1] << endl;
                  }
                  m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 3] = direction;
                }

                if(m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0]
                   == m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 2]) {
                  cerr << "ERROR: somehow a face is detected as a problem face twice" << endl;
                }
              }
            }

            if(newEdgeCut[0] == -1 && newEdgeCut[1] == -1) {
              for(MInt i = 0; i < 8; i++) {
                MInt additionalCutPoint = -1;
                MInt counter = 0;

                additionalCutEdge = -1;
                for(MInt j = 0; j < 3; j++) {
                  if(edgeInCorner[i][j] == edgesCutRm[0]) {
                    counter++;
                  }
                  if(edgeInCorner[i][j] == edgesCutRm[1]) {
                    counter++;
                  }
                  if(counter == 2) {
                    additionalCutPoint = 1;
                  }
                }
                counter = 0;
                if(additionalCutPoint == 1 && noOldEdge == 0) {
                  for(MInt j = 0; j < 3; j++) {
                    if(edgeInCorner[i][j] != edgesCutRm[0] && edgeInCorner[i][j] != edgesCutRm[1]) {
                      additionalCutEdge = edgeInCorner[i][j];
                    }
                  }
                  for(MInt j = 0; j < 3; j++) {
                    edgePointOne[j] = cornersCell(nodeStencil[0][additionalCutEdge], j);
                    edgePointTwo[j] = cornersCell(nodeStencil[1][additionalCutEdge], j);
                    pointDifference[j] = edgePointTwo[j] - edgePointOne[j];
                    pointDifference[j] = pointDifference[j] / 2;
                    cutCoordinates[j] = edgePointOne[j] + pointDifference[j];
                  }

                  if(additionalCutPoint != -1) {
                    // safe information about the corner that is no longer inside/outside of the geometry but was before
                    // (for createCutFace)
                    m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 1] = i;
                  }
                  // if the cell used to be cut and isnt cut anymore it is also a problem cell
                  for(MInt k = 0; k < 6; k++) {
                    counter = 0;
                    MInt problemFace = -1;
                    for(MInt l = 0; l < 4; l++) {
                      if(additionalCutEdge == edgeFaceStencil[k][l]) {
                        counter++;
                      }
                    }
                    for(MInt l = 0; l < 4; l++) {
                      if(counter == 1) {
                        if(newEdgeCut[0] == -1 && newEdgeCut[1] == -1) {
                          if(edgesCutRm[1] == edgeFaceStencil[k][l] || edgesCutRm[0] == edgeFaceStencil[k][l]) {
                            counter++;
                          }
                        }
                        if(counter == 2
                           && m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] != -1) {
                          problemFace = k;
                          m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 2] = k;
                        }

                        if(counter == 2
                           && m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] == -1) {
                          problemFace = k;
                          m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] = k;
                        }
                        counter = 1;
                        if(counter != 1) {
                          cerr << problemFace << endl;
                        }
                      }
                    }
                  }
                  if(m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] != -1
                     && m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 2] != -1) {
                    m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 3] = direction;
                  }

                  MBool skip = false;
                  // if on the edge for the additional cut point a cut point already exists, it needs to be removed
                  // instead
                  for(MInt x = 0; x < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; x++) {
                    MBool removed = false;

                    if(m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[x] == additionalCutEdge
                       && additionalCutEdge != -1) {
                      // delete cut edge
                      for(MInt k = x; k < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; k++) {
                        m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[k] =
                            m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[k + 1];
                        // remove bndryId! has to be tested!
                        m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[k] =
                            m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[k + 1];
                        for(MInt l = 0; l < 3; l++) {
                          m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[k][l] =
                              m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[k + 1][l];
                        }
                      }

                      m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints--;
                      noCutPoints--;
                      removed = true;
                    }
                    if(removed == true) {
                      skip = true;
                      // cerr << "test" << endl;
                      x--;
                    }
                  }

                  // safe that the new cuts are creating an edge that used to be inside/outside the geometry and is not
                  // anymore AND that the created face triangles are always outside if they used to be inside before and
                  // vise verca
                  if(skip == false) {
                    noNewCutPoints++;
                    // store cut points in the data structure
                    MInt cutPointNo = m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
                    m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cutPointNo] = additionalCutEdge;
                    //bergangslsung fr das setzen der bndry id
                    m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[cutPointNo] =
                        m_bndryCells->a[nghbrbndryId].m_srfcs[0]->m_bodyId[0];
                    for(MInt x = 0; x < nDim; x++) {
                      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPointNo][x] = cutCoordinates[x];
                    }
                    m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints++;
                  }
                }
              }
            }
          }
        }
        if(m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints == 0
           && m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 1] != -1) {
          MFloat testCorner[3];
          cerr << "bndry cell that is no longer cut is found."
               << " it is checked if it is inside or outside; cellId: " << cellId << endl;
          m_solver->a_bndryId(cellId) = -5;
          for(MInt i = 0; i < 3; i++) {
            testCorner[i] =
                cornersCell(m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 1], i);
          }
          // if the corner used to be inside of the fluid domain (which is checked by pointisinside2 -> true if outside
          // of the fluid domain) the cell is now completely outside of the fluid domain and vise verca
          m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) =
              m_solver->m_geometry->pointIsInside2(testCorner);
          m_solver->a_hasProperty(cellId, SolverCell::IsInvalid) = !m_solver->m_geometry->pointIsInside2(testCorner);
          m_solver->a_bndryId(cellId) = -5;
          m_solver->a_isInterface(cellId) = false;
          deleteBndryCell(bndryId);
          if(bndryId < m_bndryCells->size()) {
            m_solver->a_bndryId(m_bndryCells->a[bndryId].m_cellId) = bndryId;
          }
          if(!m_solver->m_geometry->pointIsInside2(testCorner)) {
          }
        }
        if(edgesCutRm[0] == -1 && edgesCutRm[1] == -1 && newEdgeCut[0] == -1 && newEdgeCut[1] == -1) {
          MFloat testCorner[3];
          MBool testBool = false;
          for(MInt j = 0; j < 4; j++) {
            for(MInt i = 0; i < 3; i++) {
              testCorner[i] = cornersCell(nodeStencil[0][directionEdgesStencil[direction][j]], i);
            }
            if(j > 0 && testBool != m_solver->m_geometry->pointIsInside2(testCorner)) {
              cerr << "ERROR: cell is not cut but it is not completely inside or completely"
                   << " outside of the fluid region" << endl;
            }
            testBool = m_solver->m_geometry->pointIsInside2(testCorner);
          }
          if(m_solver->m_geometry->pointIsInside2(testCorner)) {
            // cerr << "this cell has a surface that needs to have no area: " << cellId << endl;
            // cerr << "nghbr is: " << nghbrId << endl;
            m_solver->m_bndryRfnJumpInformation_[cellId] = nghbrId;
          }
        }
      }
    } // loop over all directions
  }   // loop over all boundary cells
  //##start of the "not yet boundary cell" part
  //
  // part that finds the new boundary cells and safes them:
  for(MInt cell = 0; cell < m_solver->a_noCells(); cell++) {
    if(m_solver->a_bndryId(cell) > -1) {
      continue;
    }

    if(m_solver->c_noChildren(cell) != 0) { // m_solver->c_noChildren(cell)_ > 0)
      continue;
    }

    MInt cellId = cell;
    // don't skip halo cells
    // if(m_solver->a_isHalo(cellId))
    // continue;
    MInt bndryId;
    for(MInt direction = 0; direction < m_noDirs; direction++) {
      MBool problemCell = false;

      if(m_solver->a_hasNeighbor(cellId, direction) == 0) {
        MInt parentId = m_solver->c_parentId(cellId);
        if(parentId > -1) {
          if(m_solver->a_hasNeighbor(parentId, direction) == 1) {
            problemCell = true;
          }
        }
      }

      if(problemCell == true) { // cellId is always the finer cell
        MInt parentId = m_solver->c_parentId(cellId);
        MInt nghbrId = m_solver->c_neighborId(parentId, direction);
        MInt nghbrbndryId = -1;
        MFloat cellHalfLengthParent = F1B2 * m_solver->c_cellLengthAtCell(parentId);
        MFloatScratchSpace cornersParent(m_noCorners, nDim, AT_, "corners");
        MFloatScratchSpace centerParent(nDim, AT_, "center");

        nghbrbndryId = m_solver->a_bndryId(nghbrId);
        if(nghbrbndryId == -1) {
          continue;
        }
        MInt noCutPointsNeighbor = m_bndryCells->a[nghbrbndryId].m_srfcs[0]->m_noCutPoints;
        if(noCutPointsNeighbor == 0) continue;

        for(MInt i = 0; i < nDim; i++)
          centerParent[i] = m_solver->a_coordinate(parentId, i);

        for(MInt n = 0; n < m_noCorners; n++)
          for(MInt i = 0; i < nDim; i++)
            cornersParent(n, i) = centerParent[i] + signStencil[n][i] * cellHalfLengthParent;

        MFloat cellHalfLengthNeighbor = F1B2 * m_solver->c_cellLengthAtCell(nghbrId);
        MFloatScratchSpace cornersNeighbor(m_noCorners, nDim, AT_, "corners");
        MFloatScratchSpace centerNeighbor(nDim, AT_, "center");

        for(MInt i = 0; i < nDim; i++)
          centerNeighbor[i] = m_solver->a_coordinate(nghbrId, i);
        for(MInt n = 0; n < m_noCorners; n++)
          for(MInt i = 0; i < nDim; i++)
            cornersNeighbor(n, i) = centerNeighbor[i] + signStencil[n][i] * cellHalfLengthNeighbor;

        MFloat cellHalfLengthCell = F1B2 * m_solver->c_cellLengthAtCell(cellId);
        MFloatScratchSpace cornersCell(m_noCorners, nDim, AT_, "corners");
        MFloatScratchSpace centerCell(nDim, AT_, "center");

        for(MInt i = 0; i < nDim; i++)
          centerCell[i] = m_solver->a_coordinate(cellId, i);
        for(MInt n = 0; n < m_noCorners; n++)
          for(MInt i = 0; i < nDim; i++)
            cornersCell(n, i) = centerCell[i] + signStencil[n][i] * cellHalfLengthCell;
        const MInt cornerDirectionStencil[8][3] = {{0, 2, 4}, {1, 2, 4}, {0, 3, 4}, {1, 3, 4},
                                                   {0, 2, 5}, {1, 2, 5}, {0, 3, 5}, {1, 3, 5}};
        const MFloat eps = 0.0000001;
        MBool directionMatchesCorner = false;
        MInt cornerId = -1;
        for(MInt n = 0; n < m_noCorners; n++) {
          if(abs(cornersParent(n, 0) - cornersCell(n, 0)) < eps && abs(cornersParent(n, 1) - cornersCell(n, 1)) < eps
             && abs(cornersParent(n, 2) - cornersCell(n, 2)) < eps) {
            cornerId = n;
          }
        }
        for(MInt i = 0; i < 3; i++) {
          if(cornerDirectionStencil[cornerId][i] == direction) {
            directionMatchesCorner = true;
          }
        }
        if(directionMatchesCorner == false) {
          cerr << "direction: " << direction << endl;
          cerr << "direction doesnt match corner! This shouldn't be able to happen."
               << " Check your grid. Corner id: " << cornerId << endl;
          continue;
        }

        MFloatScratchSpace dParent(nDim, AT_, "d_scratch");
        MFloatScratchSpace eParent(nDim, AT_, "e_scratch");
        MFloatScratchSpace dNeighbor(nDim, AT_, "d_scratch");
        MFloatScratchSpace eNeighbor(nDim, AT_, "e_scratch");
        MFloatScratchSpace dCell(nDim, AT_, "d_scratch");
        MFloatScratchSpace eCell(nDim, AT_, "e_scratch");

        for(MInt edge = 0; edge < m_noEdges; edge++) {
          for(MInt i = 0; i < nDim; i++) {
            dParent[i] = cornersParent(nodeStencil[0][edge], i);
            eParent[i] = cornersParent(nodeStencil[1][edge], i);

            dNeighbor[i] = cornersNeighbor(nodeStencil[0][edge], i);
            eNeighbor[i] = cornersNeighbor(nodeStencil[1][edge], i);

            dCell[i] = cornersCell(nodeStencil[0][edge], i);
            eCell[i] = cornersCell(nodeStencil[1][edge], i);
          }
        }
        const MInt directionEdgesStencil[6][4] = {{0, 4, 8, 10},  {1, 5, 9, 11}, {2, 6, 8, 9},
                                                  {3, 7, 10, 11}, {0, 1, 2, 3},  {4, 5, 6, 7}};
        const MInt directionEdgesStencilNeighbor[6][4] = {{1, 5, 9, 11}, {0, 4, 8, 10}, {3, 7, 10, 11},
                                                          {2, 6, 8, 9},  {4, 5, 6, 7},  {0, 1, 2, 3}};
        MInt noEdgesCut = 0;
        MInt newEdgeCut[2] = {-1, -1};
        MFloat cutPointCoordinatesNeighbor[3][2] = {{0, 0}, {0, 0}, {0, 0}};
        for(MInt i = 0; i < noCutPointsNeighbor; i++) {
          for(MInt j = 0; j < 4; j++) {
            if(m_bndryCells->a[nghbrbndryId].m_srfcs[0]->m_cutEdge[i] == directionEdgesStencilNeighbor[direction][j]) {
              for(MInt k = 0; k < 3; k++) {
                cutPointCoordinatesNeighbor[k][noEdgesCut] =
                    m_bndryCells->a[nghbrbndryId].m_srfcs[0]->m_cutCoordinates[i][k];
              }
              noEdgesCut++;
            }
          }
        }
        if(noEdgesCut == 2) {
          // here starts the computation of the new cut points
          MFloat cutPointOne[3] = {0, 0, 0};
          MFloat cutPointTwo[3] = {0, 0, 0};
          MFloat edgePointOne[3] = {0, 0, 0};
          MFloat edgePointTwo[3] = {0, 0, 0};
          MInt divisorPosition = -1;
          MFloat lineOne[3] = {0, 0, 0};
          MFloat lineTwo[3] = {0, 0, 0};
          MFloat cutPoint[3] = {0, 0, 0};
          MFloat divisor = 0;
          MInt noNewCutPoints = 0;
          for(MInt i = 0; i < 3; i++) {
            cutPointOne[i] = cutPointCoordinatesNeighbor[i][0];
            cutPointTwo[i] = cutPointCoordinatesNeighbor[i][1];
          }
          for(MInt i = 0; i < 4; i++) {
            MBool newCutPoint = false;
            MInt edge = directionEdgesStencil[direction][i];
            for(MInt j = 0; j < 3; j++) {
              edgePointOne[j] = cornersCell(nodeStencil[0][edge], j);
              edgePointTwo[j] = cornersCell(nodeStencil[1][edge], j);
            }
            MBool zero = false;
            for(MInt l = 0; l < 3; l++) {
              for(MInt k = 0; k < 3; k++) {
                if(l == k) continue;
                if(zero == true) continue;
                if(abs(edgePointOne[l] - 0.0) < eps && abs(edgePointTwo[l] - 0.0) < eps
                   && abs(edgePointOne[k] - edgePointTwo[k]) < eps
                   && (!(abs(edgePointOne[k] - 0.0) < eps) || !(abs(edgePointTwo[k] - 0.0) < eps))) {
                  zero = true;
                  divisorPosition = k;
                }
              }
            }
            for(MInt l = 0; l < 3; l++) {
              for(MInt k = 0; k < 3; k++) {
                if(l == k) continue;
                if(zero == true) continue;
                if(abs(edgePointOne[l] - 0.0) < eps && abs(edgePointTwo[l] - 0.0) < eps
                   && abs(edgePointOne[k] - edgePointTwo[k]) < eps
                   && ((abs(edgePointOne[k] - 0.0) < eps) && (abs(edgePointTwo[k] - 0.0) < eps))) {
                  zero = true;
                  divisorPosition = k;
                }
              }
            }
            if(zero == true) {
              for(MInt l = 0; l < 3; l++) {
                cutPointOne[l] = cutPointOne[l] + 1;
                cutPointTwo[l] = cutPointTwo[l] + 1;
                edgePointOne[l] = edgePointOne[l] + 1;
                edgePointTwo[l] = edgePointTwo[l] + 1;
              }
            }

            lineOne[0] = (cutPointOne[1] * cutPointTwo[2] - cutPointOne[2] * cutPointTwo[1]);
            lineOne[1] = (cutPointOne[2] * cutPointTwo[0] - cutPointOne[0] * cutPointTwo[2]);
            lineOne[2] = (cutPointOne[0] * cutPointTwo[1] - cutPointOne[1] * cutPointTwo[0]);

            lineTwo[0] = (edgePointOne[1] * edgePointTwo[2] - edgePointOne[2] * edgePointTwo[1]);
            lineTwo[1] = (edgePointOne[2] * edgePointTwo[0] - edgePointOne[0] * edgePointTwo[2]);
            lineTwo[2] = (edgePointOne[0] * edgePointTwo[1] - edgePointOne[1] * edgePointTwo[0]);

            cutPoint[0] = (lineOne[1] * lineTwo[2] - lineOne[2] * lineTwo[1]);
            cutPoint[1] = (lineOne[2] * lineTwo[0] - lineOne[0] * lineTwo[2]);
            cutPoint[2] = (lineOne[0] * lineTwo[1] - lineOne[1] * lineTwo[0]);

            if(zero == true) {
              for(MInt l = 0; l < 3; l++) {
                cutPointOne[l] = cutPointOne[l] - 1;
                cutPointTwo[l] = cutPointTwo[l] - 1;
                edgePointTwo[l] = edgePointTwo[l] - 1;
              }
            }
            if(zero == false) {
              for(MInt l = 0; l < 3; l++) {
                if(abs(cutPointOne[l] - cutPointTwo[l]) < eps && abs(cutPointOne[l] - edgePointOne[l]) < eps
                   && abs(cutPointOne[l] - edgePointTwo[l]) < eps && abs(cutPointTwo[l] - edgePointTwo[l]) < eps) {
                  divisorPosition = l;
                }
              }
            }
            if(divisorPosition == -1) {
              cerr << "divisorPosition,new is -1; this shouldn't be possible" << endl;
              for(MInt l = 0; l < 3; l++) {
                cerr << l << ": coordinate;"
                     << "cutPointOne: " << cutPointOne[l] << " -- cutPointTwo: " << cutPointTwo[l]
                     << " -- edgePointOne: " << edgePointOne[l] << " -- edgePointTwo: " << edgePointTwo[l] << endl;
              }
              cerr << "zero: " << zero << endl;
              cerr << "direction: " << direction << endl;
            }
            divisor = cutPoint[divisorPosition];
            divisor = divisor / edgePointOne[divisorPosition];

            MBool continueing = false;
            for(MInt k = 0; k < 3; k++) {
              cutPoint[k] = cutPoint[k] / divisor;
              if(std::isnan(cutPoint[k])) {
                cerr << "ERROR: NAN. Divisor: " << divisor << " cut point k: " << cutPoint[k] << " zero: " << zero
                     << endl;
                cerr << "k: " << k << " edgepointone: " << edgePointOne[k] << " edgepointtwo: " << edgePointTwo[k]
                     << endl;
                cerr << "k: " << k << " cutpointone:  " << cutPointOne[k] << " cutpointtwo:  " << cutPointTwo[k]
                     << endl;
                cerr << "divisorPosition: " << divisorPosition << endl;
                cerr << "cut points are probably parallel to the edge. continue";
                continueing = true;
              }
            }
            if(continueing == true) {
              continueing = false;
              continue;
            }

            if(zero == true) {
              for(MInt l = 0; l < 3; l++) {
                cutPoint[l] = cutPoint[l] - 1;
                edgePointOne[l] = edgePointOne[l] - 1;
              }
            }
            if(newCutPointAdjustment == true) {
              for(MInt m = 0; m < 3; m++) {
                if(abs(edgePointOne[m] - cutPoint[m]) < 0.00000001) { // TODO labels:FV,toenhance,
                                                                      // why this number, isnt there
                                                                      // some functionwide eps
                  cutPoint[m] = edgePointOne[m];
                }
              }
            }
            for(MInt n = 0; n < 3; n++) {
              if(edgePointTwo[n] > edgePointOne[n] && abs(edgePointOne[n] - cutPoint[n]) > eps
                 && (edgePointTwo[n] - edgePointOne[n]) > (edgePointTwo[n] - cutPoint[n])
                 && (edgePointTwo[n] - cutPoint[n]) > 0) {
                // cerr << "cut point is on the edge" << endl;
                newCutPoint = true;
              }
              if(edgePointTwo[n] < edgePointOne[n] && abs(edgePointOne[n] - cutPoint[n]) > eps
                 && (edgePointOne[n] - edgePointTwo[n]) > (edgePointOne[n] - cutPoint[n])
                 && (edgePointOne[n] - cutPoint[n]) > 0) {
                // cerr << "cut point is on the edge" << endl;
                newCutPoint = true;
              }
            }

            if(newCutPoint == false) {
              continue;
            }
            cerr << "(this is not an error) a non boundary cell with cut points has been found. parentId: " << parentId
                 << " cellId: " << cellId << endl;
            // create a new boundary cell
            bndryId = m_bndryCells->size() - 1;
            if(m_bndryCells->a[bndryId].m_cellId != cellId) {
              cerr << "(this is not an error) creating a new boundary cell; cellId: " << cellId
                   << " bndryCellId: " << m_bndryCells->a[bndryId].m_cellId << endl;
              // increase collector size by one
              MInt size = m_bndryCells->size();
              cerr << size << endl;
              m_bndryCells->resetSize(size + 1);
              bndryId++;

              // set the boundary cell properties of the new boundary cell
              m_solver->a_isInterface(cellId) = true;
              m_solver->a_bndryId(cellId) = bndryId;
              m_bndryCells->a[bndryId].m_cellId = cellId;
              m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = true;
              m_solver->a_hasProperty(cellId, SolverCell::IsInvalid) = false;
              m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] = -1;
              m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 1] = -1;
              m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 2] = -1;
              m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 3] = -1;
            }

            if(m_bndryCells->a[bndryId].m_cellId == cellId) {
              // store the cut point in the new boundary cell
              cerr << "(this is not an error) cut point is saved in the new boundary cell; cellId: " << cellId
                   << " bndryId: " << bndryId << endl;
              if(newEdgeCut[0] != -1) {
                newEdgeCut[1] = edge;
              }
              if(newEdgeCut[0] == -1) {
                newEdgeCut[0] = edge;
              }
              noNewCutPoints++;
              // store cut points in the data structure
              MInt cutPointNo = m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
              m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cutPointNo] = edge;
              // set the bndry cnd
              m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[cutPointNo] =
                  m_bndryCells->a[nghbrbndryId].m_srfcs[0]->m_bodyId[0];
              for(MInt x = 0; x < nDim; x++) {
                m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPointNo][x] = cutPoint[x];
              }
              m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints++;
              m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId =
                  m_bndryCells->a[nghbrbndryId].m_srfcs[0]->m_bndryCndId;
              if(m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints == 2) {
                MInt counter = 0;
                MFloat pointDifference[3] = {0, 0, 0};
                MFloat cutCoordinates[3] = {0, 0, 0};
                const MInt edgeInCorner[8][3] = {{0, 2, 8}, {1, 2, 9}, {0, 3, 10}, {1, 3, 11},
                                                 {4, 6, 8}, {5, 6, 9}, {4, 7, 10}, {5, 7, 11}};
                MInt additionalCutEdge = -1;
                for(MInt x = 0; x < 8; x++) {
                  for(MInt z = 0; z < 3; z++) {
                    if(edgeInCorner[x][z] == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[0]) {
                      counter++;
                    }
                    if(edgeInCorner[x][z] == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[1]) {
                      counter++;
                    }
                  }
                  if(counter == 2) {
                    for(MInt y = 0; y < 3; y++) {
                      if(edgeInCorner[x][y] != m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[0]
                         && edgeInCorner[x][y] != m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[1]) {
                        additionalCutEdge = edgeInCorner[x][y];
                      }
                    }
                  }
                  counter = 0;
                }
                for(MInt j = 0; j < 3; j++) {
                  edgePointOne[j] = cornersCell(nodeStencil[0][additionalCutEdge], j);
                  edgePointTwo[j] = cornersCell(nodeStencil[1][additionalCutEdge], j);
                  pointDifference[j] = edgePointTwo[j] - edgePointOne[j];
                  pointDifference[j] = pointDifference[j] / 2;
                  cutCoordinates[j] = edgePointOne[j] + pointDifference[j];
                }
                // store cut points in the data structure
                MInt cutPointNo3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
                m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cutPointNo3] = additionalCutEdge;
                // set the bndry cnd
                m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[cutPointNo3] =
                    m_bndryCells->a[nghbrbndryId].m_srfcs[0]->m_bodyId[0];
                for(MInt x = 0; x < nDim; x++) {
                  m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPointNo3][x] = cutCoordinates[x];
                }
                m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints++;
              }
              cerr << "(this is not an error) number of cut points (should first be 1 and then 3): "
                   << m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints << endl;
            }
          }

          if(newEdgeCut[0] != -1 && newEdgeCut[1] != -1) {
            bndryId = m_bndryCells->size() - 1;
            MInt additionalCutEdge = -1;
            MFloat pointDifference[3] = {0, 0, 0};
            MFloat cutCoordinates[3] = {0, 0, 0};
            const MInt edgeFaceStencil[6][4] = {{8, 10, 0, 4},  {9, 11, 1, 5}, {2, 6, 8, 9},
                                                {3, 7, 10, 11}, {0, 1, 2, 3},  {4, 5, 6, 7}};
            const MInt edgeInCorner[8][3] = {{0, 2, 8}, {1, 2, 9}, {0, 3, 10}, {1, 3, 11},
                                             {4, 6, 8}, {5, 6, 9}, {4, 7, 10}, {5, 7, 11}};
            for(MInt i = 0; i < 8; i++) {
              MInt additionalCutPoint = -1;
              MInt counter = 0;
              additionalCutEdge = -1;
              for(MInt j = 0; j < 3; j++) {
                if(edgeInCorner[i][j] == newEdgeCut[0]) {
                  counter++;
                }
                if(edgeInCorner[i][j] == newEdgeCut[1]) {
                  counter++;
                }
                if(counter == 2) {
                  additionalCutPoint = 1;
                  // is this correct?
                  m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 1] = i;
                  cerr << i << endl;
                }
              }
              counter = 0;
              if(additionalCutPoint == 1) {
                for(MInt j = 0; j < 3; j++) {
                  if(edgeInCorner[i][j] != newEdgeCut[0] && edgeInCorner[i][j] != newEdgeCut[1]) {
                    additionalCutEdge = edgeInCorner[i][j];
                  }
                }
                for(MInt j = 0; j < 3; j++) {
                  edgePointOne[j] = cornersCell(nodeStencil[0][additionalCutEdge], j);
                  edgePointTwo[j] = cornersCell(nodeStencil[1][additionalCutEdge], j);
                  pointDifference[j] = edgePointTwo[j] - edgePointOne[j];
                  pointDifference[j] = pointDifference[j] / 2;
                  cutCoordinates[j] = edgePointOne[j] + pointDifference[j];
                }
                // if the cell used to be cut and isnt cut anymore it is also a problem cell
                for(MInt k = 0; k < 6; k++) {
                  counter = 0;
                  MInt problemFace = -1;
                  for(MInt l = 0; l < 4; l++) {
                    if(additionalCutEdge == edgeFaceStencil[k][l]) {
                      counter++;
                    }
                  }
                  for(MInt l = 0; l < 4; l++) {
                    if(counter == 1) {
                      if(newEdgeCut[0] != -1 && newEdgeCut[1] != -1) {
                        if(newEdgeCut[1] == edgeFaceStencil[k][l] || newEdgeCut[0] == edgeFaceStencil[k][l]) {
                          counter++;
                        }
                      }
                      if(counter == 2
                         && m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] != -1) {
                        problemFace = k;
                        m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 2] = k;
                      }
                      if(counter == 2
                         && m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] == -1) {
                        problemFace = k;
                        m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] = k;
                      }
                      counter = 1;
                      if(counter != 1) {
                        cerr << problemFace << endl;
                      }
                    }
                  }
                }
                if(m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] != -1
                   && m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 2] != -1) {
                  m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 3] = direction;
                }
                if(m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints == 50) {
                  noNewCutPoints++;
                  // store cut points in the data structure
                  MInt cutPointNo = m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
                  m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cutPointNo] = additionalCutEdge;
                  // set the bndry cnd
                  m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[cutPointNo] =
                      m_bndryCells->a[nghbrbndryId].m_srfcs[0]->m_bodyId[0];
                  for(MInt x = 0; x < nDim; x++) {
                    m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPointNo][x] = cutCoordinates[x];
                  }
                  m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints++;
                }
              }
            } // loop from 0 to 7, might be corners
          }   // newEdgeCut condition
        }     // noEdgesCut == 2 condition
      }       // if problem cell
    }         // loop over direction
  }           // loop over all cells


  checkCutPointsValidity();
  // some not-inside and not-boundary cells in the grid are made inactive.
  // These cells follow from setting ggp_keepOutsideBndryCellChildren = 1
  // during the grid generation. CutOffInterface cells need to be excluded
  // No idea what this -5 code does ... may be bs
  // TODO labels:FV,toenhance additional actually-outside cells should be created on demand during
  // the solver run, then this 'dangerous' loop over all cells is obsolete in
  // the bndrycnd class
  for(MInt cellId = 0; cellId < m_solver->a_noCells(); cellId++) {
    if(m_solver->a_bndryId(cellId) == -1 && !checkInside(cellId)) { //&&
      //!(m_solver->a_isInterface( cellId )
      //&& m_solver->c_noChildren( cellId ) == 0
      //&& isCutOffInterface(cellId))){
      m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = false;
      m_solver->a_hasProperty(cellId, SolverCell::IsInvalid) = true;
    }
    if(m_solver->a_bndryId(cellId) == -5) {
      m_solver->a_bndryId(cellId) = -1;
    }
  }


  //   plotAllCutPoints();
}


/** \brief checks the validity of a boundary cell
 *
 * \author Daniel Hartmann, Claudia Guenther, Andreas Lintermann
 * \date 15.04.2016
 *
 * This was part of the function computeCutPoints() before. Had to be moved
 * out of this function to apply a different handlin for parallel geometries.
 *
 **/
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::checkCutPointsValidity() {
  TRACE();

  const MInt noCells = m_bndryCells->size();
  // boundary cells with not enough cut points should be removed -> important: check, if corresponding cell should also
  // be removed! mark boundary cells with less than 3/2 cut points
  for(MInt bndryId = noCells - 1; bndryId > -1; bndryId--) {
    MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints < nDim) {
#ifndef NDEBUG
      m_log << "cell " << cellId << " on level " << m_solver->a_level(cellId) << " with globalId "
            << m_solver->c_globalId(cellId) << " has less than " << nDim << " cut points! deleting bndryCell! " << endl;
#endif

      m_solver->a_isInterface(cellId) = false;
      m_solver->a_hasProperty(cellId, SolverCell::IsMovingBnd) = false;
      m_solver->a_bndryId(cellId) = -1;
      m_solver->a_bndryId(m_bndryCells->a[bndryId].m_cellId) = -1;
      deleteBndryCell(bndryId);

      // If the deleted bounday cell was not the last cell in m_bndryCells the last cell was moved
      // to the position of the deleted cell and its corresponding bndryId needs to be updated!
      if(bndryId < m_bndryCells->size()) {
        m_solver->a_bndryId(m_bndryCells->a[bndryId].m_cellId) = bndryId;
      }

      // if cell is not located fully in the fluid domain, mark it as inactive
      // do not really delete the cell, as this leas to inconsistencies with the other domains resulting from cell
      // reordering!
      if(!checkInside(cellId)) {
#ifndef NDEBUG
        if(m_solver->c_noChildren(cellId) == 0) {
          cerr << domainId() << ": cell deactivated"
               << ", cellId " << cellId << ", globalId " << m_solver->c_globalId(cellId) << ", level "
               << m_solver->a_level(cellId) << endl;
        }
#endif
        m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = false;
        m_solver->a_hasProperty(cellId, SolverCell::IsInvalid) = true;

        MInt parentId = m_solver->c_parentId(cellId);
        MInt itCnt = 0;
        while(parentId > -1) {
          m_solver->a_hasProperty(parentId, SolverCell::IsOnCurrentMGLevel) = false;
          m_solver->a_hasProperty(parentId, SolverCell::IsInvalid) = true;
          // cerr << domainId() <<": parent " << parentId << " " << m_solver->c_globalId( parentId ) << endl;
          // if ( m_solver->c_parentId( parentId ) == -1 ) cerr << domainId() <<": parent " << parentId << endl;
          parentId = m_solver->c_parentId(parentId);
          itCnt++;
          if(itCnt > m_solver->maxLevel() - m_solver->minLevel()) {
            mTerm(1, AT_, "Invalid parent relations.");
          }
        }
      }
    }
  }
}


/** \brief checks the validity of a boundary cell using parallel geometry
 *
 * \author Andreas Lintermann
 * \date 15.04.2016
 * \todo labels:FV,totest this function is not yet working
 *
 * This function in principal does the same as checkCutPointsValidity(), however,
 * makes use of parallel geometry information.
 *
 **/
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::checkCutPointsValidityParGeom() {
  TRACE();

  // 1. basic init
  const MInt noCells = m_bndryCells->size();
  const MInt* traverseOrder = traverseCorners2D;
  IF_CONSTEXPR(nDim == 3) traverseOrder = traverseCorners3D;

  MInt noCorners = IPOW2(nDim);
  MInt noShares = noCorners - 1;

  MIntScratchSpace sharedCorners(noCorners, noShares, AT_, "sharedCorners");
  for(MInt c = 0; c < noCorners; c++) {
    for(MInt s = 0; s < noShares; s++) {
      IF_CONSTEXPR(nDim == 2) { sharedCorners(c, s) = sharedCornerNeighs2D[c][s]; }
      else {
        sharedCorners(c, s) = sharedCornerNeighs3D[c][s];
      }
    }
  }


  // 2. prepare: how many of the cells that we need to consider are totally outside?
  vector<MInt> missing;

  // 2.1 find first only those that are easily detectable, i.e., cells that have a neighbor which is not an
  //    interface cell. That is, run over all neighbors and check for the property IsInterface.
  //    If a cell has only interface neighbors, it is added to the missing list that is processed in 2.2.
  for(MInt bndryId = noCells - 1; bndryId > -1; bndryId--) {
    if(m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints < nDim) {
      MInt cellId = m_bndryCells->a[bndryId].m_cellId;
      MBool found = false;
      MInt insidePt = -1;

      // search a corner point that is inside for sure
      for(MInt corner = 0; corner < IPOW2(nDim); corner++) {
        for(MInt s = 0; s < noShares; s++) {
          MInt dir = sharedCorners(corner, s);
          if(m_solver->a_hasNeighbor(cellId, dir)
             && !m_solver->a_hasProperty(m_solver->c_neighborId(cellId, dir), SolverCell::IsInterface)) {
            found = true;
            insidePt = corner;
            break;
          }
        }
        if(found) break;
      }

      // we found a corner of the current cell that is definitively inside
      if(found) {
        // perform a check if there is a way to an outside cell, then this cell
        // is not completely located inside
        cout << insidePt << " " << traverseOrder << endl;
      } else {
      }
      /*


      //run over all neighbors
      for(MInt n = 0; n < noNeigh; n++)
        {
          //great we found one
          if(m_solver->a_hasNeighbor(cellId, n) && !m_solver->a_hasProperty( m_solver->c_neighborId(cellId,n) ,
      SolverCell::IsInterface) )
        {
          found = true;
          bndCellIsOutside.insert(pair<MInt,MBool>(cellId,true));
          break;
        }

            if(found)
        break;
          }

      //the cell is either isolated or all neighbors are interface cells
      if(!found)
        missing.push_back(cellId);

      */
    }
  }


  // 2.2 run over the cells that have
  if(!missing.empty()) {
  }

  for(MInt bndryId = noCells - 1; bndryId > -1; bndryId--) {
    MInt cellId = m_bndryCells->a[bndryId].m_cellId;

    if(m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints < nDim) {
#ifndef NDEBUG
      m_log << "cell " << cellId << " on level " << m_solver->a_level(cellId) << " with globalId "
            << m_solver->c_globalId(cellId) << " has less than " << nDim << " cut points! deleting bndryCell! " << endl;
#endif

      m_solver->a_isInterface(cellId) = false;
      m_solver->a_bndryId(cellId) = -1;
      m_solver->a_bndryId(m_bndryCells->a[bndryId].m_cellId) = -1;
      deleteBndryCell(bndryId);

      // If the deleted bounday cell was not the last cell in m_bndryCells the last cell was moved
      // to the position of the deleted cell and its corresponding bndryId needs to be updated!
      if(bndryId < m_bndryCells->size()) {
        m_solver->a_bndryId(m_bndryCells->a[bndryId].m_cellId) = bndryId;
      }

      // if cell is not located fully in the fluid domain, mark it as inactive
      // do not really delete the cell, as this leas to inconsistencies with the other domains resulting from cell
      // reordering!
      if(!checkInside(cellId)) {
#ifndef NDEBUG
        if(m_solver->c_noChildren(cellId) == 0)
          cerr << domainId() << ": cell deactivated"
               << ", cellId " << cellId << ", globalId " << m_solver->c_globalId(cellId) << ", level "
               << m_solver->a_level(cellId) << endl;
#endif

        m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = false;
        m_solver->a_hasProperty(cellId, SolverCell::IsInvalid) = true;

        MInt parentId = m_solver->c_parentId(cellId);
        while(parentId > -1) {
          m_solver->a_hasProperty(parentId, SolverCell::IsOnCurrentMGLevel) = false;
          m_solver->a_hasProperty(parentId, SolverCell::IsInvalid) = true;

          parentId = m_solver->c_parentId(parentId);
        }
      }
    }
  }
}


// required for bndryRfnJumpMethod
// exchange of all window cell cut information to corresponding halo cells
// 30 informations need to be exchanged (noCutPoints(1), cutEdges(6), bodyId(1), cutCoordinates(18),
// m_bndryRfnJumpInformation(4)
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::exchangeComputedCutPoints() {
  TRACE();
  MBool bndryRfnJump = false;
  bndryRfnJump = Context::getSolverProperty<MBool>("bndryRfnJump", m_solverId, AT_, &bndryRfnJump);

  if(bndryRfnJump == 0) {
    return;
  }
  m_log << "processing MInts " << endl;
  MIntScratchSpace idSendRecBuffers(m_solver->a_noCells() * 12, AT_, "idSendRecBuffers");
  idSendRecBuffers.fill(0);

  MInt cnt = 0;
  for(MInt cellId = 0; cellId < m_solver->a_noCells(); cellId++) {
    if(m_solver->a_bndryId(cellId) < 0) {
      continue;
    }
    MInt bndryId = m_solver->a_bndryId(cellId);
    idSendRecBuffers[cellId * 12 + 0] = m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
    idSendRecBuffers[cellId * 12 + 1] = m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[0];
    idSendRecBuffers[cellId * 12 + 2] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[0];
    idSendRecBuffers[cellId * 12 + 3] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[1];
    idSendRecBuffers[cellId * 12 + 4] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[2];
    idSendRecBuffers[cellId * 12 + 5] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[3];
    idSendRecBuffers[cellId * 12 + 6] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[4];
    idSendRecBuffers[cellId * 12 + 7] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[5];
    idSendRecBuffers[cellId * 12 + 8] = m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0];
    idSendRecBuffers[cellId * 12 + 9] = m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 1];
    idSendRecBuffers[cellId * 12 + 10] = m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 2];
    idSendRecBuffers[cellId * 12 + 11] = m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 3];

    if(idSendRecBuffers[cellId * 12 + 0] > 0 && m_solver->a_isWindow(cellId)) {
      cnt++;
    }
  }
  m_log << "... " << cnt << " window boundary cells to exchange to all domains ... (Ids) " << endl;

  m_solver->exchangeData(&idSendRecBuffers[0], 12);

  for(MInt i = 0; i < m_solver->noNeighborDomains(); i++) {
    for(MInt j = 0; j < m_solver->noHaloCells(i); j++) {
      MInt thishaloCellId = m_solver->haloCellId(i, j);
      MInt bndryId = m_solver->a_bndryId(thishaloCellId);
      if(m_solver->a_bndryId(thishaloCellId) < 0) {
        continue;
      }
      m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints = idSendRecBuffers[thishaloCellId * 12 + 0];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[0] = idSendRecBuffers[thishaloCellId * 12 + 1];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[1] = idSendRecBuffers[thishaloCellId * 12 + 1];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[2] = idSendRecBuffers[thishaloCellId * 12 + 1];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[3] = idSendRecBuffers[thishaloCellId * 12 + 1];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[4] = idSendRecBuffers[thishaloCellId * 12 + 1];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[5] = idSendRecBuffers[thishaloCellId * 12 + 1];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[0] = idSendRecBuffers[thishaloCellId * 12 + 2];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[1] = idSendRecBuffers[thishaloCellId * 12 + 3];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[2] = idSendRecBuffers[thishaloCellId * 12 + 4];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[3] = idSendRecBuffers[thishaloCellId * 12 + 5];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[4] = idSendRecBuffers[thishaloCellId * 12 + 6];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[5] = idSendRecBuffers[thishaloCellId * 12 + 7];
      m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] =
          idSendRecBuffers[thishaloCellId * 12 + 8];
      m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 1] =
          idSendRecBuffers[thishaloCellId * 12 + 9];
      m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 2] =
          idSendRecBuffers[thishaloCellId * 12 + 10];
      m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 3] =
          idSendRecBuffers[thishaloCellId * 12 + 11];
    }
  }
  m_log << " finished. " << endl;

  m_log << "processing MFloats " << endl;
  MFloatScratchSpace floatSendRecBuffers(m_solver->a_noCells() * 18, AT_, "floatSendRecBuffers");
  floatSendRecBuffers.fill(0);

  cnt = 0;
  for(MInt cellId = 0; cellId < m_solver->a_noCells(); cellId++) {
    if(m_solver->a_bndryId(cellId) < 0) {
      continue;
    }
    MInt bndryId = m_solver->a_bndryId(cellId);

    floatSendRecBuffers[cellId * 18 + 0] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[0][0];
    floatSendRecBuffers[cellId * 18 + 1] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[0][1];
    floatSendRecBuffers[cellId * 18 + 2] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[0][2];
    floatSendRecBuffers[cellId * 18 + 3] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[1][0];
    floatSendRecBuffers[cellId * 18 + 4] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[1][1];
    floatSendRecBuffers[cellId * 18 + 5] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[1][2];
    floatSendRecBuffers[cellId * 18 + 6] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[2][0];
    floatSendRecBuffers[cellId * 18 + 7] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[2][1];
    floatSendRecBuffers[cellId * 18 + 8] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[2][2];
    floatSendRecBuffers[cellId * 18 + 9] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[3][0];
    floatSendRecBuffers[cellId * 18 + 10] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[3][1];
    floatSendRecBuffers[cellId * 18 + 11] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[3][2];
    floatSendRecBuffers[cellId * 18 + 12] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[4][0];
    floatSendRecBuffers[cellId * 18 + 13] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[4][1];
    floatSendRecBuffers[cellId * 18 + 14] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[4][2];
    floatSendRecBuffers[cellId * 18 + 15] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[5][0];
    floatSendRecBuffers[cellId * 18 + 16] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[5][1];
    floatSendRecBuffers[cellId * 18 + 17] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[5][2];
    if((floatSendRecBuffers[cellId * 18 + 0] > 0 || floatSendRecBuffers[cellId * 18 + 1] > 0
        || floatSendRecBuffers[cellId * 18 + 2] > 0 || floatSendRecBuffers[cellId * 18 + 3] > 0
        || floatSendRecBuffers[cellId * 18 + 4] > 0 || floatSendRecBuffers[cellId * 18 + 5] > 0
        || floatSendRecBuffers[cellId * 18 + 6] > 0 || floatSendRecBuffers[cellId * 18 + 7] > 0
        || floatSendRecBuffers[cellId * 18 + 8] > 0 || floatSendRecBuffers[cellId * 18 + 9] > 0
        || floatSendRecBuffers[cellId * 18 + 10] > 0 || floatSendRecBuffers[cellId * 18 + 11] > 0
        || floatSendRecBuffers[cellId * 18 + 12] > 0 || floatSendRecBuffers[cellId * 18 + 13] > 0
        || floatSendRecBuffers[cellId * 18 + 14] > 0 || floatSendRecBuffers[cellId * 18 + 15] > 0
        || floatSendRecBuffers[cellId * 18 + 16] > 0 || floatSendRecBuffers[cellId * 18 + 17] > 0
        || floatSendRecBuffers[cellId * 18 + 0] < 0 || floatSendRecBuffers[cellId * 18 + 1] < 0
        || floatSendRecBuffers[cellId * 18 + 2] < 0 || floatSendRecBuffers[cellId * 18 + 3] < 0
        || floatSendRecBuffers[cellId * 18 + 4] < 0 || floatSendRecBuffers[cellId * 18 + 5] < 0
        || floatSendRecBuffers[cellId * 18 + 6] < 0 || floatSendRecBuffers[cellId * 18 + 7] < 0
        || floatSendRecBuffers[cellId * 18 + 8] < 0 || floatSendRecBuffers[cellId * 18 + 9] < 0
        || floatSendRecBuffers[cellId * 18 + 10] < 0 || floatSendRecBuffers[cellId * 18 + 11] < 0
        || floatSendRecBuffers[cellId * 18 + 12] < 0 || floatSendRecBuffers[cellId * 18 + 13] < 0
        || floatSendRecBuffers[cellId * 18 + 14] < 0 || floatSendRecBuffers[cellId * 18 + 15] < 0
        || floatSendRecBuffers[cellId * 18 + 16] < 0 || floatSendRecBuffers[cellId * 18 + 17] < 0)
       && m_solver->a_isWindow(cellId)) {
      cnt++;
    }
  }
  m_log << "... " << cnt << " window boundary cells to exchange to all domains ... (Floats) " << endl;


  m_solver->exchangeData(&floatSendRecBuffers[0], 18);
  for(MInt i = 0; i < m_solver->noNeighborDomains(); i++) {
    for(MInt j = 0; j < m_solver->noHaloCells(i); j++) {
      MInt thishaloCellId = m_solver->haloCellId(i, j);
      MInt bndryId = m_solver->a_bndryId(thishaloCellId);
      if(m_solver->a_bndryId(thishaloCellId) < 0) {
        continue;
      }

      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[0][0] = floatSendRecBuffers[thishaloCellId * 18 + 0];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[0][1] = floatSendRecBuffers[thishaloCellId * 18 + 1];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[0][2] = floatSendRecBuffers[thishaloCellId * 18 + 2];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[1][0] = floatSendRecBuffers[thishaloCellId * 18 + 3];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[1][1] = floatSendRecBuffers[thishaloCellId * 18 + 4];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[1][2] = floatSendRecBuffers[thishaloCellId * 18 + 5];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[2][0] = floatSendRecBuffers[thishaloCellId * 18 + 6];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[2][1] = floatSendRecBuffers[thishaloCellId * 18 + 7];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[2][2] = floatSendRecBuffers[thishaloCellId * 18 + 8];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[3][0] = floatSendRecBuffers[thishaloCellId * 18 + 9];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[3][1] = floatSendRecBuffers[thishaloCellId * 18 + 10];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[3][2] = floatSendRecBuffers[thishaloCellId * 18 + 11];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[4][0] = floatSendRecBuffers[thishaloCellId * 18 + 12];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[4][1] = floatSendRecBuffers[thishaloCellId * 18 + 13];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[4][2] = floatSendRecBuffers[thishaloCellId * 18 + 14];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[5][0] = floatSendRecBuffers[thishaloCellId * 18 + 15];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[5][1] = floatSendRecBuffers[thishaloCellId * 18 + 16];
      m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[5][2] = floatSendRecBuffers[thishaloCellId * 18 + 17];
    }
  }
  m_log << " finished. " << endl;
}


/** \brief writes a .vtk file containing all cut points stored on the cut cells
 *
 * \author Claudia Guenther, December 2008
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::plotAllCutPoints() {
  TRACE();

  const MChar* fileName = "AllCutPoints_";
  stringstream fileName2;
  fileName2 << fileName << domainId() << ".vtk";
  ofstream ofl;
  ofl.open((fileName2.str()).c_str(), ofstream::trunc);

  MInt noCutPoints = 0;
  const MInt noCells = m_bndryCells->size();

  //-------------------------------------

  // count the total number of cut points
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    noCutPoints += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
  }

  if(ofl) {
    ofl.setf(ios::fixed);
    ofl.precision(20);

    ofl << "# vtk DataFile Version 3.0" << endl
        << "MAIAD intersectionPoints file" << endl
        << "ASCII" << endl
        << "DATASET POLYDATA" << endl
        << "POINTS " << noCutPoints << " float" << endl;

    // write each cut point in the data file
    for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
      if(m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints > 0) {
        for(MInt edge = 0; edge < m_noEdges; edge++) {
          for(MInt n = 0; n < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; n++) {
            if(m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[n] == edge) {
              for(MInt i = 0; i < nDim; i++) {
                ofl << m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[n][i] << " ";
              }
              IF_CONSTEXPR(nDim == 2) ofl << F0 << " ";
              ofl << endl;
            }
          }
        }
      }
    }

    ofl << "VERTICES " << noCutPoints << " " << noCutPoints * 2 << endl;
    for(MInt i = 0; i < noCutPoints; i++) {
      ofl << "1 " << i << endl;
    }
  }

  ofl.close();
}


/** \brief computes centroid and radius (return parameter) of a cut-off boundary surface
 * assumes that the surface is circular in 3D
 *
 * \author Claudia Guenther, December 2013
 */
template <MInt nDim, class SysEqn>
MFloat FvBndryCndXD<nDim, SysEqn>::computeCutoffBoundaryGeometry(const MInt bcId, const MInt dirN,
                                                                 MFloat* referencePoint) {
  MFloat inflowArea = F0;
  for(MInt i = F0; i < nDim; i++) {
    referencePoint[i] = F0;
  }

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    const MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    const MInt bndryId = m_solver->a_bndryId(cellId);

    MFloat area = F0;
    if(bndryId > -1) {
      // identify the "boundary surface" between cutoff boundary cell
      // and neighboring layer cell if cell is a boundary cell
      MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dirN];
      if(srfcId > -1) {
        area = m_solver->a_surfaceArea(srfcId);
      } else {
        for(MInt dir = 0; dir < m_noDirs; dir++) {
          srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dir];
          if(srfcId > -1) break;
        }
        if(srfcId == -1) {
          cerr << "[" << domainId() << "]: did not find associated surface in dir " << dirN << " for cell " << cellId
               << endl;
          writeStlFileOfCell(cellId, "cell.stl");
          mTerm(1, AT_, "something went wrong!");
        }
        area = m_solver->a_surfaceArea(srfcId);
      }
    } else {
      IF_CONSTEXPR(nDim == 2) { area = m_solver->c_cellLengthAtCell(cellId); }
      else {
        area = POW2(m_solver->c_cellLengthAtCell(cellId));
      }
    }
    inflowArea += area;
    // compute midpoint of inflow boundary and mean normal
    for(MInt i = 0; i < nDim; i++) {
      referencePoint[i] += m_solver->a_coordinate(cellId, i) * area;
    }
  }

  MInt minDom = domainId();

  if(noDomains() > 1) {
    const MInt noExchangeData = 1 + nDim;
    MFloatScratchSpace comm_buff(noExchangeData, AT_, "comm_buff");
    comm_buff[0] = inflowArea;
    for(MInt i = 0; i < nDim; i++) {
      comm_buff[i + 1] = referencePoint[i];
    }

    MPI_Allreduce(MPI_IN_PLACE, &comm_buff[0], noExchangeData, MPI_DOUBLE, MPI_SUM,
                  m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_, "MPI_IN_PLACE", "comm_buff[0]");
    MPI_Allreduce(MPI_IN_PLACE, &minDom, 1, MPI_INT, MPI_MIN, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                  "MPI_IN_PLACE", "minDom");

    inflowArea = comm_buff[0];
    for(MInt i = 0; i < nDim; i++) {
      referencePoint[i] = comm_buff[i + 1];
    }
  }

  for(MInt i = 0; i < nDim; i++) {
    referencePoint[i] /= inflowArea;
  }

  stringstream referencePointOutputStream;
  referencePointOutputStream << referencePoint[0] << " " << referencePoint[1] << " ";
  IF_CONSTEXPR(nDim == 3) referencePointOutputStream << referencePoint[2] << " ";

  if(domainId() == minDom) {
    cerr << " [" << domainId() << "]: bndryId: " << bcId << " refPoint: " << referencePointOutputStream.str()
         << ", area: " << inflowArea << endl;
  }

  return inflowArea;
}


/*
 * \author Daniel Hartmann, 22.12.2006
 *
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::createBndryCells() {
  TRACE();

  MInt noCells = m_solver->a_noCells();
  MInt noDirs = 2 * nDim;
  //--- end of initialization

  m_bndryCells->resetSize(0);

  for(MInt cellId = 0; cellId < noCells; cellId++) {
    if(m_solver->a_isInterface(cellId)) {
      if(isCutOffInterface(cellId)) {
        continue;
      }
      MInt bndryId = m_bndryCells->size();
      m_bndryCells->append();
      m_bndryCells->a[bndryId].m_cellId = cellId;
      m_bndryCells->a[bndryId].m_linkedCellId = -1;
      for(MInt face = 0; face < noDirs; face++) {
        m_bndryCells->a[bndryId].m_associatedSrfc[face] = -1;
      }
      for(MInt i = 0; i < nDim; i++) {
        m_bndryCells->a[bndryId].m_coordinates[i] = F0;
      }
    }
  }
}


/**
 * \fn void FvBndryCndXD<nDim, SysEqn>::generateBndryCells()
 * \brief generate finite-volume boundary cells
 * \author Daniel Hartmann, 22.12.2006, modified by Claudia Guenther, January 2010
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::generateBndryCells() {
  TRACE();

  createBndryCells();

  computeReverseMap();

  computeCutPoints();

  // bndryRfnJumpMethod needs this
  exchangeComputedCutPoints();

  if(m_multipleGhostCells || m_solver->m_useCreateCutFaceMGC) {
    createCutFaceMGC();
#ifndef NDEBUG
    cerr << "cut faces created! " << endl;
#endif
  } else {
    createCutFace();
  }

  // compute special cut cells at in/outflow boundaries where the sharp edge should be preserved
  if(m_multipleGhostCells) {
    MFloatScratchSpace normal_scratch(nDim, AT_, "normal_scratch");
    MFloatScratchSpace referencePoint_scratch(nDim, AT_, "referencePoint_scratch");
    MFloat* normal = normal_scratch.getPointer();
    MFloat* referencePoint = referencePoint_scratch.getPointer();
    MInt noInflowCorrectionBoundaries = 0;
    MInt bcId;
    MBool normalsCentersSpecified = false;
    if(Context::propertyExists("inflowCorrectionBoundaries", m_solverId)) {
      /*! \page propertiesFV
        \section inflowCorrectionBoundaries
        <code>FvBndryCnd3D::bc10910::bcProperty</code>\n
        default = <code>none</code>\n \n
        Boundaries for which special cut cells should be computed where \n
        a sharp edge should be preserved.\n
        <ul>
        <li> Positive Integer values </li>
        </ul>
        Keywords: <i> FINITE_VOLUME, BOUNDARY </i>
      */
      noInflowCorrectionBoundaries = Context::propertyLength("inflowCorrectionBoundaries", m_solverId);
    }
    if(noInflowCorrectionBoundaries) {
      if(Context::propertyExists("inflowCorrectionNormals", m_solverId)
         && Context::propertyExists("inflowCorrectionCenters", m_solverId)) {
        normalsCentersSpecified = true;

        /*! \page propertiesFV
         \section inflowCorrectionCenters
         <code>FvBndryCnd3D::bc10910:referencePointProperty</code>\n
         default = <code>none</code>\n \n
         inflow correction centers for boundaries for which special \n
         cut cells should be computed where \n
         a sharp edge should be preserved.\n
         <ul>
         <li> Positive Integer values </li>
         </ul>
         Keywords: <i> FINITE_VOLUME, BOUNDARY </i>
       */
        if(Context::propertyLength("inflowCorrectionNormals", m_solverId) < noInflowCorrectionBoundaries * nDim) {
          cerr << " Warning in FvBndryCnd3D::generateBndryCells: property inflowCorrectionNormals has not enough "
                  "entries! Go on without normals specified. Please check!"
               << endl;
          normalsCentersSpecified = false;
        }
        if(Context::propertyLength("inflowCorrectionCenters", m_solverId) < noInflowCorrectionBoundaries * nDim) {
          cerr << " Warning in FvBndryCnd3D::generateBndryCells: property inflowCorrectionCenters has not enough "
                  "entries! Go on without normals specified. Please check!"
               << endl;
          normalsCentersSpecified = false;
        }
      }
    }
    for(MInt i = 0; i < noInflowCorrectionBoundaries; i++) {
      bcId = Context::getSolverProperty<MInt>("inflowCorrectionBoundaries", m_solverId, AT_, i);
      if(normalsCentersSpecified) {
        cerr << " reading normal and reference point for bndry " << i << " with bcId " << bcId << endl;
        for(MInt d = 0; d < nDim; d++) {
          normal[d] = Context::getSolverProperty<MFloat>("inflowCorrectionNormals", m_solverId, AT_, i * nDim + d);
          referencePoint[d] =
              Context::getSolverProperty<MFloat>("inflowCorrectionCenters", m_solverId, AT_, i * nDim + d);
        }
        cerr << " normal: " << normal[0] << " " << normal[1] << " " << normal[2] << ", refPOint: " << referencePoint[0]
             << " " << referencePoint[1] << " " << referencePoint[2] << endl;
        correctInflowBoundary(bcId, normal, referencePoint);
      } else {
        correctInflowBoundary(bcId);
      }
    }
  }

  ASSERT(!m_cellCoordinatesCorrected, "");
  for(MInt bndryId = 0; bndryId < m_bndryCells->size(); bndryId++) {
    MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInvalid)) continue;
    m_bndryCells->a[bndryId].m_gapDistance = std::numeric_limits<MFloat>::max();
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance = F0;
      for(MInt i = 0; i < nDim; i++) {
        m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVectorCentroid[i] =
            m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
        m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance +=
            m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i]
            * (m_solver->a_coordinate(cellId, i) + m_bndryCells->a[bndryId].m_coordinates[i]
               - m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i]);
      }
      m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance =
          mMax(F0, m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance);
    }
  }


  if(m_createBoundaryAtCutoff) createBoundaryAtCutoff();

  createBndryCndHandler();

  createSortedBndryCellList();

  if(m_createSpongeBoundary) createSpongeAtSpongeBndryCnds();

  checkBoundaryCells();


  // create intracommunicator for boundary condition ids
  if(globalNoDomains() > 1) {
    initBndryCommunications();

    // check cutOff-boundary-communicators
    for(MInt bcId = 0; bcId < m_noCutOffBndryCndIds; bcId++) {
      if(m_sortedCutOffCells[bcId]->size() > 0) {
        MInt noTotalCutOffCellsCheck = m_sortedCutOffCells[bcId]->size();
        MPI_Allreduce(MPI_IN_PLACE, &noTotalCutOffCellsCheck, 1, MPI_INT, MPI_SUM,
                      m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_, "INPLACE", "noTotalCutOffCellsCheck");
      }
    }
  }
}


/** \brief uses Gram-Schmidt to compute orthonormal vectors in the cut plane
 *
 *	plane vectors are computed for all cut surfaces of a boundary cell
 *
 * \author Daniel Hartmann, modified by Claudia Guenther, Mai 2009
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::computePlaneVectors() {
  TRACE();


  const MInt noCells = m_bndryCells->size();
  for(MInt id = 0; id < noCells; id++) {
    for(MInt srfc = 0; srfc < m_bndryCells->a[id].m_noSrfcs; srfc++) {
      const MInt cellId = m_bndryCells->a[id].m_cellId;
      if(!m_multipleGhostCells) {
        if(m_solver->c_noChildren(cellId) > 0 || (!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel))) {
          continue;
        }
      }
      MFloat testVector0[nDim]{};
      MInt component[nDim - 1]{};


      if(fabs(m_bndryCells->a[id].m_srfcs[srfc]->m_normalVector[0])
         < fabs(m_bndryCells->a[id].m_srfcs[srfc]->m_normalVector[1])) {
        IF_CONSTEXPR(nDim == 3) {
          if(fabs(m_bndryCells->a[id].m_srfcs[srfc]->m_normalVector[0])
             < fabs(m_bndryCells->a[id].m_srfcs[srfc]->m_normalVector[2])) {
            component[0] = 0;
            if(fabs(m_bndryCells->a[id].m_srfcs[srfc]->m_normalVector[1])
               < fabs(m_bndryCells->a[id].m_srfcs[srfc]->m_normalVector[2])) {
              component[1] = 1;
            } else {
              component[1] = 2;
            }
          } else {
            component[0] = 2;
            component[1] = 0;
          }
        }
        else IF_CONSTEXPR(nDim == 2) {
          component[0] = 0;
        }
      } else
        IF_CONSTEXPR(nDim == 3) {
          if(fabs(m_bndryCells->a[id].m_srfcs[srfc]->m_normalVector[1])
             < fabs(m_bndryCells->a[id].m_srfcs[srfc]->m_normalVector[2])) {
            component[0] = 1;
            if(fabs(m_bndryCells->a[id].m_srfcs[srfc]->m_normalVector[0])
               < fabs(m_bndryCells->a[id].m_srfcs[srfc]->m_normalVector[2])) {
              component[1] = 0;
            } else {
              component[1] = 2;
            }
          } else {
            component[0] = 2;
            component[1] = 1;
          }
        }
      else IF_CONSTEXPR(nDim == 2) {
        component[0] = 1;
      }

      testVector0[component[0]] = F1;

      // (i) first vector
      // scalar product of test vector and normal vector
      MFloat sp[nDim - 1]{};
      for(MInt i = 0; i < nDim; i++) {
        sp[0] += testVector0[i] * m_bndryCells->a[id].m_srfcs[srfc]->m_normalVector[i];
      }
      // 1st orthogonal vector
      for(MInt i = 0; i < nDim; i++) {
        m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector0[i] =
            testVector0[i] - sp[0] * m_bndryCells->a[id].m_srfcs[srfc]->m_normalVector[i];
      }
      // normalize (use sp[0])
      sp[0] = F0;
      for(MInt i = 0; i < nDim; i++) {
        sp[0] += POW2(m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector0[i]);
      }
      sp[0] = F1 / sqrt(sp[0]);
      for(MInt i = 0; i < nDim; i++) {
        m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector0[i] *= sp[0];
      }
      IF_CONSTEXPR(nDim == 3) {
        // (ii) second vector
        MFloat testVector1[nDim]{};
        testVector1[component[1]] = F1;
        // scalar product of test vector and normal vector
        sp[0] = F0;
        for(MInt i = 0; i < nDim; i++) {
          sp[0] += testVector1[i] * m_bndryCells->a[id].m_srfcs[srfc]->m_normalVector[i];
        }
        // scalar product of test vector and first plane vector
        sp[1] = F0;
        for(MInt i = 0; i < nDim; i++) {
          sp[1] += testVector1[i] * m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector0[i];
        }
        // 1st orthogonal vector
        for(MInt i = 0; i < nDim; i++) {
          m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector1[i] =
              testVector1[i] - sp[0] * m_bndryCells->a[id].m_srfcs[srfc]->m_normalVector[i]
              - sp[1] * m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector0[i];
        }
        // normalize (use sp[])
        sp[0] = F0;
        for(MInt i = 0; i < nDim; i++) {
          sp[0] += POW2(m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector1[i]);
        }
        sp[0] = F1 / sqrt(sp[0]);
        for(MInt i = 0; i < nDim; i++) {
          m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector1[i] *= sp[0];
        }
      }

      MFloat normalVector[nDim];
      if(m_multipleGhostCells) {
        // compute the normal vector -  already given by surface normal
        for(MInt i = 0; i < nDim; i++) {
          normalVector[i] = m_bndryCells->a[id].m_srfcs[srfc]->m_normalVector[i];
        }
      } else {
        const MInt ghostCellId = m_bndryCells->a[id].m_srfcVariables[srfc]->m_ghostCellId;

        // compute the normal vector - unit vector in direction cellCenter->ghostCellCenter
        MFloat coordinates[nDim];

        for(MInt i = 0; i < nDim; i++) {
          coordinates[i] = m_solver->a_coordinate(cellId, i) - m_solver->a_coordinate(ghostCellId, i);
        }
        MFloat FtotalDistance = F0;
        for(MInt i = 0; i < nDim; i++) {
          FtotalDistance += POW2(coordinates[i]);
        }
        FtotalDistance = F1 / sqrt(FtotalDistance);
        for(MInt i = 0; i < nDim; i++) {
          normalVector[i] = coordinates[i] * FtotalDistance;
        }
      }

      // compute the Jacobian
      MFloat JacobianQuotient;

      IF_CONSTEXPR(nDim == 2) {
        JacobianQuotient = normalVector[0] * m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector0[1]
                           - normalVector[1] * m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector0[0];
      }
      else IF_CONSTEXPR(nDim == 3) {
        JacobianQuotient = normalVector[0] * m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector0[1]
                               * m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector1[2]
                           + normalVector[1] * m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector0[2]
                                 * m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector1[0]
                           + normalVector[2] * m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector0[0]
                                 * m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector1[1]
                           - normalVector[0] * m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector0[2]
                                 * m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector1[1]
                           - normalVector[1] * m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector0[0]
                                 * m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector1[2]
                           - normalVector[2] * m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector0[1]
                                 * m_bndryCells->a[id].m_srfcs[srfc]->m_planeVector1[0];
      }
      m_bndryCells->a[id].m_srfcs[srfc]->m_FJacobian = F1 / JacobianQuotient;
    }
  }
}


/** \brief Deletes a boundary cell (without collector fragmentation)
 *
 *	\author Daniel Hartmann
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::deleteBndryCell(MInt id) {
  TRACE();

  MInt size = m_bndryCells->size();
  if(size == 0) {
    mTerm(1, AT_, "collector is empty.");
  }
  void* from;
  void* to;
  MLong dataSize;
  char* rawMemory = m_bndryCells->getRawPointer();
  dataSize = FvBndryCell<nDim, SysEqn>::staticElementSize();
  to = (void*)(rawMemory + dataSize * (MLong)id);
  from = (void*)(rawMemory + dataSize * (size - 1));

  // 3. if the cell to delete is already the last cell we are finished here...
  if(size - 1 == id) {
    // 3.a tidy up your old place
    m_bndryCells->a[size - 1].allocateElements(from, (void*)m_bndryCells->getRawPointer(), size - 1);
    // 3.b Decrease current collector size by one (Note: was previously done before tidying up)
    m_bndryCells->setSize(size - 1);
    return;
  }

  // 4. Move last cell to freed space
  //    a. copy members of last cell to free space
  m_bndryCells->a[id] = m_bndryCells->a[size - 1];

  //    b. Move raw memory to free space
  memcpy(to, from, dataSize);

  //    c. call moveElements (which shifts pointers
  //       to the new destination
  m_bndryCells->a[id].moveElements(to);

  //    d. tidy up your old place
  m_bndryCells->a[size - 1].allocateElements(from, (void*)m_bndryCells->getRawPointer(), size - 1);

  // 8. Decrease current collector size by one
  m_bndryCells->setSize(size - 1);
}


/**
 * \brief Removes surfaces between master-slave pairs and
 * reassigns slave cell surfaces
 *
 * \author: Daniel Hartmann, December 27, 2006
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::correctMasterSlaveSurfaces() {
  TRACE();

  MInt cellId;
  MInt bndryId;
  MInt masterCellId;
  MInt noSurfaces = m_solver->a_noSurfaces();
  MInt otherId[2] = {1, 0};
  //--- end of initialization


  for(MInt srfcId = 0; srfcId < noSurfaces; srfcId++) {
    for(MInt nghbrId = 0; nghbrId < 2; nghbrId++) {
      cellId = m_solver->a_surfaceNghbrCellId(srfcId, nghbrId);
      if(m_solver->a_bndryId(cellId) < 0) {
        continue;
      }

      bndryId = m_solver->a_bndryId(cellId);
      // check whether the cell is a slave cell
      if(m_bndryCells->a[bndryId].m_linkedCellId == -1) {
        continue;
      }

      masterCellId = m_bndryCells->a[bndryId].m_linkedCellId;

      // check whether the other neighbor of the surface is the
      // master cell
      if(m_solver->a_surfaceNghbrCellId(srfcId, otherId[nghbrId]) == masterCellId) {
        // THIS CASE SHOULD NOT APPEAR
        cerr << " srfc: " << srfcId << " cellId: " << cellId << " master: " << masterCellId
             << " other neighbor: " << m_solver->a_surfaceNghbrCellId(srfcId, otherId[nghbrId]) << endl;
        mTerm(1, AT_, "correctMasterSlaveSurfaces ERROR, exiting...");

      } else {
        // shift the Id to the master cell
        m_solver->a_surfaceNghbrCellId(srfcId, nghbrId) = masterCellId;
      }
    }
  }
}


/** \brief Sets up the reconstruction stencil for boundary cells
 *
 *  Information is stored on the reconstructionData of the respective boundary cell
 *
 * \author Daniel Hartmann
 *
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::computeNeumannLSConstants(MInt bcId) {
  TRACE();

  const MInt noSmallCells = m_smallBndryCells->size();
  MInt bndryId;
  MInt nghbrId;
  MInt cellId;
  MInt noNghbrIds;
  MInt id;
  MInt noUnknowns = nDim;
  MFloatScratchSpace x_scratch(nDim, AT_, "x_scratch");
  MFloat* x = x_scratch.getPointer();
  MBool bcCell = false;
  //---

  // cell-center reconstruction
  for(MInt bc = m_bndryCndCells[bcId]; bc < m_bndryCndCells[bcId + 1]; bc++) {
    bndryId = m_sortedBndryCells->a[bc];
    cellId = m_bndryCells->a[bndryId].m_cellId;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      continue;
    }
    if(m_solver->a_hasProperty(cellId, SolverCell::IsNotGradient)) {
      continue;
    }
    if(m_bndryCells->a[bndryId].m_linkedCellId > -1) {
      continue;
    }
    if(m_solver->c_noChildren(cellId) > 0) {
      continue;
    }

    noNghbrIds = m_solver->a_noReconstructionNeighbors(cellId);

    // loop over least-squares cell cluster
    for(MInt cell = 0; cell < noNghbrIds; cell++) {
      id = m_solver->a_reconstructionNeighborId(cellId, cell);
      if(!m_solver->a_isBndryGhostCell(id)) {
        for(MInt i = 0; i < nDim; i++) {
          x[i] = m_solver->a_coordinate(id, i);
        }
      } else {
        computeMirrorCoordinates(m_solver->a_bndryId(m_solver->getAssociatedInternalCell(id)), x);
      }

      for(MInt i = 0; i < nDim; i++) {
        m_solver->m_A[cell][i] = x[i] - m_solver->a_coordinate(cellId, i);
      }
      // additional terms for a higher-order reconstruction
      if(m_solver->m_orderOfReconstruction == 2) {
        for(MInt i = 0; i < nDim; i++) {
          m_solver->m_A[cell][nDim + i] = POW2(x[i] - m_solver->a_coordinate(cellId, i));
        }
        m_solver->m_A[cell][2 * nDim + 1] =
            (x[0] - m_solver->a_coordinate(cellId, 0)) * (x[1] - m_solver->a_coordinate(cellId, 1));
        m_solver->m_A[cell][2 * nDim + 2] =
            (x[0] - m_solver->a_coordinate(cellId, 0)) * (x[2] - m_solver->a_coordinate(cellId, 2));
        m_solver->m_A[cell][2 * nDim + 3] =
            (x[1] - m_solver->a_coordinate(cellId, 1)) * (x[2] - m_solver->a_coordinate(cellId, 2));
      }
    }

    // compute ATA
    for(MInt i = 0; i < noUnknowns; i++) {
      for(MInt j = 0; j < noUnknowns; j++) {
        m_solver->m_ATA[i][j] = F0;
        for(MInt k = 0; k < noNghbrIds; k++) {
          m_solver->m_ATA[i][j] += m_solver->m_A[k][i] * m_solver->m_A[k][j];
        }
      }
    }

    // invert ATA
    const MFloat epsilon = POW3(m_solver->c_cellLengthAtLevel(m_solver->maxRefinementLevel()) / (1000.0));
    maia::math::inverse(m_solver->m_ATA, m_solver->m_ATAi, noUnknowns, epsilon);

    // compute (ATA)^(-1) * AT
    for(MInt i = 0; i < noUnknowns; i++) {
      for(MInt j = 0; j < noNghbrIds; j++) {
        m_solver->m_ATA[i][j] = F0;
        for(MInt k = 0; k < noUnknowns; k++) {
          m_solver->m_ATA[i][j] += m_solver->m_ATAi[i][k] * m_solver->m_A[j][k];
        }
      }
    }

    // loop over least-squares cell cluster
    for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
      nghbrId = m_solver->a_reconstructionNeighborId(cellId, nghbr);

      // compute the constants
      if(!m_solver->a_isBndryGhostCell(nghbrId)) {
        for(MInt i = 0; i < nDim; i++) {
          m_reconstructionConstants[bndryId][nDim * nghbr + i] = m_solver->m_ATA[i][nghbr];
        }
      } else {
        for(MInt i = 0; i < nDim; i++) {
          m_reconstructionConstants[bndryId][nDim * nghbr + i] = F0;
        }
      }
    }
  }

  // loop over all slave cells with internal master
  for(MInt sid = 0; sid < noSmallCells; sid++) {
    bcCell = false;
    bndryId = m_smallBndryCells->a[sid];
    cellId = m_bndryCells->a[bndryId].m_linkedCellId;
    // check, if cell is indeed a boundary cell with bc bcId:
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      // only compute reconstruction constants for the cells with the respective boundary condition
      if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == m_bndryCndIds[bcId]) {
        bcCell = true;
        break;
      }
    }
    if(!bcCell) {
      continue;
    }
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      continue;
    }
    if(m_solver->a_hasProperty(cellId, SolverCell::IsNotGradient)) {
      continue;
    }
    if(m_solver->a_bndryId(cellId) > -1) {
      continue;
    }

    // take all neighbors of the master cell
    noNghbrIds = m_solver->a_noReconstructionNeighbors(cellId);

    // loop over least-squares cell cluster
    for(MInt cell = 0; cell < noNghbrIds; cell++) {
      id = m_solver->a_reconstructionNeighborId(cellId, cell);
      if(!m_solver->a_isBndryGhostCell(id)) {
        for(MInt i = 0; i < nDim; i++) {
          x[i] = m_solver->a_coordinate(id, i);
        }
      } else {
        computeMirrorCoordinates(m_solver->a_bndryId(m_solver->getAssociatedInternalCell(id)), x);
      }

      for(MInt i = 0; i < nDim; i++) {
        m_solver->m_A[cell][i] = x[i] - m_solver->a_coordinate(cellId, i);
      }
      // additional terms for a higher-order reconstruction
      if(m_solver->m_orderOfReconstruction == 2) {
        for(MInt i = 0; i < nDim; i++) {
          m_solver->m_A[cell][nDim + i] = POW2(x[i] - m_solver->a_coordinate(cellId, i));
        }
        m_solver->m_A[cell][2 * nDim + 1] =
            (x[0] - m_solver->a_coordinate(cellId, 0)) * (x[1] - m_solver->a_coordinate(cellId, 1));
        m_solver->m_A[cell][2 * nDim + 2] =
            (x[0] - m_solver->a_coordinate(cellId, 0)) * (x[2] - m_solver->a_coordinate(cellId, 2));
        m_solver->m_A[cell][2 * nDim + 3] =
            (x[1] - m_solver->a_coordinate(cellId, 1)) * (x[2] - m_solver->a_coordinate(cellId, 2));
      }
    }

    // compute ATA
    for(MInt i = 0; i < noUnknowns; i++) {
      for(MInt j = 0; j < noUnknowns; j++) {
        m_solver->m_ATA[i][j] = F0;
        for(MInt k = 0; k < noNghbrIds; k++) {
          m_solver->m_ATA[i][j] += m_solver->m_A[k][i] * m_solver->m_A[k][j];
        }
      }
    }

    // invert ATA
    const MFloat epsilon = POW3(m_solver->c_cellLengthAtLevel(m_solver->maxRefinementLevel()) / (1000.0));
    maia::math::inverse(m_solver->m_ATA, m_solver->m_ATAi, noUnknowns, epsilon);

    // compute (ATA)^(-1) * AT
    for(MInt i = 0; i < noUnknowns; i++) {
      for(MInt j = 0; j < noNghbrIds; j++) {
        m_solver->m_ATA[i][j] = F0;
        for(MInt k = 0; k < noUnknowns; k++) {
          m_solver->m_ATA[i][j] += m_solver->m_ATAi[i][k] * m_solver->m_A[j][k];
        }
      }
    }

    // loop over least-squares cell cluster
    for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
      nghbrId = m_solver->a_reconstructionNeighborId(cellId, nghbr);

      // compute the constants
      if(!m_solver->a_isBndryGhostCell(nghbrId)) {
        for(MInt i = 0; i < nDim; i++) {
          m_reconstructionConstants[bndryId][nDim * nghbr + i] = m_solver->m_ATA[i][nghbr];
        }
      } else {
        for(MInt i = 0; i < nDim; i++) {
          m_reconstructionConstants[bndryId][nDim * nghbr + i] = F0;
        }
      }
    }
  }
}

/** \brief Updates the image point variables used with multiple ghost cell formulation
 *
 * If the multiple ghost cells formulation is used where the ghost cells are located normal to
 * the boundary surfaces from the surface centroids, this function is needed to update the
 * mirrored image points or their variables, respectively.
 *
 * input variable mode: Triggers the interpolation on the image points;
 * mode 0 means that the interpolation is based on the slopes computed only on the regular cells
 *				 surrounding the respective boundary cell without the ghost cells (first guess)
 * mode 1 means that the interpolation is based on the regular slopes on the boundary cell (for iteration)
 *
 * \author Claudia Guenther, Mai 2010
 */
template <MInt nDim, class SysEqn>
MFloat FvBndryCndXD<nDim, SysEqn>::updateImagePointVariables(MInt mode) {
  TRACE();

  MInt nghbrId = 0;
  MInt cellId;
  MInt linkedCell;
  MFloatScratchSpace dx_scratch(nDim, AT_, "dx_scratch");
  MFloat* dx = dx_scratch.getPointer();
  MFloat eps = F0;
  MFloat oldVar = F0;
  MFloat diff = F0;

  for(MInt bndryId = 0; bndryId < m_bndryCells->size(); bndryId++) {
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      cellId = m_bndryCells->a[bndryId].m_cellId;
      linkedCell = m_bndryCells->a[bndryId].m_linkedCellId;
      if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        if(m_solver->a_hasProperty(cellId, SolverCell::IsNotGradient)) {
          continue;
        }
        if(!m_solver->a_hasProperty(cellId, SolverCell::IsFlux)) {
          continue;
        }


        // if cell is a small cell with bndry cell Master, use this reconstruction stencil. Otherwise, use your own
        // stencil.
        if(linkedCell > -1) {
          cellId = linkedCell;
        }

        if(m_solver->a_hasProperty(cellId, SolverCell::IsNotGradient)) {
          continue;
        }
        if(!m_solver->a_hasProperty(cellId, SolverCell::IsFlux)) {
          continue;
        }


        // compute the slopes based only on the fluid cells - no ghost cells (bndry cnd not taken into account)
        if(mode == 0) {
          // reset the slopes
          for(MInt i = 0; i < nDim; i++) {
            for(MInt varId = 0; varId < PV->noVariables; varId++) {
              m_solver->a_slope(cellId, varId, i) = F0;
            }
          }

          // compute the slopes for the interpolation -
          for(MInt nghbr = 0; nghbr < m_solver->a_noReconstructionNeighbors(cellId); nghbr++) {
            nghbrId = m_solver->a_reconstructionNeighborId(cellId, nghbr);
            // skip ghost cells (reconstruction constants are set to zero - skip nevertheless!
            // important if ghost cell variables are not yet set properly!
            if(m_solver->a_isBndryGhostCell(nghbrId)) {
              continue;
            }
            for(MInt i = 0; i < nDim; i++) {
              for(MInt varId = 0; varId < PV->noVariables; varId++) {
                m_solver->a_slope(cellId, varId, i) +=
                    m_reconstructionConstants[bndryId][nghbr * nDim + i]
                    * (m_solver->a_pvariable(nghbrId, varId) - m_solver->a_pvariable(cellId, varId));
              }
            }
          }
        }

        // compute the offset of mp relative to the cell center
        for(MInt i = 0; i < nDim; i++) {
          dx[i] =
              m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageCoordinates[i] - m_solver->a_coordinate(cellId, i);
        }

        // compute Image Point variable
        for(MInt varId = 0; varId < PV->noVariables; varId++) {
          // store old value for computation of max. rel. change
          oldVar = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[varId];

          // compute image point value
          m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[varId] =
              m_solver->a_pvariable(cellId, varId);
          for(MInt i = 0; i < nDim; i++) {
            m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[varId] +=
                dx[i] * m_solver->a_slope(cellId, varId, i);
          }
          // compute relative change
          diff = abs((oldVar - m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[varId])
                     / m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[varId]);
          if(diff > eps) {
            eps = diff;
          }
        }
      }
    }
  }
  return eps;
}

/** \brief Computes the p and rho slopes on boundary cells using the least-squares method and setting implicitely
 * TInfinity burnt
 *
 * \authors Daniel Hartmann, Stephan Schlimpert
 * \date unknown, August 2011
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bcNeumannIsothermal(MInt bcId) {
  TRACE();

  IF_CONSTEXPR(nDim == 3) { TERMM(-1, "Info: untested for 3D."); }

  MInt nghbrId = 0;
  MInt cellId;
  MInt bndryId;
  MInt ghostCellId;
  MInt linkedCell;
  MFloatScratchSpace dx(nDim, AT_, "dx");
  MFloat thermalProfileStartFactor = m_solver->m_thermalProfileStartFactor;
  const MFloat TInfinity =
      m_solver->m_burntUnburntTemperatureRatio * m_solver->m_temperatureFlameTube * thermalProfileStartFactor;
  //---

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    bndryId = m_sortedBndryCells->a[id];
    cellId = m_bndryCells->a[bndryId].m_cellId;
    linkedCell = m_bndryCells->a[bndryId].m_linkedCellId;
    ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      if(linkedCell > -1) {
        cellId = linkedCell;
      }
      if(linkedCell == -1 || m_solver->a_bndryId(linkedCell) == -1) {
        // reset the slopes
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_slope(cellId, PV->P, i) = F0;
        }

        for(MInt nghbr = 0; nghbr < m_solver->a_noReconstructionNeighbors(cellId); nghbr++) {
          nghbrId = m_solver->a_reconstructionNeighborId(cellId, nghbr);
          for(MInt i = 0; i < nDim; i++) {
            m_solver->a_slope(cellId, PV->P, i) +=
                m_reconstructionConstants[bndryId][nghbr * nDim + i]
                * (m_solver->a_pvariable(nghbrId, PV->P) - m_solver->a_pvariable(cellId, PV->P));
          }
        }

        // compute the offset of mp relative to the cell center
        for(MInt i = 0; i < nDim; i++) {
          dx.p[i] = m_solver->a_coordinate(ghostCellId, i) - m_solver->a_coordinate(cellId, i);
        }

        // apply the Neumann bc for the pressure
        m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_pvariable(ghostCellId, PV->P) += dx.p[i] * m_solver->a_slope(cellId, PV->P, i);
        }

        // compute the density assuming that on the boundary cell T=T_inf
        m_solver->a_pvariable(ghostCellId, PV->RHO) =
            sysEqn().density_ES(m_solver->a_pvariable(ghostCellId, PV->P), TInfinity);
      }
    }
  }
}

/** \brief Computes the p and rho slopes on boundary cells using the least-squares method and setting implicitely
 * TInfinity burnt as a tanh profile from the tube edges rising up to the desired burnt temperature (dump boundaries)
 *
 * \authors Stephan Schlimpert
 * \date Januar 2012
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bcNeumannIsothermalBurntProfile(MInt bcId) {
  TRACE();

  IF_CONSTEXPR(nDim == 3) { TERMM(-1, "Info: untested for 3D."); }

  MInt nghbrId = 0;
  MInt cellId;
  MInt bndryId;
  MInt ghostCellId;
  MInt linkedCell;
  MFloatScratchSpace dx(nDim, AT_, "dx");
  MFloat deltaX = m_solver->m_deltaXtemperatureProfile;
  MFloat xOffsetTemperatureRise = m_radiusFlameTube + F1B2 * m_solver->m_flameRadiusOffset;
  MFloat neg2 = -F2;
  MFloat thermalProfileStartFactor = m_solver->m_thermalProfileStartFactor;
  //---

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    bndryId = m_sortedBndryCells->a[id];
    cellId = m_bndryCells->a[bndryId].m_cellId;
    linkedCell = m_bndryCells->a[bndryId].m_linkedCellId;
    ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      if(linkedCell > -1) {
        cellId = linkedCell;
      }
      if(linkedCell == -1 || m_solver->a_bndryId(linkedCell) == -1) {
        // reset the slopes
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_slope(cellId, PV->P, i) = F0;
        }

        for(MInt nghbr = 0; nghbr < m_solver->a_noReconstructionNeighbors(cellId); nghbr++) {
          nghbrId = m_solver->a_reconstructionNeighborId(cellId, nghbr);
          for(MInt i = 0; i < nDim; i++) {
            m_solver->a_slope(cellId, PV->P, i) +=
                m_reconstructionConstants[bndryId][nghbr * nDim + i]
                * (m_solver->a_pvariable(nghbrId, PV->P) - m_solver->a_pvariable(cellId, PV->P));
          }
        }

        // compute the offset of mp relative to the cell center
        for(MInt i = 0; i < nDim; i++) {
          dx.p[i] = m_solver->a_coordinate(ghostCellId, i) - m_solver->a_coordinate(cellId, i);
        }

        // apply the Neumann bc for the pressure
        m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_pvariable(ghostCellId, PV->P) += dx.p[i] * m_solver->a_slope(cellId, PV->P, i);
        }

        MFloat temperatureProfile;
        if(m_solver->a_coordinate(cellId, 0) > F0) {
          temperatureProfile =
              (m_solver->m_temperatureFlameTube * thermalProfileStartFactor
               + (m_solver->m_burntUnburntTemperatureRatio
                  - m_solver->m_temperatureFlameTube * thermalProfileStartFactor)
                     * (tanh(5.0) - F1B2 * tanh(5.0)
                        + F1B2
                              * tanh((F2 * (m_solver->a_coordinate(cellId, 0) - xOffsetTemperatureRise) - deltaX) * 5.0
                                     / deltaX)));
        } else {
          temperatureProfile =
              (m_solver->m_temperatureFlameTube * thermalProfileStartFactor
               + (m_solver->m_burntUnburntTemperatureRatio
                  - m_solver->m_temperatureFlameTube * thermalProfileStartFactor)
                     * (tanh(5.0) - F1B2 * tanh(5.0)
                        + F1B2
                              * tanh((neg2 * (m_solver->a_coordinate(cellId, 0) + xOffsetTemperatureRise) - deltaX)
                                     * 5.0 / deltaX)));
        }

        // compute the density assuming that on the boundary cell T=T_inf
        m_solver->a_pvariable(ghostCellId, PV->RHO) =
            sysEqn().density_ES(m_solver->a_pvariable(ghostCellId, PV->P), temperatureProfile);
      }
    }
  }
}

/** \brief Computes the p and rho slopes on boundary cells using the least-squares method and setting implicitely
 * TInfinity burnt as a tanh profile from the tube edges rising up to the desired burnt temperature (dump boundaries)
 *
 * \authors Stephan Schlimpert
 * \date Januar 2012
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bcNeumannIsothermalBurntProfileH(MInt bcId) {
  TRACE();

  IF_CONSTEXPR(nDim == 3) { TERMM(-1, "Info: untested for 3D."); }

  MInt nghbrId = 0;
  MInt cellId;
  MInt bndryId;
  MInt ghostCellId;
  MInt linkedCell;
  MFloatScratchSpace dx(nDim, AT_, "dx");
  MFloat deltaX = m_solver->m_deltaXtemperatureProfile;
  MFloat xOffsetTemperatureRise = m_radiusFlameTube + F1B2 * m_solver->m_flameRadiusOffset;
  MFloat thermalProfileStartFactor = m_solver->m_thermalProfileStartFactor;
  MFloat tempHalfBurnt = m_solver->m_temperatureFlameTube * F1B2 * m_solver->m_burntUnburntTemperatureRatio;
  MFloat tempBurnt =
      m_solver->m_temperatureFlameTube * m_solver->m_burntUnburntTemperatureRatio * thermalProfileStartFactor;
  MFloat neg2 = -F2;
  //---

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    bndryId = m_sortedBndryCells->a[id];
    cellId = m_bndryCells->a[bndryId].m_cellId;
    linkedCell = m_bndryCells->a[bndryId].m_linkedCellId;
    ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      if(linkedCell > -1) {
        cellId = linkedCell;
      }
      if(linkedCell == -1 || m_solver->a_bndryId(linkedCell) == -1) {
        // reset the slopes
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_slope(cellId, PV->P, i) = F0;
        }

        for(MInt nghbr = 0; nghbr < m_solver->a_noReconstructionNeighbors(cellId); nghbr++) {
          nghbrId = m_solver->a_reconstructionNeighborId(cellId, nghbr);
          for(MInt i = 0; i < nDim; i++) {
            m_solver->a_slope(cellId, PV->P, i) +=
                m_reconstructionConstants[bndryId][nghbr * nDim + i]
                * (m_solver->a_pvariable(nghbrId, PV->P) - m_solver->a_pvariable(cellId, PV->P));
          }
        }

        // compute the offset of mp relative to the cell center
        for(MInt i = 0; i < nDim; i++) {
          dx.p[i] = m_solver->a_coordinate(ghostCellId, i) - m_solver->a_coordinate(cellId, i);
        }

        // apply the Neumann bc for the pressure
        m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_pvariable(ghostCellId, PV->P) += dx.p[i] * m_solver->a_slope(cellId, PV->P, i);
        }

        MFloat temperatureProfile;
        if(m_solver->a_coordinate(cellId, 0) > F0) {
          temperatureProfile =
              tempHalfBurnt
              + (tempBurnt - tempHalfBurnt)
                    * (tanh(5.0) - F1B2 * tanh(5.0)
                       + F1B2
                             * tanh((F2 * (m_solver->a_coordinate(cellId, 0) - xOffsetTemperatureRise) - deltaX) * 5.0
                                    / deltaX));
        } else {
          temperatureProfile =
              tempHalfBurnt
              + (tempBurnt - tempHalfBurnt)
                    * (tanh(5.0) - F1B2 * tanh(5.0)
                       + F1B2
                             * tanh((neg2 * (m_solver->a_coordinate(cellId, 0) + xOffsetTemperatureRise) - deltaX) * 5.0
                                    / deltaX));
        }

        // compute the density assuming that on the boundary cell T=T_inf
        m_solver->a_pvariable(ghostCellId, PV->RHO) =
            sysEqn().density_ES(m_solver->a_pvariable(ghostCellId, PV->P), temperatureProfile);
      }
    }
  }
}

/** \brief Computes the p and rho slopes on boundary cells using the least-squares method and setting implicitely
 * TInfinity as a tanh profile rising up to the desired burnt temperature at the tube edges (tube inflow boundary!)
 *
 * \authors Stephan Schlimpert
 * \date Januar 2012
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bcNeumannIsothermalUnburntProfile(MInt bcId) {
  TRACE();

  IF_CONSTEXPR(nDim == 3) { TERMM(-1, "Info: untested for 3D."); }

  MInt nghbrId = 0;
  MInt cellId;
  MInt bndryId;
  MInt ghostCellId;
  MInt linkedCell;
  MFloatScratchSpace dx(nDim, AT_, "dx");
  MFloat deltaY = m_solver->m_deltaYtemperatureProfile;
  MFloat yOffsetTemperatureRise = m_solver->m_yOffsetFlameTube - deltaY;
  //---

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    bndryId = m_sortedBndryCells->a[id];
    cellId = m_bndryCells->a[bndryId].m_cellId;
    linkedCell = m_bndryCells->a[bndryId].m_linkedCellId;
    ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      if(linkedCell > -1) {
        cellId = linkedCell;
      }
      if(linkedCell == -1 || m_solver->a_bndryId(linkedCell) == -1) {
        // reset the slopes
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_slope(cellId, PV->P, i) = F0;
        }

        for(MInt nghbr = 0; nghbr < m_solver->a_noReconstructionNeighbors(cellId); nghbr++) {
          nghbrId = m_solver->a_reconstructionNeighborId(cellId, nghbr);
          for(MInt i = 0; i < nDim; i++) {
            m_solver->a_slope(cellId, PV->P, i) +=
                m_reconstructionConstants[bndryId][nghbr * nDim + i]
                * (m_solver->a_pvariable(nghbrId, PV->P) - m_solver->a_pvariable(cellId, PV->P));
          }
        }

        // compute the offset of mp relative to the cell center
        for(MInt i = 0; i < nDim; i++) {
          dx.p[i] = m_solver->a_coordinate(ghostCellId, i) - m_solver->a_coordinate(cellId, i);
        }

        // apply the Neumann bc for the pressure
        m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_pvariable(ghostCellId, PV->P) += dx.p[i] * m_solver->a_slope(cellId, PV->P, i);
        }

        const MFloat temperatureProfile =
            ((m_solver->m_temperatureFlameTube
              + (m_solver->m_burntUnburntTemperatureRatio - m_solver->m_temperatureFlameTube)
                    * (tanh(5.0) - F1B2 * tanh(5.0)
                       + F1B2
                             * tanh((F2 * (m_solver->a_coordinate(cellId, 1) - yOffsetTemperatureRise) - deltaY) * 5.0
                                    / deltaY))));

        // compute the density assuming that on the boundary cell T=T_inf
        m_solver->a_pvariable(ghostCellId, PV->RHO) =
            sysEqn().density_ES(m_solver->a_pvariable(ghostCellId, PV->P), temperatureProfile);
      }
    }
  }
}

/** \brief Computes the p and rho slopes on boundary cells using the least-squares method and setting implicitely
 * TInfinity as a tanh profile rising up to the desired half burnt temperature at the tube edges (tube inflow boundary!)
 *
 * \authors Stephan Schlimpert
 * \date Januar 2012
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bcNeumannIsothermalUnburntProfileH(MInt bcId) {
  TRACE();

  IF_CONSTEXPR(nDim == 3) { TERMM(-1, "Info: untested for 3D."); }

  MInt nghbrId = 0;
  MInt cellId;
  MInt bndryId;
  MInt ghostCellId;
  MInt linkedCell;
  MFloatScratchSpace dx(nDim, AT_, "dx");
  MFloat deltaY = m_solver->m_deltaYtemperatureProfile;
  MFloat yOffsetTemperatureRise = m_solver->m_yOffsetFlameTube - deltaY;
  //---

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    bndryId = m_sortedBndryCells->a[id];
    cellId = m_bndryCells->a[bndryId].m_cellId;
    linkedCell = m_bndryCells->a[bndryId].m_linkedCellId;
    ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      if(linkedCell > -1) {
        cellId = linkedCell;
      }
      if(linkedCell == -1 || m_solver->a_bndryId(linkedCell) == -1) {
        // reset the slopes
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_slope(cellId, PV->P, i) = F0;
        }

        for(MInt nghbr = 0; nghbr < m_solver->a_noReconstructionNeighbors(cellId); nghbr++) {
          nghbrId = m_solver->a_reconstructionNeighborId(cellId, nghbr);
          for(MInt i = 0; i < nDim; i++) {
            m_solver->a_slope(cellId, PV->P, i) +=
                m_reconstructionConstants[bndryId][nghbr * nDim + i]
                * (m_solver->a_pvariable(nghbrId, PV->P) - m_solver->a_pvariable(cellId, PV->P));
          }
        }

        // compute the offset of mp relative to the cell center
        for(MInt i = 0; i < nDim; i++) {
          dx.p[i] = m_solver->a_coordinate(ghostCellId, i) - m_solver->a_coordinate(cellId, i);
        }

        // apply the Neumann bc for the pressure
        m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_pvariable(ghostCellId, PV->P) += dx.p[i] * m_solver->a_slope(cellId, PV->P, i);
        }


        const MFloat temperatureProfile =
            (m_solver->m_temperatureFlameTube
             + (F1B2 * m_solver->m_burntUnburntTemperatureRatio - m_solver->m_temperatureFlameTube)
                   * (tanh(5.0) - F1B2 * tanh(5.0)
                      + F1B2
                            * tanh((F2 * (m_solver->a_coordinate(cellId, 1) - yOffsetTemperatureRise) - deltaY) * 5.0
                                   / deltaY)));

        // compute the density assuming that on the boundary cell T=T_inf
        m_solver->a_pvariable(ghostCellId, PV->RHO) =
            sysEqn().density_ES(m_solver->a_pvariable(ghostCellId, PV->P), temperatureProfile);
      }
    }
  }
}

/** \brief Computes the p and rho slopes on boundary cells using the least-squares method, and setting implicitely
 * TInfinity unburnt (tube wall boundaries)
 *
 * \authors Stephan Schlimpert
 * \date November 2011
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bcNeumannIsothermalUnburnt(MInt bcId) {
  TRACE();

  IF_CONSTEXPR(nDim == 3) { TERMM(-1, "Info: untested for 3D."); }

  MInt nghbrId = 0;
  MInt cellId;
  MInt bndryId;
  MInt ghostCellId;
  MInt linkedCell;
  MFloatScratchSpace dx(nDim, AT_, "dx");
  const MFloat TInfinityUnburnt = m_solver->m_temperatureFlameTube;
  //---

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    bndryId = m_sortedBndryCells->a[id];
    cellId = m_bndryCells->a[bndryId].m_cellId;
    linkedCell = m_bndryCells->a[bndryId].m_linkedCellId;
    ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      if(linkedCell > -1) {
        cellId = linkedCell;
      }
      if(linkedCell == -1 || m_solver->a_bndryId(linkedCell) == -1) {
        // reset the slopes
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_slope(cellId, PV->P, i) = F0;
        }

        for(MInt nghbr = 0; nghbr < m_solver->a_noReconstructionNeighbors(cellId); nghbr++) {
          nghbrId = m_solver->a_reconstructionNeighborId(cellId, nghbr);
          for(MInt i = 0; i < nDim; i++) {
            m_solver->a_slope(cellId, PV->P, i) +=
                m_reconstructionConstants[bndryId][nghbr * nDim + i]
                * (m_solver->a_pvariable(nghbrId, PV->P) - m_solver->a_pvariable(cellId, PV->P));
          }
        }

        // compute the offset of mp relative to the cell center
        for(MInt i = 0; i < nDim; i++) {
          dx.p[i] = m_solver->a_coordinate(ghostCellId, i) - m_solver->a_coordinate(cellId, i);
        }

        // apply the Neumann bc for the pressure
        m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_pvariable(ghostCellId, PV->P) += dx.p[i] * m_solver->a_slope(cellId, PV->P, i);
        }

        // compute the density assuming that on the boundary cell T=T_inf
        m_solver->a_pvariable(ghostCellId, PV->RHO) =
            sysEqn().density_ES(m_solver->a_pvariable(ghostCellId, PV->P), TInfinityUnburnt);
      }
    }
  }
}

/** \brief Moving boundary Neumann condition.
 *  \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bcNeumannMb(MInt bcId) {
  TRACE();

  //---

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt bndryId = m_sortedBndryCells->a[id];
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;

    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      const MBool gapCell = m_solver->a_hasProperty(cellId, SolverCell::IsGapCell);

      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        MInt k = m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bodyId[0];
        ASSERT(k > -1 && k < m_solver->m_noEmbeddedBodies + m_solver->m_noPeriodicGhostBodies, "");
        if(k < 0 || k >= m_solver->m_noEmbeddedBodies + m_solver->m_noPeriodicGhostBodies) {
          mTerm(1, AT_, "Invalid body id: " + to_string(k));
        }

        MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
        MFloat normal[nDim];
        MFloat delta[3] = {F0, F0, F0};
        MFloat dr[3] = {F0, F0, F0};
        MFloat dw[3] = {F0, F0, F0};
        MFloat dg[3] = {F0, F0, F0};
        MFloat du[3] = {F0, F0, F0};
        MFloat dv[3] = {F0, F0, F0};
        MFloat dn = F0;
        for(MInt i = 0; i < nDim; i++) {
          normal[i] = m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
          dr[i] = m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i] - m_solver->m_bodyCenter[k * nDim + i];
          du[i] = m_solver->m_bodyAcceleration[k * nDim + i];
          dv[i] = m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]]
                  - m_solver->m_bodyVelocity[k * nDim + i];
          dn += (m_solver->a_coordinate(cellId, i) - m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i])
                * normal[i];

          if(gapCell && m_solver->m_gapInitMethod > 0) {
            du[i] = 0;
            dv[i] = 0;
          }
        }

        for(MInt i = 0; i < 3; i++) {
          dw[i] = m_solver->m_bodyAngularAcceleration[k * 3 + i];
          dg[i] = m_solver->m_bodyAngularVelocity[k * 3 + i];
        }
        // assemble material acceleration
        delta[0] = du[0] + dw[1] * dr[2] - dw[2] * dr[1] + dg[1] * dv[2] - dg[2] * dv[1];
        delta[1] = du[1] + dw[2] * dr[0] - dw[0] * dr[2] + dg[2] * dv[0] - dg[0] * dv[2];
        delta[2] = du[2] + dw[0] * dr[1] - dw[1] * dr[0] + dg[0] * dv[1] - dg[1] * dv[0];


        MFloat an = F0;
        for(MInt i = 0; i < nDim; i++) {
          an += normal[i] * delta[i];
        }

        MFloat surfTemp =
            sysEqn().temperature_ES(m_solver->a_pvariable(cellId, PV->RHO), m_solver->a_pvariable(cellId, PV->P));
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == 3008
           || m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == 3010) {
          surfTemp = m_solver->m_bodyTemperature[m_solver->m_internalBodyId[k]];
          // Timw engine specific
          // labels:FV Tina-engine liner-Temperatur hack:
          if(m_solver->m_engineSetup && m_solver->m_noGapRegions >= 1 && k == 0) {
            if(m_solver->a_coordinate(cellId, 1) > 0) {
              surfTemp = 1;
            } else if(m_solver->a_coordinate(cellId, 1) > -0.1 && m_solver->a_coordinate(cellId, 1) < 0) {
              // linear interpolation between T_infinity and surface temperature
              surfTemp = 1 + m_solver->a_coordinate(cellId, 1) / -0.1 * (surfTemp - 1);
            }
          }
        }

        const MFloat beta = sysEqn().gamma_Ref() * an / surfTemp;
        m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_robinFactor = beta;

        if(fabs(F1 - beta * dn) < 1e-3) {
          cerr << "Warning: small denom Robin BC: " << k << " " << m_solver->m_internalBodyId[k] << " " << beta << " "
               << dn << " " << an << " " << surfTemp << " " << srfc << endl;
        }
        const MFloat fac = (F1 + beta * dn) / (F1 - beta * dn);

        m_solver->a_pvariable(ghostCellId, PV->P) = fac * m_solver->a_pvariable(cellId, PV->P);
        m_solver->a_pvariable(ghostCellId, PV->RHO) = fac * m_solver->a_pvariable(cellId, PV->RHO);

        // JANNIK: should this be here?
        for(MInt s = 0; s < m_noSpecies; s++) {
          m_solver->a_pvariable(ghostCellId, PV->Y[s]) = m_solver->a_pvariable(cellId, PV->Y[s]);
        }

        IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
          for(MInt r = 0; r < m_solver->m_noRansEquations; ++r) {
            m_solver->a_pvariable(ghostCellId, PV->NN[r]) = -m_solver->a_pvariable(cellId, PV->NN[r]);
          }
        }

        MFloat pressure = F1B2 * (m_solver->a_pvariable(cellId, PV->P) + m_solver->a_pvariable(ghostCellId, PV->P));
        m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->P] = pressure;

        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == 3007) {
          m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->RHO] =
              m_solver->a_pvariable(cellId, PV->RHO)
              * pow(pressure / m_solver->a_pvariable(cellId, PV->P), sysEqn().gamma_Ref());
          m_solver->a_pvariable(ghostCellId, PV->RHO) =
              F2 * m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->RHO]
              - m_solver->a_pvariable(cellId, PV->RHO);
        } else if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == 3008
                  || m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == 3010) {
          m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->RHO] = sysEqn().density_ES(pressure, surfTemp);
          m_solver->a_pvariable(ghostCellId, PV->RHO) =
              F2 * m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->RHO]
              - m_solver->a_pvariable(cellId, PV->RHO);
        } else {
          m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->RHO] =
              F1B2 * (m_solver->a_pvariable(cellId, PV->RHO) + m_solver->a_pvariable(ghostCellId, PV->RHO));
        }
      }
    }
  }
}


//------------------------------------------------------------------------------

/**
 * \fn FvBndryCndXD::bc01()
 * Zero boundary condition: ghost cells set to infinity flow conditions (initial condition) \n
 * Debug boundary condition \n
 * Set of variables: Standard CV \n
 * u=v=w=0, rho=1, p=1/gamma \n
 * \author Claudia Guenther
 * \fvbc{FvBndryCndXD::bc01(), fvbc01, BC 1}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc01(MInt bcId) {
  TRACE();

#ifdef _OPENMP
#pragma omp parallel for
#endif
  // loop over all concerning boundary cells
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt cellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      const MInt ghostCellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_srfcVariables[0]->m_ghostCellId;

      // set the density
      m_solver->a_pvariable(ghostCellId, PV->RHO) =
          2.0 * m_solver->m_rhoInfinity - m_solver->a_pvariable(cellId, PV->RHO);


      // set the velocities
      for(MInt i = 0; i < nDim; i++) {
        m_solver->a_pvariable(ghostCellId, PV->VV[i]) =
            2.0 * m_solver->m_VVInfinity[i] - m_solver->a_pvariable(cellId, PV->VV[i]);
      }

      // set the pressure of the ghost cell equal to that of the boundary cell
      m_solver->a_pvariable(ghostCellId, PV->P) = 2.0 * m_solver->m_PInfinity;
    }
  }
}

/**
 * \fn FvBndryCndXD::bc1000()
 * Zero boundary condition: ghost cells set to quiescent flow (initial condition) \n
 * Set of variables: Standard CV \n
 * u=v=w=0, rho=1, p=1/gamma
 * \author Claudia Guenther
 * \fvbc{FvBndryCndXD::bc1000(), fvbc1000, BC 1000}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1000(MInt bcId) {
  TRACE();

#ifdef _OPENMP
#pragma omp parallel for
#endif
  // loop over all concerning boundary cells
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt cellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      const MInt ghostCellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_srfcVariables[0]->m_ghostCellId;

      // set the density
      m_solver->a_pvariable(ghostCellId, PV->RHO) = m_solver->a_pvariable(cellId, PV->RHO);

      // set the velocities
      for(MInt i = 0; i < nDim; i++) {
        m_solver->a_pvariable(ghostCellId, PV->VV[i]) = -m_solver->a_pvariable(cellId, PV->VV[i]);
      }

      // set the pressure of the ghost cell equal to that of the boundary cell
      m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);

      for(MInt s = 0; s < m_noSpecies; s++) {
        m_solver->a_pvariable(ghostCellId, PV->Y[s]) = m_solver->a_pvariable(cellId, PV->Y[s]);
      }
    }
  }
}


/**
 * \fn FvBndryCndXD::bc1001()
 * Subsonic inflow boundary condition. \n
 * Set of variables: Standard CV \n
 * u=v=w=IF;  rho=rhoIF;  dp/dn=0;
 * \author Daniel Hartmann
 * \date November 11, 2006 (3D)
 * \fvbc{FvBndryCndXD::bc1001(), fvbc1001, BC 1001}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1001(MInt bcId) {
  TRACE();

#ifdef _OPENMP
#pragma omp parallel for
#endif
  // loop over all concerning boundary cells
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt cellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      const MInt ghostCellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_srfcVariables[0]->m_ghostCellId;

      // set the density
      m_solver->a_pvariable(ghostCellId, PV->RHO) =
          2.0 * m_solver->m_rhoInfinity - m_solver->a_pvariable(cellId, PV->RHO);

      // set the velocities
      for(MInt i = 0; i < nDim; i++) {
        m_solver->a_pvariable(ghostCellId, PV->VV[i]) =
            F2 * m_solver->m_VVInfinity[i] - m_solver->a_pvariable(cellId, PV->VV[i]);
      }

      // set the pressure of the ghost cell equal to that of the boundary cell
      m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);
      IF_CONSTEXPR(hasPV_C<SysEqn>::value) {
        if(m_combustion) {
          m_solver->a_pvariable(ghostCellId, PV->C) = -m_solver->a_pvariable(cellId, PV->C);
        }
      }
      IF_CONSTEXPR(isDetChem<SysEqn>) {
        for(MInt s = 0; s < m_noSpecies; s++) {
          m_solver->a_pvariable(ghostCellId, PV->Y[s]) =
              2.0 * m_solver->m_YInfinity[s] - m_solver->a_pvariable(cellId, PV->Y[s]);
        }
      }
      else {
        if(m_isEEGas) {
          m_solver->a_pvariable(ghostCellId, PV->Y[0]) =
              2.0 * m_solver->m_EEGas.alphaIn - m_solver->a_pvariable(cellId, PV->Y[0]);
        } else {
          for(MInt s = 0; s < m_noSpecies; s++) {
            m_solver->a_pvariable(cellId, PV->Y[s]) = 1.0;
          }
        }
      }
      IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
        IF_CONSTEXPR(SysEqn::m_ransModel == RANS_SA_DV || SysEqn::m_ransModel == RANS_FS) {
          m_solver->a_pvariable(ghostCellId, PV->N) =
              2.0 * m_solver->m_nuTildeInfinity - m_solver->a_pvariable(cellId, PV->N);
        }
        IF_CONSTEXPR(SysEqn::m_ransModel == RANS_KOMEGA || SysEqn::m_ransModel == RANS_SST) {
          m_solver->a_pvariable(ghostCellId, PV->K) =
              2.0 * m_solver->m_kInfinity - m_solver->a_pvariable(cellId, PV->K);
          m_solver->a_pvariable(ghostCellId, PV->OMEGA) =
              2.0 * m_solver->m_omegaInfinity - m_solver->a_pvariable(cellId, PV->OMEGA);
        }
      }
    }
  }
}

/**
 * \fn FvBndryCndXD::bc1002
 * Subsonic outflow boundary condition.
 * Set of variables: Standard CV \n
 * du/dn=dv/dn=dw/dn=0;  drho/dn=0;  p=pIF; \n \n
 * 3D version
 * \author Daniel Hartmann
 * \date November 11, 2006 (3D)
 * \fvbc{FvBndryCndXD::bc1002(), fvbc1002, BC 1002}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1002(MInt bcId) {
  TRACE();

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt cellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      const MInt ghostCellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_srfcVariables[0]->m_ghostCellId;

      // set the density
      m_solver->a_pvariable(ghostCellId, PV->RHO) = m_solver->a_pvariable(cellId, PV->RHO);

      // set the velocities
      for(MInt i = 0; i < nDim; i++) {
        m_solver->a_pvariable(ghostCellId, PV->VV[i]) = m_solver->a_pvariable(cellId, PV->VV[i]);
      }

      // set the pressure
      m_solver->a_pvariable(ghostCellId, PV->P) = 2.0 * m_solver->m_PInfinity - m_solver->a_pvariable(cellId, PV->P);

      if(isDetChem<SysEqn> || m_isEEGas) {
        for(MInt s = 0; s < m_noSpecies; s++) {
          m_solver->a_pvariable(ghostCellId, PV->Y[s]) = m_solver->a_pvariable(cellId, PV->Y[s]);
        }
      } else {
        for(MInt s = 0; s < m_noSpecies; s++) {
          m_solver->a_pvariable(cellId, PV->Y[s]) = 0.0;
        }
      }


      IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
        for(MInt r = 0; r < m_solver->m_noRansEquations; ++r) {
          m_solver->a_pvariable(ghostCellId, PV->NN[r]) = m_solver->a_pvariable(cellId, PV->NN[r]);
        }
      }
    }
  }
}

/**
 * \fn FvBndryCndXD::bc1009
 * Subsonic inflow boundary condition for cavity flow with different Mach number. \n
 * Set of variables: Standard CV \n
 * u=v=w=IF;  rho=rhoIF;  dp/dn=0; \n
 * \author Jannik Borgelt
 * \date November 01, 2020 (3D)
 * \fvbc{FvBndryCndXD::bc1009(), fvbc1009, BC 1009}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1009(MInt bcId) {
  TRACE();

#ifdef _OPENMP
#pragma omp parallel for
#endif
  // loop over all concerning boundary cells
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt cellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      const MInt ghostCellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_srfcVariables[0]->m_ghostCellId;

      // Density
      m_solver->a_pvariable(ghostCellId, PV->RHO) = 2.0 * m_solver->m_rhoCg - m_solver->a_pvariable(cellId, PV->RHO);

      // Velocities
      m_solver->a_pvariable(ghostCellId, PV->VV[0]) = 2.0 * m_solver->m_UCg - m_solver->a_pvariable(cellId, PV->U);
      m_solver->a_pvariable(ghostCellId, PV->VV[1]) = 2.0 * m_solver->m_VCg - m_solver->a_pvariable(cellId, PV->V);
      m_solver->a_pvariable(ghostCellId, PV->VV[2]) = 2.0 * m_solver->m_WCg - m_solver->a_pvariable(cellId, PV->W);

      // Pressure
      m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);

      // Species
      if(!m_isEEGas) {
        for(MInt s = 0; s < m_noSpecies; s++) {
          m_solver->a_pvariable(cellId, PV->Y[s]) = 1.0;
        }
      }

      // RANS
      IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
        IF_CONSTEXPR(SysEqn::m_ransModel == RANS_SA_DV || SysEqn::m_ransModel == RANS_FS) {
          m_solver->a_pvariable(ghostCellId, PV->N) =
              2.0 * m_solver->m_nuTildeInfinity - m_solver->a_pvariable(cellId, PV->N);
        }
        IF_CONSTEXPR(SysEqn::m_ransModel == RANS_KOMEGA || SysEqn::m_ransModel == RANS_SST) {
          m_solver->a_pvariable(ghostCellId, PV->K) =
              2.0 * m_solver->m_kInfinity - m_solver->a_pvariable(cellId, PV->K);
          m_solver->a_pvariable(ghostCellId, PV->OMEGA) =
              2.0 * m_solver->m_omegaInfinity - m_solver->a_pvariable(cellId, PV->OMEGA);
        }
      }
    }
  }
}

/**
 *
 * Daniel Hartmann, March 06, 2007
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bcInit1050(MInt) {
  IF_CONSTEXPR(nDim == 2) { TERMM(-1, "INFO: function bcInit1050 is untested for 2D!"); }
  TRACE();

  MInt noCells = m_bndryCells->size();
  MFloat eps = 0.0001 / FPOW2(m_solver->maxRefinementLevel());
// --- end of initialization

// loop over all concerning boundary cells
#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    if(m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId == 1051) {
      MInt cellId = m_bndryCells->a[bndryId].m_cellId;
      MFloat coordinates[nDim];
      MFloat coordinatesP[nDim];
      for(MInt i = 0; i < nDim; i++) {
        coordinates[i] = m_solver->a_coordinate(cellId, i) - m_bndryCells->a[bndryId].m_coordinates[i];
      }
      for(MInt bndryId2 = 0; bndryId2 < noCells; bndryId2++) {
        if(m_bndryCells->a[bndryId2].m_srfcs[0]->m_bndryCndId == 1052) {
          MInt periodicCellId = m_bndryCells->a[bndryId2].m_cellId;
          for(MInt i = 0; i < nDim; i++) {
            coordinatesP[i] = m_solver->a_coordinate(periodicCellId, i) - m_bndryCells->a[bndryId2].m_coordinates[i];
          }
          if(fabs(coordinates[0] - coordinatesP[0]) < eps && fabs(coordinates[1] - coordinatesP[1]) < eps) {
            m_bndryCells->a[bndryId].m_periodicCellId = periodicCellId;
            m_bndryCells->a[bndryId2].m_periodicCellId = cellId;
            break;
          }
        }
      }
    }
  }
}

//--------------------------------------------------------------------------
/**
 * \fn FvBndryCndXD::bc1091
 * Subsonic laminar tube inflow boundary condition normal to the boundary \n
 * Set of variables: Standard PV \n
 * prescribes a constant stagnation pressure \n
 * density and pressure are computed according to massflux \n
 * velocity is computed according to massflux such that a parabolic profile is attained \n
 * only valid for circular tubes \n \n
 * multiple ghost cells can be handled but MGC formulation is not used
 * surface ghost cells can not be handled \n \n
 * no 2D version available
 * \author Claudia Guenther
 * \date June 2009, modified Mai 2010
 * \fvbc{FvBndryCndXD::bc1091(), fvbc1091, BC 1091}
 */

template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1091(MInt bcId) {
  IF_CONSTEXPR(nDim == 2) { TERMM(-1, "INFO: function bc1091 is untested for 2D!"); }
  TRACE();

  MInt cellId;
  MInt bndryId;
  MInt ghostCellId;
  MFloat R;
  MFloat massflux = F0;
  MFloat inflowArea = F0;
  MFloat pressure = F0;
  MFloat localVel = F0;
  MFloat density = F0;
  MFloat referencePoint[3] = {0.0, 0.0, 0.0};
  MFloat normal[3] = {0.0, 0.0, 0.0};
  MFloat radius = F0;
  MFloat velocity = F0;

  // --- end of initialization

  // compute current massflux, inflow area, reference Point and normal of the inflow area
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    cellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_cellId;
    bndryId = m_solver->a_bndryId(cellId);
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[m_sortedBndryCells->a[id]].m_noSrfcs; srfc++) {
        // search for surfaces which belong to the respective boundary condition
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == m_bndryCndIds[bcId]) {
          // compute massflux through the first cell layer
          massflux -= (((m_solver->a_pvariable(cellId, PV->U)) * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area
                            * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[0]
                        + (m_solver->a_pvariable(cellId, PV->V)) * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area
                              * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[1]
                        + (m_solver->a_pvariable(cellId, PV->W)) * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area
                              * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[2])
                       * (m_solver->a_pvariable(cellId, PV->RHO)));
          inflowArea += m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;

          // compute midpoint of inflow boundary and mean normal
          for(MInt i = 0; i < 3; i++) {
            referencePoint[i] += m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i]
                                 * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
            normal[i] += m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i]
                         * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
          }
        }
      }
    }
  }
  for(MInt i = 0; i < 3; i++) {
    referencePoint[i] /= inflowArea;
    normal[i] /= inflowArea;
  }

  // compute massflux per unit area
  massflux /= inflowArea;

  // compute static pressure and density iteratively (see e.g. thesis of Ingolf Hoerschler)
  pressure = sysEqn().p_Ref();
  for(MInt i = 0; i < 20; i++) {
    pressure = sysEqn().pressure_IRit(pressure, massflux);
  }
  pressure = pressure * sysEqn().p_Ref();
  density = sysEqn().density_IR_P(pressure);

  localVel = massflux / density;

  R = sqrt(inflowArea / PI);
  radius = F0;
  velocity = F0;

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    cellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_cellId;
    bndryId = m_solver->a_bndryId(cellId);
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[m_sortedBndryCells->a[id]].m_noSrfcs; srfc++) {
        // search for surfaces which belong to the respective boundary condition
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == m_bndryCndIds[bcId]) {
          ghostCellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_srfcVariables[srfc]->m_ghostCellId;

          // compute radius of the boundary surface and compute velocity according to parabolic profile
          radius = POW2(m_solver->a_coordinate(cellId, 0) - referencePoint[0])
                   + POW2(m_solver->a_coordinate(cellId, 1) - referencePoint[1])
                   + POW2(m_solver->a_coordinate(cellId, 2) - referencePoint[2]);
          velocity = 2.0 * localVel * (1 - radius / POW2(R));

          // set ghost cell variables such that p, rho, v_i are attained on the boundary surface; v is assumed to be
          // normal to the surface
          m_solver->a_pvariable(ghostCellId, PV->RHO) = F2 * density - m_solver->a_pvariable(cellId, PV->RHO);
          m_solver->a_pvariable(ghostCellId, PV->P) = F2 * pressure - m_solver->a_pvariable(cellId, PV->P);
          m_solver->a_pvariable(ghostCellId, PV->U) =
              -F2 * velocity * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[0]
              - m_solver->a_pvariable(cellId, PV->U);
          m_solver->a_pvariable(ghostCellId, PV->V) =
              -F2 * velocity * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[1]
              - m_solver->a_pvariable(cellId, PV->V);
          m_solver->a_pvariable(ghostCellId, PV->W) =
              -F2 * velocity * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[2]
              - m_solver->a_pvariable(cellId, PV->W);
        }
      }
    }
  }
}

/**
 * \fn FvBndryCndXD::bc1101
 * Subsonic inflow boundary condition for reactants. \n
 * Set of variables: Standard CV \n
 * u=v=w=IF;  rho=rhoIF;  dp/dn=0; Yi=Yi81
 * \fvbc{FvBndryCndXD::bc1101(), fvbc1101, BC 1101}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1101(MInt bcId) {
  IF_CONSTEXPR(nDim == 3) { TERMM(-1, "INFO: function bc1101 is untested for 3D!"); }

  TRACE();

  //----------------------------------------------------------------------------

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt bndryId = m_sortedBndryCells->a[id];
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;

      // density
      m_solver->a_variable(ghostCellId, CV->RHO) = F2 * m_solver->m_rhoInfinity - m_solver->a_variable(cellId, CV->RHO);
      const MFloat fRho = F1 / m_solver->a_variable(cellId, CV->RHO);

      // velocities
      m_solver->a_variable(ghostCellId, CV->RHO_VV[0]) =
          m_solver->a_variable(ghostCellId, CV->RHO)
          * (F2 * m_solver->m_UInfinity - m_solver->a_variable(cellId, CV->RHO_VV[0]) * fRho);

      m_solver->a_variable(ghostCellId, CV->RHO_VV[1]) =
          m_solver->a_variable(ghostCellId, CV->RHO)
          * (F2 * m_solver->m_VInfinity - m_solver->a_variable(cellId, CV->RHO_VV[1]) * fRho);

      MFloat rhoU =
          POW2(m_solver->a_variable(cellId, CV->RHO_VV[0])) + POW2(m_solver->a_variable(cellId, CV->RHO_VV[1]));
      IF_CONSTEXPR(nDim == 3) { rhoU += POW2(m_solver->a_variable(cellId, CV->RHO_VV[2])); }

      MFloat rhoUGC = POW2(m_solver->a_variable(ghostCellId, CV->RHO_VV[0]))
                      + POW2(m_solver->a_variable(ghostCellId, CV->RHO_VV[1]));
      IF_CONSTEXPR(nDim == 3) { rhoUGC += POW2(m_solver->a_variable(ghostCellId, CV->RHO_VV[2])); }
      // pressure
      const MFloat pressureBC =
          sysEqn().pressure(m_solver->a_variable(cellId, CV->RHO), rhoU, m_solver->a_variable(cellId, CV->RHO_E));

      const MFloat pressureGC = pressureBC;

      const MFloat vel = rhoUGC / POW2(m_solver->a_variable(ghostCellId, CV->RHO));

      m_solver->a_variable(ghostCellId, CV->RHO_E) =
          sysEqn().internalEnergy(pressureGC, m_solver->a_variable(ghostCellId, CV->RHO), vel);

      /*
      // species
      for( MInt i=0; i<noSpecies-1; i++ ) {
  m_solver->a_variable( ghostCellId ,  CV->RHO_Y[i] ) =
    m_solver->a_variable( ghostCellId ,  CV->RHO ) *
    ( F2 * m_Yi81[i] -
      m_solver->a_variable( cellId ,  CV->RHO_Y[ i ] ) * fRho );
      }
      */
    }
  }
}

/**
 * \fn FvBndryCndXD::bc1102
 * Subsonic outflow boundary condition for products. \n
 * Set of variables: Standard CV \n
 * du/dn=dv/dn=dw/dn=0;  drho/dn=0;  p=pIF;  Yi = Yi82 \n
 * \fvbc{FvBndryCndXD::bc1102(), fvbc1102, BC 1102}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1102(MInt bcId) {
  IF_CONSTEXPR(nDim == 3) { TERMM(-1, "INFO: function bc1102 is untested for 3D!"); }

  TRACE();

  // pressure loss from inflow to outflow
  const MFloat deltaP = 0.0;
  // 5.0 * m_solver->m_rhoInfinity * m_solver->m_UInfinity * m_solver->m_UInfinity;

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt bndryId = m_sortedBndryCells->a[id];
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;

      // density
      m_solver->a_variable(ghostCellId, CV->RHO) = m_solver->a_variable(cellId, CV->RHO);

      // momentum fluxes
      m_solver->a_variable(ghostCellId, CV->RHO_VV[0]) = m_solver->a_variable(cellId, CV->RHO_VV[0]);
      m_solver->a_variable(ghostCellId, CV->RHO_VV[1]) = m_solver->a_variable(cellId, CV->RHO_VV[1]);
      IF_CONSTEXPR(nDim == 3) {
        m_solver->a_variable(ghostCellId, CV->RHO_VV[2]) = m_solver->a_variable(cellId, CV->RHO_VV[2]);
      }

      MFloat rhoU =
          POW2(m_solver->a_variable(cellId, CV->RHO_VV[0])) + POW2(m_solver->a_variable(cellId, CV->RHO_VV[1]));
      IF_CONSTEXPR(nDim == 3) { rhoU += POW2(m_solver->a_variable(cellId, CV->RHO_VV[2])); }
      // pressure
      const MFloat pressureBC =
          sysEqn().pressure(m_solver->a_variable(cellId, CV->RHO), rhoU, m_solver->a_variable(cellId, CV->RHO_E));
      const MFloat pressureGC = F2 * (m_solver->m_PInfinity - deltaP) - pressureBC;
      const MFloat vel = rhoU / m_solver->a_variable(ghostCellId, CV->RHO);


      m_solver->a_variable(ghostCellId, CV->RHO_E) =
          sysEqn().internalEnergy(pressureGC, m_solver->a_variable(cellId, CV->RHO), vel);

      /*
      // species
      for( MInt i=0; i<noSpecies-1; i++ ) {
  m_solver->a_variable( ghostCellId ,  CV->RHO_Y[ i ] ) =
    m_solver->a_variable( ghostCellId ,  CV->RHO ) * fRho *
    m_solver->a_variable( cellId ,  CV->RHO_Y[ i ] );
      }
      */
    }
  }
}

/**
 * \fn FvBndryCndXD::bc1156
 * Cold/hot fuel/air coaxial jet (applied directly to the (boundary) cell) \n
 * Set of variables: Standard CV + passive scalar \n
 * u=v=w=IF; crocco-busemann relation rho=f(rhoIF);  dp/dn=0;  Z=1*rhoIF; \n
 * Seong et. al. Turbulence and heat excited noise sources in single and coaxial jets,2010 \n \n
 * 3D version
 * \author Onur Cetin
 * \date August, 2013 (3D)
 * \fvcutoffbc{FvBndryCndXD::bc1156(), fvbc1156, BC 1156}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1156(MInt bcId) {
  IF_CONSTEXPR(nDim == 2) { TERMM(-1, "INFO: function bc1156 is untested for 2D!"); }
  TRACE();

  MInt cellId;
  MInt nghbrId;
  MInt d = 0;
  MFloat radius;
  MFloat jet; //, profile_T;//radius2;
  // --- end of initialization

  switch(m_cutOffBndryCndIds[bcId]) {
    case 1156:
      d = 1;
      break;
    case 1166:
      d = 3;
      break;
    case 1176:
      d = 5;
      break;
    default: {
      stringstream errorMessage;
      errorMessage << "ERROR: Switch variable 'm_cutOffBndryCndIds[ bcId ]' with value " << m_cutOffBndryCndIds[bcId]
                   << " not matching any case." << endl;
      mTerm(1, AT_, errorMessage.str());
    }
  }
  // loop over all concerning cells
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    cellId = m_sortedCutOffCells[bcId]->a[id];
    nghbrId = m_solver->c_neighborId(cellId, d);
    // compute the radial position
    radius = F0;
    for(MInt i = 0; i < nDim; i++) {
      if(i != d / 2) radius += POW2(m_solver->a_coordinate(cellId, i));
    }
    radius = sqrt(radius);

    // Jet mean velocity profile
    jet = (F1 / 0.90 - F1) * F1B2 * (1 + tanh((m_primaryJetRadius - radius) / (2 * m_momentumThickness)))
          + F1B2 * (1 + tanh((m_secondaryJetRadius - radius) / (2 * m_momentumThickness)));

    // Set the velocities  [Choose 0.05 for momentum thickness ref: Bogey&Bailly]
    m_solver->a_pvariable(cellId, PV->VV[0]) = jet * m_targetVelocityFactor * m_targetVelocityFactor;
    m_solver->a_pvariable(cellId, PV->VV[1]) = F0;
    m_solver->a_pvariable(cellId, PV->VV[2]) = F0;
    if(radius <= m_primaryJetRadius) {
      // hot air jet
      //--------------
      // inflow mean density profile (Crocco-Buseman)
      m_solver->a_pvariable(cellId, PV->RHO) =
          m_solver->m_rhoInfinity * (1 / sysEqn().CroccoBusemann(m_Ma, jet)) / m_solver->m_densityRatio;
      // set the pressure of the ghost cell equal to that of the boundary cell
      m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
    } else if(radius <= m_secondaryJetRadius && m_primaryJetRadius <= radius) {
      // cold air jet
      //--------------
      // inflow mean density profile (Crocco-Buseman relation)
      //-----
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->m_rhoInfinity * (1 / sysEqn().CroccoBusemann(m_Ma, jet));
      // set the pressure of the ghost cell equal to that of the boundary cell
      m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
    }
    // else{
    // m_solver->a_pvariable( cellId ,  PV->P ) = m_solver->a_pvariable( nghbrId ,  PV->P );
    // m_solver->a_pvariable( cellId ,  PV->RHO ) = m_solver->m_rhoInfinity;
    // m_solver->a_pvariable( cellId ,  PV->VV[0] ) = F0;
    // m_solver->a_pvariable( cellId ,  PV->VV[1] ) = F0;
    // m_solver->a_pvariable( cellId ,  PV->VV[2] ) = F0;
    //}
  }
}

/**
 * \fn FvBndryCndXD::bc1601()
 * Random-eddy inflow boundary condition. \n
 * Set of variables: Standard CV \n
 * Eddies are generated according to Batten et al., AIAA J. 42(3), 485-492 (2004) \n
 * and inserted in +x direction \n \n
 * 3D version
 * \author Rudie Kunnen
 * \date Feb. 2010
 * \fvcutoffbc{FvBndryCndXD::bc1601(), fvbc1601, BC 1601}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1601(MInt bcId) {
  IF_CONSTEXPR(nDim == 2) { TERMM(-1, "INFO: function bc1601 is untested for 2D!"); }
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MFloat dummyTime;
  MFloat that;
  MFloat twopioverlb;

  MInt cellId;
  MInt nghbrId;
  MFloat xhat;
  MFloat yhat;
  MFloat zhat;
  MFloat spongeCorrection;
  MFloat fluctChol[3];

  dummyTime = m_solver->m_time / m_bc1601->m_tau_b;

  m_bc1601->checkRegeneration(dummyTime);

  that = 2.0 * PI * dummyTime;
  twopioverlb = 2.0 * PI / m_bc1601->m_l_b;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    cellId = m_sortedCutOffCells[bcId]->a[id];
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;

    nghbrId = m_solver->c_neighborId(cellId, 1); // neighbor in +x dir.

    xhat = twopioverlb * m_solver->a_coordinate(cellId, 0);
    yhat = twopioverlb * m_solver->a_coordinate(cellId, 1);
    zhat = twopioverlb * m_solver->a_coordinate(cellId, 2);

    m_bc1601->calculateFlucts(that, xhat, yhat, zhat, fluctChol);

    // correction factor for the sponge layer
    // so that fluctuations are reduced toward the edges in the sponge layer
    spongeCorrection = 1.0;
    if(m_solver->m_noSpongeFactors > 0) {
      spongeCorrection = 1.0 - m_solver->a_spongeFactor(cellId) * m_bc1601->m_invSigmaSponge;
    }

    m_solver->a_pvariable(cellId, PV->VV[0]) = m_solver->m_UInfinity + fluctChol[0] * spongeCorrection;
    m_solver->a_pvariable(cellId, PV->VV[1]) = m_solver->m_VInfinity + fluctChol[1] * spongeCorrection;
    m_solver->a_pvariable(cellId, PV->VV[2]) = m_solver->m_WInfinity + fluctChol[2] * spongeCorrection;

    // set the density
    m_solver->a_pvariable(cellId, PV->RHO) = m_solver->m_rhoInfinity;

    // extrapolate the pressure (dp/dn = 0)
    if(m_solver->checkNeighborActive(cellId, 1)) {
      nghbrId = m_solver->c_neighborId(cellId, 1);
      if(nghbrId < 0) {
        cutOffBcMissingNeighbor(cellId, "bc1601");
      } else {
        m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
      }
    } else {
      m_solver->a_pvariable(cellId, PV->P) = m_solver->m_PInfinity;
    }

    // species
    for(MInt s = 0; s < m_noSpecies; s++) {
      m_solver->a_pvariable(cellId, PV->Y[s]) = 1.0;
    }
  }
}


/**
 * \fn void FvBndryCndXD<nDim, SysEqn>::bcInit1601(MInt)
 * \brief Initialize bc1601
 * \author Rudie Kunnen
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bcInit1601(MInt bcId) {
  IF_CONSTEXPR(nDim == 2) { TERMM(-1, "INFO: function bcInit1601 is untested for 2D!"); }
  TRACE();

  // Store the boundary condition id (required if weighting of bc1601 is enabled since the actual boundary condition
  // using the bc1601-framework can vary)
  m_bc1601_bcId = bcId;

  // build MPI Communicator
  const MInt noBc1601Cells = m_sortedCutOffCells[bcId]->size();
  ScratchSpace<MInt> bc1601CellsPerDomain(noDomains(), AT_, "bc1601CellsPerDomain");


  MPI_Allgather(&noBc1601Cells, 1, MPI_INT, &bc1601CellsPerDomain[0], 1, MPI_INT, mpiComm(), AT_, "noBc1601Cells ",
                "bc1601CellsPerDomain");


  const MInt totalNoBc1601Cells = std::accumulate(&bc1601CellsPerDomain[0], &bc1601CellsPerDomain[0] + noDomains(), 0);
  m_log << "BC1601 inflow boundary total number of cells: " << totalNoBc1601Cells << std::endl;
  if(domainId() == 0) {
    std::cerr << "BC1601 inflow boundary total number of cells: " << totalNoBc1601Cells << std::endl;
  }

  MInt noInvolvedRanks = 0;
  ScratchSpace<MInt> involvedRanks(noDomains(), AT_, "involvedRanks");
  // Determine list of ranks with boundary cells
  for(MInt i = 0; i < noDomains(); i++) {
    if(bc1601CellsPerDomain[i] > 0) {
      involvedRanks[noInvolvedRanks] = i;
      ++noInvolvedRanks;
    }
  }

  MPI_Comm newcomm;
  MPI_Group group;
  MPI_Group newgroup;
  MPI_Comm_group(mpiComm(), &group, AT_, "group");
  MPI_Group_incl(group, noInvolvedRanks, &involvedRanks[0], &newgroup, AT_);

  MPI_Comm_create(mpiComm(), newgroup, &newcomm, AT_, "newcomm");

  MPI_Group_free(&group, AT_);
  MPI_Group_free(&newgroup, AT_);

  // if not involved, exit
  if(noBc1601Cells == 0) {
    return;
  }


  MFloat u_total = sysEqn().temperature_IR(m_solver->m_Ma);
  u_total = m_solver->m_Ma * sqrt(u_total);

  MFloat invSigmaSponge = 1.0;
  if(m_solver->m_noSpongeFactors > 0) {
    if(m_solver->m_sigmaSponge > 0.0) invSigmaSponge = 1.0 / m_solver->m_sigmaSponge;
  }

  if(m_bc1601 != nullptr) {
    delete m_bc1601;
  }

  // create instance

  m_bc1601 = new Bc1601Class<nDim>(newcomm, m_solverId, domainId(), u_total, invSigmaSponge);


  // Free memory

  /*! \page propertiesFV
\section bc1601MoveGenOutOfSponge
<code>MInt FvBndryCnd3D::m_bc1601MoveGenOutOfSponge </code>\n
default = <code> 0 (false) </code>\n
Moves the bc1601 by the spongeLayerThickness into the domain.
Keywords: <i>FINITE_VOLUME</i>
*/
  m_bc1601MoveGenOutOfSponge = false;
  m_bc1601MoveGenOutOfSponge =
      Context::getSolverProperty<MBool>("bc1601MoveGenOutOfSponge", m_solverId, AT_, &m_bc1601MoveGenOutOfSponge);
  if(m_bc1601MoveGenOutOfSponge) {
    MInt nghbrId;
    MInt noCellsToMove;
    //     noCellsToMove = 10;
    //     m_solver->c_cellLengthAtLevel( m_solver->a_level( cellId ) + 1 );
    noCellsToMove = ceil(m_spongeLayerThickness * m_spongeFactor[0]
                         / m_solver->c_cellLengthAtLevel(m_solver->maxRefinementLevel()));
    m_log << endl
          << "Move bc1601 by " << noCellsToMove << " rows into the domain, because of initial Sponge layer " << endl
          << endl;
    for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
      nghbrId = m_sortedCutOffCells[bcId]->a[id];
      for(MInt i = 0; i < noCellsToMove; i++) {
        nghbrId = m_solver->c_neighborId(nghbrId, 1); // neighbor in +x dir.
      }
      m_sortedCutOffCells[bcId]->a[id] = nghbrId;
    }
  }
}


/**
 * \fn FvBndryCndXD::bc1602()
 * Random-eddy inflow boundary condition. \n
 * Eddies are generated according to Batten et al., AIAA J. 42(3), 485-492 (2004) \n
 * and added to the velocity profile \n \n
 * 3D version for turbulent slot flame
 * \author Stephan Schlimpert
 * \date April 2014
 * \fvcutoffbc{FvBndryCndXD::bc1602(), fvbc1602, BC 1602}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1602(MInt bcId) {
  IF_CONSTEXPR(nDim == 2) { TERMM(-1, "INFO: function bc1602 is untested for 2D!"); }
  TRACE();

  MFloat dummyTime;
  MFloat that;
  MFloat twopioverlb;
  MFloat factor1;
  MFloat factor2;
  MFloat b1;
  MFloat b2;
  MInt ghost1;
  MInt in1;
  MFloat xhat;
  MFloat yhat;
  MFloat zhat;
  MFloat fluctChol[3];
  MFloat velocity = F0;
  MInt d = 3;
  b1 = m_shearLayerThickness;
  b2 = m_shearLayerThickness;
  MFloat massflux = F0;
  MFloat jetInflowArea = F0;

  if(((globalTimeStep - m_solver->m_restartTimeStep) <= 1 || globalTimeStep == 0) && !m_solver->m_restart) {
    m_log << "computing mass flux " << endl;

    for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
      ghost1 = m_sortedCutOffCells[bcId]->a[id];
      if(m_solver->a_isHalo(ghost1)) continue;

      MFloat jetArea = POW2(m_solver->c_cellLengthAtCell(ghost1));
      factor1 = m_solver->a_coordinate(ghost1, 0);
      factor2 = m_solver->a_coordinate(ghost1, 2);

      velocity = m_solver->m_Ma
                 * (F1B2 * (1 + tanh(b1 * (factor1 + m_solver->m_jetHalfWidth)))
                        * (1 - tanh(b1 * (factor1 - m_solver->m_jetHalfWidth)))
                    - 1)
                 * (F1B2 * (1 + tanh(b2 * (factor2 + m_solver->m_jetHalfLength)))
                        * (1 - tanh(b2 * (factor2 - m_solver->m_jetHalfLength)))
                    - 1);
      massflux += m_solver->a_variable(ghost1, PV->RHO) * velocity * jetArea;
      jetInflowArea += jetArea;
    }
    MPI_Allreduce(MPI_IN_PLACE, &massflux, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "massflux");
    MPI_Allreduce(MPI_IN_PLACE, &jetInflowArea, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "jetInflowArea");


    // compute static pressure and density iteratively (see e.g. thesis of Ingolf Hoerschler)
    // compute massflux per unit area
    massflux /= jetInflowArea;
    m_solver->m_jetPressure = m_solver->m_PInfinity;
    m_solver->m_jetDensity = m_solver->m_rhoInfinity;
    m_solver->m_jetTemperature = sysEqn().temperature_ES(m_solver->m_jetDensity, m_solver->m_jetPressure);
    m_log << "calculated pressure" << m_solver->m_jetPressure << endl;
    m_log << "calculated density" << m_solver->m_jetDensity << endl;
    m_log << "calculated temperature at inflow " << m_solver->m_jetTemperature << endl;
    m_log << "calculated massflux" << massflux << endl;
  }
  //  MFloat FTInfinity = F1/m_solver->m_jetTemperature;

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  dummyTime = m_solver->m_time / m_bc1601->m_tau_b;

  m_bc1601->checkRegeneration(dummyTime);

  that = 2.0 * PI * dummyTime;
  twopioverlb = 2.0 * PI / m_bc1601->m_l_b;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    ghost1 = m_sortedCutOffCells[bcId]->a[id];
    in1 = m_solver->c_neighborId(ghost1, d);

    factor1 = m_solver->a_coordinate(ghost1, 0);
    factor2 = m_solver->a_coordinate(ghost1, 2);

    xhat = twopioverlb * m_solver->a_coordinate(ghost1, 0);
    yhat = twopioverlb * m_solver->a_coordinate(ghost1, 1);
    zhat = twopioverlb * m_solver->a_coordinate(ghost1, 2);
    fluctChol[0] = 0;
    fluctChol[1] = 0;
    fluctChol[2] = 0;
    m_bc1601->calculateFlucts(that, xhat, yhat, zhat, fluctChol);

    // correction factor for the sponge layer
    // so that fluctuations are reduced toward the edges in the sponge layer
    /*
    spongeCorrection = 1.0;
    if (m_solver->m_noSpongeFactors > 0)
      spongeCorrection = 1.0 - m_solver->a_spongeFactor(ghost1) * m_bc1601->m_invSigmaSponge;
    */

    // set variables in the cut-off cell at the desired value
    // NOT at the exact interface
    /*
    velocity = m_solver->m_jetConst[0]*pow(x,20);
    velocity +=m_solver->m_jetConst[1]*pow(x,19);
    velocity +=m_solver->m_jetConst[2]*pow(x,18);
    velocity +=m_solver->m_jetConst[3]*pow(x,17);
    velocity +=m_solver->m_jetConst[4]*pow(x,16);
    velocity +=m_solver->m_jetConst[5]*pow(x,15);
    velocity +=m_solver->m_jetConst[6]*pow(x,14);
    velocity +=m_solver->m_jetConst[7]*pow(x,13);
    velocity +=m_solver->m_jetConst[8]*pow(x,12);
    velocity +=m_solver->m_jetConst[9]*pow(x,11);
    velocity +=m_solver->m_jetConst[10]*pow(x,10);
    velocity +=m_solver->m_jetConst[11]*pow(x,9);
    velocity +=m_solver->m_jetConst[12]*pow(x,8);
    velocity +=m_solver->m_jetConst[13]*pow(x,7);
    velocity +=m_solver->m_jetConst[14]*pow(x,6);
    velocity +=m_solver->m_jetConst[15]*pow(x,5);
    velocity +=m_solver->m_jetConst[16]*pow(x,4);
    velocity +=m_solver->m_jetConst[17]*pow(x,3);
    velocity +=m_solver->m_jetConst[18]*pow(x,2);
    velocity +=m_solver->m_jetConst[19]*pow(x,1);
    velocity +=m_solver->m_jetConst[20];*/

    fluctChol[0] *= (F1B2 * (1 + tanh(b1 * (factor1 + m_solver->m_jetHalfWidth)))
                         * (1 - tanh(b1 * (factor1 - m_solver->m_jetHalfWidth)))
                     - 1);
    fluctChol[0] *= (F1B2 * (1 + tanh(b2 * (factor2 + m_solver->m_jetHalfLength)))
                         * (1 - tanh(b2 * (factor2 - m_solver->m_jetHalfLength)))
                     - 1);

    fluctChol[2] *= (F1B2 * (1 + tanh(b1 * (factor1 + m_solver->m_jetHalfWidth)))
                         * (1 - tanh(b1 * (factor1 - m_solver->m_jetHalfWidth)))
                     - 1);
    fluctChol[2] *= (F1B2 * (1 + tanh(b2 * (factor2 + m_solver->m_jetHalfLength)))
                         * (1 - tanh(b2 * (factor2 - m_solver->m_jetHalfLength)))
                     - 1);

    m_solver->a_pvariable(ghost1, PV->U) = F2 * fluctChol[0] - m_solver->a_pvariable(in1, PV->U);
    velocity = m_solver->m_Ma;

    m_solver->a_pvariable(ghost1, PV->V) = F2 * (velocity + fluctChol[1])
                                               * (F1B2 * (1 + tanh(b1 * (factor1 + m_solver->m_jetHalfWidth)))
                                                      * (1 - tanh(b1 * (factor1 - m_solver->m_jetHalfWidth)))
                                                  - 1)
                                               * (F1B2 * (1 + tanh(b2 * (factor2 + m_solver->m_jetHalfLength)))
                                                      * (1 - tanh(b2 * (factor2 - m_solver->m_jetHalfLength)))
                                                  - 1)
                                           - m_solver->a_pvariable(in1, PV->V);

    m_solver->a_pvariable(ghost1, PV->W) = F2 * fluctChol[2] - m_solver->a_pvariable(in1, PV->W);

    // extrapolate the pressure (dp/dn = 0)
    // set the pressure
    m_solver->a_pvariable(ghost1, PV->P) = m_solver->a_pvariable(in1, PV->P);

    // setting density
    m_solver->a_pvariable(ghost1, PV->RHO) = F2 * m_solver->m_jetDensity - m_solver->a_pvariable(in1, PV->RHO);

    IF_CONSTEXPR(hasPV_C<SysEqn>::value)
    if(m_combustion) {
      m_solver->a_pvariable(ghost1, PV->C) = F0; //-var[ in1 ][ PV->C ];
    }
  }
}


/**
 * \fn FvBndryCndXD::bc1603()
 * Random-eddy inflow boundary condition. \n
 * Eddies are generated according to Batten et al., AIAA J. 42(3), 485-492 (2004) \n
 * Mean velocity profile (tangential hyperbolic) is introduced \n \n
 * 3D version for turbulent round jet
 * \author Onur Cetin
 * \date April 2014
 * \fvcutoffbc{FvBndryCndXD::bc1603(), fvbc1603, BC 1603}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1603(MInt bcId) {
  IF_CONSTEXPR(nDim == 2) { TERMM(-1, "INFO: function bc1603 is untested for 2D!"); }
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MFloat that = 0;
  MFloat twopioverlb = 0;
  MFloat xhat;
  MFloat yhat;
  MFloat zhat;
  if(m_jetInletTurbulence) {
    const MFloat dummyTime = m_solver->m_time / m_bc1601->m_tau_b;
    m_bc1601->checkRegeneration(dummyTime);
    that = 2.0 * PI * dummyTime;
    twopioverlb = 2.0 * PI / m_bc1601->m_l_b;
  }
  MFloat fluctChol[3] = {0., 0., 0.};

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    const MInt nghbrId = m_solver->c_neighborId(cellId, 1); // neighbor in +x dir.
    const MFloat radius = sqrt(POW2(m_solver->a_coordinate(cellId, 1)) + POW2(m_solver->a_coordinate(cellId, 2)));

    // if (radius<=m_jetHeight){
    if(radius <= F1B2) { // TODO labels:FV
      if(m_jetInletTurbulence) {
        xhat = twopioverlb * m_solver->a_coordinate(cellId, 0);
        yhat = twopioverlb * m_solver->a_coordinate(cellId, 1);
        zhat = twopioverlb * m_solver->a_coordinate(cellId, 2);
        m_bc1601->calculateFlucts(that, xhat, yhat, zhat, fluctChol);
      }

      // TODO labels:FV
      m_solver->a_pvariable(cellId, PV->VV[0]) = F1B2 * m_Ma * (1 + tanh((radius) / (0.05))) + fluctChol[0];
      m_solver->a_pvariable(cellId, PV->VV[1]) = m_solver->m_VInfinity + fluctChol[1];
      m_solver->a_pvariable(cellId, PV->VV[2]) = m_solver->m_WInfinity + fluctChol[2];

      MFloat profil;
      profil = F1B2 * (1 + tanh((radius) / (0.05)));

      /* MFloat profil; */
      /* profil = F1B2*m_Ma* (1+tanh((m_jetHeight-radius)/(2*m_momentumThickness))); */
      /* // Set velocity profile with or without fluctuations */
      /* m_solver->a_pvariable(cellId, PV->VV[0]) = profil*m_Ma + fluctChol[0]; */
      /* m_solver->a_pvariable(cellId, PV->VV[1]) = m_solver->m_VInfinity + fluctChol[1]; */
      /* m_solver->a_pvariable(cellId, PV->VV[2]) = m_solver->m_WInfinity + fluctChol[2]; */

      // set the density Crocco-Buesemann relation
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->m_rhoInfinity * (1 / sysEqn().CroccoBusemann(m_Ma, profil));
      // extrapolate the pressure (dp/dn = 0)
      m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
    } else {
      m_solver->a_pvariable(cellId, PV->VV[0]) = F0;
      m_solver->a_pvariable(cellId, PV->VV[1]) = F0;
      m_solver->a_pvariable(cellId, PV->VV[2]) = F0;

      // set the density without Crocco-Buesemann relation
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->m_rhoInfinity;
      // extrapolate the pressure (dp/dn = 0)
      m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
    }
  }
}


/**
 * \fn FvBndryCndXD::bc1604()
 * Updated version of bc1603 with some fixes/improvements \n \n
 * TODO labels:FV,toenhance unify the two version/fix testcases
 * \fvcutoffbc{FvBndryCndXD::bc1604(), fvbc1604, BC 1604}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1604(MInt bcId) {
  TRACE();
  IF_CONSTEXPR(nDim == 2) { TERMM(-1, "INFO: function bc1604 is untested for 2D!"); }

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MFloat that = 0;
  MFloat twopioverlb = 0;
  MFloat xhat;
  MFloat yhat;
  MFloat zhat;
  if(m_jetInletTurbulence) {
    const MFloat dummyTime = m_solver->m_time / m_bc1601->m_tau_b;
    m_bc1601->checkRegeneration(dummyTime);
    that = 2.0 * PI * dummyTime;
    twopioverlb = 2.0 * PI / m_bc1601->m_l_b;
  }
  MFloat fluctChol[3] = {0.0, 0.0, 0.0};

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    const MInt nghbrId = m_solver->c_neighborId(cellId, 1); // neighbor in +x dir.
    if(nghbrId < 0) {
      cutOffBcMissingNeighbor(cellId, "bc1604");
      continue;
    }

    const MFloat radius = sqrt(POW2(m_solver->a_coordinate(cellId, 1)) + POW2(m_solver->a_coordinate(cellId, 2)));

    if(radius
       <= 1.5 * m_jetHeight) { // Note: was just m_jetHeight but jet profile has still a value of 0.5 at this position
      if(m_jetInletTurbulence) {
        xhat = twopioverlb * m_solver->a_coordinate(cellId, 0);
        yhat = twopioverlb * m_solver->a_coordinate(cellId, 1);
        zhat = twopioverlb * m_solver->a_coordinate(cellId, 2);
        m_bc1601->calculateFlucts(that, xhat, yhat, zhat, fluctChol);
      }

      const MFloat jet = 0.5 * (1.0 + tanh((m_jetHeight - radius) / (2 * m_momentumThickness)));

      // Set velocity profile with or without fluctuations
      m_solver->a_pvariable(cellId, PV->VV[0]) = jet * m_solver->m_VVInfinity[0] + fluctChol[0];
      m_solver->a_pvariable(cellId, PV->VV[1]) = m_solver->m_VVInfinity[1] + fluctChol[1];
      m_solver->a_pvariable(cellId, PV->VV[2]) = m_solver->m_VVInfinity[2] + fluctChol[2];

      // set the density Crocco-Buesemann relation
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->m_rhoInfinity / sysEqn().CroccoBusemann(m_Ma, jet);
      // extrapolate the pressure (dp/dn = 0)
      m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
    } else {
      m_solver->a_pvariable(cellId, PV->VV[0]) = F0;
      m_solver->a_pvariable(cellId, PV->VV[1]) = F0;
      m_solver->a_pvariable(cellId, PV->VV[2]) = F0;
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->m_rhoInfinity;
      // extrapolate the pressure (dp/dn = 0)
      m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
    }
  }
}


/**
 * \fn FvBndryCndXD::bc1606()
 * Random-eddy inflow boundary condition for chevron jet. \n
 * Eddies are generated according to Batten et al., AIAA J. 42(3), 485-492 (2004) \n
 * Mean velocity profile (tangential hyperbolic) is introduced
 * \author Vitali Pauz
 * \date July 2015
 * \fvcutoffbc{FvBndryCndXD::bc1606(), fvbc1606, BC 1606}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1606(MInt bcId) {
  TRACE();
  IF_CONSTEXPR(nDim == 2) { TERMM(1, "bc1606 not useful in 2D"); }

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MFloat fluctChol[3];

  const MFloat dummyTime = m_solver->m_time / m_bc1601->m_tau_b;
  m_bc1601->checkRegeneration(dummyTime);

  const MFloat that = 2.0 * PI * dummyTime;
  const MFloat twopioverlb = 2.0 * PI / m_bc1601->m_l_b;
  const MFloat jetTurbulence = (m_jetInletTurbulence) ? 1.0 : 0.0;
  const MFloat inletRadius = m_solver->m_inletRadius;
  const MFloat deltaMomentum = m_momentumThickness * inletRadius;

  const MFloat densityAmbient = m_solver->m_rhoInfinity;
  const MFloat density_i = m_solver->m_nozzleInletRho;

  // u(r) / u_i = jet = tanh((R-r)/2delta)
  const MFloat u_i = m_solver->m_nozzleInletU;
  const MFloat Ma_i = m_solver->m_maNozzleInlet;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    const MInt nghbrId = m_solver->c_neighborId(cellId, 1); // neighbor in +x dir.
    if(nghbrId < 0) {
      cutOffBcMissingNeighbor(cellId, "bc1606");
      continue;
    }

    const MFloat radius =
        sqrt(POW2(m_solver->a_coordinate(cellId, 1) - 0.0) + POW2(m_solver->a_coordinate(cellId, 2) - 0.0));

    if(radius <= inletRadius) {
      const MFloat xhat = twopioverlb * m_solver->a_coordinate(cellId, 0);
      const MFloat yhat = twopioverlb * m_solver->a_coordinate(cellId, 1);
      const MFloat zhat = twopioverlb * m_solver->a_coordinate(cellId, 2);

      m_bc1601->calculateFlucts(that, xhat, yhat, zhat, fluctChol);

      // velocity profile, zero at wall
      const MFloat jet = tanh((inletRadius - radius) / (2.0 * deltaMomentum));

      // Without Crocco-Busemann:
      // var[cellId][PV->RHO ]= density_i;

      // With Crocco-Busemann:
      m_solver->a_pvariable(cellId, PV->RHO) = density_i / sysEqn().CroccoBusemann(Ma_i, jet);
      // TODO labels:FV,toenhance scale u/v/w fluctuations near the wall?
      m_solver->a_pvariable(cellId, PV->VV[0]) = u_i * jet + fluctChol[0] * jetTurbulence;
      m_solver->a_pvariable(cellId, PV->VV[1]) = fluctChol[1] * jetTurbulence;
      m_solver->a_pvariable(cellId, PV->VV[2]) = fluctChol[2] * jetTurbulence;

      // Extrapolate pressure
      m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
    } else {
      m_solver->a_pvariable(cellId, PV->VV[0]) = 0.0;
      m_solver->a_pvariable(cellId, PV->VV[1]) = 0.0;
      m_solver->a_pvariable(cellId, PV->VV[2]) = 0.0;

      m_solver->a_pvariable(cellId, PV->RHO) = densityAmbient;

      // extrapolate the pressure (dp/dn = 0)
      m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
    }
  }
}


/**
 * \fn FvBndryCndXD::bc1792()
 * Subsonic inflow in a rotating frame of reference
 * \author Alexej Pogorelov
 * \fvcutoffbc{FvBndryCndXD::bc1792(), fvbc1792, BC 1792}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1792(MInt bcId) {
  IF_CONSTEXPR(nDim == 2) { TERMM(-1, "INFO: function bc1792 is untested for 2D!"); }
  TRACE();

  MFloat radius_1;
  MFloat phi_1;
  MInt cellId;
  MInt d;
  MInt nghbrId;

  d = 1;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    cellId = m_sortedCutOffCells[bcId]->a[id];


    nghbrId = m_solver->c_neighborId(cellId, d);

    radius_1 = sqrt((m_solver->a_coordinate(cellId, 1) - 200.0) * (m_solver->a_coordinate(cellId, 1) - 200.0)
                    + (m_solver->a_coordinate(cellId, 2) - 200.0) * (m_solver->a_coordinate(cellId, 2) - 200.0));
    if((m_solver->a_coordinate(cellId, 1) - 200.0) >= 0 && (m_solver->a_coordinate(cellId, 2) - 200.0) >= 0) {
      phi_1 = asin((m_solver->a_coordinate(cellId, 1) - 200.0) / radius_1);
    } else if((m_solver->a_coordinate(cellId, 1) - 200.0) >= 0 && (m_solver->a_coordinate(cellId, 2) - 200.0) < 0) {
      phi_1 = PI - asin((m_solver->a_coordinate(cellId, 1) - 200.0) / radius_1);
    } else if((m_solver->a_coordinate(cellId, 1) - 200.0) < 0 && (m_solver->a_coordinate(cellId, 2) - 200.0) < 0) {
      phi_1 = PI - asin((m_solver->a_coordinate(cellId, 1) - 200.0) / radius_1);
    } else {
      phi_1 = 2 * PI + asin((m_solver->a_coordinate(cellId, 1) - 200.0) / radius_1);
    }


    m_solver->a_pvariable(cellId, PV->U) = m_solver->m_UInfinity;
    m_solver->a_pvariable(cellId, PV->V) = m_solver->m_VInfinity * cos(phi_1) / 29.0 * radius_1;
    m_solver->a_pvariable(cellId, PV->W) = -m_solver->m_VInfinity * sin(phi_1) / 29.0 * radius_1;

    m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
    m_solver->a_pvariable(cellId, PV->RHO) = m_solver->m_rhoInfinity;
  }
}
/** \brief Subsonic outflow boundary condition (applied directly to the (boundary) cell).
 *        Set of variables: Standard CV + passive scalar
 *        du/dn=dv/dn=dw/dn=0;  drho/dn=0;  p=pIF;  dZ/dn=0
 *
 * 3D version
 * \author Daniel Hartmann
 * \date November 11, 2006 (3D)
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1952(MInt bcId) {
  IF_CONSTEXPR(nDim == 2) { TERMM(-1, "INFO: function bc1952 is untested for 2D!"); }
  TRACE();

  MInt cellId;
  MInt nghbrId;
  MInt d = 0;
  //---

  switch(m_cutOffBndryCndIds[bcId]) {
    case 1952:
      d = 0;
      break;
    case 1972:
      d = 4;
      break;
    default: {
      stringstream errorMessage;
      errorMessage << "ERROR: Switch variable 'm_cutOffBndryCndIds[ bcId ]' with value " << m_cutOffBndryCndIds[bcId]
                   << " not matching any case." << endl;
      mTerm(1, AT_, errorMessage.str());
    }
  }

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    cellId = m_sortedCutOffCells[bcId]->a[id];
    nghbrId = m_solver->c_neighborId(cellId, d);

    // zero-gradient density
    m_solver->a_pvariable(cellId, PV->RHO) = m_solver->a_pvariable(nghbrId, PV->RHO);

    // zero-gradient velocity
    for(MInt i = 0; i < nDim; i++) {
      m_solver->a_pvariable(cellId, PV->VV[i]) = m_solver->a_pvariable(nghbrId, PV->VV[i]);
    }

    // set the pressure
    m_solver->a_pvariable(cellId, PV->P) = m_solver->m_PInfinity;

    // zero-gradient species
    for(MInt s = 0; s < m_noSpecies; s++) {
      m_solver->a_pvariable(cellId, PV->Y[s]) = m_solver->a_pvariable(nghbrId, PV->Y[s]);
    }
  }
}


/**
 * \fn FvBndryCndXD::bc2700
 * Supersonic inflow with imposed acoustic or entropy waves
 * \author Thomas Schilden
 * \date 12.2.2015
 * \fvcutoffbc{FvBndryCndXD::bc2700(), fvbc2700, BC 2700}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc2700(MInt bcId) {
  TRACE();

#ifdef _OPENMP
#pragma omp parallel for
#endif
  // set mean flow values
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    // density
    m_solver->a_pvariable(cellId, PV->RHO) = m_solver->m_rhoInfinity;
    // velocities
    for(MInt dim = 0; dim < m_solver->nDim; dim++) {
      m_solver->a_pvariable(cellId, PV->VV[dim]) = m_solver->m_VVInfinity[dim];
    }
    // pressure
    m_solver->a_pvariable(cellId, PV->P) = m_solver->m_PInfinity;
  }

  // add the modes
  if(m_besselModes) {
    // time ist constant during the rk steps, we only need to integrate once
    if(!m_solver->m_RKStep) {
      precomputeBesselTrigonometry(bcId);
    }
    // add the modes using the precomputed bessel fractions
    addBesselModes(bcId);
  } else {
    addModes(bcId);
  }
}


/**
 * \fn void FvBndryCndXD<nDim, SysEqn>::bcInit2700(MInt)
 * \brief init for the acoustic and entropy waves
 * \version: init for cut-off boundary condition
 * \author: Thomas Schilden, 12.2.2015
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bcInit2700(MInt bcId) {
  TRACE();

  /*! \page propertiesFV
    \section besselModes
    <code>MInt FvCartesianSolver::m_besselModes </code>\n
    default = <code> 0 </code>\n
    switches from plane incident waves to oblique axisymmetric waves \n \n
    possible values are:
    <ul>
    <li> 1 is yes(bessel), 0 is no(plane)</li>
    </ul>
    Keywords: <i>RECEPTIVITY, TUNNEL NOISE, </i>
  */
  m_besselModes = Context::getSolverProperty<MInt>("besselModes", m_solverId, AT_, &m_besselModes);

  if(m_besselModes) {
    initBesselModes(bcId);
  } else {
    initModes(bcId);
  }
}


/**
 * \fn void FvBndryCndXD<nDim, SysEqn>::bcInit2770()
 * \brief supersonic inflow with imposed onlique shock wave and linear waves
 * version: cut-off boundary condition
 * author: Thomas Schilden, 7.3.2016
 *
 * a boundary shock region within the cut off cells is created. In this region
 * we impose an oblique shock wave. Therefore we allocate memory to store a
 * solution that is copied to these cells every timestep. There are three possible
 * solutions:
 * 1. linear blending between up- and downstream values, restartfile = 0
 * 2. solution from an inner shock region, shockFromInnerSolution = 1, restartFile = 1
 * 3. solution from the boundary shock region, shockFromInnerSolution = 0, restartFile = 1
 *
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bcInit2770(MInt bcId) {
  TRACE();
  m_log << endl << "bcInit2770 for bcId " << bcId << endl;
  // read bc2770 properties

  /*! \page propertiesFV
    \section noShockBcCells
    <code> MInt FvBndryCndXD::m_noShockBcCells></code> \n
    default = <code>21</code>\n \n
    Number of cells for the shock solution at the boundary, in BC-2770.
    <ul>
    <li>Any integer number</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, BOUNDARY CONDITION</i>
   */

  // number of cells for the shock solution at the boundary
  m_noShockBcCells = 21;
  m_noShockBcCells = Context::getSolverProperty<MInt>("noShockBcCells", m_solverId, AT_, &m_noShockBcCells);

  /*! \page propertiesFV
   \section shockFromInnerSolution
   <code> MBool FvBndryCndPar::m_shockFromInnerSolution </code>  \n
   default = <code>"0"</code>\n \n
   Triggers whether the solution is copied from an inner shock region (=1) or the boundary shock region (=0) at cut off
   cells with shock regions. <ul> <li>0 or 1 (false or true)</li>
   </ul>
   Keywords: <i>FINITE_VOLUME, BOUNDARY CONDITION</i>
  */

  // number of cells for the shock solution at the boundary
  m_shockFromInnerSolution = false;
  m_shockFromInnerSolution =
      Context::getSolverProperty<MBool>("shockFromInnerSolution", m_solverId, AT_, &m_shockFromInnerSolution);

  /*! \page propertiesFV
    \section sigmaShock
    <code>MFloat FvBndryCnd2/3D::m_sigmaShock </code>\n
    default = <code>none</code>\n
    Defines the value of the shock angle at the boundary in [deg].\n
    Possible values are:
    <ul>
    <li>Values between asin(1/Ma)/PI*180.0 deg (Mach angle) and 90.0 deg</li>
    </ul>
    Keywords: <i>FINITE VOLUME, BOUNDARY CONDITION, SHOCK WAVE</i>
  */
  // shock angle, see fluidmechanics lecture notes
  m_sigmaShock = Context::getSolverProperty<MFloat>("sigmaShock", m_solverId, AT_, &m_sigmaShock);
  m_sigmaShock *= PI / 180.0;

  // y-location of shock position at the boundary
  /*! \page propertiesFV
    \section ys
    <code>MFloat FvBndryCnd2/3D::m_ys </code>\n
    default = <code>none</code>\n
    y-coordinate of an oblique shock wave imposed at the boundary of the domain.\n
    Possible values are:
    <ul>
      <li>values within the y-range of the domain </li>
    </ul>
    Keywords: <i>FINITE VOLUME, BOUNDARY CONDITION, SHOCK WAVE</i>
  */
  m_ys = Context::getSolverProperty<MFloat>("ys", m_solverId, AT_);

  MFloat srf = F4;
  /*! \page propertiesFV
    \section srf
    <code>MFloat FvBndryCndXD::m_srf </code>\n
    default = <code>4</code>\n
    shock region factor defining the compression factor from the analytic shock to m_noShockBcCells cells. \n
    srf = 1 is all over m_noShockBcCells, srf = 2 is m_noShockBcCells/2 and so on. \n
    Possible values are:
    <ul>
      <li>any positive value</li>
    </ul>
    Keywords: <i>FINITE VOLUME, BOUNDARY CONDITION, SHOCK WAVE</i>
  */

  srf = Context::getSolverProperty<MFloat>("srf", m_solverId, AT_, &srf);
  MInt dom = -1;
  MIntScratchSpace tmpTargetCells(m_noShockBcCells, AT_, "tmpTargetCells");
  tmpTargetCells.fill(-1);
  MFloatScratchSpace tmpTargetCoords(nDim, AT_, "tmpTargetCoords");
  MFloatScratchSpace tmpSrcVars(m_noShockBcCells, PV->noVariables, AT_, "tmpSrcVars");
  tmpSrcVars.fill(-std::numeric_limits<MFloat>::max());

  // find the cell on the boundary at the upper shock region border
  //(m_ys + m_noShockBcCells/2 * cellLength)
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    const MFloat cellLength = m_solver->c_cellLengthAtCell(cellId);
    // skip halos
    if(m_solver->a_isHalo(cellId)) {
      continue;
    }
    if(m_solver->a_coordinate(cellId, 1) + cellLength / F2 >= m_ys + m_noShockBcCells / 2 * cellLength
       && m_solver->a_coordinate(cellId, 1) - cellLength / F2 < m_ys + m_noShockBcCells / 2 * cellLength) {
      dom = domainId();
      tmpTargetCells[0] = cellId;
      for(MInt dim = 0; dim < nDim; dim++) {
        tmpTargetCoords[dim] = m_solver->a_coordinate(cellId, dim);
      }
      break;
    }
  }

  // communicate the upper shock region border
  MPI_Allreduce(MPI_IN_PLACE, &dom, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "dom");
  MPI_Bcast(tmpTargetCoords.begin(), nDim, MPI_DOUBLE, dom, mpiComm(), AT_, "tmpTargetCoords.begin()");

  // save the cell ids in the boundary shock region of every domain
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    const MFloat cellLength = m_solver->c_cellLengthAtCell(cellId);

    if(m_solver->a_isHalo(cellId)) { // TODO labels:FV,totest Stephan says I need to set the bc at halo cells, check!
      continue;
    }

    MFloat y_coord = tmpTargetCoords[1];
    for(MInt i = 1; i < m_noShockBcCells; i++) {
      y_coord -= cellLength;
      if(m_solver->a_coordinate(cellId, 1) + cellLength / F2 >= y_coord
         && m_solver->a_coordinate(cellId, 1) - cellLength / F2 < y_coord) {
        tmpTargetCells[i] = cellId;
      }
    }
  }

  // save a shock solution for the boundary shock region
  if(m_solver->m_restart) {
    if(m_shockFromInnerSolution) {
      m_log << "using shock solution from inside of the domain" << endl;
      // get the solution from the inner shock region
      MFloatScratchSpace tmpSrcCoords(nDim, AT_, "tmpSrcCoords");
      tmpSrcCoords[0] = tmpTargetCoords[0]
                        + 0.8; // TODO labels:FV,toenhance distance is hardcoded, is there a min/max cell value to use?
      tmpSrcCoords[1] = tmpTargetCoords[1] + (tan(m_solver->m_angle[0] + m_sigmaShock) * 0.8);
      for(MInt id = 0; id < m_solver->noInternalCells(); id++) {
        const MFloat cellLength = m_solver->c_cellLengthAtCell(id);
        if(m_solver->c_noChildren(id) > 0) {
          continue;
        }
        MFloat y_src_coord = tmpSrcCoords[1];
        for(MInt i = 0; i < m_noShockBcCells; i++) {
          if(m_solver->a_coordinate(id, 0) + cellLength / F2 >= tmpSrcCoords[0]
             && m_solver->a_coordinate(id, 0) - cellLength / F2 < tmpSrcCoords[0]
             && m_solver->a_coordinate(id, 1) + cellLength / F2 >= y_src_coord
             && m_solver->a_coordinate(id, 1) - cellLength / F2 < y_src_coord) {
            // density
            tmpSrcVars(i, PV->RHO) = m_solver->a_pvariable(id, PV->RHO);
            // velocities
            for(MInt dim = 0; dim < m_solver->nDim; dim++) {
              tmpSrcVars(i, PV->VV[dim]) = m_solver->a_pvariable(id, PV->VV[dim]);
            }
            // pressure
            tmpSrcVars(i, PV->P) = m_solver->a_pvariable(id, PV->P);
          }
          MFloat y_src = y_src_coord - cellLength;
          y_src_coord = y_src;
        }
      }
      // communicate the shock solution in the inner shock region
      MPI_Allreduce(MPI_IN_PLACE, tmpSrcVars.begin(), m_noShockBcCells * PV->noVariables, MPI_DOUBLE, MPI_MAX,
                    mpiComm(), AT_, "MPI_IN_PLACE", "tmpSrcVars.begin()");

    } else {
      m_log << "using shock solution from the inlet boundary of the domain" << endl;
      // get the solution from the boundary shock region
      for(MInt i = 0; i < m_noShockBcCells; i++) {
        const MInt cellId = tmpTargetCells[i];
        if(cellId != -1) {
          // density
          tmpSrcVars(i, PV->RHO) = m_solver->a_pvariable(cellId, PV->RHO);
          // velocities
          for(MInt dim = 0; dim < m_solver->nDim; dim++) {
            tmpSrcVars(i, PV->VV[dim]) = m_solver->a_pvariable(cellId, PV->VV[dim]);
          }
          // pressure
          tmpSrcVars(i, PV->P) = m_solver->a_pvariable(cellId, PV->P);
        }
      }
    }
  } else {
    m_log << "using analytic shock solution" << endl;
    // if we are not restarting, blend between up and downstream of the shock
    // calculate the flow downstream of the shock, see fluidmechanics lecture notes
    const MFloat gamma = sysEqn().gamma_Ref();
    const MFloat gammaPlusOne = gamma + F1;
    const MFloat gammaMinusOne = gamma - F1;
    const MFloat Ma = m_solver->m_Ma;
    const MFloat Ma_ns = POW2(Ma * sin(m_sigmaShock));
    const MFloat fact_pressure = F1 + (F2 * gamma / gammaPlusOne) * (Ma_ns - F1);
    const MFloat fact_density = (gammaPlusOne * Ma_ns) / (gammaMinusOne * Ma_ns + F2);
    // rotate the velocities into the shock aligned coordinate system
    const MFloat angle = PI / F2 - m_sigmaShock;
    const MFloat un1 = m_solver->m_VVInfinity[0] * cos(angle) - m_solver->m_VVInfinity[1] * sin(angle);
    const MFloat ut1 = m_solver->m_VVInfinity[0] * sin(angle) + m_solver->m_VVInfinity[1] * cos(angle);
    // apply the shock conditions
    const MFloat un2 = un1 / fact_density;
    const MFloat ut2 = ut1;
    // rotate the velocities back to cartesian coordinate system
    const MFloat ux2 = un2 * cos(angle) + ut2 * sin(angle);
    const MFloat uy2 = -un2 * sin(angle) + ut2 * cos(angle);
    // check the mach number downstream for supersonic flow
    const MFloat a2 =
        sysEqn().speedOfSound(m_solver->m_rhoInfinity * fact_density, m_solver->m_PInfinity * fact_pressure);
    m_log << "Ma_2x = " << ux2 / a2 << ", Ma_2y = " << uy2 / a2 << endl;
    //    if(ux2/a2 <= F1 || uy2/a2 <= F1)
    //      mTerm(1, AT_, "bc2770: downstream supersonic assumptions are violated");
    // set the variables
    for(MInt i = 0; i < m_noShockBcCells; i++) {
      // however i want to blend, F0 is upstream and F1 is downstream
      // srf (shock region factor): how much do i want to compress my analytic shock into the m_noShockBcCells cells
      // srf = 1 is all over m_noShockBcCells, srf = 2 is m_noShockBcCells/2 and so on
      MFloat fb = mMax(mMin(((MFloat)i / (m_noShockBcCells - 1) - F1B2) * srf, F1B2), -F1B2) + F1B2;
      m_log << "fb ( " << i << ") = " << fb << endl;

      // density
      tmpSrcVars(i, PV->RHO) = m_solver->m_rhoInfinity * ((F1 - fb) + fb * fact_density);
      // velocities
      tmpSrcVars(i, PV->VV[0]) = (F1 - fb) * m_solver->m_VVInfinity[0] + fb * ux2;
      tmpSrcVars(i, PV->VV[1]) = (F1 - fb) * m_solver->m_VVInfinity[1] + fb * uy2;
      // pressure
      tmpSrcVars(i, PV->P) = m_solver->m_PInfinity * ((F1 - fb) + fb * fact_pressure);
    }
  }

  // count the cells in the boundary shock region of this domain
  MInt noShockBcCellsInDomain = 0;
  for(MInt i = 0; i < m_noShockBcCells; i++) {
    if(tmpTargetCells[i] != -1) {
      noShockBcCellsInDomain++;
    }
  }

  // allocate permanent memory for the boundary shock region
  mAlloc(m_Bc2770TargetCells, noShockBcCellsInDomain, "Bc2770TargetCells", AT_);
  mAlloc(m_shockBcVars, noShockBcCellsInDomain, PV->noVariables, "m_shockBcVars", AT_);

  // fill the permanent memory
  MInt k = 0;
  for(MInt i = 0; i < m_noShockBcCells; i++) {
    if(tmpTargetCells[i] != -1) {
      m_Bc2770TargetCells[k] = tmpTargetCells[i];
      for(MInt var = 0; var < PV->noVariables; var++) {
        m_shockBcVars[k][var] = tmpSrcVars(i, var);
      }
      k++;
    }
  }
  m_noShockBcCells = noShockBcCellsInDomain;

  initModes(bcId);

  m_log << "initialization of bc2770 done" << endl;
}


/**
 * \fn FvBndryCndXD::bc2710()
 * Simple extrapolation of all variables
 * \author: Thomas Schilden
 * \date 10.1.2014
 * \fvcutoffbc{FvBndryCndXD::bc2710(), fvbc2710, BC 2710}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc2710(MInt bcId) {
  TRACE();

  MInt direction = m_cutOffBndryCndIds[bcId] - 2710;

  if(direction % 2) {
    direction--;
  } else {
    direction++;
  }

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    if(m_solver->a_hasProperty(cellId, SolverCell::IsPeriodicWithRot)) {
      continue;
    }
    MLong nghbrId = m_solver->c_neighborId(cellId, direction);

    if(nghbrId < 0) {
      continue;
    }
    if(m_solver->c_noChildren(nghbrId) > 0) {
      MFloat coCoord = m_solver->a_coordinate(cellId, direction / 2);
      MInt childCnt = 0;
      // reset cut off cell
      for(MInt i = 0; i < PV->noVariables; i++) {
        m_solver->a_pvariable(cellId, i) = F0;
      }
      // use parents neighbours childs, but only the close ones, should be four
      for(MInt child = 0; child < IPOW2(nDim); child++) {
        MLong childId = m_solver->c_childId(nghbrId, child);
        if(childId < 0) {
          continue;
        }
        if(abs(m_solver->a_coordinate(childId, direction / 2) - coCoord) > m_solver->c_cellLengthAtCell(cellId)) {
          continue;
        }
        childCnt++;
        for(MInt i = 0; i < PV->noVariables; i++) {
          m_solver->a_pvariable(cellId, i) += m_solver->a_pvariable(childId, i);
        }
      }
      // divide by number of cells used
      for(MInt i = 0; i < PV->noVariables; i++) {
        m_solver->a_pvariable(cellId, i) /= (MFloat)childCnt;
      }
    } else {
      for(MInt i = 0; i < PV->noVariables; i++) {
        m_solver->a_pvariable(cellId, i) = m_solver->a_pvariable(nghbrId, i);
      }
    }
  }
}


/**
 * \fn FvBndryCndXD::bc2720()
 * Simple extrapolation of all variables, postshock pressure is set
 * \author Thomas Schilden
 * \date 10.1.2014
 * \fvcutoffbc{FvBndryCndXD::bc2720(), fvbc2720, BC 2720}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc2720(MInt bcId) {
  TRACE();

  MInt direction = m_cutOffBndryCndIds[bcId] - 2720;

  if(direction % 2) {
    direction--;
  } else {
    direction++;
  }

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    if(m_solver->a_hasProperty(cellId, SolverCell::IsPeriodicWithRot)) {
      continue;
    }
    MLong nghbrId = m_solver->c_neighborId(cellId, direction);

    if(nghbrId < 0) {
      continue;
    }
    if(m_solver->c_noChildren(nghbrId) > 0) {
      MFloat coCoord = m_solver->a_coordinate(cellId, direction / 2);
      MInt childCnt = 0;
      // reset cut off cell
      for(MInt i = 0; i < PV->noVariables; i++) {
        m_solver->a_pvariable(cellId, i) = F0;
      }
      // use parents neighbours childs, but only the close ones, should be four
      for(MInt child = 0; child < IPOW2(nDim); child++) {
        MLong childId = m_solver->c_childId(nghbrId, child);
        if(childId < 0) {
          continue;
        }
        if(abs(m_solver->a_coordinate(childId, direction / 2) - coCoord) > m_solver->c_cellLengthAtCell(cellId)) {
          continue;
        }
        childCnt++;
        for(MInt i = 0; i < PV->noVariables; i++) {
          m_solver->a_pvariable(cellId, i) += m_solver->a_pvariable(childId, i);
        }
      }
      // divide by number of cells used
      for(MInt i = 0; i < PV->noVariables; i++) {
        m_solver->a_pvariable(cellId, i) /= (MFloat)childCnt;
      }

      m_solver->a_pvariable(cellId, PV->P) = F2 * m_solver->m_postShockPV[PV->P] - m_solver->a_pvariable(cellId, PV->P);
    } else {
      for(MInt i = 0; i < PV->P; i++) {
        m_solver->a_pvariable(cellId, i) = m_solver->a_pvariable(nghbrId, i);
      }

      m_solver->a_pvariable(cellId, PV->P) =
          F2 * m_solver->m_postShockPV[PV->P] - m_solver->a_pvariable(nghbrId, PV->P);

      for(MInt i = PV->P + 1; i < PV->noVariables; i++) {
        m_solver->a_pvariable(cellId, i) = m_solver->a_pvariable(nghbrId, i);
      }
    }
  }
}

/**
 * \fn FvBndryCndXD::bc2907
 * Coflow bc \n
 * Set of variables: Standard CV \n
 * u=w=0, v= v_coflow; drho/dn=dp/dn=0;
 * \fvbc{FvBndryCndXD::bc2907(), fvbc2907, BC 2907}
 */

template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc2907(MInt bcId) {
  IF_CONSTEXPR(nDim == 2) { TERMM(-1, "INFO: function bc2907 is untested for 2D!"); }
  TRACE();

  MInt cellId;
  MInt bndryId;
  MInt ghostCellId;
  MFloat TInfinity = m_solver->m_TInfinity;
  if(m_combustion) TInfinity = m_solver->m_burntUnburntTemperatureRatio;

  //---end of initialization

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    bndryId = m_sortedBndryCells->a[id];
    cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;

      // set the velocities
      if(abs(m_solver->a_coordinate(cellId, 0)) >= m_solver->m_jetCoflowOffset
         && // jet radius R = 0.5 + 0.125 distance = 0.625to coflow
         abs(m_solver->a_coordinate(cellId, 0)) <= m_solver->m_jetCoflowEndOffset
         && // jet radius R = 0.5 + 0.125 distance = 0.625to coflow
         abs(m_solver->a_coordinate(cellId, 2)) <= m_solver->m_jetHalfLength) { // half jet length L = 8.33/2

        m_solver->a_pvariable(ghostCellId, PV->V) = F2 * m_solver->m_MaCoflow - m_solver->a_pvariable(cellId, PV->V);
        m_solver->a_pvariable(ghostCellId, PV->U) = -m_solver->a_pvariable(cellId, PV->U);
        m_solver->a_pvariable(ghostCellId, PV->W) = -m_solver->a_pvariable(cellId, PV->W);

        // set the pressure
        m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);
        // changed to dirichlet bc
        //    m_solver->a_pvariable( ghostCellId ,  PV->RHO ) = F2*CV->m_rhoInfinity -
        //    m_solver->a_pvariable( cellId ,  PV->RHO );
        // compute the density from inside of the domain using the pressure
        m_solver->a_pvariable(ghostCellId, PV->RHO) =
            sysEqn().density_ES(m_solver->a_pvariable(cellId, PV->P), TInfinity);

        // set the species
        for(MInt s = 0; s < m_noSpecies; s++) {
          m_solver->a_pvariable(ghostCellId, PV->Y[s]) = m_solver->a_pvariable(cellId, PV->Y[s]);
        }

      } else {
        m_solver->a_pvariable(ghostCellId, PV->V) = -m_solver->a_pvariable(cellId, PV->V);
        m_solver->a_pvariable(ghostCellId, PV->U) = -m_solver->a_pvariable(cellId, PV->U);
        m_solver->a_pvariable(ghostCellId, PV->W) = -m_solver->a_pvariable(cellId, PV->W);

        /// set adiabtic wall
        // set the density
        m_solver->a_pvariable(ghostCellId, PV->RHO) = m_solver->a_pvariable(cellId, PV->RHO);

        m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);

        // set the species
        for(MInt s = 0; s < m_noSpecies; s++) {
          m_solver->a_pvariable(ghostCellId, PV->Y[s]) = m_solver->a_pvariable(cellId, PV->Y[s]);
        }
      }
    }
  }
}

/**
 * \fn FvBndryCndXD::bc3006()
 * Moving wall Navier-Stokes boundary condition.
 * \author Lennart Schneiders
 * \fvbc{FvBndryCndXD::bc3006(), fvbc3006, BC 3006}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc3006(MInt bcId) {
  TRACE();

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    MInt bndryId = m_sortedBndryCells->a[id];
    MInt cellId = m_bndryCells->a[bndryId].m_cellId;

    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
        if(ghostCellId < 0 && ghostCellId >= m_solver->a_noCells()) {
          mTerm(1, AT_, "Ghost cell: " + to_string(ghostCellId));
        }
        MInt k = m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bodyId[0];
        ASSERT(k > -1 && k < m_solver->m_noEmbeddedBodies + m_solver->m_noPeriodicGhostBodies, "");
        if(k < 0 || k >= m_solver->m_noEmbeddedBodies + m_solver->m_noPeriodicGhostBodies) {
          mTerm(1, AT_, "Invalid body id: " + to_string(k));
        }


        MFloat vel[3] = {0.0, 0.0, 0.0};
        for(MInt i = 0; i < nDim; i++) {
          vel[i] = m_solver->m_bodyVelocity[k * nDim + i];
        }

        MFloat dx[3]{};
        MFloat omega[3]{};
        MFloat vrad[3]{};
        MFloat dn = 0;
        for(MInt i = 0; i < nDim; i++) {
          dn += m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i]
                * (m_solver->a_coordinate(cellId, i) - m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i]);
        }
        for(MInt i = 0; i < nDim; i++) {
          dx[i] = m_solver->a_coordinate(cellId, i) - dn * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i]
                  - m_solver->m_bodyCenter[k * nDim + i];
        }
        for(MInt i = 0; i < 3; i++) {
          omega[i] = m_solver->m_bodyAngularVelocity[k * 3 + i];
        }
        vrad[0] = omega[1] * dx[2] - omega[2] * dx[1];
        vrad[1] = omega[2] * dx[0] - omega[0] * dx[2];
        IF_CONSTEXPR(nDim == 3) vrad[2] = omega[0] * dx[1] - omega[1] * dx[0];

        for(MInt i = 0; i < nDim; i++) {
          vel[i] += vrad[i];
        }

        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_pvariable(ghostCellId, PV->VV[i]) = F2 * vel[i] - m_solver->a_pvariable(cellId, PV->VV[i]);
        }

        IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
          for(MInt r = 0; r < m_solver->m_noRansEquations; r++) {
            m_solver->a_pvariable(ghostCellId, PV->NN[r]) = -m_solver->a_pvariable(cellId, PV->NN[r]);
          }
        }


        for(MInt s = 0; s < m_noSpecies; s++) {
          m_solver->a_pvariable(ghostCellId, PV->Y[s]) = m_solver->a_pvariable(cellId, PV->Y[s]);
        }
      }
    }
  }

  // gap-Cell correction!
  if(m_solver->m_closeGaps && !m_solver->m_gapCells.empty()) {
    // update of nearGap-Cells with secondBody-Id!
    setGapGhostCellVariables(bcId);
  }
}

/** \brief update ghostCell variables for gap-Cells
 *  \author Claudia Guenther
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::setGapGhostCellVariables(MInt bcId) {
  TRACE();

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt bndryId = m_sortedBndryCells->a[id];
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;

    if(!m_solver->a_isGapCell(cellId)) continue;
    // if(  m_solver->a_hasProperty( cellId , SolverCell::IsNotGradient) ) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;

    const MInt gapCellId = m_solver->m_gapCellId[cellId];
    ASSERT(gapCellId > -1, "");
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
      for(MInt i = 0; i < nDim; i++) {
        const MFloat vel = m_solver->m_gapCells[gapCellId].surfaceVelocity[i];
        m_solver->a_pvariable(ghostCellId, PV->VV[i]) = F2 * vel - m_solver->a_pvariable(cellId, PV->VV[i]);
      }
    }
  }
}


/**
 * \fn FvBndryCndXD::bc3007()
 * Moving wall Euler boundary condition.
 * \author Lennart Schneiders
 * \fvbc{FvBndryCndXD::bc3007(), fvbc3007, BC 3007}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc3007(MInt bcId) {
#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt bndryId = m_sortedBndryCells->a[id];
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;

    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;

        MInt k = m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bodyId[0];
        ASSERT(k > -1 && k < m_solver->m_noEmbeddedBodies + m_solver->m_noPeriodicGhostBodies, "");
        if(k < 0 || k >= m_solver->m_noEmbeddedBodies + m_solver->m_noPeriodicGhostBodies) {
          mTerm(1, AT_, "Invalid body id: " + to_string(k));
        }

        MFloat vel[nDim];
        MFloat surfVel[nDim];
        for(MInt i = 0; i < nDim; i++) {
          surfVel[i] = m_solver->m_bodyVelocity[k * nDim + i];
        }
        MFloat dx[3] = {F0, F0, F0};
        MFloat omega[3] = {F0, F0, F0};
        MFloat vrad[3] = {F0, F0, F0};
        for(MInt i = 0; i < nDim; i++) {
          dx[i] = m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i] - m_solver->m_bodyCenter[k * nDim + i];
        }
        for(MInt i = 0; i < 3; i++) {
          omega[i] = m_solver->m_bodyAngularVelocity[k * 3 + i];
        }
        vrad[0] = omega[1] * dx[2] - omega[2] * dx[1];
        vrad[1] = omega[2] * dx[0] - omega[0] * dx[2];
        IF_CONSTEXPR(nDim == 3) vrad[2] = omega[0] * dx[1] - omega[1] * dx[0];

        for(MInt i = 0; i < nDim; i++) {
          surfVel[i] += vrad[i];
        }
        /*
                MFloat imageVel[3] = {F0,F0,F0};
                for(MInt s = 0; s < mMin((signed)m_bndryCell[ bndryId ].m_recNghbrIds.size(),m_bndryCells->a[ bndryId
           ].m_noSrfcs); s++){ const MInt dummyId = m_bndryCell[ bndryId ].m_recNghbrIds[s]; for( MInt i=0; i<nDim;
           i++ ) { m_solver->a_pvariable( dummyId ,  PV->VV[i] ) = surfVel[i];
                  }
                }
                for ( MUint n = 0; n < m_bndryCell[ bndryId ].m_recNghbrIds.size(); n++ ) {
                  const MInt nghbrId = m_bndryCell[ bndryId ].m_recNghbrIds[n];
                  if ( nghbrId < 0 || m_bndryCell[ bndryId ].m_srfcVariables[srfc]->m_imagePointRecConst.size() !=
           m_bndryCell[ bndryId ].m_recNghbrIds.size() ) { cerr << nghbrId << " " << m_bndryCell[ bndryId
           ].m_srfcVariables[srfc]->m_imagePointRecConst.size() << " " << m_bndryCell[ bndryId ].m_recNghbrIds.size() <<
           endl;
                  }
                  ASSERT ( nghbrId > -1 && m_bndryCell[ bndryId ].m_srfcVariables[srfc]->m_imagePointRecConst.size() ==
           m_bndryCell[ bndryId ].m_recNghbrIds.size(), "" ); for( MInt i=0; i<nDim; i++ ) { imageVel[i] += m_bndryCell[
           bndryId ].m_srfcVariables[srfc]->m_imagePointRecConst[n] * m_solver->a_pvariable( nghbrId ,
           PV->VV[i]);
                  }
                }

                MFloat normal[3] = {F0,F0,F0};
                MFloat cnt = F0;
                for ( MInt i = 0; i < nDim; i++ ) {
                  normal[i] = m_solver->a_coordinate( cellId ,  i ) - m_solver->a_coordinate( ghostCellId ,  i );
                  cnt += POW2(normal[i]);
                }
                cnt = sqrt(cnt);
                for ( MInt i = 0; i < nDim; i++ ) {
                  normal[i] /= cnt;
                }


                // 1. set the surface velocities
                for( MInt i=0; i<nDim; i++ ) {
                  vel[i] = imageVel[i];//m_solver->a_pvariable( cellId ,  PV->VV[i] );
                  for( MInt j=0; j<nDim; j++ ) {
                    vel[i] +=
                      normal[i] * //m_bndryCells->a[ bndryId ].m_srfcs[srfc]->m_normalVector[ i ] *
                      ( surfVel[ j ] - imageVel[i] ) //m_solver->a_pvariable( cellId ,  PV->VV[j] ) )
                      * normal[j] ;//m_bndryCells->a[ bndryId ].m_srfcs[srfc]->m_normalVector[ j ] ;
                  }
                }*/

        // 1. set the surface velocities
        for(MInt i = 0; i < nDim; i++) {
          vel[i] = m_solver->a_pvariable(cellId, PV->VV[i]);
          for(MInt j = 0; j < nDim; j++) {
            vel[i] += m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i]
                      * (surfVel[j] - m_solver->a_pvariable(cellId, PV->VV[j]))
                      * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[j];
          }
        }


        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_pvariable(ghostCellId, PV->VV[i]) = F2 * vel[i] - m_solver->a_pvariable(cellId, PV->VV[i]);
          m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] = vel[i];
        }
      }
    }
  }
}


/**
 * \fn FvBndryCndXD::bc3466
 * Simple shear flow
 * \fvbc{FvBndryCndXD::bc3466(), fvbc3466, BC 3466}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc3466(MInt bcId) {
  TRACE();

  MFloat vel[3]{};
  MFloat bbox[6]{};
  m_solver->m_geometry->getBoundingBox(bbox);
  const MFloat deltaY = bbox[1 + nDim] - bbox[1];

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    MInt bndryId = m_sortedBndryCells->a[id];
    MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == m_bndryCndIds[bcId]) {
          MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;

          vel[0] = F2 * m_solver->m_UInfinity * m_bndryCell[bndryId].m_srfcs[0]->m_coordinates[1] / deltaY;
          for(MInt i = 0; i < nDim; i++) {
            m_solver->a_pvariable(ghostCellId, PV->VV[i]) = F2 * vel[i] - m_solver->a_pvariable(cellId, PV->VV[i]);
          }

          m_solver->a_pvariable(ghostCellId, PV->RHO) = m_solver->a_pvariable(cellId, PV->RHO);
          m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);
        }
      }
    }
  }
}


/**
 * \fn FvBndryCndXD::bc3600()
 * Simple and fast fixed adiabatic wall boundary condition for use with the flux-redistribution method
 * \author Lennart Schneiders
 * \fvbc{FvBndryCndXD::bc3600(), fvbc3600, BC 3600}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc3600(MInt bcId) {
  TRACE();
#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    MInt bndryId = m_sortedBndryCells->a[id];
    MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == m_bndryCndIds[bcId]) {
          MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
          for(MInt i = 0; i < nDim; i++) {
            m_solver->a_pvariable(ghostCellId, PV->VV[i]) = -m_solver->a_pvariable(cellId, PV->VV[i]);
          }
        }
      }
    }
  }
}

/**
 * \brief Simple and fast fixed adiabatic wall boundary condition for use with the flux-redistribution method
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bcNeumann3600(MInt bcId) {
  TRACE();

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    MInt bndryId = m_sortedBndryCells->a[id];
    MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == m_bndryCndIds[bcId]) {
          MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
          m_solver->a_pvariable(ghostCellId, PV->RHO) = m_solver->a_pvariable(cellId, PV->RHO);
          m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);
          for(MInt s = 0; s < m_noSpecies; s++) {
            m_solver->a_pvariable(ghostCellId, PV->Y[s]) = m_solver->a_pvariable(cellId, PV->Y[s]);
          }
        }
      }
    }
  }
}

/**
 * \fn FvBndryCndXD::bc10970()
 * Subsonic outflow boundary condition with fixed pressure (cutOff)
 * \author Claudia Guenther
 * \fvcutoffbc{FvBndryCndXD::bc10970(), fvbc10970, BC 10970}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc10970(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) return;

  const MInt otherDir[4] = {1, 0, 3, 2};

  if(m_firstUseBc10970) {
    MInt noCutOffBndryIds = Context::propertyLength("cutOffBndryIds", m_solverId);
    MInt noCutOffDirections = Context::propertyLength("cutOffDirections", m_solverId);
    if(noCutOffDirections != noCutOffBndryIds)
      mTerm(1, AT_,
            "Wrong number of cut off directions. Must be identical to number of cut off bndryIds! Please check!");
    MInt cutOffBndryIdTmp, cutOffDirectionTmp;
    for(MInt i = 0; i < noCutOffBndryIds; i++) {
      cutOffBndryIdTmp = Context::getSolverProperty<MInt>("cutOffBndryIds", m_solverId, AT_, i);
      cutOffDirectionTmp = Context::getSolverProperty<MInt>("cutOffDirections", m_solverId, AT_, i);
      if(cutOffBndryIdTmp == m_cutOffBndryCndIds[bcId]) {
        m_dirNBc10970 = otherDir[cutOffDirectionTmp];
        break;
      }
    }

    m_pModeBc10970 = 0;
    m_pModeBc10970 = Context::getSolverProperty<MInt>("BC10970Mode", m_solverId, AT_, &m_pModeBc10970);
    m_firstUseBc10970 = false;
  }
  //---

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    MInt nghbrId = m_solver->c_neighborId(cellId, m_dirNBc10970);

    // set the density
    m_solver->a_pvariable(cellId, PV->RHO) = m_solver->a_pvariable(nghbrId, PV->RHO);

    // set the velocities
    for(MInt i = 0; i < nDim; i++)
      m_solver->a_pvariable(cellId, PV->VV[i]) = m_solver->a_pvariable(nghbrId, PV->VV[i]);

    IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
      for(MInt r = 0; r < m_solver->m_noRansEquations; ++r) {
        m_solver->a_pvariable(cellId, PV->NN[r]) = m_solver->a_pvariable(nghbrId, PV->NN[r]);
      }
    }

    // set the pressure
    if(m_pModeBc10970 == 0) {
      m_solver->a_pvariable(cellId, PV->P) = F2 * (m_solver->m_PInfinity) - m_solver->a_pvariable(nghbrId, PV->P);
    } else if(m_pModeBc10970 == 1) {
      m_solver->a_pvariable(cellId, PV->P) = 0.9 * m_solver->m_PInfinity;
    } else {
      mTerm(1, AT_, "Unknown pressure mode in BC10970");
    }
  }
}

/**
 * \fn FvBndryCndXD::bc10980()
 * Subsonic inflow boundary condition
 * \author Claudia Guenther
 * \fvcutoffbc{FvBndryCndXD::bc10980(), fvbc10980, BC 10980}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc10980(MInt bcId) {
  IF_CONSTEXPR(nDim == 3) { TERMM(-1, "INFO: function bc10980 is untested for 3D!"); }
  TRACE();


  if(m_sortedCutOffCells[bcId]->size() == 0) return;

  const MInt otherDir[4] = {1, 0, 3, 2};

  if(m_firstUseBc10980) {
    MInt noCutOffBndryIds = Context::propertyLength("cutOffBndryIds", m_solverId);
    MInt noCutOffDirections = Context::propertyLength("cutOffDirections", m_solverId);
    if(noCutOffDirections != noCutOffBndryIds)
      mTerm(1, AT_,
            "Wrong number of cut off directions. Must be identical to number of cut off bndryIds! Please check!");
    MInt cutOffBndryIdTmp, cutOffDirectionTmp;
    for(MInt i = 0; i < noCutOffBndryIds; i++) {
      cutOffBndryIdTmp = Context::getSolverProperty<MInt>("cutOffBndryIds", m_solverId, AT_, i);
      cutOffDirectionTmp = Context::getSolverProperty<MInt>("cutOffDirections", m_solverId, AT_, i);
      if(cutOffBndryIdTmp == m_cutOffBndryCndIds[bcId]) {
        m_dirNBc10980 = otherDir[cutOffDirectionTmp];
        break;
      }
    }

    m_firstUseBc10980 = false;
  }
  //---

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    MInt nghbrId = m_solver->c_neighborId(cellId, m_dirNBc10980);

    // set the density
    m_solver->a_pvariable(cellId, PV->RHO) = F2 * m_solver->m_rhoInfinity - m_solver->a_pvariable(nghbrId, PV->RHO);

    // set the velocities
    for(MInt i = 0; i < nDim; i++)
      m_solver->a_pvariable(cellId, PV->VV[i]) =
          F2 * m_solver->m_VVInfinity[i] - m_solver->a_pvariable(nghbrId, PV->VV[i]);

    IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
      IF_CONSTEXPR(SysEqn::m_ransModel == RANS_SA_DV || SysEqn::m_ransModel == RANS_FS) {
        m_solver->a_pvariable(cellId, PV->N) = F2 * m_solver->m_nuTildeInfinity - m_solver->a_pvariable(nghbrId, PV->N);
      }
      IF_CONSTEXPR(SysEqn::m_ransModel == RANS_KOMEGA || SysEqn::m_ransModel == RANS_SST) {
        m_solver->a_pvariable(cellId, PV->K) = F2 * m_solver->m_kInfinity - m_solver->a_pvariable(nghbrId, PV->K);
        m_solver->a_pvariable(cellId, PV->OMEGA) =
            F2 * m_solver->m_omegaInfinity - m_solver->a_pvariable(nghbrId, PV->OMEGA);
      }
    }

    // set the pressure
    m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
  }
}


/**
 * \fn FvBndryCndXD::bc11110()
 * TODO
 * \fvcutoffbc{FvBndryCndXD::bc11110(), fvbc11110, BC 11110}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc11110(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) return;

  if(m_firstUseBc11110) {
    //
    //    if (m_clusterCutOffBcs==false)
    //      mTerm(1, AT_, "WARNING: m_clusterCutOffBcs=false");

    /*    MInt noCutOffBndryIds = Context::propertyLength( "cutOffBndryIds", m_solverId);
        MInt noCutOffDirections = Context::propertyLength( "cutOffDirections", m_solverId);
        if( noCutOffDirections != noCutOffBndryIds )
          mTerm(1, AT_, "Wrong number of cut off directions. Must be identical to number of cut off bndryIds! Please
       check!"); MInt cutOffBndryIdTmp, cutOffDirectionTmp; for(MInt i=0; i < noCutOffBndryIds; i++){
          cutOffBndryIdTmp = Context::getSolverProperty<MInt>( "cutOffBndryIds", m_solverId, AT_, i);
          cutOffDirectionTmp = Context::getSolverProperty<MInt>( "cutOffDirections", m_solverId, AT_, i);
          if( cutOffBndryIdTmp == m_cutOffBndryCndIds[ bcId ] ){
            m_dirNBc11110 = otherDir[cutOffDirectionTmp];
            break;
          }
        }*/

    // save target values from RANS
    constexpr const MInt noVars = nDim + 2;

    mAlloc(m_targetValuesBC11110, m_sortedCutOffCells[bcId]->size(), noVars, "m_targetValuesBC11110", AT_);
    mAlloc(m_dirNBc11110, m_sortedCutOffCells[bcId]->size(), "m_dirNBc11110", AT_);

    for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); ++id) {
      const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
      MBool found = false;
      for(MInt dir = 0; dir < 2 * nDim; ++dir) {
        if(m_solver->a_hasNeighbor(cellId, dir) == 0) {
          m_dirNBc11110[id] = dir;
          found = true;
          break;
        }
      }
      if(!found) mTerm(1, AT_, "");
    }

    MFloat zCoord = 0;
    IF_CONSTEXPR(nDim == 2) {
      /*! \page propertiesFV
        \section zCoordFor2DInterpolation
        <code>MInt zCoordFor2DInterpolation </code>\n
        default = <code> 0</code>\n \n
        BlaBlaBlub.\n
        Possible values are:\n
        <ul>
        <li> Float </li>
        </ul>
        Keywords: <i>INTERPOLATION, IO, FINITE_VOLUME</i>
*/
      zCoord = Context::getSolverProperty<MFloat>("zCoordFor2DInterpolation", m_solverId, AT_, &zCoord);
    }

    // Coordinates need to be reorderd
    std::vector<std::vector<MFloat>> coords(3);
    for(MInt d = 0; d < 3; ++d)
      coords[d].resize(m_sortedCutOffCells[bcId]->size());

    for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); ++id) {
      const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
      for(MInt d = 0; d < nDim; ++d) {
        coords[d][id] = m_solver->a_coordinate(cellId, d);
      }
    }
    IF_CONSTEXPR(nDim == 2) {
      for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); ++id) {
        //        const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
        coords[2][id] = zCoord;
      }
    }

    // labels:FV hack, since prepareInterpolation takes C-type pointer to pointer as input argument
    MInt c_ = 0;
    std::vector<MFloat*> coords_ptr(nDim);
    for(auto& c_ptr : coords)
      coords_ptr[c_++] = c_ptr.data();

    StructuredInterpolation<3>* structuredInterpolation =
        new StructuredInterpolation<3>(m_comm_bcCo[m_bcCo_comm_pointer[bcId]]);
    MInt temp[] = {m_sortedCutOffCells[bcId]->size(), 1, 1};
    structuredInterpolation->prepareInterpolationField(&temp[0], coords_ptr.data());

    // pvariableNames saves the conversion between the naming of the primitive variables of the FvCartesianSolver and
    // the structured solver
    std::array<MString, /*solver->PV->noVariables*/ noVars> pvariableNames;
    pvariableNames[PV->U] = "u";
    pvariableNames[PV->V] = "v";
    IF_CONSTEXPR(nDim == 3) pvariableNames[PV->W] = "w";
    pvariableNames[PV->P] = "p";
    pvariableNames[PV->RHO] = "rho";

    std::vector<MFloat> vars(m_sortedCutOffCells[bcId]->size());
    for(MInt var = 0; var < noVars /*solver->PV->noVariables*/; var++) {
      structuredInterpolation->interpolateField(pvariableNames[var], &vars[0]);
      for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); ++id) {
        //        const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
        m_targetValuesBC11110[id][var] = vars[id];
      }
    }

    m_firstUseBc11110 = false;
  }
  //---
  const MInt otherDir[6] = {1, 0, 3, 2, 5, 4};

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    const MInt dimN = (MInt)m_dirNBc11110[id] / 2;
    const MInt dir = (m_dirNBc11110[id] % 2) * 2 - 1;

    const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    const MInt nghbrId = m_solver->c_neighborId(cellId, otherDir[m_dirNBc11110[id]]);

    // Determine if boundary is inflow or outflow
    const MBool isOutflow = (m_targetValuesBC11110[id][PV->VV[dimN]] * dir > 0) ? true : false;

    if(isOutflow) {
      // set the density
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->a_pvariable(nghbrId, PV->RHO);

      // set the velocities
      for(MInt i = 0; i < nDim; i++)
        m_solver->a_pvariable(cellId, PV->VV[i]) = m_solver->a_pvariable(nghbrId, PV->VV[i]);

      // set the pressure
      m_solver->a_pvariable(cellId, PV->P) =
          F2 * m_targetValuesBC11110[id][PV->P] - m_solver->a_pvariable(nghbrId, PV->P);
    } else {
      // set the density
      m_solver->a_pvariable(cellId, PV->RHO) =
          F2 * m_targetValuesBC11110[id][PV->RHO] - m_solver->a_pvariable(nghbrId, PV->RHO);

      // set the velocities
      for(MInt i = 0; i < nDim; i++)
        m_solver->a_pvariable(cellId, PV->VV[i]) =
            F2 * m_targetValuesBC11110[id][PV->VV[i]] - m_solver->a_pvariable(nghbrId, PV->VV[i]);

      // set the pressure
      m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
    }
  }
}


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc16010(MInt bcId) {
  IF_CONSTEXPR(nDim == 2) { TERMM(-1, "INFO: function bc16010 is untested for 2D!"); }
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  const MInt d = 0; // -x direction
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    const MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;

    if(m_solver->checkNeighborActive(cellId, d)) {
      const MInt nghbrId = m_solver->c_neighborId(cellId, d);
      if(nghbrId < 0) {
        cutOffBcMissingNeighbor(cellId, "bc16010");
      } else {
        // set the velocities
        m_solver->a_pvariable(cellId, PV->U) = m_solver->a_pvariable(nghbrId, PV->U);
        m_solver->a_pvariable(cellId, PV->V) = m_solver->a_pvariable(nghbrId, PV->V);
        m_solver->a_pvariable(cellId, PV->W) = m_solver->a_pvariable(nghbrId, PV->W);
        // set the density
        m_solver->a_pvariable(cellId, PV->RHO) = m_solver->a_pvariable(nghbrId, PV->RHO);
        // set the pressure
        m_solver->a_pvariable(cellId, PV->P) = F2 * m_solver->m_PInfinity - m_solver->a_pvariable(nghbrId, PV->P);

        IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
          for(MInt r = 0; r < m_solver->m_noRansEquations; ++r) {
            m_solver->a_pvariable(cellId, PV->NN[r]) = m_solver->a_pvariable(nghbrId, PV->NN[r]);
          }
        }
      }
    } else {
      m_solver->a_pvariable(cellId, PV->U) = m_solver->m_UInfinity;
      m_solver->a_pvariable(cellId, PV->V) = m_solver->m_VInfinity;
      m_solver->a_pvariable(cellId, PV->W) = m_solver->m_WInfinity;
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->m_rhoInfinity;
      m_solver->a_pvariable(cellId, PV->P) = m_solver->m_PInfinity;
    }

    // species
    for(MInt s = 0; s < m_noSpecies; s++) {
      m_solver->a_pvariable(cellId, PV->Y[s]) = F0;
    }
  }
}

/**
 * \fn FvBndryCndXD::bc16011()
 * TODO
 * \fvcutoffbc{FvBndryCndXD::bc16011(), fvbc16011, BC 16011}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc16011(MInt bcId) {
  IF_CONSTEXPR(nDim == 2) { TERMM(-1, "INFO: function bc16011 is untested for 2D!"); }
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  const MInt d = 1;
  // loop over all concerning cells
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    const MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    // set the velocities
    m_solver->a_pvariable(cellId, PV->U) = m_solver->m_UInfinity;
    m_solver->a_pvariable(cellId, PV->V) = m_solver->m_VInfinity;
    m_solver->a_pvariable(cellId, PV->W) = m_solver->m_WInfinity;
    // set the density
    m_solver->a_pvariable(cellId, PV->RHO) = m_solver->m_rhoInfinity;

    if(m_solver->checkNeighborActive(cellId, d)) {
      const MInt nghbrId = m_solver->c_neighborId(cellId, d);
      if(nghbrId < 0) {
        cutOffBcMissingNeighbor(cellId, "bc16011");
      } else {
        m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
      }
    } else {
      m_solver->a_pvariable(cellId, PV->P) = m_solver->m_PInfinity;
    }

    IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
      IF_CONSTEXPR(SysEqn::m_ransModel == RANS_SA_DV || SysEqn::m_ransModel == RANS_FS) {
        m_solver->a_pvariable(cellId, PV->N) = m_solver->m_nuTildeInfinity;
      }
      IF_CONSTEXPR(SysEqn::m_ransModel == RANS_KOMEGA || SysEqn::m_ransModel == RANS_SST) {
        m_solver->a_pvariable(cellId, PV->K) = m_solver->m_kInfinity;
        m_solver->a_pvariable(cellId, PV->OMEGA) = m_solver->m_omegaInfinity;
      }
    }

    // set the species
    for(MInt s = 0; s < m_noSpecies; s++)
      m_solver->a_pvariable(cellId, PV->Y[s]) = 1.0;
  }
}

/**
 * \fn FvBndryCndXD::bc16012()
 * Slip-wall Navier-Stokes boundary condition.
 * \fvcutoffbc{FvBndryCndXD::bc16012(), fvbc16012, BC 16012}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc16012(MInt bcId) {
  IF_CONSTEXPR(nDim == 2) { TERMM(-1, "INFO: function bc16012 is untested for 2D!"); }
  TRACE();

  const MInt d = 3;
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    const MInt nghbrId = m_solver->c_neighborId(cellId, d);
    if(nghbrId < 0) {
      cutOffBcMissingNeighbor(cellId, "bc16012");
    } else {
      // set the velocities
      m_solver->a_pvariable(cellId, PV->U) = m_solver->a_pvariable(nghbrId, PV->U);
      m_solver->a_pvariable(cellId, PV->V) = -m_solver->a_pvariable(nghbrId, PV->V);
      m_solver->a_pvariable(cellId, PV->W) = m_solver->a_pvariable(nghbrId, PV->W);
      // set the density
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->a_pvariable(nghbrId, PV->RHO);
      // set the density
      m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
      // set the species
      for(MInt s = 0; s < m_noSpecies; s++)
        m_solver->a_pvariable(cellId, PV->Y[s]) = m_solver->a_pvariable(nghbrId, PV->Y[s]);
    }
  }
}

/**
 * \fn FvBndryCndXD::bc16013()
 * TODO
 * \fvcutoffbc{FvBndryCndXD::bc16013(), fvbc16013, BC 16013}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc16013(MInt bcId) {
  IF_CONSTEXPR(nDim == 2) { TERMM(-1, "INFO: function bc16013 is untested for 2D!"); }
  TRACE();

  const MInt d = 2;
  // loop over all concerning cells
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    const MInt nghbrId = m_solver->c_neighborId(cellId, d);
    if(nghbrId < 0) {
      cutOffBcMissingNeighbor(cellId, "bc16013");
    } else {
      // set the velocities
      m_solver->a_pvariable(cellId, PV->U) = m_solver->a_pvariable(nghbrId, PV->U);
      m_solver->a_pvariable(cellId, PV->V) = -m_solver->a_pvariable(nghbrId, PV->V);
      m_solver->a_pvariable(cellId, PV->W) = m_solver->a_pvariable(nghbrId, PV->W);
      // set the density
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->a_pvariable(nghbrId, PV->RHO);
      // set the density
      m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
      // set the species
      for(MInt s = 0; s < m_noSpecies; s++)
        m_solver->a_pvariable(cellId, PV->Y[s]) = m_solver->a_pvariable(nghbrId, PV->Y[s]);
    }
  }
}

/**
 * \fn FvBndryCndXD::bc16014()
 * TODO
 * \fvcutoffbc{FvBndryCndXD::bc16014(), fvbc16014, BC 16014}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc16014(MInt bcId) {
  IF_CONSTEXPR(nDim == 2) { TERMM(-1, "INFO: function bc16014 is untested for 2D!"); }
  TRACE();

  const MInt d = 5;
  // loop over all concerning cells
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    const MInt nghbrId = m_solver->c_neighborId(cellId, d);
    if(nghbrId < 0) {
      cutOffBcMissingNeighbor(cellId, "bc16014");
    } else {
      // set the velocities
      m_solver->a_pvariable(cellId, PV->U) = m_solver->a_pvariable(nghbrId, PV->U);
      m_solver->a_pvariable(cellId, PV->V) = m_solver->a_pvariable(nghbrId, PV->V);
      m_solver->a_pvariable(cellId, PV->W) = -m_solver->a_pvariable(nghbrId, PV->W);
      // set the density
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->a_pvariable(nghbrId, PV->RHO);
      // set the density
      m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
      // set the species
      for(MInt s = 0; s < m_noSpecies; s++)
        m_solver->a_pvariable(cellId, PV->Y[s]) = m_solver->a_pvariable(nghbrId, PV->Y[s]);
    }
  }
}

/**
 * \fn FvBndryCndXD::bc16015()
 * TODO
 * \fvcutoffbc{FvBndryCndXD::bc16015(), fvbc16014, BC 16015}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc16015(MInt bcId) {
  IF_CONSTEXPR(nDim == 2) { TERMM(-1, "INFO: function bc16015 is untested for 2D!"); }
  TRACE();

  const MInt d = 4;
  // loop over all concerning cells
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    const MInt nghbrId = m_solver->c_neighborId(cellId, d);
    if(nghbrId < 0) {
      cutOffBcMissingNeighbor(cellId, "bc16015");
    } else {
      // set the velocities
      m_solver->a_pvariable(cellId, PV->U) = m_solver->a_pvariable(nghbrId, PV->U);
      m_solver->a_pvariable(cellId, PV->V) = m_solver->a_pvariable(nghbrId, PV->V);
      m_solver->a_pvariable(cellId, PV->W) = -m_solver->a_pvariable(nghbrId, PV->W);
      // set the density
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->a_pvariable(nghbrId, PV->RHO);
      // set the density
      m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
      // set the species
      for(MInt s = 0; s < m_noSpecies; s++)
        m_solver->a_pvariable(cellId, PV->Y[s]) = m_solver->a_pvariable(nghbrId, PV->Y[s]);
    }
  }
}


// ----- ZONAL -----
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<hasPV_N<SysEqn>::value, _*>, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::bcInit7901(MInt bcId) {
  TRACE();

  m_log << endl << "::bcInit7901: ..." << endl;

  const MFloat eps = 1e-08;

  m_7901faceNormalDir = 0;
  m_7901wallDir = 1;
  m_7901periodicDir = 2;
  if(Context::propertyExists("bc7901faceNormalDir")) {
    m_7901faceNormalDir = Context::getSolverProperty<MInt>("bc7901faceNormalDir", m_solverId, AT_);
  }
  if(Context::propertyExists("bc7901wallDir")) {
    m_7901wallDir = Context::getSolverProperty<MInt>("bc7901wallDir", m_solverId, AT_);
  }
  if(Context::propertyExists("bc7901periodicDir")) {
    m_7901periodicDir = Context::getSolverProperty<MInt>("bc7901periodicDir", m_solverId, AT_);
  }

  m_7901StartTimeStep = m_solver->m_stgStartTimeStep;

  // Prepare the exchange cells for zonal RANS-LES method
  MInt noBc7901Cells = 0;
  MInt noBc7901Locations = 0;
  MFloat periodicL = 0;
  MBool first = true;

  // m_7901BcCells.clear();
  m_7901wallNormalLocations.clear();

  // ======================================================
  // 1) Determine m_7901BcCells
  // ======================================================
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    MFloat halfCellLength = m_solver->grid().halfCellLength(cellId);
    if(first) {
      periodicL = m_solver->a_coordinate(cellId, m_7901periodicDir);
      // cerr << m_solver->domainId() << " " << cellId << ": " << periodicL << endl;
      first = false;
    }

    if(abs(m_solver->a_coordinate(cellId, m_7901periodicDir) + halfCellLength - eps - periodicL) < halfCellLength) {
      // m_7901BcCells.push_back(cellId);
      m_7901wallNormalLocations.push_back(m_solver->a_coordinate(cellId, m_7901wallDir));
      noBc7901Locations++;
    }
    noBc7901Cells++;
  }

  // if not involved, exit
  if(noBc7901Cells == 0) return;

  /* // ====================================================== */
  /* // 2) Create communicator for bc7901 from m_comm_bcCo[m_bcCo_comm_pointer[bcId]] communicator */
  /* // ====================================================== */
  /* m_log << "      + ... building reconstructNut communicator ..." << endl; */

  /* const MPI_Comm& comm7901 = m_comm_bcCo[m_bcCo_comm_pointer[bcId]]; */
  /* MInt comm_size; */
  /* MPI_Comm_size(comm7901, &comm_size); */
  /* MInt* rntRanks = new MInt[comm_size]; */
  /* MInt myRntRank = m_solver->domainId(); */

  /* /\* MPI_Allgather(&noBc7901Cells, 1, MPI_INT, bc7901CellsperDomain, 1, MPI_INT, *\/ */
  /* /\*               m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_, "noBc7901Cells ", "bc7901CellsperDomain" ); *\/ */
  /* MPI_Allgather(&myRntRank, 1, MPI_INT, rntRanks, 1, MPI_INT, */
  /*               comm7901, AT_, "myRntRank", "rntRanks" ); */

  /* MInt rntRoot = rntRanks[0]; */
  /* MInt myCommRank = 0; */
  /* for(MInt r = 0; r < comm_size; r++){ */
  /*   if(myRntRank == rntRanks[r]){ */
  /*     myCommRank = r; */
  /*     break; */
  /*   } */
  /* } */

  /* //cerr << myRntRank << " " << myCommRank << ": " << noBc7901Locations << endl; */

  /* // ====================================================== */
  /* // 3) Determine global locations in wall-normal direction for spanwise average */
  /* // ====================================================== */
  /* MInt globalNoBc7901Locations = 0; */

  /* MPI_Allreduce(&noBc7901Locations, &globalNoBc7901Locations, 1, */
  /*               MPI_INT, MPI_SUM, comm7901, */
  /*               AT_, "noBc7901Locations", "globalNoBc7901Locations"); */

  /* ScratchSpace<MFloat> globalBc7901Locations(globalNoBc7901Locations, "globalBc7901Locations", FUN_); */

  /* ScratchSpace<MInt> recvbuf( comm_size, "recvbuf", FUN_); */
  /* recvbuf.fill(0); */

  /* MPI_Gather(&noBc7901Locations, 1, MPI_INT, */
  /*            &recvbuf[0], 1, MPI_INT, 0, comm7901 , */
  /*            AT_, "noBc7901Locations", "recvbuf" ); */

  /* ScratchSpace<MInt> displs( comm_size, "displspos", FUN_); */
  /* if(myRntRank == rntRoot){ */
  /*   MInt offset = 0; */
  /*   for (MInt dom = 0; dom < comm_size; dom ++){ */
  /*     displs[dom] = offset; */
  /*     offset += recvbuf[dom]; */
  /*   } */
  /* } */

  /* MPI_Gatherv(&m_7901wallNormalLocations[0], noBc7901Locations, MPI_DOUBLE, */
  /*             &globalBc7901Locations[0], &recvbuf[myCommRank], &displs[myCommRank], MPI_DOUBLE, */
  /*             0, comm7901, AT_, "m_7901wallNormalLocations", "globalBc7901Locations" ); */

  /* MPI_Bcast(&globalBc7901Locations[0], globalNoBc7901Locations, */
  /*           MPI_DOUBLE, 0, comm7901, AT_, "globalBc7901Locations" ); */

  /* m_7901globalWallNormalLocations.clear(); */

  /* for(MInt i = 0; i < globalNoBc7901Locations; i++){ */
  /*   MFloat L = globalBc7901Locations[i]; */
  /*   if(std::find(m_7901globalWallNormalLocations.begin(), m_7901globalWallNormalLocations.end(), L) ==
   * m_7901globalWallNormalLocations.end()) { */
  /*     m_7901globalWallNormalLocations.push_back(L); */
  /*   } */
  /* } */

  /* m_7901globalNoWallNormalLocations = (MInt)m_7901globalWallNormalLocations.size(); */

  /* std::sort(m_7901globalWallNormalLocations.begin(), */
  /*           m_7901globalWallNormalLocations.end()); */

  /* /\* if(myRntRank == rntRoot){ *\/ */
  /* /\*   cerr << "----------------------------" << endl; *\/ */
  /* /\*   cerr << m_7901globalNoWallNormalLocations << ": " << m_7901globalNoWallNormalLocations << endl; *\/ */
  /* /\*   for(MInt i = 0; i < m_7901globalNoWallNormalLocations; i++){ *\/ */
  /* /\*     cerr << m_7901globalWallNormalLocations[i] << endl; *\/ */
  /* /\*   } *\/ */
  /* /\* } *\/ */


  /* // ====================================================== */
  /* // 4) Determine local cells in periodic locations of global wall-normal locations */
  /* // ====================================================== */
  /* mAlloc(m_7901periodicLocations, m_7901globalNoWallNormalLocations, */
  /*          "m_7901periodicLocations", FUN_); */

  /* mAlloc(m_7901globalNoPeriodicLocations, m_7901globalNoWallNormalLocations, */
  /*          "m_7901globalNoPeriodicLocations", 0, FUN_); */

  /* for(MInt i = 0; i < m_7901globalNoWallNormalLocations; i++){ */
  /*   m_7901periodicLocations[i].clear(); */
  /* } */

  /* mAlloc(m_7901periodicIndex, noBc7901Cells, "m_7901periodicIndex", FUN_); */

  /* vector<MInt> noPeriodicLocations (m_7901globalNoWallNormalLocations, F0); */

  /* for(MInt i = 0; i < m_7901globalNoWallNormalLocations; i++){ */
  /*   //MInt count = 0; */
  /*   for( MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++ ){ */
  /*     MInt cellId = m_sortedCutOffCells[bcId]->a[id]; */
  /*     if(abs(m_solver->a_coordinate(cellId,m_7901wallDir)-m_7901globalWallNormalLocations[i]) */
  /*        < eps){ */
  /*       m_7901periodicIndex[id] = i; */
  /*       if(!m_solver->a_isHalo(cellId)){ */
  /*         m_7901periodicLocations[i].push_back(cellId); */
  /*         ++noPeriodicLocations[i]; */
  /*       } */
  /*     } */
  /*   } */
  /* } */

  /* MPI_Allreduce(&noPeriodicLocations[0], &m_7901globalNoPeriodicLocations[0], */
  /*               m_7901globalNoWallNormalLocations, MPI_INT, MPI_SUM, comm7901, AT_, */
  /*               "7901noPeriodicLocations", "m_7901globalNoPeriodicLocations"); */

  /* // ====================================================== */
  /* // 5) Init spanwise average */
  /* // ====================================================== */
  /* //mAlloc(m_7901LESAverageOld, PV->noVariables, m_7901globalNoWallNormalLocations, "m_7901LESAverageOld",
   * F0, FUN_); */
  /* mAlloc(m_7901LESAverage, PV->noVariables, m_7901globalNoWallNormalLocations, "m_7901LESAverage", F0,
   * FUN_); */


  //========================================================================

  // MInt noBc7901Cells = m_sortedCutOffCells[bcId]->size();

  /* mAlloc(m_7901LESAverage, PV->noVariables, "m_7901LESAverage", FUN_); */

  /* for(MInt var = 0; var < PV->noVariables; var++){ */
  /*   m_7901LESAverage[var].clear(); */
  /* } */

  /* for(MInt var = 0; var < PV->noVariables; var++){ */
  /*   for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++){ */
  /*     MInt cellId = m_sortedCutOffCells[bcId]->a[id]; */
  /*     m_7901LESAverage[var].push_back(m_solver->m_LESVarAverage[var][cellId]); */
  /*   } */
  /* } */

  /* m_7901StartTimeStep = Context::getSolverProperty<MInt>("7901StartTimeStep", m_solver->m_solverId, AT_,
   * &m_7901StartTimeStep); */


  m_log << "::bcInit7901: ... FINISHED" << endl;
}

template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<hasPV_N<SysEqn>::value, _*>, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::bcInit7902(MInt bcId) {
  TRACE();

  m_log << endl << "::bcInit7902: ..." << endl;

  const MFloat eps = 1e-08;

  m_7902faceNormalDir = 1;
  m_7902wallDir = 1;
  m_7902periodicDir = 2;
  if(Context::propertyExists("bc7902faceNormalDir")) {
    m_7902faceNormalDir = Context::getSolverProperty<MInt>("bc7902faceNormalDir", m_solverId, AT_);
  }
  if(Context::propertyExists("bc7902wallDir")) {
    m_7902wallDir = Context::getSolverProperty<MInt>("bc7902wallDir", m_solverId, AT_);
  }
  if(Context::propertyExists("bc7902periodicDir")) {
    m_7902periodicDir = Context::getSolverProperty<MInt>("bc7902periodicDir", m_solverId, AT_);
  }

  m_7902StartTimeStep = m_solver->m_rntStartTimeStep;

  // Prepare the exchange cells for zonal RANS-LES method
  MInt noBc7902Cells = 0;
  MInt noBc7902Locations = 0;
  MFloat periodicL = 0;
  MBool first = true;

  // m_7902BcCells.clear();
  m_7902wallNormalLocations.clear();

  // ======================================================
  // 1) Determine m_7902BcCells
  // ======================================================
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    MFloat halfCellLength = m_solver->grid().halfCellLength(cellId);
    if(first) {
      periodicL = m_solver->a_coordinate(cellId, m_7902periodicDir);
      // cerr << m_solver->domainId() << " " << cellId << ": " << periodicL << endl;
      first = false;
    }

    if(abs(m_solver->a_coordinate(cellId, m_7902periodicDir) + halfCellLength - eps - periodicL) < halfCellLength) {
      // m_7902BcCells.push_back(cellId);
      m_7902wallNormalLocations.push_back(m_solver->a_coordinate(cellId, m_7902wallDir));
      noBc7902Locations++;
    }
    noBc7902Cells++;
  }

  // if not involved, exit
  if(noBc7902Cells == 0) return;

  // ======================================================
  // 2) Create communicator for bc7902 from m_comm_bcCo[m_bcCo_comm_pointer[bcId]] communicator
  // ======================================================
  m_log << "      + ... building reconstructNut communicator ..." << endl;

  const MPI_Comm& comm7902 = m_comm_bcCo[m_bcCo_comm_pointer[bcId]];
  MInt comm_size;
  MPI_Comm_size(comm7902, &comm_size);
  MInt* rntRanks = new MInt[comm_size];
  MInt myRntRank = m_solver->domainId();

  /* MPI_Allgather(&noBc7902Cells, 1, MPI_INT, bc7902CellsperDomain, 1, MPI_INT, */
  /*               m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_, "noBc7902Cells ", "bc7902CellsperDomain" ); */
  if(comm_size > 0) {
    MPI_Allgather(&myRntRank, 1, MPI_INT, rntRanks, 1, MPI_INT, comm7902, AT_, "myRntRank", "rntRanks");
  }

  MInt rntRoot = rntRanks[0];
  MInt myCommRank = 0;
  for(MInt r = 0; r < comm_size; r++) {
    if(myRntRank == rntRanks[r]) {
      myCommRank = r;
      break;
    }
  }

  m_rntRoot = rntRanks[0];

  // ======================================================
  // 3) Determine global locations in wall-normal direction for spanwise average
  // ======================================================
  MInt globalNoBc7902Locations = 0;

  if(comm_size > 0) {
    MPI_Allreduce(&noBc7902Locations, &globalNoBc7902Locations, 1, MPI_INT, MPI_SUM, comm7902, AT_, "noBc7902Locations",
                  "globalNoBc7902Locations");
  } else {
    globalNoBc7902Locations = noBc7902Locations;
  }

  ScratchSpace<MFloat> globalBc7902Locations(globalNoBc7902Locations, "globalBc7902Locations", FUN_);

  if(comm_size > 0) {
    ScratchSpace<MInt> recvbuf(comm_size, "recvbuf", FUN_);
    recvbuf.fill(0);

    MPI_Gather(&noBc7902Locations, 1, MPI_INT, &recvbuf[0], 1, MPI_INT, 0, comm7902, AT_, "noBc7902Locations",
               "recvbuf");


    ScratchSpace<MInt> displs(comm_size, "displspos", FUN_);
    if(myRntRank == rntRoot) {
      MInt offset = 0;
      for(MInt dom = 0; dom < comm_size; dom++) {
        displs[dom] = offset;
        offset += recvbuf[dom];
      }
    }

    MPI_Gatherv(&m_7902wallNormalLocations[0], noBc7902Locations, MPI_DOUBLE, &globalBc7902Locations[0],
                &recvbuf[myCommRank], &displs[myCommRank], MPI_DOUBLE, 0, comm7902, AT_, "m_7902wallNormalLocations",
                "globalBc7902Locations");

    MPI_Bcast(&globalBc7902Locations[0], globalNoBc7902Locations, MPI_DOUBLE, 0, comm7902, AT_,
              "globalBc7902Locations");

    m_7902globalWallNormalLocations.clear();

    for(MInt i = 0; i < globalNoBc7902Locations; i++) {
      MFloat L = globalBc7902Locations[i];
      if(std::find(m_7902globalWallNormalLocations.begin(), m_7902globalWallNormalLocations.end(), L)
         == m_7902globalWallNormalLocations.end()) {
        m_7902globalWallNormalLocations.push_back(L);
      }
    }

  } else {
    for(MInt i = 0; i < globalNoBc7902Locations; i++) {
      MFloat L = m_7902wallNormalLocations[i];
      if(std::find(m_7902globalWallNormalLocations.begin(), m_7902globalWallNormalLocations.end(), L)
         == m_7902globalWallNormalLocations.end()) {
        m_7902globalWallNormalLocations.push_back(L);
      }
    }
  }

  m_7902globalNoWallNormalLocations = (MInt)m_7902globalWallNormalLocations.size();

  std::sort(m_7902globalWallNormalLocations.begin(), m_7902globalWallNormalLocations.end());

  // ======================================================
  // 4) Determine local cells in periodic locations of global wall-normal locations
  // ======================================================
  mAlloc(m_7902periodicLocations, m_7902globalNoWallNormalLocations, "m_7902periodicLocations", FUN_);

  mAlloc(m_7902globalNoPeriodicLocations, m_7902globalNoWallNormalLocations, "m_7902globalNoPeriodicLocations", 0,
         FUN_);

  for(MInt i = 0; i < m_7902globalNoWallNormalLocations; i++) {
    m_7902periodicLocations[i].clear();
  }

  mAlloc(m_7902periodicIndex, noBc7902Cells, "m_7902periodicIndex", FUN_);

  vector<MInt> noPeriodicLocations(m_7902globalNoWallNormalLocations, F0);

  for(MInt i = 0; i < m_7902globalNoWallNormalLocations; i++) {
    // MInt count = 0;
    for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
      MInt cellId = m_sortedCutOffCells[bcId]->a[id];
      if(abs(m_solver->a_coordinate(cellId, m_7902wallDir) - m_7902globalWallNormalLocations[i]) < eps) {
        m_7902periodicIndex[id] = i;
        if(!m_solver->a_isHalo(cellId)) {
          m_7902periodicLocations[i].push_back(cellId);
          ++noPeriodicLocations[i];
        }
      }
    }
  }

  if(comm_size > 0) {
    MPI_Allreduce(&noPeriodicLocations[0], &m_7902globalNoPeriodicLocations[0], m_7902globalNoWallNormalLocations,
                  MPI_INT, MPI_SUM, comm7902, AT_, "7902noPeriodicLocations", "m_7902globalNoPeriodicLocations");
  }


  // ======================================================
  // 5) Init spanwise average
  // ======================================================
  mAlloc(m_7902LESAverage, PV->noVariables, m_7902globalNoWallNormalLocations, "m_7902LESAverage", F0, FUN_);

  for(MInt var = 0; var < PV->noVariables; var++) {
    for(MInt i = 0; i < m_7902globalNoWallNormalLocations; i++) {
      for(MInt p = 0; p < (MInt)m_7902periodicLocations[i].size(); p++) {
        MInt cellId = m_7902periodicLocations[i][p];
        m_7902LESAverage[var][i] += m_solver->a_pvariable(cellId, var) / m_7902globalNoPeriodicLocations[i];
      }
    }
  }


  for(MInt var = 0; var < PV->noVariables; var++) {
    if(comm_size > 0) {
      MPI_Allreduce(MPI_IN_PLACE, m_7902LESAverage[var], m_7902globalNoWallNormalLocations, MPI_DOUBLE, MPI_SUM,
                    m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_, "MPI_IN_PLACE", "m_7902LESAverage");
    }
  }

  m_log << "::bcInit7902: ... FINISHED" << endl;
}


template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<hasPV_N<SysEqn>::value, _*>, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::bcInit7905(MInt bcId) {
  TRACE();

  m_log << endl << "::bcInit7905: ..." << endl;

  m_7902faceNormalDir = 1;
  m_7902wallDir = 1;
  m_7902periodicDir = 2;
  if(Context::propertyExists("bc7902faceNormalDir")) {
    m_7902faceNormalDir = Context::getSolverProperty<MInt>("bc7902faceNormalDir", m_solverId, AT_);
  }
  if(Context::propertyExists("bc7902wallDir")) {
    m_7902wallDir = Context::getSolverProperty<MInt>("bc7902wallDir", m_solverId, AT_);
  }
  if(Context::propertyExists("bc7902periodicDir")) {
    m_7902periodicDir = Context::getSolverProperty<MInt>("bc7902periodicDir", m_solverId, AT_);
  }

  m_7902StartTimeStep = m_solver->m_rntStartTimeStep;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
  }

  m_log << "::bcInit7902: ... FINISHED" << endl;
}


template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<!hasPV_N<SysEqn>::value, _*>, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::bcInit7909(MInt bcId) {
  TRACE();

  m_log << endl << "::bcInit:" + to_string(m_bndryCndIds[bcId]) + " ..." << endl;

  m_startSTGTimeStep = Context::getSolverProperty<MInt>("startSTGTimeStep", m_solverId, AT_, &m_startSTGTimeStep);

  IF_CONSTEXPR(!isEEGas<SysEqn> && !isDetChem<SysEqn>) {
    /*
      0) Check if stg is active
      1) Loop over all boundary cells;
      Skip cells if !IsOnCurrentMGLevel;
      Check if cell has multiple ghost cells;
      Save cells participating in stg and pass them later to MSTG constructor;
      Mark if current rank has cells involved in current stg
      2) Create communicator for bc7909 from m_comm_bc[m_bc_comm_pointer[bcId]] communicator
      --> ranks which have no STG cells return
      3) Determine normal to STG boundary (by now only +x and -x allowed);
      Determine y-coordinate of adjacent solid wall (assume wall with constant y in spanwise
      direction); Determine normal pointing from the solid wall to the domain;
      y-coordinate of adjacent wall is the closest one, from those read in by a property;
      4) Create MSTG object
    */

    // ======================================================
    // 0) Check if stg is active
    // ======================================================
    if(!m_solver->m_stgIsActive) TERMM(1, "m_stgIsActive=false but BC 7909, 7910, ... exists!");

    // ======================================================
    // 1) Loop over all boundary cells;
    //    Skip cells if !IsOnCurrentMGLevel;
    //    Check if cell has multiple ghost cells;
    //    Save cells participating in stg and pass them later to MSTG constructor
    //    Mark if current rank has cells involved in current stg
    // ======================================================
    ScratchSpace<MInt> stgBcCells(m_bndryCndCells[bcId + 1] - m_bndryCndCells[bcId], AT_, "stgBcCells");

    MInt noBc7909Cells = 0;
    for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
      const MInt bndryId = m_sortedBndryCells->a[id];
      const MInt cellId = m_bndryCells->a[bndryId].m_cellId;

      if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        if(m_bndryCells->a[bndryId].m_noSrfcs > 1) {
          mTerm(1, AT_, "Multiple ghost cells by now not supported by STG!");
        }
        stgBcCells[noBc7909Cells++] = cellId;
        m_stgBcCells.push_back(cellId);
      }
    }

    m_stgLocal[bcId] = noBc7909Cells > 0;

#ifndef NDEBUG
  if(!m_stgLocal[bcId]) {
    cout << "RANK " << m_solver->domainId() << " has no 7909 cells, although it was entering bcInit7909 " << endl;
  }
#endif

  // ======================================================
  // 2) Create communicator for bc7909 from m_comm_bc[m_bc_comm_pointer[bcId]] communicator
  // ======================================================
  m_log << "::bcInit" + to_string(m_bndryCndIds[bcId]) + ": ... building stg communicator ..." << endl;
  const MPI_Comm& comm7909 = m_comm_bc[m_bc_comm_pointer[bcId]];
  MInt comm_size;
  MPI_Comm_size(comm7909, &comm_size);
  MInt* bc7909CellsperDomain = new MInt[comm_size];
  MInt* stgRanks = new MInt[comm_size];
  MInt myStgRank = m_solver->domainId();

  if(noDomains() > 1) {
    MPI_Allgather(&noBc7909Cells, 1, MPI_INT, bc7909CellsperDomain, 1, MPI_INT, comm7909, AT_, "noBc7909Cells ",
                  "bc7909CellsperDomain");
    MPI_Allgather(&myStgRank, 1, MPI_INT, stgRanks, 1, MPI_INT, comm7909, AT_, "myStgRank", "stgRanks");
  }

  MInt noInvolvedRanks = 0;
  MInt* involvedRanks = new MInt[comm_size];
  for(MInt i = 0; i < comm_size; i++) {
    if(bc7909CellsperDomain[i]) {
      involvedRanks[noInvolvedRanks] = i;
      ++noInvolvedRanks;
    }
  }

  MPI_Comm commStg;
  MPI_Group group, groupStg;
  MPI_Comm_group(comm7909, &group, AT_, "group");
  MPI_Group_incl(group, noInvolvedRanks, involvedRanks, &groupStg, AT_);

  MPI_Comm_create(comm7909, groupStg, &commStg, AT_, "commStg");
  m_commStg = commStg;

  // if not involved, exit
  if(!noBc7909Cells) return;

  // ======================================================
  // 3) Determine normal to STG boundary
  //    Determine normal pointing from the solid wall to the domain;
  // ======================================================

  // JANNIK:change this for cylinder transformation

  static constexpr const MFloat eps = 1e-8;
  std::vector<MInt> faces = {0, 0, 0, 0, 0, 0};
  for(MInt i = 0; i < noBc7909Cells; ++i) {
    const MInt cellId = stgBcCells[i];
    const MInt bndryId = m_solver->a_bndryId(cellId);
    const MFloat* const n = &m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[0];
    if(abs(n[0] - 1.0) < eps)
      ++faces[0];
    else if(abs(n[0] + 1.0) < eps)
      ++faces[1];
    else if(abs(n[1] - 1.0) < eps)
      ++faces[2];
    else if(abs(n[1] + 1.0) < eps)
      ++faces[3];
    else if(abs(n[2] - 1.0) < eps)
      ++faces[4];
    else if(abs(n[2] + 1.0) < eps)
      ++faces[5];
  }

  const MInt stgFaceNormalDir = std::max_element(faces.begin(), faces.end()) - faces.begin();
  for(MInt i = 0; i < 2 * nDim; i++) {
    if(i != stgFaceNormalDir) {
      if(faces[i] != 0) mTerm(1, AT_, "Something went wrong, STG plane is only allowed in one direction!");
    }
  }

  MInt stgDir = stgFaceNormalDir;
  if(noDomains() > 1) {
    MPI_Allreduce(&stgFaceNormalDir, &stgDir, 1, MPI_INT, MPI_MIN, comm7909, AT_, "dirN", "stgDir");
  }
  // Sanity check: check if all ranks of STG have normal direction
  if(stgFaceNormalDir != stgDir) {
    mTerm(1, AT_, "Something went wrong, STG plane is only allowed in one direction!");
  } else {
    stgDir = stgFaceNormalDir / 2;
  }

  MInt stgWallNormalDir = 3;
  MInt noCoords_ = Context::propertyLength("stgWallNormalDir");
  for(MInt i = 0; i < noCoords_; i++) {
    if(m_bndryCndIds[bcId] == 7909 + i) {
      stgWallNormalDir = Context::getBasicProperty<MFloat>("stgWallNormalDir", AT_, i);
    }
  }

  MInt wallDir = stgWallNormalDir / 2;

  // ======================================================
  // 4) Create MSTG object
  // ======================================================
  m_log << "::bcInit7909: ... creating MSTG object ..." << endl;

  switch(string2enum(m_solver->m_bc7909RANSSolverType)) {
    case MAIA_FINITE_VOLUME: {
      // TODO labels:FV don't forget to delete the objects later
      MSTG<nDim, MAIA_FINITE_VOLUME, MAIA_FINITE_VOLUME>* stgBC =
          new MSTG<nDim, MAIA_FINITE_VOLUME, MAIA_FINITE_VOLUME>(m_solver,
                                                                 m_bndryCndIds[bcId],
                                                                 commStg,
                                                                 &stgBcCells[0],
                                                                 noBc7909Cells,
                                                                 stgFaceNormalDir,
                                                                 stgDir,
                                                                 stgWallNormalDir,
                                                                 wallDir,
                                                                 false);

      m_log << "::bcInit" + to_string(m_bndryCndIds[bcId]) + ": ... creating MSTG object finished..." << endl;
      stgBC->init(0);
      m_stgBC.insert(std::pair<MInt, MSTG<nDim, MAIA_FINITE_VOLUME, MAIA_FINITE_VOLUME>*>(bcId, stgBC));
      break;
    }
    case MAIA_STRUCTURED: {
      // TODO labels:FV don't forget to delete the objects later
      MSTG<nDim, MAIA_STRUCTURED, MAIA_FINITE_VOLUME>* stgBCStrcd =
          // stgBC = static_cast<MSTGInterface<nDim>*>(
          new MSTG<nDim, MAIA_STRUCTURED, MAIA_FINITE_VOLUME>(m_solver,
                                                              m_bndryCndIds[bcId],
                                                              commStg,
                                                              &stgBcCells[0],
                                                              noBc7909Cells,
                                                              stgFaceNormalDir,
                                                              stgDir,
                                                              stgWallNormalDir,
                                                              wallDir,
                                                              false);

      m_log << "::bcInit" + to_string(m_bndryCndIds[bcId]) + ": ... creating MSTG object finished..." << endl;
      stgBCStrcd->init(0);
      m_stgBCStrcd.insert(std::pair<MInt, MSTG<nDim, MAIA_STRUCTURED, MAIA_FINITE_VOLUME>*>(bcId, stgBCStrcd));
      break;
    }
    default:
      mTerm(1, AT_, "Not yet implemented for solver " + m_solver->m_bc7909RANSSolverType);
  }

  m_log << "::bcInit7909: ... FINISHED" << endl;
  }
}


template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<!hasPV_N<SysEqn>::value, _*>, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::bcInit7809(MInt bcId) {
  TRACE();

  m_log << endl << "::bcInit:" + to_string(m_cutOffBndryCndIds[bcId]) + " ..." << endl;
  m_startSTGTimeStep = Context::getSolverProperty<MInt>("startSTGTimeStep", m_solverId, AT_, &m_startSTGTimeStep);

  IF_CONSTEXPR(!isEEGas<SysEqn> && !isDetChem<SysEqn>) {
    /*
      0) Check if stg is active
      1) Loop over all boundary cells;
      Skip cells if !IsOnCurrentMGLevel;
      Check if cell has multiple ghost cells;
      Save cells participating in stg and pass them later to STG constructor;
      Mark if current rank has cells involved in current stg
      2) Create communicator for bc7909 from m_comm_bc[m_bc_comm_pointer[bcId]] communicator
      --> ranks which have no STG cells return
      3) Determine normal to STG boundary (by now only +x and -x allowed);
      Determine y-coordinate of adjacent solid wall (assume wall with constant y in spanwise
      direction); Determine normal pointing from the solid wall to the domain;
      y-coordinate of adjacent wall is the closest one, from those read in by a property;
      4) Create STG object
    */

    // ======================================================
    // 0) Check if stg is active
    // ======================================================
    if(!m_solver->m_stgIsActive) return; // TERMM(1, "m_stgIsActive=false but CBC 7909, 7910, ... exists!");


    // ======================================================
    // 1) Loop over all boundary cells;
    //    Skip cells if !IsOnCurrentMGLevel;
    //    Check if cell has multiple ghost cells;
    //    Save cells participating in stg and pass them later to STG constructor
    //    Mark if current rank has cells involved in current stg
    // ======================================================
    ScratchSpace<MInt> stgBcCells(m_sortedCutOffCells[bcId]->size(), AT_, "stgBcCells");

    MInt noBc7909Cells = 0;
    for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
      MInt cellId = m_sortedCutOffCells[bcId]->a[id];
      if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;
      if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        stgBcCells[noBc7909Cells++] = cellId;
        m_stgBcCells.push_back(cellId);
      }
    }

    m_stgLocal[bcId] = noBc7909Cells > 0;

    // if not involved, exit
    if(!(noBc7909Cells > 0)) return;

#ifndef NDEBUG
    if(!m_stgLocal[bcId]) {
      cout << "RANK " << m_solver->domainId() << " has no 7909 cells, although it was entering cbcInit7909 " << endl;
    }
#endif

    // ======================================================
    // 2) Create communicator for bc7909 from m_comm_bcCo[m_bcCo_comm_pointer[bcId]] communicator
    // ======================================================
    m_log << "::bcInit" + to_string(m_cutOffBndryCndIds[bcId]) + ": ... building stg communicator ..." << endl;
    const MPI_Comm& comm7909 = m_comm_bcCo[m_bcCo_comm_pointer[bcId]];
    MInt comm_size;
    MPI_Comm_size(comm7909, &comm_size);
    MInt* bc7909CellsperDomain = new MInt[comm_size];
    MInt* stgRanks = new MInt[comm_size];
    MInt myStgRank = m_solver->domainId();

    if(noDomains() > 1) {
      MPI_Allgather(&noBc7909Cells, 1, MPI_INT, bc7909CellsperDomain, 1, MPI_INT, comm7909, AT_, "noBc7909Cells ",
                    "bc7909CellsperDomain");
      MPI_Allgather(&myStgRank, 1, MPI_INT, stgRanks, 1, MPI_INT, comm7909, AT_, "myStgRank", "stgRanks");
    }

    MInt noInvolvedRanks = 0;
    MInt* involvedRanks = new MInt[comm_size];
    for(MInt i = 0; i < comm_size; i++) {
      if(bc7909CellsperDomain[i]) {
        involvedRanks[noInvolvedRanks] = i;
        ++noInvolvedRanks;
      }
    }

    MPI_Comm commStg;
    MPI_Group group, groupStg;
    MPI_Comm_group(comm7909, &group, AT_, "group");
    MPI_Group_incl(group, noInvolvedRanks, involvedRanks, &groupStg, AT_);

    MPI_Comm_create(comm7909, groupStg, &commStg, AT_, "commStg");
    m_commStg = commStg;

    // ======================================================
    // 3) Determine normal to STG boundary
    //    Determine normal pointing from the solid wall to the domain;
    // ======================================================

    // JANNIK:change this for cylinder transformation

    // static constexpr const MFloat eps = 1e-8;
    std::vector<MInt> faces = {0, 0, 0, 0, 0, 0};
    for(MInt i = 0; i < noBc7909Cells; ++i) {
      const MInt cellId = stgBcCells[i];

      for(MInt d = 0; d < 2 * nDim; d++) {
        if(!m_solver->a_hasNeighbor(cellId, d, false)) {
          ++faces[d];
        }
      }

      // const MFloat* const n = &m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[0];
      // if(abs(n[0] - 1.0) < eps)
      //   ++faces[0];
      // else if(abs(n[0] + 1.0) < eps)
      //   ++faces[1];
      // else if(abs(n[1] - 1.0) < eps)
      //   ++faces[2];
      // else if(abs(n[1] + 1.0) < eps)
      //   ++faces[3];
      // else if(abs(n[2] - 1.0) < eps)
      //   ++faces[4];
      // else if(abs(n[2] + 1.0) < eps)
      //   ++faces[5];
    }

    const MInt stgFaceNormalDir = std::max_element(faces.begin(), faces.end()) - faces.begin();
    // cerr << m_solver->domainId() << " " << stgFaceNormalDir << endl;
    // for(MInt d = 0; d < 2*nDim; d++){
    //   cerr << faces[d] << endl;
    // }
    // for(MInt i = 0; i < 2 * nDim; i++) {
    //   if(i != stgFaceNormalDir) {
    //     if(faces[i] != 0) mTerm(1, AT_, "Something went wrong, STG plane is only allowed in one direction!");
    //   }
    // }

    MInt stgDir = stgFaceNormalDir;
    if(noDomains() > 1) {
      MPI_Allreduce(&stgFaceNormalDir, &stgDir, 1, MPI_INT, MPI_MIN, comm7909, AT_, "dirN", "stgDir");
    }
    // Sanity check: check if all ranks of STG have normal direction
    // if(stgFaceNormalDir != stgDir) {
    //   mTerm(1, AT_, "Something went wrong, STG plane is only allowed in one direction!");
    // } else {
    //   stgDir = stgFaceNormalDir / 2;
    // }

    MInt stgWallNormalDir = 3;
    MInt noCoords_ = Context::propertyLength("stgWallNormalDir");
    for(MInt i = 0; i < noCoords_; i++) {
      if(m_cutOffBndryCndIds[bcId] == 7909 + i) {
        stgWallNormalDir = Context::getBasicProperty<MFloat>("stgWallNormalDir", AT_, i);
      }
    }

    MInt wallDir = stgWallNormalDir / 2;

    // cerr << stgFaceNormalDir << " " << stgDir << " " << stgWallNormalDir << " " << wallDir << endl;

    // ======================================================
    // 4) Create MSTG object
    // ======================================================
    m_log << "::bcInit7909: ... creating MSTG object ..." << endl;

    switch(string2enum(m_solver->m_bc7909RANSSolverType)) {
      case MAIA_FINITE_VOLUME: {
        // TODO: don't forget to delete the objects later
        MSTG<nDim, MAIA_FINITE_VOLUME, MAIA_FINITE_VOLUME>* stgBC =
            new MSTG<nDim, MAIA_FINITE_VOLUME, MAIA_FINITE_VOLUME>(m_solver,
                                                                   m_cutOffBndryCndIds[bcId],
                                                                   commStg,
                                                                   &stgBcCells[0],
                                                                   noBc7909Cells,
                                                                   stgFaceNormalDir,
                                                                   stgDir,
                                                                   stgWallNormalDir,
                                                                   wallDir,
                                                                   true);

        m_log << "::bcInit" + to_string(m_cutOffBndryCndIds[bcId]) + ": ... creating MSTG object finished..." << endl;

        if(m_stgBC.find(bcId) != m_stgBC.end()) {
          if(m_solver->m_wasAdapted || m_solver->m_wasBalancedZonal) {
            // if(globalTimeStep > m_solver->m_restartTimeStep+1){
            m_stgBC[bcId]->saveStg();
            delete m_stgBC[bcId];
            m_stgBC.erase(bcId);
            stgBC->init(0);
            m_stgBC.insert(std::pair<MInt, MSTG<nDim, MAIA_FINITE_VOLUME, MAIA_FINITE_VOLUME>*>(bcId, stgBC));

            cerr << "init bc7909 " << m_solver->m_wasAdapted << " " << m_solver->m_wasBalancedZonal << endl;
          }
        } else {
          stgBC->init(0);
          m_stgBC.insert(std::pair<MInt, MSTG<nDim, MAIA_FINITE_VOLUME, MAIA_FINITE_VOLUME>*>(bcId, stgBC));
        }

        break;
      }

      default:
        mTerm(1, AT_, "Not yet implemented for solver " + m_solver->m_bc7909RANSSolverType);
    }

    m_log << "::bcInit7909: ... FINISHED" << endl;
  }
}


/**
 * \page fvCutoffBc
 * \section fvbc7901 BC 7901
 * FvBndryCndXD::bc7901() \n \n
 * Zonal interface RANS outflow boundary condition (RANS->LES coupling)
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<hasPV_N<SysEqn>::value, _*>, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::bc7901(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cellId, nghbrId, d = m_7901faceNormalDir;
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;

    if(m_solver->checkNeighborActive(cellId, d)) {
      nghbrId = m_solver->c_neighborId(cellId, d);
      if(nghbrId < 0) {
        cutOffBcMissingNeighbor(cellId, "bc7901");
      } else {
        // set the velocities
        m_solver->a_pvariable(cellId, PV->U) = m_solver->a_pvariable(nghbrId, PV->U);
        m_solver->a_pvariable(cellId, PV->V) = m_solver->a_pvariable(nghbrId, PV->V);
        m_solver->a_pvariable(cellId, PV->W) = m_solver->a_pvariable(nghbrId, PV->W);
        // set the density
        m_solver->a_pvariable(cellId, PV->RHO) = m_solver->a_pvariable(nghbrId, PV->RHO);
        IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
          for(MInt r = 0; r < m_solver->m_noRansEquations; ++r) {
            m_solver->a_pvariable(cellId, PV->NN[r]) = m_solver->a_pvariable(nghbrId, PV->NN[r]);
          }
        }

        MFloat pressureTarget = m_solver->m_PInfinity; // m_solver->m_LESValues[PV->P][cellId];

        m_solver->a_pvariable(cellId, PV->P) = pressureTarget;
        if(m_noSpecies > 0) {
          m_solver->a_pvariable(cellId, PV->Y[0]) = m_solver->m_LESValues[PV->Y[0]][cellId];
        }
      }
    } else {
      m_solver->a_pvariable(cellId, PV->U) = m_solver->m_UInfinity;
      m_solver->a_pvariable(cellId, PV->V) = m_solver->m_VInfinity;
      m_solver->a_pvariable(cellId, PV->W) = m_solver->m_WInfinity;
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->m_rhoInfinity;
      m_solver->a_pvariable(cellId, PV->P) = m_solver->m_PInfinity;
    }
  }
}

/**
 * \page fvCutoffBc
 * \section fvbc7902 BC 7902
 * FvBndryCndXD::bc7902() \n \n
 * Zonal interface RANS inflow boundary condition (LES->RANS coupling)
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<hasPV_N<SysEqn>::value, _*>, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::bc7902(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) return;

  if(globalTimeStep % m_solver->m_zonalTransferInterval == 0 //&& globalTimeStep != m_solver->m_restartTimeStep
     && m_solver->m_RKStep == 0) {
    for(MInt var = 0; var < PV->noVariables; var++) {
      for(MInt i = 0; i < m_7902globalNoWallNormalLocations; i++) {
        m_7902LESAverage[var][i] = F0;
      }
    }

    for(MInt var = 0; var < PV->noVariables; var++) {
      for(MInt i = 0; i < m_7902globalNoWallNormalLocations; i++) {
        for(MInt p = 0; p < (MInt)m_7902periodicLocations[i].size(); p++) {
          MInt cellId = m_7902periodicLocations[i][p];

          ASSERT(cellId < (MInt)m_solver->m_LESValues[var].size(),
                 "Trying to access data [" + to_string(var) + "][" + to_string(cellId) + "] in m_LESValues with length "
                     + to_string(m_solver->m_LESValues[var].size()) + ", domainId: " + to_string(m_solver->domainId()));

          m_7902LESAverage[var][i] += m_solver->m_LESValues[var][cellId] / m_7902globalNoPeriodicLocations[i];
        }
      }
    }

    if(noDomains() > 1) {
      for(MInt var = 0; var < PV->noVariables; var++) {
        MPI_Allreduce(MPI_IN_PLACE, m_7902LESAverage[var], m_7902globalNoWallNormalLocations, MPI_DOUBLE, MPI_SUM,
                      m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_, "MPI_IN_PLACE", "m_7902LESAverage");
      }
    }
  }

  MInt cellId, nghbrId, d = m_7902faceNormalDir;
  // Prepare the exchange cells for zonal RANS-LES method
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    cellId = m_sortedCutOffCells[bcId]->a[id];

    // InitialRange
    if(globalTimeStep < m_7902StartTimeStep) {
      // Velocities
      m_solver->a_pvariable(cellId, PV->U) = m_solver->m_UInfinity;
      m_solver->a_pvariable(cellId, PV->V) = m_solver->m_VInfinity;
      m_solver->a_pvariable(cellId, PV->W) = m_solver->m_WInfinity;
      // Density
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->m_rhoInfinity;
      // Turbulent viscosity
      m_solver->a_pvariable(cellId, PV->N) = m_solver->m_nuTildeInfinity;

      // fully developed LES solution
    } else {
      for(MInt var = 0; var < PV->noVariables; var++) {
        MInt index = m_7902periodicIndex[id];
        m_solver->a_pvariable(cellId, var) = m_7902LESAverage[var][index];
      }
    }

    // Pressure
    if(m_solver->checkNeighborActive(cellId, d)) {
      nghbrId = m_solver->c_neighborId(cellId, d);
      if(nghbrId < 0) {
        cutOffBcMissingNeighbor(cellId, "bc7902");
      } else {
        m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
      }
    } else {
      TERMM(1, "ERROR in bc7902");
    }
  }
}

/**
 * \page fvCutoffBc
 * \section fvbc7905 BC 7905
 * FvBndryCndXD::bc7905() \n \n
 * Zonal interface RANS inflow boundary condition without periodic averaging (LES->RANS coupling)
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<hasPV_N<SysEqn>::value, _*>, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::bc7905(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) return;

  MInt cellId, nghbrId, d = m_7902faceNormalDir;
  // Prepare the exchange cells for zonal RANS-LES method
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;

    // InitialRange
    if(globalTimeStep < m_7902StartTimeStep) {
      // Velocities
      m_solver->a_pvariable(cellId, PV->U) = m_solver->m_UInfinity;
      m_solver->a_pvariable(cellId, PV->V) = m_solver->m_VInfinity;
      m_solver->a_pvariable(cellId, PV->W) = m_solver->m_WInfinity;
      // Density
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->m_rhoInfinity;
      // Turbulent viscosity
      m_solver->a_pvariable(cellId, PV->N) = m_solver->m_nuTildeInfinity;

      // fully developed LES solution
    } else {
      for(MInt var = 0; var < PV->noVariables; var++) {
        m_solver->a_pvariable(cellId, var) = m_solver->m_LESValues[var][cellId];
      }
    }

    // Pressure
    if(m_solver->checkNeighborActive(cellId, d)) {
      nghbrId = m_solver->c_neighborId(cellId, d);
      if(nghbrId < 0) {
        cutOffBcMissingNeighbor(cellId, "bc7905");
      } else {
        m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
      }
    } else {
      TERMM(1, "ERROR in bc7905");
    }
  }
}

/**
 * \page fvCutoffBc
 * \section fvbc7903 BC 7903
 * FvBndryCndXD::bc7903() \n \n
 * Zonal interface LES outflow boundary condition (LES->RANS coupling)
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<!hasPV_N<SysEqn>::value, _*>, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::bc7903(MInt bcId) {
  TRACE();

  /* if(m_sortedCutOffCells[bcId]->size() == 0) return; */

  MInt cellId, nghbrId, d = 0;
  // Prepare the exchange cells for zonal RANS-LES method
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;

    // set boundary values
    if(m_solver->checkNeighborActive(cellId, d)) {
      nghbrId = m_solver->c_neighborId(cellId, d);
      if(nghbrId < 0) {
        cutOffBcMissingNeighbor(cellId, "bc7903");
      } else {
        // set the velocities
        m_solver->a_pvariable(cellId, PV->U) = m_solver->a_pvariable(nghbrId, PV->U);
        m_solver->a_pvariable(cellId, PV->V) = m_solver->a_pvariable(nghbrId, PV->V);
        m_solver->a_pvariable(cellId, PV->W) = m_solver->a_pvariable(nghbrId, PV->W);
        // set the density
        m_solver->a_pvariable(cellId, PV->RHO) = m_solver->a_pvariable(nghbrId, PV->RHO);

        m_solver->a_pvariable(cellId, PV->P) = m_solver->m_RANSValues[PV->P][cellId];

        for(MInt s = 0; s < m_noSpecies; s++)
          m_solver->a_pvariable(cellId, PV->Y[s]) = m_solver->a_pvariable(nghbrId, PV->Y[s]);
      }
    } else {
      TERMM(1, "ERROR in bc7903");
    }
  }
}

/**
 * \page fvCutoffBc
 * \section fvbc7909 BC 7909
 * FvBndryCndXD::bc7909() \n \n
 * Zonal interface LES inflow boundary condition (LES->RANS coupling)
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<!hasPV_N<SysEqn>::value, _*>, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::bc7909(MInt bcId) {
  TRACE();

  IF_CONSTEXPR(isEEGas<SysEqn>)
  TERMM(1, "bc7809 not working for AIAFvSysEqnEEGas");

  if(m_stgLocal[bcId]) {
    switch(string2enum(m_solver->m_bc7909RANSSolverType)) {
      case MAIA_FINITE_VOLUME: {
        m_stgBC[bcId]->bc7909();
        break;
      }
      case MAIA_STRUCTURED: {
        m_stgBCStrcd[bcId]->bc7909();
        break;
      }
      default:
        mTerm(1, AT_, "Not yet implemented for solver " + m_solver->m_bc7909RANSSolverType);
    }
    if(m_solver->m_noSpecies > 0) {
      for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
        MInt bndryId = m_sortedBndryCells->a[id];
        const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
        if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
          const MInt ghostCellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_srfcVariables[0]->m_ghostCellId;
          for(MInt i = 0; i < m_noSpecies; i++) {
            m_solver->a_pvariable(ghostCellId, PV->Y[i]) = F0;
          }
        }
      }
    }
  }
}

/**
 * \page fvCutoffBc
 * \section fvbc7809 BC 7809
 * FvBndryCndXD::bc7809() \n \n
 * TODO
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<!hasPV_N<SysEqn>::value, _*>, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::bc7809(MInt bcId) {
  TRACE();

  IF_CONSTEXPR(isEEGas<SysEqn>)
  TERMM(1, "bc7809 not working for AIAFvSysEqnEEGas");

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt d = 1;

  if(!m_solver->m_stgIsActive) {
    for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
      const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
      // set variables
      // for(MInt var = 0; var < PV->noVariables; var++) {
      m_solver->a_pvariable(cellId, PV->U) = m_solver->m_RANSValues[PV->U][cellId];
      m_solver->a_pvariable(cellId, PV->V) = m_solver->m_RANSValues[PV->V][cellId];
      m_solver->a_pvariable(cellId, PV->W) = m_solver->m_RANSValues[PV->W][cellId];
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->m_RANSValues[PV->RHO][cellId];
    }
    // return;
  } else {
    if(m_stgLocal[bcId]) {
      switch(string2enum(m_solver->m_bc7909RANSSolverType)) {
        case MAIA_FINITE_VOLUME: {
          m_stgBC[bcId]->bc7909();
          break;
        }
        case MAIA_STRUCTURED: {
          m_stgBCStrcd[bcId]->bc7909();
          break;
        }

        default:
          mTerm(1, AT_, "Not yet implemented for solver " + m_solver->m_bc7909RANSSolverType);
      }
    }

    if(m_solver->m_noSpecies > 0) {
      for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
        const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
        if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
          for(MInt i = 0; i < m_noSpecies; i++) {
            m_solver->a_pvariable(cellId, PV->Y[i]) = F0;
          }
        }
      }
    }
  }

  // set pressure
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    const MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->checkNeighborActive(cellId, d)) {
      const MInt nghbrId = m_solver->c_neighborId(cellId, d);
      if(nghbrId < 0) {
        cutOffBcMissingNeighbor(cellId, "bc7909");
      } else {
        m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
      }
    } else {
      m_solver->a_pvariable(cellId, PV->P) = m_solver->m_PInfinity;
    }
  }
}


/**
 * \fn FvBndryCndXD::bc30022()
 * Zonal interface LES inflow boundary condition (LES->RANS coupling)
 * \fvcutoffbc{FvBndryCndXD::bc30022(), fvbc30022, BC 30022}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc30022(MInt bcId) {
  TRACE();

  IF_CONSTEXPR(isEEGas<SysEqn>)
  TERMM(1, "bc7809 not working for AIAFvSysEqnEEGas");

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  const MInt d = 2;
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->checkNeighborActive(cellId, d)) {
      const MInt nghbrId = m_solver->c_neighborId(cellId, d);
      if(nghbrId < 0) {
        cutOffBcMissingNeighbor(cellId, "bc30022");
      } else {
        m_solver->a_pvariable(cellId, PV->U) = m_solver->a_pvariable(nghbrId, PV->U);
        m_solver->a_pvariable(cellId, PV->V) = m_horTargetData[id][1];
        m_solver->a_pvariable(cellId, PV->W) = m_solver->m_WInfinity;
        m_solver->a_pvariable(cellId, PV->RHO) = m_horTargetData[id][2];
        m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);
      }
    } else {
      m_solver->a_pvariable(cellId, PV->U) = m_solver->m_UInfinity;
      m_solver->a_pvariable(cellId, PV->V) = m_solver->m_VInfinity;
      m_solver->a_pvariable(cellId, PV->W) = m_solver->m_WInfinity;
      m_solver->a_pvariable(cellId, PV->RHO) = m_solver->m_rhoInfinity;
      m_solver->a_pvariable(cellId, PV->P) = m_solver->m_PInfinity;
    }
  }
}
// --- ZONAL ENDS ---

/// Helper method to treat cut-off cells without a neighbor in a certain direction. This situation
/// should only appear in multisolver cases and if the cell is a halo. That is, the cut-off halo-cell
/// is only created due to additional halos in the multisolver grid and it should not be relevant to
/// the computation. Thus the primitive variables are set to NaN such that any influence of these
/// cells can be detected.
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cutOffBcMissingNeighbor(const MInt cellId, const MString bcName) {
#ifndef NDEBUG
  ASSERT(m_solver->a_isHalo(cellId) && g_multiSolverGrid,
         "Error in " + bcName + ": missing neighbor for (halo) cut-off cell only allowed in multisolver case (halo = "
             + to_string(m_solver->a_isHalo(cellId)) + "; multisolver = " + to_string(g_multiSolverGrid) + ")");
#else
  std::ignore = bcName;
#endif
  const MFloat nanValue = std::numeric_limits<MFloat>::quiet_NaN();
  std::fill_n(&m_solver->a_pvariable(cellId, 0), PV->noVariables, nanValue);
}


/**
 * \fn FvBndryCndXD::bc100100
 * Symmetry boundary condition about x-axis
 * \author Claudia Guenther
 * \date 01/2014
 * \fvbc{FvBndryCndXD::bc100100(), fvbc100100, BC 100100}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc100100(MInt bcId) {
  TRACE();

#ifdef _OPENMP
#pragma omp parallel for
#endif
  // loop over all concerning boundary cells
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    const MInt cellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      const MInt ghostCellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_srfcVariables[0]->m_ghostCellId;

      // set the density
      m_solver->a_pvariable(ghostCellId, PV->RHO) = m_solver->a_pvariable(cellId, PV->RHO);

      // set the velocities
      m_solver->a_pvariable(ghostCellId, PV->U) = m_solver->a_pvariable(cellId, PV->U);
      m_solver->a_pvariable(ghostCellId, PV->V) = -m_solver->a_pvariable(cellId, PV->V);

      // set the pressure of the ghost cell equal to that of the boundary cell
      m_solver->a_pvariable(ghostCellId, PV->P) = m_solver->a_pvariable(cellId, PV->P);

      IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
        for(MInt r = 0; r < m_solver->m_noRansEquations; ++r) {
          m_solver->a_pvariable(ghostCellId, PV->NN[r]) = m_solver->a_pvariable(cellId, PV->N);
        }
      }
    }
  }
}


/**
 * \fn FvBndryCndXD::bc29050()
 * Slip-wall Navier-Stokes boundary condition.
 * \fvcutoffbc{FvBndryCndXD::bc29050(), fvbc29050, BC 29050}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc29050(MInt bcId) {
  TRACE();

  MInt cellId, d;
  MLong nghbrId;
  //---end of initialization

  MInt Dir[nDim];
  for(MInt i = 0; i < nDim; i++) {
    Dir[i] = 1;
  }
  switch(m_cutOffBndryCndIds[bcId]) {
    case 29050:
      d = 1;
      Dir[0] = -1;
      break;
    case 29051:
      d = 0;
      Dir[0] = -1;
      break;
    case 29052:
      d = 2;
      Dir[1] = -1;
      break;
    case 29053:
      d = 3;
      Dir[1] = -1;
      break;
    case 29054:
      IF_CONSTEXPR(nDim == 2) mTerm(1, AT_, "bc29054: symmetry in z-direction not possible for 2D");
      d = 4;
      Dir[2] = -1;
      break;
    case 29055:
      IF_CONSTEXPR(nDim == 2) mTerm(1, AT_, "bc29054: symmetry in z-direction not possible for 2D");
      d = 5;
      Dir[2] = -1;
      break;
    default: {
      stringstream errorMessage;
      errorMessage << "ERROR: Switch variable 'm_cutOffBndryCndIds[ bcId ]' with value " << m_cutOffBndryCndIds[bcId]
                   << " not matching any case." << endl;
      mTerm(1, AT_, errorMessage.str());
    }
  }

  // loop over all concerning cells
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    cellId = m_sortedCutOffCells[bcId]->a[id];
    nghbrId = m_solver->c_neighborId(cellId, d);

    // set the velocities
    m_solver->a_pvariable(cellId, PV->U) = Dir[0] * m_solver->a_pvariable(nghbrId, PV->U);
    m_solver->a_pvariable(cellId, PV->V) = Dir[1] * m_solver->a_pvariable(nghbrId, PV->V);
    IF_CONSTEXPR(nDim == 3) { m_solver->a_pvariable(cellId, PV->W) = Dir[2] * m_solver->a_pvariable(nghbrId, PV->W); }
    // set the density
    m_solver->a_pvariable(cellId, PV->RHO) = m_solver->a_pvariable(nghbrId, PV->RHO);

    // set the density
    m_solver->a_pvariable(cellId, PV->P) = m_solver->a_pvariable(nghbrId, PV->P);

    // set the species
    for(MInt i = 0; i < m_noSpecies; i++) {
      m_solver->a_pvariable(cellId, PV->Y[i]) = m_solver->a_pvariable(nghbrId, PV->Y[i]);
    }
  }
}


/**
 * \fn FvBndryCndXD::cbc1091()
 * Subsonic partially reflecting characteristic inflow condition - cut off \n
 * p0,T0 is prescribed, incl. shear and transverse terms
 * \fvcbc{FvBndryCndXD::cbc1091(), fvcbc1091, CBC 1091}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc1091(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  MInt last = nDim + 1;

  // Allocate memory
  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");

  MFloat mach[2] = {F0, F0};
  cbcMachCo(bcId, mach);
  MFloat meanM = mach[0];
  MFloat maxM = mach[1];

  MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");
  MFloatScratchSpace gradTau(m_cbcViscous ? (nDim * nDim * nDim) : 1, AT_, "gradTau");
  MFloatScratchSpace gradQ(m_cbcViscous ? (nDim * nDim) : 1, AT_, "gradQ");

  MIntScratchSpace cutOffStencilCellIds(m_cbcViscous ? m_solver->a_noCells() : 1, AT_, "cutOffStencilCellIds");
  if(m_cbcViscous) cbcTauQ(bcId, &tau[0], &q[0], &cutOffStencilCellIds[0]);

  MFloat T_target = sysEqn().temperature_IR(meanM);
  MFloat p_Target = sysEqn().pressure_IR(T_target);
  MFloat y_target = F1;

  IF_CONSTEXPR(isDetChem<SysEqn>) {
    T_target = m_solver->m_detChem.infTemperature;
    p_Target = m_solver->m_detChem.infPressure;
  }

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);
    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    V.fill(F0);
    if(m_cbcViscous) {
      cbcGradientsViscous(cellId, bcId, &tau[0], &q[0], &gradTau[0], &gradQ[0], &cutOffStencilCellIds[0]);
      // BC specific
      gradTau[dimN * IPOW2(nDim) + dimT1 * nDim + dimN] = F0;
      IF_CONSTEXPR(nDim == 3) gradTau[dimN * IPOW2(nDim) + dimT2 * nDim + dimN] = F0;
      // END BC specific
      cbcViscousTerms<(unsigned char)01111>(cellId, bcId, &tau[0], &gradTau[0], &gradQ[0], &gradVV[0],
                                            &cutOffStencilCellIds[0], &V[0]);
    }

    cbcOutgoingAmplitudeVariation<1>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
    cbcTransversalTerms<(unsigned char)11111>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &T[0]);
    cbcDampingInflow(cellId, bcId, maxM, &K[0], "pressure");

    const MFloat p = m_solver->a_pvariable(cellId, PV->P);
    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    const MFloat ut1 = m_solver->a_pvariable(cellId, PV->VV[dimT1]);
    MFloat temp = sysEqn().temperature_ES(rho, p);

    IF_CONSTEXPR(isDetChem<SysEqn>) {
      MFloat fMeanMolarWeight = F0;
      for(MUint s = 0; s < PV->m_noSpecies; s++) {
        fMeanMolarWeight += m_solver->a_pvariable(cellId, PV->Y[s]) * m_solver->m_fMolarMass[s];
      }
      MFloat meanMolarWeight = F1 / fMeanMolarWeight;
      temp = p / rho * meanMolarWeight / m_solver->m_gasConstant;
    }

    const MFloat a = sysEqn().speedOfSound(rho, p);

    if(dirN % 2 == 0) {
      L[0] = K[0] * (p - p_Target) + (T[last] - rho * a * T[1]) + (V[last] - rho * a * V[1]);
    } else {
      L[last] = K[last] * (p - p_Target) + (T[last] + rho * a * T[1]) + (V[last] + rho * a * V[1]);
    }

    L[1] = K[1] * (temp - T_target) + (a * a * T[0] - T[last]) - V[last];

    L[2] = K[2] * ut1 + T[2] + V[2];

    IF_CONSTEXPR(nDim == 3) {
      const MFloat ut2 = m_solver->a_pvariable(cellId, PV->VV[dimT2]);
      L[3] = K[3] * ut2 + T[3] + V[3];
    }
    for(MInt s = 0; s < m_solver->m_noSpecies; s++) {
      MFloat y = m_solver->a_pvariable(cellId, sysEqn().PV->Y[s]);
      L[last + 1 + s] = K[last + 1 + s] * (y - y_target);
    }

    IF_CONSTEXPR(isDetChem<SysEqn>) {
      for(MInt s = 0; s < m_solver->m_noSpecies; s++) {
        MFloat y = m_solver->a_pvariable(cellId, sysEqn().PV->Y[s]);
        L[last + 1 + s] = K[last + 1 + s] * (y - m_solver->m_YInfinity[s]);
      }
    }

    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);
  }
}

/**
 * \fn void FvBndryCndXD<nDim, SysEqn>::cbc1091b(MInt)
 * Subsonic fully reflecting characteristic inflow condition - cut off \n
 * T0,u,v is prescribed, incl. transverse terms
 * \fvcbc{FvBndryCndXD::cbc1091b(), fvcbc1091b, CBC 1091B}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc1091b(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];

  MInt last = nDim + 1;

  // Allocate memory
  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);

  MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");
  MFloatScratchSpace gradTau(m_cbcViscous ? (nDim * nDim * nDim) : 1, AT_, "gradTau");
  MFloatScratchSpace gradQ(m_cbcViscous ? (nDim * nDim) : 1, AT_, "gradQ");

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");

  MFloat mach[2] = {F0, F0};
  cbcMachCo(bcId, mach);
  MFloat meanM = mach[0];
  MFloat maxM = mach[1];

  const MFloat gammaMinusOne = m_solver->m_gamma - 1.0;

  // BC specific
  MBool solverProfile = Context::getSolverProperty<MBool>("solverProfile", m_solverId, AT_, &solverProfile);
  MFloat A = F0;
  IF_CONSTEXPR(nDim == 3) { A = sqrt(m_cbcInflowArea[cbcId] / PI); }
  else {
    A = m_cbcInflowArea[cbcId] * F1B2;
  }
  MFloat testSum2 = F0;
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    MInt bndryId = m_solver->a_bndryId(cellId);

    MFloat area;
    if(bndryId > -1) {
      MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dirN];
      if(srfcId > -1) {
        area = m_solver->a_surfaceArea(srfcId);
      } else {
        mTerm(1, AT_, "something went wrong!");
      }
    } else {
      IF_CONSTEXPR(nDim == 2) area = m_solver->c_cellLengthAtCell(cellId);
      IF_CONSTEXPR(nDim == 3) area = POW2(m_solver->c_cellLengthAtCell(cellId));
    }

    MFloat rsquare;
    IF_CONSTEXPR(nDim == 2) {
      rsquare = POW2((m_solver->a_coordinate(cellId, dimT1) - m_cbcReferencePoint[cbcId][dimT1]));
    }
    else {
      rsquare = POW2(m_solver->a_coordinate(cellId, 0) - m_cbcReferencePoint[cbcId][0])
                + POW2(m_solver->a_coordinate(cellId, 1) - m_cbcReferencePoint[cbcId][1])
                + POW2(m_solver->a_coordinate(cellId, 2) - m_cbcReferencePoint[cbcId][2]);
    }
    testSum2 += area * rsquare;
  }
  MPI_Allreduce(MPI_IN_PLACE, &testSum2, 3, MPI_DOUBLE, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                "testSum2", "testSum2Result");


  MFloat massflux_test;
  IF_CONSTEXPR(nDim == 2) { massflux_test = F3B4 / A * (m_cbcInflowArea[cbcId] - F1 / (A * A) * testSum2); }
  else {
    massflux_test = F2 * (F1 - testSum2 / (m_cbcInflowArea[cbcId] * A * A));
  }
  MFloat un_correctionFactor = F1;
  if(fabs(massflux_test) > m_solver->m_eps) {
    un_correctionFactor = F1 / massflux_test;
  }
  // END BC specific

  // Target values
  MFloat massflux_target;
  massflux_target = m_solver->m_UInfinity * m_cbcInflowArea[cbcId]
                    * sysEqn().density_ES(m_solver->m_PInfinity, m_solver->m_TInfinity);
  MFloat T_target = sysEqn().temperature_IR(meanM);

  MIntScratchSpace cutOffStencilCellIds(m_cbcViscous ? m_solver->a_noCells() : 1, AT_, "cutOffStencilCellIds");
  if(m_cbcViscous) cbcTauQ(bcId, &tau[0], &q[0], &cutOffStencilCellIds[0]);

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);
    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    V.fill(F0);
    if(m_cbcViscous) {
      cbcGradientsViscous(cellId, bcId, &tau[0], &q[0], &gradTau[0], &gradQ[0], &cutOffStencilCellIds[0]);
      cbcViscousTerms<(unsigned char)01111>(cellId, bcId, &tau[0], &gradTau[0], &gradQ[0], &gradVV[0],
                                            &cutOffStencilCellIds[0], &V[0]);
    }

    cbcOutgoingAmplitudeVariation<1>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
    cbcTransversalTerms<(unsigned char)11111>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &T[0]);
    cbcDampingInflow(cellId, bcId, maxM, &K[0], "velocity");

    MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat a = sysEqn().speedOfSound(rho, p);

    MFloat rsquare;
    MFloat un_target;
    if(nDim == 2) {
      rsquare = POW2((m_solver->a_coordinate(cellId, dimT1) - m_cbcReferencePoint[cbcId][dimT1]));
      un_target = F3B4 * massflux_target / rho / A * (1 - rsquare / (A * A)) * un_correctionFactor;
    } else {
      rsquare = POW2(m_solver->a_coordinate(cellId, 0) - m_cbcReferencePoint[cbcId][0])
                + POW2(m_solver->a_coordinate(cellId, 1) - m_cbcReferencePoint[cbcId][1])
                + POW2(m_solver->a_coordinate(cellId, 2) - m_cbcReferencePoint[cbcId][2]);
      un_target = F2 * massflux_target / m_cbcInflowArea[cbcId] * (F1 - rsquare / (A * A)) / rho * un_correctionFactor;
    }
    if(solverProfile) {
      un_target = massflux_target / m_cbcInflowArea[cbcId] / rho;
    }

    // BC specific
    L[2] = F0;
    L[3] = F0;
    T[2] = F0;
    T[3] = F0;
    // END BC specific

    if(dirN % 2 == 0) {
      L[0] = L[last] + (T[last] - rho * a * T[1]);
    } else {
      L[last] = L[0] + (T[last] + rho * a * T[1]);
    }

    L[1] = F1B2 * gammaMinusOne * (L[0] + L[last]) + (a * a * T[0] - T[last]);

    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);

    m_solver->a_rightHandSide(cellId, CV->RHO_VV[dimN]) = F0;
    m_solver->a_rightHandSide(cellId, CV->RHO_VV[dimT1]) = F0;
    m_solver->a_rightHandSide(cellId, CV->RHO_E) = F0;
    MFloat sign = F1;
    if(dirN % 2 == 0) {
      sign = -F1;
    }
    m_solver->a_pvariable(cellId, PV->VV[dimN]) = un_target * sign;
    m_solver->a_pvariable(cellId, PV->VV[dimT1]) = F0;
    m_solver->a_pvariable(cellId, PV->P) = T_target;
    IF_CONSTEXPR(nDim == 3) {
      MInt dimT2 = m_cbcDir[cbcId][nDim];
      m_solver->a_rightHandSide(cellId, CV->RHO_VV[dimT2]) = F0;
      m_solver->a_pvariable(cellId, PV->VV[dimT1]) = F0;
    }
  }
}


/** \brief Subsonic fully reflecting characteristic inflow condition - cut off - sets T0,u,v to prescribed value after
 * rkstep
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc1091b_after(MInt bcId) {
  TRACE();
  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    if(m_solver->a_isHalo(cellId)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    const MInt bndryId = m_solver->a_bndryId(cellId);

    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) {
        continue;
      }
    }

    // recompute the correct energy:
    const MFloat rho = m_solver->a_variable(cellId, CV->RHO);
    const MFloat u = m_solver->a_pvariable(cellId, PV->VV[0]);
    const MFloat v = m_solver->a_pvariable(cellId, PV->VV[1]);
    const MFloat T = m_solver->a_pvariable(cellId, PV->P);
    const MFloat p = sysEqn().pressure_ES(T, rho);
    MFloat velSquared = u * u + v * v;
    IF_CONSTEXPR(nDim == 3) {
      const MFloat w = m_solver->a_pvariable(cellId, PV->VV[2]);
      m_solver->a_variable(cellId, CV->RHO_VV[2]) = rho * w;
      velSquared += w * w;
    }
    m_solver->a_variable(cellId, CV->RHO_E) = sysEqn().internalEnergy(p, rho, velSquared);
    m_solver->a_variable(cellId, CV->RHO_VV[0]) = rho * u;
    m_solver->a_variable(cellId, CV->RHO_VV[1]) = rho * v;
  }
}


/**
 * \fn FvBndryCndXD::cbc1091c()
 * Subsonic partially reflecting characteristic inflow condition - cut off \n
 * p0,T0,v is prescribed, incl. shear
 * and transverse terms
 * \fvcbc{FvBndryCndXD::cbc1091c(), fvcbc1091c, CBC 1091C}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc1091c(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  MInt last = nDim + 1;

  // Allocate memory
  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);

  MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");
  MFloatScratchSpace gradTau(m_cbcViscous ? (nDim * nDim * nDim) : 1, AT_, "gradTau");
  MFloatScratchSpace gradQ(m_cbcViscous ? (nDim * nDim) : 1, AT_, "gradQ");

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");

  MFloat mach[2] = {F0, F0};
  cbcMachCo(bcId, mach);
  MFloat meanM = mach[0];
  MFloat maxM = mach[1];

  const MFloat gammaMinusOne = m_solver->m_gamma - 1.0;

  MIntScratchSpace cutOffStencilCellIds(m_cbcViscous ? m_solver->a_noCells() : 1, AT_, "cutOffStencilCellIds");
  if(m_cbcViscous) cbcTauQ(bcId, &tau[0], &q[0], &cutOffStencilCellIds[0]);

  MFloat T_target = sysEqn().temperature_IR(meanM);
  MFloat p_Target = sysEqn().pressure_IR(T_target);

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);
    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    V.fill(F0);
    if(m_cbcViscous) {
      cbcGradientsViscous(cellId, bcId, &tau[0], &q[0], &gradTau[0], &gradQ[0], &cutOffStencilCellIds[0]);
      gradTau[dimN * IPOW2(nDim) + dimT1 * nDim + dimN] = F0;
      IF_CONSTEXPR(nDim == 3) gradTau[dimN * IPOW2(nDim) + dimT2 * nDim + dimN] = F0;
      cbcViscousTerms<(unsigned char)01111>(cellId, bcId, &tau[0], &gradTau[0], &gradQ[0], &gradVV[0],
                                            &cutOffStencilCellIds[0], &V[0]);
    }

    cbcOutgoingAmplitudeVariation<1>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
    cbcTransversalTerms<(unsigned char)11111>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &T[0]);
    cbcDampingInflow(cellId, bcId, maxM, &K[0], "pressure");

    MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat a = sysEqn().speedOfSound(rho, p);

    if(dirN % 2 == 0) {
      L[0] = -L[last] + (T[last] - rho * a * T[1]) + (V[last] - rho * a * V[1]);
    } else {
      L[last] = -L[0] + (T[last] + rho * a * T[1]) + (V[last] + rho * a * V[1]);
    }

    L[1] = F1B2 * gammaMinusOne * (L[last] - L[0]) + (a * a * T[0] - T[last]) - V[last];

    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);

    m_solver->a_rightHandSide(cellId, CV->RHO) = 0.0;
    m_solver->a_rightHandSide(cellId, CV->RHO_VV[dimT1]) = 0.0;
    m_solver->a_rightHandSide(cellId, CV->RHO_E) = 0.0;
    IF_CONSTEXPR(nDim == 3) { m_solver->a_rightHandSide(cellId, CV->RHO_VV[dimT2]) = 0.0; }
    m_solver->a_pvariable(cellId, PV->RHO) = sysEqn().density_ES(p_Target, T_target);
    m_solver->a_pvariable(cellId, PV->VV[dimT1]) = 0.0;
    IF_CONSTEXPR(nDim == 3) { m_solver->a_pvariable(cellId, PV->VV[dimT2]) = 0.0; }
    m_solver->a_pvariable(cellId, PV->P) = p_Target;
  }
}


/** \brief Subsonic fully reflecting characteristic inflow condition - cut off - sets T0,u,v to prescribed value after
 * rkstep
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc1091c_after(MInt bcId) {
  TRACE();

  MInt otherDir[2 * nDim];
  for(MInt dim = 0; dim < nDim; dim++) {
    otherDir[2 * dim] = 2 * dim + 1;
    otherDir[2 * dim + 1] = 2 * dim;
  }

  MBool& first = m_static_cbc1091c_after_first;
  MInt& dirN = m_static_cbc1091c_after_dirN;
  MInt& dimN = m_static_cbc1091c_after_dimN;
  MInt& dimT1 = m_static_cbc1091c_after_dimT1;
  MInt& dimT2 = m_static_cbc1091c_after_dimT2;

  if(first) {
    MInt noCutOffBndryIds = Context::propertyLength("cutOffBndryIds", m_solverId);
    MInt noCutOffDirections = Context::propertyLength("cutOffDirections", m_solverId);
    if(noCutOffDirections != noCutOffBndryIds) {
      mTerm(1, AT_,
            "Wrong number of cut off directions. Must be identical to number of cut off bndryIds! Please check!");
    }
    MInt cutOffBndryIdTmp, cutOffDirectionTmp;
    for(MInt i = 0; i < noCutOffBndryIds; i++) {
      cutOffBndryIdTmp = Context::getSolverProperty<MInt>("cutOffBndryIds", m_solverId, AT_, i);
      cutOffDirectionTmp = Context::getSolverProperty<MInt>("cutOffDirections", m_solverId, AT_, i);
      if(cutOffBndryIdTmp == m_cutOffBndryCndIds[bcId]) {
        dirN = otherDir[cutOffDirectionTmp];
        break;
      }
    }
    dimN = (MInt)dirN / 2;
    dimT1 = (dimN + 1) % nDim;
    IF_CONSTEXPR(nDim == 3) dimT2 = (dimT1 + 1) % nDim;

    first = false;
  }

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    if(m_solver->a_isHalo(cellId)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);

    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) {
        continue;
      }
    }

    // recompute the correct energy:
    MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    MFloat u = m_solver->a_variable(cellId, CV->RHO_VV[dimN]) / m_solver->a_variable(cellId, CV->RHO);
    MFloat v = m_solver->a_pvariable(cellId, PV->VV[dimT1]);
    MFloat p = m_solver->a_pvariable(cellId, PV->P);
    const MFloat vel = POW2(u) + POW2(v);
    MFloat E = sysEqn().internalEnergy(p, rho, vel);

    IF_CONSTEXPR(nDim == 3) {
      // compute corrected energy
      MFloat w = m_solver->a_pvariable(cellId, PV->VV[dimT2]);
      E += F1B2 * (w * w) * rho;
      m_solver->a_variable(cellId, CV->RHO_VV[dimT2]) = rho * w;
    }

    m_solver->a_variable(cellId, CV->RHO_E) = E;
  }
}


/**
 * \fn FvBndryCndXD::cbc1091d()
 * Subsonic partially reflecting characteristic inflow condition - cut off \n
 * p0,T0,v is prescribed, incl. shear and transverse terms, profile of un is prescribed
 * \fvcbc{FvBndryCndXD::cbc1091d(), fvcbc1091d, CBC 1091D}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc1091d(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cbcId = m_cbcBndryCndIds[bcId];
  // Determine dirs
  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];

  MInt last = nDim + 1;

  // Allocate memory
  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);

  MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");
  MFloatScratchSpace gradTau(m_cbcViscous ? (nDim * nDim * nDim) : 1, AT_, "gradTau");
  MFloatScratchSpace gradQ(m_cbcViscous ? (nDim * nDim) : 1, AT_, "gradQ");

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");

  // Get mean/max mach number
  MFloat mach[2] = {F0, F0};
  cbcMachCo(bcId, mach);
  MFloat meanM = mach[0];
  MFloat maxM = mach[1];

  // BC specific
  MBool solverProfile = Context::getSolverProperty<MBool>("solverProfile", m_solverId, AT_, &solverProfile);
  MFloat A = F0;
  IF_CONSTEXPR(nDim == 3) { A = sqrt(m_cbcInflowArea[cbcId] / PI); }
  else {
    A = m_cbcInflowArea[cbcId] * F1B2;
  }
  MFloat testSum2 = F0;
  MFloat massflux = F0;
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    MInt bndryId = m_solver->a_bndryId(cellId);
    MInt nghbrN = m_solver->c_neighborId(cellId, dirN);

    MFloat area;
    if(bndryId > -1) {
      MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dirN];
      if(srfcId > -1) {
        area = m_solver->a_surfaceArea(srfcId);
      } else {
        mTerm(1, AT_, "something went wrong!");
      }
    } else {
      IF_CONSTEXPR(nDim == 2) area = m_solver->c_cellLengthAtCell(cellId);
      IF_CONSTEXPR(nDim == 3) area = POW2(m_solver->c_cellLengthAtCell(cellId));
    }

    MFloat rsquare;
    IF_CONSTEXPR(nDim == 2) {
      rsquare = POW2((m_solver->a_coordinate(cellId, dimT1) - m_cbcReferencePoint[cbcId][dimT1]));
    }
    else {
      rsquare = POW2(m_solver->a_coordinate(cellId, 0) - m_cbcReferencePoint[cbcId][0])
                + POW2(m_solver->a_coordinate(cellId, 1) - m_cbcReferencePoint[cbcId][1])
                + POW2(m_solver->a_coordinate(cellId, 2) - m_cbcReferencePoint[cbcId][2]);
    }
    testSum2 += area * rsquare;
    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    const MFloat un_N = m_solver->a_pvariable(nghbrN, PV->VV[dimN]);
    massflux += un_N * area * rho;
  }

  MPI_Allreduce(MPI_IN_PLACE, &massflux, 3, MPI_DOUBLE, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                "massflux", "massfluxResult");
  MPI_Allreduce(MPI_IN_PLACE, &testSum2, 3, MPI_DOUBLE, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                "testSum2", "testSum2Result");

  MFloat massflux_test;
  IF_CONSTEXPR(nDim == 2) { massflux_test = F3B4 / A * (m_cbcInflowArea[cbcId] - F1 / (A * A) * testSum2); }
  else {
    massflux_test = F2 * (F1 - testSum2 / (m_cbcInflowArea[cbcId] * A * A));
  }
  MFloat un_correctionFactor = F1;
  if(fabs(massflux_test) > m_solver->m_eps) {
    un_correctionFactor = F1 / massflux_test;
  }
  // END BC specific

  MIntScratchSpace cutOffStencilCellIds(m_cbcViscous ? m_solver->a_noCells() : 1, AT_, "cutOffStencilCellIds");
  if(m_cbcViscous) cbcTauQ(bcId, &tau[0], &q[0], &cutOffStencilCellIds[0]);

  MFloat T_target = sysEqn().temperature_IR(meanM);
  MFloat p_Target = sysEqn().pressure_IR(T_target);

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);
    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    if(m_cbcViscous) {
      cbcGradientsViscous(cellId, bcId, &tau[0], &q[0], &gradTau[0], &gradQ[0], &cutOffStencilCellIds[0]);
    }

    MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    MFloat ut1 = m_solver->a_pvariable(cellId, PV->VV[dimT1]);
    MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat temp = sysEqn().temperature_ES(rho, p);
    MFloat a = sysEqn().speedOfSound(rho, p);

    MFloat un_target;
    IF_CONSTEXPR(nDim == 3) {
      MFloat rsquare = POW2(m_solver->a_coordinate(cellId, 0) - m_cbcReferencePoint[cbcId][0])
                       + POW2(m_solver->a_coordinate(cellId, 1) - m_cbcReferencePoint[cbcId][1])
                       + POW2(m_solver->a_coordinate(cellId, 2) - m_cbcReferencePoint[cbcId][2]);
      un_target = F2 * massflux / m_cbcInflowArea[cbcId] * (F1 - rsquare / (A * A)) / un_correctionFactor;
    }
    else {
      MFloat rsquare = POW2((m_solver->a_coordinate(cellId, dimT1) - m_cbcReferencePoint[cbcId][dimT1]));
      if(!solverProfile) {
        const MFloat mu = sysEqn().sutherlandLaw(temp);
        if(m_cbcViscous)
          gradTau[dimN * IPOW2(nDim) + dimT1 * nDim + dimT1] =
              -mu * F3B2 * massflux / (rho * A * A * A) * un_correctionFactor;
      }
      un_target = F3B4 * massflux / A * (1 - rsquare / (A * A)) * un_correctionFactor;
      if(solverProfile) {
        un_target = m_solver->m_UInfinity;
      }
    }

    V.fill(F0);
    if(m_cbcViscous)
      cbcViscousTerms<(unsigned char)01111>(cellId, bcId, &tau[0], &gradTau[0], &gradQ[0], &gradVV[0],
                                            &cutOffStencilCellIds[0], &V[0]);

    cbcOutgoingAmplitudeVariation<1>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
    cbcTransversalTerms<(unsigned char)11111>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &T[0]);
    cbcDampingInflow(cellId, bcId, maxM, &K[0], "pressure");

    if(dirN % 2 == 0) {
      L[0] = K[0] * (p - p_Target) + (T[last] - rho * a * T[1]) + (V[last] - rho * a * V[1]);
    } else {
      L[last] = K[last] * (p - p_Target) + (T[last] + rho * a * T[1]) + (V[last] + rho * a * V[1]);
    }

    L[1] = K[1] * (temp - T_target) + (a * a * T[0] - T[last]) - V[last];
    L[2] = K[2] * ut1 + T[2] + V[2];
    IF_CONSTEXPR(nDim == 3) {
      MInt dimT2 = m_cbcDir[cbcId][nDim];
      MFloat ut2 = m_solver->a_pvariable(cellId, PV->VV[dimT2]);
      L[3] = K[3] * ut2 + T[3] + V[3];
    }

    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);
    m_solver->a_pvariable(cellId, PV->VV[dimN]) = un_target;
  }
}


/** \brief Subsonic fully reflecting characteristic inflow condition - cut off - sets un to prescribed value after
 * rkstep
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc1091d_after(MInt bcId) {
  TRACE();

  MInt otherDir[2 * nDim];
  for(MInt dim = 0; dim < nDim; dim++) {
    otherDir[2 * dim] = 2 * dim + 1;
    otherDir[2 * dim + 1] = 2 * dim;
  }

  MBool& first = m_static_cbc1091d_after_first;
  MInt& dirN = m_static_cbc1091d_after_dirN;
  MInt& dimN = m_static_cbc1091d_after_dimN;
  MInt& dimT1 = m_static_cbc1091d_after_dimT1;
  MInt& dimT2 = m_static_cbc1091d_after_dimT2;

  if(first) {
    MInt noCutOffBndryIds = Context::propertyLength("cutOffBndryIds", m_solverId);
    MInt noCutOffDirections = Context::propertyLength("cutOffDirections", m_solverId);
    if(noCutOffDirections != noCutOffBndryIds) {
      mTerm(1, AT_,
            "Wrong number of cut off directions. Must be identical to number of cut off bndryIds! Please check!");
    }
    MInt cutOffBndryIdTmp, cutOffDirectionTmp;
    for(MInt i = 0; i < noCutOffBndryIds; i++) {
      cutOffBndryIdTmp = Context::getSolverProperty<MInt>("cutOffBndryIds", m_solverId, AT_, i);
      cutOffDirectionTmp = Context::getSolverProperty<MInt>("cutOffDirections", m_solverId, AT_, i);
      if(cutOffBndryIdTmp == m_cutOffBndryCndIds[bcId]) {
        dirN = otherDir[cutOffDirectionTmp];
        break;
      }
    }
    dimN = (MInt)dirN / 2;
    dimT1 = (dimN + 1) % nDim;
    IF_CONSTEXPR(nDim == 3) dimT2 = (dimT1 + 1) % nDim;

    first = false;
  }

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    if(m_solver->a_isHalo(cellId)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);

    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) {
        continue;
      }
    }

    // recompute the correct energy:
    MFloat rho = m_solver->a_variable(cellId, CV->RHO);
    MFloat u = m_solver->a_pvariable(cellId, PV->VV[dimN]);
    MFloat u_wrong = m_solver->a_variable(cellId, CV->RHO_VV[dimN]) / m_solver->a_variable(cellId, CV->RHO);
    MFloat v = m_solver->a_variable(cellId, CV->RHO_VV[dimT1]) / m_solver->a_variable(cellId, CV->RHO);

    MFloat Sum_sq_u = u_wrong * u_wrong + v * v;
    MFloat E;
    IF_CONSTEXPR(nDim == 2) {
      MFloat p = sysEqn().pressure(rho, Sum_sq_u, m_solver->a_variable(cellId, CV->RHO_E));
      E = sysEqn().internalEnergy(p, rho, (u * u + v * v));
    }
    IF_CONSTEXPR(nDim == 3) {
      MFloat w = m_solver->a_variable(cellId, CV->RHO_VV[dimT2]) / m_solver->a_variable(cellId, CV->RHO);
      MFloat p = sysEqn().pressure(rho, Sum_sq_u, m_solver->a_variable(cellId, CV->RHO_E));
      Sum_sq_u += w * w;
      E = sysEqn().internalEnergy(p, rho, (u * u + v * v + w * w));
    }
    m_solver->a_variable(cellId, CV->RHO_VV[dimN]) = rho * u;
    m_solver->a_variable(cellId, CV->RHO_E) = E;
  }
}

/**
 * \fn FvBndryCndXD::cbc1099a()
 * Subsonic fully reflecting characteristic outflow condition - cut off \n
 * pstat is set, incl. shear and transverse terms
 * \fvcbc{FvBndryCndXD::cbc1099a(), fvcbc1099a, CBC 1099A}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc1099a(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  MInt last = nDim + 1;

  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);

  MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");
  MFloatScratchSpace gradTau(m_cbcViscous ? (nDim * nDim * nDim) : 1, AT_, "gradTau");
  MFloatScratchSpace gradQ(m_cbcViscous ? (nDim * nDim) : 1, AT_, "gradQ");

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");

  MFloat mach[2];
  cbcMachCo(bcId, mach);
  MFloat meanM = mach[0];
  MFloat maxM = mach[1];

  MIntScratchSpace cutOffStencilCellIds(m_cbcViscous ? m_solver->a_noCells() : 1, AT_, "cutOffStencilCellIds");
  if(m_cbcViscous) cbcTauQ(bcId, &tau[0], &q[0], &cutOffStencilCellIds[0]);

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    V.fill(F0);
    if(m_cbcViscous) {
      cbcGradientsViscous(cellId, bcId, &tau[0], &q[0], &gradTau[0], &gradQ[0], &cutOffStencilCellIds[0]);
      gradQ[dimN * nDim + dimN] = F0;
      gradTau[dimN * IPOW2(nDim) + dimT1 * nDim + dimN] = F0;
      IF_CONSTEXPR(nDim == 3) { gradTau[dimN * IPOW2(nDim) + dimT2 * nDim + dimN] = F0; }
      cbcViscousTerms<(unsigned char)11111>(cellId, bcId, &tau[0], &gradTau[0], &gradQ[0], &gradVV[0],
                                            &cutOffStencilCellIds[0], &V[0]);
    }

    cbcOutgoingAmplitudeVariation<0>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
    cbcTransversalTerms<(unsigned char)11111>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &T[0]);
    cbcDampingOutflow(cellId, bcId, maxM, &K[0]);

    MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat a = sysEqn().speedOfSound(rho, p);
    const MFloat targetPressure = m_solver->m_PInfinity - m_deltaPL;

    MFloat beta = meanM;
    if(dirN % 2 == 0) {
      L[0] = -L[last] + (F1 - beta) * (T[last] - rho * a * T[1]) + (V[last] - rho * a * V[1]);
    } else {
      L[last] = -L[0] + (F1 - beta) * (T[last] + rho * a * T[1]) + (V[last] + rho * a * V[1]);
    }
    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);
    m_solver->a_rightHandSide(cellId, CV->RHO_E) = 0.0;
    m_solver->a_pvariable(cellId, PV->P) = targetPressure;
  }
}


/** \brief Subsonic fully reflecting characteristic outflow condition - cut off - sets pstat to prescribed value after
 * rkstep
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc1099a_after(MInt bcId) {
  TRACE();

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);
    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    // recompute the correct energy:
    MFloat rho = m_solver->a_variable(cellId, CV->RHO);
    MFloat u = m_solver->a_variable(cellId, CV->RHO_U) / rho;
    MFloat v = m_solver->a_variable(cellId, CV->RHO_V) / rho;
    MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat E = sysEqn().internalEnergy(p, rho, (u * u + v * v));
    IF_CONSTEXPR(nDim == 3) {
      MFloat w = m_solver->a_variable(cellId, CV->RHO_W) / rho;
      E = sysEqn().internalEnergy(p, rho, (u * u + v * v + w * w));
    }

    m_solver->a_variable(cellId, CV->RHO_E) = E;
  }
}

/**
 * \fn FvBndryCndXD::cbc1099_1091_local()
 * Subsonic partially reflecting characteristic outflow/inflow condition - cut off \n
 * TODO: Great differences between 2D- and 3D-versions, should be checked
 * \fvcbc{FvBndryCndXD::cbc1099_1091_local(), fvcbc1099_1091_local, CBC 1099 1091 Local}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc1099_1091_local(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  MFloat& targetPressure = m_static_cbc1099_1091_local_targetPressure;
  MFloat& R = m_static_cbc1099_1091_local_R;
  MFloat& H = m_static_cbc1099_1091_local_H;

  MFloat inflowArea = m_cbcInflowArea[cbcId];
  IF_CONSTEXPR(nDim == 3) { R = sqrt(inflowArea / PI); }
  IF_CONSTEXPR(nDim == 2) {
    targetPressure = sysEqn().p_Ref();
    H = inflowArea * F1B2;
  }

  MInt last = nDim + 1;
  // MInt last = 4;
  if(last != 4) mTerm(1, AT_, "Last is not four!");

  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);

  MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");
  MFloatScratchSpace gradTau(m_cbcViscous ? (nDim * nDim * nDim) : 1, AT_, "gradTau");
  MFloatScratchSpace gradQ(m_cbcViscous ? (nDim * nDim) : 1, AT_, "gradQ");

  MIntScratchSpace cutOffStencilCellIds(m_cbcViscous ? m_solver->a_noCells() : 1, AT_, "cutOffStencilCellIds");
  if(m_cbcViscous) cbcTauQ(bcId, &tau[0], &q[0], &cutOffStencilCellIds[0]);

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");

  MFloat massflux = F0;
  MFloat T_mean = F0;
  MFloat massflux_pos = F0;
  MFloat massflux_neg = F0;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    MInt bndryId = m_solver->a_bndryId(cellId);

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MFloat area = -1;
    if(bndryId > -1) {
      MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dirN];
      if(srfcId > -1) {
        area = m_solver->a_surfaceArea(srfcId);
        IF_CONSTEXPR(nDim == 3) ASSERT(area <= POW2(m_solver->c_cellLengthAtCell(cellId)), "");
      } else {
        mTerm(1, AT_, "something went wrong!");
      }
    } else {
      IF_CONSTEXPR(nDim == 2) area = m_solver->c_cellLengthAtCell(cellId);
      IF_CONSTEXPR(nDim == 3) area = POW2(m_solver->c_cellLengthAtCell(cellId));
    }

    ASSERT(area > -1, "");
    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    const MFloat p = m_solver->a_pvariable(cellId, PV->P);
    const MFloat un = m_solver->a_pvariable(cellId, PV->VV[dimN]);
    const MFloat Temp = sysEqn().temperature_ES(rho, p);
    MInt nghbrN = m_solver->c_neighborId(cellId, dirN);
    const MFloat un_N = m_solver->a_pvariable(nghbrN, PV->VV[dimN]);


    if(rho < F0 || std::isnan(rho) || std::isnan(un)) {
      cerr << "NAN detected in cutOff-Cell " << m_solver->c_globalId(cellId) << " " << m_solver->a_isHalo(cellId) << " "
           << m_solver->a_bndryId(cellId) << " " << rho << endl;
    }

    if(un_N > F0) {
      massflux_pos += un_N * area;
    } else {
      massflux_neg += un_N * area;
    }

    massflux += un_N * area * rho;
    T_mean += Temp * area;
  }

  MFloat mach[2] = {F0, F0};
  cbcMachCo(bcId, mach);
  MFloat meanM = mach[0];
  MFloat maxM = mach[1];

  MInt noExchangeData = 4;
  MFloatScratchSpace comm_buff(noExchangeData, AT_, "comm_buff");
  MFloatScratchSpace comm_buff_result(noExchangeData, AT_, "comm_buff_result");
  comm_buff[0] = massflux;
  comm_buff[1] = T_mean;
  comm_buff[2] = massflux_pos;
  comm_buff[3] = massflux_neg;

  MPI_Allreduce(&comm_buff[0], &comm_buff_result[0], 4, MPI_DOUBLE, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]],
                AT_, "comm_buff[0]", "comm_buff_result[0]");

  massflux = comm_buff_result[0];
  T_mean = comm_buff_result[1];
  massflux_pos = comm_buff_result[2];
  massflux_neg = comm_buff_result[3];

  T_mean /= inflowArea;

  const MFloat gammaMinusOne = m_solver->m_gamma - 1.0;

  MFloat T_target = 1 - gammaMinusOne * F1B2 * (massflux * massflux / inflowArea / inflowArea);
  MFloat p_Target = sysEqn().pressure_IR(T_target);

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);
    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    V.fill(F0);
    if(m_cbcViscous) {
      cbcGradientsViscous(cellId, bcId, &tau[0], &q[0], &gradTau[0], &gradQ[0], &cutOffStencilCellIds[0]);
      gradTau[dimN * IPOW2(nDim) + dimT1 * nDim + dimN] = F0;
      IF_CONSTEXPR(nDim == 3) { gradTau[dimN * IPOW2(nDim) + dimT2 * nDim + dimN] = F0; }
      cbcViscousTerms<(unsigned char)01111>(cellId, bcId, &tau[0], &gradTau[0], &gradQ[0], &gradVV[0],
                                            &cutOffStencilCellIds[0], &V[0]);
    }

    cbcTransversalTerms<(unsigned char)11111>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &T[0]);

    // This is where you differentiate between inflow and outflow
    MFloat un_mean = m_solver->a_pvariable(cellId, PV->VV[dimN]);

    MBool hasBndryNghbr = false;
    for(MInt nghbr = 0; nghbr < m_solver->a_noReconstructionNeighbors(cellId); nghbr++) {
      MInt recNghbr = m_solver->a_reconstructionNeighborId(cellId, nghbr);
      if(m_solver->a_bndryId(recNghbr) > -1) hasBndryNghbr = true;
    }

    MFloat massFluxSum = (abs(massflux_neg) + abs(massflux_pos));
    MFloat negMassFluxFactor = F0;
    MFloat posMassFluxFactor = F0;
    if(massFluxSum > m_solver->m_eps) {
      negMassFluxFactor = abs(massflux_neg) / massFluxSum;
      posMassFluxFactor = abs(massflux_pos) / massFluxSum;
    } else {
      if(dirN % 2 == 0) {
        negMassFluxFactor = F1;
      } else {
        posMassFluxFactor = F1;
      }
    }

    MBool isInflow = true;
    if(dirN % 2 == 0) {
      if(un_mean > F0) {
        isInflow = false;
      } else {
        T_target = negMassFluxFactor * T_target + posMassFluxFactor * T_mean;
      }
    } else {
      if(un_mean < F0) {
        isInflow = false;
      } else {
        T_target = posMassFluxFactor * T_target + posMassFluxFactor * T_mean;
      }
    }

    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    const MFloat ut1 = m_solver->a_pvariable(cellId, PV->VV[dimT1]);
    const MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat a = sysEqn().speedOfSound(rho, p);
    const MFloat Temp = sysEqn().temperature_ES(rho, p);

    if(isInflow) {
      targetPressure = p_Target;
      MFloat beta = F0;

      cbcOutgoingAmplitudeVariation<1>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
      cbcDampingInflow(cellId, bcId, maxM, &K[0], "pressure");

      MFloat LN = 100;
      K[0] = K[0] * m_cbcLref[cbcId] / LN;
      K[1] = K[1] * m_cbcLref[cbcId] / LN;
      K[2] = K[2] * m_cbcLref[cbcId] / LN * 100;
      K[last] = K[last] * m_cbcLref[cbcId] / LN;

      MFloat ceta = F1;
      if(dirN % 2 == 0)
        ceta = -F1;
      else
        ceta = F1;

      // Timw: don't use BndryNghbr-correction!
      if((m_solver->a_bndryId(cellId) > -1 || hasBndryNghbr) && false) {
        if(dirN % 2 == 0) {
          L[0] = K[0] * (p - targetPressure);
        } else {
          L[last] = K[last] * (p - targetPressure);
        }
        L[1] = K[1] * (Temp - T_target);
        L[2] = K[2] * ut1;
        IF_CONSTEXPR(nDim == 3) {
          const MFloat ut2 = m_solver->a_pvariable(cellId, PV->VV[dimT2]);
          L[3] = K[2] * ut2;
        }
      } else {
        if(dirN % 2 == 0) {
          L[0] = K[0] * (p - targetPressure) + (beta - 1) * (T[last] + ceta * rho * a * T[1])
                 + (V[last] + ceta * rho * a * V[1]);
        } else {
          L[last] = K[last] * (p - targetPressure) + (beta - 1) * (T[last] + ceta * rho * a * T[1])
                    + (V[last] + ceta * rho * a * V[1]);
        }

        L[1] = K[1] * (Temp - T_target) - (a * a * T[0] - T[last]) + (a * a * V[0] - V[last]);
        L[2] = K[2] * ut1 - T[2] * 0.9;
        IF_CONSTEXPR(nDim == 3) {
          const MFloat ut2 = m_solver->a_pvariable(cellId, PV->VV[dimT2]);
          K[3] = K[3] * m_cbcLref[cbcId] / LN * 100;
          L[3] = K[3] * ut2 - T[3] * 0.9;
        }
      }
    } else {
      targetPressure = sysEqn().p_Ref();
      MFloat beta = meanM;

      cbcOutgoingAmplitudeVariation<0>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
      cbcDampingOutflow(cellId, bcId, maxM, &K[0]);

      // for fv-mb: LN = 100.0
      MFloat LN = 100;
      K[0] = K[0] * m_cbcLref[cbcId] * m_sigmaNonRefl / LN;
      K[2] = m_cbcRelax[cbcId][2] * a / LN * 10;

      MFloat ceta = F1;
      if(dirN % 2 == 0)
        ceta = -F1;
      else
        ceta = F1;

      MFloat deltaP = (p - targetPressure);
      MFloat tmpP = sysEqn().pressure_ES(T_mean, rho) - targetPressure;
      if((m_solver->a_bndryId(cellId) > -1 || hasBndryNghbr)) {
        if(tmpP > deltaP) deltaP = tmpP;
        if(dirN % 2 == 0) // outflow on pos. coordinate direction -> L1 has to be modeled
          L[0] = K[0] * (deltaP);
        else
          L[last] = K[0] * (deltaP);

      } else {
        if(tmpP > deltaP) deltaP = tmpP;
        if(dirN % 2 == 0) {
          L[0] = K[0] * (deltaP) + (beta - 1) * (T[last] + ceta * rho * a * T[1]) + (V[last] + ceta * rho * a * V[0]);
        } else {
          L[last] =
              K[0] * (deltaP) + (beta - 1) * (T[last] + ceta * rho * a * T[1]) + (V[last] + ceta * rho * a * V[1]);
        }

        IF_CONSTEXPR(nDim == 3) {
          const MFloat ut2 = m_solver->a_pvariable(cellId, PV->VV[dimT2]);
          L[2] += K[2] * ut1;
          L[3] += K[2] * ut2;
        }
      }
    }
    IF_CONSTEXPR(nDim == 3) {
      if((m_solver->a_bndryId(cellId) > -1 || hasBndryNghbr)) {
        T[0] = F0;
        T[1] = F0;
        T[2] = F0;
        T[3] = F0;
        T[last] = F0;
        V[0] = F0;
        V[1] = F0;
        V[2] = F0;
        V[3] = F0;
        V[last] = F0;
      }
    }
    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);
  }
}


/**
 * \fn FvBndryCndXD::cbc1099_1091_local_comb()
 * Subsonic partially reflecting characteristic outflow condition - cut off - turbulent combustion
 * \fvcbc{FvBndryCndXD::cbc1099_1091_local_comb(), fvcbc1099_1091_local_comb, CBC 1099 1091 Local Comb.}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc1099_1091_local_comb(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  MFloat outFlowArea = m_cbcInflowArea[cbcId];

  MInt last = nDim + 1;

  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);


  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");

  MFloat massflux = F0;
  MFloat T_mean = F0;
  MFloat rho_mean = F0;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    MInt bndryId = m_solver->a_bndryId(cellId);

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MFloat area;
    if(bndryId > -1) {
      // identify the "boundary surface" between cutoff boundary cell and neighboring layer cell if cell is a boundary
      // cell
      MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dirN];
      if(srfcId > -1) {
        area = m_solver->a_surfaceArea(srfcId);
      } else {
        mTerm(1, AT_, "something went wrong!");
      }
    } else {
      IF_CONSTEXPR(nDim == 3) area = POW2(m_solver->c_cellLengthAtCell(cellId));
      IF_CONSTEXPR(nDim == 2) area = m_solver->c_cellLengthAtCell(cellId);
    }

    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    const MFloat p = m_solver->a_pvariable(cellId, PV->P);
    const MFloat un = m_solver->a_pvariable(cellId, PV->VV[dimN]);
    const MFloat Temp = sysEqn().temperature_ES(rho, p);

    massflux += un * area * rho;
    T_mean += Temp * area;
    IF_CONSTEXPR(nDim == 2) rho_mean += rho * area;
  }

  MFloat mach[2] = {F0, F0};
  cbcMachCo(bcId, mach);
  MFloat meanM = mach[0];
  MFloat maxM = mach[1];

  MInt noExchangeData = 2;
  MFloatScratchSpace comm_buff(noExchangeData, AT_, "comm_buff");
  MFloatScratchSpace comm_buff_result(noExchangeData, AT_, "comm_buff_result");
  comm_buff[0] = massflux;
  comm_buff[1] = T_mean;


  MPI_Allreduce(&comm_buff[0], &comm_buff_result[0], 2, MPI_DOUBLE, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]],
                AT_, "comm_buff[0]", "comm_buff_result[0]");

  IF_CONSTEXPR(nDim == 2) {
    MPI_Allreduce(MPI_IN_PLACE, &rho_mean, 1, MPI_DOUBLE, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                  "MPI_IN_PLACE", "rho_mean");
    rho_mean /= outFlowArea;

    const MFloat gammaMinusOne = m_solver->m_gamma - 1.0;
    MFloat T_target = 1 - gammaMinusOne * F1B2 * (massflux * massflux / outFlowArea / outFlowArea);
    MFloat p_Target = sysEqn().pressure_ES(T_target, rho_mean);
    MFloat p_test = p_Target;
    for(MInt i = 0; i < 20; i++) {
      p_test = sysEqn().pressure_IRit(p_test, massflux);
    }
    m_solver->m_jetPressure = p_Target;
    m_solver->m_jetDensity = rho_mean; // gamma*p_Target/T_target;
    m_solver->m_jetTemperature = T_target;
  }

  massflux = comm_buff_result[0];
  T_mean = comm_buff_result[1];
  T_mean /= outFlowArea;

  MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");
  MFloatScratchSpace gradTau(m_cbcViscous ? (nDim * nDim * nDim) : 1, AT_, "gradTau");
  MFloatScratchSpace gradQ(m_cbcViscous ? (nDim * nDim) : 1, AT_, "gradQ");

  MIntScratchSpace cutOffStencilCellIds(m_cbcViscous ? m_solver->a_noCells() : 1, AT_, "cutOffStencilCellIds");
  if(m_cbcViscous) cbcTauQ(bcId, &tau[0], &q[0], &cutOffStencilCellIds[0]);

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);
    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    V.fill(F0);
    if(m_cbcViscous) {
      cbcGradientsViscous(cellId, bcId, &tau[0], &q[0], &gradTau[0], &gradQ[0], &cutOffStencilCellIds[0]);
      gradTau[dimN * IPOW2(nDim) + dimT1 * nDim + dimN] = F0;
      IF_CONSTEXPR(nDim == 3) { gradTau[dimN * IPOW2(nDim) + dimT2 * nDim + dimN] = F0; }
      cbcViscousTerms<(unsigned char)01111>(cellId, bcId, &tau[0], &gradTau[0], &gradQ[0], &gradVV[0],
                                            &cutOffStencilCellIds[0], &V[0]);
    }

    cbcTransversalTerms<(unsigned char)11111>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &T[0]);

    // This is where you differentiate between inflow and outflow
    MFloat un_mean = m_solver->a_pvariable(cellId, PV->VV[dimN]);
    MFloat T_target_new = 0.0;

    MBool isInflow = true;
    if(dirN % 2 == 0) {
      if(un_mean > F0) {
        isInflow = false;
      } else {
        T_target_new = T_mean;
      }
    } else {
      if(un_mean < F0) {
        isInflow = false;
      } else {
        T_target_new = T_mean;
      }
    }

    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    const MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat a = sysEqn().speedOfSound(rho, p);
    const MFloat Temp = sysEqn().temperature_ES(rho, p);

    const MFloat ut1 = m_solver->a_pvariable(cellId, PV->VV[dimT1]);

    MFloat targetPressure;

    if(isInflow) {
      targetPressure = 0.0;
      MFloat beta = F0;

      cbcOutgoingAmplitudeVariation<1>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
      cbcDampingInflow(cellId, bcId, maxM, &K[0], "pressure");

      IF_CONSTEXPR(nDim == 3) {
        K[2] = K[2] * 100;
        K[3] = K[3] * 100;
      }
      K[last] = K[0];

      MFloat ceta = F1;
      if(dirN % 2 == 0)
        ceta = -F1;
      else
        ceta = F1;

      if(dirN % 2 == 0) {
        L[0] = K[0] * (p - targetPressure) + (beta - 1) * (T[last] + ceta * rho * a * T[1])
               + (V[last] + ceta * rho * a * V[1]);
      } else {
        L[last] = K[last] * (p - targetPressure) + (beta - 1) * (T[last] + ceta * rho * a * T[1])
                  + (V[last] + ceta * rho * a * V[1]);
      }

      L[1] = K[1] * (Temp - T_target_new) - (a * a * T[0] - T[last]) + (a * a * V[0] - V[last]);
      L[2] = K[2] * ut1;
      IF_CONSTEXPR(nDim == 3) {
        const MFloat ut2 = m_solver->a_pvariable(cellId, PV->VV[dimT2]);
        L[3] = K[3] * ut2;
      }
    } else {
      targetPressure = sysEqn().p_Ref();
      MFloat beta = meanM;

      cbcOutgoingAmplitudeVariation<0>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
      cbcDampingOutflow(cellId, bcId, maxM, &K[0]);

      IF_CONSTEXPR(nDim == 3) {
        K[2] = K[2] * 100;
        K[3] = K[3] * 100;
      }
      K[0] = K[0] * m_sigmaNonRefl;
      K[last] = K[0];

      MFloat ceta = F1;
      if(dirN % 2 == 0)
        ceta = -F1;
      else
        ceta = F1;

      MFloat deltaP = (p - targetPressure);

      if(dirN % 2 == 0) {
        L[0] = K[0] * (deltaP) + (beta - 1) * (T[last] + ceta * rho * a * T[1]) + (V[last] + ceta * rho * a * V[0]);
      } else {
        L[last] = K[0] * (deltaP) + (beta - 1) * (T[last] + ceta * rho * a * T[1]) + (V[last] + ceta * rho * a * V[1]);
      }
      L[2] = K[2] * ut1;
      IF_CONSTEXPR(nDim == 3) {
        const MFloat ut2 = m_solver->a_pvariable(cellId, PV->VV[dimT2]);
        L[3] = K[2] * ut2;
      }
    }
    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);
  }
}


/** \brief Cut off condition for the slopes
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::sbc00co(MInt bcId) {
  TRACE();

  const MInt noVars = PV->noVariables;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    // set the cut off slopes to zero
    for(MInt varId = 0; varId < noVars; varId++) {
      for(MInt i = 0; i < nDim; i++) {
        m_solver->a_slope(cellId, varId, i) = F0;
      }
    }
  }
}


/** \brief Solid wall Navier-Stokes boundary condition for the slopes.
 *        Set of variables: Standard CV
 */
template <MInt nDim, class SysEqn>
inline void FvBndryCndXD<nDim, SysEqn>::sbc1000(const MInt bcId /*, const MUint noSpecies_*/) {
  // TRACE();
  const MUint noVars = CV->noVariables; // 2 + nDim + noSpecies_ + m_solver->m_noRansEquations;
  const MInt* const RESTRICT sortedBndryIds = ALIGNED_I(m_sortedBndryCells->a);
  const MInt* const RESTRICT bndryCndIds = m_bndryCndIds;
  const FvBndryCell<nDim, SysEqn>* const bCells = m_bndryCells->a;
  const MInt firstBndryCell = m_bndryCndCells[bcId];
  const MInt lastBndryCell = m_bndryCndCells[bcId + 1];

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt id = firstBndryCell; id < lastBndryCell; ++id) {
    MInt bndryId = sortedBndryIds[id];
    MInt cellId = bCells[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      const MUint noSrfcs = bCells[bndryId].m_noSrfcs;
      const typename FvBndryCell<nDim, SysEqn>::BodySurface* const cellSurfaces = bCells[bndryId].m_srfcs[0];
      const typename FvBndryCell<nDim, SysEqn>::BodySurfaceVariables* const cellSurfaceVariables =
          m_bndryCells->a[bndryId].m_srfcVariables[0];
      for(MUint srfc = 0; srfc < noSrfcs; ++srfc) {
        if(cellSurfaces[srfc].m_bndryCndId == bndryCndIds[bcId]) {
          const MUint ghostCellId = cellSurfaceVariables[srfc].m_ghostCellId;
          MFloat* const RESTRICT ghostCellSlopes = ALIGNED_MF(&m_solver->a_slope(ghostCellId, 0, 0));
          const MFloat* const RESTRICT cellSlopes = ALIGNED_F(&m_solver->a_slope(cellId, 0, 0));
          // copy the slopes from the boundary cell to the ghost cell
          for(MUint varId = 0; varId < noVars; ++varId) {
            for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
              ghostCellSlopes[varId * nDim + spaceId] = cellSlopes[varId * nDim + spaceId];
            }
          }
        }
      }
    }
  }
}


/** \brief Cut off condition for the slopes
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::sbc1000co(MInt bcId) {
  TRACE();

  const MInt noVars = PV->noVariables;
  const MInt otherDir[6] = {1, 0, 3, 2, 5, 4};

  MBool& first = m_static_sbc1000co_first;
  const MInt fixedMaxNoBndryCndIds = s_sbc1000co_fixedMaxNoBndryCndIds;
  MInt(&directions)[fixedMaxNoBndryCndIds] = m_static_sbc1000co_directions;
  if(first) { // TODO labels:FV move this to some initialization routine
    if(fixedMaxNoBndryCndIds < m_maxNoBndryCndIds) {
      mTerm(1, AT_, "fixedMaxNoBndryCndIds is too small. increase...");
    }

    MInt noCutOffBndryIds = Context::propertyLength("cutOffBndryIds", m_solverId);
    MInt noCutOffDirections = Context::propertyLength("cutOffDirections", m_solverId);
    if(noCutOffDirections != noCutOffBndryIds) {
      mTerm(1, AT_,
            "Wrong number of cut off directions. Must be identical to number of cut off bndryIds! Please check!");
    }
    MInt cutOffBndryIdTmp, cutOffDirectionTmp;
    for(MInt bc = 0; bc < m_noCutOffBndryCndIds; bc++) {
      for(MInt i = 0; i < noCutOffBndryIds; i++) {
        cutOffBndryIdTmp = Context::getSolverProperty<MInt>("cutOffBndryIds", m_solverId, AT_, i);
        cutOffDirectionTmp = Context::getSolverProperty<MInt>("cutOffDirections", m_solverId, AT_, i);
        if(cutOffBndryIdTmp == m_cutOffBndryCndIds[bc]) {
          directions[bc] = otherDir[cutOffDirectionTmp];
          break;
        }
      }
    }

    first = false;
  }
  //---end of initialization

  const MInt direction = directions[bcId];

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    MLong nghbrId = m_solver->c_neighborId(cellId, direction);

    // continue if the neighbor does not exist -> happens on the second layer of halo cells
    if(nghbrId < 0) {
      TERMM_IF_NOT_COND(m_solver->a_isHalo(cellId), "Error: cell has no neighbor and is not a halo cell.");
      continue;
    }

    if(m_solver->a_hasProperty(nghbrId, SolverCell::IsInactive)) continue;

    if(m_solver->a_hasProperty(nghbrId, SolverCell::IsOnCurrentMGLevel)) {
      // copy the slopes from the boundary cell to the ghost cell
      for(MInt varId = 0; varId < noVars; varId++) {
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_slope(cellId, varId, i) = m_solver->a_slope(nghbrId, varId, i);
        }
      }
    }
  }
}

/** \brief Symmetry boundary condition about x-axis (slopes)
 * \author Claudia Guenther
 * \date 01/2014
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::sbc1002(MInt bcId) {
  TRACE();

  MInt cellId;
  MInt ghostCellId = 0;
  const MInt noVars = PV->noVariables;
  //---end of initialization

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    cellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      ghostCellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_srfcVariables[0]->m_ghostCellId;

      // copy the slopes from the boundary cell to the ghost cell
      for(MInt varId = 0; varId < noVars; varId++) {
        m_solver->a_slope(ghostCellId, varId, 0) = m_solver->a_slope(cellId, varId, 0);
        m_solver->a_slope(ghostCellId, varId, 1) = -m_solver->a_slope(cellId, varId, 1);
      }
    }
  }
}


/**
 * \fn FvBndryCndXD::cbc1091e()
 * Subsonic fully reflecting characteristic inflow condition - cut off \n
 * T0,u,v is prescribed, incl. transverse terms
 * \fvcbc{FvBndryCndXD::cbc1091e(), fvcbc1091e, CBC 1091E}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc1091e(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];

  MInt last = nDim + 1;

  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");

  MFloat mach[2] = {F0, F0};
  cbcMachCo(bcId, mach);
  MFloat maxM = mach[1];

  const MFloat gammaMinusOne = m_solver->m_gamma - 1.0;

  MFloat T_target = sysEqn().temperature_IR(m_solver->m_Ma);

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);

    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    // labels:FV HACK
    gradVV[dimN * nDim + dimT1] = F0;
    gradVV[dimT1 * nDim + dimT1] = F0;

    cbcOutgoingAmplitudeVariation<1>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
    cbcTransversalTerms<(unsigned char)11111>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &T[0]);

    cbcDampingInflow(cellId, bcId, maxM, &K[0], "velocity");

    MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat a = sysEqn().speedOfSound(rho, p);

    MFloat un_target = m_solver->m_UInfinity;
    MFloat ut1_target = F0;

    if(dirN % 2 == 0) {
      L[0] = L[last] + (T[last] - rho * a * T[1]);
    } else {
      L[last] = L[0] + (T[last] + rho * a * T[1]);
    }

    L[1] = F1B2 * gammaMinusOne * (L[0] + L[last]) + (a * a * T[0] - T[last]);


    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);

    m_solver->a_rightHandSide(cellId, CV->RHO_VV[dimN]) = F0;
    m_solver->a_rightHandSide(cellId, CV->RHO_VV[dimT1]) = F0;
    m_solver->a_rightHandSide(cellId, CV->RHO_E) = F0;

    m_solver->a_pvariable(cellId, PV->VV[dimN]) = un_target;
    m_solver->a_pvariable(cellId, PV->VV[dimT1]) = ut1_target;
    m_solver->a_pvariable(cellId, PV->P) = T_target;
  }
}
/** \brief Subsonic fully reflecting characteristic inflow condition - cut off - sets T0,u,v to prescribed value after
 * rkstep
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc1091e_after(MInt bcId) {
  IF_CONSTEXPR(nDim == 3) { TERMM(-1, "INFO: function cbc1091e_after is untested for 3D!"); }
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) return;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);

    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    // recompute the correct energy:
    MFloat rho = m_solver->a_variable(cellId, CV->RHO);
    MFloat u = m_solver->a_pvariable(cellId, PV->VV[0]);
    MFloat v = m_solver->a_pvariable(cellId, PV->VV[1]);
    MFloat T = m_solver->a_pvariable(cellId, PV->P);
    MFloat p = sysEqn().pressure_ES(T, rho);
    MFloat E = sysEqn().internalEnergy(p, rho, (u * u + v * v));

    m_solver->a_variable(cellId, CV->RHO_VV[0]) = rho * u;
    m_solver->a_variable(cellId, CV->RHO_VV[1]) = rho * v;
    m_solver->a_variable(cellId, CV->RHO_E) = E;
  }
}


/** \brief Returns the mean and maximum Mach number of the cut off cells.
 *  \date October 2019
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbcMachCo(MInt bcId, MFloat* mach) {
  TRACE();

  MInt cbcId = m_cbcBndryCndIds[bcId];
  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];

  MFloat localMach[2] = {F0, F0};

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    MInt bndryId = m_solver->a_bndryId(cellId);

    if(m_solver->a_isHalo(cellId)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    MFloat area = -1;
    if(bndryId > -1) {
      MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dirN];
      if(srfcId > -1) {
        area = m_solver->a_surfaceArea(srfcId);
        IF_CONSTEXPR(nDim == 3) ASSERT(area <= POW2(m_solver->c_cellLengthAtCell(cellId)), "");
      } else {
        for(MInt dir = 0; dir < m_noDirs; dir++) {
          srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dir];
          if(srfcId > -1) break;
        }
        if(srfcId == -1) {
          mTerm(1, AT_, "something went wrong!");
        }
        area = m_solver->a_surfaceArea(srfcId);
      }
    } else {
      IF_CONSTEXPR(nDim == 2) area = m_solver->c_cellLengthAtCell(cellId);
      IF_CONSTEXPR(nDim == 3) area = POW2(m_solver->c_cellLengthAtCell(cellId));
    }

    area *= m_dirTangent[cbcId][dimT1];

    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    const MFloat p = m_solver->a_pvariable(cellId, PV->P);
    const MFloat T = sysEqn().temperature_ES(rho, p);
    const MFloat a = sysEqn().speedOfSound(T);

    MFloat un = m_solver->a_pvariable(cellId, PV->VV[dimN]) * m_dirNormal[cbcId][dimN]
                + m_solver->a_pvariable(cellId, PV->VV[dimT1]) * m_dirNormal[cbcId][dimT1];
    IF_CONSTEXPR(nDim == 3) {
      MInt dimT2 = m_cbcDir[cbcId][nDim];
      un += m_solver->a_pvariable(cellId, PV->VV[dimT2]) * m_dirNormal[cbcId][dimT2];
    }

    const MFloat M = fabs(un / a);

    localMach[0] += fabs(M) * area;
    localMach[1] = mMax(localMach[1], M);
  }

  MFloat globalMach[2] = {F0, F0};

  if(m_solver->noDomains() > 1) {
    MPI_Allreduce(&localMach[0], &globalMach[0], 1, MPI_DOUBLE, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                  "localMeanMach", "globalMeanMach");
    MPI_Allreduce(&localMach[1], &globalMach[1], 1, MPI_DOUBLE, MPI_MAX, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                  "localMaxMach", "globalMaxMach");
  }

  MFloat inflowArea = m_cbcInflowArea[cbcId];
  globalMach[0] /= inflowArea;

  mach[0] = globalMach[0];
  mach[1] = globalMach[1];

  return;
}


/** \brief Calculates the stress tensor tau and the heat flux q and the mean velocity on the construction stencils of
 * all cbc cells. \date October 2019
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbcTauQ(MInt bcId, MFloat* tau, MFloat* q, MInt* cutOffStencilCellIds) {
  TRACE();

  auto index = [&](MInt dim0, MInt dim1, MInt dim2) { return dim0 * (nDim * nDim) + dim1 * nDim + dim2; };

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];

  for(MInt i = 0; i < m_solver->maxNoGridCells(); i++) {
    cutOffStencilCellIds[i] = -1;
  }

  MInt cellCounter = 0;
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);
    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat T = sysEqn().temperature_ES(rho, p);

    if(cutOffStencilCellIds[cellId] < 0) { // tau and q have not been computed yet
      MInt coId = cellCounter++;
      cutOffStencilCellIds[cellId] = coId;

      MFloat dpdn = m_solver->a_slope(cellId, PV->P, dimN);
      MFloat dpdt1 = m_solver->a_slope(cellId, PV->P, dimT1);
      MFloat drhodn = m_solver->a_slope(cellId, PV->RHO, dimN);
      MFloat drhodt1 = m_solver->a_slope(cellId, PV->RHO, dimT1);
      MFloat dundn = m_solver->a_slope(cellId, PV->VV[dimN], dimN);
      MFloat dundt1 = m_solver->a_slope(cellId, PV->VV[dimN], dimT1);
      MFloat dut1dn = m_solver->a_slope(cellId, PV->VV[dimT1], dimN);
      MFloat dut1dt1 = m_solver->a_slope(cellId, PV->VV[dimT1], dimT1);

      const MFloat mu = sysEqn().sutherlandLaw(T);
      MFloat divT = dundn + dut1dt1;
      IF_CONSTEXPR(nDim == 3) {
        MInt dimT2 = m_cbcDir[cbcId][nDim];
        MFloat dpdt2 = m_solver->a_slope(cellId, PV->P, dimT2);
        MFloat drhodt2 = m_solver->a_slope(cellId, PV->RHO, dimT2);
        MFloat dundt2 = m_solver->a_slope(cellId, PV->VV[dimN], dimT2);
        MFloat dut1dt2 = m_solver->a_slope(cellId, PV->VV[dimT1], dimT2);
        MFloat dut2dn = m_solver->a_slope(cellId, PV->VV[dimT2], dimN);
        MFloat dut2dt1 = m_solver->a_slope(cellId, PV->VV[dimT2], dimT1);
        MFloat dut2dt2 = m_solver->a_slope(cellId, PV->VV[dimT2], dimT2);
        divT = divT + dut2dt2;

        tau[index(coId, dimN, dimT2)] = mu * (dundt2 + dut2dn);
        tau[index(coId, dimT2, dimN)] = tau[index(coId, dimN, dimT2)];
        tau[index(coId, dimT1, dimT2)] = mu * (dut1dt2 + dut2dt1);
        tau[index(coId, dimT2, dimT2)] = mu * (F2 * dut2dt2 - F2B3 * divT);
        tau[index(coId, dimT2, dimT1)] = tau[index(coId, dimT1, dimT2)];

        q[index(0, coId, dimT2)] =
            mu * m_solver->m_gamma * sysEqn().cp_Ref() / (m_solver->m_Pr * rho) * (dpdt2 - p / rho * drhodt2);
      }

      tau[index(coId, dimN, dimN)] = mu * (F2 * dundn - F2B3 * divT);
      tau[index(coId, dimN, dimT1)] = mu * (dundt1 + dut1dn);
      tau[index(coId, dimT1, dimN)] = tau[index(coId, dimN, dimT1)];
      tau[index(coId, dimT1, dimT1)] = mu * (F2 * dut1dt1 - F2B3 * divT);

      q[index(0, coId, dimN)] =
          mu * m_solver->m_gamma * sysEqn().cp_Ref() / (m_solver->m_Pr * rho) * (dpdn - p / rho * drhodn);
      q[index(0, coId, dimT1)] =
          mu * m_solver->m_gamma * sysEqn().cp_Ref() / (m_solver->m_Pr * rho) * (dpdt1 - p / rho * drhodt1);
    }

    for(MInt recN = 0; recN < m_solver->a_noReconstructionNeighbors(cellId); recN++) {
      MInt recNgbhr = m_solver->a_reconstructionNeighborId(cellId, recN);
      if(cutOffStencilCellIds[recNgbhr] < 0) {
        MInt coIdN = cellCounter++;
        cutOffStencilCellIds[recNgbhr] = coIdN;
        // compute shear tensor and heat flux on recNgbhr:
        MFloat pG = m_solver->a_pvariable(recNgbhr, PV->P);
        MFloat rhoG = m_solver->a_pvariable(recNgbhr, PV->RHO);
        MFloat TG = sysEqn().temperature_ES(rhoG, pG);
        MFloat muG = sysEqn().sutherlandLaw(TG);
        MFloat dpdnG = m_solver->a_slope(recNgbhr, PV->P, dimN);
        MFloat dpdt1G = m_solver->a_slope(recNgbhr, PV->P, dimT1);
        MFloat drhodnG = m_solver->a_slope(recNgbhr, PV->RHO, dimN);
        MFloat drhodt1G = m_solver->a_slope(recNgbhr, PV->RHO, dimT1);
        MFloat dundnG = m_solver->a_slope(recNgbhr, PV->VV[dimN], dimN);
        MFloat dundt1G = m_solver->a_slope(recNgbhr, PV->VV[dimN], dimT1);
        MFloat dut1dnG = m_solver->a_slope(recNgbhr, PV->VV[dimT1], dimN);
        MFloat dut1dt1G = m_solver->a_slope(recNgbhr, PV->VV[dimT1], dimT1);

        MFloat divTG = dundnG + dut1dt1G;

        IF_CONSTEXPR(nDim == 3) {
          MInt dimT2 = m_cbcDir[cbcId][nDim];
          MFloat dpdt2G = m_solver->a_slope(recNgbhr, PV->P, dimT2);
          MFloat drhodt2G = m_solver->a_slope(recNgbhr, PV->RHO, dimT2);
          MFloat dundt2G = m_solver->a_slope(recNgbhr, PV->VV[dimN], dimT2);
          MFloat dut1dt2G = m_solver->a_slope(recNgbhr, PV->VV[dimT1], dimT2);
          MFloat dut2dnG = m_solver->a_slope(recNgbhr, PV->VV[dimT2], dimN);
          MFloat dut2dt1G = m_solver->a_slope(recNgbhr, PV->VV[dimT2], dimT1);
          MFloat dut2dt2G = m_solver->a_slope(recNgbhr, PV->VV[dimT2], dimT2);
          divTG = divTG + dut2dt2G;

          tau[index(coIdN, dimN, dimT2)] = muG * (dundt2G + dut2dnG);
          tau[index(coIdN, dimT2, dimN)] = tau[index(coIdN, dimN, dimT2)];
          tau[index(coIdN, dimT2, dimT2)] = muG * (2 * dut2dt2G - F2B3 * divTG);
          tau[index(coIdN, dimT1, dimT2)] = muG * (dut1dt2G + dut2dt1G);
          tau[index(coIdN, dimT2, dimT1)] = tau[index(coIdN, dimT1, dimT2)];

          q[index(0, coIdN, dimT2)] =
              muG * m_solver->m_gamma * sysEqn().cp_Ref() / (m_solver->m_Pr * rhoG) * (dpdt2G - pG / rhoG * drhodt2G);
        }

        tau[index(coIdN, dimN, dimN)] = muG * (F2 * dundnG - F2B3 * divTG);
        tau[index(coIdN, dimN, dimT1)] = muG * (dundt1G + dut1dnG);
        tau[index(coIdN, dimT1, dimN)] = tau[index(coIdN, dimN, dimT1)];
        tau[index(coIdN, dimT1, dimT1)] = muG * (2 * dut1dt1G - F2B3 * divTG);

        q[index(0, coIdN, dimN)] =
            muG * m_solver->m_gamma * sysEqn().cp_Ref() / (m_solver->m_Pr * rhoG) * (dpdnG - pG / rhoG * drhodnG);
        q[index(0, coIdN, dimT1)] =
            muG * m_solver->m_gamma * sysEqn().cp_Ref() / (m_solver->m_Pr * rhoG) * (dpdt1G - pG / rhoG * drhodt1G);
      }
    }
  }
}

/** \brief Calculates the viscous gradients of the cbcCell.
 *  \date October 2019
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbcGradientsViscous(MInt cellId, MInt bcId, MFloat* tau, MFloat* q, MFloat* gradTau,
                                                     MFloat* gradQ, MInt* cutOffStencilCellIds) {
  TRACE();

  auto index = [&](MInt dim0, MInt dim1, MInt dim2) { return dim0 * (nDim * nDim) + dim1 * nDim + dim2; };

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];

  MInt coId = cutOffStencilCellIds[cellId];
  MInt recData = m_solver->a_reconstructionData(cellId);
  for(MInt nghbr = 0; nghbr < m_solver->a_noReconstructionNeighbors(cellId); nghbr++) {
    MInt recNghbr = m_solver->a_reconstructionNeighborId(cellId, nghbr);
    MInt coIdN = cutOffStencilCellIds[recNghbr];
    for(MInt i = 0; i < nDim; i++) {
      MFloat recConst = m_solver->m_reconstructionConstants[nDim * (recData + nghbr) + i];
      gradTau[index(dimN, dimN, i)] += recConst * (tau[index(coIdN, dimN, dimN)] - tau[index(coId, dimN, dimN)]);
      gradTau[index(dimN, dimT1, i)] += recConst * (tau[index(coIdN, dimN, dimT1)] - tau[index(coId, dimN, dimT1)]);
      gradTau[index(dimT1, dimT1, i)] += recConst * (tau[index(coIdN, dimT1, dimT1)] - tau[index(coId, dimT1, dimT1)]);
      gradQ[index(0, dimN, i)] += recConst * (q[index(0, coIdN, dimN)] - q[index(0, coId, dimN)]);
      gradQ[index(0, dimT1, i)] += recConst * (q[index(0, coIdN, dimT1)] - q[index(0, coId, dimT1)]);
      IF_CONSTEXPR(nDim == 3) {
        MInt dimT2 = m_cbcDir[cbcId][nDim];
        gradTau[index(dimN, dimT2, i)] += recConst * (tau[index(coIdN, dimN, dimT2)] - tau[index(coId, dimN, dimT2)]);
        gradTau[index(dimT1, dimT2, i)] +=
            recConst * (tau[index(coIdN, dimT1, dimT2)] - tau[index(coId, dimT1, dimT2)]);
        gradTau[index(dimT2, dimT2, i)] +=
            recConst * (tau[index(coIdN, dimT2, dimT2)] - tau[index(coId, dimT2, dimT2)]);
        gradQ[index(0, dimT2, i)] += recConst * (q[index(0, coIdN, dimT2)] - q[index(0, coId, dimT2)]);
      }
    }
  }
}


/** \brief Calculates the gradients of the cbcCell.
 *  \date October 2019
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbcGradients(MInt cellId, MInt bcId, MFloat* gradRho, MFloat* gradVV, MFloat* gradP,
                                              MFloat* gradY) {
  TRACE();

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  gradRho[dimN] = m_solver->a_slope(cellId, PV->RHO, dimN) * m_dirNormal[cbcId][dimN]
                  + m_solver->a_slope(cellId, PV->RHO, dimT1) * m_dirNormal[cbcId][dimT1];
  gradRho[dimT1] = m_solver->a_slope(cellId, PV->RHO, dimN) * m_dirTangent[cbcId][dimN]
                   + m_solver->a_slope(cellId, PV->RHO, dimT1) * m_dirTangent[cbcId][dimT1];

  gradVV[dimN * nDim + dimN] = m_solver->a_slope(cellId, PV->VV[dimN], dimN) * m_dirNormal[cbcId][dimN]
                               + m_solver->a_slope(cellId, PV->VV[dimN], dimT1) * m_dirNormal[cbcId][dimT1];
  gradVV[dimN * nDim + dimT1] = m_solver->a_slope(cellId, PV->VV[dimN], dimN) * m_dirTangent[cbcId][dimN]
                                + m_solver->a_slope(cellId, PV->VV[dimN], dimT1) * m_dirTangent[cbcId][dimT1];
  gradVV[dimT1 * nDim + dimN] = m_solver->a_slope(cellId, PV->VV[dimT1], dimN) * m_dirNormal[cbcId][dimN]
                                + m_solver->a_slope(cellId, PV->VV[dimT1], dimT1) * m_dirNormal[cbcId][dimT1];
  gradVV[dimT1 * nDim + dimT1] = m_solver->a_slope(cellId, PV->VV[dimT1], dimN) * m_dirTangent[cbcId][dimN]
                                 + m_solver->a_slope(cellId, PV->VV[dimT1], dimT1) * m_dirTangent[cbcId][dimT1];

  gradP[dimN] = m_solver->a_slope(cellId, PV->P, dimN) * m_dirNormal[cbcId][dimN]
                + m_solver->a_slope(cellId, PV->P, dimT1) * m_dirNormal[cbcId][dimT1];
  gradP[dimT1] = m_solver->a_slope(cellId, PV->P, dimN) * m_dirTangent[cbcId][dimN]
                 + m_solver->a_slope(cellId, PV->P, dimT1) * m_dirTangent[cbcId][dimT1];

  if(m_solver->m_noSpecies > 0) {
    for(MInt s = 0; s < m_solver->m_noSpecies; s++) {
      gradY[s * nDim + dimN] = m_solver->a_slope(cellId, PV->Y[s], dimN) * m_dirNormal[cbcId][dimN]
                               + m_solver->a_slope(cellId, PV->Y[s], dimT1) * m_dirNormal[cbcId][dimT1];
      gradY[s * nDim + dimT1] = m_solver->a_slope(cellId, PV->Y[s], dimN) * m_dirTangent[cbcId][dimN]
                                + m_solver->a_slope(cellId, PV->Y[s], dimT1) * m_dirNormal[cbcId][dimT1];
    }
  }

  IF_CONSTEXPR(nDim == 3) {
    gradRho[dimN] += m_solver->a_slope(cellId, PV->RHO, dimT2) * m_dirNormal[cbcId][dimT2];
    gradRho[dimT1] += m_solver->a_slope(cellId, PV->RHO, dimT2) * m_dirTangent[cbcId][dimT2];
    gradRho[dimT2] = m_solver->a_slope(cellId, PV->RHO, dimT2);

    gradVV[dimN * nDim + dimN] += m_solver->a_slope(cellId, PV->VV[dimN], dimT2) * m_dirNormal[cbcId][dimT2];
    gradVV[dimN * nDim + dimT1] += m_solver->a_slope(cellId, PV->VV[dimN], dimT2) * m_dirTangent[cbcId][dimT2];
    gradVV[dimN * nDim + dimT2] = m_solver->a_slope(cellId, PV->VV[dimN], dimT2);
    gradVV[dimT1 * nDim + dimN] += m_solver->a_slope(cellId, PV->VV[dimT1], dimT2) * m_dirNormal[cbcId][dimT2];
    gradVV[dimT1 * nDim + dimT1] += m_solver->a_slope(cellId, PV->VV[dimT1], dimT2) * m_dirTangent[cbcId][dimT2];
    gradVV[dimT1 * nDim + dimT2] = m_solver->a_slope(cellId, PV->VV[dimT1], dimT2);
    gradVV[dimT2 * nDim + dimN] = m_solver->a_slope(cellId, PV->VV[dimT2], dimN) * m_dirNormal[cbcId][dimN]
                                  + m_solver->a_slope(cellId, PV->VV[dimT2], dimT1) * m_dirNormal[cbcId][dimT1]
                                  + m_solver->a_slope(cellId, PV->VV[dimT2], dimT2) * m_dirNormal[cbcId][dimT2];
    gradVV[dimT2 * nDim + dimT1] = m_solver->a_slope(cellId, PV->VV[dimT2], dimN) * m_dirTangent[cbcId][dimN]
                                   + m_solver->a_slope(cellId, PV->VV[dimT2], dimT1) * m_dirTangent[cbcId][dimT1]
                                   + m_solver->a_slope(cellId, PV->VV[dimT2], dimT2) * m_dirTangent[cbcId][dimT2];
    gradVV[dimT2 * nDim + dimT2] = m_solver->a_slope(cellId, PV->VV[dimT2], dimT2);

    gradP[dimN] += m_solver->a_slope(cellId, PV->P, dimT2) * m_dirNormal[cbcId][dimT2];
    gradP[dimT1] += m_solver->a_slope(cellId, PV->P, dimT2) * m_dirTangent[cbcId][dimT2];
    gradP[dimT2] = m_solver->a_slope(cellId, PV->P, dimT2);
    if(m_solver->m_noSpecies > 0) {
      for(MInt s = 0; s < m_solver->m_noSpecies; s++) {
        gradY[s * nDim + dimN] += m_solver->a_slope(cellId, PV->Y[s], dimT2) * m_dirNormal[cbcId][dimT2];
        gradY[s * nDim + dimT1] += m_solver->a_slope(cellId, PV->Y[s], dimT2) * m_dirTangent[cbcId][dimT2];
        gradY[s * nDim + dimT2] = m_solver->a_slope(cellId, PV->Y[s], dimT2);
      }
    }
  }
}


/** \brief Calculates the outgoing terms wave amplitude variation L
 *  \date 02.10.2019
 *  side 0 = outflow
 *       1 = inflow
 */
template <MInt nDim, class SysEqn>
template <MInt side>
void FvBndryCndXD<nDim, SysEqn>::cbcOutgoingAmplitudeVariation(MInt cellId, MInt bcId, MFloat* gradRho, MFloat* gradVV,
                                                               MFloat* gradP, MFloat* gradY, MFloat* L) {
  TRACE();

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
  MFloat un = F0;
  un = m_solver->a_pvariable(cellId, PV->VV[dimN]) * m_dirNormal[cbcId][dimN]
       + m_solver->a_pvariable(cellId, PV->VV[dimT1]) * m_dirNormal[cbcId][dimT1];

  IF_CONSTEXPR(nDim == 3) { un += m_solver->a_pvariable(cellId, PV->VV[dimT2]) * m_dirNormal[cbcId][dimT2]; }

  MFloat p = m_solver->a_pvariable(cellId, PV->P);
  MFloat a = sysEqn().speedOfSound(rho, p);

  MInt last = CV->noVariables - 1 - m_solver->m_noSpecies;

  if(side == 1) {
    MFloat lambda1 = (un - a);
    MFloat lambda5 = (un + a);
    L[0] = lambda1 * (gradP[dimN] - rho * a * gradVV[dimN * nDim + dimN]);
    L[last] = lambda5 * (gradP[dimN] + rho * a * gradVV[dimN * nDim + dimN]);
    IF_CONSTEXPR(nDim == 3) { L[3] = un * (gradVV[dimT2 * nDim + dimN]); }
  } else if(side == 0) {
    MFloat lambda1 = (un - a);
    MFloat lambda2 = un;
    MFloat lambda5 = (un + a);
    L[0] = lambda1 * (gradP[dimN] - rho * a * gradVV[dimN * nDim + dimN]);
    L[1] = lambda2 * (a * a * gradRho[dimN] - gradP[dimN]);
    L[2] = lambda2 * (gradVV[dimT1 * nDim + dimN]);
    IF_CONSTEXPR(nDim == 3) { L[3] = lambda2 * (gradVV[dimT2 * nDim + dimN]); }
    L[last] = lambda5 * (gradP[dimN] + rho * a * gradVV[dimN * nDim + dimN]);
    for(MInt s = 0; s < m_solver->m_noSpecies; s++) {
      L[last + 1 + s] = lambda2 * gradY[s * nDim + dimN];
    }
  } else {
    mTerm(1, AT_, "Wrong template argument");
  }
}


/** \brief Calculates the transversal correction terms T
 * \date October 2019
 */
template <MInt nDim, class SysEqn>
template <unsigned char tTerms>
void FvBndryCndXD<nDim, SysEqn>::cbcTransversalTerms(MInt cellId, MInt bcId, MFloat* gradRho, MFloat* gradVV,
                                                     MFloat* gradP, MFloat* gradY, MFloat* T) {
  TRACE();

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
  MFloat ut1 = F0;

  ut1 = m_solver->a_pvariable(cellId, PV->VV[dimN]) * m_dirTangent[cbcId][dimN]
        + m_solver->a_pvariable(cellId, PV->VV[dimT1]) * m_dirTangent[cbcId][dimT1];

  MFloat ut2 = F0;
  IF_CONSTEXPR(nDim == 3) {
    ut1 += m_solver->a_pvariable(cellId, PV->VV[dimT2]) * m_dirTangent[cbcId][dimT2];
    ut2 = m_solver->a_pvariable(cellId, PV->VV[dimT2]);
  }

  MFloat p = m_solver->a_pvariable(cellId, PV->P);

  MInt last = CV->noVariables - 1 - m_solver->m_noSpecies;

  if(tTerms & 1) {
    T[0] = -rho * gradVV[dimT1 * nDim + dimT1] - ut1 * gradRho[dimT1];
    IF_CONSTEXPR(nDim == 3) T[0] += (-rho * gradVV[dimT2 * nDim + dimT2] - ut2 * gradRho[dimT2]);
  }

  if(tTerms & 2) {
    T[1] = -ut1 * gradVV[dimN * nDim + dimT1];
    IF_CONSTEXPR(nDim == 3) T[1] += (-ut2 * gradVV[dimN * nDim + dimT2]);
  }

  if(tTerms & 3) {
    T[2] = -ut1 * gradVV[dimT1 * nDim + dimT1] - F1 / rho * gradP[dimT1];
    IF_CONSTEXPR(nDim == 3) T[2] += (-ut2 * gradVV[dimT1 * nDim + dimT2]);
  }

  IF_CONSTEXPR(nDim == 3) {
    if(tTerms & 4) {
      T[3] = -ut1 * gradVV[dimT2 * nDim + dimT1] - ut2 * gradVV[dimT2 * nDim + dimT2] - F1 / rho * gradP[dimT2];
    }
  }

  if(tTerms & 5) {
    T[last] = -ut1 * gradP[dimT1] - p * sysEqn().gamma_Ref() * gradVV[dimT1 * nDim + dimT1];
    IF_CONSTEXPR(nDim == 3) T[last] += (-ut2 * gradP[dimT2] - p * sysEqn().gamma_Ref() * gradVV[dimT2 * nDim + dimT2]);
  }

  for(MInt s = 0; s < m_solver->m_noSpecies; s++) {
    T[last + 1 + s] = -ut1 * gradY[s * nDim + dimT1];
    IF_CONSTEXPR(nDim == 3) T[last + 1 + s] += -ut2 * gradY[s * nDim + dimT2];
  }
}


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbcMeanPressureCo(MInt bcId, MFloat* pressure) {
  TRACE();

  MInt cbcId = m_cbcBndryCndIds[bcId];
  MInt dirN = m_cbcDir[cbcId][0];

  MFloat localMeanPressure = F0;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    MInt bndryId = m_solver->a_bndryId(cellId);

    if(m_solver->a_isHalo(cellId)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;

    MFloat area;
    if(bndryId > -1) {
      // identify the "boundary surface" between cutoff boundary cell
      // and neighboring layer cell if cell is a boundary cell
      MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dirN];
      if(srfcId > -1) {
        area = m_solver->a_surfaceArea(srfcId);
      } else {
        mTerm(1, AT_, "something went wrong!");
      }
    } else {
      area = m_solver->c_cellLengthAtCell(cellId);
#ifdef DIM3
      area = POW2(m_solver->c_cellLengthAtCell(cellId));
#endif
    }

    MFloat p = m_solver->a_pvariable(cellId, PV->P);

    localMeanPressure += p * area;
  }

  MFloat globalMeanPressure = F0;

  MPI_Allreduce(&localMeanPressure, &globalMeanPressure, 1, MPI_DOUBLE, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]],
                AT_, "localMeanPressure", "globalMeanPressure");

  const MFloat inflowArea = m_cbcInflowArea[cbcId];

  globalMeanPressure /= inflowArea;
  pressure[0] = globalMeanPressure;
  return;
}

/** \brief Calculates the outgoing viscous terms V
 *  \date October 2019
 */
template <MInt nDim, class SysEqn>
template <unsigned char vTerms>
void FvBndryCndXD<nDim, SysEqn>::cbcViscousTerms(MInt cellId, MInt bcId, MFloat* tau, MFloat* gradTau, MFloat* gradQ,
                                                 MFloat* gradVV, MInt* cutOffStencilCellIds, MFloat* V) {
  TRACE();

  auto index = [&](MInt dim0, MInt dim1, MInt dim2) { return dim0 * (nDim * nDim) + dim1 * nDim + dim2; };

  // if ( m_solver->m_noSpecies > 0 ) mTerm(1, AT_, "Species not yet supported!");

  MInt coId = cutOffStencilCellIds[cellId];

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
  MInt last = CV->noVariables - 1 - m_solver->m_noSpecies;
  // MInt last = 4;
  if(last != 4) mTerm(1, AT_, "last is not four!");

  if(vTerms & 2) {
    MFloat Sum_dtaun = gradTau[index(dimN, dimN, dimN)] + gradTau[index(dimN, dimT1, dimT1)];
    IF_CONSTEXPR(nDim == 3) { Sum_dtaun += gradTau[index(dimN, dimT2, dimT2)]; }
    V[1] = F1 / (sysEqn().m_Re0 * rho) * (Sum_dtaun);
  }

  if(vTerms & 3) {
    MFloat Sum_dtaut = gradTau[index(dimT1, dimT1, dimT1)];
    IF_CONSTEXPR(nDim == 3) { Sum_dtaut += gradTau[index(dimT1, dimT2, +dimT2)]; }
    V[2] = F1 / (sysEqn().m_Re0 * rho) * (Sum_dtaut);
  }

  IF_CONSTEXPR(nDim == 3) {
    if(vTerms & 4) {
      V[3] = F1 / (sysEqn().m_Re0 * rho) * (gradTau[index(dimT1, dimT2, dimT1)] + gradTau[index(dimT2, dimT2, dimT2)]);
    }
  }

  if(vTerms & 5) {
    MFloat Sum_d_for_V5 =
        tau[index(coId, dimN, dimN)] * gradVV[index(0, dimN, dimN)]
        + tau[index(coId, dimN, dimT1)] * (gradVV[index(0, dimT1, dimN)] + gradVV[index(0, dimN, dimT1)])
        + tau[index(coId, dimT1, dimT1)] * gradVV[index(0, dimT1, dimT1)] + gradQ[index(0, dimT1, dimT1)];

    IF_CONSTEXPR(nDim == 3) {
      Sum_d_for_V5 +=
          tau[index(coId, dimN, dimT2)] * (gradVV[index(0, dimT2, dimN)] + gradVV[index(0, dimN, dimT2)])
          + tau[index(coId, dimT2, dimT2)] * gradVV[index(0, dimT2, dimT2)]
          + tau[index(coId, dimT1, dimT2)] * (gradVV[index(0, dimT1, dimT2)] + gradVV[index(0, dimT2, dimT1)])
          + gradQ[index(0, dimT2, dimT2)];
    }
    V[last] = Sum_d_for_V5 / sysEqn().cp_Ref() / sysEqn().m_Re0;
  }
}


/** \brief Calculates the inflow damping terms
 *  \date October 2019
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbcDampingInflow(MInt cellId, MInt bcId, MFloat maxM, MFloat* K,
                                                  MString prescribedVariable) {
  TRACE();

  MInt cbcId = m_cbcBndryCndIds[bcId];
  MInt dirN = m_cbcDir[cbcId][0];
  MInt last = CV->noVariables - 1 - m_solver->m_noSpecies;

  MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
  MFloat p = m_solver->a_pvariable(cellId, PV->P);
  MFloat a = sysEqn().speedOfSound(rho, p);

  if(dirN % 2 == 0) {
    if(prescribedVariable == "velocity") {
      K[0] = m_cbcRelax[cbcId][0] * rho * a * a * (1 - maxM * maxM) / m_cbcLref[cbcId];
    } else if(prescribedVariable == "pressure") {
      K[0] = m_cbcRelax[cbcId][0] * rho * a * (1 - maxM * maxM) / m_cbcLref[cbcId];
    } else {
      TERMM(-1, "INFO: no prescribed variable set in cbcDampingInflow");
    }
    K[last] = m_cbcRelax[cbcId][last] * rho * a * a * (1 - maxM * maxM) / m_cbcLref[cbcId];
  } else {
    if(prescribedVariable == "velocity") {
      K[last] = m_cbcRelax[cbcId][last] * rho * a * a * (1 - maxM * maxM) / m_cbcLref[cbcId];
    } else if(prescribedVariable == "pressure") {
      K[last] = m_cbcRelax[cbcId][last] * rho * a * (1 - maxM * maxM) / m_cbcLref[cbcId];
    } else {
      TERMM(-1, "INFO: no prescribed variable set in cbcDampingInflow");
    }
    K[0] = m_cbcRelax[cbcId][0] * rho * a * a * (1 - maxM * maxM) / m_cbcLref[cbcId];
  }

  K[1] = m_cbcRelax[cbcId][1] * rho * a / (m_cbcLref[cbcId]);

  // needed because of non-dimensionalization (correction for detailed chemistry)
  IF_CONSTEXPR(isDetChem<SysEqn>)
  K[1] = m_cbcRelax[cbcId][1] * rho * a * m_solver->m_gasConstant
         / (m_cbcLref[cbcId] * m_solver->a_avariable(cellId, AV->W_MEAN));

  K[2] = m_cbcRelax[cbcId][2] * a / m_cbcLref[cbcId];
  IF_CONSTEXPR(nDim == 3) { K[3] = m_cbcRelax[cbcId][3] * a / m_cbcLref[cbcId]; }

  for(MInt s = 0; s < m_solver->m_noSpecies; s++) {
    K[last + 1 + s] = m_cbcRelax[cbcId][last + 1 + s] * a / m_cbcLref[cbcId];
  }
}


/** \brief Calculates the outflow damping terms
 *  \date October 2019
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbcDampingOutflow(MInt cellId, MInt bcId, MFloat maxM, MFloat* K) {
  TRACE();

  MInt cbcId = m_cbcBndryCndIds[bcId];
  MInt last = CV->noVariables - 1 - m_solver->m_noSpecies;

  MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
  MFloat p = m_solver->a_pvariable(cellId, PV->P);
  MFloat a = sysEqn().speedOfSound(rho, p);

  K[0] = m_cbcRelax[cbcId][0] * a * (F1 - maxM * maxM) / m_cbcLref[cbcId];
  K[last] = K[0];
}

/** \brief Calculates the right hand side
 * \date October 2019
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbcRHS(MInt cellId, MInt bcId, MFloat* L, MFloat* T, MFloat* V) {
  TRACE();

  MInt last = CV->noVariables - 1 - m_solver->m_noSpecies;

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];

  MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
  MFloat un = F0;
  MFloat ut1 = F0;

  un = m_solver->a_pvariable(cellId, PV->VV[dimN]) * m_dirNormal[cbcId][dimN]
       + m_solver->a_pvariable(cellId, PV->VV[dimT1]) * m_dirNormal[cbcId][dimT1];
  ut1 = m_solver->a_pvariable(cellId, PV->VV[dimN]) * m_dirTangent[cbcId][dimN]
        + m_solver->a_pvariable(cellId, PV->VV[dimT1]) * m_dirTangent[cbcId][dimT1];

  MFloat ut2 = F0;
  IF_CONSTEXPR(nDim == 3) {
    MInt dimT2 = m_cbcDir[cbcId][nDim];
    un += m_solver->a_pvariable(cellId, PV->VV[dimT2]) * m_dirNormal[cbcId][dimT2];
    ut1 += m_solver->a_pvariable(cellId, PV->VV[dimT2]) * m_dirTangent[cbcId][dimT2];
    ut2 = m_solver->a_pvariable(cellId, PV->VV[dimT2]);
  }

  MFloat p = m_solver->a_pvariable(cellId, PV->P);
  MFloat a = sysEqn().speedOfSound(rho, p);

  MFloat sumOfVVSquared = POW2(un) + POW2(ut1);
  IF_CONSTEXPR(nDim == 3) sumOfVVSquared += POW2(ut2);

  MFloat d1 = m_dirNormal[cbcId][dimN] * F1 / (a * a) * L[1] + m_dirNormal[cbcId][dimT1] * L[3]
              + F1B2 * F1 / (a * a) * (L[last] + L[0]);
  MFloat d2 = m_dirNormal[cbcId][dimN] * (F1B2 / (rho * a) * (L[last] - L[0])) - m_dirNormal[cbcId][dimT1] * L[2];
  MFloat d3 = m_dirNormal[cbcId][dimN] * L[2] + m_dirNormal[cbcId][dimT1] * (F1B2 / (rho * a) * (L[last] - L[0]));
  IF_CONSTEXPR(nDim == 3) {
    MInt dimT2 = m_cbcDir[cbcId][nDim];
    d1 -= m_dirNormal[cbcId][dimT2] * L[2];
    d2 -= m_dirNormal[cbcId][dimT2] * L[3];
    d3 += m_dirNormal[cbcId][dimT2] * F1 / (a * a) * L[1];
  }
  MFloat d5 = F1B2 * (L[last] + L[0]);

  std::vector<MFloat> dSpecies;
  std::vector<MFloat> rhs_rhoY;
  dSpecies.resize(m_solver->m_noSpecies);
  rhs_rhoY.resize(m_solver->m_noSpecies);

  for(MInt s = 0; s < m_solver->m_noSpecies; s++) {
    dSpecies[s] = L[last + 1 + s];
  }

  MFloat rhs_rho = -d1 + T[0] + V[0];
  MFloat rhs_rhoun = un * (-d1 + T[0] + V[0]) + rho * (-d2 + T[1] + V[1]);
  MFloat rhs_rhout1 = ut1 * (-d1 + T[0] + V[0]) + rho * (-d3 + T[2] + V[2]);
  MFloat rhs_rhoe = F1B2 * sumOfVVSquared * (-d1 + T[0] + V[0]) + rho * un * (-d2 + T[1] + V[1])
                    + rho * ut1 * (-d3 + T[2] + V[2]) + sysEqn().cp_Ref() * (-d5 + T[last] + V[last]);

  for(MInt s = 0; s < m_solver->m_noSpecies; s++) {
    rhs_rhoY[s] = m_solver->a_pvariable(cellId, PV->Y[s]) * (-d1 + T[0]) + rho * (-dSpecies[s] + T[last + 1 + s]);
  }

  IF_CONSTEXPR(nDim == 3) {
    MInt dimT2 = m_cbcDir[cbcId][nDim];
    MFloat d4 = m_dirNormal[cbcId][dimN] * L[3] + m_dirNormal[cbcId][dimT2] * (F1B2 / (rho * a) * (L[last] - L[0]))
                - m_dirNormal[cbcId][dimT1] * F1 / (a * a) * L[1];
    MFloat rhs_rhout2 = ut2 * (-d1 + T[0] + V[0]) + rho * (-d4 + T[3] + V[3]);
    rhs_rhoe += rho * ut2 * (-d4 + T[3] + V[3]);

    m_solver->a_rightHandSide(cellId, CV->RHO_VV[dimT2]) = -m_solver->a_cellVolume(cellId) * rhs_rhout2;
  }

  m_solver->a_rightHandSide(cellId, CV->RHO) = -m_solver->a_cellVolume(cellId) * rhs_rho;
  m_solver->a_rightHandSide(cellId, CV->RHO_VV[dimN]) = -m_solver->a_cellVolume(cellId) * rhs_rhoun;
  m_solver->a_rightHandSide(cellId, CV->RHO_VV[dimT1]) = -m_solver->a_cellVolume(cellId) * rhs_rhout1;
  m_solver->a_rightHandSide(cellId, CV->RHO_E) = -m_solver->a_cellVolume(cellId) * rhs_rhoe;

  for(MInt s = 0; s < m_solver->m_noSpecies; s++) {
    m_solver->a_rightHandSide(cellId, CV->RHO_Y[s]) -= m_solver->a_cellVolume(cellId) * rhs_rhoY[s];
  }
}


/** \brief Turbulence injection (identical to bc1601) adjusted for Taylor's Hypothesis for cbc
 *  \author Soeren Mehnert
 *  \date June 2020
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbcTurbulenceInjection(MInt cellId, MFloat* L_turbulent, MInt sortedCutOffCellId) {
  TRACE();

  IF_CONSTEXPR(nDim != 3) mTerm(1, AT_, "Only implemented for nDim = 3");

  MFloat dummyTime;
  MFloat that, twopioverlb;

  MFloat xhat, yhat, zhat;
  MFloat fluctChol[3];

  // calculate fluctuation from time step previous to restart
  if(m_solver->m_restart && globalTimeStep == m_solver->m_restartTimeStep + 1) {
    dummyTime = (m_solver->m_time - m_solver->m_timeStep) / m_bc1601->m_tau_b;
    m_bc1601->checkRegeneration(dummyTime);

    that = F2 * PI * dummyTime;
    twopioverlb = F2 * PI / m_bc1601->m_l_b;

    xhat = twopioverlb * m_solver->a_coordinate(cellId, 0);
    yhat = twopioverlb * m_solver->a_coordinate(cellId, 1);
    zhat = twopioverlb * m_solver->a_coordinate(cellId, 2);

    m_bc1601->calculateFlucts(that, xhat, yhat, zhat, fluctChol);

    m_oldFluctChol[sortedCutOffCellId][0] = fluctChol[0];
    m_oldFluctChol[sortedCutOffCellId][1] = fluctChol[1];
    IF_CONSTEXPR(nDim == 3) m_oldFluctChol[sortedCutOffCellId][2] = fluctChol[2];
  }

  dummyTime = m_solver->m_time / m_bc1601->m_tau_b;
  m_bc1601->checkRegeneration(dummyTime);

  that = F2 * PI * dummyTime;
  twopioverlb = F2 * PI / m_bc1601->m_l_b;

  xhat = twopioverlb * m_solver->a_coordinate(cellId, 0);
  yhat = twopioverlb * m_solver->a_coordinate(cellId, 1);
  zhat = twopioverlb * m_solver->a_coordinate(cellId, 2);

  m_bc1601->calculateFlucts(that, xhat, yhat, zhat, fluctChol);

  MFloat dFluctCholndn =
      (fluctChol[0] - m_oldFluctChol[sortedCutOffCellId][0]) / (m_solver->c_cellLengthAtCell(cellId));
  MFloat dFluctCholt1dn =
      (fluctChol[1] - m_oldFluctChol[sortedCutOffCellId][1]) / (m_solver->c_cellLengthAtCell(cellId));

  MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
  MFloat a = sysEqn().speedOfSound(rho, m_solver->a_pvariable(cellId, PV->P));

  L_turbulent[0] = rho * a * m_solver->m_UInfinity * dFluctCholndn;
  L_turbulent[1] = rho * a * m_solver->m_UInfinity * dFluctCholt1dn;
  IF_CONSTEXPR(nDim == 3) {
    MFloat dFluctCholt2dn =
        (fluctChol[2] - m_oldFluctChol[sortedCutOffCellId][2]) / (m_solver->c_cellLengthAtCell(cellId));
    L_turbulent[2] = rho * a * m_solver->m_UInfinity * dFluctCholt2dn;
  }

  if(m_solver->m_RKStep == m_solver->m_noRKSteps - 1) {
    m_oldFluctChol[sortedCutOffCellId][0] = fluctChol[0];
    m_oldFluctChol[sortedCutOffCellId][1] = fluctChol[1];
    IF_CONSTEXPR(nDim == 3) m_oldFluctChol[sortedCutOffCellId][2] = fluctChol[2];
  }

  return;
}


/**
 * \fn FvBndryCndXD::cbc1091a()
 * Characteristic boundary condition. Inflow. Prescribed: T, un, ut1, ut2. Partially Refelecting.
 * \author Thomas Hoesgen, Soeren Mehnert
 * \date May 2020
 * \fvcbc{FvBndryCndXD::cbc1091a(), fvcbc1091a, CBC 1091A}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc1091a(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  MInt last = nDim + 1;

  // Allocate meomry
  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");

  MFloat mach[2] = {F0, F0};
  cbcMachCo(bcId, mach);
  MFloat meanM = mach[0];
  MFloat maxM = mach[1];
  maxM = F0;

  if(m_cbcTurbulence) m_cbcViscous = false;

  MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");
  MFloatScratchSpace gradTau(m_cbcViscous ? (nDim * nDim * nDim) : 1, AT_, "gradTau");
  MFloatScratchSpace gradQ(m_cbcViscous ? (nDim * nDim) : 1, AT_, "gradQ");

  MIntScratchSpace cutOffStencilCellIds(m_cbcViscous ? m_solver->a_noCells() : 1, AT_, "cutOffStencilCellIds");
  if(m_cbcViscous) cbcTauQ(bcId, &tau[0], &q[0], &cutOffStencilCellIds[0]);

  MFloat T_target = sysEqn().temperature_IR(meanM);
  IF_CONSTEXPR(isDetChem<SysEqn>) T_target = m_solver->m_detChem.infTemperature;

  // BC specific start
  MBool solverProfile = false;
  solverProfile = Context::getSolverProperty<MBool>("solverProfile", m_solverId, AT_, &solverProfile);
  MFloat A = F0;
  IF_CONSTEXPR(nDim == 3) { A = sqrt(m_cbcInflowArea[cbcId] / PI); }
  else {
    A = m_cbcInflowArea[cbcId] * F1B2;
  }
  MFloat testSum2 = F0;
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    MInt bndryId = m_solver->a_bndryId(cellId);

    MFloat area;
    if(bndryId > -1) {
      MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dirN];
      if(srfcId > -1) {
        area = m_solver->a_surfaceArea(srfcId);
      } else {
        mTerm(1, AT_, "something went wrong!");
      }
    } else {
      IF_CONSTEXPR(nDim == 2) area = m_solver->c_cellLengthAtCell(cellId);
      IF_CONSTEXPR(nDim == 3) area = POW2(m_solver->c_cellLengthAtCell(cellId));
    }

    area *= m_dirTangent[cbcId][m_cbcDir[cbcId][2]];

    MFloat rsquare;
    IF_CONSTEXPR(nDim == 2) {
      rsquare = POW2((m_solver->a_coordinate(cellId, dimT1) - m_cbcReferencePoint[cbcId][dimT1]));
    }
    else {
      rsquare = POW2(m_solver->a_coordinate(cellId, 0) - m_cbcReferencePoint[cbcId][0])
                + POW2(m_solver->a_coordinate(cellId, 1) - m_cbcReferencePoint[cbcId][1])
                + POW2(m_solver->a_coordinate(cellId, 2) - m_cbcReferencePoint[cbcId][2]);
    }
    testSum2 += area * rsquare;
  }

  MInt noExchangeData = 1;
  MFloatScratchSpace comm_buff(noExchangeData, AT_, "comm_buff");
  MFloatScratchSpace comm_buff_result(noExchangeData, AT_, "comm_buff_result");
  comm_buff[0] = testSum2;

  if(noDomains() > 1) {
    MPI_Allreduce(&comm_buff[0], &comm_buff_result[0], 1, MPI_DOUBLE, MPI_MAX, m_comm_bcCo[m_bcCo_comm_pointer[bcId]],
                  AT_, "comm_buff[0]", "comm_buff_result[0]");
  }

  testSum2 = comm_buff_result[0];

  MFloat massflux_test;
  IF_CONSTEXPR(nDim == 2) { massflux_test = F3B4 / A * (m_cbcInflowArea[cbcId] - F1 / (A * A) * testSum2); }
  else {
    massflux_test = F2 * (F1 - testSum2 / (m_cbcInflowArea[cbcId] * A * A));
  }
  MFloat un_correctionFactor = F1;
  if(fabs(massflux_test) > m_solver->m_eps) {
    un_correctionFactor = F1 / massflux_test;
  }

  MFloat massflux_target;
  IF_CONSTEXPR(nDim == 2) {
    massflux_target = m_solver->m_UInfinity * m_cbcInflowArea[cbcId]
                      * sysEqn().density_ES(m_solver->m_PInfinity, m_solver->m_TInfinity);
    IF_CONSTEXPR(isDetChem<SysEqn>) {
      massflux_target = m_solver->m_VInfinity * m_cbcInflowArea[cbcId] * m_solver->m_rhoInfinity;
    }
  }
  // fvmbbndrycnd3d uses m_UInfinity instead!
  IF_CONSTEXPR(nDim == 3) {
    massflux_target = m_solver->m_VInfinity * m_cbcInflowArea[cbcId]
                      * sysEqn().density_ES(m_solver->m_PInfinity, m_solver->m_TInfinity);
  }
  // BC specific end

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);

    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    V.fill(F0);
    if(m_cbcViscous) {
      cbcGradientsViscous(cellId, bcId, &tau[0], &q[0], &gradTau[0], &gradQ[0], &cutOffStencilCellIds[0]);
      gradTau[dimN * IPOW2(nDim) + dimT1 * nDim + dimN] = F0;
      IF_CONSTEXPR(nDim == 3) { gradTau[dimN * IPOW2(nDim) + dimT2 * nDim + dimN] = F0; }
      V.fill(F0);
      cbcViscousTerms<(unsigned char)01111>(cellId, bcId, &tau[0], &gradTau[0], &gradQ[0], &gradVV[0],
                                            &cutOffStencilCellIds[0], &V[0]);
    }

    cbcOutgoingAmplitudeVariation<1>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
    cbcTransversalTerms<(unsigned char)11111>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &T[0]);
    cbcDampingInflow(cellId, bcId, maxM, &K[0], "velocity");

    MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    MFloat un = m_solver->a_pvariable(cellId, PV->VV[dimN]);
    MFloat ut1 = m_solver->a_pvariable(cellId, PV->VV[dimT1]);
    MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat temp = sysEqn().temperature_ES(rho, p);

    IF_CONSTEXPR(isDetChem<SysEqn>) {
      MFloat fMeanMolarWeight = F0;
      for(MUint s = 0; s < PV->m_noSpecies; s++) {
        fMeanMolarWeight += m_solver->a_pvariable(cellId, PV->Y[s]) * m_solver->m_fMolarMass[s];
      }
      MFloat meanMolarWeight = F1 / fMeanMolarWeight;
      temp = p / rho * meanMolarWeight / m_solver->m_gasConstant;
    }

    MFloat a = sysEqn().speedOfSound(rho, p);
    IF_CONSTEXPR(isDetChem<SysEqn>) a = sqrt(m_solver->a_avariable(cellId, m_solver->AV->GAMMA) * p / rho);

    // BC specific start
    MFloat rsquare;
    MFloat un_target;
    IF_CONSTEXPR(nDim == 2) {
      rsquare = POW2((m_solver->a_coordinate(cellId, dimT1) - m_cbcReferencePoint[cbcId][dimT1]));
      un_target = F3B4 * massflux_target / rho / A * (1 - rsquare / (A * A)) * un_correctionFactor;
    }
    else {
      rsquare = POW2(m_solver->a_coordinate(cellId, 0) - m_cbcReferencePoint[cbcId][0])
                + POW2(m_solver->a_coordinate(cellId, 1) - m_cbcReferencePoint[cbcId][1])
                + POW2(m_solver->a_coordinate(cellId, 2) - m_cbcReferencePoint[cbcId][2]);
      un_target = F2 * massflux_target / m_cbcInflowArea[cbcId] * (F1 - rsquare / (A * A)) / rho * un_correctionFactor;
    }
    if(solverProfile) {
      un_target = massflux_target / m_cbcInflowArea[cbcId] / rho;
    }
    // BC specific end

    // detChem specific setting
    IF_CONSTEXPR(isDetChem<SysEqn>) un_target = m_solver->m_VInfinity;
    MFloat ut1_target = F0;
    MFloat y_target = F1;

    MFloat L_turbulent[3] = {F0, F0, F0};
    if(m_cbcTurbulence) {
      cbcTurbulenceInjection(cellId, L_turbulent, id);
    }

    if(dirN % 2 == 0) {
      L[0] = -F1 * K[0] * (un - un_target) + (T[last] - rho * a * T[1]) + (V[last] - rho * a * V[1]);
    } else {
      L[last] = K[last] * (un - un_target) - L_turbulent[0] + (T[last] + rho * a * T[1]) + (V[last] + rho * a * V[1]);
    }

    L[1] = K[1] * (temp - T_target) + (a * a * T[0] - T[last]) - V[last];
    L[2] = K[2] * (ut1 - ut1_target) - L_turbulent[1] + T[2] + V[2];

    IF_CONSTEXPR(nDim == 3) {
      MFloat ut2 = m_solver->a_pvariable(cellId, PV->VV[dimT2]);
      MFloat ut2_target = F0;
      L[3] = K[3] * (ut2 - ut2_target) - L_turbulent[2] + T[3] + V[3];
    }

    IF_CONSTEXPR(isDetChem<SysEqn>) {
      for(MInt s = 0; s < m_solver->m_noSpecies; s++) {
        MFloat y = m_solver->a_pvariable(cellId, sysEqn().PV->Y[s]);
        L[last + 1 + s] = K[last + 1 + s] * (y - m_solver->m_YInfinity[s]);
      }
    }
    else {
      for(MInt s = 0; s < m_solver->m_noSpecies; s++) {
        MFloat y = m_solver->a_pvariable(cellId, sysEqn().PV->Y[s]);
        L[last + 1 + s] = K[last + 1 + s] * (y - y_target);
      }
    }
    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);
  }
}

/** \brief Characteristic boundary condition. Outflow. Prescribed: p. Partially Refelecting.
 *  \author Jannik Borgelt
 *  \date September 2023
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc109921(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  // MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  // MInt last = nDim + 1;

  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");
  L.fill(F0);
  T.fill(F0);
  V.fill(F0);
  K.fill(F0);

  std::vector<MFloat> mach(2);
  cbcMachCo(bcId, &mach[0]);
  // MFloat meanM = mach[0];
  MFloat maxM = mach[1];

  MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");
  MFloatScratchSpace gradTau(m_cbcViscous ? (nDim * nDim * nDim) : 1, AT_, "gradTau");
  MFloatScratchSpace gradQ(m_cbcViscous ? (nDim * nDim) : 1, AT_, "gradQ");

  MIntScratchSpace cutOffStencilCellIds(m_cbcViscous ? m_solver->a_noCells() : 1, AT_, "cutOffStencilCellIds");
  if(m_cbcViscous) cbcTauQ(bcId, &tau[0], &q[0], &cutOffStencilCellIds[0]);

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    V.fill(F0);
    // if(m_cbcViscous) {
    //   cbcGradientsViscous(cellId, bcId, &tau[0], &q[0], &gradTau[0], &gradQ[0], &cutOffStencilCellIds[0]);
    //   gradQ[dimN * nDim + dimN] = F0;
    //   gradTau[dimN * IPOW2[nDim] + dimT1 * nDim + dimN] = F0;
    //   IF_CONSTEXPR(nDim == 3) gradTau[dimN * IPOW2[nDim] + dimT2 * nDim + dimN] = F0;
    //   cbcViscousTerms<(unsigned char)11111>(cellId, bcId, &tau[0], &gradTau[0], &gradQ[0], &gradVV[0],
    //                                         &cutOffStencilCellIds[0], &V[0]);
    // }

    MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat a = sysEqn().speedOfSound(rho, p);

    MFloat vn_N = 0;

    // check neighbor active!
    if(m_solver->checkNeighborActive(cellId, dirN) && m_solver->a_hasNeighbor(cellId, dirN)) {
      const MInt nghbrN = m_solver->c_neighborId(cellId, dirN);
      for(MInt n = 0; n < nDim; n++) {
        vn_N += m_solver->a_variable(nghbrN, CV->RHO_VV[n]) * m_dirNormal[cbcId][n];
      }
    }

    MFloat x = m_solver->a_coordinate(cellId, 0);
    MFloat vn_target = m_solver->m_UInfinity;
    MInt length = m_vnTargetDataCount;
    for(MInt i = 1; i < length; i++) {
      if(m_vnTargetData[i].first > x && m_vnTargetData[i - 1].first <= x) {
        vn_target = m_vnTargetData[i - 1].second
                    + (m_vnTargetData[i].second - m_vnTargetData[i - 1].second)
                          / (m_vnTargetData[i].first - m_vnTargetData[i - 1].first) * (x - m_vnTargetData[i - 1].first);
      }
    }

    MFloat un = m_solver->a_pvariable(cellId, PV->VV[0]);
    MFloat vn = m_solver->a_pvariable(cellId, PV->VV[1]);
    MFloat lambda1 = (un - a);
    MFloat lambda2 = un;

    cbcOutgoingAmplitudeVariation<1>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
    cbcDampingInflow(cellId, bcId, maxM, &K[0], "pressure");
    L[0] = lambda1 * (gradP[dimN] - rho * a * gradVV[dimN * nDim + dimN]);
    L[1] = lambda2 * (a * a * gradRho[dimN] - gradP[dimN]);
    L[2] = K[2] * (vn - vn_target);
    // L[2] = lambda2 * (gradVV[dimT1 * nDim + dimN]);
    IF_CONSTEXPR(nDim == 3) { L[3] = lambda2 * (gradVV[dimT2 * nDim + dimN]); }

    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);
  }
}

/** \brief Characteristic boundary condition. Outflow. Prescribed: p. Partially Refelecting.
 *  \author Jannik Borgelt
 *  \date May 2023
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc109910(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  MInt last = nDim + 1;

  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");
  L.fill(F0);
  T.fill(F0);
  V.fill(F0);
  K.fill(F0);

  std::vector<MFloat> mach(2);
  cbcMachCo(bcId, &mach[0]);
  MFloat meanM = mach[0];
  MFloat maxM = mach[1];

  MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");
  MFloatScratchSpace gradTau(m_cbcViscous ? (nDim * nDim * nDim) : 1, AT_, "gradTau");
  MFloatScratchSpace gradQ(m_cbcViscous ? (nDim * nDim) : 1, AT_, "gradQ");

  MIntScratchSpace cutOffStencilCellIds(m_cbcViscous ? m_solver->a_noCells() : 1, AT_, "cutOffStencilCellIds");
  if(m_cbcViscous) cbcTauQ(bcId, &tau[0], &q[0], &cutOffStencilCellIds[0]);


  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    V.fill(F0);
    // if(m_cbcViscous) {
    //   cbcGradientsViscous(cellId, bcId, &tau[0], &q[0], &gradTau[0], &gradQ[0], &cutOffStencilCellIds[0]);
    //   gradQ[dimN * nDim + dimN] = F0;
    //   gradTau[dimN * IPOW2[nDim] + dimT1 * nDim + dimN] = F0;
    //   IF_CONSTEXPR(nDim == 3) gradTau[dimN * IPOW2[nDim] + dimT2 * nDim + dimN] = F0;
    //   cbcViscousTerms<(unsigned char)11111>(cellId, bcId, &tau[0], &gradTau[0], &gradQ[0], &gradVV[0],
    //                                         &cutOffStencilCellIds[0], &V[0]);
    // }

    MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat a = sysEqn().speedOfSound(rho, p);

    MFloat beta = meanM;

    // BC specific start
    MFloat targetPressure = m_solver->m_PInfinity;
    MFloat targetDensity = m_solver->m_rhoInfinity;

    MFloat un_N = 0;

    // check neighbor active!
    if(m_solver->checkNeighborActive(cellId, dirN) && m_solver->a_hasNeighbor(cellId, dirN)) {
      const MInt nghbrN = m_solver->c_neighborId(cellId, dirN);

      for(MInt n = 0; n < nDim; n++) {
        un_N += m_solver->a_variable(nghbrN, CV->RHO_VV[n]) * m_dirNormal[cbcId][n];
      }
    }

    MFloat y = m_solver->a_coordinate(cellId, 1);
    MFloat un_target = m_solver->m_UInfinity;
    MInt length = m_unTargetDataCount; //(MInt)un_targetData.size();
    for(MInt i = 1; i < length; i++) {
      if(m_unTargetData[i].first > y && m_unTargetData[i - 1].first <= y) {
        un_target = m_unTargetData[i - 1].second
                    + (m_unTargetData[i].second - m_unTargetData[i - 1].second)
                          / (m_unTargetData[i].first - m_unTargetData[i - 1].first) * (y - m_unTargetData[i - 1].first);
      }
    }

    MBool isInflow = false;
    if(dirN % 2 == 0) {
      if(un_N < F0 /*|| un_target < F0*/) {
        isInflow = true;
      }
    } else {
      if(un_N > F0 /*|| un_target > F0*/) {
        isInflow = true;
      }
    }

    MFloat un = m_solver->a_pvariable(cellId, PV->VV[0]);

    MFloat lambda2 = un;

    isInflow = true;

    std::ignore = targetDensity;

    if(isInflow) {
      cbcOutgoingAmplitudeVariation<1>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
      cbcDampingInflow(cellId, bcId, maxM, &K[0], "pressure");
      if(dirN % 2 == 0) {
        L[0] = -F1 * K[0] * (un - un_target) + (T[last] - rho * a * T[1]) + (V[last] - rho * a * V[1]);
      } else {
        L[last] = K[last] * (un - un_target) + (T[last] + rho * a * T[1]) + (V[last] + rho * a * V[1]);
      }
      L[1] = lambda2 * (a * a * gradRho[dimN] - gradP[dimN]);
      L[2] = lambda2 * (gradVV[dimT1 * nDim + dimN]);
      IF_CONSTEXPR(nDim == 3) { L[3] = lambda2 * (gradVV[dimT2 * nDim + dimN]); }
    } else {
      cbcOutgoingAmplitudeVariation<0>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
      cbcDampingOutflow(cellId, bcId, maxM, &K[0]);
      if(dirN % 2 == 0) {
        L[0] = K[0] * (p - targetPressure) + (F1 - beta) * (T[last] - rho * a * T[1]) + (V[last] - rho * a * V[1]);
      } else {
        L[last] =
            K[last] * (p - targetPressure) + (F1 - beta) * (T[last] + rho * a * T[1]) + (V[last] + rho * a * V[1]);
      }
    }

    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);
  }
}

/** \brief Characteristic boundary condition. Outflow. Prescribed: p. Partially Refelecting.
 *  \author Jannik Borgelt
 *  \date July 2023
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc109911(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  // MInt dimN = m_cbcDir[cbcId][1];
  // MInt dimT1 = m_cbcDir[cbcId][2];
  // MInt dimT2 = m_cbcDir[cbcId][nDim];

  MInt last = nDim + 1;

  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  // gradY.fill(F0);

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  // MFloatScratchSpace K(PV->noVariables, AT_, "K");
  L.fill(F0);
  T.fill(F0);
  V.fill(F0);
  // K.fill(F0);

  // MFloat mach[2];
  // cbcMachCo(bcId, mach);
  // MFloat meanM = mach[0];
  // MFloat maxM = mach[1];

  // MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  // MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  // MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    MInt level = m_solver->a_level(cellId);
    MInt rDistance = 1 / m_solver->c_cellLengthAtLevel(level);

    if(m_solver->a_isHalo(cellId)) continue;

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);

    MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat u = m_solver->a_pvariable(cellId, PV->VV[0]);
    MFloat a = sysEqn().speedOfSound(rho, p);

    // BC specific start
    MFloat targetPressure = m_solver->m_PInfinity;
    // MFloat targetDensity = m_solver->m_rhoInfinity;

    MFloat y = m_solver->a_coordinate(cellId, 1);
    MFloat un_target = m_solver->m_UInfinity;
    MInt length = m_unTargetDataCount; //(MInt)un_targetData.size();
    for(MInt i = 1; i < length; i++) {
      if(m_unTargetData[i].first > y && m_unTargetData[i - 1].first <= y) {
        un_target = m_unTargetData[i - 1].second
                    + (m_unTargetData[i].second - m_unTargetData[i - 1].second)
                          / (m_unTargetData[i].first - m_unTargetData[i - 1].first) * (y - m_unTargetData[i - 1].first);
      }
    }

    // MBool switchRelax = false;

    // cbcOutgoingAmplitudeVariation<0>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
    // cbcDampingOutflow(cellId, bcId, maxM, &K[0]);
    if(dirN % 2 == 0) {
      L[0] = F0; // ToDo
    } else {
      L[last] = rDistance * ((u - a) * (targetPressure - p) - rho * a * (un_target - u));
    }

    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);
  }
}

/**
 * \fn FvBndryCndXD::cbc1099()
 * Characteristic boundary condition. Outflow. Prescribed: p. Partially Refelecting.
 * \author Thomas Hoesgen, Soeren Mehnert
 * \date May 2020
 * \fvcbc{FvBndryCndXD::cbc1099(), fvcbc1099, CBC 1099}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc1099(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  MInt last = nDim + 1;

  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");

  MFloat mach[2];
  cbcMachCo(bcId, mach);
  MFloat meanM = mach[0];
  MFloat maxM = mach[1];


  MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");
  MFloatScratchSpace gradTau(m_cbcViscous ? (nDim * nDim * nDim) : 1, AT_, "gradTau");
  MFloatScratchSpace gradQ(m_cbcViscous ? (nDim * nDim) : 1, AT_, "gradQ");

  MIntScratchSpace cutOffStencilCellIds(m_cbcViscous ? m_solver->a_noCells() : 1, AT_, "cutOffStencilCellIds");
  if(m_cbcViscous) cbcTauQ(bcId, &tau[0], &q[0], &cutOffStencilCellIds[0]);

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    V.fill(F0);
    if(m_cbcViscous) {
      cbcGradientsViscous(cellId, bcId, &tau[0], &q[0], &gradTau[0], &gradQ[0], &cutOffStencilCellIds[0]);
      gradQ[dimN * nDim + dimN] = F0;
      gradTau[dimN * IPOW2(nDim) + dimT1 * nDim + dimN] = F0;
      IF_CONSTEXPR(nDim == 3) gradTau[dimN * IPOW2(nDim) + dimT2 * nDim + dimN] = F0;
      cbcViscousTerms<(unsigned char)11111>(cellId, bcId, &tau[0], &gradTau[0], &gradQ[0], &gradVV[0],
                                            &cutOffStencilCellIds[0], &V[0]);
    }

    cbcOutgoingAmplitudeVariation<0>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
    cbcTransversalTerms<(unsigned char)11111>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &T[0]);
    cbcDampingOutflow(cellId, bcId, maxM, &K[0]);

    MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat a = sysEqn().speedOfSound(rho, p);

    MFloat beta = meanM;

    // BC specific start
    MFloat targetPressure = m_solver->m_PInfinity - m_deltaPL;
    // BC specific end
    // targetPressure = m_solver->m_PInfinity;
    MFloat y_target = F0;

    if(dirN % 2 == 0) {
      L[0] = K[0] * (p - targetPressure) + (F1 - beta) * (T[last] - rho * a * T[1]) + (V[last] - rho * a * V[1]);
    } else {
      L[last] = K[last] * (p - targetPressure) + (F1 - beta) * (T[last] + rho * a * T[1]) + (V[last] + rho * a * V[1]);
    }
    for(MInt s = 0; s < m_solver->m_noSpecies; s++) {
      MFloat y = m_solver->a_pvariable(cellId, sysEqn().PV->Y[s]);
      L[last + 1 + s] = K[last + 1 + s] * (y - y_target);
    }

    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);
  }
}


/**
 * \fn FvBndryCndXD::cbc2091a()
 * Subsonic partially reflecting characteristic inflow condition - cut off \n
 * T0, u, v is prescribed, incl. transverse terms
 * \fvcbc{FvBndryCndXD::cbc2091a(), fvcbc2091a, CBC 2091A}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc2091a(MInt bcId) {
  IF_CONSTEXPR(nDim == 3) { TERMM(-1, "INFO: function cbc2091a is untested for 3D!"); }
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  MBool solverProfile = Context::getSolverProperty<MBool>("solverProfile", m_solverId, AT_, &solverProfile);
  MFloat time = m_solver->m_time;
  MFloat St = m_solver->m_flameStrouhal;
  MFloat ampl = m_solver->m_forcingAmplitude;

  MFloat inflowArea = m_cbcInflowArea[cbcId];
  // MFloat H = inflowArea * F1B2;

  MInt last = nDim + 1;

  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");

  MFloat mach[2] = {F0, F0};
  cbcMachCo(bcId, mach);
  MFloat maxM = mach[1];

  MFloat massflux = F0;
  MFloat uInt = F0;
  MFloat testSum2 = F0;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    MInt bndryId = m_solver->a_bndryId(cellId);

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MFloat area = F0;
    if(bndryId > -1) {
      // identify the "boundary surface" between cutoff boundary cell and neighboring layer cell if cell is a boundary
      // cell
      MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dirN];
      if(srfcId > -1)
        area = m_solver->a_surfaceArea(srfcId);
      else
        mTerm(1, AT_, "something went wrong!");
    } else {
      area = m_solver->c_cellLengthAtCell(cellId);
    }

    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    const MFloat un = m_solver->a_pvariable(cellId, PV->VV[dimN]);
    const MFloat y = (m_solver->a_coordinate(cellId, dimT1) - m_cbcReferencePoint[cbcId][dimT1]);
    testSum2 += area * y * y;
    massflux += un * rho * area;
    uInt += un * area;
  }

  MInt noExchangeData = 2;
  MFloatScratchSpace comm_buff(noExchangeData, AT_, "comm_buff");
  MFloatScratchSpace comm_buff_result(noExchangeData, AT_, "comm_buff_result");
  comm_buff[0] = massflux;
  comm_buff[1] = testSum2;

  if(noDomains() > 1) {
    MPI_Allreduce(&comm_buff[0], &comm_buff_result[0], 3, MPI_DOUBLE, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]],
                  AT_, "comm_buff[0]", "comm_buff_result[0]");
    MPI_Allreduce(MPI_IN_PLACE, &uInt, 1, MPI_DOUBLE, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                  "MPI_IN_PLACE", "uInt");
  }

  massflux = comm_buff_result[0];
  testSum2 = comm_buff_result[1];
  MFloat massflux_test = uInt / m_solver->m_analyticIntegralVelocity;

  MFloat un_correctionFactor = F1;
  if(fabs(massflux_test) > m_solver->m_eps) un_correctionFactor = F1 / massflux_test;

  const MFloat massflux_target = massflux * un_correctionFactor;

  MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");
  MFloatScratchSpace gradTau(m_cbcViscous ? (nDim * nDim * nDim) : 1, AT_, "gradTau");
  MFloatScratchSpace gradQ(m_cbcViscous ? (nDim * nDim) : 1, AT_, "gradQ");

  MIntScratchSpace cutOffStencilCellIds(m_cbcViscous ? m_solver->a_noCells() : 1, AT_, "cutOffStencilCellIds");
  if(m_cbcViscous) cbcTauQ(bcId, &tau[0], &q[0], &cutOffStencilCellIds[0]);

  MFloat T_target = sysEqn().temperature_ES(m_solver->m_rhoInfinity, m_solver->m_meanPressure);

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);
    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    V.fill(F0);
    if(m_cbcViscous) {
      cbcGradientsViscous(cellId, bcId, &tau[0], &q[0], &gradTau[0], &gradQ[0], &cutOffStencilCellIds[0]);
      gradTau[dimN * IPOW2(nDim) + dimT1 * nDim + dimN] = F0;
      IF_CONSTEXPR(nDim == 3) { gradTau[dimN * IPOW2(nDim) + dimT2 * nDim + dimN] = F0; }
      cbcViscousTerms<(unsigned char)01111>(cellId, bcId, &tau[0], &gradTau[0], &gradQ[0], &gradVV[0],
                                            &cutOffStencilCellIds[0], &V[0]);
    }

    cbcOutgoingAmplitudeVariation<1>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
    cbcTransversalTerms<(unsigned char)11111>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &T[0]);
    cbcDampingInflow(cellId, bcId, maxM, &K[0], "velocity");

    MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    MFloat un = m_solver->a_pvariable(cellId, PV->VV[dimN]);
    MFloat ut1 = m_solver->a_pvariable(cellId, PV->VV[dimT1]);

    MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat temp = sysEqn().temperature_ES(rho, p);
    MFloat a = sysEqn().speedOfSound(rho, p);

    MFloat xPlus = (m_solver->a_coordinate(cellId, 0) + m_radiusVelFlameTube);
    xPlus *= m_shearLayerStrength;
    MFloat xNegative = m_solver->a_coordinate(cellId, 0) - m_radiusVelFlameTube;
    xNegative *= m_shearLayerStrength;

    MFloat un_target = m_solver->m_VInfinity
                       * (F1B2 * (F1 + tanh(xPlus)) * (F1 - tanh(xNegative))
                          - F1); // F3B4 * massflux/H*(1-y*y/(H*H))*un_correctionFactor;

    // F3B4 * massflux_target/rho/H*(1-y*y/(H*H))*un_correctionFactor;
    if(solverProfile) un_target = massflux_target / inflowArea / rho;

    if(m_solver->m_forcing) {
      //      dundt = un_target;
      //      dundt *= St*ampl*cos(St*time);
      un_target *= (F1 + ampl * sin(St * time));
    }

    MFloat ut1_target = F0;

    if(dirN % 2 == 0) {
      L[0] = -F1 * K[0] * (un - un_target) + (T[last] - rho * a * T[1]) + (V[last] - rho * a * V[1]);
    } else {
      L[last] = K[last] * (un - un_target) + (T[last] + rho * a * T[1]) + (V[last] + rho * a * V[1]);
    }

    L[1] = K[1] * (temp - T_target) + (a * a * T[0] - T[last]) - V[last];
    L[2] = K[2] * (ut1 - ut1_target) + T[2] + V[2];

    IF_CONSTEXPR(nDim == 3) {
      MFloat ut2 = m_solver->a_pvariable(cellId, PV->VV[dimT2]);
      MFloat ut2_target = F0;
      L[3] = K[3] * (ut2 - ut2_target) + T[3] + V[3];
    }

    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);
    for(MInt s = 0; s < m_solver->m_noSpecies; s++)
      m_solver->a_rightHandSide(cellId, CV->RHO_Y[s]) = F0;
  }
}


/**
 * \fn FvBndryCndXD::cbc2091b()
 * Subsonic fully reflecting characteristic inflow condition - cut off \n
 * T0,u,v is prescribed, incl. transverse terms
 * \fvcbc{FvBndryCndXD::cbc2091b(), fvcbc2091b, CBC 2091B}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc2091b(MInt bcId) {
  TRACE();

  IF_CONSTEXPR(nDim == 3) { TERMM(-1, "INFO: function cbc2091a is untested for 3D!"); }

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  MBool solverProfile = Context::getSolverProperty<MBool>("solverProfile", m_solverId, AT_, &solverProfile);
  MFloat time = m_solver->m_time;
  MFloat St = m_solver->m_flameStrouhal;
  MFloat ampl = m_solver->m_forcingAmplitude;

  MFloat inflowArea = m_cbcInflowArea[cbcId];
  // MFloat H = m_cbcInflowArea[cbcId] * F1B2;

  MInt last = nDim + 1;

  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");

  MFloat mach[2] = {F0, F0};
  cbcMachCo(bcId, mach);
  MFloat maxM = mach[1];

  MFloat massflux = F0;
  MFloat uInt = F0;
  MFloat testSum2 = F0;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    MInt bndryId = m_solver->a_bndryId(cellId);

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MFloat area = F0;
    if(bndryId > -1) {
      // identify the "boundary surface" between cutoff boundary cell and neighboring layer cell if cell is a boundary
      // cell
      MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dirN];
      if(srfcId > -1)
        area = m_solver->a_surfaceArea(srfcId);
      else
        mTerm(1, AT_, "something went wrong!");
    } else {
      area = m_solver->c_cellLengthAtCell(cellId);
    }

    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    const MFloat un = m_solver->a_pvariable(cellId, PV->VV[dimN]);
    const MFloat y = (m_solver->a_coordinate(cellId, dimT1) - m_cbcReferencePoint[cbcId][dimT1]);
    testSum2 += area * y * y;
    massflux += un * rho * area;
    uInt += un * area;
  }

  MInt noExchangeData = 2;
  MFloatScratchSpace comm_buff(noExchangeData, AT_, "comm_buff");
  MFloatScratchSpace comm_buff_result(noExchangeData, AT_, "comm_buff_result");
  comm_buff[0] = massflux;
  comm_buff[1] = testSum2;

  if(noDomains() > 1) {
    MPI_Allreduce(&comm_buff[0], &comm_buff_result[0], 3, MPI_DOUBLE, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]],
                  AT_, "comm_buff[0]", "comm_buff_result[0]");
    MPI_Allreduce(MPI_IN_PLACE, &uInt, 1, MPI_DOUBLE, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                  "MPI_IN_PLACE", "uInt");
  }

  massflux = comm_buff_result[0];
  testSum2 = comm_buff_result[1];
  MFloat massflux_test = uInt / m_solver->m_analyticIntegralVelocity;

  MFloat un_correctionFactor = F1;
  if(fabs(massflux_test) > m_solver->m_eps) un_correctionFactor = F1 / massflux_test;

  const MFloat massflux_target = massflux * un_correctionFactor;
  const MFloat gammaMinusOne = m_solver->m_gamma - 1.0;

  MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");
  MFloatScratchSpace gradTau(m_cbcViscous ? (nDim * nDim * nDim) : 1, AT_, "gradTau");
  MFloatScratchSpace gradQ(m_cbcViscous ? (nDim * nDim) : 1, AT_, "gradQ");

  MIntScratchSpace cutOffStencilCellIds(m_cbcViscous ? m_solver->a_noCells() : 1, AT_, "cutOffStencilCellIds");
  if(m_cbcViscous) cbcTauQ(bcId, &tau[0], &q[0], &cutOffStencilCellIds[0]);

  MFloat T_target = sysEqn().temperature_IR(m_solver->m_Ma);

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);
    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    V.fill(F0);
    if(m_cbcViscous) {
      cbcGradientsViscous(cellId, bcId, &tau[0], &q[0], &gradTau[0], &gradQ[0], &cutOffStencilCellIds[0]);
      gradTau[dimN * IPOW2(nDim) + dimT1 * nDim + dimN] = F0;
      IF_CONSTEXPR(nDim == 3) { gradTau[dimN * IPOW2(nDim) + dimT2 * nDim + dimN] = F0; }
      V.fill(F0);
      cbcViscousTerms<(unsigned char)01111>(cellId, bcId, &tau[0], &gradTau[0], &gradQ[0], &gradVV[0],
                                            &cutOffStencilCellIds[0], &V[0]);
    }

    cbcOutgoingAmplitudeVariation<1>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
    cbcTransversalTerms<(unsigned char)11111>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &T[0]);
    cbcDampingInflow(cellId, bcId, maxM, &K[0], "velocity");

    MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    MFloat ut1 = m_solver->a_pvariable(cellId, PV->VV[dimT1]);
    MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat a = sysEqn().speedOfSound(rho, p);

    MFloat xPlus = (m_solver->a_coordinate(cellId, 0) + m_radiusVelFlameTube);
    xPlus *= m_shearLayerStrength;
    MFloat xNegative = m_solver->a_coordinate(cellId, 0) - m_radiusVelFlameTube;
    xNegative *= m_shearLayerStrength;

    MFloat un_target = m_solver->m_VInfinity
                       * (F1B2 * (F1 + tanh(xPlus)) * (F1 - tanh(xNegative))
                          - F1); // F3B4 * massflux/H*(1-y*y/(H*H))*un_correctionFactor;

    // F3B4 * massflux_target/rho/H*(1-y*y/(H*H))*un_correctionFactor;
    if(solverProfile) un_target = massflux_target / inflowArea / rho;

    MFloat ceta = F1;
    if(dirN % 2 == 0) // inflow on pos. coordinate direction
      ceta = -F1;
    else // inflow on neg. coordinate direction
      ceta = F1;

    MFloat dundt = F0;
    if(m_solver->m_forcing) {
      dundt = un_target;
      dundt *= St * ampl * cos(St * time);
      un_target *= (F1 + ampl * sin(St * time));
    }
    MFloat ut1_target = F0;

    if(dirN % 2 == 0) { // inflow on pos. coordinate direction (right) -> un < 0
      L[0] = L[last] + (T[last] + ceta * rho * a * T[1]) - ceta * F2 * rho * a * dundt;
    } else { // inflow on neg. coordinate direction (left) -> un > 0
      L[last] = L[0] + (T[last] + ceta * rho * a * T[1]) - ceta * F2 * rho * a * dundt;
    }
    L[1] = F1B2 * gammaMinusOne * (L[0] + L[last]) + (a * a * T[0] - T[last]);

    MFloat d1 = F1 / (a * a) * (L[1] + F1B2 * (L[last] + L[0]));

    MFloat dut1dt1 = m_solver->a_slope(cellId, PV->VV[dimT1], dimT1);
    MFloat drhodt1 = m_solver->a_slope(cellId, PV->RHO, dimT1);

    MFloat rhs_rho = -d1 - rho * (dut1dt1)-ut1 * drhodt1;

    m_solver->a_rightHandSide(cellId, CV->RHO) = -m_solver->a_cellVolume(cellId) * rhs_rho;
    for(MInt s = 0; s < m_solver->m_noSpecies; s++)
      m_solver->a_rightHandSide(cellId, CV->RHO_Y[s]) -=
          m_solver->a_cellVolume(cellId) * rhs_rho * m_solver->a_pvariable(cellId, PV->Y[s]);
    m_solver->a_rightHandSide(cellId, CV->RHO_VV[dimN]) = F0;
    m_solver->a_rightHandSide(cellId, CV->RHO_VV[dimT1]) = F0;
    m_solver->a_rightHandSide(cellId, CV->RHO_E) = F0;

    for(MInt s = 0; s < m_solver->m_noSpecies; s++)
      m_solver->a_pvariable(cellId, PV->Y[s]) = 0;

    m_solver->a_pvariable(cellId, PV->VV[dimN]) = un_target;
    m_solver->a_pvariable(cellId, PV->VV[dimT1]) = ut1_target;
    m_solver->a_pvariable(cellId, PV->P) = T_target;
  }
}


/** \brief Subsonic fully reflecting characteristic inflow condition - cut off - sets T0,u,v to prescribed value after
 * rkstep
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc2091b_after(MInt bcId) {
  IF_CONSTEXPR(nDim == 3) { TERMM(-1, "INFO: function cbc2091b_after is untested for 3D!"); }
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) return;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);

    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    // recompute the correct energy:
    MFloat rho = m_solver->a_variable(cellId, CV->RHO);
    MFloat u = m_solver->a_pvariable(cellId, PV->VV[0]);
    MFloat v = m_solver->a_pvariable(cellId, PV->VV[1]);
    MFloat T = m_solver->a_pvariable(cellId, PV->P);
    MFloat p = sysEqn().pressure_ES(T, rho);
    MFloat E = sysEqn().internalEnergy(p, rho, (u * u + v * v));

    m_solver->a_variable(cellId, CV->RHO_VV[0]) = rho * u;
    m_solver->a_variable(cellId, CV->RHO_VV[1]) = rho * v;
    m_solver->a_variable(cellId, CV->RHO_E) = E;
    for(MInt s = 0; s < m_solver->m_noSpecies; s++)
      m_solver->a_variable(cellId, CV->RHO_Y[s]) = rho * m_solver->a_pvariable(cellId, PV->Y[s]);
  }
}
/**
 * \fn FvBndryCndXD::cbc2091d()
 * Subsonic partially reflecting characteristic inflow condition - cut off \n
 * p0,T0,v is prescribed, incl. shear and transverse terms, profile of un is prescribed
 * \fvcbc{FvBndryCndXD::cbc2091d(), fvcbc2091d, CBC 2091D}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc2091d(MInt bcId) {
  IF_CONSTEXPR(nDim == 3) { TERMM(-1, "INFO: function cbc2091a is untested for 3D!"); }
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  MFloat inflowArea = m_cbcInflowArea[cbcId];
  // MFloat H = m_cbcInflowArea[cbcId] * F1B2;

  MInt last = nDim + 1;

  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");

  MFloat mach[2] = {F0, F0};
  cbcMachCo(bcId, mach);
  MFloat maxM = mach[1];

  MFloat massflux = F0;
  MFloat uInt = F0;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    MInt bndryId = m_solver->a_bndryId(cellId);
    MInt nghbrN = m_solver->c_neighborId(cellId, dirN);

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MFloat area = F0;
    if(bndryId > -1) {
      // identify the "boundary surface" between cutoff boundary cell and neighboring layer cell if cell is a boundary
      // cell
      MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dirN];
      if(srfcId > -1)
        area = m_solver->a_surfaceArea(srfcId);
      else
        mTerm(1, AT_, "something went wrong!");
    } else {
      area = m_solver->c_cellLengthAtCell(cellId);
    }

    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    const MFloat un_N = m_solver->a_pvariable(nghbrN, PV->VV[dimN]);
    massflux += un_N * rho * area;
    uInt += un_N * area;
  }

  MInt noExchangeData = 2;
  MFloatScratchSpace comm_buff(noExchangeData, AT_, "comm_buff");
  MFloatScratchSpace comm_buff_result(noExchangeData, AT_, "comm_buff_result");
  comm_buff[0] = massflux;
  comm_buff[1] = uInt;

  if(noDomains() > 1) {
    MPI_Allreduce(&comm_buff[0], &comm_buff_result[0], 3, MPI_DOUBLE, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]],
                  AT_, "comm_buff[0]", "comm_buff_result[0]");
    MPI_Allreduce(MPI_IN_PLACE, &uInt, 1, MPI_DOUBLE, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                  "MPI_IN_PLACE", "uInt");
  }

  massflux = comm_buff_result[0];
  MFloat massflux_test = uInt / m_solver->m_analyticIntegralVelocity;

  MFloat un_correctionFactor = F1;
  if(fabs(massflux_test) > m_solver->m_eps) un_correctionFactor = F1 / massflux_test;

  massflux = massflux * un_correctionFactor;

  const MFloat gammaMinusOne = m_solver->m_gamma - 1.0;

  MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");
  MFloatScratchSpace gradTau(m_cbcViscous ? (nDim * nDim * nDim) : 1, AT_, "gradTau");
  MFloatScratchSpace gradQ(m_cbcViscous ? (nDim * nDim) : 1, AT_, "gradQ");

  MIntScratchSpace cutOffStencilCellIds(m_cbcViscous ? m_solver->a_noCells() : 1, AT_, "cutOffStencilCellIds");
  if(m_cbcViscous) cbcTauQ(bcId, &tau[0], &q[0], &cutOffStencilCellIds[0]);

  MFloat T_target = 1 - gammaMinusOne * F1B2 * (massflux * massflux / inflowArea / inflowArea);
  MFloat p_Target = sysEqn().pressure_IR(T_target);
  p_Target += m_solver->m_rhoInfinity * POW2(m_solver->m_flameSpeed) * (m_solver->m_burntUnburntTemperatureRatio - F1);
  p_Target += m_solver->m_rhoFlameTube * m_solver->m_targetDensityFactor * POW2(m_solver->m_velocityOutlet)
              * m_solver->m_flameOutletAreaRatio;
  p_Target -= m_solver->m_rhoFlameTube * POW2(m_solver->m_VInfinity);

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);
    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    V.fill(F0);
    if(m_cbcViscous) {
      cbcGradientsViscous(cellId, bcId, &tau[0], &q[0], &gradTau[0], &gradQ[0], &cutOffStencilCellIds[0]);
      gradTau[dimN * IPOW2(nDim) + dimT1 * nDim + dimN] = F0;
      IF_CONSTEXPR(nDim == 3) { gradTau[dimN * IPOW2(nDim) + dimT2 * nDim + dimN] = F0; }
      V.fill(F0);
      cbcViscousTerms<(unsigned char)01111>(cellId, bcId, &tau[0], &gradTau[0], &gradQ[0], &gradVV[0],
                                            &cutOffStencilCellIds[0], &V[0]);
    }

    cbcOutgoingAmplitudeVariation<1>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
    cbcTransversalTerms<(unsigned char)11111>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &T[0]);
    cbcDampingInflow(cellId, bcId, maxM, &K[0], "pressure");

    MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    MFloat ut1 = m_solver->a_pvariable(cellId, PV->VV[dimT1]);

    MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat temp = sysEqn().temperature_ES(rho, p);
    MFloat a = sysEqn().speedOfSound(rho, p);

    MFloat xPlus = (m_solver->a_coordinate(cellId, 0) + m_radiusVelFlameTube);
    xPlus *= m_shearLayerStrength;
    MFloat xNegative = m_solver->a_coordinate(cellId, 0) - m_radiusVelFlameTube;
    xNegative *= m_shearLayerStrength;

    MFloat un_target = m_solver->m_VInfinity
                       * (F1B2 * (F1 + tanh(xPlus)) * (F1 - tanh(xNegative))
                          - F1); // F3B4 * massflux/H*(1-y*y/(H*H))*un_correctionFactor;

    MFloat ut1_target = F0;

    if(dirN % 2 == 0) {
      L[0] = K[0] * (p - p_Target) + (T[last] - rho * a * T[1]) + (V[last] - rho * a * V[1]);
    } else {
      L[last] = K[last] * (p - p_Target) + (T[last] + rho * a * T[1]) + (V[last] + rho * a * V[1]);
    }

    L[1] = K[1] * (temp - T_target) + (a * a * T[0] - T[last]) - V[last];
    L[2] = K[2] * (ut1 - ut1_target) + T[2] + V[2];

    IF_CONSTEXPR(nDim == 3) {
      MFloat ut2 = m_solver->a_pvariable(cellId, PV->VV[dimT2]);
      MFloat ut2_target = F0;
      L[3] = K[3] * (ut2 - ut2_target) + T[3] + V[3];
    }

    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);

    // temporary fix until species is included in cbcRHS()
    MFloat d1 = F1 / (a * a) * (L[1] + F1B2 * (L[last] + L[0]));
    MFloat rhs_rho = -d1 + T[0] + V[0];
    for(MInt s = 0; s < m_solver->m_noSpecies; s++)
      m_solver->a_rightHandSide(cellId, CV->RHO_Y[s]) -=
          m_solver->a_cellVolume(cellId) * rhs_rho * m_solver->a_pvariable(cellId, PV->Y[s]);
    for(MInt s = 0; s < m_solver->m_noSpecies; s++)
      m_solver->a_rightHandSide(cellId, CV->RHO_Y[s]) = F0;
    m_solver->a_pvariable(cellId, PV->VV[dimN]) = un_target;
  }
}
/** \brief Subsonic fully reflecting characteristic inflow condition - cut off - sets un to prescribed value after
 * rkstep
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc2091d_after(MInt bcId) {
  TRACE();

  IF_CONSTEXPR(nDim == 3) { TERMM(-1, "INFO: function cbc2091d_after is untested for 3D!"); }

  const MInt otherDir[4] = {1, 0, 3, 2};

  MBool& first = m_static_cbc2091d_after_first;
  MInt& dirN = m_static_cbc2091d_after_dirN;
  MInt& dimN = m_static_cbc2091d_after_dimN;
  MInt& dimT1 = m_static_cbc2091d_after_dimT1;
  if(first) {
    MInt noCutOffBndryIds = Context::propertyLength("cutOffBndryIds", m_solverId);
    MInt noCutOffDirections = Context::propertyLength("cutOffDirections", m_solverId);
    if(noCutOffDirections != noCutOffBndryIds)
      mTerm(1, AT_,
            "Wrong number of cut off directions. Must be identical to number of cut off bndryIds! Please check!");
    MInt cutOffBndryIdTmp, cutOffDirectionTmp;
    for(MInt i = 0; i < noCutOffBndryIds; i++) {
      cutOffBndryIdTmp = Context::getSolverProperty<MInt>("cutOffBndryIds", m_solverId, AT_, i);
      cutOffDirectionTmp = Context::getSolverProperty<MInt>("cutOffDirections", m_solverId, AT_, i);
      if(cutOffBndryIdTmp == m_cutOffBndryCndIds[bcId]) {
        dirN = otherDir[cutOffDirectionTmp];
        break;
      }
    }
    dimN = (MInt)dirN / 2;
    dimT1 = (dimN + 1) % nDim;

    first = false;
  }

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);

    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    // recompute the correct energy:
    MFloat rho = m_solver->a_variable(cellId, CV->RHO);
    MFloat u = m_solver->a_pvariable(cellId, PV->VV[dimN]);
    MFloat u_wrong = m_solver->a_variable(cellId, CV->RHO_VV[dimN]) / m_solver->a_variable(cellId, CV->RHO);
    MFloat v = m_solver->a_variable(cellId, CV->RHO_VV[dimT1]) / m_solver->a_variable(cellId, CV->RHO);
    MFloat p = sysEqn().pressure(rho, (u_wrong * u_wrong + v * v), m_solver->a_variable(cellId, CV->RHO_E));
    MFloat E = sysEqn().internalEnergy(p, rho, (u * u + v * v));

    m_solver->a_variable(cellId, CV->RHO_VV[dimN]) = rho * u;
    for(MInt s = 0; s < m_solver->m_noSpecies; s++)
      m_solver->a_variable(cellId, CV->RHO_Y[s]) = rho * m_solver->a_pvariable(cellId, PV->Y[s]);
    m_solver->a_variable(cellId, CV->RHO_E) = E;
  }
}

/**
 * \fn FvBndryCndXD::cbc2099_1091_local_comb
 * Subsonic partially reflecting characteristic outflow condition - cut off \n
 * turbulent combustion
 * \fvcbc{FvBndryCndXD::cbc2099_1091_local_comb(), fvcbc2099_1091_local_comb, CBC 2099 1091 Local Comb.}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc2099_1091_local_comb(MInt bcId) {
  IF_CONSTEXPR(nDim == 3) { TERMM(-1, "INFO: function cbc2099_1091_local_comb is untested for 3D!"); }
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  MFloat outFlowArea = m_cbcInflowArea[cbcId];

  MInt last = nDim + 1;

  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");

  MFloat massflux = F0;
  MFloat T_mean = F0;
  MFloat rho_mean = F0;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    MInt bndryId = m_solver->a_bndryId(cellId);

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MFloat area = F0;
    if(bndryId > -1) {
      // identify the "boundary surface" between cutoff boundary cell and neighboring layer cell if cell is a boundary
      // cell
      MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dirN];
      if(srfcId > -1)
        area = m_solver->a_surfaceArea(srfcId);
      else
        mTerm(1, AT_, "something went wrong!");
    } else {
      IF_CONSTEXPR(nDim == 2) { area = m_solver->c_cellLengthAtCell(cellId); }
      else {
        area = POW2(m_solver->c_cellLengthAtCell(cellId));
      }
    }

    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    const MFloat p = m_solver->a_pvariable(cellId, PV->P);
    const MFloat Temp = sysEqn().temperature_ES(rho, p);
    const MFloat un = m_solver->a_pvariable(cellId, PV->VV[dimN]);

    massflux += un * area * rho;
    T_mean += Temp * area;
    rho_mean += rho * area;
  }

  MFloat mach[2] = {F0, F0};
  cbcMachCo(bcId, mach);
  MFloat maxM = mach[1];

  MInt noExchangeData = 2;
  MFloatScratchSpace comm_buff(noExchangeData, AT_, "comm_buff");
  MFloatScratchSpace comm_buff_result(noExchangeData, AT_, "comm_buff_result");
  comm_buff[0] = massflux;
  comm_buff[2] = T_mean;

  if(noDomains() > 1) {
    MPI_Allreduce(&comm_buff[0], &comm_buff_result[0], 2, MPI_DOUBLE, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]],
                  AT_, "comm_buff[0]", "comm_buff_result[0]");
  }

  massflux = comm_buff_result[0];
  T_mean = comm_buff_result[1];
  T_mean /= outFlowArea;
  rho_mean /= outFlowArea;

  MFloat T_target = T_mean;
  MFloat p_Target = m_solver->m_PInfinity;

  m_solver->m_jetPressure = m_solver->m_PInfinity;
  m_solver->m_jetDensity = rho_mean;
  m_solver->m_jetTemperature = T_target;

  MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");
  MFloatScratchSpace gradTau(m_cbcViscous ? (nDim * nDim * nDim) : 1, AT_, "gradTau");
  MFloatScratchSpace gradQ(m_cbcViscous ? (nDim * nDim) : 1, AT_, "gradQ");

  MIntScratchSpace cutOffStencilCellIds(m_cbcViscous ? m_solver->a_noCells() : 1, AT_, "cutOffStencilCellIds");
  if(m_cbcViscous) cbcTauQ(bcId, &tau[0], &q[0], &cutOffStencilCellIds[0]);

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);

    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    V.fill(F0);
    if(m_cbcViscous) {
      cbcGradientsViscous(cellId, bcId, &tau[0], &q[0], &gradTau[0], &gradQ[0], &cutOffStencilCellIds[0]);
      gradTau[dimN * IPOW2(nDim) + dimT1 * nDim + dimN] = F0;
      IF_CONSTEXPR(nDim == 3) { gradTau[dimN * IPOW2(nDim) + dimT2 * nDim + dimN] = F0; }
      cbcViscousTerms<(unsigned char)01111>(cellId, bcId, &tau[0], &gradTau[0], &gradQ[0], &gradVV[0],
                                            &cutOffStencilCellIds[0], &V[0]);
    }

    cbcTransversalTerms<(unsigned char)11111>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &T[0]);

    // This is where you differentiate between inflow and outflow
    MFloat un_mean = m_solver->a_pvariable(cellId, PV->VV[dimN]);

    MBool isInflow = true;
    if(dirN % 2 == 0) {
      if(un_mean > F0) {
        isInflow = false;
      } else {
        //           T_target_new = T_mean;
      }
    } else {
      if(un_mean < F0) {
        isInflow = false;
      } else {
        //           T_target_new = T_mean;
      }
    }

    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    const MFloat p = m_solver->a_pvariable(cellId, PV->P);
    const MFloat Temp = sysEqn().temperature_ES(rho, p);
    const MFloat a = sysEqn().speedOfSound(Temp);


    if(isInflow) {
      cbcOutgoingAmplitudeVariation<1>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
      cbcDampingInflow(cellId, bcId, maxM, &K[0], "pressure");

      MFloat ceta = F1;
      if(dirN % 2 == 0)
        ceta = -F1;
      else
        ceta = F1;

      K[0] = K[0] / a * m_sigmaNonRefl;
      K[last] = K[0];
      MFloat beta = F0;

      if(dirN % 2 == 0) {
        L[0] =
            K[0] * (p - p_Target) + (beta - 1) * (T[last] + ceta * rho * a * T[1]) + (V[last] + ceta * rho * a * V[1]);
      } else {
        L[last] = K[last] * (p - p_Target) + (beta - 1) * (T[last] + ceta * rho * a * T[1])
                  + (V[last] + ceta * rho * a * V[1]);
      }

    } else {
      cbcOutgoingAmplitudeVariation<0>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
      cbcDampingOutflow(cellId, bcId, maxM, &K[0]);

      K[0] = K[0] * m_sigmaNonRefl;
      K[last] = K[0];

      MFloat deltaP = (p - p_Target);

      if(dirN % 2 == 0) { // outflow on pos. coordinate direction -> L1 has to be modeled
        L[0] = K[0] * deltaP;
      } else {
        L[last] = K[last] * deltaP;
      }
    }
    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);
  }
}


/** \brief Cut off condition for the slopes copys the slopes,
 *         and sets pressure slope to sero NOTIMPLEMENTED
 * version: cut-off boundary condition
 * author: Thomas Schilden, 12.2.2015
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::sbc2720co(MInt bcId) {
  TRACE();
  MInt direction = m_cutOffBndryCndIds[bcId] - 2720;

  if(direction % 2) {
    direction--;
  } else {
    direction++;
  }

  const MInt noPVars = PV->noVariables;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    MLong nghbrId = m_solver->c_neighborId(cellId, direction);

    if(nghbrId < 0) {
      continue;
    }
    if(m_solver->c_noChildren(nghbrId) > 0) {
      MFloat coCoord = m_solver->a_coordinate(cellId, direction / 2);
      MInt childCnt = 0;
      // reset cut off cell
      for(MInt varId = 0; varId < noPVars; varId++) {
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_slope(cellId, varId, i) = F0;
        }
      }
      for(MInt child = 0; child < IPOW2(nDim); child++) {
        MInt childId = m_solver->c_childId(nghbrId, child);
        if(childId < 0) {
          continue;
        }
        if(abs(m_solver->a_coordinate(childId, direction / 2) - coCoord) > m_solver->c_cellLengthAtCell(cellId)) {
          continue;
        }
        childCnt++;
        for(MInt varId = 0; varId < noPVars; varId++) {
          for(MInt i = 0; i < nDim; i++) {
            m_solver->a_slope(cellId, varId, i) += m_solver->a_slope(childId, varId, i);
          }
        }
      }
      for(MInt varId = 0; varId < noPVars; varId++) {
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_slope(cellId, varId, i) /= childCnt;
        }
      }
    } else {
      // copy the slopes
      for(MInt varId = 0; varId < noPVars; varId++) {
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_slope(cellId, varId, i) = m_solver->a_slope(nghbrId, varId, i);
        }
      }
    }
  }
}

/** \brief Solid wall Navier-Stokes boundary condition
 *        Computes ghost cell slopes for the viscous flux computation
 *        Set of variables: primitive (u,v,rho,p,Z)
 *
 * \author Daniel Hartmann, 12.01.2007
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::sbc2801x(MInt bcId) {
  IF_CONSTEXPR(nDim == 3) { TERMM(-1, "INFO: function sbc2801x is untested for 3D!"); }
  TRACE();

  MInt bndryId, cellId, ghostCellId;
  MFloat Frho, FrhoGhost, rhoU2;
  const MInt noPVars = PV->noVariables;
  ScratchSpace<MFloat> PVbndry(noPVars, AT_, "PVbndry");
  ScratchSpace<MFloat> PVghost(noPVars, AT_, "PVghost");
  //---

  Frho = FrhoGhost = rhoU2 = 0.0;

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    bndryId = m_sortedBndryCells->a[id];
    cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;

      for(MInt i = 0; i < nDim; i++) {
        PVbndry[i] = m_solver->a_variable(cellId, CV->RHO_VV[i]) * Frho;
        PVghost[i] = m_solver->a_variable(ghostCellId, CV->RHO_VV[i]) * FrhoGhost;
      }

      // density
      PVbndry[PV->RHO] = m_solver->a_variable(cellId, CV->RHO);
      PVghost[PV->RHO] = m_solver->a_variable(ghostCellId, CV->RHO);

      // pressure
      rhoU2 = F0;
      for(MInt i = 0; i < nDim; i++) {
        rhoU2 += POW2(m_solver->a_variable(cellId, CV->RHO_VV[i]));
      }

      PVbndry[PV->P] = sysEqn().pressure(Frho, rhoU2, m_solver->a_variable(cellId, CV->RHO_E));
      rhoU2 = F0;
      for(MInt i = 0; i < nDim; i++) {
        rhoU2 += POW2(m_solver->a_variable(ghostCellId, CV->RHO_VV[i]));
      }
      PVbndry[PV->P] = sysEqn().pressure(FrhoGhost, rhoU2, m_solver->a_variable(ghostCellId, CV->RHO_E));

      // species
      for(MInt k = 0; k < m_noSpecies; k++) {
        PVbndry[PV->Y[k]] = m_solver->a_variable(cellId, CV->RHO_Y[k]) * Frho;
        PVghost[PV->Y[k]] = m_solver->a_variable(ghostCellId, CV->RHO_Y[k]) * FrhoGhost;
      }

      for(MInt var = 0; var < noPVars; var++) {
        m_solver->a_slope(ghostCellId, var, 0) =
            (PVbndry[var] - PVghost[var])
            / (m_solver->a_coordinate(cellId, 0) - m_solver->a_coordinate(ghostCellId, 0));
        m_solver->a_slope(ghostCellId, var, 1) = m_solver->a_slope(cellId, var, 1);
      }

      // compute the slopes on the ghost cell
      for(MInt varId = 0; varId < noPVars; varId++) {
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_slope(ghostCellId, varId, i) =
              F2 * m_solver->a_slope(ghostCellId, varId, i) - m_solver->a_slope(cellId, varId, i);
        }
      }
    }
  }
}
/** \brief Solid wall Navier-Stokes boundary condition
 *        Computes ghost cell slopes for the viscous flux computation
 *        Set of variables: primitive (u,v,rho,p,Z)
 *
 * \author Daniel Hartmann, 12.01.2007
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::sbc2801y(MInt bcId) {
  IF_CONSTEXPR(!hasE<SysEqn>) {
    mTerm(1, AT_, "Not compatible with SysEqn without RHO_E!");
    return;
  }
  IF_CONSTEXPR(nDim == 3) { TERMM(-1, "INFO: function sbc2801x is untested for 3D!"); }
  TRACE();

  MInt bndryId, cellId, ghostCellId;
  MFloat Frho, FrhoGhost, rhoU2;
  const MInt noPVars = PV->noVariables;
  ScratchSpace<MFloat> PVbndry(noPVars, AT_, "PVbndry");
  ScratchSpace<MFloat> PVghost(noPVars, AT_, "PVghost");
  //---

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    bndryId = m_sortedBndryCells->a[id];
    cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;

      // determine the primitive variables on the boundary and on the ghost cell
      Frho = F1 / m_solver->a_variable(cellId, CV->RHO);
      FrhoGhost = F1 / m_solver->a_variable(ghostCellId, CV->RHO);
      // velocitites
      for(MInt i = 0; i < nDim; i++) {
        PVbndry[i] = m_solver->a_variable(cellId, CV->RHO_VV[i]) * Frho;
        PVghost[i] = m_solver->a_variable(ghostCellId, CV->RHO_VV[i]) * FrhoGhost;
      }

      // density
      PVbndry[PV->RHO] = m_solver->a_variable(cellId, CV->RHO);
      PVghost[PV->RHO] = m_solver->a_variable(ghostCellId, CV->RHO);

      // pressure
      rhoU2 = F0;
      for(MInt i = 0; i < nDim; i++) {
        rhoU2 += POW2(m_solver->a_variable(cellId, CV->RHO_VV[i]));
      }
      rhoU2 *= Frho;
      PVbndry[PV->P] = sysEqn().pressure(1.0, rhoU2, m_solver->a_variable(cellId, CV->RHO_E));
      rhoU2 = F0;
      for(MInt i = 0; i < nDim; i++) {
        rhoU2 += POW2(m_solver->a_variable(ghostCellId, CV->RHO_VV[i]));
      }
      rhoU2 *= FrhoGhost;
      PVghost[PV->P] = sysEqn().pressure(1.0, rhoU2, m_solver->a_variable(ghostCellId, CV->RHO_E));

      // species
      for(MInt k = 0; k < m_noSpecies; k++) {
        PVbndry[PV->Y[k]] = m_solver->a_variable(cellId, CV->RHO_Y[k]) * Frho;
        PVghost[PV->Y[k]] = m_solver->a_variable(ghostCellId, CV->RHO_Y[k]) * FrhoGhost;
      }

      for(MInt var = 0; var < noPVars; var++) {
        m_solver->a_slope(ghostCellId, var, 0) = m_solver->a_slope(cellId, var, 0);
        m_solver->a_slope(ghostCellId, var, 1) =
            (PVbndry[var] - PVghost[var])
            / (m_solver->a_coordinate(cellId, 1) - m_solver->a_coordinate(ghostCellId, 1));
      }

      // compute the slopes on the ghost cell
      for(MInt varId = 0; varId < noPVars; varId++) {
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_slope(ghostCellId, varId, i) =
              F2 * m_solver->a_slope(ghostCellId, varId, i) - m_solver->a_slope(cellId, varId, i);
        }
      }
    }
  }
}

/**
 * \fn FvBndryCndXD::cbc3091a()
 * Subsonic partially reflecting characteristic turbulent inflow condition - cut off \n
 * p0,T0,v is prescribed, incl. shear and transverse terms
 * \fvcbc{FvBndryCndXD::cbc3091a(), fvcbc3091a, CBC 3091A}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc3091a(MInt bcId) {
  IF_CONSTEXPR(nDim == 2) { TERMM(-1, "INFO: function cbc3091a is untested for 2D!"); }
  TRACE();

  MFloat dummyTime;
  MFloat that, twopioverlb;
  MFloat factor1, factor2, b1, b2;
  MInt ghost1;
  MFloat xhat, yhat, zhat;
  MFloat fluctChol[3];
  MFloat velocity = F0;
  b1 = m_shearLayerThickness;
  b2 = m_shearLayerThickness;
  MFloat massfluxTest = F0, jetInflowArea = F0;

  if(((globalTimeStep - m_solver->m_restartTimeStep) <= 1 || globalTimeStep == 0) && !m_solver->m_restart) {
    m_log << "computing mass flux " << endl;

    for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
      ghost1 = m_sortedCutOffCells[bcId]->a[id];
      if(m_solver->a_isHalo(ghost1)) continue;

      MFloat jetArea = POW2(m_solver->grid().cellLengthAtCell(ghost1));
      factor1 = m_solver->a_coordinate(ghost1, 0);
      factor2 = m_solver->a_coordinate(ghost1, 2);

      velocity = m_solver->m_Ma
                 * (F1B2 * (1 + tanh(b1 * (factor1 + m_solver->m_jetHalfWidth)))
                        * (1 - tanh(b1 * (factor1 - m_solver->m_jetHalfWidth)))
                    - 1)
                 * (F1B2 * (1 + tanh(b2 * (factor2 + m_solver->m_jetHalfLength)))
                        * (1 - tanh(b2 * (factor2 - m_solver->m_jetHalfLength)))
                    - 1);
      massfluxTest += m_solver->a_variable(ghost1, PV->RHO) * velocity * jetArea;
      jetInflowArea += jetArea;
    }

    MPI_Allreduce(MPI_IN_PLACE, &massfluxTest, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "massfluxTest");
    MPI_Allreduce(MPI_IN_PLACE, &jetInflowArea, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "jetInflowArea");

    // compute static pressure and density iteratively (see e.g. thesis of Ingolf Hoerschler)
    // compute massflux per unit area
    massfluxTest /= jetInflowArea;

    m_solver->m_jetPressure = m_solver->m_PInfinity;
    m_solver->m_jetDensity = m_solver->m_rhoInfinity;
    m_solver->m_jetTemperature = sysEqn().temperature_ES(m_solver->m_jetDensity, m_solver->m_jetPressure);
    m_log << "calculated pressure" << m_solver->m_jetPressure << endl;
    m_log << "calculated density" << m_solver->m_jetDensity << endl;
    m_log << "calculated temperature at inflow " << m_solver->m_jetTemperature << endl;
    m_log << "calculated massflux" << massfluxTest << endl;
  }

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  dummyTime = m_solver->m_time / m_bc1601->m_tau_b;

  m_bc1601->checkRegeneration(dummyTime);

  that = 2.0 * PI * dummyTime;
  twopioverlb = 2.0 * PI / m_bc1601->m_l_b;


  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  MBool solverProfile = Context::getSolverProperty<MBool>("solverProfile", m_solverId, AT_, &solverProfile);
  MFloat inflowArea = m_cbcInflowArea[cbcId];
  // MFloat R = sqrt(inflowArea / PI);

  MInt last = nDim + 1;

  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");

  MFloat mach[2] = {F0, F0};
  cbcMachCo(bcId, mach);
  MFloat maxM = mach[1];

  MFloat massflux = F0;
  MFloat testSum2 = F0;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    MInt bndryId = m_solver->a_bndryId(cellId);

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MFloat area = F0;
    if(bndryId > -1) {
      // identify the "boundary surface" between cutoff boundary cell and neighboring layer cell if cell is a boundary
      // cell
      MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dirN];
      if(srfcId > -1)
        area = m_solver->a_surfaceArea(srfcId);
      else
        mTerm(1, AT_, "something went wrong!");
    } else {
      area = m_solver->c_cellLengthAtCell(cellId);
    }

    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    const MFloat un = m_solver->a_pvariable(cellId, PV->VV[dimN]);
    const MFloat y = (m_solver->a_coordinate(cellId, dimT1) - m_cbcReferencePoint[cbcId][dimT1]);
    testSum2 += area * y * y;
    massflux += un * rho * area;
  }

  MInt noExchangeData = 2;
  MFloatScratchSpace comm_buff(noExchangeData, AT_, "comm_buff");
  MFloatScratchSpace comm_buff_result(noExchangeData, AT_, "comm_buff_result");
  comm_buff[0] = massflux;
  comm_buff[1] = testSum2;

  if(noDomains() > 1) {
    MPI_Allreduce(&comm_buff[0], &comm_buff_result[0], 3, MPI_DOUBLE, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]],
                  AT_, "comm_buff[0]", "comm_buff_result[0]");
  }

  massflux = comm_buff_result[0];
  testSum2 = comm_buff_result[1];

  const MFloat TInfinity = m_solver->m_TInfinity;
  const MFloat PInfinity = m_solver->m_PInfinity;

  MFloat ut1_target = F0;
  const MFloat massflux_target = m_solver->m_VInfinity * inflowArea * sysEqn().density_ES(PInfinity, TInfinity);
  MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");
  MFloatScratchSpace gradTau(m_cbcViscous ? (nDim * nDim * nDim) : 1, AT_, "gradTau");
  MFloatScratchSpace gradQ(m_cbcViscous ? (nDim * nDim) : 1, AT_, "gradQ");

  MIntScratchSpace cutOffStencilCellIds(m_cbcViscous ? m_solver->a_noCells() : 1, AT_, "cutOffStencilCellIds");
  if(m_cbcViscous) cbcTauQ(bcId, &tau[0], &q[0], &cutOffStencilCellIds[0]);

  MFloat T_target = sysEqn().temperature_IR(m_solver->m_Ma);

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);
    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    V.fill(F0);
    if(m_cbcViscous) {
      cbcGradientsViscous(cellId, bcId, &tau[0], &q[0], &gradTau[0], &gradQ[0], &cutOffStencilCellIds[0]);
      gradTau[dimN * IPOW2(nDim) + dimT1 * nDim + dimN] = F0;
      IF_CONSTEXPR(nDim == 3) { gradTau[dimN * IPOW2(nDim) + dimT2 * nDim + dimN] = F0; }
      cbcViscousTerms<(unsigned char)01111>(cellId, bcId, &tau[0], &gradTau[0], &gradQ[0], &gradVV[0],
                                            &cutOffStencilCellIds[0], &V[0]);
    }

    cbcOutgoingAmplitudeVariation<1>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
    cbcTransversalTerms<(unsigned char)11111>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &T[0]);
    cbcDampingInflow(cellId, bcId, maxM, &K[0], "velocity");

    MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    MFloat un = m_solver->a_pvariable(cellId, PV->VV[dimN]);
    MFloat ut1 = m_solver->a_pvariable(cellId, PV->VV[dimT1]);
    MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat temp = sysEqn().temperature_ES(rho, p);
    MFloat a = sysEqn().speedOfSound(rho, p);

    factor1 = m_solver->a_coordinate(cellId, dimT1);
    IF_CONSTEXPR(nDim == 3) { factor2 = m_solver->a_coordinate(cellId, dimT2); }

    xhat = twopioverlb * m_solver->a_coordinate(cellId, dimN);
    yhat = twopioverlb * m_solver->a_coordinate(cellId, dimT1);
    IF_CONSTEXPR(nDim == 2) { zhat = F0; }
    IF_CONSTEXPR(nDim == 3) { zhat = twopioverlb * m_solver->a_coordinate(cellId, dimT2); }
    fluctChol[dimN] = 0;
    fluctChol[dimT1] = 0;
    fluctChol[dimT2] = 0;

    m_bc1601->calculateFlucts(that, xhat, yhat, zhat, fluctChol);

    fluctChol[dimT1] *= (F1B2 * (1 + tanh(b1 * (factor1 + m_solver->m_jetHalfWidth)))
                             * (1 - tanh(b1 * (factor1 - m_solver->m_jetHalfWidth)))
                         - 1);
    fluctChol[dimT1] *= (F1B2 * (1 + tanh(b2 * (factor2 + m_solver->m_jetHalfLength)))
                             * (1 - tanh(b2 * (factor2 - m_solver->m_jetHalfLength)))
                         - 1);
    IF_CONSTEXPR(nDim == 3) {
      fluctChol[dimT2] *= (F1B2 * (1 + tanh(b1 * (factor1 + m_solver->m_jetHalfWidth)))
                               * (1 - tanh(b1 * (factor1 - m_solver->m_jetHalfWidth)))
                           - 1);
      fluctChol[dimT2] *= (F1B2 * (1 + tanh(b2 * (factor2 + m_solver->m_jetHalfLength)))
                               * (1 - tanh(b2 * (factor2 - m_solver->m_jetHalfLength)))
                           - 1);
    }

    ut1_target = fluctChol[dimT1];
    MFloat un_target = (velocity + fluctChol[1])
                       * (F1B2 * (1 + tanh(b1 * (factor1 + m_solver->m_jetHalfWidth)))
                              * (1 - tanh(b1 * (factor1 - m_solver->m_jetHalfWidth)))
                          - 1)
                       * (F1B2 * (1 + tanh(b2 * (factor2 + m_solver->m_jetHalfLength)))
                              * (1 - tanh(b2 * (factor2 - m_solver->m_jetHalfLength)))
                          - 1);
    // F2*massflux_target/inflowArea*(F1-rsquare/(R*R))/rho*un_correctionFactor;

    if(solverProfile) un_target = massflux_target / inflowArea / rho;

    if(dirN % 2 == 0) {
      L[0] = -F1 * K[0] * (un - un_target) + (T[last] - rho * a * T[1]) + (V[last] - rho * a * V[1]);
    } else {
      L[last] = K[last] * (un - un_target) + (T[last] + rho * a * T[1]) + (V[last] + rho * a * V[1]);
    }

    L[1] = K[1] * (temp - T_target) + (a * a * T[0] - T[last]) - V[last];
    L[2] = K[2] * (ut1 - ut1_target) + T[2] + V[2];
    IF_CONSTEXPR(nDim == 3) {
      MFloat ut2 = m_solver->a_pvariable(cellId, PV->VV[dimT2]);
      MFloat ut2_target = fluctChol[dimT2];
      L[3] = K[3] * (ut2 - ut2_target) + T[3] + V[3];
    }

    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);
    for(MInt s = 0; s < m_solver->m_noSpecies; s++)
      m_solver->a_rightHandSide(cellId, CV->RHO_Y[s]) = F0;
  }
}

/**
 * \fn FvBndryCndXD::bc1091MGC()
 * Subsonic laminar tube inflow boundary condition normal to the boundary - multiple ghost cells \n \n
 * Set of variables: Standard PV \n
 * prescribes a constant stagnation pressure \n
 * density and pressure are computed according to massflux \n
 * velocity is computed according to massflux such that a parabolic profile is attained \n
 * only valid for circular tubes \n \n
 * special formulation for complex boundaries with multiple ghost cells \n
 * works also for surface ghost cells (m_surfaceGhostCell = true) \n \n
 * no 2D version available \n \n
 * minimum number of time steps is prescribed for different testcases \n
 * which is required to obtain a massflux different from zero
 * \author Claudia Guenther
 * \date June 2009, modified Mai 2010
 * \fvbc{FvBndryCndXD::bc1091MGC(), fvbc1091MGC, BC 1091 MGC}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1091MGC(MInt bcId) {
  TRACE();
  IF_CONSTEXPR(nDim == 2) TERMM(1, "3D BC!");

  if(m_bndryCndCells[bcId] == m_bndryCndCells[bcId + 1]) {
    return;
  }

  MInt cellId, bndryId;
  MInt ghostCellId;
  MFloat R;
  MFloat massflux = F0;
  MFloat inflowArea = F0;
  MFloat meanPressure;
  MFloat localVelocity;
  MFloat meanDensity;
  MFloat referencePoint[3] = {0.0, 0.0, 0.0};
  MFloat normal[3] = {0.0, 0.0, 0.0};
  MFloat radius;
  MFloat meanVelocity;
  MFloat epsilon = 1e-15;
  MInt nghbrId;
  MInt minTimeSteps = m_static_bc1091MGC_minTimeSteps;
  MInt nghbrDir = m_static_bc1091MGC_nghbrDir;
  MFloatScratchSpace comm_buff_scratch(5, AT_, "comm_buff_scratch");
  MFloatScratchSpace comm_buff_result_scratch(5, AT_, "comm_buff_result_scratch");
  MFloat* comm_buff = comm_buff_scratch.getPointer();
  MFloat* comm_buff_result = comm_buff_result_scratch.getPointer();
  MInt noBndryCndCells = m_bndryCndCells[bcId + 1] - m_bndryCndCells[bcId];
  MIntScratchSpace edgeCells_scratch(noBndryCndCells, AT_, "edgeCells_scratch");
  MFloatScratchSpace edgeDistance_scratch(noBndryCndCells, AT_, "edgeDistance_scratch");
  MIntScratchSpace edgeSurface_scratch(noBndryCndCells, AT_, "edgeSurface_scratch");
  MInt edgeCellCounter = m_static_bc1091MGC_edgeCellCounter;
  MInt first = m_static_bc1091MGC_first;
  MInt first2 = m_static_bc1091MGC_first2;
  MFloat distCur;

  // --- end of initialization


  if(first2) {
    // claudia vorsicht: Alte Testcases aendern!
    // SUZI_TC: minTimeSteps = 550
    // NOZZLE_TC: minTimeSteps = 260
    // TINA_TC: minTimeSteps = 520
    // spongeLayerType 49: minTimeSteps = 800
    // spongeLayerType 50: minTimeSteps = 750
    // special treatment for engine test cases: massflux accepted soonest after minTimeSteps time steps
    minTimeSteps = Context::getSolverProperty<MInt>("InflowMinTimeSteps", m_solverId, AT_, &minTimeSteps);

    // SUZI_TC: nghbrDir = 0
    // ELBOW_TC: nghbrDir = 3
    // NOZZLE_TC: nghbrDir = 2
    // TINA_TC: nghbrDir = 1
    // else: nghbrDir = -1
    // special treatment: massflux is averaged over two layers
    nghbrDir = Context::getSolverProperty<MInt>("InflowNghbrDir", m_solverId, AT_, &nghbrDir);

    first2 = false;
  }
  m_static_bc1091MGC_first2 = first2;

  // compute current massflux, inflow area, reference Point and normal of the inflow area
  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    cellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_cellId;
    bndryId = m_solver->a_bndryId(cellId);
    if(m_solver->a_hasProperty(cellId,
                               SolverCell::IsNotGradient)) { // do not compute massflux of multisolver ghost cells!
      continue;
    }
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[m_sortedBndryCells->a[id]].m_noSrfcs; srfc++) {
        // search for surfaces which belong to the respective boundary condition
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == m_bndryCndIds[bcId]) {
          // compute massflux through the first cell layer
          massflux -= (((m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->U])
                            * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area
                            * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[0]
                        + (m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->V])
                              * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area
                              * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[1]
                        + (m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->W])
                              * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area
                              * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[2])
                       * (m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->RHO]));

          if(nghbrDir > -1) {
            // compute massflux through the next cell layer
            // validity of nghbrId has to be guaranteed by the user! (only for special testcases!)
            // only valid if normal is parallel a coordinate axis
            nghbrId = m_solver->c_neighborId(cellId, nghbrDir);
            massflux -= (((m_solver->a_pvariable(nghbrId, PV->U)) * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area
                              * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[0]
                          + (m_solver->a_pvariable(nghbrId, PV->V)) * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area
                                * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[1]
                          + (m_solver->a_pvariable(nghbrId, PV->W)) * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area
                                * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[2])
                         * (m_solver->a_pvariable(nghbrId, PV->RHO)));
          }
          inflowArea += m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;

          // compute midpoint of inflow boundary and mean normal
          for(MInt i = 0; i < 3; i++) {
            referencePoint[i] += m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i]
                                 * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
            normal[i] += m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i]
                         * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
          }
        }
      }
    }
  }

  comm_buff[0] = inflowArea;
  comm_buff[1] = referencePoint[0];
  comm_buff[2] = referencePoint[1];
  comm_buff[3] = referencePoint[2];
  comm_buff[4] = massflux;

  if(noDomains() > 1) {
    MPI_Allreduce(comm_buff, comm_buff_result, 5, MPI_DOUBLE, MPI_SUM, m_comm_bc[m_bc_comm_pointer[bcId]], AT_,
                  "comm_buff", "comm_buff_result");
  }

  inflowArea = comm_buff_result[0];
  referencePoint[0] = comm_buff_result[1];
  referencePoint[1] = comm_buff_result[2];
  referencePoint[2] = comm_buff_result[3];
  massflux = comm_buff_result[4];

  for(MInt i = 0; i < 3; i++) {
    referencePoint[i] /= inflowArea;
    normal[i] /= inflowArea;
  }

  // special treatment for nozzle testcase
  if(string2enum(m_solver->m_testCaseName) == NOZZLE_TC) {
    normal[0] = 0.0;
    normal[1] = -1.0;
    normal[2] = F0;
    referencePoint[0] = 0.0;
    referencePoint[2] = 0.0;
  }

  // compute massflux per unit area
  if(nghbrDir > -1) {
    massflux /= (2.0 * inflowArea);
  } else {
    massflux /= (inflowArea);
  }

  // correct massflux if necessary
  if(abs(massflux) < epsilon * inflowArea || globalTimeStep < minTimeSteps) {
    massflux = F0;
  }

  // compute static pressure and density iteratively (see e.g. thesis of Ingolf Hoerschler)
  meanPressure = sysEqn().p_Ref();
  for(MInt i = 0; i < 20; i++) {
    meanPressure = sysEqn().pressure_IRit(meanPressure, massflux);
  }
  meanPressure = meanPressure * sysEqn().p_Ref();
  meanDensity = sysEqn().density_IR_P(meanPressure);
  meanVelocity = massflux / meanDensity;

  R = sqrt(inflowArea / PI);

  // "brute force" computation of boundary distance for TINA engine - non-circular inflow...
  if(string2enum(m_solver->m_testCaseName) == TINA_TC && first) {
    for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
      cellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_cellId;
      bndryId = m_solver->a_bndryId(cellId);
      if(m_solver->a_hasProperty(cellId,
                                 SolverCell::IsNotGradient)) { // do not compute massflux of multisolver ghost cells!
        continue;
      }
      if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        if(m_bndryCells->a[bndryId].m_noSrfcs > 1) {
          for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
            if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId != m_bndryCndIds[bcId]) {
              edgeCells_scratch[edgeCellCounter] = bndryId;
              edgeSurface_scratch[edgeCellCounter] = srfc;
              edgeCellCounter++;
            }
          }
        }
      }
    }
    for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
      cellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_cellId;
      bndryId = m_solver->a_bndryId(cellId);
      if(m_solver->a_hasProperty(cellId,
                                 SolverCell::IsNotGradient)) { // do not compute massflux of multisolver ghost cells!
        continue;
      }
      if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        for(MInt srfc = 0; srfc < m_bndryCells->a[m_sortedBndryCells->a[id]].m_noSrfcs; srfc++) {
          // search for surfaces which belong to the respective boundary condition
          if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == m_bndryCndIds[bcId]) {
            edgeDistance_scratch[id - m_bndryCndCells[bcId]] = F2 * R;
            for(MInt ec = 0; ec < edgeCellCounter; ec++) {
              distCur = F0;
              for(MInt d = 0; d < nDim; d++) {
                distCur +=
                    (m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[d]
                     - m_bndryCells->a[edgeCells_scratch[ec]].m_srfcs[srfc]->m_coordinates[d])
                    * (m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[d]
                       - m_bndryCells->a[edgeCells_scratch[ec]].m_srfcs[edgeSurface_scratch[ec]]->m_coordinates[d]);
              }
              distCur = sqrt(distCur);
              if(distCur < edgeDistance_scratch[id - m_bndryCndCells[bcId]]) {
                edgeDistance_scratch[id - m_bndryCndCells[bcId]] = distCur;
              }
            }
          }
        }
      }
    }
    first = false;
  }

  m_static_bc1091MGC_first = first;

  MFloat K = 1.0;

  if(string2enum(m_solver->m_testCaseName) == TINA_TC) {
    MFloat Vdot = F0;

    for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
      cellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_cellId;
      bndryId = m_solver->a_bndryId(cellId);
      if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        for(MInt srfc = 0; srfc < m_bndryCells->a[m_sortedBndryCells->a[id]].m_noSrfcs; srfc++) {
          // search for surfaces which belong to the respective boundary condition
          if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == m_bndryCndIds[bcId]) {
            // compute radius of the boundary surface and compute velocity according to parabolic profile
            radius = POW2(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[0] - referencePoint[0])
                     + POW2(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[1] - referencePoint[1])
                     + POW2(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[2] - referencePoint[2]);
            Vdot += m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area * 2.0 * meanVelocity
                    * (1.0 - radius / POW2(edgeDistance_scratch[id - m_bndryCndCells[bcId]] + sqrt(radius)));
          }
        }
      }
    }
    if(abs(meanVelocity) > epsilon * inflowArea && abs(Vdot / inflowArea) > epsilon * inflowArea) {
      K = meanVelocity / Vdot * inflowArea;
    }
  }


  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    cellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_cellId;
    bndryId = m_solver->a_bndryId(cellId);
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[m_sortedBndryCells->a[id]].m_noSrfcs; srfc++) {
        // search for surfaces which belong to the respective boundary condition
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == m_bndryCndIds[bcId]) {
          ghostCellId = m_bndryCells->a[m_sortedBndryCells->a[id]].m_srfcVariables[srfc]->m_ghostCellId;

          // compute radius of the boundary surface and compute velocity according to parabolic profile
          radius = POW2(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[0] - referencePoint[0])
                   + POW2(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[1] - referencePoint[1])
                   + POW2(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[2] - referencePoint[2]);
          localVelocity = 2.0 * meanVelocity * (1.0 - radius / POW2(R));
          if(string2enum(m_solver->m_testCaseName) == TINA_TC) {
            localVelocity = 2.0 * meanVelocity * K
                            * (1.0 - radius / POW2(edgeDistance_scratch[id - m_bndryCndCells[bcId]] + sqrt(radius)));
          }
          if((string2enum(m_solver->m_testCaseName) == NOZZLE_TC) && globalTimeStep >= minTimeSteps) {
            localVelocity = -((m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->U])
                                  * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[0]
                              + (m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->V])
                                    * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[1]
                              + (m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->W])
                                    * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[2])
                            * (m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->RHO]) / meanDensity;
          }

          // set ghost cell variables such that p, rho, v_i are attained on the boundary surface; v is assumed to be
          // normal to the surface
          m_solver->a_pvariable(ghostCellId, PV->RHO) =
              F2 * meanDensity - m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->RHO];
          m_solver->a_pvariable(ghostCellId, PV->P) =
              F2 * meanPressure - m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->P];
          m_solver->a_pvariable(ghostCellId, PV->U) =
              -F2 * localVelocity * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[0]
              - m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->U];
          m_solver->a_pvariable(ghostCellId, PV->V) =
              -F2 * localVelocity * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[1]
              - m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->V];
          m_solver->a_pvariable(ghostCellId, PV->W) =
              -F2 * localVelocity * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[2]
              - m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->W];

          // if ghost cell is located on the surface, set values directly to the computed p, rho, v
          if(m_surfaceGhostCell) {
            m_solver->a_pvariable(ghostCellId, PV->RHO) = meanDensity;
            m_solver->a_pvariable(ghostCellId, PV->P) = meanPressure;
            m_solver->a_pvariable(ghostCellId, PV->U) =
                -localVelocity * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[0];
            m_solver->a_pvariable(ghostCellId, PV->W) =
                -localVelocity * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[2];
            m_solver->a_pvariable(ghostCellId, PV->V) =
                -localVelocity * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[1];
          }
        }
      }
    }
  }

  if(globalTimeStep % 10 == 0)
    cerr << " ReferencePoint, R, normal, Massflux, pressure, density, velocity: " << referencePoint[0] << " "
         << referencePoint[1] << " " << referencePoint[2] << ", " << R << ", " << normal[0] << " " << normal[1] << " "
         << normal[2] << ", " << massflux << ", " << meanPressure << ", " << meanDensity << ", " << meanVelocity
         << endl;
}


/**
 * \fn FvBndryCndXD::bc1099MGC()
 * Subsonic outflow boundary condition - MGC formulation \n
 * Set of variables: Standard PV \n
 * static pressure is prescribed with the pressure loss L*m_deltaP (see initialCondition) \n
 * density and velocities are assumed not to change in normal direction \n \n
 * multiple ghost cells are handled - MGC formulation is used \n
 * surface Ghost cells can be handled \n \n
 * L has to be specified for the respective testcase
 * (approximative length between inflow and outflow)
 * used to compute the pressure loss \n \n
 * no 2D version available
 * \author Claudia Guenther
 * \date Mai 2009, modified April 2010
 * \fvbc{FvBndryCndXD::bc1099MGC(), fvbc1099MGC, BC 1099 MGC}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bc1099MGC(MInt bcId) {
  TRACE();
  IF_CONSTEXPR(nDim == 2) TERMM(1, "3D BC!");

  MInt cellId, bndryId, ghostCellId;
  // TINA_TC: L = 400.0
  // SUZI_TC: L = 400.0
  // standard: L = 400.0
  // NOZZLE_TC: L = 300.0
  // Pdiff = L * m_deltaP
  // m_Ma = 1.0: Pdiff = 0.1
  // neu! vorsicht - alte Testfaelle umstellen!
  MFloat& timeOfMaxPdiff = m_static_bc1099MGC_timeOfMaxPdiff;
  MBool& first = m_static_bc1099MGC_first;
  if(first) {
    timeOfMaxPdiff = Context::getSolverProperty<MFloat>("timeOfMaxPdiff", m_solverId, AT_, &timeOfMaxPdiff);
    // Convert from freestream-based to stagnation-based non-dimensionalization
    timeOfMaxPdiff = timeOfMaxPdiff / m_solver->m_timeRef;
    first = false;
  }
  MFloat Pdiff = m_deltaPL;
  MFloat fac = 1.0;
  if(m_solver->m_time < timeOfMaxPdiff) fac = m_solver->m_time / timeOfMaxPdiff;
  const MFloat initialPressure = sysEqn().p_Ref() - Pdiff;
  const MFloat deltaPressure = m_solver->m_PInfinity - sysEqn().p_Ref();


  //---

  for(MInt id = m_bndryCndCells[bcId]; id < m_bndryCndCells[bcId + 1]; id++) {
    bndryId = m_sortedBndryCells->a[id];
    cellId = m_bndryCells->a[bndryId].m_cellId;

    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      // set the pressure
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId != m_bndryCndIds[bcId]) {
          continue;
        }
        ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
        m_solver->a_pvariable(ghostCellId, PV->P) =
            F2 * (initialPressure + fac * deltaPressure)
            - m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->P];

        // if ghost cell is located on the surface direct application of the surface pressure
        if(m_surfaceGhostCell) m_solver->a_pvariable(ghostCellId, PV->P) = (initialPressure + fac * deltaPressure);


        //  apply the Neumann bc
        m_solver->a_pvariable(ghostCellId, PV->RHO) =
            m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->RHO];
        m_solver->a_pvariable(ghostCellId, PV->U) =
            m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->U];
        m_solver->a_pvariable(ghostCellId, PV->V) =
            m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->V];
        m_solver->a_pvariable(ghostCellId, PV->W) =
            m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[PV->W];
      }
    }
  }
}

/**
 * \fn FvBndryCndXD::cbc1099_1091d()
 * Subsonic partially reflecting characteristic inflow/outflow condition - uses methodology of cbc1099 and cbc1091d \n
 * no 2D-version available yet!
 * \author Claudia Guenther
 * \fvcbc{FvBndryCndXD::cbc1099_1091d(), fvcbc1099_1091d, CBC 1099 1091D}
 */

// NEW
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc1099_1091d(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  MFloat inflowArea = m_cbcInflowArea[cbcId];
  MFloat targetPressure = sysEqn().p_Ref();
  MInt last = nDim + 1;

  const MFloat R = sqrt(inflowArea / PI);
  const MFloat gammaMinusOne = m_solver->m_gamma - 1.0;
  const MFloat ut1_target = F0;

  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");

  MFloat massflux = F0;
  MFloat testSum2 = F0;
  MFloat T_mean = F0;
  MFloat massflux_pos = F0;
  MFloat massflux_neg = F0;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    MInt bndryId = m_solver->a_bndryId(cellId);

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MFloat area;
    if(bndryId > -1) {
      // identify the "boundary surface" between cutoff boundary cell and neighboring layer cell if cell is a boundary
      // cell
      MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dirN];
      if(srfcId > -1) {
        area = m_solver->a_surfaceArea(srfcId);
      } else {
        mTerm(1, AT_, "something went wrong!");
      }
    } else {
      area = POW2(m_solver->c_cellLengthAtCell(cellId));
    }

    MInt nghbrN = m_solver->c_neighborId(cellId, dirN);
    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    const MFloat p = m_solver->a_pvariable(cellId, PV->P);
    const MFloat un_N = m_solver->a_pvariable(nghbrN, PV->VV[dimN]);
    const MFloat Temp = sysEqn().temperature_ES(rho, p);

    const MFloat rsquare = POW2(m_solver->a_coordinate(cellId, 0) - m_cbcReferencePoint[cbcId][0])
                           + POW2(m_solver->a_coordinate(cellId, 1) - m_cbcReferencePoint[cbcId][1])
                           + POW2(m_solver->a_coordinate(cellId, 2) - m_cbcReferencePoint[cbcId][2]);

    testSum2 += area * rsquare;
    massflux += un_N * area;
    T_mean += Temp * area;

    if(un_N > F0) {
      massflux_pos += un_N * area;
    } else {
      massflux_neg += un_N * area;
    }
  }

  MFloat mach[2] = {F0, F0};
  cbcMachCo(bcId, mach);
  MFloat meanM = mach[0];
  MFloat maxM = mach[1];

  MInt noExchangeData = 5;
  MFloatScratchSpace comm_buff(noExchangeData, AT_, "comm_buff");
  MFloatScratchSpace comm_buff_result(noExchangeData, AT_, "comm_buff_result");
  comm_buff[0] = massflux;
  comm_buff[1] = testSum2;
  comm_buff[2] = T_mean;
  comm_buff[3] = massflux_pos;
  comm_buff[4] = massflux_neg;

  if(noDomains() > 1) {
    MPI_Allreduce(&comm_buff[0], &comm_buff_result[0], 5, MPI_DOUBLE, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]],
                  AT_, "comm_buff[0]", "comm_buff_result[0]");
  }

  massflux = comm_buff_result[0];
  testSum2 = comm_buff_result[2];
  T_mean = comm_buff_result[3];
  massflux_pos = comm_buff_result[4];
  massflux_neg = comm_buff_result[5];
  T_mean /= inflowArea;
  MFloat massflux_test = F2 * (F1 - testSum2 / (inflowArea * R * R));
  MFloat un_correctionFactor = F1;
  if(fabs(massflux_test) > m_solver->m_eps) un_correctionFactor = F1 / massflux_test;

  MFloat T_target = 1 - gammaMinusOne * F1B2 * (massflux * massflux / inflowArea / inflowArea);
  MFloat p_Target = sysEqn().pressure_IR(T_target);

  MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");
  MFloatScratchSpace gradTau(m_cbcViscous ? (nDim * nDim * nDim) : 1, AT_, "gradTau");
  MFloatScratchSpace gradQ(m_cbcViscous ? (nDim * nDim) : 1, AT_, "gradQ");

  MIntScratchSpace cutOffStencilCellIds(m_cbcViscous ? m_solver->a_noCells() : 1, AT_, "cutOffStencilCellIds");
  if(m_cbcViscous) cbcTauQ(bcId, &tau[0], &q[0], &cutOffStencilCellIds[0]);

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MInt bndryId = m_solver->a_bndryId(cellId);
    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    V.fill(F0);
    if(m_cbcViscous) {
      cbcGradientsViscous(cellId, bcId, &tau[0], &q[0], &gradTau[0], &gradQ[0], &cutOffStencilCellIds[0]);
      gradTau[dimN * IPOW2(nDim) + dimT1 * nDim + dimN] = F0;
      IF_CONSTEXPR(nDim == 3) { gradTau[dimN * IPOW2(nDim) + dimT2 * nDim + dimN] = F0; }
      cbcViscousTerms<(unsigned char)01111>(cellId, bcId, &tau[0], &gradTau[0], &gradQ[0], &gradVV[0],
                                            &cutOffStencilCellIds[0], &V[0]);
    }

    cbcTransversalTerms<(unsigned char)11111>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &T[0]);

    const MFloat rsquare = POW2(m_solver->a_coordinate(cellId, 0) - m_cbcReferencePoint[cbcId][0])
                           + POW2(m_solver->a_coordinate(cellId, 1) - m_cbcReferencePoint[cbcId][1])
                           + POW2(m_solver->a_coordinate(cellId, 2) - m_cbcReferencePoint[cbcId][2]);

    // This is where you differentiate between inflow and outflow
    MFloat un_mean = m_solver->a_pvariable(cellId, PV->VV[dimN]);

    MBool isInflow = true;
    if(dirN % 2 == 0) {
      if(un_mean > F0) {
        isInflow = false;
      } else {
        T_target = abs(massflux_neg) / (abs(massflux_neg) + abs(massflux_pos)) * T_target
                   + abs(massflux_pos) / (abs(massflux_neg) + abs(massflux_pos)) * T_mean;
      }
    } else {
      if(un_mean < F0) {
        isInflow = false;
      } else {
        T_target = abs(massflux_pos) / (abs(massflux_neg) + abs(massflux_pos)) * T_target
                   + abs(massflux_neg) / (abs(massflux_neg) + abs(massflux_pos)) * T_mean;
      }
    }

    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    const MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat a = sysEqn().speedOfSound(rho, p);

    const MFloat ut1 = m_solver->a_pvariable(cellId, PV->VV[dimT1]);
    const MFloat Temp = sysEqn().temperature_ES(rho, p);

    targetPressure = p_Target;

    if(isInflow) {
      cbcOutgoingAmplitudeVariation<1>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
      cbcDampingInflow(cellId, bcId, maxM, &K[0], "pressure");

      MFloat ceta = F1;
      if(dirN % 2 == 0)
        ceta = -F1;
      else
        ceta = F1;

      if(dirN % 2 == 0) {
        L[0] = K[0] * (p - targetPressure) + (T[last] + ceta * rho * a * T[1]) + (V[last] + ceta * rho * a * V[1]);
      } else {
        L[last] =
            K[last] * (p - targetPressure) + (T[last] + ceta * rho * a * T[1]) + (V[last] + ceta * rho * a * V[1]);
      }
      L[1] = K[1] * (Temp - T_target) + (a * a * T[0] - T[last]) + (a * a * V[0] - V[last]);
      L[2] = K[2] * (ut1 - ut1_target) + T[2] + V[2];
      IF_CONSTEXPR(nDim == 3) {
        const MFloat ut2 = m_solver->a_pvariable(cellId, PV->VV[dimT2]);
        const MFloat ut2_target = F0;
        L[3] = K[3] * (ut2 - ut2_target) + T[3] + V[3];
      }
    } else { // Outflow
      MFloat beta = meanM;

      cbcOutgoingAmplitudeVariation<0>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
      cbcDampingOutflow(cellId, bcId, maxM, &K[0]);

      MFloat ceta = F1;
      if(dirN % 2 == 0)
        ceta = -F1;
      else
        ceta = F1;

      if(dirN % 2 == 0) // outflow on pos. coordinate direction -> L1 has to be modeled
        L[0] = K[0] * (p - targetPressure) + (F1 - beta) * (T[last] + ceta * rho * a * T[1])
               + (V[last] + ceta * rho * a * V[1]);
      else
        L[last] = K[last] * (p - targetPressure) + (F1 - beta) * (T[last] + ceta * rho * a * T[1])
                  + (V[last] + ceta * rho * a * V[1]);
    }
    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);

    MFloat un_target = F2 * massflux / inflowArea * (F1 - rsquare / (R * R)) * un_correctionFactor;
    m_solver->a_pvariable(cellId, PV->VV[dimN]) = un_target;
  }
}


/** \brief Subsonic fully reflecting characteristic inflow condition - cut off
 *         - sets un to prescribed value after rkstep
 *
 * no 2D-version available yet!
 * moved here from fvmbbndrycnd3d!
 *
 * \author Claudia Guenther
 */

template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc1099_1091d_after(MInt bcId) {
  TRACE();
  IF_CONSTEXPR(nDim == 2) TERMM(1, "3D BC!");

  if(m_sortedCutOffCells[bcId]->size() == 0) return;

  const MInt otherDir[6] = {1, 0, 3, 2, 5, 4};

  MBool& first = m_static_cbc1099_1091d_after_first;
  MInt& dirN = m_static_cbc1099_1091d_after_dirN;
  MInt& dimN = m_static_cbc1099_1091d_after_dimN;
  MFloat& interpolationFactor = m_static_cbc1099_1091d_after_interpolationFactor;

  if(first) {
    MInt noCutOffBndryIds = Context::propertyLength("cutOffBndryIds", m_solverId);
    MInt noCutOffDirections = Context::propertyLength("cutOffDirections", m_solverId);
    if(noCutOffDirections != noCutOffBndryIds)
      mTerm(1, AT_,
            "Wrong number of cut off directions. Must be identical to number of cut off bndryIds! Please check!");
    MInt cutOffBndryIdTmp, cutOffDirectionTmp;
    for(MInt i = 0; i < noCutOffBndryIds; i++) {
      cutOffBndryIdTmp = Context::getSolverProperty<MInt>("cutOffBndryIds", m_solverId, AT_, i);
      cutOffDirectionTmp = Context::getSolverProperty<MInt>("cutOffDirections", m_solverId, AT_, i);
      if(cutOffBndryIdTmp == m_cutOffBndryCndIds[bcId]) {
        dirN = otherDir[cutOffDirectionTmp];
        break;
      }
    }
    dimN = (MInt)dirN / 2;

    /*! \page propertiesFV
      \section inOutInterpolationFactor
      <code>MInt FvBndryCnd3D::interpolationFactor</code>\n
      default = <code></code>\n \n
      Sets the inOutInterpolationFactor\n
      Possible values are:
      <ul>
      <li></li>
      </ul>
      Keywords: <i>FINITE VOLUME, MOVING BOUNDARY,</i>
    */
    interpolationFactor =
        Context::getSolverProperty<MFloat>("inOutInterpolationFactor", m_solverId, AT_, &interpolationFactor);

    first = false;
  }


  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    // recompute the correct energy:
    MFloat rho = m_solver->a_variable(cellId, CV->RHO);
    MFloat u_target = m_solver->a_pvariable(cellId, PV->VV[dimN]);
    MFloat u_rungeKutta = m_solver->a_variable(cellId, CV->RHO_VV[dimN]) / m_solver->a_variable(cellId, CV->RHO);
    MFloat deltaU = u_target - u_rungeKutta;
    MFloat u_corrected = u_rungeKutta + deltaU * interpolationFactor;

    m_solver->a_variable(cellId, CV->RHO_VV[dimN]) = rho * u_corrected;
    m_solver->a_pvariable(cellId, PV->VV[dimN]) = u_corrected;
  }
}


/**
 * \fn FvBndryCndXD::cbc1099_1091_engine()
 * Subsonic characteristic inflow/outflow for fvmb with switch by crank-angle
 * \fvcbc{FvBndryCndXD::cbc1099_1091_engine(), fvcbc1099_1091_engine, CBC 1099 1091 Engine}
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::cbc1099_1091_engine(MInt bcId) {
  TRACE();

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

// check cutOfCells:
#if !defined NDEBUG
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    const MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    ASSERT(fabs(m_solver->a_rightHandSide(cellId, CV->RHO)) < m_solver->m_eps, "");
    ASSERT(fabs(m_solver->a_rightHandSide(cellId, CV->RHO_VV[0])) < m_solver->m_eps, "");
    ASSERT(fabs(m_solver->a_rightHandSide(cellId, CV->RHO_VV[1])) < m_solver->m_eps, "");
    ASSERT(fabs(m_solver->a_rightHandSide(cellId, CV->RHO_E)) < m_solver->m_eps, "");
    IF_CONSTEXPR(nDim == 3)
    ASSERT(fabs(m_solver->a_rightHandSide(cellId, CV->RHO_VV[2])) < m_solver->m_eps, "");
  }

  // check conservative variables on window and halo-cells:
  // uncomment the part below for further debug checks, remaining for documentary purposes
  /*
  const MInt noChecks = CV->noVariables;
  MFloatScratchSpace cellCheck(m_solver->a_noCells(), noChecks, AT_, "cellCheck");
  cellCheck.fill(std::numeric_limits<MFloat>::max());

  for(MInt cellId = 0; cellId < m_solver->noInternalCells(); cellId++) {
    for(MInt v = 0; v < noChecks; v++) {
      cellCheck(cellId, v) = m_solver->a_variable(cellId, v);
    }
  }
  m_solver->exchangeData(&cellCheck(0), noChecks);
  for(MInt cellId = m_solver->noInternalCells(); cellId < m_solver->c_noCells(); cellId++) {
    if(!m_solver->c_isLeafCell(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    for(MInt v = 0; v < noChecks; v++) {
      if(fabs(cellCheck(cellId, v) - m_solver->a_variable(cellId, v)) > m_solver->m_eps * 10) {
        cerr << "Incorrect value at halo-cell: " << m_solver->a_isHalo(cellId) << setprecision(14) << " "
             << m_solver->a_variable(cellId, v) << " " << cellCheck(cellId, v) << endl;
      }
    }
  }
  */
#endif

  MInt cbcId = m_cbcBndryCndIds[bcId];

  MInt dirN = m_cbcDir[cbcId][0];
  MInt dimN = m_cbcDir[cbcId][1];
  MInt dimT1 = m_cbcDir[cbcId][2];
  MInt dimT2 = m_cbcDir[cbcId][nDim];

  MFloat inflowArea = m_cbcInflowArea[cbcId];
  inflowArea = inflowArea * m_dirTangent[cbcId][dimT1];

  MInt last = nDim + 1;

  MFloatScratchSpace gradRho(nDim, AT_, "gradRho");
  MFloatScratchSpace gradVV(nDim * nDim, AT_, "gradVV");
  MFloatScratchSpace gradP(nDim, AT_, "gradP");
  MFloatScratchSpace gradY(mMax(1, m_solver->m_noSpecies * nDim), AT_, "gradY");
  gradY.fill(F0);

  MFloatScratchSpace L(PV->noVariables, AT_, "L");
  MFloatScratchSpace T(PV->noVariables, AT_, "T");
  MFloatScratchSpace V(PV->noVariables, AT_, "V");
  MFloatScratchSpace K(PV->noVariables, AT_, "K");

  MFloat massflux = F0;
  MFloat T_mean = F0;
  MFloat rho_mean = F0;
  MFloat rho_max = F0;
  MFloat rho_min = 99;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];
    MInt bndryId = m_solver->a_bndryId(cellId);

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    MFloat area = -1;
    if(bndryId > -1) {
      // identify the "boundary surface" between cutoff boundary cell and neighboring layer cell if cell is a boundary
      // cell
      MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dirN];
      if(srfcId > -1) {
        area = m_solver->a_surfaceArea(srfcId);
        IF_CONSTEXPR(nDim == 3) ASSERT(area <= POW2(m_solver->c_cellLengthAtCell(cellId)), "");
      } else {
        for(MInt dir = 0; dir < m_noDirs; dir++) {
          srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dir];
          if(srfcId > -1) break;
        }
        if(srfcId == -1) {
          mTerm(1, AT_, "something went wrong!");
        }
        area = m_solver->a_surfaceArea(srfcId);
      }
    } else {
      IF_CONSTEXPR(nDim == 2) area = m_solver->c_cellLengthAtCell(cellId);
      IF_CONSTEXPR(nDim == 3) area = POW2(m_solver->c_cellLengthAtCell(cellId));
    }

    ASSERT(area > 0, "");

    // recompute area
    area = area * m_dirTangent[cbcId][dimT1];

    m_solver->setPrimitiveVariables(cellId);

    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    MFloat un = m_solver->a_pvariable(cellId, PV->VV[dimN]);

    MFloat un_N = 0;
    MFloat T_N = 1;

    if(m_solver->checkNeighborActive(cellId, dirN) && m_solver->a_hasNeighbor(cellId, dirN)) {
      const MInt nghbrN = m_solver->c_neighborId(cellId, dirN);

      if(m_dirNormal[cbcId][0] > -2) {
        for(MInt n = 0; n < nDim; n++) {
          un_N += m_solver->a_variable(nghbrN, CV->RHO_VV[n]) / m_solver->a_variable(nghbrN, CV->RHO)
                  * m_dirNormal[cbcId][n];
        }
      } else {
        un_N = m_solver->a_variable(nghbrN, CV->RHO_VV[dimN]) / m_solver->a_variable(nghbrN, CV->RHO);
      }

      if(std::isnan(un_N)) {
        cerr << "NAN detected in cutOff-Neighbor! " << endl;
      }

      T_N = sysEqn().temperature_ES(m_solver->a_variable(nghbrN, CV->RHO), m_solver->a_pvariable(nghbrN, PV->P));
    }

    if(rho < F0 || std::isnan(rho) || std::isnan(un)) {
      cerr << "NAN detected in cutOff-Cell " << m_solver->c_globalId(cellId) << " " << m_solver->a_isHalo(cellId) << " "
           << m_solver->a_bndryId(cellId) << " " << rho << " " << bcId << endl;
    }

    // massflux intentionally without rho
    massflux += un_N * area;
    T_mean += T_N * area;
    rho_mean += rho * area;
    rho_min = mMin(rho, rho_min);
    rho_max = mMax(rho, rho_max);
  }

  MInt noExchangeData = 3;
  MFloatScratchSpace comm_buff(noExchangeData, AT_, "comm_buff");
  comm_buff[0] = massflux;
  comm_buff[1] = T_mean;
  comm_buff[2] = rho_mean;

  if(noDomains() > 1) {
    MPI_Allreduce(MPI_IN_PLACE, &comm_buff[0], noExchangeData, MPI_DOUBLE, MPI_SUM,
                  m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_, "MPI_IN_PLACE", "comm_buff[0]");
    MPI_Allreduce(MPI_IN_PLACE, &rho_max, 1, MPI_DOUBLE, MPI_MAX, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                  "MPI_IN_PLACE", "rho_max");
    MPI_Allreduce(MPI_IN_PLACE, &rho_min, 1, MPI_DOUBLE, MPI_MIN, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                  "MPI_IN_PLACE", "rho_min");
  }

  massflux = comm_buff[0];
  T_mean = comm_buff[1];
  rho_mean = comm_buff[2];

  T_mean /= inflowArea;
  rho_mean /= inflowArea;

  MFloat mach[2] = {F0, F0};
  cbcMachCo(bcId, mach);
  MFloat meanM = mach[0];
  MFloat maxM = mach[1];


  MFloat T_out = sysEqn().temperature_IR(massflux / inflowArea);
  MFloat p_out = sysEqn().pressure_IR(T_out);
  if(p_out / sysEqn().p_Ref() > 1) p_out = sysEqn().p_Ref();
  if(T_out > 1) T_out = 1;
  const MFloat p_target = p_out;
  MFloat T_target;
  if(dirN % 2 == 1) {
    T_target = T_out; // intake-side
  } else {
    T_target = T_mean; // exhaust side
  }

  if(globalTimeStep % 10 == 0 && m_solver->m_RKStep == 0 && domainId() == m_cbcDomainMin[cbcId]) {
    cerr << globalTimeStep << " " << bcId << " " << (dirN % 2)
         << " M_mean, M_max, T_target, p_target, rho_mean, massflux, T_mean, rho_min, rho_max" << setprecision(9)
         << meanM << ", " << maxM << ", " << T_target << ", " << p_target << ", " << rho_mean << ", " << rho_min << ", "
         << rho_max << ", " << massflux << " " << T_mean << endl;
    // check engine inflow
    /*
    if(dirN % 2 == 1 && globalTimeStep % 10 == 0 && m_solver->m_engineSetup) {
      // compute isotropic inflowFlux for comparison:
      const MInt pistonBodyId = 1;
      const MInt pistonNormal = 1; // 0: x, 1: y, 2: z
      // const MFloat boreArea = PI / 4 / 2;
      //              for circle with diameter 1 and 2 inflow ducts (TINA)
      const MFloat boreArea = PI / 4;
      //              for circle with diameter 1 and 1 inflow duct ( HELEN)
      // const MFloat boreArea = PI / 4 / 4;
      //              for quarter circle with diameter 1 and 1 inflow duct ( Inflow-test)
      const MFloat volFluxMean = fabs(m_solver->m_bodyVelocity[pistonBodyId * nDim + pistonNormal] * boreArea);
      const MFloat flux_iso = volFluxMean / inflowArea;
      const MFloat flux = massflux / inflowArea;
      const MFloat flux_pos = massflux_pos / area_pos;
      const MFloat flux_neg = massflux_neg / area_neg;
      const MFloat flux_dif = fabs(flux - flux_iso) / flux * 100;
      cerr << "Mean flux " << flux << " positive flux " << flux_pos << " negative flux " << flux_neg
           << " isotropic inlow flux " << flux_iso << " dif: " << flux_dif << endl;
    }
    */
  }
  ASSERT(!std::isnan(massflux), "ERROR: Mass-flux is nan!");

  MInt noCutOffBCCells = m_cbcViscous ? m_sortedCutOffCells[bcId]->size() : 1;
  MFloatScratchSpace tau(3 * noCutOffBCCells * nDim * nDim, AT_, "tau");
  MFloatScratchSpace q(3 * noCutOffBCCells * nDim, AT_, "q");
  MFloatScratchSpace gradTau(m_cbcViscous ? (nDim * nDim * nDim) : 1, AT_, "gradTau");
  MFloatScratchSpace gradQ(m_cbcViscous ? (nDim * nDim) : 1, AT_, "gradQ");

  MIntScratchSpace cutOffStencilCellIds(m_cbcViscous ? m_solver->a_noCells() : 1, AT_, "cutOffStencilCellIds");
  if(m_cbcViscous) cbcTauQ(bcId, &tau[0], &q[0], &cutOffStencilCellIds[0]);

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    // get neighbor for eddy calculation
    MFloat un_N = 0;
    MFloat ut_N[nDim - 1] = {0};

    // check neighbor active!
    if(m_solver->checkNeighborActive(cellId, dirN) && m_solver->a_hasNeighbor(cellId, dirN)) {
      const MInt nghbrN = m_solver->c_neighborId(cellId, dirN);

      for(MInt n = 0; n < nDim; n++) {
        un_N += m_solver->a_variable(nghbrN, CV->RHO_VV[n]) * m_dirNormal[cbcId][n];
        ut_N[0] += m_solver->a_variable(nghbrN, CV->RHO_VV[n]) * m_dirTangent[cbcId][n];
      }
      IF_CONSTEXPR(nDim == 3) { ut_N[1] = m_solver->a_variable(nghbrN, CV->RHO_VV[dimT2]); }
    }

    MInt bndryId = m_solver->a_bndryId(cellId);
    if(bndryId > -1) {
      if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;
    }

    cbcGradients(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0]);
    V.fill(F0);
    if(m_cbcViscous) {
      cbcGradientsViscous(cellId, bcId, &tau[0], &q[0], &gradTau[0], &gradQ[0], &cutOffStencilCellIds[0]);
      gradTau[dimN * IPOW2(nDim) + dimT1 * nDim + dimN] = F0;
      IF_CONSTEXPR(nDim == 3) { gradTau[dimN * IPOW2(nDim) + dimT2 * nDim + dimN] = F0; }
      cbcViscousTerms<(unsigned char)01111>(cellId, bcId, &tau[0], &gradTau[0], &gradQ[0], &gradVV[0],
                                            &cutOffStencilCellIds[0], &V[0]);
    }

    cbcTransversalTerms<(unsigned char)11111>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &T[0]);

    // eddy detection:
    MFloat eddy = POW2(ut_N[0]) / POW2(un_N);
    IF_CONSTEXPR(nDim == 3) { eddy = (POW2(ut_N[0]) + POW2(ut_N[1])) / POW2(un_N); }

    MBool isInflow = true;
    if(dirN % 2 == 0) {
      if(un_N > F0) {
        isInflow = false;
      }
    } else {
      if(un_N < F0) {
        isInflow = false;
      }
    }

    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    MFloat ut1 = F0;

    for(MInt n = 0; n < nDim; n++) {
      ut1 += m_solver->a_pvariable(cellId, PV->VV[n]) * m_dirTangent[cbcId][n];
    }

    const MFloat p = m_solver->a_pvariable(cellId, PV->P);
    MFloat a = sysEqn().speedOfSound(rho, p);
    const MFloat Temp = sysEqn().temperature_ES(rho, p);

    if(isInflow) {
      cbcOutgoingAmplitudeVariation<1>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
      cbcDampingInflow(cellId, bcId, maxM, &K[0], "pressure");

      if(dirN % 2 == 0) {
        L[0] = K[0] * (p - p_target) + (T[last] - rho * a * T[1]) + (V[last] - rho * a * V[1]);
      } else {
        L[last] = K[last] * (p - p_target) + (T[last] + rho * a * T[1]) + (V[last] + rho * a * V[1]);
      }

      L[1] = K[1] * (Temp - T_target) + (a * a * T[0] - T[last]) - V[last];
      L[2] = K[2] * ut1 + T[2] + V[2];
      IF_CONSTEXPR(nDim == 3) {
        const MFloat ut2 = m_solver->a_pvariable(cellId, PV->VV[dimT2]);
        L[3] = K[3] * ut2 + T[3] + V[3];
      }

      MBool limitVariable = false;
      if(m_solver->a_pvariable(cellId, PV->RHO) > 1.0000001) {
        m_solver->a_pvariable(cellId, PV->RHO) = 1;
        limitVariable = true;
      }
      if(m_solver->a_pvariable(cellId, PV->P) / sysEqn().p_Ref() > 1.0000001) {
        m_solver->a_pvariable(cellId, PV->P) = sysEqn().p_Ref();
        limitVariable = true;
      }

      if(limitVariable) {
        m_solver->setConservativeVariables(cellId);
      }

    } else {
      MFloat beta = meanM;

      cbcOutgoingAmplitudeVariation<0>(cellId, bcId, &gradRho[0], &gradVV[0], &gradP[0], &gradY[0], &L[0]);
      cbcDampingOutflow(cellId, bcId, maxM, &K[0]);

      if(eddy > 1) {
        // TODO labels:FV update testcase to new version!
        if(!m_solver->m_engineSetup) {
          K[0] = 0;
        } else {
          // update: only set K1 to zero for considerable mass-flux through the
          //        boundary!
          if(fabs(massflux) > 0.05) {
            K[0] = 0;
          } else {
            // surpress fluctuations in transversal velocities (sponging)
            // const MFloat K3 = eta3 * 10 * a / LN;
            L[2] = K[2] * ut1 + T[2] + V[2];
            IF_CONSTEXPR(nDim == 3) {
              const MFloat ut2 = m_solver->a_pvariable(cellId, PV->VV[dimT2]);
              L[3] = K[3] * ut2 + T[3] + V[3];
            }
          }
        }
      }

      if(dirN % 2 == 0) {
        L[0] = K[0] * (p - p_target) + (F1 - beta) * (T[last] - rho * a * T[1]) + (V[last] - rho * a * V[1]);
      } else {
        L[last] = K[last] * (p - p_target) + (F1 - beta) * (T[last] + rho * a * T[1]) + (V[last] + rho * a * V[1]);
      }

      // additional amplitude description for low mass-fluxes at outflow!
      if(dirN % 2 != 0 && fabs(massflux) < 0.05 && m_solver->m_engineSetup) {
        const MFloat K2_outflow = m_cbcRelax[cbcId][1] * rho * a / m_cbcLref[cbcId];
        L[1] = K2_outflow * (Temp - T_target) + (a * a * T[0] - T[last]) - V[last];
      }
    }

    cbcRHS(cellId, bcId, &L[0], &T[0], &V[0]);
  }
}


/** \brief reset sorterdCutOff Cells and cutOff communicator before balancing and adaptation!
 * \author Tim Wegmann
 *
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::resetCutOff() {
  TRACE();

  for(auto it = m_sortedCutOffCells.begin(); it != m_sortedCutOffCells.end(); it++) {
    delete *it;
  }

  m_sortedCutOffCells.clear();
  mDeallocate(m_bcCo_comm_pointer);
}

/** \brief reset first for cutOffBndryCnd, this is necessary after a balance!
 * \author Tim Wegmann
 * NOTE: not ideal implementation, but working...
 */

template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::resetCutOffFirst() {
  TRACE();

  m_static_cbc1099_first = true;
  m_static_cbc1091_first = true;
  m_static_cbc2091a_first = true;
  m_static_cbc1091b_first = true;
  m_static_cbc2091b_first = true;
  m_static_cbc1091c_first = true;
  m_static_cbc1091c_after_first = true;
  m_static_cbc1091d_first = true;
  m_static_cbc1091d_after_first = true;
  m_static_cbc2091d_first = true;
  m_static_cbc2091d_after_first = true;
  m_static_cbc1091e_first = true;
  m_static_cbc1099_1091_local_first = true;
  m_static_cbc1099_1091_local_comb_first = true;
  m_static_cbc2099_1091_local_comb_first = true;
  m_static_cbc3091a_first = true;
  m_static_cbc1099_1091_engine_first = true;
  IF_CONSTEXPR(nDim == 3) {
    m_static_cbc1099_1091d_first = true;
    m_static_cbc1099_1091d_after_first = true;
  }
}


template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::resetBndryCommunication() {
  TRACE();
  if(m_comm_bc_init > 0) {
    for(MInt i = 0; i < m_comm_bc_init; i++) {
      if(m_comm_bc[i] != MPI_COMM_NULL && m_comm_bc[i] != globalMaiaCommWorld()) {
        MPI_Comm_free(&m_comm_bc[i], AT_, "m_comm_bc[i]");
      }
    }
  }

  if(m_comm_bcCo_init > 0) {
    for(MInt i = 0; i < m_comm_bcCo_init; i++) {
      if(m_comm_bcCo[i] != MPI_COMM_NULL && m_comm_bcCo[i] != globalMaiaCommWorld()) {
        MPI_Comm_free(&m_comm_bcCo[i], AT_, "m_comm_bcCo[]i");
      }
    }
  }
}


/**
 * \fn void FvBndryCndXD<2, SysEqn>::createCutFace()
 * \brief computes the geometry of each the cut cells (2D version)
 * 2 cut points are assumed for each boundary cell
 * this restriction is required since the remainder of the 2D code
 * is not able to work with multiply cut cellls
 * this algorithm can easily be modified to account for 4 cut points
 * (multiply cut cell or split cells)
 * computes the following boundary cell member variables:
 *  - m_noSrfcs
 *  - m_volume
 *  - m_coordinates
 *  - m_srfcs[srfc]->m_area
 *  - m_srfcs[srfc]->m_coordinates
 *  - m_srfcs[srfc]->m_volume
 *  - m_srfcs[srfc]->m_normalVector
 *  - m_externalFaces
 *  for each cut surface (currently only 1):
 *  - m_srfcs[srfc]->m_bodyId
 *  - m_srfcs[srfc]->m_cutEdge
 *  - m_srfcs[srfc]->m_cutCoordinates
 * of the respective surface
 * in addition, surfaces for the body surfaces and the cut cartesian
 * faces of each cell are suplied (will be corrected in checkForSrfcs)
 * \author Claudia Guenther, 10/2013
 *
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 2, _*>>
void FvBndryCndXD<nDim, SysEqn>::createCutFace() {
  TRACE();

  const MInt otherDir[2] = {1, 0};
  const MInt faceOrder[4] = {2, 1, 3, 0};
  const MFloat signCode[2][4] = {{-F1, F1, F1, -F1}, {-F1, -F1, F1, F1}};

  //----------------------------------------------------------------------------
  for(MInt bndryId = 0; bndryId < m_bndryCells->size(); bndryId++) {
    MInt cellId = m_bndryCells->a[bndryId].m_cellId;

    for(MInt f = 0; f < m_noDirs; f++) {
      m_bndryCells->a[bndryId].m_externalFaces[f] = false;
    }

    if(m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints != 2) {
      cerr << "** FvBndryCnd2D ERROR" << endl;
      cerr << "boundary cell " << bndryId << endl;
      cerr << m_solver->a_coordinate(cellId, 0) << " " << m_solver->a_coordinate(cellId, 1) << endl;
      cerr << m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints
           << " -> number of cut points is not equal two - multiple body surfaces not implemented!" << endl;
      continue;
    }

    const MFloat cellLength = m_solver->c_cellLengthAtCell(cellId);
    const MFloat cellHalfLength = F1B2 * cellLength;

    if(!m_solver->c_isLeafCell(cellId) || (!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel))) {
      m_bndryCells->a[bndryId].m_volume = m_solver->grid().gridCellVolume(m_solver->a_level(cellId));
      for(MInt i = 0; i < nDim; i++) {
        m_bndryCells->a[bndryId].m_coordinates[i] = F0;
      }
      m_bndryCells->a[bndryId].m_noSrfcs = 0;
      continue;
    }

    MInt noCutPoints = m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;

    MInt cutPointIds[4] = {-1, -1, -1, -1};
    MInt edgeCutPointCounter[4] = {0, 0, 0, 0};
    for(MInt cp = 0; cp < noCutPoints; cp++) {
      MInt edge = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cp];
      ASSERT(edgeCutPointCounter[edge] == 0, "");
      cutPointIds[edge] = cp;
      edgeCutPointCounter[edge]++;
    }

    // store relevant cut and corner point information in math. pos. sense of rotation (only convex cells are allowed)
    MFloat coords[16];
    MInt pointBodyId[8]; // -1: corner point; > -1: cut point with body Id
    MInt pointEdgeId[8];
    MInt noNodes = 0;
    for(MInt n = 0; n < 4; n++) {
      MFloat cornerPoint[2] = {F0, F0};
      for(MInt d = 0; d < nDim; d++)
        cornerPoint[d] = m_solver->a_coordinate(cellId, d) + signCode[d][n] * cellHalfLength;
      if(!m_solver->m_geometry->pointIsInside(cornerPoint)) {
        for(MInt d = 0; d < nDim; d++)
          coords[noNodes * 2 + d] = cornerPoint[d];
        pointBodyId[noNodes] = -1; // corner point
        pointEdgeId[noNodes] =
            faceOrder[n]; // holds the edge which starts in the respective point (math. pos. sense of rotation)
        noNodes++;
      }
      MInt cpId = cutPointIds[faceOrder[n]];
      if(cpId > -1) {
        for(MInt d = 0; d < nDim; d++)
          coords[noNodes * 2 + d] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cpId][d];
        pointBodyId[noNodes] = m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[cpId];  // point is a cut point
        pointEdgeId[noNodes] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cpId]; // cut edge
        noNodes++;
      }
    }
    // after this, the original cut point storage can be deleted -> will be stored cut-surface-wise in correct order
    // from now on!

    // compute cell "volume" and centroid
    MFloat volume = F0;
    MFloat centroid[2]{};
    computePolygon(coords, noNodes, centroid, &volume);

    // set up data structure of line segments for easier processing
    MInt lineSegments[8][2]; // stores the point Ids of the points defining the different segments
    MInt lineTypes[8];       // -2: uncut cartesian face, -1: cut cartesian face, >=0: body segment
    MInt edgeLinePointer[4] = {
        -1, -1, -1, -1}; // stores segment Id for each (cut or uncut) Cartesian edge which is part of the polygonal
                         // cell description, -1 if edge is nonFluidSide and thus not part of the polygon
    MInt bodyLinePointer[4] = {
        -1, -1, -1,
        -1}; // stores segment Id for each body surface = non-Cartesian edges in the polygonal cell description
    MInt bodyLineCounter = 0; // number of body surfaces
    for(MInt segment = 0; segment < noNodes; segment++) {
      MInt firstPoint = segment;
      MInt secondPoint = (segment + 1) % noNodes;
      lineSegments[segment][0] = firstPoint;
      lineSegments[segment][1] = secondPoint;
      if(pointBodyId[firstPoint] == -1 && pointBodyId[secondPoint] == -1) {
        // line segment is uncut cartesian segment
        edgeLinePointer[pointEdgeId[firstPoint]] = segment;
        lineTypes[segment] = -2; // uncut cartesian face
      } else if(pointBodyId[firstPoint] == -1 || pointBodyId[secondPoint] == -1) {
        // line segment is cut cartesian segment
        edgeLinePointer[pointEdgeId[firstPoint]] = segment;
        lineTypes[segment] = -1; // cut cartesian face
      } else {
        // line segment is body segment with pointBodyId
        bodyLinePointer[bodyLineCounter] = segment;
        lineTypes[segment] = bodyLineCounter++;
      }
      if(bodyLineCounter > 1) {
        cerr << to_string(m_solver->c_cellLengthAtCell(cellId)) << endl;
        cerr << to_string(m_solver->c_cellLengthAtCell(cellId)) << endl;
        // cerr << to_string(m_solver->a_surfaceCoordinate( cellId , 1) << endl;
      }
    }

    MFloat cutFaceAreas[4];
    MFloat surfCoords[2];
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      MInt edge = dir;
      MInt sideId = dir % 2;
      MInt spaceId = dir / 2;
      MInt tDir = otherDir[spaceId];
      for(MInt j = 0; j < nDim; j++) {
        surfCoords[j] = m_solver->a_coordinate(cellId, j);
      }
      surfCoords[spaceId] += signCode[0][sideId] * cellHalfLength;

      MInt segmentId = edgeLinePointer[edge];
      if(segmentId == -1) {
        // non fluid side
        m_bndryCells->a[bndryId].m_externalFaces[dir] = true;
        cutFaceAreas[dir] = F0;
      } else {
        MInt lineType = lineTypes[segmentId];
        if(lineType == -2) {
          // uncut Cartesian face
          cutFaceAreas[dir] = cellLength;
        } else {
          // cut Cartesian face - compute segment area
          MInt point1 = lineSegments[segmentId][0];
          MInt point2 = lineSegments[segmentId][1];
          MFloat pointDiff = coords[point2 * 2 + tDir] - coords[point1 * 2 + tDir];
          cutFaceAreas[dir] = fabs(pointDiff);
          surfCoords[tDir] = coords[point1 * 2 + tDir] + F1B2 * pointDiff;
        }
      }

      MBool createSrfc = true;
      MInt nghbrId = -1;
      if(m_solver->a_hasNeighbor(cellId, dir) > 0) {
        nghbrId = m_solver->c_neighborId(cellId, dir);
      } else {
        if(m_solver->c_parentId(cellId) > -1) {
          if(m_solver->a_hasNeighbor(m_solver->c_parentId(cellId), dir) > 0)
            nghbrId = m_solver->c_neighborId(m_solver->c_parentId(cellId), dir);
          else
            createSrfc = false;
        } else
          createSrfc = false;
      }
      if(createSrfc)
        if(m_solver->c_noChildren(nghbrId) > 0) createSrfc = false;
      if(createSrfc) {
        MInt srfcId = m_solver->a_noSurfaces();
        m_surfaces.append();
        m_solver->a_surfaceOrientation(srfcId) = spaceId;
        m_solver->a_surfaceNghbrCellId(srfcId, sideId) = nghbrId;
        m_solver->a_surfaceNghbrCellId(srfcId, otherDir[sideId]) = cellId;
        m_solver->a_surfaceArea(srfcId) = cutFaceAreas[dir];
        for(MInt i = 0; i < nDim; i++) {
          m_solver->a_surfaceCoordinate(srfcId, i) = surfCoords[i];
        }
        m_bndryCells->a[bndryId].m_associatedSrfc[dir] = srfcId;
      }
    }

    ASSERT(bodyLineCounter == 1, ""); // in a later version, multiply cut cells can be enabled!
    m_bndryCells->a[bndryId].m_noSrfcs = 1;

    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      MInt segmentId = bodyLinePointer[srfc];
      ASSERT(segmentId > -1, "");
      MInt point1 = lineSegments[segmentId][0];
      MInt point2 = lineSegments[segmentId][1];

      // compute area and normal of body surface
      MFloat area = F0;
      MFloat normal[2];
      MFloat surfaceCoordinates[2];
      // compute body surfaces
      MFloat deltaX = coords[point2 * 2] - coords[point1 * 2];
      MFloat deltaY = coords[point2 * 2 + 1] - coords[point1 * 2 + 1];
      area = sqrt(deltaX * deltaX + deltaY * deltaY);
      normal[0] = -deltaY / mMax(m_solver->m_eps, area);
      normal[1] = deltaX / mMax(m_solver->m_eps, area);
      surfaceCoordinates[0] = coords[point1 * 2 + 0] + F1B2 * deltaX;
      surfaceCoordinates[1] = coords[point1 * 2 + 1] + F1B2 * deltaY;

      // store cut point information
      m_bndryCells->a[bndryId].m_srfcs[srfc]->m_noCutPoints = 2;
      for(MInt i = 0; i < nDim; i++) {
        m_bndryCells->a[bndryId].m_srfcs[srfc]->m_cutCoordinates[0][i] = coords[point1 * 2 + i];
        m_bndryCells->a[bndryId].m_srfcs[srfc]->m_cutCoordinates[1][i] = coords[point2 * 2 + i];
      }
      m_bndryCells->a[bndryId].m_srfcs[srfc]->m_cutEdge[0] = pointEdgeId[point1];
      m_bndryCells->a[bndryId].m_srfcs[srfc]->m_cutEdge[1] = pointEdgeId[point2];
      m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bodyId[0] = pointBodyId[point1];
      m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bodyId[1] = pointBodyId[point2];

      // store body surface information
      m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area = area;
      for(MInt i = 0; i < nDim; i++) {
        m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i] = normal[i];
        m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i] = surfaceCoordinates[i];
      }
    }

    m_bndryCells->a[bndryId].m_volume = volume;
    for(MInt i = 0; i < nDim; i++) {
      m_bndryCells->a[bndryId].m_coordinates[i] = centroid[i] - m_solver->a_coordinate(cellId, i);
    }

    // for debug purpose: check cell areas:
    MFloat areaCheck[2] = {F0, F0};
    const MFloat checkEps = 1e-12;
    for(MInt i = 0; i < nDim; i++) {
      areaCheck[i] += (cutFaceAreas[2 * i] - cutFaceAreas[2 * i + 1]);
    }
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      for(MInt i = 0; i < nDim; i++) {
        areaCheck[i] +=
            m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
      }
    }
    MBool checkPassed = ((fabs(areaCheck[0]) < checkEps) && (fabs(areaCheck[1]) < checkEps));
    if(!checkPassed) {
      cerr << "** FvBndryCnd2D WARNING" << endl;
      cerr << "boundary cell " << bndryId << endl;
      cerr << m_solver->a_coordinate(cellId, 0) << " " << m_solver->a_coordinate(cellId, 1) << endl;
      cerr << " -> boundary cell check not passed! " << endl;
      cerr << " area check: " << areaCheck[0] << " " << areaCheck[1] << endl;
      continue;
    }
  }
}


/**
 * \fn void FvBndryCndXD<3, SysEqn>::createCutFace()
 * \brief computes the geometry of each the cut cells (3D version)
 * multiply cut cells can not be handeled!
 * computes the following boundary cell member variables:
 *  - m_noSrfcs = 1 (otherwise quit)
 *  - m_volume
 *  - m_coordinates
 *  - m_srfcs[srfc]->m_area
 *  - m_srfcs[srfc]->m_coordinates
 *  - m_srfcs[srfc]->m_volume
 *  - m_srfcs[srfc]->m_normalVector
 *  - m_externalFaces
 *  for each cut surface (i.e. _the_ cut surface):
 *  - m_srfcs[srfc]->m_bodyId
 *  - m_srfcs[srfc]->m_cutEdge
 *  - m_srfcs[srfc]->m_cutCoordinates
 * of the respective surface
 * in addition, surfaces for the body surfaces and the cut cartesian
 * faces of each cell are suplied (will be corrected in checkForSrfcs)
 * \author Daniel Hartmann, 23.12.2006, changed by Claudia Guenther, 10/2013, changed by Sohel Herff 2016
 *
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::createCutFace() {
  TRACE();

  static constexpr MInt edgeCode[24] = {8, 10, 0, 4, 9, 11, 1, 5, 2, 6, 8, 9, 3, 7, 10, 11, 0, 1, 2, 3, 4, 5, 6, 7};
  static constexpr MInt faceCode[24] = {0, 4, 1, 4, 2, 4, 3, 4, 0, 5, 1, 5, 2, 5, 3, 5, 0, 2, 1, 2, 0, 3, 1, 3};
  MBoolScratchSpace cutFaces(m_noDirs, AT_, "cutFaces");
  MBoolScratchSpace cutEdgesAll(m_noEdges, AT_, "cutEdgesAll");
  MBoolScratchSpace faceGeometryIsTriangle(m_noDirs, AT_, "faceGeometryIsTriangle");
  MBoolScratchSpace nonFluidSideEdge(m_noEdges, AT_, "nonFluidSideEdge");
  MBoolScratchSpace shapeIsInside(m_noDirs, AT_, "shapeIsInside");
  MBool positiveSlope;
  MBool pointInside;
  MInt edgeCounter;
  MInt face0 = 0, face1 = 0;
  const MInt noCells = m_bndryCells->size();
  MIntScratchSpace cutPointOnEdge(m_noEdges, AT_, "cutPointOnEdge");
  MIntScratchSpace noNonFluidEdges(m_noDirs, AT_, "noNonFluidEdges");
  MIntScratchSpace cutEdges(4, AT_, "cutEdges");
  MIntScratchSpace cutPoint(4, AT_, "cutPoint");
  MFloatScratchSpace cc0(nDim, AT_, "cc0");
  MFloatScratchSpace cc1(nDim, AT_, "cc1");
  MFloatScratchSpace cutLineLength(m_noEdges, AT_, "cutLineLength");
  MFloatScratchSpace faceVolume(m_noDirs, AT_, "faceVolume");
  MFloatScratchSpace gridFaceVolume(m_noDirs, AT_, "gridFaceVolume");
  MFloatScratchSpace cutLineCentroid(m_noDirs * nDim, AT_, "cutLineCentroid");
  MFloat cutOutVolume;
  MFloatScratchSpace delta_scratch(m_noDirs * nDim, AT_, "delta_scratch");
  MFloat* delta = delta_scratch.getPointer();
  MFloat dfcc[2];
  MFloatScratchSpace faceCentroid(m_noDirs * nDim, AT_, "faceCentroid");
  MFloatScratchSpace triangleCentroid(m_noDirs * nDim, AT_, "triangleCentroid");
  MFloatScratchSpace normalVector(m_noDirs * nDim, AT_, "normalVector");
  MFloat negativePoint[3] = {0, 0, 0};
  MFloat oppositePoint[3] = {0, 0, 0};
  MFloat point[3] = {0, 0, 0};
  MFloat pointP[3] = {0, 0, 0};
  MFloat pointM[3] = {0, 0, 0};
  MFloat pointW[3] = {0, 0, 0};
  MFloat pointE[3] = {0, 0, 0};
  MFloat pointBR[3] = {0, 0, 0};
  MFloat pointTL[3] = {0, 0, 0};
  MFloat rectVolume, triVolume;
  MFloat trianglePoint[3] = {0, 0, 0};
  MFloat trianglePointP[3] = {0, 0, 0};
  MFloat trianglePointM[3] = {0, 0, 0};
  MFloat trianglePointW[3] = {0, 0, 0};
  MFloat trianglePointE[3] = {0, 0, 0};
  //---

  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    MInt noCutFaces = 0;
    m_bndryCells->a[bndryId].m_noSrfcs = 1;

    for(MInt f = 0; f < m_noDirs; f++) {
      m_bndryCells->a[bndryId].m_externalFaces[f] = false;
    }

    // reset all local variables
    fill_n(&cutEdgesAll[0], m_noEdges, false);
    fill_n(&nonFluidSideEdge[0], m_noEdges, false);
    fill_n(&cutPointOnEdge[0], m_noEdges, -1);
    fill_n(&cutFaces[0], m_noDirs, false);
    fill_n(&faceGeometryIsTriangle[0], m_noDirs, false);
    fill_n(&shapeIsInside[0], m_noDirs, false);

    const MFloat eps = m_solver->c_cellLengthAtCell(cellId) * 0.00001;

    if(!m_solver->c_isLeafCell(cellId) || (!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel))) {
      m_bndryCells->a[bndryId].m_volume = m_solver->grid().gridCellVolume(m_solver->a_level(cellId));
      for(MInt i = 0; i < nDim; i++) {
        m_bndryCells->a[bndryId].m_coordinates[i] = F0;
      }
      m_bndryCells->a[bndryId].m_noSrfcs = 0;
      continue;
    }

    // store all cut points in a separate array
    for(MInt cp = 0; cp < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cp++) {
      cutPointOnEdge[m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cp]] = cp;
    }

    // I.
    // --
    //    determine the cut geometry for each face
    //    assuming that each face has either 0 or 2 cut points
    for(MInt face = 0; face < m_noDirs; face++) {
      // assemble face edges and cut points
      MInt n = 0;
      for(MInt e = 0; e < 4; e++) {
        MInt cp = cutPointOnEdge[edgeCode[4 * face + e]];
        if(cp > -1) {
          cutPoint[n] = cp;
          cutEdges[n] = e;
          cutEdgesAll[edgeCode[4 * face + e]] = true;
          n++;
        }
      }

      if(n > 0) {
        cutFaces[face] = true;
        noCutFaces++;
      }

      if(n == 1 || n > 2) {
        cerr << "** ERROR create cut face: " << n << " cut points for face " << face << endl;
        stringstream errorMessage;
        errorMessage << "create cut face: " << n << " cut points for face " << face;
        cerr << "cell " << cellId << " cog " << m_solver->a_coordinate(cellId, 0) << " "
             << m_solver->a_coordinate(cellId, 1) << " " << m_solver->a_coordinate(cellId, 2) << endl;
        cerr << "level " << m_solver->a_level(cellId) << endl;
        cerr << "edges that get cut: " << endl;
        for(MInt cp = 0; cp < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cp++) {
          cerr << m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cp] << endl;
        }

        stringstream fileName;
        fileName << "multipleCutCell_" << cellId << ".stl";
        cerr << "Writing stl-file of cell " << cellId << " to " << (fileName.str()) << endl;
        writeStlFileOfCell(cellId, (fileName.str()).c_str());

        mTerm(1, AT_, errorMessage.str());
      }

      const MInt spaceId = face / 2;
      const MInt sideId = face % 2;
      const MInt spaceId1 = (spaceId + 1) % nDim;
      const MInt spaceId2 = (spaceId1 + 1) % nDim;

      const MInt nDimFaceSpaceId1 = nDim * face + spaceId1;
      const MInt nDimFaceSpaceId2 = nDim * face + spaceId2;

      gridFaceVolume[face] = POW2(m_solver->c_cellLengthAtCell(cellId));
      faceVolume[face] = gridFaceVolume[face];

      // set the reference points
      for(MInt i = 0; i < nDim; i++) {
        point[i] = m_solver->a_coordinate(cellId, i) - F1B2 * m_solver->c_cellLengthAtCell(cellId);
        negativePoint[i] = point[i];
        oppositePoint[i] = point[i] + m_solver->c_cellLengthAtCell(cellId);
      }

      // set the secondary coordinate (spaceId) of the reference points
      point[spaceId] += (MFloat)sideId * m_solver->c_cellLengthAtCell(cellId);
      oppositePoint[spaceId] = point[spaceId];
      pointBR[spaceId] = point[spaceId];
      pointTL[spaceId] = point[spaceId];

      pointBR[spaceId1] = oppositePoint[spaceId1];
      pointBR[spaceId2] = point[spaceId2];
      pointTL[spaceId1] = point[spaceId1];
      pointTL[spaceId2] = oppositePoint[spaceId2];

      // inside / outside check for point
      for(MInt i = 0; i < nDim; i++) {
        pointP[i] = point[i];
        pointM[i] = point[i];
        pointW[i] = point[i];
        pointE[i] = point[i];
      }
      pointP[spaceId1] += eps;
      pointM[spaceId1] -= eps;
      pointW[spaceId2] += eps;
      pointE[spaceId2] -= eps;

      pointInside = m_solver->m_geometry->pointIsInside2(point);

      MBool pointBRInside_ = false;
      MBool pointTLInside_ = false;

      // Note: this prevents costly pointIsInside2() calls if they are not required
      auto pointBRInside = [this, &pointBRInside_, &pointBR]() {
        static MFloat lastPoint[3] = {MFloatNaN, MFloatNaN, MFloatNaN};
        // Return the stored value if already computed for this point
        if(std::equal(&pointBR[0], &pointBR[0] + nDim, &lastPoint[0])) {
          return pointBRInside_;
        } else {
          // Determine if point is inside and store position
          pointBRInside_ = m_solver->m_geometry->pointIsInside2(pointBR);
          std::copy_n(&pointBR[0], nDim, &lastPoint[0]);
          return pointBRInside_;
        }
      };

      auto pointTLInside = [this, &pointTLInside_, &pointTL]() {
        static MFloat lastPoint[3] = {MFloatNaN, MFloatNaN, MFloatNaN};
        if(std::equal(&pointTL[0], &pointTL[0] + nDim, &lastPoint[0])) {
          return pointTLInside_;
        } else {
          pointTLInside_ = m_solver->m_geometry->pointIsInside2(pointTL);
          std::copy_n(&pointTL[0], nDim, &lastPoint[0]);
          return pointTLInside_;
        }
      };


      //##start of bndryRfnJumpMethod part

      // stencil to determin in which cell-corner the Point, BR or TL corner of the face is
      const MInt BRInCorner[6] = {2, 3, 4, 6, 1, 5};
      const MInt TLInCorner[6] = {4, 5, 1, 3, 2, 6};
      const MInt pointInCorner[6] = {0, 1, 0, 2, 0, 4};
      const MInt oppositeInCorner[6] = {6, 7, 5, 7, 3, 7};
      /*! \page propertiesFV
        \section bndryRfnJump
        <code>void FvBndryCnd3D::createCutFace</code>\n
        default = <code>0</code>\n \n
        This trigger enables a cut point correction for grid refinement jumps along boundaries.
        Split cells and multiple ghost cells are not supported.
        Possible values are:
        <ul>
        <li>0: deactivated</li>
        <li>1: activated</li>
        </ul>
        Keywords: <i>CUT_POINTS, BOUNDARY_REFINEMENT</i>
      */
      // TODO labels:FV move property to initialization
      MBool bndryRfnJump = false;
      bndryRfnJump = Context::getSolverProperty<MBool>("bndryRfnJump", m_solverId, AT_, &bndryRfnJump);

      if(bndryRfnJump == 1) {
        // change if the point is inside or not
        if(m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] == face
           || m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 2] == face
           || m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 3] == face) {
          if(m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 1] == BRInCorner[face]) {
            if(pointBRInside() == false) {
              pointBRInside_ = true;
            } else {
              pointBRInside_ = false;
            }
          }
          if(m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 1] == TLInCorner[face]) {
            if(pointTLInside() == false) {
              pointTLInside_ = true;
            } else {
              pointTLInside_ = false;
            }
          }
          if(m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 1] == pointInCorner[face]) {
            if(pointInside == false) {
              pointInside = true;
            } else {
              pointInside = false;
            }
          }
        }
      }
      //##end of bndryRfnJumpMethodPart


      faceCentroid[face * nDim + spaceId] = point[spaceId];

      if(n == 2) {
        // delta of cut point coordinates, sign of the cut line slope
        for(MInt i = 0; i < nDim; i++) {
          delta[face * nDim + i] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoint[0]][i]
                                   - m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoint[1]][i];
        }
        if(delta[nDimFaceSpaceId1] * delta[nDimFaceSpaceId2] > 0) {
          positiveSlope = true;
        } else {
          positiveSlope = false;
        }

        for(MInt i = 0; i < nDim; i++) {
          delta[face * nDim + i] = fabs(delta[face * nDim + i]);
        }

        // compute the length of the cut line
        cutLineLength[face] = sqrt(POW2(delta[nDimFaceSpaceId1]) + POW2(delta[nDimFaceSpaceId2]));

        // compute the coordinates of the cut line centroid
        for(MInt i = 0; i < nDim; i++) {
          cutLineCentroid[face * nDim + i] =
              F1B2
              * (m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoint[0]][i]
                 + m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoint[1]][i]);
        }

        // compute the volume and the normal vector of the cut face
        // assuming 2 cut points!!! (checked above)
        // space0: space Id of the first cut edge
        // space1: space Id of the second cut edge
        // *Relative: in two-dimensional space0-space1 space, either 0 or 1
        const MInt space0Relative = cutEdges[0] / 2;
        const MInt space1Relative = cutEdges[1] / 2;
        const MInt space0 = (space0Relative + spaceId + 1) % nDim;
        const MInt side0 = cutEdges[0] % 2;
        const MInt space1 = (space1Relative + spaceId + 1) % nDim;
        const MInt side1 = cutEdges[1] % 2;

        // compute the absolute values of the normal vector components
        normalVector[face * nDim + spaceId] = 0;
        normalVector[nDimFaceSpaceId1] = delta[nDimFaceSpaceId2] / cutLineLength[face];
        normalVector[nDimFaceSpaceId2] = delta[nDimFaceSpaceId1] / cutLineLength[face];


        // determine the cut geometry and compute
        //  - the volume of the boundary cell
        //  - the coordinate shift
        //  - nonFluidSides
        if(space0 != space1) {
          // 1. the cut geometry is a triangle
          faceGeometryIsTriangle[face] = true;
          faceVolume[face] = F1B2 * (delta[nDimFaceSpaceId1] * delta[nDimFaceSpaceId2]);

          trianglePoint[space0] = point[space0] + m_solver->c_cellLengthAtCell(cellId) * (MFloat)side0;
          trianglePoint[space1] = point[space1] + m_solver->c_cellLengthAtCell(cellId) * (MFloat)side1;
          trianglePoint[spaceId] = point[spaceId];

          for(MInt i = 0; i < nDim; i++) {
            trianglePointP[i] = trianglePoint[i];
            trianglePointM[i] = trianglePoint[i];
            trianglePointW[i] = trianglePoint[i];
            trianglePointE[i] = trianglePoint[i];
          }
          trianglePointP[spaceId1] += eps;
          trianglePointM[spaceId1] -= eps;
          trianglePointW[spaceId2] += eps;
          trianglePointE[spaceId2] -= eps;

          faceCentroid[face * nDim + space0] =
              trianglePoint[space0] + F2B3 * (F1B2 - (MFloat)side0) * delta[face * nDim + space0];
          faceCentroid[face * nDim + space1] =
              trianglePoint[space1] + F2B3 * (F1B2 - (MFloat)side1) * delta[face * nDim + space1];

          for(MInt i = 0; i < nDim; i++) {
            triangleCentroid[face * nDim + i] = faceCentroid[face * nDim + i];
          }

          //##start of bndryRfnJumpMethodPart
          MBool problemFace = false;
          if(bndryRfnJump == 1) {
            if(m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 0] == face) {
              // cerr << "we are currently on a problem face: " << face << endl;
              // cerr << "cellId: " << cellId << endl;
              problemFace = true;
            }
            // in case of removed cut points
            if(m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 2] == face) {
              // cerr << "we are currently on a problem face: " << face << endl;
              // cerr << "cellId: " << cellId << endl;
              problemFace = true;
            }
            // in case of new boundary cell
            if(m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 3] == face) {
              // cerr << "we are currently on a problem face: " << face << endl;
              // cerr << "cellId: " << cellId << endl;
              problemFace = true;
            }
          }
          MInt triangleCase = -1;
          MBool trianglePointInside = false;
          if(bndryRfnJump == 1) {
            if(m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 1] != -1) {
              if(trianglePoint[0] - point[0] < eps && trianglePoint[1] - point[1] < eps
                 && trianglePoint[2] - point[2] < eps) {
                // cerr << "triangle point is the same as point" << endl;
                triangleCase = 0;
                trianglePointInside = pointInside;
              }
              if(trianglePoint[0] - pointBR[0] < eps && trianglePoint[1] - pointBR[1] < eps
                 && trianglePoint[2] - pointBR[2] < eps && triangleCase == -1) {
                // cerr << "triangle point is the same as pointBR" << endl;
                triangleCase = 1;
                trianglePointInside = pointBRInside();
              }
              if(trianglePoint[0] - pointTL[0] < eps && trianglePoint[1] - pointTL[1] < eps
                 && trianglePoint[2] - pointTL[2] < eps && triangleCase == -1) {
                // cerr << "triangle point is the same as point" << endl;
                triangleCase = 2;
                trianglePointInside = pointTLInside();
              }
              if(triangleCase == -1) {
                // cerr << "triangle point is different from the 3 other points" << endl;
                triangleCase = 3;
                trianglePointInside = m_solver->m_geometry->pointIsInside2(trianglePoint);
                // cerr << "before: " << trianglePointInside << endl;
                if(oppositeInCorner[face]
                   == m_solver->m_bndryRfnJumpInformation[m_bndryCells->a[bndryId].m_cellId * 4 + 1]) {
                  trianglePointInside = 1 - trianglePointInside;
                }
                // cerr << "after: " << trianglePointInside << endl;
              }
            }
          }
          if(problemFace == true) {
            // cerr << "triangle case: " << triangleCase << endl;
            // check if the third triangle point is inside or outside
            // if( m_solver->m_geometry->pointIsInside2( trianglePoint ) )
            if(trianglePointInside == false) {
              // computed volume is the boundary cell volume
              noNonFluidEdges[face] = 2;
              nonFluidSideEdge[edgeCode[4 * face + 2 * space0Relative + ((side0 + 1) % 2)]] = true;
              nonFluidSideEdge[edgeCode[4 * face + 2 * space1Relative + ((side1 + 1) % 2)]] = true;

            } else {
              // computed volume is inside the geometry and cut out
              shapeIsInside[face] = true;
              cutOutVolume = faceVolume[face];
              faceVolume[face] = gridFaceVolume[face] - faceVolume[face];
              faceCentroid[face * nDim + space0] = F1 / faceVolume[face]
                                                   * ((gridFaceVolume[face] * m_solver->a_coordinate(cellId, space0))
                                                      - (cutOutVolume * faceCentroid[face * nDim + space0]));
              faceCentroid[face * nDim + space1] = F1 / faceVolume[face]
                                                   * ((gridFaceVolume[face] * m_solver->a_coordinate(cellId, space1))
                                                      - (cutOutVolume * faceCentroid[face * nDim + space1]));

              // no non-fluid edge
              noNonFluidEdges[face] = 0;
              // DEBUG (not required)
              for(MInt e = 0; e < 4; e++) {
                if(nonFluidSideEdge[edgeCode[4 * face + e]]) {
                  cerr << "triangle case: " << triangleCase << endl;
                  for(MInt i = 0; i < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; i++) {
                    cerr << "cut point: " << i << " cut edge: " << m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[i]
                         << endl;
                  }
                  cerr << cellId << " " << bndryId << endl;
                  cerr << "Error non-fluid edge was true for edge " << edgeCode[4 * face + e] << " face " << face
                       << endl;
                  cerr << "All face data " << noNonFluidEdges[0] << noNonFluidEdges[1] << noNonFluidEdges[2]
                       << noNonFluidEdges[3] << noNonFluidEdges[4] << noNonFluidEdges[5] << endl;
                  cerr << "All edge data " << nonFluidSideEdge[edgeCode[0]] << nonFluidSideEdge[edgeCode[1]]
                       << nonFluidSideEdge[edgeCode[2]] << nonFluidSideEdge[edgeCode[3]] << " "
                       << nonFluidSideEdge[edgeCode[4]] << nonFluidSideEdge[edgeCode[5]]
                       << nonFluidSideEdge[edgeCode[6]] << nonFluidSideEdge[edgeCode[7]] << " "
                       << nonFluidSideEdge[edgeCode[8]] << nonFluidSideEdge[edgeCode[9]]
                       << nonFluidSideEdge[edgeCode[10]] << nonFluidSideEdge[edgeCode[11]] << endl;
                  cerr << "cell " << cellId << " domain " << domainId() << " "
                       << "bndryId " << bndryId << " " << m_solver->a_coordinate(cellId, 0) << " "
                       << m_solver->a_coordinate(cellId, 1) << " " << m_solver->a_coordinate(cellId, 2) << endl;
                  cerr << " " << endl;
                }
                nonFluidSideEdge[edgeCode[4 * face + e]] = false;
              }
            }
          }
          if(problemFace == false) {
            //##end of bndryRfnJumpMethodPart
            // check if the third triangle point is inside or outside
            if(m_solver->m_geometry->pointIsInside2(trianglePoint)) {
              // computed volume is inside the geometry and cut out
              shapeIsInside[face] = true;
              cutOutVolume = faceVolume[face];
              faceVolume[face] = gridFaceVolume[face] - faceVolume[face];
              faceCentroid[face * nDim + space0] = F1 / faceVolume[face]
                                                   * ((gridFaceVolume[face] * m_solver->a_coordinate(cellId, space0))
                                                      - (cutOutVolume * faceCentroid[face * nDim + space0]));
              faceCentroid[face * nDim + space1] = F1 / faceVolume[face]
                                                   * ((gridFaceVolume[face] * m_solver->a_coordinate(cellId, space1))
                                                      - (cutOutVolume * faceCentroid[face * nDim + space1]));

              // no non-fluid edge
              noNonFluidEdges[face] = 0;
              // DEBUG (not required)
              for(MInt e = 0; e < 4; e++) {
                if(nonFluidSideEdge[edgeCode[4 * face + e]]) {
                  cerr << cellId << " " << bndryId << endl;
                  cerr << "Error non-fluid edge was true for edge " << edgeCode[4 * face + e] << " face " << face
                       << endl;
                  cerr << "All face data " << noNonFluidEdges[0] << noNonFluidEdges[1] << noNonFluidEdges[2]
                       << noNonFluidEdges[3] << noNonFluidEdges[4] << noNonFluidEdges[5] << endl;
                  cerr << "All edge data " << nonFluidSideEdge[edgeCode[0]] << nonFluidSideEdge[edgeCode[1]]
                       << nonFluidSideEdge[edgeCode[2]] << nonFluidSideEdge[edgeCode[3]] << " "
                       << nonFluidSideEdge[edgeCode[4]] << nonFluidSideEdge[edgeCode[5]]
                       << nonFluidSideEdge[edgeCode[6]] << nonFluidSideEdge[edgeCode[7]] << " "
                       << nonFluidSideEdge[edgeCode[8]] << nonFluidSideEdge[edgeCode[9]]
                       << nonFluidSideEdge[edgeCode[10]] << nonFluidSideEdge[edgeCode[11]] << endl;
                  cerr << "cell " << cellId << " domain " << domainId() << " "
                       << "bndryId " << bndryId << " " << m_solver->a_coordinate(cellId, 0) << " "
                       << m_solver->a_coordinate(cellId, 1) << " " << m_solver->a_coordinate(cellId, 2) << endl;
                  cerr << " " << endl;
                  cerr << "triangle case: " << triangleCase << endl;
                  for(MInt i = 0; i < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; i++) {
                    cerr << "cut point: " << i << " cut edge: " << m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[i]
                         << endl;
                  }
                }
                nonFluidSideEdge[edgeCode[4 * face + e]] = false;
              }

            } else {
              // computed volume is the boundary cell volume
              noNonFluidEdges[face] = 2;
              nonFluidSideEdge[edgeCode[4 * face + 2 * space0Relative + ((side0 + 1) % 2)]] = true;
              nonFluidSideEdge[edgeCode[4 * face + 2 * space1Relative + ((side1 + 1) % 2)]] = true;
            }
          } // belongs to bndryRfnJumpMethodPart switch
          // determine the sign of the normal vector components
          if(!pointInside) {
            if(pointTLInside()) {
              if(pointBRInside()) {
                // bottom right corner is inside the geometry
                normalVector[nDimFaceSpaceId1] = -normalVector[nDimFaceSpaceId1];
                normalVector[nDimFaceSpaceId2] = -normalVector[nDimFaceSpaceId2];
              } else {
                // top left corner is inside the geometry
                normalVector[nDimFaceSpaceId2] = -normalVector[nDimFaceSpaceId2];
              }
            } else {
              if(pointBRInside()) {
                // bottom right corner is inside the geometry
                normalVector[nDimFaceSpaceId1] = -normalVector[nDimFaceSpaceId1];
              } else {
                // top right corner is inside the geometry
                normalVector[nDimFaceSpaceId1] = -normalVector[nDimFaceSpaceId1];
                normalVector[nDimFaceSpaceId2] = -normalVector[nDimFaceSpaceId2];
              }
            }
          } else {
            if(pointTLInside()) {
              if(pointBRInside()) {
                // top right corner is outside the geometry
              } else {
                // bottom right corner is outside the geometry
                normalVector[nDimFaceSpaceId2] = -normalVector[nDimFaceSpaceId2];
              }
            } else {
              if(pointBRInside()) {
                // top left corner is outside the geometry
                normalVector[nDimFaceSpaceId1] = -normalVector[nDimFaceSpaceId1];
              } else {
                // bottom left corner is inside the geometry
              }
            }
          }
        } else {
          // 2. the cut geometry is a trapezoid
          noNonFluidEdges[face] = 1;
          if(space0 == spaceId1) {
            // 2.a) the cut face is along the x_spaceId1 coordinate
            faceVolume[face] =
                m_solver->c_cellLengthAtCell(cellId) * (cutLineCentroid[nDimFaceSpaceId2] - point[spaceId2]);

            // check if point is inside or outside
            if(pointInside) {
              faceVolume[face] = gridFaceVolume[face] - faceVolume[face];
              nonFluidSideEdge[edgeCode[4 * face + 2]] = true;
              // * compute boundary cell center
              // * set signs of the normal vector
              //    - x_0 sign according to the slope (+/-,-/+)
              //    - x_1 sign is positive
              const MFloat maxY = cutLineCentroid[nDimFaceSpaceId2] + F1B2 * delta[nDimFaceSpaceId2];
              cc0[0] = m_solver->a_coordinate(cellId, spaceId1);
              cc0[1] = F1B2 * (oppositePoint[spaceId2] + maxY);
              if(positiveSlope) {
                cc1[0] = point[spaceId1] + F1B3 * m_solver->c_cellLengthAtCell(cellId);
                normalVector[nDimFaceSpaceId1] = -normalVector[nDimFaceSpaceId1];
              } else {
                cc1[0] = point[spaceId1] + F2B3 * m_solver->c_cellLengthAtCell(cellId);
              }
              cc1[1] = maxY - F1B3 * delta[nDimFaceSpaceId2];
              rectVolume = (oppositePoint[spaceId2] - maxY) * m_solver->c_cellLengthAtCell(cellId);
              triVolume = faceVolume[face] - rectVolume;
            } else {
              nonFluidSideEdge[edgeCode[4 * face + 3]] = true;
              // * compute boundary cell center
              // * set signs of the normal vector
              //    - x_0 sign according to the slope (+/+,-/-)
              //    - x_1 sign is negative
              normalVector[nDimFaceSpaceId2] = -normalVector[nDimFaceSpaceId2];
              const MFloat minY = cutLineCentroid[nDimFaceSpaceId2] - F1B2 * delta[nDimFaceSpaceId2];
              cc0[0] = m_solver->a_coordinate(cellId, spaceId1);
              cc0[1] = F1B2 * (point[spaceId2] + minY);
              if(positiveSlope) {
                cc1[0] = point[spaceId1] + F2B3 * m_solver->c_cellLengthAtCell(cellId);
              } else {
                normalVector[nDimFaceSpaceId1] = -normalVector[nDimFaceSpaceId1];
                cc1[0] = point[spaceId1] + F1B3 * m_solver->c_cellLengthAtCell(cellId);
              }
              cc1[1] = minY + F1B3 * delta[nDimFaceSpaceId2];
              rectVolume = (minY - point[spaceId2]) * m_solver->c_cellLengthAtCell(cellId);
              triVolume = faceVolume[face] - rectVolume;
            }
          } else {
            // 2.b) the cut face is along the x_spaceId2 coordinate
            faceVolume[face] =
                m_solver->c_cellLengthAtCell(cellId) * (cutLineCentroid[nDimFaceSpaceId1] - point[spaceId1]);

            // check if point is inside or outside
            if(pointInside) {
              faceVolume[face] = gridFaceVolume[face] - faceVolume[face];
              nonFluidSideEdge[edgeCode[4 * face]] = true;
              // * compute boundary cell center
              // * set signs of the normal vector
              //    - x_0 sign is positive
              //    - x_1 sign according to the slope (+/-,-/+)
              const MFloat maxX = cutLineCentroid[nDimFaceSpaceId1] + F1B2 * delta[nDimFaceSpaceId1];
              cc0[0] = F1B2 * (oppositePoint[spaceId1] + maxX);
              cc0[1] = m_solver->a_coordinate(cellId, spaceId2);
              cc1[0] = maxX - F1B3 * delta[nDimFaceSpaceId1];
              if(positiveSlope) {
                normalVector[nDimFaceSpaceId2] = -normalVector[nDimFaceSpaceId2];
                cc1[1] = point[spaceId2] + F1B3 * m_solver->c_cellLengthAtCell(cellId);
              } else {
                cc1[1] = point[spaceId2] + F2B3 * m_solver->c_cellLengthAtCell(cellId);
              }
              rectVolume = (oppositePoint[spaceId1] - maxX) * m_solver->c_cellLengthAtCell(cellId);
              triVolume = faceVolume[face] - rectVolume;
            } else {
              nonFluidSideEdge[edgeCode[4 * face + 1]] = true;
              // * compute boundary cell center
              // * set signs of the normal vector
              //    - x_0 sign is negative
              //    - x_1 sign according to the slope (+/+,-/-)
              normalVector[nDimFaceSpaceId1] = -normalVector[nDimFaceSpaceId1];
              const MFloat minX = cutLineCentroid[nDimFaceSpaceId1] - F1B2 * delta[nDimFaceSpaceId1];
              cc0[0] = F1B2 * (point[spaceId1] + minX);
              cc0[1] = m_solver->a_coordinate(cellId, spaceId2);
              cc1[0] = minX + F1B3 * delta[nDimFaceSpaceId1];
              if(positiveSlope) {
                cc1[1] = point[spaceId2] + F2B3 * m_solver->c_cellLengthAtCell(cellId);
              } else {
                normalVector[nDimFaceSpaceId2] = -normalVector[nDimFaceSpaceId2];
                cc1[1] = point[spaceId2] + F1B3 * m_solver->c_cellLengthAtCell(cellId);
              }
              rectVolume = (minX - point[spaceId1]) * m_solver->c_cellLengthAtCell(cellId);
              triVolume = faceVolume[face] - rectVolume;
            }
          }

          faceCentroid[nDimFaceSpaceId1] = (rectVolume * cc0[0] + triVolume * cc1[0]) / faceVolume[face];
          faceCentroid[nDimFaceSpaceId2] = (rectVolume * cc0[1] + triVolume * cc1[1]) / faceVolume[face];
        }

        // face data is assembled
        // create a surface for the cut face if a boundary cell neighbor exists
        MBool createSrfc = true;

        MInt nghbrId = -1;
        if(m_solver->a_hasNeighbor(cellId, face) > 0) {
          nghbrId = m_solver->c_neighborId(cellId, face);
        } else {
          if(m_solver->c_parentId(cellId) > -1) {
            if(m_solver->a_hasNeighbor(m_solver->c_parentId(cellId), face) > 0)
              nghbrId = m_solver->c_neighborId(m_solver->c_parentId(cellId), face);
            else
              createSrfc = false;
          } else
            createSrfc = false;
        }
        if(createSrfc)
          if(m_solver->c_noChildren(nghbrId) > 0) createSrfc = false;
        if(createSrfc) {
          const MInt otherSideId = (sideId + 1) % 2;
          const MInt srfcId = m_solver->a_noSurfaces();
          m_surfaces.append();
          m_solver->a_surfaceOrientation(srfcId) = spaceId;
          m_solver->a_surfaceNghbrCellId(srfcId, sideId) = nghbrId;
          m_solver->a_surfaceNghbrCellId(srfcId, otherSideId) = cellId;
          for(MInt i = 0; i < nDim; i++) {
            m_solver->a_surfaceCoordinate(srfcId, i) = faceCentroid[face * nDim + i];
          }
          m_solver->a_surfaceArea(srfcId) = faceVolume[face];
          m_bndryCells->a[bndryId].m_associatedSrfc[face] = srfcId;
        }

      } else {
        // set the nonFluidSideEdge flag
        // none of the face edges is cut
        if(pointInside) {
          for(MInt e = 0; e < 4; e++) {
            nonFluidSideEdge[edgeCode[4 * face + e]] = true;
          }
        }
      }
    }


    // from here on the whole control volume is concerned

    // II.
    // --
    //    set the non fluid side Ids
    for(MInt face = 0; face < m_noDirs; face++) {
      MBool nonFluidSide = true;
      for(MInt e = 0; e < 4; e++) {
        if(!nonFluidSideEdge[edgeCode[4 * face + e]]) {
          nonFluidSide = false;
          break;
        }
      }
      if(nonFluidSide) {
        m_bndryCells->a[bndryId].m_externalFaces[face] = true;
        faceVolume[face] = F0;
      }
    }

    // III.
    // --
    //    determine the 3D cell geometry
    switch(noCutFaces) {
      case 0: {
        cerr << "case 0 " << endl;
        cerr << m_solver->a_coordinate(cellId, 0) << " " << m_solver->a_coordinate(cellId, 1) << " "
             << m_solver->a_coordinate(cellId, 2) << " " << F1B2 * m_solver->c_cellLengthAtCell(cellId) << " "
             << m_solver->a_level(cellId) << endl;
        mTerm(1, AT_, "case 0");
      }

      case 3: {
        // III. 1.
        // the cut geometry is a tetraeder

        // find the cut sides
        face0 = -1;
        face1 = -1;
        for(MInt face = 0; face < m_noDirs; face++) {
          if(cutFaces[face]) {
            if(face0 == -1) {
              face0 = face;
            } else {
              if(face1 == -1) face1 = face;
            }
          }
        }
        edgeCounter = 0;
        // find the two cut edges of face0
        for(MInt e = 0; e < 4; e++) {
          cutEdges[e] = 0;
          if(cutEdgesAll[edgeCode[4 * face0 + e]]) {
            cutEdges[edgeCounter] = e;
            edgeCounter++;
          }
        }

        // DEBUG
        if(edgeCounter != 2) cerr << "ERROR create cut face, tetraeter shape, not enough cut edges" << endl;
        // find the remaining cut edge (face1)
        for(MInt e = 0; e < 4; e++) {
          if(cutEdgesAll[edgeCode[4 * face1 + e]]) {
            if(faceCode[2 * edgeCode[4 * face1 + e]] != face0 && faceCode[2 * edgeCode[4 * face1 + e] + 1] != face0) {
              cutEdges[2] = e;
            }
          }
        }

        // determine the cut point on the remaining cut edge
        for(MInt cp = 0; cp < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cp++) {
          if(m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cp] == edgeCode[4 * face1 + cutEdges[2]]) {
            cutPoint[0] = cp;
          }
        }

        const MInt face0Space = face0 / 2;
        const MInt face0Side = face0 % 2;

        // determine the center and the volume of the tetraeder
        // center of the triangle
        for(MInt i = 0; i < nDim; i++) {
          m_bndryCells->a[bndryId].m_coordinates[i] =
              F3B4 * triangleCentroid[face0 * nDim + i]
              + F1B4 * m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoint[0]][i];
        }

        // volume
        const MFloat h = F2 * (F1B2 - (MFloat)face0Side)
                         * (m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoint[0]][face0Space]
                            - (negativePoint[face0Space] + (MFloat)face0Side * m_solver->c_cellLengthAtCell(cellId)));
        if(shapeIsInside[face0]) {
          m_bndryCells->a[bndryId].m_volume = F1B3 * (gridFaceVolume[face0] - faceVolume[face0]) * h;
        } else {
          m_bndryCells->a[bndryId].m_volume = F1B3 * faceVolume[face0] * h;
        }

        // correct the volume and the cell center of the reshaped cell if the geometry is cut out
        if(shapeIsInside[face0]) {
          cutOutVolume = m_bndryCells->a[bndryId].m_volume;
          m_bndryCells->a[bndryId].m_volume =
              m_solver->grid().gridCellVolume(m_solver->a_level(cellId)) - m_bndryCells->a[bndryId].m_volume;
          for(MInt i = 0; i < nDim; i++) {
            m_bndryCells->a[bndryId].m_coordinates[i] =
                F1 / m_bndryCells->a[bndryId].m_volume
                * (m_solver->grid().gridCellVolume(m_solver->a_level(cellId)) * m_solver->a_coordinate(cellId, i)
                   - cutOutVolume * m_bndryCells->a[bndryId].m_coordinates[i]);
          }
        }
        // compute the coordinate shift
        for(MInt i = 0; i < nDim; i++) {
          m_bndryCells->a[bndryId].m_coordinates[i] -= m_solver->a_coordinate(cellId, i);
        }

        // compute the cut surface area (store surface components in the normal vector member)
        for(MInt i = 0; i < nDim; i++) {
          m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i] = faceVolume[2 * i + 1] - faceVolume[2 * i];
        }
        m_bndryCells->a[bndryId].m_srfcs[0]->m_area =
            sqrt(POW2(m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[0])
                 + POW2(m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[1])
                 + POW2(m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[2]));

        // compute the normal vector
        for(MInt i = 0; i < nDim; i++) {
          m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i] =
              m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i] / m_bndryCells->a[bndryId].m_srfcs[0]->m_area;
        }

        // compute the cut surface centroid
        for(MInt i = 0; i < nDim; i++) {
          m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[i] =
              F2B3 * cutLineCentroid[face0 * nDim + i]
              + F1B3 * m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoint[0]][i];
        }
        break;
      }
      case 4:
      case 5:
      case 6: {
        // III. 2.

        // find a pair of opposite cut sides (the one with the largest area)
        cutLineLength[6] = F0;
        for(MInt face = 0; face < m_noDirs; face += 2) {
          if(cutFaces[face]) {
            if(cutFaces[face + 1]) {
              cutLineLength[7] = cutLineLength[face] + cutLineLength[face + 1];
              if(cutLineLength[7] > cutLineLength[6]) {
                face0 = face;
                face1 = face + 1;
                cutLineLength[6] = cutLineLength[7];
              }
            }
          }
        }

        const MInt spaceId = face0 / 2;
        const MInt spaceId1 = (spaceId + 1) % nDim;
        const MInt spaceId2 = (spaceId1 + 1) % nDim;

        // compute the new cell center
        //   coordinate spaceId1 and Id2
        const MFloat Fvol = F1 / (faceVolume[face0] + faceVolume[face1]);
        const MFloat dA = faceVolume[face1] - faceVolume[face0];
        dfcc[0] = faceCentroid[face1 * nDim + spaceId1] - faceCentroid[face0 * nDim + spaceId1];
        dfcc[1] = faceCentroid[face1 * nDim + spaceId2] - faceCentroid[face0 * nDim + spaceId2];

        m_bndryCells->a[bndryId].m_coordinates[spaceId] =
            faceCentroid[face0 * nDim + spaceId]
            + F1B3 * (F1 + Fvol * faceVolume[face1]) * m_solver->c_cellLengthAtCell(cellId);
        m_bndryCells->a[bndryId].m_coordinates[spaceId1] =
            F2 * Fvol
            * (faceVolume[face0] * faceCentroid[face0 * nDim + spaceId1]
               + F1B2 * (faceVolume[face0] * dfcc[0] + dA * faceCentroid[face0 * nDim + spaceId1])
               + F1B3 * dA * dfcc[0]);
        m_bndryCells->a[bndryId].m_coordinates[spaceId2] =
            F2 * Fvol
            * (faceVolume[face0] * faceCentroid[face0 * nDim + spaceId2]
               + F1B2 * (faceVolume[face0] * dfcc[1] + dA * faceCentroid[face0 * nDim + spaceId2])
               + F1B3 * dA * dfcc[1]);

        for(MInt i = 0; i < nDim; i++) {
          m_bndryCells->a[bndryId].m_coordinates[i] -= m_solver->a_coordinate(cellId, i);
        }

        // compute the cut surface area (store surface components in the normal vector member)
        for(MInt i = 0; i < nDim; i++) {
          m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i] = faceVolume[2 * i + 1] - faceVolume[2 * i];
        }
        m_bndryCells->a[bndryId].m_srfcs[0]->m_area =
            sqrt(POW2(m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[0])
                 + POW2(m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[1])
                 + POW2(m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[2]));

        // compute the normal vector
        for(MInt i = 0; i < nDim; i++) {
          m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i] =
              m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i] / m_bndryCells->a[bndryId].m_srfcs[0]->m_area;
        }

        // compute the cut surface centroid
        for(MInt i = 0; i < nDim; i++) {
          m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[i] =
              F1B2 * (cutLineCentroid[face0 * nDim + i] + cutLineCentroid[face1 * nDim + i]);
        }

        // compute the boundary cell volume using Gauss theorem
        m_bndryCells->a[bndryId].m_volume =
            -F1B3
            * (faceVolume[0] * faceCentroid[0 * nDim + 0] - faceVolume[1] * faceCentroid[1 * nDim + 0]
               + faceVolume[2] * faceCentroid[2 * nDim + 1] - faceVolume[3] * faceCentroid[3 * nDim + 1]
               + faceVolume[4] * faceCentroid[4 * nDim + 2] - faceVolume[5] * faceCentroid[5 * nDim + 2]
               + m_bndryCells->a[bndryId].m_srfcs[0]->m_area
                     * (m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[0]
                            * m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[0]
                        + m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[1]
                              * m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[1]
                        + m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[2]
                              * m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[2]));


        break;
      }
      default: {
        cerr << "this case has not yet been implemented" << endl;
        cerr << "cell " << cellId << endl;
        cerr << "coordinates"
             << " " << m_solver->a_coordinate(cellId, 0) << " " << m_solver->a_coordinate(cellId, 1) << " "
             << m_solver->a_coordinate(cellId, 2) << endl;
        cerr << "number of cut faces: " << noCutFaces << endl;
        mTerm(1, AT_, "this case has not yet been implemented");
      }
    }
  }
}


////////////////////////////////////////////////////////////////////////////////
/// ONLY 3D VERSIONS
////////////////////////////////////////////////////////////////////////////////
/** \brief recomputes the cut cells based on the cut points on the cell edges - MGC version
 *
 * computes the following boundary cell member variables:
 * 2 cut points are assumed for each cell face
 * multiple boundary cut faces are allowed
 *  - m_noSrfcs
 *  - m_srfcs[srfc]->m_area
 *  - m_srfcs[srfc]->m_coordinates
 *  - m_srfcs[srfc]->m_volume
 *  - m_srfcs[srfc]->m_normalVector
 *  - m_externalFaces
 *
 * cell structure is determined by using a modified marching cubes approach
 * (see e.g. Evgeni V. Chernyaev, Marching Cubes 33 and further publications)
 * uses fvlookuptable.h
 *
 * extended version of createCutFaceMG() method which is able to handle split cells
 * and ambiguous cell configurations correctly.
 *
 * \author Claudia Guenther, Feb 2009
 *
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::createCutFaceMGC() {
  TRACE();

  static constexpr MInt cornerIndices[8][3] = {{-1, -1, -1}, {1, -1, -1}, {-1, 1, -1}, {1, 1, -1},
                                               {-1, -1, 1},  {1, -1, 1},  {-1, 1, 1},  {1, 1, 1}};
  // the following variables describe the different corner/edge/face numbering in MAIA and MarchingCubes table
  static constexpr MInt cornersMCtoSOLVER[8] = {2, 0, 1, 3, 6, 4, 5, 7};
  static constexpr MInt cornersSOLVERtoMC[8] = {1, 2, 0, 3, 5, 6, 4, 7};
  static constexpr MInt edgesMCtoSOLVER[12] = {0, 2, 1, 3, 4, 6, 5, 7, 10, 8, 9, 11};
  static constexpr MInt facesMCtoSOLVER[6] = {0, 2, 1, 3, 4, 5};
  static constexpr MInt neighborCorner[6] = {1, -1, 2, -2, 4, -4};
  static constexpr MInt cornerFaceMapping[24] = {0, 2, 4, 1, 2, 4, 0, 3, 4, 1, 3, 4,
                                                 0, 2, 5, 1, 2, 5, 0, 3, 5, 1, 3, 5};
  static constexpr MInt faceCornerMapping[24] = {0, 2, 4, 6, 1, 3, 5, 7, 0, 1, 4, 5,
                                                 2, 3, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7};

  unsigned char outcode_MC = 0;
  MInt noCells = m_bndryCells->size();
  MInt cellId;
  MFloat gridCellVolume;
  MFloat corner[8][3] = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}};
  MInt currentCase;
  MInt presentCases[15] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  MInt* presentSubCases[15];
  const MInt maxNoSubCases = 48;
  MIntScratchSpace presentSubCases_scratch(15 * maxNoSubCases, AT_, "presentSubCases_scratch");
  for(MInt i = 0; i < 15; i++)
    presentSubCases[i] = &presentSubCases_scratch.p[maxNoSubCases * i];
  for(MInt i = 0; i < 15; i++) {
    for(MInt j = 0; j < maxNoSubCases; j++) {
      presentSubCases[i][j] = 0;
    }
  }
  MBool currentOutcode = false;
  MInt nghbrId;
  MInt sideId;
  MInt otherSideId;
  MInt srfcId;
  MInt spaceId;
  MFloat* faceCentroid[6];
  MFloatScratchSpace faceCentroid_scratch(nDim * 6, AT_, "faceCentroid_scratch");
  for(MInt i = 0; i < 6; i++)
    faceCentroid[i] = &faceCentroid_scratch.p[i * nDim];
  MFloat* faceCentroid_0[6];
  MFloatScratchSpace faceCentroid_0_scratch(nDim * 6, AT_, "faceCentroid_0_scratch");
  for(MInt i = 0; i < 6; i++)
    faceCentroid_0[i] = &faceCentroid_0_scratch.p[i * nDim];
  MFloat* faceCentroid_00[6];
  MFloatScratchSpace faceCentroid_00_scratch(nDim * 6, AT_, "faceCentroid_00_scratch");
  for(MInt i = 0; i < 6; i++)
    faceCentroid_00[i] = &faceCentroid_00_scratch.p[i * nDim];
  MFloat* normal[6];
  MFloatScratchSpace normal_scratch(nDim * 6, AT_, "normal_scratch");
  for(MInt i = 0; i < 6; i++)
    normal[i] = &normal_scratch.p[i * nDim];
  const MInt maxNoPyramids = 13;
  MFloat* pyraCentroid[maxNoPyramids];
  MFloatScratchSpace pyraCentroid_scratch(nDim * maxNoPyramids, AT_, "pyraCentroid_scratch");
  for(MInt i = 0; i < maxNoPyramids; i++)
    pyraCentroid[i] = &pyraCentroid_scratch.p[i * nDim];
  MFloatScratchSpace faceVolume_scratch(F2 * m_noDirs, AT_, "faceVolume_scratch");
  MFloat* faceVolume = faceVolume_scratch.getPointer();
  MFloatScratchSpace pyraVolume_scratch(maxNoPyramids, AT_, "pyraVolume_scratch");
  MFloat* pyraVolume = pyraVolume_scratch.getPointer();
  MFloatScratchSpace faceVolume_0_scratch(F2 * m_noDirs, AT_, "faceVolume_0_scratch");
  MFloat* faceVolume_0 = faceVolume_0_scratch.getPointer();
  MFloatScratchSpace faceVolume_00_scratch(F2 * m_noDirs, AT_, "faceVolume_00_scratch");
  MFloat* faceVolume_00 = faceVolume_00_scratch.getPointer();
  MFloat cellVolume_0;
  MFloatScratchSpace cellCentroid_0_scratch(nDim, AT_, "cellCentroid_0_scratch");
  MFloat* cellCentroid_0 = cellCentroid_0_scratch.getPointer();
  MFloatScratchSpace cellCentroid_00_scratch(nDim, AT_, "cellCentroid_00_scratch");
  MInt currentSubCase;
  MInt subCaseDummy;
  MFloat* p_0;
  MFloat* p_1;
  MFloat* p_2;
  MFloat* p_3;
  MFloat* p_4;
  MFloat* p_5;
  MFloat* p_0s;
  MFloat* p_1s;
  MFloat* p_2s;
  MFloat* p_3s;
  MFloat* p_0ss;
  MFloat* p_1ss;
  MFloat* p_2ss;
  MFloat* p_3ss;
  MFloat* p_1sss;
  MFloat* p_2sss;
  MFloat* p_3sss;

  MInt splitCorner1 = -1;
  MInt splitCorner2 = -1;
  MInt splitCorner12 = -1;
  MInt splitCorner22 = -1;
  MInt cutDummy;
  MInt face1;
  MInt face2;
  MInt face3;
  MInt face4;
  MInt face5;
  MInt face6;
  MInt* facepointers[6] = {&face1, &face2, &face3, &face4, &face5, &face6};
  MInt cutPoints[12] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
  MFloatScratchSpace normalVec_c_scratch(nDim, AT_, "normalVec_c_scratch");
  MFloat* normalVec_c = normalVec_c_scratch.getPointer();
  MFloat area_c;
  MFloatScratchSpace coordinates_c_scratch(nDim, AT_, "coordinates_c_scratch");
  MFloat* coordinates_c = coordinates_c_scratch.getPointer();
  MFloat volume_C;
  MFloatScratchSpace coordinatesCell_scratch(nDim, AT_, "coordinatesCell_scratch");
  MFloat* coordinates_Cell = coordinatesCell_scratch.getPointer();
  MFloat M[3] = {0, 0, 0};
  MFloat dummy_1[3] = {0, 0, 0};
  MBool nfs_cur[6] = {false, false, false, false, false, false};
  MBool nfs_cur_0[6] = {false, false, false, false, false, false};
  MBool nfs_cur_00[6] = {false, false, false, false, false, false};
  MBool faceCut[6] = {false, false, false, false, false, false};
  MBool faceCut_0[6] = {false, false, false, false, false, false};
  MBool faceCut_00[6] = {false, false, false, false, false, false};
  MInt noFaces;
  MFloat absA;
  MFloatScratchSpace faceDiff_scratch(2 * nDim, AT_, "faceDiff_scratch");
  MFloat* faceDiff = faceDiff_scratch.getPointer();
  // 	MInt maxNoNodes = 1000; // might be necessary to increase for extremely detailed .stl geometries! See error
  // output below
  static constexpr MInt opposite[6] = {1, 0, 3, 2, 5, 4};
  MInt bndryId2 = -1, bndryId3 = -1;
  MInt cellId2 = -1, cellId3 = -1;
  MIntScratchSpace splitFace_scratch(noCells, AT_, "splitFace_scratch");
  MIntScratchSpace splitCell_scratch(noCells, AT_, "splitCell_scratch");
  MIntScratchSpace disambiguation_scratch(noCells, AT_, "disambiguation_scratch");
  MIntScratchSpace ambIds_scratch(noCells, AT_, "ambIds_scratch");
  MIntScratchSpace ambiguousCells_scratch(noCells, AT_, "ambiguousCells_scratch");
  MIntScratchSpace subCases_scratch(noCells, AT_, "subCases_scratch");
  MIntScratchSpace mcCases_scratch(noCells, AT_, "mcCases_scratch");
  MInt* splitFace = splitFace_scratch.getPointer();
  MInt* splitCell = splitCell_scratch.getPointer();
  MInt* disambiguation = disambiguation_scratch.getPointer();
  MInt* ambIds = ambIds_scratch.getPointer();
  MInt* ambiguousCells = ambiguousCells_scratch.getPointer();
  MInt* subCases = subCases_scratch.getPointer();
  MInt* mcCases = mcCases_scratch.getPointer();
  for(MInt i = 0; i < m_bndryCells->size(); i++) {
    ambiguousCells[i] = -1;
    disambiguation[i] = -1;
    ambIds[i] = -1;
    splitCell[i] = 0;
    splitFace[i] = 0;
  }
  MInt noSplitCells = 0;
  MInt noSplitFaces = 0;
  MInt noAmbiguousCells = 0;
  MInt bdAmbId;
  MInt faceTMP;
  MInt nghbrCellId;
  MInt nghbrBndryId;
  stack<MInt> ambStack;
  MFloatScratchSpace splitFaceVolume_scratch(2, AT_, "splitFaceVolume_scratch");
  MFloat* splitFaceVolume = splitFaceVolume_scratch.getPointer();
  MFloat* splitFaceCentroid[2];
  MFloatScratchSpace splitFaceCentroid_scratch(nDim * 2, AT_, "splitFaceCentroid_scratch");
  for(MInt i = 0; i < 2; i++)
    splitFaceCentroid[i] = &splitFaceCentroid_scratch.p[i * nDim];
  MFloat* splitFaceNormal[2];
  MFloatScratchSpace splitFaceNormal_scratch(nDim * 2, AT_, "splitFaceNormal_scratch");
  for(MInt i = 0; i < 2; i++)
    splitFaceNormal[i] = &splitFaceNormal_scratch.p[i * nDim];
  MFloatScratchSpace splitFaceVolume2_scratch(2, AT_, "splitFaceVolume2_scratch");
  MFloat* splitFaceVolume2 = splitFaceVolume2_scratch.getPointer();
  MFloat* splitFaceCentroid2[2];
  MFloatScratchSpace splitFaceCentroid2_scratch(nDim * 2, AT_, "splitFaceCentroid2_scratch");
  for(MInt i = 0; i < 2; i++)
    splitFaceCentroid2[i] = &splitFaceCentroid2_scratch.p[i * nDim];
  MFloat* splitFaceNormal2[2];
  MFloatScratchSpace splitFaceNormal2_scratch(nDim * 2, AT_, "splitFaceNormal2_scratch");
  for(MInt i = 0; i < 2; i++)
    splitFaceNormal2[i] = &splitFaceNormal2_scratch.p[i * nDim];
  MInt splitFaceId = -1;
  MInt splitFaceId2 = -1;
  MInt splitSurfaceIndexCounter = 2;
  MInt mcCorner;
  MBool keepNghbrs = true;
  MInt disamb_tmp = 0;
  MInt disambPointer[16][21];
  const MInt* disambPointer_dummy = nullptr;
  MIntScratchSpace levelSetCornerSigns(8, AT_, "levelSetCornerSigns");
  //--- end of initialization

  // preprocessing of each cell
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    cellId = m_bndryCells->a[bndryId].m_cellId;
    m_bndryCells->a[bndryId].m_noSrfcs = 0;
    outcode_MC = 0;

    for(MInt f = 0; f < m_noDirs; f++) {
      m_bndryCells->a[bndryId].m_externalFaces[f] = false;
    }

    if(m_solver->c_noChildren(cellId) > 0) {
      continue;
    }
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      m_bndryCells->a[bndryId].m_volume = F0;
      continue;
    }

    // 1. Determine Case/Subcase of each bndry cell
    // get In/Outcode of the corners of the voxel
    // 0 -> Corner is outside Fluid Domain
    // 1 -> Corner is inside Fluid Domain or on Boundary
    for(MInt i = 0; i < 8; i++) {
      for(MInt dim = 0; dim < nDim; dim++) {
        corner[i][dim] =
            m_solver->a_coordinate(cellId, dim) + cornerIndices[i][dim] * F1B2 * m_solver->c_cellLengthAtCell(cellId);
      }
      currentOutcode = !((MBool)m_solver->m_geometry->pointIsInside2(corner[i]));
      if(currentOutcode) outcode_MC = outcode_MC | (1 << cornersSOLVERtoMC[i]);
    }

    // Determine Case and check if case is implemented
    currentCase = (MInt)cases[outcode_MC][0];
    mcCases[bndryId] = currentCase;
    currentSubCase = (MInt)cases[outcode_MC][1];
    subCases[bndryId] = currentSubCase;
    if(!caseStatesSTL[currentCase][0]) {
      cerr << "Error in createCutFaceMGC: Case not implemented: " << currentCase << endl;
      continue;
    }

    // 2.1 Determine ambiguous cells
    disambiguation[bndryId] = -1;
    if(!caseStatesSTL[mcCases[bndryId]][1]) { // ambiguous case
      ambIds[bndryId] = noAmbiguousCells;
      ambiguousCells[noAmbiguousCells++] = bndryId;
    }
  }


  // 2.2 Prepare corner cell mapping array
  MIntScratchSpace cornerCellMapping_scratch(8 * noAmbiguousCells, AT_, "cornerCellMapping_scratch");
  MInt* cornerCellMapping = cornerCellMapping_scratch.getPointer();
  for(MInt i = 0; i < noAmbiguousCells; i++) {
    bdAmbId = ambiguousCells[i];
    cellId = m_bndryCells->a[bdAmbId].m_cellId;
    outcode_MC = 0;

    // redetermine outcode
    for(MInt j = 0; j < 8; j++) {
      for(MInt dim = 0; dim < nDim; dim++) {
        corner[j][dim] = m_solver->a_coordinate(cellId, dim)
                         + cornerIndices[j][dim] * F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId));
      }
      currentOutcode = !((MBool)m_solver->m_geometry->pointIsInside2(corner[j]));
      if(currentOutcode) outcode_MC = outcode_MC | (1 << cornersSOLVERtoMC[j]);
    }
    for(MInt j = 0; j < 8; j++) {
      mcCorner = cornersSOLVERtoMC[j];
      if(!(outcode_MC & 1 << mcCorner))
        cornerCellMapping[i * 8 + j] = -1;
      else
        cornerCellMapping[i * 8 + j] = cellId;
    }
  }

  // 3. Determine case of ambiguous cells by states of surface midpoints - new!
  for(MInt ambId = 0; ambId < noAmbiguousCells; ambId++) {
    bdAmbId = ambiguousCells[ambId];
    disambiguation[bdAmbId] = 0;
    cellId = m_bndryCells->a[bdAmbId].m_cellId;
    currentCase = mcCases[bdAmbId];
    currentSubCase = subCases[bdAmbId];

    MInt faceMax = 0;
    switch(currentCase) {
      case 3:
        faceMax = 1;
        break;
      case 4:
        m_bndryCells->a[bdAmbId].m_noSrfcs = 2;
        continue;
      case 6:
        faceMax = 1;
        break;
      case 7:
        faceMax = 3;
        break;
      case 10:
        faceMax = 2;
        break;
      case 12:
        faceMax = 2;
        break;
      default: {
        stringstream errorMessage;
        errorMessage << " Error in FvBndryCnd3D::createCutFaceMGC: cell in ambigous cells does not have an "
                        "ambiguous case... cellId: "
                     << cellId << " case: " << currentCase << " bndryId: " << bdAmbId << endl;
        writeStlFileOfCell(cellId, "errorcell.stl");
        mTerm(1, AT_, errorMessage.str());
      }
    }

    for(MInt i = 0; i < faceMax; i++) {
      // compute ambigous face centroid and check if it is fluid or solid. If fluid, choose connected, else choose
      // separated.
      switch(currentCase) {
        case 3:
          faceTMP = facesMCtoSOLVER[tiling3_1STL[currentSubCase][2 + i]];
          break;

        case 6:
          faceTMP = facesMCtoSOLVER[tiling6_1STL[currentSubCase][2 + i]];
          break;
        case 7:
          faceTMP = facesMCtoSOLVER[tiling7_1STL[currentSubCase][3 + i]];
          break;

        case 10:
          faceTMP = facesMCtoSOLVER[tiling10_1STL[currentSubCase][2 + i]];
          break;

        case 12:
          faceTMP = facesMCtoSOLVER[tiling12_1STL[currentSubCase][2 + i]];
          break;
        default: {
          stringstream errorMessage;
          errorMessage << "ERROR: Switch variable 'currentCase' with value " << currentCase << " not matching any case."
                       << endl;
          mTerm(1, AT_, errorMessage.str());
        }
      }
      nghbrCellId = m_solver->c_neighborId(cellId, faceTMP);
      if(nghbrCellId < 0 || !m_solver->a_hasNeighbor(cellId, faceTMP)) {
        stringstream errorMessage;
        errorMessage << " Error in FvBndryCnd3D::createCutFaceMGC: no neighbor in ambiguous direction... exiting."
                     << endl;
        errorMessage << " cellId: " << cellId << ", ambiguous face: " << faceTMP << endl;
        writeStlFileOfCell(cellId, "errorcell.stl");
        mTerm(1, AT_, errorMessage.str());
      }
      // compute ambiguous face centroid
      for(MInt dim = 0; dim < nDim; dim++) {
        corner[0][dim] = (m_solver->a_coordinate(cellId, dim) + m_solver->a_coordinate(nghbrCellId, dim)) * F1B2;
      }
      currentOutcode = (MBool)m_solver->m_geometry->pointIsInside2(corner[0]);

      // returns true if point is not located in fluid domain, false if it is located in the fluid domain
      if(currentOutcode) {
        disambiguation[bdAmbId] += IPOW2(faceMax - i - 1);
      }
    }
  }

  // 3.2 Determine split cell and split surface cells & count them
  for(MInt ambId = 0; ambId < noAmbiguousCells; ambId++) {
    bdAmbId = ambiguousCells[ambId];
    cellId = m_bndryCells->a[bdAmbId].m_cellId;
    currentCase = mcCases[bdAmbId];
    currentSubCase = subCases[bdAmbId];

    switch(currentCase) {
      case 3:
        if(currentSubCase < 12 && disambiguation[bdAmbId] == 1) {
          splitCell[bdAmbId] = true;
          noSplitCells++;
        } else if(currentSubCase >= 12 && disambiguation[bdAmbId] == 1) {
          splitFace[bdAmbId] = true;
          noSplitFaces++;
        }
        break;
      case 4:
        if(currentSubCase < 4) {
          splitCell[bdAmbId] = true;
          noSplitCells++;
        }
        break;
      case 6:
        if(currentSubCase < 24 && disambiguation[bdAmbId] == 1) {
          splitCell[bdAmbId] = true;
          noSplitCells++;
        } else if(currentSubCase >= 24 && disambiguation[bdAmbId] == 1) {
          splitFace[bdAmbId] = true;
          noSplitFaces++;
        }
        break;
      case 7:
        if(currentSubCase < 8) {
          switch(disambiguation[bdAmbId]) {
            case 0:
              // connected cell, no special cell
              break;
            case 1:
            case 2:
            case 4:
              splitFace[bdAmbId] = true;
              noSplitFaces++;
              break;
            case 3:
            case 5:
            case 6:
              splitCell[bdAmbId] = true;
              noSplitCells++;
              break;
            case 7:
              splitCell[bdAmbId] = true;
              noSplitCells++;
              noSplitCells++;
              break;
            default: {
              stringstream errorMessage;
              errorMessage << "ERROR: Switch variable 'disambiguation[bdAmbId]' with value " << disambiguation[bdAmbId]
                           << " not matching any case." << endl;
              mTerm(1, AT_, errorMessage.str());
            }
          }
        } else {
          switch(disambiguation[bdAmbId]) {
            case 0:
              // connected cell, no special cell
              break;
            case 1:
            case 2:
            case 4:
              splitFace[bdAmbId] = true;
              noSplitFaces++;
              break;
            case 3:
            case 5:
            case 6:
              // Here: Check how to manage split faces for cells with 2 split faces!
              splitFace[bdAmbId] = true;
              noSplitFaces++;
              noSplitFaces++;
              break;
            case 7:
              splitCell[bdAmbId] = true;
              noSplitCells++;
              break;
            default: {
              stringstream errorMessage;
              errorMessage << "ERROR: Switch variable 'disambiguation[bdAmbId]' with value " << disambiguation[bdAmbId]
                           << " not matching any case." << endl;
              mTerm(1, AT_, errorMessage.str());
            }
          }
        }
        break;
      case 10:
        if(disambiguation[bdAmbId] == 3) {
          splitCell[bdAmbId] = true;
          noSplitCells++;
        }
        if(disambiguation[bdAmbId] == 2 || disambiguation[bdAmbId] == 1) {
          stringstream errorMessage;
          errorMessage << " found case 10 cell with disambiguation " << disambiguation[bdAmbId] << " and cellId "
                       << cellId << ". This means cell is a case 10.2 cell which is not implemented. Exiting..."
                       << endl;
          mTerm(1, AT_, errorMessage.str());
        }
        break;
      case 12:
        if(disambiguation[bdAmbId] == 3) {
          splitCell[bdAmbId] = true;
          noSplitCells++;
        }
        if(disambiguation[bdAmbId] == 2 || disambiguation[bdAmbId] == 1) {
          stringstream errorMessage;
          errorMessage << " found case 12 cell with disambiguation " << disambiguation[bdAmbId] << " and cellId "
                       << cellId << ". This means cell is a case 12.2 cell which is not implemented. Exiting..."
                       << endl;
          mTerm(1, AT_, errorMessage.str());
        }
        break;
      default: {
        stringstream errorMessage;
        errorMessage << "ERROR: Switch variable 'currentCase' with value " << currentCase << " not matching any case."
                     << endl;
        mTerm(1, AT_, errorMessage.str());
      }
    }
  }

  // 3.3 Allocate space for split face information
  // index is (- m_associatedSurfaces[bndryId][face])*6 + ident for the first split surface
  // index is (- m_associatedSurfaces[bndryId][face])*6 + 3 + ident for the second split surface
  // ident = 1: srfcId in m_srfcs
  // ident = 2: corner left cell (in -dir)
  // ident = 3: corner right cell (in +dir)
  // indices 0 to 11 may not be used! First index to be stored in m_associatedSurfaces is -2!
  // split Cells: positive if cell is a split cell, link to split parent
  // split Cells: negative if cell is a split parent, -link to split child
  // split Cells: 0 if no split cell and no split parent. Check later, if cell 0 is either split cell or split parent ->
  // doof
  const MInt maxNoSplitChildrenPerCell = 3;
  mAlloc(m_splitSurfaces, (2 + noSplitFaces) * 2 * maxNoSplitChildrenPerCell, "m_splitSurfaces", -1, AT_);
  mAlloc(m_splitParents, noCells + noSplitCells, "m_splitPartents", -1, AT_);
  mAlloc(m_splitChildren, (noCells + noSplitCells) * maxNoSplitChildrenPerCell, "m_splitChildren", -1, AT_);

  // 4. Compute cut cell information
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    noFaces = 0;
    cellId = m_bndryCells->a[bndryId].m_cellId;
    gridCellVolume = m_solver->grid().gridCellVolume(m_solver->a_level(cellId));
    outcode_MC = 0;
    volume_C = 0;
    coordinates_Cell[0] = 0;
    coordinates_Cell[1] = 0;
    coordinates_Cell[2] = 0;


    // store all cut points in a separate array
    for(MInt cutPoint = 0; cutPoint < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cutPoint++) {
      cutPoints[m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cutPoint]] = cutPoint;
    }

    for(MInt i = 0; i < nDim; i++) {
      faceVolume[2 * i] = POW2(m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId)));
      faceVolume[2 * i + 1] = faceVolume[2 * i];
      for(MInt j = 0; j < 3; j++) {
        faceCentroid[2 * i][j] = m_solver->a_coordinate(cellId, j);
        faceCentroid[2 * i + 1][j] = m_solver->a_coordinate(cellId, j);
      }
      faceCentroid[2 * i][i] -= F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId));
      faceCentroid[2 * i + 1][i] += F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId));
    }

    // if cell is no leaf cell do not compute it but set variables to dummy values.
    if(!m_solver->c_isLeafCell(cellId)) {
      m_bndryCells->a[bndryId].m_volume = gridCellVolume;
      for(MInt dim = 0; dim < 3; dim++) {
        m_bndryCells->a[bndryId].m_coordinates[dim] = m_solver->a_coordinate(cellId, dim);
      }
      m_bndryCells->a[bndryId].m_noSrfcs = 0;
      m_bndryCells->a[bndryId].m_srfcs[0]->m_area = faceVolume[0];
      for(MInt dim = 0; dim < 3; dim++) {
        m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = faceCentroid[0][dim];
        m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = F1 / sqrt(F3);
      }
      for(MInt i = 0; i < nDim; i++) {
        m_bndryCells->a[bndryId].m_coordinates[i] -= m_solver->a_coordinate(cellId, i);
      }
      continue;
    }

    // 1. Compute Voxel corners
    for(MInt i = 0; i < 8; i++) {
      for(MInt dim = 0; dim < nDim; dim++) {
        corner[i][dim] = m_solver->a_coordinate(cellId, dim)
                         + cornerIndices[i][dim] * F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId));
      }
    }
    for(MInt i = 0; i < 6; i++) {
      faceCut[i] = false;
      faceCut_0[i] = false;
    }


    // 2. Determine Case and check if case is implemented and if case is unambiguous
    currentCase = mcCases[bndryId];
    presentCases[currentCase]++;
    currentSubCase = subCases[bndryId];
    presentSubCases[currentCase][currentSubCase]++;

    if(!(m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints == caseCutPoints[currentCase])) {
      cerr << "FvBndryCnd3D::createCutFaceMGC - Error: number of cut points not correct!" << endl;
      cerr << "Case: " << currentCase << " cutPointsTheory: " << caseCutPoints[currentCase]
           << " actual Cut Points: " << m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints << endl;
      cerr << "Cell level: " << m_solver->a_level(cellId) << endl;
      stringstream fileName;
      fileName << cellId << ".stl";
      writeStlFileOfCell(cellId, (fileName.str()).c_str());
      cerr << "Wrote stl-file of cell. FileName: " << (fileName.str()) << endl;
    }
    if(!caseStatesSTL[currentCase][0]) {
      cerr << "FvBndryCnd3D::createCutFaceMGC - Error: Case not implemented: " << currentCase << endl;
      cerr << "Cell level: " << m_solver->a_level(cellId) << endl;
      stringstream fileName;
      fileName << cellId << ".stl";
      writeStlFileOfCell(cellId, (fileName.str()).c_str());
      cerr << "Wrote stl-file of cell. FileName: " << (fileName.str()) << endl;
      continue;
    }


    // compute cell depending on its case and disambiguation
    if(!caseStatesSTL[currentCase][1]) {
      switch(currentCase) {
        case 3: {
          for(MInt i = 0; i < 6; i++) {
            faceVolume_0[i] = faceVolume[i];
            for(MInt j = 0; j < 3; j++) {
              faceCentroid_0[i][j] = faceCentroid[i][j];
            }
          }
          cellVolume_0 = gridCellVolume;
          for(MInt i = 0; i < 3; i++) {
            cellCentroid_0[i] = m_solver->a_coordinate(cellId, i);
          }


          if((currentSubCase < 12 && disambiguation[bndryId] == 0)
             || (currentSubCase >= 12 && disambiguation[bndryId] == 1)) { // case 3.2, 1 surface

            // compute cell without correction (no split surface, convex cell), correct later if subCase >= 12 (split
            // surface, concave cell)
            m_bndryCells->a[bndryId].m_noSrfcs = 1;

            for(MInt face = 0; face < 6; face++) {
              nfs_cur[face] = nfs3_2[currentSubCase][face];
            }
            noFaces = 5;
            p_0 = corner[cornersMCtoSOLVER[tiling3_2STL[currentSubCase][0]]];
            p_0s = corner[cornersMCtoSOLVER[tiling3_2STL[currentSubCase][1]]];

            cutDummy = edgesMCtoSOLVER[tiling3_2STL[currentSubCase][2]];
            p_1 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling3_2STL[currentSubCase][3]];
            p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling3_2STL[currentSubCase][4]];
            p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling3_2STL[currentSubCase][5]];
            p_1s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling3_2STL[currentSubCase][6]];
            p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling3_2STL[currentSubCase][7]];
            p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            face1 = facesMCtoSOLVER[tiling3_2STL[currentSubCase][8]];
            face2 = facesMCtoSOLVER[tiling3_2STL[currentSubCase][9]];
            face3 = facesMCtoSOLVER[tiling3_2STL[currentSubCase][10]];
            face4 = facesMCtoSOLVER[tiling3_2STL[currentSubCase][11]];
            face5 = facesMCtoSOLVER[tiling3_2STL[currentSubCase][12]];

            computeTri(p_0, p_1, p_2, &faceVolume[face1], faceCentroid[face1], normal[face1]);
            computeTri(p_0, p_2, p_3, &faceVolume[face2], faceCentroid[face2], normal[face2]);
            computeTri(p_0s, p_2s, p_3s, &faceVolume[face3], faceCentroid[face3], normal[face3]);
            computeTri(p_0s, p_1s, p_2s, &faceVolume[face4], faceCentroid[face4], normal[face4]);
            computePoly6(p_0, p_1, p_3s, p_0s, p_1s, p_3, &faceVolume[face5], faceCentroid[face5], normal[face5]);

            computePoly6(p_1, p_2, p_3, p_1s, p_2s, p_3s, &area_c, coordinates_c, normalVec_c);

            maia::math::vecAvg<3>(M, p_0, p_0s, p_1, p_1s, p_2, p_2s, p_3, p_3s);

            for(MInt i = 0; i < 5; i++) {
              computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                          &pyraVolume[i], pyraCentroid[i]);
            }
            computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[5], pyraCentroid[5]);

            for(MInt i = 0; i < 6; i++) {
              volume_C += pyraVolume[i];
              maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
            }
            vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

            if(currentSubCase >= 12) { // correct cell

              correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
              correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
              correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);
              correctFace(&faceVolume[face4], faceCentroid[face4], &faceVolume_0[face4], faceCentroid_0[face4]);
              p_1ss = corner[cornersMCtoSOLVER[tiling3_2STL[currentSubCase][13]]];
              p_2ss = corner[cornersMCtoSOLVER[tiling3_2STL[currentSubCase][14]]];
              splitCorner1 = cornersMCtoSOLVER[tiling3_2STL[currentSubCase][13]];
              splitCorner2 = cornersMCtoSOLVER[tiling3_2STL[currentSubCase][14]];
              computeTri(p_1s, p_1ss, p_3, &splitFaceVolume[0], splitFaceCentroid[0], splitFaceNormal[0]);
              computeTri(p_1, p_2ss, p_3s, &splitFaceVolume[1], splitFaceCentroid[1], splitFaceNormal[1]);
              correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

              correctNormal(normalVec_c);
              splitFaceId = face5;
            }

            m_bndryCells->a[bndryId].m_volume = volume_C;
            // create 1 Cut face
            m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
              m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
              m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
            }

            faceCut[face1] = true;
            faceCut[face2] = true;
            faceCut[face3] = true;
            faceCut[face4] = true;
            faceCut[face5] = true;

            absA = F0;
            for(MInt i = 0; i < nDim; i++) {
              if(!nfs_cur[2 * i + 1]) faceVolume[2 * i + 1] = 0;
              if(!nfs_cur[2 * i]) faceVolume[2 * i] = 0;
              faceDiff[i] = faceVolume[2 * i + 1] - faceVolume[2 * i];
              absA += POW2(faceDiff[i]);
            }

            if(currentSubCase < 12) {
              for(MInt i = 0; i < nDim; i++) {
                m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i] = faceDiff[i] / sqrt(absA);
              }
              m_bndryCells->a[bndryId].m_srfcs[0]->m_area = sqrt(absA);
            }

          } else { // case 3.1 - two surfaces or split cell

            if(currentSubCase < 12) {
              // split cell: add another boundary cell and a new cell:
              cellId2 = createSplitCell_MGC(cellId, 1);
              bndryId2 = m_solver->a_bndryId(cellId2);
              m_splitParents[bndryId2] = bndryId;
              m_splitChildren[bndryId * 3 + 0] = bndryId2;
              if(bndryId == 0)
                cerr << " problem in FvBndryCnd3D::createCutFaceMGC, assuming cell 0 is no split cell failed! " << endl;
              m_bndryCells->a[bndryId].m_noSrfcs = 1;
              m_bndryCells->a[bndryId2].m_noSrfcs = 1;
            } else {
              m_bndryCells->a[bndryId].m_noSrfcs = 2;
            }

            for(MInt face = 0; face < 6; face++) {
              nfs_cur[face] = nfs3_1[currentSubCase][face];
            }

            // 1st Pyramid + 1st cutFace
            subCaseDummy = tiling3_1STL[currentSubCase][0];
            p_0 = corner[cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
            p_1 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
            p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
            p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            face1 = facesMCtoSOLVER[tiling1STL[subCaseDummy][4]];
            face2 = facesMCtoSOLVER[tiling1STL[subCaseDummy][5]];
            face3 = facesMCtoSOLVER[tiling1STL[subCaseDummy][6]];

            faceCut[face1] = true;
            faceCut[face2] = true;
            faceCut[face3] = true;

            computeTri(p_0, p_1, p_3, &faceVolume[face1], faceCentroid[face1]);
            computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2]);
            computeTri(p_0, p_2, p_1, &faceVolume[face3], faceCentroid[face3]);

            computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

            computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

            if(currentSubCase >= 12) {
              correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
              correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
              correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);

              correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

              correctNormal(normalVec_c);
            } else {
              for(MInt face = 0; face < 6; face++) {
                nfs_cur[face] = nfs1[subCaseDummy][face];
              }
            }

            // create 1st Cut face and 1st cell
            m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
              m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            }
            m_bndryCells->a[bndryId].m_volume = volume_C;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
            }

            if(currentSubCase >= 12) {
              faceVolume_0[face1] = faceVolume[face1];
              faceVolume_0[face2] = faceVolume[face2];
              faceVolume_0[face3] = faceVolume[face3];
              cellVolume_0 = volume_C;
              for(MInt i = 0; i < 3; i++) {
                cellCentroid_0[i] = coordinates_Cell[i];
                faceCentroid_0[face1][i] = faceCentroid[face1][i];
                faceCentroid_0[face2][i] = faceCentroid[face2][i];
                faceCentroid_0[face3][i] = faceCentroid[face3][i];
              }
            }

            // 2nd Pyramid + 2nd cutFace
            subCaseDummy = tiling3_1STL[currentSubCase][1];
            p_0 = corner[cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
            p_1 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
            p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
            p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            face1 = facesMCtoSOLVER[tiling1STL[subCaseDummy][4]];
            face2 = facesMCtoSOLVER[tiling1STL[subCaseDummy][5]];
            face3 = facesMCtoSOLVER[tiling1STL[subCaseDummy][6]];

            if(currentSubCase < 12) {
              for(MInt face = 0; face < 6; face++) {
                nfs_cur_0[face] = nfs1[subCaseDummy][face];
              }

              faceCut_0[face1] = true;
              faceCut_0[face2] = true;
              faceCut_0[face3] = true;

              computeTri(p_0, p_1, p_3, &faceVolume_0[face1], faceCentroid_0[face1]);
              computeTri(p_0, p_3, p_2, &faceVolume_0[face2], faceCentroid_0[face2]);
              computeTri(p_0, p_2, p_1, &faceVolume_0[face3], faceCentroid_0[face3]);

              computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

              computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

              // create 2nd Cut face & cell
              m_bndryCells->a[bndryId2].m_srfcs[0]->m_area = area_c;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId2].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
                m_bndryCells->a[bndryId2].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
              }

              m_bndryCells->a[bndryId2].m_volume = volume_C;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId2].m_coordinates[dim] = coordinates_Cell[dim];
              }

              // fill ambiguous corners array
              cornerCellMapping[ambIds[bndryId] * 8 + cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]] = cellId2;

            } else {
              faceCut[face1] = true;
              faceCut[face2] = true;
              faceCut[face3] = true;

              computeTri(p_0, p_1, p_3, &faceVolume[face1], faceCentroid[face1]);
              computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2]);
              computeTri(p_0, p_2, p_1, &faceVolume[face3], faceCentroid[face3]);

              computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

              computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

              correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
              correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
              correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);

              correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

              correctNormal(normalVec_c);

              // create 2nd Cut face
              m_bndryCells->a[bndryId].m_srfcs[1]->m_area = area_c;
              m_bndryCells->a[bndryId].m_srfcs[1]->m_bndryCndId = m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId].m_srfcs[1]->m_coordinates[dim] = coordinates_c[dim];
                m_bndryCells->a[bndryId].m_srfcs[1]->m_normalVector[dim] = normalVec_c[dim];
              }

              m_bndryCells->a[bndryId].m_volume = volume_C;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
              }
            }
          }
          break;
        }
        case 4: {
          for(MInt i = 0; i < 6; i++) {
            faceVolume_0[i] = faceVolume[i];
            for(MInt j = 0; j < 3; j++) {
              faceCentroid_0[i][j] = faceCentroid[i][j];
            }
          }
          cellVolume_0 = gridCellVolume;
          for(MInt i = 0; i < 3; i++) {
            cellCentroid_0[i] = m_solver->a_coordinate(cellId, i);
          }

          // cerr << "Case 4.1 detected. Starting Cutface computation..." << endl;
          if(currentSubCase < 4) {
            // split cell: add another boundary cell and a new cell:
            cellId2 = createSplitCell_MGC(cellId, 1);
            bndryId2 = m_solver->a_bndryId(cellId2);
            m_splitParents[bndryId2] = bndryId;
            m_splitChildren[bndryId * 3 + 0] = bndryId2;
            if(bndryId == 0)
              cerr << " problem in FvBndryCnd3D::createCutFaceMGC, assuming cell 0 is no split cell failed! " << endl;

            // compute first cell:
            m_bndryCells->a[bndryId].m_noSrfcs = 1;

            // first cell is a pyramid - case 1:
            subCaseDummy = tiling4_1STL[currentSubCase][0];
            for(MInt face = 0; face < 6; face++) {
              nfs_cur[face] = nfs1[subCaseDummy][face];
            }
            p_0 = corner[cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
            p_1 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
            p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
            p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            face1 = facesMCtoSOLVER[tiling1STL[subCaseDummy][4]];
            face2 = facesMCtoSOLVER[tiling1STL[subCaseDummy][5]];
            face3 = facesMCtoSOLVER[tiling1STL[subCaseDummy][6]];

            faceCut[face1] = true;
            faceCut[face2] = true;
            faceCut[face3] = true;

            computeTri(p_0, p_1, p_3, &faceVolume[face1], faceCentroid[face1]);
            computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2]);
            computeTri(p_0, p_2, p_1, &faceVolume[face3], faceCentroid[face3]);

            computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

            computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

            m_bndryCells->a[bndryId].m_volume = volume_C;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
            }

            // create 1st Cut face
            m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
              m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            }

            // compute 2nd cell:

            m_bndryCells->a[bndryId2].m_noSrfcs = 1;

            subCaseDummy = tiling4_1STL[currentSubCase][1];
            for(MInt face = 0; face < 6; face++) {
              nfs_cur_0[face] = nfs1[subCaseDummy][face];
            }
            p_0 = corner[cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
            p_1 = m_bndryCells->a[bndryId2].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
            p_2 = m_bndryCells->a[bndryId2].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
            p_3 = m_bndryCells->a[bndryId2].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            face1 = facesMCtoSOLVER[tiling1STL[subCaseDummy][4]];
            face2 = facesMCtoSOLVER[tiling1STL[subCaseDummy][5]];
            face3 = facesMCtoSOLVER[tiling1STL[subCaseDummy][6]];

            faceCut_0[face1] = true;
            faceCut_0[face2] = true;
            faceCut_0[face3] = true;

            computeTri(p_0, p_1, p_3, &faceVolume_0[face1], faceCentroid_0[face1]);
            computeTri(p_0, p_3, p_2, &faceVolume_0[face2], faceCentroid_0[face2]);
            computeTri(p_0, p_2, p_1, &faceVolume_0[face3], faceCentroid_0[face3]);

            computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

            computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

            m_bndryCells->a[bndryId2].m_volume = volume_C;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId2].m_coordinates[dim] = coordinates_Cell[dim];
            }

            // create 2nd Cut face
            m_bndryCells->a[bndryId2].m_srfcs[0]->m_area = area_c;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId2].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
              m_bndryCells->a[bndryId2].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            }

            // fill ambiguous corners array
            cornerCellMapping[ambIds[bndryId] * 8 + cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]] = cellId2;

          } else {
            m_bndryCells->a[bndryId].m_noSrfcs = 2;
            for(MInt face = 0; face < 6; face++) {
              nfs_cur[face] = nfs4_1[currentSubCase][face];
            }
            // 1st Pyramid + 1st cutFace
            subCaseDummy = tiling4_1STL[currentSubCase][0];
            p_0 = corner[cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
            p_1 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
            p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
            p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            face1 = facesMCtoSOLVER[tiling1STL[subCaseDummy][4]];
            face2 = facesMCtoSOLVER[tiling1STL[subCaseDummy][5]];
            face3 = facesMCtoSOLVER[tiling1STL[subCaseDummy][6]];

            faceCut[face1] = true;
            faceCut[face2] = true;
            faceCut[face3] = true;

            computeTri(p_0, p_1, p_3, &faceVolume[face1], faceCentroid[face1]);
            computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2]);
            computeTri(p_0, p_2, p_1, &faceVolume[face3], faceCentroid[face3]);

            computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

            computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

            correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
            correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
            correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);

            correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

            correctNormal(normalVec_c);

            // create 1st Cut face
            m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
              m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            }

            faceVolume_0[face1] = faceVolume[face1];
            faceVolume_0[face2] = faceVolume[face2];
            faceVolume_0[face3] = faceVolume[face3];
            cellVolume_0 = volume_C;
            for(MInt i = 0; i < 3; i++) {
              cellCentroid_0[i] = coordinates_Cell[i];
              faceCentroid_0[face1][i] = faceCentroid[face1][i];
              faceCentroid_0[face2][i] = faceCentroid[face2][i];
              faceCentroid_0[face3][i] = faceCentroid[face3][i];
            }

            // 2nd Pyramid + 2nd cutFace
            subCaseDummy = tiling4_1STL[currentSubCase][1];
            p_0 = corner[cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
            p_1 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
            p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
            p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            face1 = facesMCtoSOLVER[tiling1STL[subCaseDummy][4]];
            face2 = facesMCtoSOLVER[tiling1STL[subCaseDummy][5]];
            face3 = facesMCtoSOLVER[tiling1STL[subCaseDummy][6]];

            faceCut[face1] = true;
            faceCut[face2] = true;
            faceCut[face3] = true;

            computeTri(p_0, p_1, p_3, &faceVolume[face1], faceCentroid[face1]);
            computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2]);
            computeTri(p_0, p_2, p_1, &faceVolume[face3], faceCentroid[face3]);

            computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

            computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

            correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
            correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
            correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);

            correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

            correctNormal(normalVec_c);

            // create 2nd Cut face
            m_bndryCells->a[bndryId].m_srfcs[1]->m_area = area_c;
            m_bndryCells->a[bndryId].m_srfcs[1]->m_bndryCndId = m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_srfcs[1]->m_coordinates[dim] = coordinates_c[dim];
              m_bndryCells->a[bndryId].m_srfcs[1]->m_normalVector[dim] = normalVec_c[dim];
            }

            m_bndryCells->a[bndryId].m_volume = volume_C;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
            }
          }
          break;
        }
        case 6: {
          for(MInt i = 0; i < 6; i++) {
            faceVolume_0[i] = faceVolume[i];
            for(MInt j = 0; j < 3; j++) {
              faceCentroid_0[i][j] = faceCentroid[i][j];
            }
          }
          cellVolume_0 = gridCellVolume;
          for(MInt i = 0; i < 3; i++) {
            cellCentroid_0[i] = m_solver->a_coordinate(cellId, i);
          }
          if((currentSubCase < 24 && disambiguation[bndryId] == 1)
             || (currentSubCase >= 24 && disambiguation[bndryId] == 0)) {
            // case 6.1 - 2 surfaces or split cell

            if(currentSubCase < 24) {
              // split cell: add another boundary cell and a new cell:
              cellId2 = createSplitCell_MGC(cellId, 1);
              bndryId2 = m_solver->a_bndryId(cellId2);
              m_splitParents[bndryId2] = bndryId;
              m_splitChildren[bndryId * 3 + 0] = bndryId2;
              if(bndryId == 0)
                cerr << " problem in FvBndryCnd3D::createCutFaceMGC, assuming cell 0 is no split cell failed! " << endl;
              m_bndryCells->a[bndryId].m_noSrfcs = 1;
              m_bndryCells->a[bndryId2].m_noSrfcs = 1;
            } else {
              m_bndryCells->a[bndryId].m_noSrfcs = 2;
            }

            for(MInt face = 0; face < 6; face++) {
              nfs_cur[face] = nfs6_1[currentSubCase][face];
            }

            // 1st prism & 1st cutFace
            subCaseDummy = tiling6_1STL[currentSubCase][0];
            p_0 = corner[cornersMCtoSOLVER[tiling2STL[subCaseDummy][0]]];
            p_0s = corner[cornersMCtoSOLVER[tiling2STL[subCaseDummy][1]]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][2]];
            p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][3]];
            p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][4]];
            p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][5]];
            p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            face1 = facesMCtoSOLVER[tiling2STL[subCaseDummy][6]];
            face2 = facesMCtoSOLVER[tiling2STL[subCaseDummy][7]];
            face3 = facesMCtoSOLVER[tiling2STL[subCaseDummy][8]];
            face4 = facesMCtoSOLVER[tiling2STL[subCaseDummy][9]];

            computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2], normal[face2]);
            computeTri(p_0s, p_3s, p_2s, &faceVolume[face3], faceCentroid[face3], normal[face3]);
            computeTrapez(p_0, p_0s, p_3s, p_3, &faceVolume[face1], faceCentroid[face1], normal[face1]);
            computeTrapez(p_2, p_2s, p_0s, p_0, &faceVolume[face4], faceCentroid[face4], normal[face4]);

            computePoly4(p_3, p_3s, p_2s, p_2, &area_c, coordinates_c, normalVec_c);

            maia::math::vecAvg<3>(M, p_0, p_0s, p_2, p_2s, p_3, p_3s);

            for(MInt i = 0; i < 4; i++) {
              computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                          &pyraVolume[i], pyraCentroid[i]);
            }
            computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[4], pyraCentroid[4]);
            for(MInt i = 0; i < 5; i++) {
              volume_C += pyraVolume[i];
              maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
            }
            vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

            if(currentSubCase >= 24) {
              correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
              correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
              correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);
              correctFace(&faceVolume[face4], faceCentroid[face4], &faceVolume_0[face4], faceCentroid_0[face4]);

              correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

              correctNormal(normalVec_c);
            } else {
              for(MInt face = 0; face < 6; face++) {
                nfs_cur[face] = nfs2[subCaseDummy][face];
              }
            }

            faceCut[face1] = true;
            faceCut[face2] = true;
            faceCut[face3] = true;
            faceCut[face4] = true;

            // create 1st Cut face & 1st cut cell
            m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
              m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            }
            m_bndryCells->a[bndryId].m_volume = volume_C;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
            }

            if(currentSubCase >= 24) {
              faceVolume_0[face1] = faceVolume[face1];
              faceVolume_0[face2] = faceVolume[face2];
              faceVolume_0[face3] = faceVolume[face3];
              faceVolume_0[face4] = faceVolume[face4];
              cellVolume_0 = volume_C;
              volume_C = 0;
              for(MInt i = 0; i < 3; i++) {
                cellCentroid_0[i] = coordinates_Cell[i];
                faceCentroid_0[face1][i] = faceCentroid[face1][i];
                faceCentroid_0[face2][i] = faceCentroid[face2][i];
                faceCentroid_0[face3][i] = faceCentroid[face3][i];
                faceCentroid_0[face4][i] = faceCentroid[face4][i];
                coordinates_Cell[i] = 0;
              }
            }

            // 2nd Pyramid + 2nd cutFace
            subCaseDummy = tiling6_1STL[currentSubCase][1];
            p_0 = corner[cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
            p_1 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
            p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
            p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            face1 = facesMCtoSOLVER[tiling1STL[subCaseDummy][4]];
            face2 = facesMCtoSOLVER[tiling1STL[subCaseDummy][5]];
            face3 = facesMCtoSOLVER[tiling1STL[subCaseDummy][6]];

            if(currentSubCase < 24) {
              for(MInt face = 0; face < 6; face++) {
                nfs_cur_0[face] = nfs1[subCaseDummy][face];
              }

              faceCut_0[face1] = true;
              faceCut_0[face2] = true;
              faceCut_0[face3] = true;

              computeTri(p_0, p_1, p_3, &faceVolume_0[face1], faceCentroid_0[face1]);
              computeTri(p_0, p_3, p_2, &faceVolume_0[face2], faceCentroid_0[face2]);
              computeTri(p_0, p_2, p_1, &faceVolume_0[face3], faceCentroid_0[face3]);

              computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

              computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

              // create 2nd Cut face & cell
              m_bndryCells->a[bndryId2].m_srfcs[0]->m_area = area_c;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId2].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
                m_bndryCells->a[bndryId2].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
              }

              m_bndryCells->a[bndryId2].m_volume = volume_C;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId2].m_coordinates[dim] = coordinates_Cell[dim];
              }

              // fill ambiguous corners array
              cornerCellMapping[ambIds[bndryId] * 8 + cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]] = cellId2;
            } else {
              faceCut[face1] = true;
              faceCut[face2] = true;
              faceCut[face3] = true;

              computeTri(p_0, p_1, p_3, &faceVolume[face1], faceCentroid[face1]);
              computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2]);
              computeTri(p_0, p_2, p_1, &faceVolume[face3], faceCentroid[face3]);

              computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

              computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

              correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
              correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
              correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);

              correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

              correctNormal(normalVec_c);

              // create 2nd Cut face
              m_bndryCells->a[bndryId].m_srfcs[1]->m_area = area_c;
              m_bndryCells->a[bndryId].m_srfcs[1]->m_bndryCndId = m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId].m_srfcs[1]->m_coordinates[dim] = coordinates_c[dim];
                m_bndryCells->a[bndryId].m_srfcs[1]->m_normalVector[dim] = normalVec_c[dim];
              }

              m_bndryCells->a[bndryId].m_volume = volume_C;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
              }
            }

          } else {
            // case 6.2 - 1 surface (computed as 3 connected surfaces)

            // compute cell without correction (no split surface, convex cell), correct later if subCase >=24 (split
            // surface, concave cell)
            m_bndryCells->a[bndryId].m_noSrfcs = 3;

            for(MInt face = 0; face < 6; face++) {
              nfs_cur[face] = nfs6_1[currentSubCase][face];
            }
            p_0 = corner[cornersMCtoSOLVER[tiling6_2STL[currentSubCase][0]]];
            p_1 = corner[cornersMCtoSOLVER[tiling6_2STL[currentSubCase][1]]];
            p_2 = corner[cornersMCtoSOLVER[tiling6_2STL[currentSubCase][2]]];
            p_4 = corner[cornersMCtoSOLVER[tiling6_2STL[currentSubCase][3]]];
            p_5 = corner[cornersMCtoSOLVER[tiling6_2STL[currentSubCase][4]]];

            cutDummy = edgesMCtoSOLVER[tiling6_2STL[currentSubCase][5]];
            p_0s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling6_2STL[currentSubCase][6]];
            p_0ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling6_2STL[currentSubCase][7]];
            p_1s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling6_2STL[currentSubCase][8]];
            p_1ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling6_2STL[currentSubCase][9]];
            p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling6_2STL[currentSubCase][10]];
            p_2ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling6_2STL[currentSubCase][11]];
            p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            face1 = facesMCtoSOLVER[tiling6_2STL[currentSubCase][12]];
            face2 = facesMCtoSOLVER[tiling6_2STL[currentSubCase][13]];
            face3 = facesMCtoSOLVER[tiling6_2STL[currentSubCase][14]];
            face4 = facesMCtoSOLVER[tiling6_2STL[currentSubCase][15]];
            face5 = facesMCtoSOLVER[tiling6_2STL[currentSubCase][16]];
            face6 = facesMCtoSOLVER[tiling6_2STL[currentSubCase][17]];

            computePoly6(p_1, p_1s, p_2s, p_2, p_2ss, p_1ss, &faceVolume[face1], faceCentroid[face1], normal[face1]);
            computeTrapez(p_0, p_1, p_1s, p_0s, &faceVolume[face2], faceCentroid[face2], normal[face2]);
            computeTrapez(p_0, p_1, p_1ss, p_0ss, &faceVolume[face3], faceCentroid[face3], normal[face3]);
            computeTri(p_2, p_3, p_2ss, &faceVolume[face4], faceCentroid[face4], normal[face4]);
            computeTri(p_2s, p_2, p_3, &faceVolume[face5], faceCentroid[face5], normal[face5]);
            computeTri(p_0, p_0s, p_0ss, &faceVolume[face6], faceCentroid[face6], normal[face6]);

            maia::math::vecAvg<3>(M, p_0s, p_0ss, p_1s, p_1ss, p_2s, p_2ss, p_3, p_0, p_1, p_2);

            for(MInt i = 0; i < 6; i++) {
              computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                          &pyraVolume[i], pyraCentroid[i]);
            }
            // 1st cut surface
            computePoly4(p_0s, p_3, p_2s, p_1s, &area_c, coordinates_c, normalVec_c);
            computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[6], pyraCentroid[6]);
            if(currentSubCase >= 24) correctNormal(normalVec_c);
            m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
              m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            }
            // 2nd cut surface
            computePoly4(p_0ss, p_1ss, p_2ss, p_3, &area_c, coordinates_c, normalVec_c);
            computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[7], pyraCentroid[7]);
            if(currentSubCase >= 24) correctNormal(normalVec_c);
            m_bndryCells->a[bndryId].m_srfcs[1]->m_area = area_c;
            m_bndryCells->a[bndryId].m_srfcs[1]->m_bndryCndId = m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_srfcs[1]->m_coordinates[dim] = coordinates_c[dim];
              m_bndryCells->a[bndryId].m_srfcs[1]->m_normalVector[dim] = normalVec_c[dim];
            }
            // 3rd cut surface
            computePoly3(p_0s, p_0ss, p_3, &area_c, coordinates_c, normalVec_c);
            computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[8], pyraCentroid[8]);
            if(currentSubCase >= 24) correctNormal(normalVec_c);
            m_bndryCells->a[bndryId].m_srfcs[2]->m_area = area_c;
            m_bndryCells->a[bndryId].m_srfcs[2]->m_bndryCndId = m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_srfcs[2]->m_coordinates[dim] = coordinates_c[dim];
              m_bndryCells->a[bndryId].m_srfcs[2]->m_normalVector[dim] = normalVec_c[dim];
            }

            for(MInt i = 0; i < 9; i++) {
              volume_C += pyraVolume[i];
              maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
            }
            vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

            if(currentSubCase >= 24) { // cell with split surface

              correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
              correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);
              correctFace(&faceVolume[face4], faceCentroid[face4], &faceVolume_0[face4], faceCentroid_0[face4]);
              correctFace(&faceVolume[face5], faceCentroid[face5], &faceVolume_0[face5], faceCentroid_0[face5]);
              correctFace(&faceVolume[face6], faceCentroid[face6], &faceVolume_0[face6], faceCentroid_0[face6]);
              splitCorner1 = cornersMCtoSOLVER[tiling6_2STL[currentSubCase][3]];
              splitCorner2 = cornersMCtoSOLVER[tiling6_2STL[currentSubCase][4]];
              computeTri(p_4, p_2s, p_1s, &splitFaceVolume[0], splitFaceCentroid[0], splitFaceNormal[0]);
              computeTri(p_5, p_1ss, p_2ss, &splitFaceVolume[1], splitFaceCentroid[1], splitFaceNormal[1]);

              correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

              splitFaceId = face1;
            }

            m_bndryCells->a[bndryId].m_volume = volume_C;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
            }

            faceCut[face1] = true;
            faceCut[face2] = true;
            faceCut[face3] = true;
            faceCut[face4] = true;
            faceCut[face5] = true;
            faceCut[face6] = true;
          }

          break;
        }
        case 7: {
          disamb_tmp = disambiguation[bndryId];
          if(currentSubCase >= 8) disamb_tmp = 7 - disamb_tmp;

          switch(disamb_tmp) {
            case 0: {
              // compute case 7.4.1

              for(MInt i = 0; i < 6; i++) {
                faceVolume_0[i] = faceVolume[i];
                for(MInt j = 0; j < 3; j++) {
                  faceCentroid_0[i][j] = faceCentroid[i][j];
                }
              }
              cellVolume_0 = gridCellVolume;
              for(MInt i = 0; i < 3; i++) {
                cellCentroid_0[i] = m_solver->a_coordinate(cellId, i);
              }

              if(currentSubCase >= 8) {
                // split cell: add another boundary cell and a new cell:
                cellId2 = createSplitCell_MGC(cellId, 1);
                bndryId2 = m_solver->a_bndryId(cellId2);
                m_splitParents[bndryId2] = bndryId;
                m_splitChildren[bndryId * 3 + 0] = bndryId2;
                if(bndryId == 0)
                  cerr << " problem in FvBndryCnd3D::createCutFaceMGC, assuming cell 0 is no split cell failed! "
                       << endl;
                m_bndryCells->a[bndryId].m_noSrfcs = 1;
                m_bndryCells->a[bndryId2].m_noSrfcs = 1;
              } else {
                m_bndryCells->a[bndryId].m_noSrfcs = 2;
              }

              for(MInt face = 0; face < 6; face++) {
                nfs_cur[face] = nfs7_1[currentSubCase][face];
              }

              // 1st Pyramid + 1st cutFace
              subCaseDummy = tiling7_4_1STL[currentSubCase][0];
              p_0 = corner[cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
              p_1 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
              p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
              p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              face1 = facesMCtoSOLVER[tiling1STL[subCaseDummy][4]];
              face2 = facesMCtoSOLVER[tiling1STL[subCaseDummy][5]];
              face3 = facesMCtoSOLVER[tiling1STL[subCaseDummy][6]];

              faceCut[face1] = true;
              faceCut[face2] = true;
              faceCut[face3] = true;

              computeTri(p_0, p_1, p_3, &faceVolume[face1], faceCentroid[face1]);
              computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2]);
              computeTri(p_0, p_2, p_1, &faceVolume[face3], faceCentroid[face3]);

              computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

              computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

              if(currentSubCase < 8) {
                correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
                correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
                correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);

                correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

                correctNormal(normalVec_c);
              } else {
                for(MInt face = 0; face < 6; face++) {
                  nfs_cur[face] = nfs1[subCaseDummy][face];
                }
              }

              // create 1st Cut face and 1st cell
              m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
                m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
              }
              m_bndryCells->a[bndryId].m_volume = volume_C;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
              }

              if(currentSubCase < 8) {
                faceVolume_0[face1] = faceVolume[face1];
                faceVolume_0[face2] = faceVolume[face2];
                faceVolume_0[face3] = faceVolume[face3];
                cellVolume_0 = volume_C;
                volume_C = 0;
                for(MInt i = 0; i < 3; i++) {
                  cellCentroid_0[i] = coordinates_Cell[i];
                  faceCentroid_0[face1][i] = faceCentroid[face1][i];
                  faceCentroid_0[face2][i] = faceCentroid[face2][i];
                  faceCentroid_0[face3][i] = faceCentroid[face3][i];
                  coordinates_Cell[i] = 0;
                }
              } else {
                volume_C = 0;
                for(MInt i = 0; i < 3; i++) {
                  coordinates_Cell[i] = 0;
                }
              }

              // create 2nd part of cell
              subCaseDummy = tiling7_4_1STL[currentSubCase][1];
              noFaces = 6;
              p_0 = corner[cornersMCtoSOLVER[tiling9STL[subCaseDummy][0]]];
              p_1 = corner[cornersMCtoSOLVER[tiling9STL[subCaseDummy][1]]];
              p_2 = corner[cornersMCtoSOLVER[tiling9STL[subCaseDummy][2]]];
              p_3 = corner[cornersMCtoSOLVER[tiling9STL[subCaseDummy][3]]];

              cutDummy = edgesMCtoSOLVER[tiling9STL[subCaseDummy][4]];
              p_1s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling9STL[subCaseDummy][5]];
              p_1ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling9STL[subCaseDummy][6]];
              p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling9STL[subCaseDummy][7]];
              p_2ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling9STL[subCaseDummy][8]];
              p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling9STL[subCaseDummy][9]];
              p_3ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              face1 = facesMCtoSOLVER[tiling9STL[subCaseDummy][10]];
              face2 = facesMCtoSOLVER[tiling9STL[subCaseDummy][11]];
              face3 = facesMCtoSOLVER[tiling9STL[subCaseDummy][12]];
              face4 = facesMCtoSOLVER[tiling9STL[subCaseDummy][13]];
              face5 = facesMCtoSOLVER[tiling9STL[subCaseDummy][14]];
              face6 = facesMCtoSOLVER[tiling9STL[subCaseDummy][15]];

              if(currentSubCase >= 8) {
                for(MInt face = 0; face < 6; face++) {
                  nfs_cur_0[face] = nfs9[subCaseDummy][face];
                  faceCut_0[face] = true;
                }

                computePoly5(p_0, p_3, p_3ss, p_2s, p_2, &faceVolume_0[face1], faceCentroid_0[face1], normal[face1]);
                computePoly5(p_0, p_1, p_1ss, p_3s, p_3, &faceVolume_0[face3], faceCentroid_0[face3], normal[face3]);
                computePoly5(p_0, p_2, p_2ss, p_1s, p_1, &faceVolume_0[face5], faceCentroid_0[face5], normal[face5]);
                computeTri(p_1, p_1s, p_1ss, &faceVolume_0[face2], faceCentroid_0[face2], normal[face2]);
                computeTri(p_2, p_2s, p_2ss, &faceVolume_0[face4], faceCentroid_0[face4], normal[face4]);
                computeTri(p_3, p_3s, p_3ss, &faceVolume_0[face6], faceCentroid_0[face6], normal[face6]);

                computePoly6(p_1ss, p_1s, p_2ss, p_2s, p_3ss, p_3s, &area_c, coordinates_c, normalVec_c);

                maia::math::vecAvg<3>(M, p_0, p_1, p_2, p_3, p_1s, p_2s, p_3s, p_1ss, p_2ss, p_3ss);

                for(MInt i = 0; i < 6; i++) {
                  computePyra(&faceVolume_0[*facepointers[i]], faceCentroid_0[*facepointers[i]],
                              normal[*facepointers[i]], M, &pyraVolume[i], pyraCentroid[i]);
                }
                computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[6], pyraCentroid[6]);
                for(MInt i = 0; i < 7; i++) {
                  volume_C += pyraVolume[i];
                  maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
                }
                vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

                // create 2nd Cut face & cell
                m_bndryCells->a[bndryId2].m_srfcs[0]->m_area = area_c;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId2].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
                  m_bndryCells->a[bndryId2].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
                }

                m_bndryCells->a[bndryId2].m_volume = volume_C;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId2].m_coordinates[dim] = coordinates_Cell[dim];
                }

                // fill ambiguous corners array
                cornerCellMapping[ambIds[bndryId] * 8 + cornersMCtoSOLVER[tiling9STL[subCaseDummy][0]]] = cellId2;
                cornerCellMapping[ambIds[bndryId] * 8 + cornersMCtoSOLVER[tiling9STL[subCaseDummy][1]]] = cellId2;
                cornerCellMapping[ambIds[bndryId] * 8 + cornersMCtoSOLVER[tiling9STL[subCaseDummy][2]]] = cellId2;
                cornerCellMapping[ambIds[bndryId] * 8 + cornersMCtoSOLVER[tiling9STL[subCaseDummy][3]]] = cellId2;

              } else {
                for(MInt face = 0; face < 6; face++) {
                  faceCut[face] = true;
                }

                computePoly5(p_0, p_3, p_3ss, p_2s, p_2, &faceVolume[face1], faceCentroid[face1], normal[face1]);
                computePoly5(p_0, p_1, p_1ss, p_3s, p_3, &faceVolume[face3], faceCentroid[face3], normal[face3]);
                computePoly5(p_0, p_2, p_2ss, p_1s, p_1, &faceVolume[face5], faceCentroid[face5], normal[face5]);
                computeTri(p_1, p_1s, p_1ss, &faceVolume[face2], faceCentroid[face2], normal[face2]);
                computeTri(p_2, p_2s, p_2ss, &faceVolume[face4], faceCentroid[face4], normal[face4]);
                computeTri(p_3, p_3s, p_3ss, &faceVolume[face6], faceCentroid[face6], normal[face6]);

                computePoly6(p_1ss, p_1s, p_2ss, p_2s, p_3ss, p_3s, &area_c, coordinates_c, normalVec_c);

                maia::math::vecAvg<3>(M, p_0, p_1, p_2, p_3, p_1s, p_2s, p_3s, p_1ss, p_2ss, p_3ss);

                for(MInt i = 0; i < 6; i++) {
                  computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]],
                              M, &pyraVolume[i], pyraCentroid[i]);
                }
                computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[6], pyraCentroid[6]);
                for(MInt i = 0; i < 7; i++) {
                  volume_C += pyraVolume[i];
                  maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
                }
                vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

                correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
                correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
                correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);
                correctFace(&faceVolume[face4], faceCentroid[face4], &faceVolume_0[face4], faceCentroid_0[face4]);
                correctFace(&faceVolume[face5], faceCentroid[face5], &faceVolume_0[face5], faceCentroid_0[face5]);
                correctFace(&faceVolume[face6], faceCentroid[face6], &faceVolume_0[face6], faceCentroid_0[face6]);

                correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

                correctNormal(normalVec_c);

                // create 2nd Cut face
                m_bndryCells->a[bndryId].m_srfcs[1]->m_area = area_c;
                m_bndryCells->a[bndryId].m_srfcs[1]->m_bndryCndId = m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId].m_srfcs[1]->m_coordinates[dim] = coordinates_c[dim];
                  m_bndryCells->a[bndryId].m_srfcs[1]->m_normalVector[dim] = normalVec_c[dim];
                }

                m_bndryCells->a[bndryId].m_volume = volume_C;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
                }
              }

              break;
            }
            case 1:
            case 2:
            case 4: {
              for(MInt i = 0; i < 6; i++) {
                faceVolume_0[i] = faceVolume[i];
                faceVolume_00[i] = faceVolume[i];
                for(MInt j = 0; j < 3; j++) {
                  faceCentroid_0[i][j] = faceCentroid[i][j];
                }
              }
              cellVolume_0 = gridCellVolume;
              for(MInt i = 0; i < 3; i++) {
                cellCentroid_0[i] = m_solver->a_coordinate(cellId, i);
              }

              for(MInt face = 0; face < 6; face++) {
                nfs_cur[face] = nfs7_1[currentSubCase][face];
              }

              if(disamb_tmp == 1) disambPointer_dummy = &tiling7_3_1STL[0][0];
              if(disamb_tmp == 2) disambPointer_dummy = &tiling7_3_2STL[0][0];
              if(disamb_tmp == 4) disambPointer_dummy = &tiling7_3_4STL[0][0];

              for(MInt i = 0; i < 16; i++)
                for(MInt j = 0; j < 21; j++)
                  disambPointer[i][j] = disambPointer_dummy[i * 21 + j];

              p_0 = corner[cornersMCtoSOLVER[disambPointer[currentSubCase][0]]];
              p_1 = corner[cornersMCtoSOLVER[disambPointer[currentSubCase][1]]];
              p_2 = corner[cornersMCtoSOLVER[disambPointer[currentSubCase][2]]];
              p_3 = corner[cornersMCtoSOLVER[disambPointer[currentSubCase][3]]];
              p_4 = corner[cornersMCtoSOLVER[disambPointer[currentSubCase][4]]];
              p_5 = corner[cornersMCtoSOLVER[disambPointer[currentSubCase][5]]];
              cutDummy = edgesMCtoSOLVER[disambPointer[currentSubCase][6]];
              p_1s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[disambPointer[currentSubCase][7]];
              p_1ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[disambPointer[currentSubCase][8]];
              p_1sss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[disambPointer[currentSubCase][9]];
              p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[disambPointer[currentSubCase][10]];
              p_2ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[disambPointer[currentSubCase][11]];
              p_2sss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[disambPointer[currentSubCase][12]];
              p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[disambPointer[currentSubCase][13]];
              p_3ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[disambPointer[currentSubCase][14]];
              p_3sss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];

              face1 = facesMCtoSOLVER[disambPointer[currentSubCase][15]];
              face2 = facesMCtoSOLVER[disambPointer[currentSubCase][16]];
              face3 = facesMCtoSOLVER[disambPointer[currentSubCase][17]];
              face4 = facesMCtoSOLVER[disambPointer[currentSubCase][18]];
              face5 = facesMCtoSOLVER[disambPointer[currentSubCase][19]];
              face6 = facesMCtoSOLVER[disambPointer[currentSubCase][20]];
              if(currentSubCase < 8) {
                // case 7.3 - 2 surfaces
                m_bndryCells->a[bndryId].m_noSrfcs = 2;

                // case 7.3 - 1 surface (computed as 2 connected surfaces)
                computePoly6(p_1, p_1sss, p_3sss, p_3, p_3s, p_1ss, &faceVolume[face2], faceCentroid[face2],
                             normal[face2]);
                computePoly6(p_1, p_1s, p_2ss, p_2, p_2sss, p_1sss, &faceVolume[face3], faceCentroid[face3],
                             normal[face3]);
                computeTri(p_1, p_1ss, p_1s, &faceVolume[face4], faceCentroid[face4], normal[face4]);
                computeTri(p_2, p_2ss, p_2s, &faceVolume[face5], faceCentroid[face5], normal[face5]);
                computeTri(p_3, p_3ss, p_3s, &faceVolume[face6], faceCentroid[face6], normal[face6]);
                splitCorner1 = cornersMCtoSOLVER[disambPointer[currentSubCase][3]];
                splitCorner2 = cornersMCtoSOLVER[disambPointer[currentSubCase][2]];
                computeTri(p_3, p_3sss, p_3ss, &splitFaceVolume[0], splitFaceCentroid[0], splitFaceNormal[0]);
                computeTri(p_2, p_2s, p_2sss, &splitFaceVolume[1], splitFaceCentroid[1], splitFaceNormal[1]);

                splitFaceId = face1;
                maia::math::vecAvg<3>(M, p_1s, p_1ss, p_1sss, p_2s, p_2ss, p_2sss, p_3s, p_3ss, p_3sss);

                faceVolume[face1] = F0;

                for(MInt i = 0; i < 6; i++) {
                  computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]],
                              M, &pyraVolume[i], pyraCentroid[i]);
                }
                computePyra(&splitFaceVolume[0], splitFaceCentroid[0], splitFaceNormal[0], M, &pyraVolume[6],
                            pyraCentroid[6]);
                computePyra(&splitFaceVolume[1], splitFaceCentroid[1], splitFaceNormal[1], M, &pyraVolume[7],
                            pyraCentroid[7]);

                // 1st cut surface
                computePoly5(p_1sss, p_2sss, p_2s, p_3ss, p_3sss, &area_c, coordinates_c, normalVec_c);
                computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[8], pyraCentroid[8]);
                m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
                  m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
                }
                // 2nd cut surface
                computePoly6(p_1s, p_1ss, p_3s, p_3ss, p_2s, p_2ss, &area_c, coordinates_c, normalVec_c);
                computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[9], pyraCentroid[9]);
                m_bndryCells->a[bndryId].m_srfcs[1]->m_area = area_c;
                m_bndryCells->a[bndryId].m_srfcs[1]->m_bndryCndId = m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId].m_srfcs[1]->m_coordinates[dim] = coordinates_c[dim];
                  m_bndryCells->a[bndryId].m_srfcs[1]->m_normalVector[dim] = normalVec_c[dim];
                }

                for(MInt i = 0; i < 10; i++) {
                  volume_C += pyraVolume[i];
                  maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
                }
                vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

                m_bndryCells->a[bndryId].m_volume = volume_C;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
                }

                faceCut[face1] = true;
                faceCut[face2] = true;
                faceCut[face3] = true;
                faceCut[face4] = true;
                faceCut[face5] = true;
                faceCut[face6] = true;

              } else {
                // case 7.3 - 3 surfaces
                m_bndryCells->a[bndryId].m_noSrfcs = 3;

                // case 7.3 - 1 surface (computed as 2 connected surfaces)
                computeTri(p_3, p_3sss, p_3ss, &faceVolume[face1], faceCentroid[face1], normal[face1]);
                correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
                faceVolume_0[face1] = faceVolume[face1];
                computeTri(p_2, p_2s, p_2sss, &faceVolume[face1], faceCentroid[face1], normal[face1]);
                correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);

                computeTri(p_4, p_1ss, p_3s, &splitFaceVolume[0], splitFaceCentroid[0], splitFaceNormal[0]);
                computeTri(p_0, p_3sss, p_1sss, &splitFaceVolume[1], splitFaceCentroid[1], splitFaceNormal[1]);
                splitCorner1 = cornersMCtoSOLVER[disambPointer[currentSubCase][4]];
                splitCorner2 = cornersMCtoSOLVER[disambPointer[currentSubCase][0]];

                computeTri(p_5, p_2ss, p_1s, &splitFaceVolume2[0], splitFaceCentroid2[0], splitFaceNormal2[0]);
                computeTri(p_0, p_1sss, p_2sss, &splitFaceVolume2[1], splitFaceCentroid2[1], splitFaceNormal2[1]);
                splitCorner12 = cornersMCtoSOLVER[disambPointer[currentSubCase][5]];
                splitCorner22 = cornersMCtoSOLVER[disambPointer[currentSubCase][0]];

                computeTri(p_1, p_1ss, p_1s, &faceVolume[face4], faceCentroid[face4], normal[face4]);
                correctFace(&faceVolume[face4], faceCentroid[face4], &faceVolume_0[face4], faceCentroid_0[face4]);
                computeTri(p_2, p_2ss, p_2s, &faceVolume[face5], faceCentroid[face5], normal[face5]);
                correctFace(&faceVolume[face5], faceCentroid[face5], &faceVolume_0[face5], faceCentroid_0[face5]);
                computeTri(p_3, p_3ss, p_3s, &faceVolume[face6], faceCentroid[face6], normal[face6]);
                correctFace(&faceVolume[face6], faceCentroid[face6], &faceVolume_0[face6], faceCentroid_0[face6]);

                splitFaceId = face2;
                splitFaceId2 = face3;
                maia::math::vecAvg<3>(M, p_1s, p_1ss, p_1sss, p_2s, p_2ss, p_2sss, p_3s, p_3ss, p_3sss);

                faceVolume[face2] = F0;
                faceVolume[face3] = F0;

                for(MInt i = 0; i < 6; i++) {
                  computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]],
                              M, &pyraVolume[i], pyraCentroid[i]);
                }
                computePyra(&splitFaceVolume[0], splitFaceCentroid[0], splitFaceNormal[0], M, &pyraVolume[6],
                            pyraCentroid[6]);
                computePyra(&splitFaceVolume[1], splitFaceCentroid[1], splitFaceNormal[1], M, &pyraVolume[7],
                            pyraCentroid[7]);
                computePyra(&splitFaceVolume2[0], splitFaceCentroid2[0], splitFaceNormal2[0], M, &pyraVolume[8],
                            pyraCentroid[8]);
                computePyra(&splitFaceVolume2[1], splitFaceCentroid2[1], splitFaceNormal2[1], M, &pyraVolume[9],
                            pyraCentroid[9]);
                // 1st cut surface
                computePoly5(p_1ss, p_1sss, p_3sss, p_3ss, p_3s, &area_c, coordinates_c, normalVec_c);
                computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[10], pyraCentroid[10]);
                m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
                  m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
                }
                // 2nd cut surface
                computePoly5(p_1sss, p_1s, p_2ss, p_2s, p_2sss, &area_c, coordinates_c, normalVec_c);
                computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[11], pyraCentroid[11]);
                m_bndryCells->a[bndryId].m_srfcs[1]->m_area = area_c;
                m_bndryCells->a[bndryId].m_srfcs[1]->m_bndryCndId = m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId].m_srfcs[1]->m_coordinates[dim] = coordinates_c[dim];
                  m_bndryCells->a[bndryId].m_srfcs[1]->m_normalVector[dim] = normalVec_c[dim];
                }
                // 3rd cut surface
                computePoly3(p_1s, p_1sss, p_1ss, &area_c, coordinates_c, normalVec_c);
                computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[12], pyraCentroid[12]);
                m_bndryCells->a[bndryId].m_srfcs[2]->m_area = area_c;
                m_bndryCells->a[bndryId].m_srfcs[2]->m_bndryCndId = m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId].m_srfcs[2]->m_coordinates[dim] = coordinates_c[dim];
                  m_bndryCells->a[bndryId].m_srfcs[2]->m_normalVector[dim] = normalVec_c[dim];
                }

                for(MInt i = 0; i < 13; i++) {
                  volume_C += pyraVolume[i];
                  maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
                }
                vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

                m_bndryCells->a[bndryId].m_volume = volume_C;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
                }

                faceCut[face1] = true;
                faceCut[face2] = true;
                faceCut[face3] = true;
                faceCut[face4] = true;
                faceCut[face5] = true;
                faceCut[face6] = true;
              }
              break;
            }
            case 3:
            case 5:
            case 6: {
              // compute case 7.2

              if(disamb_tmp == 3) disambPointer_dummy = &tiling7_2_3STL[0][0];
              if(disamb_tmp == 5) disambPointer_dummy = &tiling7_2_5STL[0][0];
              if(disamb_tmp == 6) disambPointer_dummy = &tiling7_2_6STL[0][0];

              for(MInt i = 0; i < 16; i++)
                for(MInt j = 0; j < 2; j++)
                  disambPointer[i][j] = disambPointer_dummy[i * 2 + j];

              for(MInt i = 0; i < 6; i++) {
                faceVolume_0[i] = faceVolume[i];
                for(MInt j = 0; j < 3; j++) {
                  faceCentroid_0[i][j] = faceCentroid[i][j];
                }
              }
              cellVolume_0 = gridCellVolume;
              for(MInt i = 0; i < 3; i++) {
                cellCentroid_0[i] = m_solver->a_coordinate(cellId, i);
              }

              if(currentSubCase < 8) {
                // split cell: add another boundary cell and a new cell:
                cellId2 = createSplitCell_MGC(cellId, 1);
                bndryId2 = m_solver->a_bndryId(cellId2);
                m_splitParents[bndryId2] = bndryId;
                m_splitChildren[bndryId * 3 + 0] = bndryId2;
                if(bndryId == 0)
                  cerr << " problem in FvBndryCnd3D::createCutFaceMGC, assuming cell 0 is no split cell failed! "
                       << endl;
                m_bndryCells->a[bndryId].m_noSrfcs = 1;
                m_bndryCells->a[bndryId2].m_noSrfcs = 1;
              } else {
                m_bndryCells->a[bndryId].m_noSrfcs = 2;
              }

              for(MInt face = 0; face < 6; face++) {
                nfs_cur[face] = nfs7_1[currentSubCase][face];
              }

              // 1st Pyramid + 1st cutFace
              subCaseDummy = disambPointer[currentSubCase][0];
              p_0 = corner[cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
              p_1 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
              p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
              p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              face1 = facesMCtoSOLVER[tiling1STL[subCaseDummy][4]];
              face2 = facesMCtoSOLVER[tiling1STL[subCaseDummy][5]];
              face3 = facesMCtoSOLVER[tiling1STL[subCaseDummy][6]];

              faceCut[face1] = true;
              faceCut[face2] = true;
              faceCut[face3] = true;

              computeTri(p_0, p_1, p_3, &faceVolume[face1], faceCentroid[face1]);
              computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2]);
              computeTri(p_0, p_2, p_1, &faceVolume[face3], faceCentroid[face3]);

              computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

              computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

              if(currentSubCase >= 8) {
                correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
                correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
                correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);

                correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

                correctNormal(normalVec_c);
              } else {
                for(MInt face = 0; face < 6; face++) {
                  nfs_cur[face] = nfs1[subCaseDummy][face];
                }
              }

              // create 1st Cut face and 1st cell
              m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
                m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
              }
              m_bndryCells->a[bndryId].m_volume = volume_C;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
              }

              if(currentSubCase >= 8) {
                faceVolume_0[face1] = faceVolume[face1];
                faceVolume_0[face2] = faceVolume[face2];
                faceVolume_0[face3] = faceVolume[face3];
                cellVolume_0 = volume_C;
                volume_C = 0;
                for(MInt i = 0; i < 3; i++) {
                  cellCentroid_0[i] = coordinates_Cell[i];
                  faceCentroid_0[face1][i] = faceCentroid[face1][i];
                  faceCentroid_0[face2][i] = faceCentroid[face2][i];
                  faceCentroid_0[face3][i] = faceCentroid[face3][i];
                  coordinates_Cell[i] = 0;
                }
              } else {
                volume_C = 0;
                for(MInt i = 0; i < 3; i++) {
                  coordinates_Cell[i] = 0;
                }
              }

              // create 2nd part of cell
              subCaseDummy = disambPointer[currentSubCase][1];

              // 3.2 case
              noFaces = 5;

              p_0 = corner[cornersMCtoSOLVER[tiling3_2STL[subCaseDummy][0]]];
              p_0s = corner[cornersMCtoSOLVER[tiling3_2STL[subCaseDummy][1]]];

              cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][2]];
              p_1 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][3]];
              p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][4]];
              p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][5]];
              p_1s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][6]];
              p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][7]];
              p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              face1 = facesMCtoSOLVER[tiling3_2STL[subCaseDummy][8]];
              face2 = facesMCtoSOLVER[tiling3_2STL[subCaseDummy][9]];
              face3 = facesMCtoSOLVER[tiling3_2STL[subCaseDummy][10]];
              face4 = facesMCtoSOLVER[tiling3_2STL[subCaseDummy][11]];
              face5 = facesMCtoSOLVER[tiling3_2STL[subCaseDummy][12]];

              if(currentSubCase < 8) {
                for(MInt face = 0; face < 6; face++) {
                  nfs_cur_0[face] = nfs3_2[subCaseDummy][face];
                }
                faceCut_0[face1] = true;
                faceCut_0[face2] = true;
                faceCut_0[face3] = true;
                faceCut_0[face4] = true;
                faceCut_0[face5] = true;

                computeTri(p_0, p_1, p_2, &faceVolume_0[face1], faceCentroid_0[face1], normal[face1]);
                computeTri(p_0, p_2, p_3, &faceVolume_0[face2], faceCentroid_0[face2], normal[face2]);
                computeTri(p_0s, p_2s, p_3s, &faceVolume_0[face3], faceCentroid_0[face3], normal[face3]);
                computeTri(p_0s, p_1s, p_2s, &faceVolume_0[face4], faceCentroid_0[face4], normal[face4]);
                computePoly6(p_0, p_1, p_3s, p_0s, p_1s, p_3, &faceVolume_0[face5], faceCentroid_0[face5],
                             normal[face5]);

                computePoly6(p_1, p_2, p_3, p_1s, p_2s, p_3s, &area_c, coordinates_c, normalVec_c);

                maia::math::vecAvg<3>(M, p_0, p_0s, p_1, p_1s, p_2, p_2s, p_3, p_3s);

                for(MInt i = 0; i < 5; i++) {
                  computePyra(&faceVolume_0[*facepointers[i]], faceCentroid_0[*facepointers[i]],
                              normal[*facepointers[i]], M, &pyraVolume[i], pyraCentroid[i]);
                }
                computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[5], pyraCentroid[5]);

                for(MInt i = 0; i < 6; i++) {
                  volume_C += pyraVolume[i];
                  maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
                }
                vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

                absA = F0;
                for(MInt i = 0; i < nDim; i++) {
                  if(!nfs_cur_0[2 * i + 1]) faceVolume_0[2 * i + 1] = 0;
                  if(!nfs_cur_0[2 * i]) faceVolume_0[2 * i] = 0;
                  faceDiff[i] = faceVolume_0[2 * i + 1] - faceVolume_0[2 * i];
                  absA += POW2(faceDiff[i]);
                }

                for(MInt i = 0; i < nDim; i++) {
                  normalVec_c[i] = faceDiff[i] / sqrt(absA);
                }
                area_c = sqrt(absA);

                // create 2nd Cut face & cell
                // create 1 Cut face
                m_bndryCells->a[bndryId2].m_srfcs[0]->m_area = area_c;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId2].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
                  m_bndryCells->a[bndryId2].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
                }

                m_bndryCells->a[bndryId2].m_volume = volume_C;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId2].m_coordinates[dim] = coordinates_Cell[dim];
                }

                // fill ambiguous corners array
                cornerCellMapping[ambIds[bndryId] * 8 + cornersMCtoSOLVER[tiling3_2STL[subCaseDummy][0]]] = cellId2;
                cornerCellMapping[ambIds[bndryId] * 8 + cornersMCtoSOLVER[tiling3_2STL[subCaseDummy][1]]] = cellId2;
              } else {
                faceCut[face1] = true;
                faceCut[face2] = true;
                faceCut[face3] = true;
                faceCut[face4] = true;
                faceCut[face5] = true;

                computeTri(p_0, p_1, p_2, &faceVolume[face1], faceCentroid[face1], normal[face1]);
                computeTri(p_0, p_2, p_3, &faceVolume[face2], faceCentroid[face2], normal[face2]);
                computeTri(p_0s, p_2s, p_3s, &faceVolume[face3], faceCentroid[face3], normal[face3]);
                computeTri(p_0s, p_1s, p_2s, &faceVolume[face4], faceCentroid[face4], normal[face4]);
                computePoly6(p_0, p_1, p_3s, p_0s, p_1s, p_3, &faceVolume[face5], faceCentroid[face5], normal[face5]);

                computePoly6(p_1, p_2, p_3, p_1s, p_2s, p_3s, &area_c, coordinates_c, normalVec_c);

                maia::math::vecAvg<3>(M, p_0, p_0s, p_1, p_1s, p_2, p_2s, p_3, p_3s);

                for(MInt i = 0; i < 5; i++) {
                  computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]],
                              M, &pyraVolume[i], pyraCentroid[i]);
                }
                computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[5], pyraCentroid[5]);

                for(MInt i = 0; i < 6; i++) {
                  volume_C += pyraVolume[i];
                  maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
                }
                vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

                // correct cell
                correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
                correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
                correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);
                correctFace(&faceVolume[face4], faceCentroid[face4], &faceVolume_0[face4], faceCentroid_0[face4]);
                p_1ss = corner[cornersMCtoSOLVER[tiling3_2STL[subCaseDummy][13]]];
                p_2ss = corner[cornersMCtoSOLVER[tiling3_2STL[subCaseDummy][14]]];
                splitCorner1 = cornersMCtoSOLVER[tiling3_2STL[subCaseDummy][13]];
                splitCorner2 = cornersMCtoSOLVER[tiling3_2STL[subCaseDummy][14]];
                computeTri(p_1s, p_1ss, p_3, &splitFaceVolume[0], splitFaceCentroid[0], splitFaceNormal[0]);
                computeTri(p_1, p_2ss, p_3s, &splitFaceVolume[1], splitFaceCentroid[1], splitFaceNormal[1]);
                correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

                correctNormal(normalVec_c);
                splitFaceId = face5;

                // create 2nd Cut face
                m_bndryCells->a[bndryId].m_srfcs[1]->m_area = area_c;
                m_bndryCells->a[bndryId].m_srfcs[1]->m_bndryCndId = m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId].m_srfcs[1]->m_coordinates[dim] = coordinates_c[dim];
                  m_bndryCells->a[bndryId].m_srfcs[1]->m_normalVector[dim] = normalVec_c[dim];
                }

                m_bndryCells->a[bndryId].m_volume = volume_C;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
                }
              }
              break;
            }
            case 7: {
              if(currentSubCase < 8) {
                // split cell2: add 2 other boundary cells and 2 new cells:
                cellId2 = createSplitCell_MGC(cellId, 1);
                bndryId2 = m_solver->a_bndryId(cellId2);
                cellId3 = createSplitCell_MGC(cellId, 2);
                bndryId3 = m_solver->a_bndryId(cellId3);
                m_splitParents[bndryId2] = bndryId;
                m_splitParents[bndryId3] = bndryId;
                m_splitChildren[bndryId * 3 + 0] = bndryId2;
                m_splitChildren[bndryId * 3 + 1] = bndryId3;
                if(bndryId == 0)
                  cerr << " problem in FvBndryCnd3D::createCutFaceMGC, assuming cell 0 is no split cell failed! "
                       << endl;
                m_bndryCells->a[bndryId].m_noSrfcs = 1;
                m_bndryCells->a[bndryId2].m_noSrfcs = 1;
                m_bndryCells->a[bndryId3].m_noSrfcs = 1;
              } else {
                m_bndryCells->a[bndryId].m_noSrfcs = 3;
              }

              for(MInt face = 0; face < 6; face++) {
                nfs_cur[face] = nfs7_1[currentSubCase][face];
              }

              // 1st Pyramid + 1st cutFace
              subCaseDummy = tiling7_1STL[currentSubCase][0];
              p_0 = corner[cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
              p_1 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
              p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
              p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              face1 = facesMCtoSOLVER[tiling1STL[subCaseDummy][4]];
              face2 = facesMCtoSOLVER[tiling1STL[subCaseDummy][5]];
              face3 = facesMCtoSOLVER[tiling1STL[subCaseDummy][6]];

              faceCut[face1] = true;
              faceCut[face2] = true;
              faceCut[face3] = true;

              computeTri(p_0, p_1, p_3, &faceVolume[face1], faceCentroid[face1]);
              computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2]);
              computeTri(p_0, p_2, p_1, &faceVolume[face3], faceCentroid[face3]);

              computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

              computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

              if(currentSubCase >= 8) {
                correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
                correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
                correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);

                correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

                correctNormal(normalVec_c);
              } else {
                for(MInt face = 0; face < 6; face++) {
                  nfs_cur[face] = nfs1[subCaseDummy][face];
                }
              }

              // create 1st Cut face and 1st cell
              m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
                m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
              }
              m_bndryCells->a[bndryId].m_volume = volume_C;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
              }

              if(currentSubCase >= 8) {
                faceVolume_0[face1] = faceVolume[face1];
                faceVolume_0[face2] = faceVolume[face2];
                faceVolume_0[face3] = faceVolume[face3];
                cellVolume_0 = volume_C;
                for(MInt i = 0; i < 3; i++) {
                  cellCentroid_0[i] = coordinates_Cell[i];
                  faceCentroid_0[face1][i] = faceCentroid[face1][i];
                  faceCentroid_0[face2][i] = faceCentroid[face2][i];
                  faceCentroid_0[face3][i] = faceCentroid[face3][i];
                }
              }

              // 2nd Pyramid + 2nd cutFace
              subCaseDummy = tiling7_1STL[currentSubCase][1];
              p_0 = corner[cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
              p_1 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
              p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
              p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              face1 = facesMCtoSOLVER[tiling1STL[subCaseDummy][4]];
              face2 = facesMCtoSOLVER[tiling1STL[subCaseDummy][5]];
              face3 = facesMCtoSOLVER[tiling1STL[subCaseDummy][6]];

              if(currentSubCase < 8) {
                for(MInt face = 0; face < 6; face++) {
                  nfs_cur_0[face] = nfs1[subCaseDummy][face];
                }

                faceCut_0[face1] = true;
                faceCut_0[face2] = true;
                faceCut_0[face3] = true;

                computeTri(p_0, p_1, p_3, &faceVolume_0[face1], faceCentroid_0[face1]);
                computeTri(p_0, p_3, p_2, &faceVolume_0[face2], faceCentroid_0[face2]);
                computeTri(p_0, p_2, p_1, &faceVolume_0[face3], faceCentroid_0[face3]);

                computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

                computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

                // create 2nd Cut face & cell
                m_bndryCells->a[bndryId2].m_srfcs[0]->m_area = area_c;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId2].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
                  m_bndryCells->a[bndryId2].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
                }

                m_bndryCells->a[bndryId2].m_volume = volume_C;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId2].m_coordinates[dim] = coordinates_Cell[dim];
                }
                // fill ambiguous corners array
                cornerCellMapping[ambIds[bndryId] * 8 + cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]] = cellId2;
              } else {
                faceCut[face1] = true;
                faceCut[face2] = true;
                faceCut[face3] = true;

                computeTri(p_0, p_1, p_3, &faceVolume[face1], faceCentroid[face1]);
                computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2]);
                computeTri(p_0, p_2, p_1, &faceVolume[face3], faceCentroid[face3]);

                computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

                computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

                correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
                correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
                correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);

                correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

                correctNormal(normalVec_c);

                // create 2nd Cut face
                m_bndryCells->a[bndryId].m_srfcs[1]->m_area = area_c;
                m_bndryCells->a[bndryId].m_srfcs[1]->m_bndryCndId = m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId].m_srfcs[1]->m_coordinates[dim] = coordinates_c[dim];
                  m_bndryCells->a[bndryId].m_srfcs[1]->m_normalVector[dim] = normalVec_c[dim];
                }

                m_bndryCells->a[bndryId].m_volume = volume_C;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
                }
              }

              if(currentSubCase >= 8) {
                faceVolume_0[face1] = faceVolume[face1];
                faceVolume_0[face2] = faceVolume[face2];
                faceVolume_0[face3] = faceVolume[face3];
                cellVolume_0 = volume_C;
                for(MInt i = 0; i < 3; i++) {
                  cellCentroid_0[i] = coordinates_Cell[i];
                  faceCentroid_0[face1][i] = faceCentroid[face1][i];
                  faceCentroid_0[face2][i] = faceCentroid[face2][i];
                  faceCentroid_0[face3][i] = faceCentroid[face3][i];
                }
              }

              // 3rd Pyramid + 3rd cutFace
              subCaseDummy = tiling7_1STL[currentSubCase][2];
              p_0 = corner[cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
              p_1 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
              p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
              p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              face1 = facesMCtoSOLVER[tiling1STL[subCaseDummy][4]];
              face2 = facesMCtoSOLVER[tiling1STL[subCaseDummy][5]];
              face3 = facesMCtoSOLVER[tiling1STL[subCaseDummy][6]];

              if(currentSubCase < 8) {
                for(MInt face = 0; face < 6; face++) {
                  nfs_cur_00[face] = nfs1[subCaseDummy][face];
                }

                faceCut_00[face1] = true;
                faceCut_00[face2] = true;
                faceCut_00[face3] = true;

                computeTri(p_0, p_1, p_3, &faceVolume_00[face1], faceCentroid_00[face1]);
                computeTri(p_0, p_3, p_2, &faceVolume_00[face2], faceCentroid_00[face2]);
                computeTri(p_0, p_2, p_1, &faceVolume_00[face3], faceCentroid_00[face3]);

                computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

                computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

                // create 3rd Cut face & cell
                m_bndryCells->a[bndryId3].m_srfcs[0]->m_area = area_c;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId3].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
                  m_bndryCells->a[bndryId3].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
                }

                m_bndryCells->a[bndryId3].m_volume = volume_C;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId3].m_coordinates[dim] = coordinates_Cell[dim];
                }

                // fill ambiguous corners array
                cornerCellMapping[ambIds[bndryId] * 8 + cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]] = cellId3;

              } else {
                faceCut[face1] = true;
                faceCut[face2] = true;
                faceCut[face3] = true;

                computeTri(p_0, p_1, p_3, &faceVolume[face1], faceCentroid[face1]);
                computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2]);
                computeTri(p_0, p_2, p_1, &faceVolume[face3], faceCentroid[face3]);

                computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

                computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

                correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
                correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
                correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);

                correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

                correctNormal(normalVec_c);

                // create 2nd Cut face
                m_bndryCells->a[bndryId].m_srfcs[2]->m_area = area_c;
                m_bndryCells->a[bndryId].m_srfcs[2]->m_bndryCndId = m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId].m_srfcs[2]->m_coordinates[dim] = coordinates_c[dim];
                  m_bndryCells->a[bndryId].m_srfcs[2]->m_normalVector[dim] = normalVec_c[dim];
                }

                m_bndryCells->a[bndryId].m_volume = volume_C;
                for(MInt dim = 0; dim < 3; dim++) {
                  m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
                }
              }
              break;
            }
            default: {
              stringstream errorMessage;
              errorMessage << "ERROR: Switch variable 'disamb_tmp' with value " << disamb_tmp
                           << " not matching any case." << endl;
              mTerm(1, AT_, errorMessage.str());
            }
          }
          break;
        }
        case 10: {
          for(MInt i = 0; i < 6; i++) {
            faceVolume_0[i] = faceVolume[i];
            for(MInt j = 0; j < 3; j++) {
              faceCentroid_0[i][j] = faceCentroid[i][j];
            }
          }
          cellVolume_0 = gridCellVolume;
          for(MInt i = 0; i < 3; i++) {
            cellCentroid_0[i] = m_solver->a_coordinate(cellId, i);
          }

          if(disambiguation[bndryId] == 3) { // case 10.2, split cell

            cellId2 = createSplitCell_MGC(cellId, 1);
            bndryId2 = m_solver->a_bndryId(cellId2);
            m_splitParents[bndryId2] = bndryId;
            m_splitChildren[bndryId * 3 + 0] = bndryId2;
            if(bndryId == 0)
              cerr << " problem in FvBndryCnd3D::createCutFaceMGC, assuming cell 0 is no split cell failed! " << endl;
            m_bndryCells->a[bndryId].m_noSrfcs = 1;
            m_bndryCells->a[bndryId2].m_noSrfcs = 1;

            // 1st prism & 1st cutFace
            subCaseDummy = tiling10_2STL[currentSubCase][0];
            for(MInt face = 0; face < 6; face++) {
              nfs_cur[face] = nfs2[subCaseDummy][face];
            }
            p_0 = corner[cornersMCtoSOLVER[tiling2STL[subCaseDummy][0]]];
            p_0s = corner[cornersMCtoSOLVER[tiling2STL[subCaseDummy][1]]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][2]];
            p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][3]];
            p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][4]];
            p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][5]];
            p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            face1 = facesMCtoSOLVER[tiling2STL[subCaseDummy][6]];
            face2 = facesMCtoSOLVER[tiling2STL[subCaseDummy][7]];
            face3 = facesMCtoSOLVER[tiling2STL[subCaseDummy][8]];
            face4 = facesMCtoSOLVER[tiling2STL[subCaseDummy][9]];

            computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2], normal[face2]);
            computeTri(p_0s, p_3s, p_2s, &faceVolume[face3], faceCentroid[face3], normal[face3]);
            computeTrapez(p_0, p_0s, p_3s, p_3, &faceVolume[face1], faceCentroid[face1], normal[face1]);
            computeTrapez(p_2, p_2s, p_0s, p_0, &faceVolume[face4], faceCentroid[face4], normal[face4]);

            computePoly4(p_3, p_3s, p_2s, p_2, &area_c, coordinates_c, normalVec_c);

            maia::math::vecAvg<3>(M, p_0, p_0s, p_2, p_2s, p_3, p_3s);

            for(MInt i = 0; i < 4; i++) {
              computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                          &pyraVolume[i], pyraCentroid[i]);
            }
            computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[4], pyraCentroid[4]);
            for(MInt i = 0; i < 5; i++) {
              volume_C += pyraVolume[i];
              maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
            }
            vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

            faceCut[face1] = true;
            faceCut[face2] = true;
            faceCut[face3] = true;
            faceCut[face4] = true;

            // create 1st Cut face and 1st cell
            m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
              m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            }

            m_bndryCells->a[bndryId].m_volume = volume_C;
            volume_C = 0;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
              coordinates_Cell[dim] = F0;
            }

            // 2nd Prism + 2nd cutFace = 2nd cell
            subCaseDummy = tiling10_2STL[currentSubCase][1];
            for(MInt face = 0; face < 6; face++) {
              nfs_cur_0[face] = nfs2[subCaseDummy][face];
            }
            p_0 = corner[cornersMCtoSOLVER[tiling2STL[subCaseDummy][0]]];
            p_0s = corner[cornersMCtoSOLVER[tiling2STL[subCaseDummy][1]]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][2]];
            p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][3]];
            p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][4]];
            p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][5]];
            p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            face1 = facesMCtoSOLVER[tiling2STL[subCaseDummy][6]];
            face2 = facesMCtoSOLVER[tiling2STL[subCaseDummy][7]];
            face3 = facesMCtoSOLVER[tiling2STL[subCaseDummy][8]];
            face4 = facesMCtoSOLVER[tiling2STL[subCaseDummy][9]];

            computeTri(p_0, p_3, p_2, &faceVolume_0[face2], faceCentroid_0[face2], normal[face2]);
            computeTri(p_0s, p_3s, p_2s, &faceVolume_0[face3], faceCentroid_0[face3], normal[face3]);
            computeTrapez(p_0, p_0s, p_3s, p_3, &faceVolume_0[face1], faceCentroid_0[face1], normal[face1]);
            computeTrapez(p_2, p_2s, p_0s, p_0, &faceVolume_0[face4], faceCentroid_0[face4], normal[face4]);

            computePoly4(p_3, p_3s, p_2s, p_2, &area_c, coordinates_c, normalVec_c);

            maia::math::vecAvg<3>(M, p_0, p_0s, p_2, p_2s, p_3, p_3s);

            for(MInt i = 0; i < 4; i++) {
              computePyra(&faceVolume_0[*facepointers[i]], faceCentroid_0[*facepointers[i]], normal[*facepointers[i]],
                          M, &pyraVolume[i], pyraCentroid[i]);
            }
            computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[4], pyraCentroid[4]);
            for(MInt i = 0; i < 5; i++) {
              volume_C += pyraVolume[i];
              maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
            }
            vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

            faceCut_0[face1] = true;
            faceCut_0[face2] = true;
            faceCut_0[face3] = true;
            faceCut_0[face4] = true;

            // create 2nd Cut face
            m_bndryCells->a[bndryId2].m_srfcs[0]->m_area = area_c;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId2].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
              m_bndryCells->a[bndryId2].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            }

            m_bndryCells->a[bndryId2].m_volume = volume_C;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId2].m_coordinates[dim] = coordinates_Cell[dim];
            }

            // fill ambiguous corner array
            cornerCellMapping[ambIds[bndryId] * 8 + cornersMCtoSOLVER[tiling2STL[subCaseDummy][0]]] = cellId2;
            cornerCellMapping[ambIds[bndryId] * 8 + cornersMCtoSOLVER[tiling2STL[subCaseDummy][1]]] = cellId2;

          } else if(disambiguation[bndryId] == 0) {
            // case 10_1 - 2 surfaces, connected cell

            m_bndryCells->a[bndryId].m_noSrfcs = 2;
            for(MInt face = 0; face < 6; face++) {
              nfs_cur[face] = nfs10[currentSubCase][face];
            }

            // 1st prism & 1st cutFace
            subCaseDummy = tiling10_1STL[currentSubCase][0];
            p_0 = corner[cornersMCtoSOLVER[tiling2STL[subCaseDummy][0]]];
            p_0s = corner[cornersMCtoSOLVER[tiling2STL[subCaseDummy][1]]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][2]];
            p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][3]];
            p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][4]];
            p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][5]];
            p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            face1 = facesMCtoSOLVER[tiling2STL[subCaseDummy][6]];
            face2 = facesMCtoSOLVER[tiling2STL[subCaseDummy][7]];
            face3 = facesMCtoSOLVER[tiling2STL[subCaseDummy][8]];
            face4 = facesMCtoSOLVER[tiling2STL[subCaseDummy][9]];

            computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2], normal[face2]);
            computeTri(p_0s, p_3s, p_2s, &faceVolume[face3], faceCentroid[face3], normal[face3]);
            computeTrapez(p_0, p_0s, p_3s, p_3, &faceVolume[face1], faceCentroid[face1], normal[face1]);
            computeTrapez(p_2, p_2s, p_0s, p_0, &faceVolume[face4], faceCentroid[face4], normal[face4]);

            computePoly4(p_3, p_3s, p_2s, p_2, &area_c, coordinates_c, normalVec_c);

            maia::math::vecAvg<3>(M, p_0, p_0s, p_2, p_2s, p_3, p_3s);

            for(MInt i = 0; i < 4; i++) {
              computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                          &pyraVolume[i], pyraCentroid[i]);
            }
            computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[4], pyraCentroid[4]);
            for(MInt i = 0; i < 5; i++) {
              volume_C += pyraVolume[i];
              maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
            }
            vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

            correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
            correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
            correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);
            correctFace(&faceVolume[face4], faceCentroid[face4], &faceVolume_0[face4], faceCentroid_0[face4]);

            correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

            correctNormal(normalVec_c);

            faceCut[face1] = true;
            faceCut[face2] = true;
            faceCut[face3] = true;
            faceCut[face4] = true;

            // create 1st Cut face
            m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
              m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            }

            faceVolume_0[face1] = faceVolume[face1];
            faceVolume_0[face2] = faceVolume[face2];
            faceVolume_0[face3] = faceVolume[face3];
            faceVolume_0[face4] = faceVolume[face4];
            cellVolume_0 = volume_C;
            volume_C = 0;
            for(MInt i = 0; i < 3; i++) {
              cellCentroid_0[i] = coordinates_Cell[i];
              faceCentroid_0[face1][i] = faceCentroid[face1][i];
              faceCentroid_0[face2][i] = faceCentroid[face2][i];
              faceCentroid_0[face3][i] = faceCentroid[face3][i];
              faceCentroid_0[face4][i] = faceCentroid[face4][i];
              coordinates_Cell[i] = 0;
            }

            // 2nd Prism + 2nd cutFace
            subCaseDummy = tiling10_1STL[currentSubCase][1];
            p_0 = corner[cornersMCtoSOLVER[tiling2STL[subCaseDummy][0]]];
            p_0s = corner[cornersMCtoSOLVER[tiling2STL[subCaseDummy][1]]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][2]];
            p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][3]];
            p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][4]];
            p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][5]];
            p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            face1 = facesMCtoSOLVER[tiling2STL[subCaseDummy][6]];
            face2 = facesMCtoSOLVER[tiling2STL[subCaseDummy][7]];
            face3 = facesMCtoSOLVER[tiling2STL[subCaseDummy][8]];
            face4 = facesMCtoSOLVER[tiling2STL[subCaseDummy][9]];

            computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2], normal[face2]);
            computeTri(p_0s, p_3s, p_2s, &faceVolume[face3], faceCentroid[face3], normal[face3]);
            computeTrapez(p_0, p_0s, p_3s, p_3, &faceVolume[face1], faceCentroid[face1], normal[face1]);
            computeTrapez(p_2, p_2s, p_0s, p_0, &faceVolume[face4], faceCentroid[face4], normal[face4]);

            computePoly4(p_3, p_3s, p_2s, p_2, &area_c, coordinates_c, normalVec_c);

            maia::math::vecAvg<3>(M, p_0, p_0s, p_2, p_2s, p_3, p_3s);

            for(MInt i = 0; i < 4; i++) {
              computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                          &pyraVolume[i], pyraCentroid[i]);
            }
            computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[4], pyraCentroid[4]);
            for(MInt i = 0; i < 5; i++) {
              volume_C += pyraVolume[i];
              maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
            }
            vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

            correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
            correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
            correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);
            correctFace(&faceVolume[face4], faceCentroid[face4], &faceVolume_0[face4], faceCentroid_0[face4]);

            correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

            correctNormal(normalVec_c);

            faceCut[face1] = true;
            faceCut[face2] = true;
            faceCut[face3] = true;
            faceCut[face4] = true;

            // create 2nd Cut face
            m_bndryCells->a[bndryId].m_srfcs[1]->m_area = area_c;
            m_bndryCells->a[bndryId].m_srfcs[1]->m_bndryCndId = m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_srfcs[1]->m_coordinates[dim] = coordinates_c[dim];
              m_bndryCells->a[bndryId].m_srfcs[1]->m_normalVector[dim] = normalVec_c[dim];
            }

            m_bndryCells->a[bndryId].m_volume = volume_C;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
            }
          }
          break;
        }
        case 12: {
          for(MInt i = 0; i < 6; i++) {
            faceVolume_0[i] = faceVolume[i];
            for(MInt j = 0; j < 3; j++) {
              faceCentroid_0[i][j] = faceCentroid[i][j];
            }
          }
          cellVolume_0 = gridCellVolume;
          for(MInt i = 0; i < 3; i++) {
            cellCentroid_0[i] = m_solver->a_coordinate(cellId, i);
          }

          if(disambiguation[bndryId] == 3) { // case 12.1 disconnected, split cell

            cellId2 = createSplitCell_MGC(cellId, 1);
            bndryId2 = m_solver->a_bndryId(cellId2);
            m_splitParents[bndryId2] = bndryId;
            m_splitChildren[bndryId * 3 + 0] = bndryId2;
            if(bndryId == 0)
              cerr << " problem in FvBndryCnd3D::createCutFaceMGC, assuming cell 0 is no split cell failed! " << endl;
            m_bndryCells->a[bndryId].m_noSrfcs = 1;
            m_bndryCells->a[bndryId2].m_noSrfcs = 1;

            // 1st case 5 cell & 1st cutFace
            subCaseDummy = tiling12_1STL[23 - currentSubCase][0];
            for(MInt face = 0; face < 6; face++) {
              nfs_cur[face] = nfs5[subCaseDummy][face];
            }
            p_0 = corner[cornersMCtoSOLVER[tiling5STL[subCaseDummy][0]]];
            p_1 = corner[cornersMCtoSOLVER[tiling5STL[subCaseDummy][1]]];
            p_2 = corner[cornersMCtoSOLVER[tiling5STL[subCaseDummy][2]]];
            cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][3]];
            p_0s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][4]];
            p_0ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][5]];
            p_1s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][6]];
            p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][7]];
            p_2ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            face1 = facesMCtoSOLVER[tiling5STL[subCaseDummy][8]];
            face2 = facesMCtoSOLVER[tiling5STL[subCaseDummy][9]];
            face3 = facesMCtoSOLVER[tiling5STL[subCaseDummy][10]];
            face4 = facesMCtoSOLVER[tiling5STL[subCaseDummy][11]];
            face5 = facesMCtoSOLVER[tiling5STL[subCaseDummy][12]];

            computePoly5(p_0, p_0ss, p_2ss, p_2, p_1, &faceVolume[face1], faceCentroid[face1], normal[face1]);
            computeTri(p_0ss, p_0, p_0s, &faceVolume[face2], faceCentroid[face2], normal[face2]);
            computeTrapez(p_0, p_1, p_1s, p_0s, &faceVolume[face3], faceCentroid[face3], normal[face3]);
            computeTrapez(p_1, p_1s, p_2s, p_2, &faceVolume[face4], faceCentroid[face4], normal[face4]);
            computeTri(p_2s, p_2, p_2ss, &faceVolume[face5], faceCentroid[face5], normal[face5]);

            computePoly5(p_0s, p_1s, p_2s, p_2ss, p_0ss, &area_c, coordinates_c, normalVec_c);

            maia::math::vecAvg<3>(M, p_0, p_1, p_2, p_0s, p_1s, p_2s, p_0ss, p_2ss);

            for(MInt i = 0; i < 5; i++) {
              computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                          &pyraVolume[i], pyraCentroid[i]);
            }
            computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[5], pyraCentroid[5]);
            for(MInt i = 0; i < 6; i++) {
              volume_C += pyraVolume[i];
              maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
            }
            vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

            faceCut[face1] = true;
            faceCut[face2] = true;
            faceCut[face3] = true;
            faceCut[face4] = true;
            faceCut[face5] = true;

            // create 1st Cut face
            m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
              m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            }

            m_bndryCells->a[bndryId].m_volume = volume_C;
            volume_C = 0;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
              coordinates_Cell[dim] = m_solver->a_coordinate(cellId, dim);
            }

            // 2nd Pyramid + 2nd cutFace = 2nd cell
            subCaseDummy = tiling12_1STL[23 - currentSubCase][1];
            for(MInt face = 0; face < 6; face++) {
              nfs_cur_0[face] = nfs1[subCaseDummy][face];
            }
            p_0 = corner[cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
            p_1 = m_bndryCells->a[bndryId2].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
            p_2 = m_bndryCells->a[bndryId2].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
            p_3 = m_bndryCells->a[bndryId2].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            face1 = facesMCtoSOLVER[tiling1STL[subCaseDummy][4]];
            face2 = facesMCtoSOLVER[tiling1STL[subCaseDummy][5]];
            face3 = facesMCtoSOLVER[tiling1STL[subCaseDummy][6]];

            faceCut_0[face1] = true;
            faceCut_0[face2] = true;
            faceCut_0[face3] = true;

            computeTri(p_0, p_1, p_3, &faceVolume_0[face1], faceCentroid_0[face1]);
            computeTri(p_0, p_3, p_2, &faceVolume_0[face2], faceCentroid_0[face2]);
            computeTri(p_0, p_2, p_1, &faceVolume_0[face3], faceCentroid_0[face3]);

            computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

            computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

            m_bndryCells->a[bndryId2].m_volume = volume_C;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId2].m_coordinates[dim] = coordinates_Cell[dim];
            }

            // create 2nd Cut face
            m_bndryCells->a[bndryId2].m_srfcs[0]->m_area = area_c;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId2].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
              m_bndryCells->a[bndryId2].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            }

            // fill ambiguous corner array
            cornerCellMapping[ambIds[bndryId] * 8 + cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]] = cellId2;

          } else if(disambiguation[bndryId] == 0) {
            // case 12_1 - 2 surfaces, connected cell

            m_bndryCells->a[bndryId].m_noSrfcs = 2;
            for(MInt face = 0; face < 6; face++) {
              nfs_cur[face] = nfs12_1[currentSubCase][face];
            }

            // 1st case 5 cell & 1st cutFace
            subCaseDummy = tiling12_1STL[currentSubCase][0];

            p_0 = corner[cornersMCtoSOLVER[tiling5STL[subCaseDummy][0]]];
            p_1 = corner[cornersMCtoSOLVER[tiling5STL[subCaseDummy][1]]];
            p_2 = corner[cornersMCtoSOLVER[tiling5STL[subCaseDummy][2]]];
            cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][3]];
            p_0s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][4]];
            p_0ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][5]];
            p_1s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][6]];
            p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][7]];
            p_2ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            face1 = facesMCtoSOLVER[tiling5STL[subCaseDummy][8]];
            face2 = facesMCtoSOLVER[tiling5STL[subCaseDummy][9]];
            face3 = facesMCtoSOLVER[tiling5STL[subCaseDummy][10]];
            face4 = facesMCtoSOLVER[tiling5STL[subCaseDummy][11]];
            face5 = facesMCtoSOLVER[tiling5STL[subCaseDummy][12]];

            computePoly5(p_0, p_0ss, p_2ss, p_2, p_1, &faceVolume[face1], faceCentroid[face1], normal[face1]);
            computeTri(p_0ss, p_0, p_0s, &faceVolume[face2], faceCentroid[face2], normal[face2]);
            computeTrapez(p_0, p_1, p_1s, p_0s, &faceVolume[face3], faceCentroid[face3], normal[face3]);
            computeTrapez(p_1, p_1s, p_2s, p_2, &faceVolume[face4], faceCentroid[face4], normal[face4]);
            computeTri(p_2s, p_2, p_2ss, &faceVolume[face5], faceCentroid[face5], normal[face5]);

            computePoly5(p_0s, p_1s, p_2s, p_2ss, p_0ss, &area_c, coordinates_c, normalVec_c);

            maia::math::vecAvg<3>(M, p_0, p_1, p_2, p_0s, p_1s, p_2s, p_0ss, p_2ss);

            for(MInt i = 0; i < 5; i++) {
              computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                          &pyraVolume[i], pyraCentroid[i]);
            }
            computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[5], pyraCentroid[5]);
            for(MInt i = 0; i < 6; i++) {
              volume_C += pyraVolume[i];
              maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
            }
            vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

            correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
            correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
            correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);
            correctFace(&faceVolume[face4], faceCentroid[face4], &faceVolume_0[face4], faceCentroid_0[face4]);
            correctFace(&faceVolume[face5], faceCentroid[face5], &faceVolume_0[face5], faceCentroid_0[face5]);

            correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

            correctNormal(normalVec_c);

            faceCut[face1] = true;
            faceCut[face2] = true;
            faceCut[face3] = true;
            faceCut[face4] = true;
            faceCut[face5] = true;

            // create 1st Cut face
            m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
              m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            }

            faceVolume_0[face1] = faceVolume[face1];
            faceVolume_0[face2] = faceVolume[face2];
            faceVolume_0[face3] = faceVolume[face3];
            faceVolume_0[face4] = faceVolume[face4];
            faceVolume_0[face5] = faceVolume[face5];
            cellVolume_0 = volume_C;
            volume_C = 0;
            for(MInt i = 0; i < 3; i++) {
              cellCentroid_0[i] = coordinates_Cell[i];
              faceCentroid_0[face1][i] = faceCentroid[face1][i];
              faceCentroid_0[face2][i] = faceCentroid[face2][i];
              faceCentroid_0[face3][i] = faceCentroid[face3][i];
              faceCentroid_0[face4][i] = faceCentroid[face4][i];
              faceCentroid_0[face5][i] = faceCentroid[face5][i];
              coordinates_Cell[i] = 0;
            }

            // 2nd Pyramid + 2nd cutFace
            subCaseDummy = tiling12_1STL[currentSubCase][1];
            p_0 = corner[cornersMCtoSOLVER[tiling1STL[subCaseDummy][0]]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
            p_1 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
            p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
            p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
            face1 = facesMCtoSOLVER[tiling1STL[subCaseDummy][4]];
            face2 = facesMCtoSOLVER[tiling1STL[subCaseDummy][5]];
            face3 = facesMCtoSOLVER[tiling1STL[subCaseDummy][6]];

            faceCut[face1] = true;
            faceCut[face2] = true;
            faceCut[face3] = true;

            computeTri(p_0, p_1, p_3, &faceVolume[face1], faceCentroid[face1]);
            computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2]);
            computeTri(p_0, p_2, p_1, &faceVolume[face3], faceCentroid[face3]);

            computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

            computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

            correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
            correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
            correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);

            correctCell(&volume_C, coordinates_Cell, &cellVolume_0, cellCentroid_0);

            correctNormal(normalVec_c);

            // create 2nd Cut face
            m_bndryCells->a[bndryId].m_srfcs[1]->m_area = area_c;
            m_bndryCells->a[bndryId].m_srfcs[1]->m_bndryCndId = m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_srfcs[1]->m_coordinates[dim] = coordinates_c[dim];
              m_bndryCells->a[bndryId].m_srfcs[1]->m_normalVector[dim] = normalVec_c[dim];
            }

            m_bndryCells->a[bndryId].m_volume = volume_C;
            for(MInt dim = 0; dim < 3; dim++) {
              m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
            }
          }
          break;
        }
        default: {
          mTerm(1, AT_, "Unknown case probably in disamb_tmp");
        }
      }

      for(MInt i = 0; i < nDim; i++) {
        m_bndryCells->a[bndryId].m_coordinates[i] -= m_solver->a_coordinate(cellId, i);
      }
      if(splitCell[bndryId]) {
        for(MInt i = 0; i < nDim; i++) {
          m_bndryCells->a[bndryId2].m_coordinates[i] -= m_solver->a_coordinate(cellId2, i);
        }
      }
      if(currentCase == 7 && disamb_tmp == 7) {
        for(MInt i = 0; i < nDim; i++) {
          m_bndryCells->a[bndryId3].m_coordinates[i] -= m_solver->a_coordinate(cellId3, i);
        }
      }

      // face data is assembled
      // create a surface for the cut face if a boundary cell neighbor exists
      if(!splitFace[bndryId]) { // cell can be split cell. here, the first cell is connected
        for(MInt face = 0; face < 6; face++) {
          m_bndryCells->a[bndryId].m_associatedSrfc[face] = -1;
          if(!faceCut[face]) continue;
          sideId = face % 2;
          spaceId = face / 2;
          if(nfs_cur[face]) {
            if(m_solver->a_hasNeighbor(cellId, face) > 0)
              nghbrId = m_solver->c_neighborId(cellId, face);
            else {
              if(m_solver->c_parentId(cellId) > -1) {
                if(m_solver->a_hasNeighbor(m_solver->c_parentId(cellId), face) > 0)
                  nghbrId = m_solver->c_neighborId(m_solver->c_parentId(cellId), face);
                else
                  continue;
              } else
                continue;
            }
            if(m_solver->c_noChildren(nghbrId) > 0) continue;
            otherSideId = (sideId + 1) % 2;
            srfcId = m_solver->a_noSurfaces();
            m_surfaces.append();
            m_solver->a_surfaceOrientation(srfcId) = spaceId;
            m_solver->a_surfaceNghbrCellId(srfcId, sideId) = nghbrId;
            m_solver->a_surfaceNghbrCellId(srfcId, otherSideId) = cellId;
            for(MInt dim = 0; dim < nDim; dim++) {
              m_solver->a_surfaceCoordinate(srfcId, dim) = faceCentroid[face][dim];
            }
            m_solver->a_surfaceArea(srfcId) = faceVolume[face];
            m_bndryCells->a[bndryId].m_associatedSrfc[face] = srfcId;
          } else {
            stringstream errorMessage;
            errorMessage << "Error in FvBndryCnd3D::createCutFaceMGC - 1. Problem with face " << face << endl;
            errorMessage << "bndryId: " << bndryId << endl;
            errorMessage << "cellId: " << cellId << endl;
            errorMessage << "bndryCnd: " << m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
            errorMessage << "case, subcase: " << currentCase << ", " << currentSubCase << endl;
            errorMessage << "disamb: " << disambiguation[bndryId] << endl;
            errorMessage << "face Volumes: " << faceVolume[0] << ", " << faceVolume[1] << ", " << faceVolume[2] << ", "
                         << faceVolume[3] << ", " << faceVolume[4] << ", " << faceVolume[5] << endl;
            errorMessage << "faceCentroids: ";
            for(MInt i = 0; i < 6; i++) {
              errorMessage << faceCentroid[i][0] << ", " << faceCentroid[i][1] << ", " << faceCentroid[i][2] << "; "
                           << endl;
            }
            errorMessage << "area_c = " << area_c << endl;
            errorMessage << "normalVec_c = " << normalVec_c[0] << ", " << normalVec_c[1] << ", " << normalVec_c[2]
                         << endl;
            errorMessage << "coordinates_c = " << coordinates_c[0] << ", " << coordinates_c[1] << ", "
                         << coordinates_c[2] << endl;
            errorMessage << "coordinates_Cell = " << coordinates_Cell[0] << ", " << coordinates_Cell[1] << ", "
                         << coordinates_Cell[2] << endl;
            errorMessage << "volume_C = " << volume_C << endl;
            mTerm(1, AT_, errorMessage.str());
          }
        }
      }
      if(splitFace[bndryId]) { // cell is not a split cell. here, both split surfaces are created and connected
        for(MInt face = 0; face < 6; face++) {
          m_bndryCells->a[bndryId].m_associatedSrfc[face] = -1;
          if(!faceCut[face]) continue;
          sideId = face % 2;
          spaceId = face / 2;
          if(nfs_cur[face]) {
            if(m_solver->a_hasNeighbor(cellId, face) > 0)
              nghbrId = m_solver->c_neighborId(cellId, face);
            else {
              if(m_solver->c_parentId(cellId) > -1) {
                if(m_solver->a_hasNeighbor(m_solver->c_parentId(cellId), face) > 0)
                  nghbrId = m_solver->c_neighborId(m_solver->c_parentId(cellId), face);
                else
                  continue;
              } else
                continue;
            }
            if(m_solver->c_noChildren(nghbrId) > 0) continue;
            otherSideId = (sideId + 1) % 2;
            if(face == splitFaceId) {
              // first surface
              srfcId = m_solver->a_noSurfaces();
              m_surfaces.append();
              m_solver->a_surfaceOrientation(srfcId) = spaceId;
              m_solver->a_surfaceNghbrCellId(srfcId, sideId) = nghbrId;
              m_solver->a_surfaceNghbrCellId(srfcId, otherSideId) = cellId;
              for(MInt dim = 0; dim < nDim; dim++) {
                m_solver->a_surfaceCoordinate(srfcId, dim) = splitFaceCentroid[0][dim];
              }
              m_solver->a_surfaceArea(srfcId) = splitFaceVolume[0];
              m_splitSurfaces[splitSurfaceIndexCounter * 6] = srfcId;
              m_splitSurfaces[splitSurfaceIndexCounter * 6 + 1] = splitCorner1;
              m_splitSurfaces[splitSurfaceIndexCounter * 6 + 2] = splitCorner1 + neighborCorner[face];
              // second surface
              srfcId = m_solver->a_noSurfaces();
              m_surfaces.append();
              m_solver->a_surfaceOrientation(srfcId) = spaceId;
              m_solver->a_surfaceNghbrCellId(srfcId, sideId) = nghbrId;
              m_solver->a_surfaceNghbrCellId(srfcId, otherSideId) = cellId;
              for(MInt dim = 0; dim < nDim; dim++) {
                m_solver->a_surfaceCoordinate(srfcId, dim) = splitFaceCentroid[1][dim];
              }
              m_solver->a_surfaceArea(srfcId) = splitFaceVolume[1];
              m_splitSurfaces[splitSurfaceIndexCounter * 6 + 3] = srfcId;
              m_splitSurfaces[splitSurfaceIndexCounter * 6 + 3 + 1] = splitCorner2;
              m_splitSurfaces[splitSurfaceIndexCounter * 6 + 3 + 2] = splitCorner2 + neighborCorner[face];
              // set associated Srfc Pointer
              m_bndryCells->a[bndryId].m_associatedSrfc[face] = -splitSurfaceIndexCounter;
              splitSurfaceIndexCounter++;
            } else {
              srfcId = m_solver->a_noSurfaces();
              m_surfaces.append();
              m_solver->a_surfaceOrientation(srfcId) = spaceId;
              m_solver->a_surfaceNghbrCellId(srfcId, sideId) = nghbrId;
              m_solver->a_surfaceNghbrCellId(srfcId, otherSideId) = cellId;
              for(MInt dim = 0; dim < nDim; dim++) {
                m_solver->a_surfaceCoordinate(srfcId, dim) = faceCentroid[face][dim];
              }
              m_solver->a_surfaceArea(srfcId) = faceVolume[face];
              m_bndryCells->a[bndryId].m_associatedSrfc[face] = srfcId;
            }
          } else {
            stringstream errorMessage;
            errorMessage << "Error in FvBndryCnd3D::createCutFaceMGC - 2. Problem with face " << face << endl;
            errorMessage << "bndryId: " << bndryId << endl;
            errorMessage << "cellId: " << cellId << endl;
            errorMessage << "bndryCnd: " << m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
            errorMessage << "case, subcase: " << currentCase << ", " << currentSubCase << endl;
            errorMessage << "disamb: " << disambiguation[bndryId] << endl;
            errorMessage << "face Volumes: " << faceVolume[0] << ", " << faceVolume[1] << ", " << faceVolume[2] << ", "
                         << faceVolume[3] << ", " << faceVolume[4] << ", " << faceVolume[5] << endl;
            errorMessage << "faceCentroids: ";
            for(MInt i = 0; i < 6; i++) {
              errorMessage << faceCentroid[i][0] << ", " << faceCentroid[i][1] << ", " << faceCentroid[i][2] << "; "
                           << endl;
            }
            errorMessage << "area_c = " << area_c << endl;
            errorMessage << "normalVec_c = " << normalVec_c[0] << ", " << normalVec_c[1] << ", " << normalVec_c[2]
                         << endl;
            errorMessage << "coordinates_c = " << coordinates_c[0] << ", " << coordinates_c[1] << ", "
                         << coordinates_c[2] << endl;
            errorMessage << "coordinates_Cell = " << coordinates_Cell[0] << ", " << coordinates_Cell[1] << ", "
                         << coordinates_Cell[2] << endl;
            errorMessage << "volume_C = " << volume_C << endl;
            mTerm(1, AT_, errorMessage.str());
          }
        }
      }
      if(currentCase == 7 && currentSubCase >= 8
         && (disamb_tmp == 1 || disamb_tmp == 2
             || disamb_tmp == 4)) { // cell is not a split cell but a 7.3 cell. here, the additional split surfaces are
                                    // created and connected
        for(MInt face = 0; face < 6; face++) {
          if(face != splitFaceId2) continue;
          if(!faceCut[face]) continue;
          sideId = face % 2;
          spaceId = face / 2;
          if(nfs_cur[face]) {
            if(m_solver->a_hasNeighbor(cellId, face) > 0)
              nghbrId = m_solver->c_neighborId(cellId, face);
            else {
              if(m_solver->c_parentId(cellId) > -1) {
                if(m_solver->a_hasNeighbor(m_solver->c_parentId(cellId), face) > 0)
                  nghbrId = m_solver->c_neighborId(m_solver->c_parentId(cellId), face);
                else
                  continue;
              } else
                continue;
            }
            if(m_solver->c_noChildren(nghbrId) > 0) continue;
            otherSideId = (sideId + 1) % 2;
            // first surface
            srfcId = m_solver->a_noSurfaces();
            m_surfaces.append();
            m_solver->a_surfaceOrientation(srfcId) = spaceId;
            m_solver->a_surfaceNghbrCellId(srfcId, sideId) = nghbrId;
            m_solver->a_surfaceNghbrCellId(srfcId, otherSideId) = cellId;
            for(MInt dim = 0; dim < nDim; dim++) {
              m_solver->a_surfaceCoordinate(srfcId, dim) = splitFaceCentroid2[0][dim];
            }
            m_solver->a_surfaceArea(srfcId) = splitFaceVolume2[0];
            m_splitSurfaces[splitSurfaceIndexCounter * 6] = srfcId;
            m_splitSurfaces[splitSurfaceIndexCounter * 6 + 1] = splitCorner12;
            m_splitSurfaces[splitSurfaceIndexCounter * 6 + 2] = splitCorner12 + neighborCorner[face];
            // second surface
            srfcId = m_solver->a_noSurfaces();
            m_surfaces.append();
            m_solver->a_surfaceOrientation(srfcId) = spaceId;
            m_solver->a_surfaceNghbrCellId(srfcId, sideId) = nghbrId;
            m_solver->a_surfaceNghbrCellId(srfcId, otherSideId) = cellId;
            for(MInt dim = 0; dim < nDim; dim++) {
              m_solver->a_surfaceCoordinate(srfcId, dim) = splitFaceCentroid2[1][dim];
            }
            m_solver->a_surfaceArea(srfcId) = splitFaceVolume2[1];
            m_splitSurfaces[splitSurfaceIndexCounter * 6 + 3] = srfcId;
            m_splitSurfaces[splitSurfaceIndexCounter * 6 + 3 + 1] = splitCorner22;
            m_splitSurfaces[splitSurfaceIndexCounter * 6 + 3 + 2] = splitCorner22 + neighborCorner[face];
            // set associated Srfc Pointer
            m_bndryCells->a[bndryId].m_associatedSrfc[face] = -splitSurfaceIndexCounter;
            splitSurfaceIndexCounter++;
          } else {
            stringstream errorMessage;
            errorMessage << "Error in FvBndryCnd3D::createCutFaceMGC - 3. Problem with face " << face << endl;
            errorMessage << "bndryId: " << bndryId << endl;
            errorMessage << "cellId: " << cellId << endl;
            errorMessage << "bndryCnd: " << m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
            errorMessage << "case, subcase: " << currentCase << ", " << currentSubCase << endl;
            errorMessage << "disamb: " << disambiguation[bndryId] << endl;
            errorMessage << "face Volumes: " << faceVolume[0] << ", " << faceVolume[1] << ", " << faceVolume[2] << ", "
                         << faceVolume[3] << ", " << faceVolume[4] << ", " << faceVolume[5] << endl;
            errorMessage << "faceCentroids: ";
            for(MInt i = 0; i < 6; i++) {
              errorMessage << faceCentroid[i][0] << ", " << faceCentroid[i][1] << ", " << faceCentroid[i][2] << "; "
                           << endl;
            }
            errorMessage << "area_c = " << area_c << endl;
            errorMessage << "normalVec_c = " << normalVec_c[0] << ", " << normalVec_c[1] << ", " << normalVec_c[2]
                         << endl;
            errorMessage << "coordinates_c = " << coordinates_c[0] << ", " << coordinates_c[1] << ", "
                         << coordinates_c[2] << endl;
            errorMessage << "coordinates_Cell = " << coordinates_Cell[0] << ", " << coordinates_Cell[1] << ", "
                         << coordinates_Cell[2] << endl;
            errorMessage << "volume_C = " << volume_C << endl;
            mTerm(1, AT_, errorMessage.str());
          }
        }
      }
      if(splitCell[bndryId]) { // first cell has been connected in standard routine above
        for(MInt face = 0; face < 6; face++) {
          m_bndryCells->a[bndryId2].m_associatedSrfc[face] = -1;
          if(!faceCut_0[face]) continue;
          sideId = face % 2;
          spaceId = face / 2;
          if(nfs_cur_0[face]) {
            // Timw: consider cellId2 as a SplitChild
            MInt splitChildId = cellId2;
            if(m_solver->a_hasProperty(cellId2, SolverCell::IsSplitClone))
              cellId2 = m_solver->m_splitChildToSplitCell.find(cellId2)->second;
            if(m_solver->a_hasNeighbor(cellId2, face) > 0)
              nghbrId = m_solver->c_neighborId(cellId2, face);
            else {
              if(m_solver->c_parentId(cellId2) > -1) {
                if(m_solver->a_hasNeighbor(m_solver->c_parentId(cellId2), face) > 0)
                  nghbrId = m_solver->c_neighborId(m_solver->c_parentId(cellId2), face);
                else
                  continue;
              } else
                continue;
            }
            cellId2 = splitChildId;
            if(m_solver->c_noChildren(nghbrId) > 0) continue;
            otherSideId = (sideId + 1) % 2;
            srfcId = m_solver->a_noSurfaces();
            m_surfaces.append();
            m_solver->a_surfaceOrientation(srfcId) = spaceId;
            m_solver->a_surfaceNghbrCellId(srfcId, sideId) = nghbrId;
            m_solver->a_surfaceNghbrCellId(srfcId, otherSideId) = cellId2;
            for(MInt dim = 0; dim < nDim; dim++) {
              m_solver->a_surfaceCoordinate(srfcId, dim) = faceCentroid_0[face][dim];
            }
            m_solver->a_surfaceArea(srfcId) = faceVolume_0[face];
            m_bndryCells->a[bndryId2].m_associatedSrfc[face] = srfcId;
          } else {
            stringstream errorMessage;
            errorMessage << "Error in FvBndryCnd3D::createCutFaceMGC - 4. Problem with face " << face << endl;
            errorMessage << "bndryId: " << bndryId2 << endl;
            errorMessage << "cellId: " << cellId2 << endl;
            errorMessage << "split cell! Twin: " << bndryId << endl;
            errorMessage << "bndryCnd: " << m_bndryCells->a[bndryId2].m_srfcs[0]->m_bndryCndId;
            errorMessage << "case, subcase: " << currentCase << ", " << currentSubCase << endl;
            errorMessage << "disamb: " << disambiguation[bndryId] << endl;
            errorMessage << "face Volumes: " << faceVolume_0[0] << ", " << faceVolume_0[1] << ", " << faceVolume_0[2]
                         << ", " << faceVolume_0[3] << ", " << faceVolume_0[4] << ", " << faceVolume_0[5] << endl;
            errorMessage << "faceCentroids: ";
            for(MInt i = 0; i < 6; i++) {
              errorMessage << faceCentroid_0[i][0] << ", " << faceCentroid_0[i][1] << ", " << faceCentroid_0[i][2]
                           << "; " << endl;
            }
            errorMessage << "area_c = " << area_c << endl;
            errorMessage << "normalVec_c = " << normalVec_c[0] << ", " << normalVec_c[1] << ", " << normalVec_c[2]
                         << endl;
            errorMessage << "coordinates_c = " << coordinates_c[0] << ", " << coordinates_c[1] << ", "
                         << coordinates_c[2] << endl;
            errorMessage << "coordinates_Cell = " << coordinates_Cell[0] << ", " << coordinates_Cell[1] << ", "
                         << coordinates_Cell[2] << endl;
            errorMessage << "volume_C = " << volume_C << endl;
            mTerm(1, AT_, errorMessage.str());
          }
        }
      }
      // split3 cell:
      if(currentCase == 7 && disamb_tmp == 7) {
        for(MInt face = 0; face < 6; face++) {
          m_bndryCells->a[bndryId3].m_associatedSrfc[face] = -1;
          if(!faceCut_00[face]) continue;
          sideId = face % 2;
          spaceId = face / 2;
          if(nfs_cur_00[face]) {
            // Timw: consider cellId3 as a SplitChild
            MInt splitChildId = cellId3;
            if(m_solver->a_hasProperty(cellId3, SolverCell::IsSplitClone))
              cellId3 = m_solver->m_splitChildToSplitCell.find(cellId3)->second;
            if(m_solver->a_hasNeighbor(cellId3, face) > 0)
              nghbrId = m_solver->c_neighborId(cellId3, face);
            else {
              if(m_solver->c_parentId(cellId3) > -1) {
                if(m_solver->a_hasNeighbor(m_solver->c_parentId(cellId3), face) > 0)
                  nghbrId = m_solver->c_neighborId(m_solver->c_parentId(cellId3), face);
                else
                  continue;
              } else
                continue;
            }
            cellId3 = splitChildId;
            if(m_solver->c_noChildren(nghbrId) > 0) continue;
            otherSideId = (sideId + 1) % 2;
            srfcId = m_solver->a_noSurfaces();
            m_surfaces.append();
            m_solver->a_surfaceOrientation(srfcId) = spaceId;
            m_solver->a_surfaceNghbrCellId(srfcId, sideId) = nghbrId;
            m_solver->a_surfaceNghbrCellId(srfcId, otherSideId) = cellId3;
            for(MInt dim = 0; dim < nDim; dim++) {
              m_solver->a_surfaceCoordinate(srfcId, dim) = faceCentroid_00[face][dim];
            }
            m_solver->a_surfaceArea(srfcId) = faceVolume_00[face];
            m_bndryCells->a[bndryId3].m_associatedSrfc[face] = srfcId;
          } else {
            stringstream errorMessage;
            errorMessage << "Error in FvBndryCnd3D::createCutFaceMGC - 5. Problem with face " << face << endl;
            errorMessage << "bndryId: " << bndryId3 << endl;
            errorMessage << "cellId: " << cellId3 << endl;
            errorMessage << "split cell! Twin (triple): " << bndryId << endl;
            errorMessage << "bndryCnd: " << m_bndryCells->a[bndryId3].m_srfcs[0]->m_bndryCndId;
            errorMessage << "case, subcase: " << currentCase << ", " << currentSubCase << endl;
            errorMessage << "disamb: " << disambiguation[bndryId] << endl;
            errorMessage << "face Volumes: " << faceVolume_00[0] << ", " << faceVolume_00[1] << ", " << faceVolume_00[2]
                         << ", " << faceVolume_00[3] << ", " << faceVolume_00[4] << ", " << faceVolume_00[5] << endl;
            errorMessage << "faceCentroids: ";
            for(MInt i = 0; i < 6; i++) {
              errorMessage << faceCentroid_00[i][0] << ", " << faceCentroid_00[i][1] << ", " << faceCentroid_00[i][2]
                           << "; " << endl;
            }
            errorMessage << "area_c = " << area_c << endl;
            errorMessage << "normalVec_c = " << normalVec_c[0] << ", " << normalVec_c[1] << ", " << normalVec_c[2]
                         << endl;
            errorMessage << "coordinates_c = " << coordinates_c[0] << ", " << coordinates_c[1] << ", "
                         << coordinates_c[2] << endl;
            errorMessage << "coordinates_Cell = " << coordinates_Cell[0] << ", " << coordinates_Cell[1] << ", "
                         << coordinates_Cell[2] << endl;
            mTerm(1, AT_, errorMessage.str());
          }
        }
      }

      for(MInt face = 0; face < 6; face++) {
        if(!nfs_cur[face]) {
          m_bndryCells->a[bndryId].m_externalFaces[face] = true;
        }
      }
      if(splitCell[bndryId]) {
        for(MInt face = 0; face < 6; face++) {
          if(!nfs_cur_0[face]) {
            m_bndryCells->a[bndryId2].m_externalFaces[face] = true;
          }
        }
      }
      if(currentCase == 7 && disamb_tmp == 7) {
        for(MInt face = 0; face < 6; face++) {
          if(!nfs_cur_00[face]) {
            m_bndryCells->a[bndryId3].m_externalFaces[face] = true;
          }
        }
      }
    } else {
      m_bndryCells->a[bndryId].m_noSrfcs = 1;
      stringstream fileName;
      switch(currentCase) {
        case 0:
          cerr << "FvBndryCnd3D::createCutFaceMGC - Error: Cell is not a boundary cell!" << endl;
          cerr << "CellId: " << cellId << "   BndryId: " << bndryId << endl;
          cerr << "Cell level: " << m_solver->a_level(cellId) << endl;
          fileName << cellId << ".stl";
          writeStlFileOfCell(cellId, (fileName.str()).c_str());
          cerr << "Wrote stl-file of cell. FileName: " << (fileName.str()) << endl;
          break;
        case 1: {
          // cerr << "Case 1 detected. Starting Cutface computation..." << endl;
          for(MInt face = 0; face < 6; face++) {
            nfs_cur[face] = nfs1[currentSubCase][face];
          }
          p_0 = corner[cornersMCtoSOLVER[tiling1STL[currentSubCase][0]]];
          noFaces = 3;
          if(currentSubCase < 8) { // 1 Point is inside, 5 Points are outside
          } else {                 // 1 Point is outside, 5 Points are inside
            for(MInt i = 0; i < 6; i++) {
              faceVolume_0[i] = faceVolume[i];
              for(MInt j = 0; j < 3; j++) {
                faceCentroid_0[i][j] = faceCentroid[i][j];
              }
            }
          }
          cutDummy = edgesMCtoSOLVER[tiling1STL[currentSubCase][1]];
          p_1 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling1STL[currentSubCase][2]];
          p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling1STL[currentSubCase][3]];
          p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          face1 = facesMCtoSOLVER[tiling1STL[currentSubCase][4]];
          face2 = facesMCtoSOLVER[tiling1STL[currentSubCase][5]];
          face3 = facesMCtoSOLVER[tiling1STL[currentSubCase][6]];

          computeTri(p_0, p_1, p_3, &faceVolume[face1], faceCentroid[face1]);
          computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2]);
          computeTri(p_0, p_2, p_1, &faceVolume[face3], faceCentroid[face3]);

          computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

          computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

          if(currentSubCase >= 8) {
            correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
            correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
            correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);

            correctCell(&volume_C, coordinates_Cell, &gridCellVolume, &m_solver->a_coordinate(cellId, 0));

            correctNormal(normalVec_c);
          }

          m_bndryCells->a[bndryId].m_volume = volume_C;
          // create 1 Cut face
          m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
          for(MInt dim = 0; dim < 3; dim++) {
            m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
            m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
          }
        } break;
        case 2: {
          // cerr << "Case 2 detected. Starting Cutface computation..." << endl;
          for(MInt face = 0; face < 6; face++) {
            nfs_cur[face] = nfs2[currentSubCase][face];
          }
          noFaces = 4;
          p_0 = corner[cornersMCtoSOLVER[tiling2STL[currentSubCase][0]]];
          p_0s = corner[cornersMCtoSOLVER[tiling2STL[currentSubCase][1]]];
          if(currentSubCase < 12) { // 2 Points are inside, 4 Points are outside
          } else {                  // 2 Points are outside, 4 Points are inside
            for(MInt i = 0; i < 6; i++) {
              faceVolume_0[i] = faceVolume[i];
              for(MInt j = 0; j < 3; j++) {
                faceCentroid_0[i][j] = faceCentroid[i][j];
              }
            }
          }

          cutDummy = edgesMCtoSOLVER[tiling2STL[currentSubCase][2]];
          p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling2STL[currentSubCase][3]];
          p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling2STL[currentSubCase][4]];
          p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling2STL[currentSubCase][5]];
          p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          face1 = facesMCtoSOLVER[tiling2STL[currentSubCase][6]];
          face2 = facesMCtoSOLVER[tiling2STL[currentSubCase][7]];
          face3 = facesMCtoSOLVER[tiling2STL[currentSubCase][8]];
          face4 = facesMCtoSOLVER[tiling2STL[currentSubCase][9]];

          computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2], normal[face2]);
          computeTri(p_0s, p_3s, p_2s, &faceVolume[face3], faceCentroid[face3], normal[face3]);
          computeTrapez(p_0, p_0s, p_3s, p_3, &faceVolume[face1], faceCentroid[face1], normal[face1]);
          computeTrapez(p_2, p_2s, p_0s, p_0, &faceVolume[face4], faceCentroid[face4], normal[face4]);

          computePoly4(p_3, p_3s, p_2s, p_2, &area_c, coordinates_c, normalVec_c);

          maia::math::vecAvg<3>(M, p_0, p_0s, p_2, p_2s, p_3, p_3s);

          for(MInt i = 0; i < 4; i++) {
            computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                        &pyraVolume[i], pyraCentroid[i]);
          }
          computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[4], pyraCentroid[4]);
          for(MInt i = 0; i < 5; i++) {
            volume_C += pyraVolume[i];
            maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
          }
          vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

          if(currentSubCase >= 12) {
            correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
            correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
            correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);
            correctFace(&faceVolume[face4], faceCentroid[face4], &faceVolume_0[face4], faceCentroid_0[face4]);

            correctCell(&volume_C, coordinates_Cell, &gridCellVolume, &m_solver->a_coordinate(cellId, 0));

            correctNormal(normalVec_c);
          }

          m_bndryCells->a[bndryId].m_volume = volume_C;
          // create 1 Cut face
          m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
          for(MInt dim = 0; dim < 3; dim++) {
            m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
            m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
          }
        } break;
        case 5: {
          // cerr << "Case 5 detected. Starting Cutface computation..." << endl;
          for(MInt face = 0; face < 6; face++) {
            nfs_cur[face] = nfs5[currentSubCase][face];
          }
          noFaces = 5;
          p_0 = corner[cornersMCtoSOLVER[tiling5STL[currentSubCase][0]]];
          p_1 = corner[cornersMCtoSOLVER[tiling5STL[currentSubCase][1]]];
          p_2 = corner[cornersMCtoSOLVER[tiling5STL[currentSubCase][2]]];
          if(currentSubCase < 24) { // 3 Points are inside, 5 Points are outside
          } else {                  // 3 Points are outside, 5 Points are inside
            for(MInt i = 0; i < 6; i++) {
              faceVolume_0[i] = faceVolume[i];
              for(MInt j = 0; j < 3; j++) {
                faceCentroid_0[i][j] = faceCentroid[i][j];
              }
            }
          }

          cutDummy = edgesMCtoSOLVER[tiling5STL[currentSubCase][3]];
          p_0s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling5STL[currentSubCase][4]];
          p_0ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling5STL[currentSubCase][5]];
          p_1s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling5STL[currentSubCase][6]];
          p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling5STL[currentSubCase][7]];
          p_2ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          face1 = facesMCtoSOLVER[tiling5STL[currentSubCase][8]];
          face2 = facesMCtoSOLVER[tiling5STL[currentSubCase][9]];
          face3 = facesMCtoSOLVER[tiling5STL[currentSubCase][10]];
          face4 = facesMCtoSOLVER[tiling5STL[currentSubCase][11]];
          face5 = facesMCtoSOLVER[tiling5STL[currentSubCase][12]];

          computePoly5(p_0, p_0ss, p_2ss, p_2, p_1, &faceVolume[face1], faceCentroid[face1], normal[face1]);
          computeTri(p_0ss, p_0, p_0s, &faceVolume[face2], faceCentroid[face2], normal[face2]);
          computeTrapez(p_0, p_1, p_1s, p_0s, &faceVolume[face3], faceCentroid[face3], normal[face3]);
          computeTrapez(p_1, p_1s, p_2s, p_2, &faceVolume[face4], faceCentroid[face4], normal[face4]);
          computeTri(p_2s, p_2, p_2ss, &faceVolume[face5], faceCentroid[face5], normal[face5]);

          computePoly5(p_0s, p_1s, p_2s, p_2ss, p_0ss, &area_c, coordinates_c, normalVec_c);

          maia::math::vecAvg<3>(M, p_0, p_1, p_2, p_0s, p_1s, p_2s, p_0ss, p_2ss);

          for(MInt i = 0; i < 5; i++) {
            computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                        &pyraVolume[i], pyraCentroid[i]);
          }
          computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[5], pyraCentroid[5]);
          for(MInt i = 0; i < 6; i++) {
            volume_C += pyraVolume[i];
            maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
          }
          vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

          if(currentSubCase >= 24) {
            correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
            correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
            correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);
            correctFace(&faceVolume[face4], faceCentroid[face4], &faceVolume_0[face4], faceCentroid_0[face4]);
            correctFace(&faceVolume[face5], faceCentroid[face5], &faceVolume_0[face5], faceCentroid_0[face5]);

            correctCell(&volume_C, coordinates_Cell, &gridCellVolume, &m_solver->a_coordinate(cellId, 0));

            correctNormal(normalVec_c);
          }

          m_bndryCells->a[bndryId].m_volume = volume_C;
          // create 1 Cut face
          m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
          for(MInt dim = 0; dim < 3; dim++) {
            m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
            m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
          }
        } break;
        case 8: {
          // cerr << "Case 8 detected. Starting Cutface computation..." << endl;
          for(MInt face = 0; face < 6; face++) {
            nfs_cur[face] = nfs8[currentSubCase][face];
          }
          noFaces = 4;
          p_0 = corner[cornersMCtoSOLVER[tiling8STL[currentSubCase][0]]];
          p_1 = corner[cornersMCtoSOLVER[tiling8STL[currentSubCase][1]]];
          p_2 = corner[cornersMCtoSOLVER[tiling8STL[currentSubCase][2]]];
          p_3 = corner[cornersMCtoSOLVER[tiling8STL[currentSubCase][3]]];

          cutDummy = edgesMCtoSOLVER[tiling8STL[currentSubCase][4]];
          p_0s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling8STL[currentSubCase][5]];
          p_1s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling8STL[currentSubCase][6]];
          p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling8STL[currentSubCase][7]];
          p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          face5 = facesMCtoSOLVER[tiling8STL[currentSubCase][8]];
          face1 = facesMCtoSOLVER[tiling8STL[currentSubCase][9]];
          face2 = facesMCtoSOLVER[tiling8STL[currentSubCase][10]];
          face3 = facesMCtoSOLVER[tiling8STL[currentSubCase][11]];
          face4 = facesMCtoSOLVER[tiling8STL[currentSubCase][12]];

          computeTrapez(p_0, p_1, p_1s, p_0s, &faceVolume[face1], faceCentroid[face1], normal[face1]);
          computeTrapez(p_1, p_2, p_2s, p_1s, &faceVolume[face2], faceCentroid[face2], normal[face2]);
          computeTrapez(p_2, p_3, p_3s, p_2s, &faceVolume[face3], faceCentroid[face3], normal[face3]);
          computeTrapez(p_3, p_0, p_0s, p_3s, &faceVolume[face4], faceCentroid[face4], normal[face4]);

          computeTrapez(p_0, p_3, p_2, p_1, &faceVolume[face5], faceCentroid[face5], normal[face5]);

          computePoly4(p_0s, p_1s, p_2s, p_3s, &area_c, coordinates_c, normalVec_c);

          maia::math::vecAvg<3>(M, p_0, p_0s, p_1, p_1s, p_2, p_2s, p_3, p_3s);

          for(MInt i = 0; i < 5; i++) {
            computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                        &pyraVolume[i], pyraCentroid[i]);
          }
          computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[5], pyraCentroid[5]);
          for(MInt i = 0; i < 6; i++) {
            volume_C += pyraVolume[i];
            maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
          }
          vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

          m_bndryCells->a[bndryId].m_volume = volume_C;
          // create 1 Cut face
          m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
          for(MInt dim = 0; dim < 3; dim++) {
            m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
            m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
          }
        } break;
        case 9: {
          // cerr << "Case 9 detected. Starting Cutface computation..." << endl;
          for(MInt face = 0; face < 6; face++) {
            nfs_cur[face] = nfs9[currentSubCase][face];
          }
          noFaces = 6;
          p_0 = corner[cornersMCtoSOLVER[tiling9STL[currentSubCase][0]]];
          p_1 = corner[cornersMCtoSOLVER[tiling9STL[currentSubCase][1]]];
          p_2 = corner[cornersMCtoSOLVER[tiling9STL[currentSubCase][2]]];
          p_3 = corner[cornersMCtoSOLVER[tiling9STL[currentSubCase][3]]];

          cutDummy = edgesMCtoSOLVER[tiling9STL[currentSubCase][4]];
          p_1s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling9STL[currentSubCase][5]];
          p_1ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling9STL[currentSubCase][6]];
          p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling9STL[currentSubCase][7]];
          p_2ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling9STL[currentSubCase][8]];
          p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling9STL[currentSubCase][9]];
          p_3ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          face1 = facesMCtoSOLVER[tiling9STL[currentSubCase][10]];
          face2 = facesMCtoSOLVER[tiling9STL[currentSubCase][11]];
          face3 = facesMCtoSOLVER[tiling9STL[currentSubCase][12]];
          face4 = facesMCtoSOLVER[tiling9STL[currentSubCase][13]];
          face5 = facesMCtoSOLVER[tiling9STL[currentSubCase][14]];
          face6 = facesMCtoSOLVER[tiling9STL[currentSubCase][15]];

          computePoly5(p_0, p_3, p_3ss, p_2s, p_2, &faceVolume[face1], faceCentroid[face1], normal[face1]);
          computePoly5(p_0, p_1, p_1ss, p_3s, p_3, &faceVolume[face3], faceCentroid[face3], normal[face3]);
          computePoly5(p_0, p_2, p_2ss, p_1s, p_1, &faceVolume[face5], faceCentroid[face5], normal[face5]);
          computeTri(p_1, p_1s, p_1ss, &faceVolume[face2], faceCentroid[face2], normal[face2]);
          computeTri(p_2, p_2s, p_2ss, &faceVolume[face4], faceCentroid[face4], normal[face4]);
          computeTri(p_3, p_3s, p_3ss, &faceVolume[face6], faceCentroid[face6], normal[face6]);

          computePoly6(p_1ss, p_1s, p_2ss, p_2s, p_3ss, p_3s, &area_c, coordinates_c, normalVec_c);

          maia::math::vecAvg<3>(M, p_0, p_1, p_2, p_3, p_1s, p_2s, p_3s, p_1ss, p_2ss, p_3ss);

          for(MInt i = 0; i < 6; i++) {
            computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                        &pyraVolume[i], pyraCentroid[i]);
          }
          computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[6], pyraCentroid[6]);
          for(MInt i = 0; i < 7; i++) {
            volume_C += pyraVolume[i];
            maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
          }
          vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

          m_bndryCells->a[bndryId].m_volume = volume_C;
          // create 1 Cut face
          m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
          for(MInt dim = 0; dim < 3; dim++) {
            m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
            m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
          }
        }

        break;
        case 11: {
          // cerr << "Case 11 detected. Starting Cutface computation..." << endl;
          for(MInt face = 0; face < 6; face++) {
            nfs_cur[face] = nfs11[currentSubCase][face];
          }
          noFaces = 6;
          p_0 = corner[cornersMCtoSOLVER[tiling11STL[currentSubCase][0]]];
          p_1 = corner[cornersMCtoSOLVER[tiling11STL[currentSubCase][1]]];
          p_2 = corner[cornersMCtoSOLVER[tiling11STL[currentSubCase][2]]];
          p_3 = corner[cornersMCtoSOLVER[tiling11STL[currentSubCase][3]]];

          cutDummy = edgesMCtoSOLVER[tiling11STL[currentSubCase][4]];
          p_0s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling11STL[currentSubCase][5]];
          p_0ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling11STL[currentSubCase][6]];
          p_1s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling11STL[currentSubCase][7]];
          p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling11STL[currentSubCase][8]];
          p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling11STL[currentSubCase][9]];
          p_3ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          face1 = facesMCtoSOLVER[tiling11STL[currentSubCase][10]];
          face2 = facesMCtoSOLVER[tiling11STL[currentSubCase][11]];
          face3 = facesMCtoSOLVER[tiling11STL[currentSubCase][12]];
          face4 = facesMCtoSOLVER[tiling11STL[currentSubCase][13]];
          face5 = facesMCtoSOLVER[tiling11STL[currentSubCase][14]];
          face6 = facesMCtoSOLVER[tiling11STL[currentSubCase][15]];

          computeTri(p_0, p_0s, p_0ss, &faceVolume[face1], faceCentroid[face1], normal[face1]);
          computePoly5(p_3s, p_3, p_2, p_1, p_1s, &faceVolume[face2], faceCentroid[face2], normal[face2]);
          computeTrapez(p_2, p_3, p_3ss, p_2s, &faceVolume[face3], faceCentroid[face3], normal[face3]);
          computeTrapez(p_1, p_0, p_0ss, p_1s, &faceVolume[face4], faceCentroid[face4], normal[face4]);
          computePoly5(p_1, p_2, p_2s, p_0s, p_0, &faceVolume[face5], faceCentroid[face5], normal[face5]);
          computeTri(p_3, p_3s, p_3ss, &faceVolume[face6], faceCentroid[face6], normal[face6]);

          computePoly6(p_0ss, p_0s, p_2s, p_3ss, p_3s, p_1s, &area_c, coordinates_c, normalVec_c);

          maia::math::vecAvg<3>(M, p_0, p_1, p_2, p_3, p_0s, p_1s, p_2s, p_3s, p_0ss, p_3ss);

          for(MInt i = 0; i < 6; i++) {
            computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                        &pyraVolume[i], pyraCentroid[i]);
          }
          computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[6], pyraCentroid[6]);
          for(MInt i = 0; i < 7; i++) {
            volume_C += pyraVolume[i];
            maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
          }
          vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

          m_bndryCells->a[bndryId].m_volume = volume_C;
          // create 1 Cut face
          m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
          for(MInt dim = 0; dim < 3; dim++) {
            m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
            m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
          }
          break;
        }
        case 14: {
          // cerr << "Case 14 detected. Starting Cutface computation..." << endl;
          for(MInt face = 0; face < 6; face++) {
            nfs_cur[face] = nfs14[currentSubCase][face];
          }
          noFaces = 6;
          p_0 = corner[cornersMCtoSOLVER[tiling14STL[currentSubCase][0]]];
          p_1 = corner[cornersMCtoSOLVER[tiling14STL[currentSubCase][1]]];
          p_2 = corner[cornersMCtoSOLVER[tiling14STL[currentSubCase][2]]];
          p_3 = corner[cornersMCtoSOLVER[tiling14STL[currentSubCase][3]]];

          cutDummy = edgesMCtoSOLVER[tiling14STL[currentSubCase][4]];
          p_0s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling14STL[currentSubCase][5]];
          p_0ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling14STL[currentSubCase][6]];
          p_1s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling14STL[currentSubCase][7]];
          p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling14STL[currentSubCase][8]];
          p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          cutDummy = edgesMCtoSOLVER[tiling14STL[currentSubCase][9]];
          p_3ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
          face1 = facesMCtoSOLVER[tiling14STL[currentSubCase][10]];
          face2 = facesMCtoSOLVER[tiling14STL[currentSubCase][11]];
          face3 = facesMCtoSOLVER[tiling14STL[currentSubCase][12]];
          face4 = facesMCtoSOLVER[tiling14STL[currentSubCase][13]];
          face5 = facesMCtoSOLVER[tiling14STL[currentSubCase][14]];
          face6 = facesMCtoSOLVER[tiling14STL[currentSubCase][15]];

          computeTri(p_0, p_0s, p_0ss, &faceVolume[face1], faceCentroid[face1], normal[face1]);
          computePoly5(p_2, p_3, p_3ss, p_1s, p_1, &faceVolume[face2], faceCentroid[face2], normal[face2]);
          computeTrapez(p_2s, p_3s, p_3, p_2, &faceVolume[face3], faceCentroid[face3], normal[face3]);
          computeTrapez(p_1s, p_0s, p_0, p_1, &faceVolume[face4], faceCentroid[face4], normal[face4]);
          computePoly5(p_2, p_1, p_0, p_0ss, p_2s, &faceVolume[face5], faceCentroid[face5], normal[face5]);
          computeTri(p_3, p_3s, p_3ss, &faceVolume[face6], faceCentroid[face6], normal[face6]);

          computePoly6(p_0ss, p_0s, p_1s, p_3ss, p_3s, p_2s, &area_c, coordinates_c, normalVec_c);

          maia::math::vecAvg<3>(M, p_0, p_1, p_2, p_3, p_0s, p_1s, p_2s, p_3s, p_0ss, p_3ss);

          for(MInt i = 0; i < 6; i++) {
            computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                        &pyraVolume[i], pyraCentroid[i]);
          }
          computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[6], pyraCentroid[6]);
          for(MInt i = 0; i < 7; i++) {
            volume_C += pyraVolume[i];
            maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
          }
          vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

          m_bndryCells->a[bndryId].m_volume = volume_C;
          // create 1 Cut face
          m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
          for(MInt dim = 0; dim < 3; dim++) {
            m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
            m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
            m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
          }

          break;
        }
        default: {
          stringstream errorMessage;
          errorMessage << "FvBndryCnd3D::createCutFaceMGC - Error: Inconsistent type implementation." << endl;
          mTerm(1, AT_, errorMessage.str());
        }
      }

      absA = F0;
      for(MInt i = 0; i < nDim; i++) {
        // make sure faceVolume of non fluid sides is zero
        if(!nfs_cur[2 * i + 1]) faceVolume[2 * i + 1] = 0;
        if(!nfs_cur[2 * i]) faceVolume[2 * i] = 0;
        // correct coordinates - bndrycell coordinates are stored relative to cell coordinates
        m_bndryCells->a[bndryId].m_coordinates[i] -= m_solver->a_coordinate(cellId, i);
        // implicitly recompute the correct area and normal of the cut surface
        faceDiff[i] = faceVolume[2 * i + 1] - faceVolume[2 * i];
        absA += POW2(faceDiff[i]);
      }
      // This is only unique if the cut surface is planar. Otherwise, this is nevertheless a reasonnable choice.
      for(MInt i = 0; i < nDim; i++) {
        m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i] = faceDiff[i] / sqrt(absA);
      }
      m_bndryCells->a[bndryId].m_srfcs[0]->m_area = sqrt(absA);

      // face data is assembled
      // create a surface for the cut face if a boundary cell neighbor exists
      for(MInt face = 0; face < 6; face++) {
        m_bndryCells->a[bndryId].m_associatedSrfc[face] = -1;
        for(MInt i = 0; i < noFaces; i++) {
          if(!(*facepointers[i] == face)) continue;
          sideId = face % 2;
          spaceId = face / 2;
          if(nfs_cur[face]) {
            if(m_solver->a_hasNeighbor(cellId, face) > 0) {
              nghbrId = m_solver->c_neighborId(cellId, face);
            } else {
              if(m_solver->c_parentId(cellId) > -1) {
                if(m_solver->a_hasNeighbor(m_solver->c_parentId(cellId), face) > 0)
                  nghbrId = m_solver->c_neighborId(m_solver->c_parentId(cellId), face);
                else
                  continue;
              } else
                continue;
            }
            if(m_solver->c_noChildren(nghbrId) > 0) continue;
            otherSideId = (sideId + 1) % 2;
            srfcId = m_solver->a_noSurfaces();
            m_surfaces.append();
            m_solver->a_surfaceOrientation(srfcId) = spaceId;
            m_solver->a_surfaceNghbrCellId(srfcId, sideId) = nghbrId;
            m_solver->a_surfaceNghbrCellId(srfcId, otherSideId) = cellId;
            for(MInt dim = 0; dim < nDim; dim++) {
              m_solver->a_surfaceCoordinate(srfcId, dim) = faceCentroid[face][dim];
            }
            m_solver->a_surfaceArea(srfcId) = faceVolume[face];
            m_bndryCells->a[bndryId].m_associatedSrfc[face] = srfcId;
            break;
          } else {
            stringstream errorMessage;
            errorMessage << " Error in FvBndryCnd3D::createCutFaceMGC - 6. Problem with face " << face << endl;
            errorMessage << "bndryId: " << bndryId << endl;
            errorMessage << "cellId: " << cellId << endl;
            errorMessage << "bndryCnd: " << m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
            errorMessage << "case, subcase: " << currentCase << ", " << currentSubCase << endl;
            errorMessage << "face Volumes: " << faceVolume[0] << ", " << faceVolume[1] << ", " << faceVolume[2] << ", "
                         << faceVolume[3] << ", " << faceVolume[4] << ", " << faceVolume[5] << endl;
            errorMessage << "faceCentroids: ";
            for(MInt j = 0; j < 6; j++) {
              errorMessage << faceCentroid[j][0] << ", " << faceCentroid[j][1] << ", " << faceCentroid[j][2] << "; "
                           << endl;
            }
            errorMessage << "area_c = " << area_c << endl;
            errorMessage << "normalVec_c = " << normalVec_c[0] << ", " << normalVec_c[1] << ", " << normalVec_c[2]
                         << endl;
            errorMessage << "coordinates_c = " << coordinates_c[0] << ", " << coordinates_c[1] << ", "
                         << coordinates_c[2] << endl;
            errorMessage << "coordinates_Cell = " << coordinates_Cell[0] << ", " << coordinates_Cell[1] << ", "
                         << coordinates_Cell[2] << endl;
            errorMessage << "volume_C = " << volume_C << endl;
            mTerm(1, AT_, errorMessage.str());
          }
        }
      }
      // set nonFluidSideIds
      for(MInt face = 0; face < 6; face++) {
        if(!nfs_cur[face]) {
          m_bndryCells->a[bndryId].m_externalFaces[face] = true;
        }
      }
    }
  }

  // initialize bndryNghbrs array
  if(keepNghbrs) {
    for(MInt bndryId = 0; bndryId < m_bndryCells->size(); bndryId++) {
      cellId = m_bndryCells->a[bndryId].m_cellId;
      if(m_solver->a_hasProperty(cellId, SolverCell::IsSplitClone)) {
        cellId = m_solver->m_splitChildToSplitCell.find(cellId)->second;
        m_solver->assertValidGridCellId(cellId);
      }
      for(MInt dirId = 0; dirId < m_noDirs; dirId++) {
        m_bndryNghbrs[bndryId * m_noDirs * 2 + dirId * 2] = -1;
        if(m_solver->a_hasNeighbor(cellId, dirId) > 0)
          m_bndryNghbrs[bndryId * m_noDirs * 2 + dirId * 2] = m_solver->c_neighborId(cellId, dirId);
        m_bndryNghbrs[bndryId * m_noDirs * 2 + dirId * 2 + 1] = -1;
      }
    }
  }

  // 5. Compute neighbor information for ambiguous cells

  if(!keepNghbrs) {
    for(MInt ambId = 0; ambId < noAmbiguousCells; ambId++) {
      MInt bndryId = ambiguousCells[ambId];
      cellId = m_bndryCells->a[bndryId].m_cellId;

      // a) Check cells which are splitCells without split surface
      if(splitCell[bndryId] && !splitFace[bndryId]) {
        // first update connections split relative cell
        for(MInt child = 0; child < 3; child++) {
          bndryId2 = m_splitChildren[bndryId * 3 + child];
          if(bndryId2 == -1) break;
          cellId2 = m_bndryCells->a[bndryId2].m_cellId;
          // 			cellId2 = splitRelatives[ambId];
          // 			bndryId2 = m_solver->a_bndryId(cellId2);
          for(MInt corn = 0; corn < 8; corn++) {
            if(cornerCellMapping[ambId * 8 + corn] == cellId2) { // this corner belongs to split relative cell!
              for(MInt f = 0; f < 3; f++) {
                faceTMP = cornerFaceMapping[corn * 3 + f];
                nghbrCellId = m_solver->c_neighborId(cellId2, faceTMP);
                nghbrBndryId = m_solver->a_bndryId(nghbrCellId);
                if(nghbrBndryId < 0) mTerm(1, AT_, "strange split cell neighbor");
                if(!splitCell[nghbrBndryId] && !splitFace[nghbrBndryId]) {
                  // neighbor is not ambigous or not split/split surface -> forward and backward connections
                  // forward connection is already alright, establish backward connection:
                  // m_solver->c_neighborId(nghbrCellId, opposite[faceTMP]) = cellId2;
                  srfcId = m_bndryCells->a[nghbrBndryId].m_associatedSrfc[opposite[faceTMP]];
                  if(m_solver->a_surfaceNghbrCellId(srfcId, 0) == nghbrCellId) {
                    m_solver->a_surfaceNghbrCellId(srfcId, 1) = cellId2;
                  } else {
                    m_solver->a_surfaceNghbrCellId(srfcId, 0) = cellId2;
                  }
                } else { // establish forward connection. backward connection will be established by neighboring cell
                  if(splitCell[nghbrBndryId]) {
                    // connect to correct split relative of neighbor cell, both neighbor and surface neighbors
                    // m_solver->c_neighborId(cellId2, faceTMP) = cornerCellMapping[ambIds[nghbrBndryId] * 8 + corn +
                    // neighborCorner[faceTMP]];
                    srfcId = m_bndryCells->a[bndryId2].m_associatedSrfc[faceTMP];
                    if(m_solver->a_surfaceNghbrCellId(srfcId, 0) == cellId2) {
                      m_solver->a_surfaceNghbrCellId(srfcId, 1) = m_solver->c_neighborId(cellId2, faceTMP);
                    } else {
                      m_solver->a_surfaceNghbrCellId(srfcId, 0) = m_solver->c_neighborId(cellId2, faceTMP);
                    }
                  } else if(splitFace[nghbrBndryId]) {
                    // nothing has to be done (neighbor is already correct, surface neighbors too)
                  }
                }
              }
            } else {
              // non fluid corner, do nothing
            }
          }
          // correct neighbors on non-fluid sides
          //      for(MInt f = 0; f < m_noDirs; f++ ){
          //        if( m_bndryCells->a[bndryId2].m_externalFaces[f]){
          //          m_solver->c_neighborId(cellId2, f) = -1;
          //        }
          //      }
        }

        // second update connections cell
        for(MInt corn = 0; corn < 8; corn++) {
          if(cornerCellMapping[ambId * 8 + corn] == cellId) { // this corner belongs to split relative cell!
            for(MInt f = 0; f < 3; f++) {
              faceTMP = cornerFaceMapping[corn * 3 + f];
              nghbrCellId = m_solver->c_neighborId(cellId, faceTMP);
              nghbrBndryId = m_solver->a_bndryId(nghbrCellId);
              if(!splitCell[nghbrBndryId] && !splitFace[nghbrBndryId]) {
                // neighbor is not ambigous or not split/split surface -> forward and backward connections
                // forward connection is already alright, establish backward connection:
                // should already be ok as nghbr cell and srfc are connected to base cell
              } else { // establish forward connection. backward connection will be established by neighboring cell
                if(splitCell[nghbrBndryId]) {
                  // connect to correct split relative of neighbor cell, both neighbor and surface neighbors
                  //								m_solver->c_neighborId(cellId, faceTMP) = cornerCellMapping[ambIds[nghbrBndryId] * 8
                  //+ corn + neighborCorner[faceTMP]];
                  srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[faceTMP];
                  if(m_solver->a_surfaceNghbrCellId(srfcId, 0) == cellId) {
                    m_solver->a_surfaceNghbrCellId(srfcId, 1) = m_solver->c_neighborId(cellId, faceTMP);
                  } else {
                    m_solver->a_surfaceNghbrCellId(srfcId, 0) = m_solver->c_neighborId(cellId, faceTMP);
                  }
                } else if(splitFace[nghbrBndryId]) {
                  // nothing has to be done (neighbor is already correct, surface neighbors too)
                }
              }
            }
          } else {
            // non fluid corner, do nothing
          }
        }
        //			// correct neighbors on non-fluid sides
        //      for(MInt f = 0; f < m_noDirs; f++ ){
        //        if( m_bndryCells->a[bndryId].m_externalFaces[f]){
        //          m_solver->c_neighborId(cellId, f) = -1;
        //        }
        //      }
      }


      // b) Check cells which are no splitCells but with split surface
      if(!splitCell[bndryId] && splitFace[bndryId]) {
        for(MInt face = 0; face < 6; face++) {
          srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[face];
          // srfcId < -1: split surface, srfcId = -1: non fluid side or non cut surface -> do nothing. srfcId >= 0:
          // normal cut surface, check neighbor
          if(srfcId < -1) {
            // split surface
            nghbrCellId = m_solver->c_neighborId(cellId, face);
            nghbrBndryId = m_solver->a_bndryId(nghbrCellId);
            // connect first surface
            splitCorner1 = m_splitSurfaces[-srfcId * 6 + 1];
            splitCorner2 = m_splitSurfaces[-srfcId * 6 + 2];
            if(splitCell[nghbrBndryId]) {
              if(m_solver->a_surfaceNghbrCellId(m_splitSurfaces[-srfcId * 6], 0) == cellId)
                m_solver->a_surfaceNghbrCellId(m_splitSurfaces[-srfcId * 6], 1) =
                    cornerCellMapping[ambIds[nghbrBndryId] * 8 + splitCorner2];
              else
                m_solver->a_surfaceNghbrCellId(m_splitSurfaces[-srfcId * 6], 0) =
                    cornerCellMapping[ambIds[nghbrBndryId] * 8 + splitCorner2];
            } else if(splitFace[nghbrBndryId]) {
              // nothing has to be done (neighbor is already correct, surface neighbors too)
            } else {
              // should not happen
              stringstream errorMessage;
              errorMessage << " Error in FvBndryCnd3D::createCutFaceMGC::this should not happen! ";
              mTerm(1, AT_, errorMessage.str());
            }

            // connect second surface
            splitCorner1 = m_splitSurfaces[-srfcId * 6 + 3 + 1];
            splitCorner2 = m_splitSurfaces[-srfcId * 6 + 3 + 2];
            if(splitCell[nghbrBndryId]) {
              if(m_solver->a_surfaceNghbrCellId(m_splitSurfaces[-srfcId * 6 + 3], 0) == cellId)
                m_solver->a_surfaceNghbrCellId(m_splitSurfaces[-srfcId * 6 + 3], 1) =
                    cornerCellMapping[ambIds[nghbrBndryId] * 8 + splitCorner2];
              else
                m_solver->a_surfaceNghbrCellId(m_splitSurfaces[-srfcId * 6 + 3], 0) =
                    cornerCellMapping[ambIds[nghbrBndryId] * 8 + splitCorner2];
            } else if(splitFace[nghbrBndryId]) {
              // nothing has to be done (neighbor is already correct, surface neighbors too)
            } else {
              // should not happen
            }
          } else if(srfcId >= 0) {
            // regular surface, check neighboring cells!
            nghbrCellId = m_solver->c_neighborId(cellId, face);
            nghbrBndryId = m_solver->a_bndryId(nghbrCellId);
            if(splitCell[nghbrBndryId]) {
              for(MInt i = 0; i < 4; i++) {
                if(cornerCellMapping[ambIds[nghbrBndryId] * 8 + faceCornerMapping[face * 6 + i]] == -1) {
                  // non fluid corner, do nothing!
                } else {
                  // set face neighbor and srfc neighbors
                  //								m_solver->c_neighborId(cellId, face) = cornerCellMapping[ambIds[nghbrBndryId]*8 +
                  // faceCornerMapping[ face * 6 + i]];
                  if(m_solver->a_surfaceNghbrCellId(srfcId, 0) == cellId)
                    m_solver->a_surfaceNghbrCellId(srfcId, 1) = m_solver->c_neighborId(cellId, face);
                  else
                    m_solver->a_surfaceNghbrCellId(srfcId, 0) = m_solver->c_neighborId(cellId, face);
                  break;
                }
              }
            } else if(splitFace[nghbrBndryId]) {
              // nothing has to be done (neighbor is already correct, surface neighbors too)
            } else {
              // everything alright, nothing has to be done.
            }
          }
        }
      }
    }


  } else {
    for(MInt ambId = 0; ambId < noAmbiguousCells; ambId++) {
      MInt bndryId = ambiguousCells[ambId];
      cellId = m_bndryCells->a[bndryId].m_cellId;

      // a) Check cells which are splitCells without split surface
      if(splitCell[bndryId] && !splitFace[bndryId]) {
        // first update connections split relative cell
        for(MInt child = 0; child < 3; child++) {
          bndryId2 = m_splitChildren[bndryId * 3 + child];
          if(bndryId2 == -1) break;
          cellId2 = m_bndryCells->a[bndryId2].m_cellId;
          MInt splitCellId = cellId2;
          for(MInt corn = 0; corn < 8; corn++) {
            if(cornerCellMapping[ambId * 8 + corn] == cellId2) { // this corner belongs to split relative cell!
              for(MInt f = 0; f < 3; f++) {
                faceTMP = cornerFaceMapping[corn * 3 + f];
                if(m_solver->a_hasProperty(cellId2, SolverCell::IsSplitClone)) {
                  cellId2 = m_solver->m_splitChildToSplitCell.find(cellId2)->second;
                }
                nghbrCellId = m_solver->c_neighborId(cellId2, faceTMP);
                if(!m_solver->a_hasNeighbor(cellId2, faceTMP) || nghbrCellId < 0) continue;
                nghbrBndryId = m_solver->a_bndryId(nghbrCellId);
                if(!splitCell[nghbrBndryId] && !splitFace[nghbrBndryId]) {
                  // neighbor is not ambigous or not split/split surface -> forward and backward connections
                  // forward connection is already alright (in m_nghbrIds), update m_bndryNghbrs, establish backward
                  // connection:
                  m_bndryNghbrs[nghbrBndryId * m_noDirs * 2 + opposite[faceTMP] * 2] = splitCellId;
                  m_bndryNghbrs[bndryId2 * m_noDirs * 2 + faceTMP * 2] = nghbrCellId;
                  srfcId = m_bndryCells->a[nghbrBndryId].m_associatedSrfc[opposite[faceTMP]];
                  if(srfcId > -1) {
                    if(m_solver->a_surfaceNghbrCellId(srfcId, 0) == nghbrCellId) {
                      m_solver->a_surfaceNghbrCellId(srfcId, 1) = splitCellId;
                    } else {
                      m_solver->a_surfaceNghbrCellId(srfcId, 0) = splitCellId;
                    }
                  } else
                    cerr << "no surf found " << m_solver->a_isHalo(splitCellId) << " "
                         << m_solver->a_isHalo(nghbrCellId) << endl;
                } else { // establish forward connection. backward connection will be established by neighboring cell
                  if(splitCell[nghbrBndryId]) {
                    // connect to correct split relative of neighbor cell, both neighbor and surface neighbors
                    m_bndryNghbrs[bndryId2 * m_noDirs * 2 + faceTMP * 2] =
                        cornerCellMapping[ambIds[nghbrBndryId] * 8 + corn + neighborCorner[faceTMP]];
                    srfcId = m_bndryCells->a[bndryId2].m_associatedSrfc[faceTMP];
                    if(srfcId > -1) {
                      if(m_solver->a_surfaceNghbrCellId(srfcId, 0) == splitCellId) {
                        m_solver->a_surfaceNghbrCellId(srfcId, 1) =
                            m_bndryNghbrs[bndryId2 * m_noDirs * 2 + faceTMP * 2];
                      } else {
                        m_solver->a_surfaceNghbrCellId(srfcId, 0) =
                            m_bndryNghbrs[bndryId2 * m_noDirs * 2 + faceTMP * 2];
                      }
                    }
                  } else if(splitFace[nghbrBndryId]) {
                    // nothing has to be done (neighbor is already correct, surface neighbors too) -> update
                    // m_bndryNghbrs, backward connection will be established by neighboring cell
                    m_bndryNghbrs[bndryId2 * m_noDirs * 2 + faceTMP * 2] = nghbrCellId;
                  }
                }
              }
            } else {
              // non fluid corner, do nothing
            }
          }
          // correct neighbors on non-fluid sides
          for(MInt f = 0; f < m_noDirs; f++) {
            if(m_bndryCells->a[bndryId2].m_externalFaces[f]) m_bndryNghbrs[bndryId2 * m_noDirs * 2 + f * 2] = -1;
          }
        }

        // second update connections cell
        for(MInt corn = 0; corn < 8; corn++) {
          if(cornerCellMapping[ambId * 8 + corn] == cellId) { // this corner belongs to split cell!
            for(MInt f = 0; f < 3; f++) {
              faceTMP = cornerFaceMapping[corn * 3 + f];
              nghbrCellId = m_solver->c_neighborId(cellId, faceTMP);
              nghbrBndryId = m_solver->a_bndryId(nghbrCellId);
              if(!splitCell[nghbrBndryId] && !splitFace[nghbrBndryId]) {
                // neighbor is not ambigous or not split/split surface -> forward and backward connections
                // forward connection is already alright, establish backward connection:
                // should already be ok as nghbr cell and srfc are connected to base cell
                // update m_bndryNghbrs
                m_bndryNghbrs[bndryId * m_noDirs * 2 + faceTMP * 2] = nghbrCellId;
                m_bndryNghbrs[nghbrBndryId * m_noDirs * 2 + opposite[faceTMP] * 2] = cellId;
              } else { // establish forward connection. backward connection will be established by neighboring cell
                if(splitCell[nghbrBndryId]) {
                  // connect to correct split relative of neighbor cell, both neighbor and surface neighbors
                  m_bndryNghbrs[bndryId * m_noDirs * 2 + faceTMP * 2] =
                      cornerCellMapping[ambIds[nghbrBndryId] * 8 + corn + neighborCorner[faceTMP]];
                  srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[faceTMP];
                  if(m_solver->a_surfaceNghbrCellId(srfcId, 0) == cellId) {
                    m_solver->a_surfaceNghbrCellId(srfcId, 1) = m_bndryNghbrs[bndryId * m_noDirs * 2 + faceTMP * 2];
                  } else {
                    m_solver->a_surfaceNghbrCellId(srfcId, 0) = m_bndryNghbrs[bndryId * m_noDirs * 2 + faceTMP * 2];
                  }
                } else if(splitFace[nghbrBndryId]) {
                  m_bndryNghbrs[bndryId * m_noDirs * 2 + faceTMP * 2] = nghbrCellId;
                  // nothing has to be done (neighbor is already correct, surface neighbors too)
                }
              }
            }
          } else {
            // non fluid corner, do nothing
          }
        }
        // correct neighbors on non-fluid sides
        for(MInt f = 0; f < m_noDirs; f++) {
          if(m_bndryCells->a[bndryId].m_externalFaces[f]) m_bndryNghbrs[bndryId * m_noDirs * 2 + f * 2] = -1;
        }
      }


      // b) Check cells which are no splitCells but with split surface
      if(!splitCell[bndryId] && splitFace[bndryId]) {
        for(MInt face = 0; face < 6; face++) {
          srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[face];
          // srfcId < -1: split surface, srfcId = -1: non fluid side or non cut surface -> do nothing. srfcId >= 0:
          // normal cut surface, check neighbor
          if(srfcId < -1) {
            // split surface
            nghbrCellId = m_solver->c_neighborId(cellId, face);
            nghbrBndryId = m_solver->a_bndryId(nghbrCellId);
            // connect first surface
            splitCorner1 = m_splitSurfaces[-srfcId * 6 + 1];
            splitCorner2 = m_splitSurfaces[-srfcId * 6 + 2];
            if(splitCell[nghbrBndryId]) {
              m_bndryNghbrs[bndryId * m_noDirs * 2 + face * 2] =
                  cornerCellMapping[ambIds[nghbrBndryId] * 8 + splitCorner2];
              if(m_solver->a_surfaceNghbrCellId(m_splitSurfaces[-srfcId * 6], 0) == cellId)
                m_solver->a_surfaceNghbrCellId(m_splitSurfaces[-srfcId * 6], 1) =
                    cornerCellMapping[ambIds[nghbrBndryId] * 8 + splitCorner2];
              else
                m_solver->a_surfaceNghbrCellId(m_splitSurfaces[-srfcId * 6], 0) =
                    cornerCellMapping[ambIds[nghbrBndryId] * 8 + splitCorner2];
            } else if(splitFace[nghbrBndryId]) {
              // nothing has to be done (neighbor is already correct, surface neighbors too)
              m_bndryNghbrs[bndryId * m_noDirs * 2 + face * 2] = nghbrCellId;
            } else {
              // should not happen
              stringstream errorMessage;
              errorMessage << " Error in FvBndryCnd3D::createCutFaceMGC::this should not happen! ";
              mTerm(1, AT_, errorMessage.str());
            }

            // connect second surface
            splitCorner1 = m_splitSurfaces[-srfcId * 6 + 3 + 1];
            splitCorner2 = m_splitSurfaces[-srfcId * 6 + 3 + 2];
            if(splitCell[nghbrBndryId]) {
              // add second split neighbor as neighbor
              m_bndryNghbrs[bndryId * m_noDirs * 2 + face * 2 + 1] =
                  cornerCellMapping[ambIds[nghbrBndryId] * 8 + splitCorner2];
              if(m_solver->a_surfaceNghbrCellId(m_splitSurfaces[-srfcId * 6 + 3], 0) == cellId)
                m_solver->a_surfaceNghbrCellId(m_splitSurfaces[-srfcId * 6 + 3], 1) =
                    cornerCellMapping[ambIds[nghbrBndryId] * 8 + splitCorner2];
              else
                m_solver->a_surfaceNghbrCellId(m_splitSurfaces[-srfcId * 6 + 3], 0) =
                    cornerCellMapping[ambIds[nghbrBndryId] * 8 + splitCorner2];
            } else if(splitFace[nghbrBndryId]) {
              // nothing has to be done (neighbor is already correct, surface neighbors too)
              m_bndryNghbrs[bndryId * m_noDirs * 2 + face * 2 + 1] = nghbrCellId;
            } else {
              // should not happen
              stringstream errorMessage;
              errorMessage << " Error in FvBndryCnd3D::createCutFaceMGC::this should not happen! ";
              mTerm(1, AT_, errorMessage.str());
            }
          } else if(srfcId >= 0) {
            // regular surface, check neighboring cells!
            nghbrCellId = m_solver->c_neighborId(cellId, face);
            nghbrBndryId = m_solver->a_bndryId(nghbrCellId);
            if(splitCell[nghbrBndryId]) {
              for(MInt i = 0; i < 4; i++) {
                if(cornerCellMapping[ambIds[nghbrBndryId] * 8 + faceCornerMapping[face * 6 + i]] == -1) {
                  // non fluid corner, do nothing!
                } else {
                  // set face neighbor and srfc neighbors
                  m_bndryNghbrs[bndryId * m_noDirs * 2 + face * 2] =
                      cornerCellMapping[ambIds[nghbrBndryId] * 8 + faceCornerMapping[face * 6 + i]];
                  if(m_solver->a_surfaceNghbrCellId(srfcId, 0) == cellId)
                    m_solver->a_surfaceNghbrCellId(srfcId, 1) = m_bndryNghbrs[bndryId * m_noDirs * 2 + face * 2];
                  else
                    m_solver->a_surfaceNghbrCellId(srfcId, 0) = m_bndryNghbrs[bndryId * m_noDirs * 2 + face * 2];
                  break;
                }
              }
            } else {
              // everything alright, nothing has to be done.
              m_bndryNghbrs[bndryId * m_noDirs * 2 + face * 2] = nghbrCellId;
            }
          }
        }
      }
    }

    // correct nonFluidSide neighbors
    if(keepNghbrs) {
      for(MInt bndryId = 0; bndryId < m_bndryCells->size(); bndryId++) {
        cellId = m_bndryCells->a[bndryId].m_cellId;
        for(MInt f = 0; f < m_noDirs; f++) {
          if(m_bndryCells->a[bndryId].m_externalFaces[f]) {
            m_bndryNghbrs[bndryId * m_noDirs * 2 + f * 2] = -1;
            m_bndryNghbrs[bndryId * m_noDirs * 2 + f * 2 + 1] = -1;
          }
        }
      }
    }
  }

#ifndef NDEBUG
  for(MInt i = 0; i < 15; i++) {
    cerr << "Occurences case " << i << " : " << presentCases[i] << " times" << endl;
  }
  cerr << "---------------------------------------------------------------" << endl << endl << endl;
  cerr << "Number Surfaces: " << m_solver->a_noSurfaces() << endl;
#endif
}

/** \brief produces an exact copy of a fvcell and the respective boundary cell
 *
 * FVCell must be a boundary cell.
 *
 * Function is needed to handle split cells (cells that are cut into two separate
 * parts by the geometry) -> each cell that is split gets an associated cell clone
 *
 * \author Claudia Guenther, Feb 2010 Update Tim Wegmann July 2018
 *
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
MInt FvBndryCndXD<nDim, SysEqn>::createSplitCell_MGC(MInt cellId, MInt noSplitChilds) {
  TRACE();

  MInt bndryId2, cellId2, bndryId;
  //-----------------------------------------
  MInt splitId = m_solver->m_splitCells.size();
  if(noSplitChilds > 1) {
    splitId = splitId - 1;
    m_solver->m_splitChilds[splitId].resize(noSplitChilds);
  } else {
    m_solver->m_splitCells.push_back(cellId);
    m_solver->m_splitChilds.resize(m_solver->m_splitCells.size());
    m_solver->m_splitChilds[splitId].resize(noSplitChilds);
  }

  bndryId = m_solver->a_bndryId(cellId);
  bndryId2 = m_bndryCells->size();
  cellId2 = m_solver->a_noCells();

  m_bndryCells->append();
  m_cells.append();
  m_solver->m_totalnosplitchilds++;
  ASSERT(cellId2 == m_solver->a_noCells() - 1, "Error in the cell-count, for splitchilds!");

  m_solver->m_splitChilds[splitId][noSplitChilds - 1] = cellId2;
  m_solver->m_splitChildToSplitCell.insert(pair<MInt, MInt>(cellId2, cellId));

  m_bndryCells->a[bndryId2].m_cellId = cellId2;
  m_solver->a_bndryId(cellId2) = bndryId2;
  m_solver->a_bndryId(cellId2) = bndryId2;

  for(MInt face = 0; face < 6; face++) {
    m_bndryCells->a[bndryId2].m_associatedSrfc[face] = -1;
    m_bndryCells->a[bndryId2].m_externalFaces[face] = false;
  }

  m_bndryCells->a[bndryId2].m_srfcs[0]->m_bndryCndId = m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
  m_bndryCells->a[bndryId2].m_srfcs[0]->m_noCutPoints = m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;

  for(MInt i = 0; i < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; i++) {
    m_bndryCells->a[bndryId2].m_srfcs[0]->m_cutEdge[i] = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[i];
    m_bndryCells->a[bndryId2].m_srfcs[0]->m_bodyId[i] = m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[i];
    for(MInt j = 0; j < nDim; j++)
      m_bndryCells->a[bndryId2].m_srfcs[0]->m_cutCoordinates[i][j] =
          m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[i][j];
  }

  for(MInt i = 0; i < nDim; i++) {
    m_solver->a_coordinate(cellId2, i) = m_solver->a_coordinate(cellId, i);
  }
  m_solver->a_isInterface(cellId2) = m_solver->a_isInterface(cellId);

  m_solver->a_level(cellId2) = m_solver->a_level(cellId);

  m_solver->a_copyPropertiesSolver(cellId, cellId2);

  m_solver->a_hasProperty(cellId2, SolverCell::IsSplitCell) = false;
  m_solver->a_hasProperty(cellId2, SolverCell::IsSplitChild) = false;
  m_solver->a_hasProperty(cellId2, SolverCell::IsSplitClone) = true;

  m_solver->a_hasProperty(cellId, SolverCell::IsSplitCell) = false;
  m_solver->a_hasProperty(cellId, SolverCell::IsSplitChild) = false;
  m_solver->a_hasProperty(cellId, SolverCell::IsSplitClone) = false;


  return cellId2;
}

#define plotall

// ---------------------------------------------------------------------------------
// ---------------	output routines to check the cut cell generation  --------------
// ---------------------------------------------------------------------------------

/*
 * \author Daniel Hartmann, July 2007
 *
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::writeStlFileOfCell(MInt cellId, const MChar* fileName) {
  TRACE();

  MInt spaceId, spaceId1, spaceId2, sideId;
  MFloat cellLength = m_solver->grid().cellLengthAtCell(cellId);
  MFloat point1[3] = {0, 0, 0};
  MFloat point2[3] = {0, 0, 0};
  MFloat point3[3] = {0, 0, 0};
  MFloat point4[3] = {0, 0, 0};
  ofstream ofl;
  ofl.open(fileName);

  if(ofl) {
    // set fixed floating point output
    ofl.setf(ios::fixed);
    ofl.precision(7);

    ofl << "solid amazonas cell " << cellId << endl;
    for(MInt dirId = 0; dirId < m_noDirs; dirId++) {
      spaceId = dirId / 2;
      sideId = dirId % 2;
      spaceId1 = (spaceId + 1) % nDim;
      spaceId2 = (spaceId1 + 1) % nDim;
      point1[spaceId] = m_solver->a_coordinate(cellId, spaceId) + ((MFloat)sideId - F1B2) * cellLength;
      point2[spaceId] = point1[spaceId];
      point3[spaceId] = point1[spaceId];
      point4[spaceId] = point1[spaceId];
      point1[spaceId1] = m_solver->a_coordinate(cellId, spaceId1) - F1B2 * cellLength;
      point2[spaceId1] = m_solver->a_coordinate(cellId, spaceId1) - F1B2 * cellLength;
      point3[spaceId1] = m_solver->a_coordinate(cellId, spaceId1) + F1B2 * cellLength;
      point4[spaceId1] = m_solver->a_coordinate(cellId, spaceId1) + F1B2 * cellLength;
      point1[spaceId2] = m_solver->a_coordinate(cellId, spaceId2) - F1B2 * cellLength;
      point2[spaceId2] = m_solver->a_coordinate(cellId, spaceId2) + F1B2 * cellLength;
      point3[spaceId2] = m_solver->a_coordinate(cellId, spaceId2) - F1B2 * cellLength;
      point4[spaceId2] = m_solver->a_coordinate(cellId, spaceId2) + F1B2 * cellLength;
      if(dirId == 0) ofl << "  facet normal -1.0  0.0  0.0 " << endl;
      if(dirId == 1) ofl << "  facet normal  1.0  0.0  0.0 " << endl;
      if(dirId == 2) ofl << "  facet normal  0.0 -1.0  0.0 " << endl;
      if(dirId == 3) ofl << "  facet normal  0.0  1.0  0.0 " << endl;
      if(dirId == 4) ofl << "  facet normal  0.0  0.0 -1.0 " << endl;
      if(dirId == 5) ofl << "  facet normal  0.0  0.0  1.0 " << endl;
      ofl << "    outer loop" << endl;
      ofl << "      vertex " << point1[0] << "  " << point1[1] << "  " << point1[2] << endl;
      ofl << "      vertex " << point2[0] << "  " << point2[1] << "  " << point2[2] << endl;
      ofl << "      vertex " << point3[0] << "  " << point3[1] << "  " << point3[2] << endl;
      ofl << "    endloop" << endl;
      ofl << "  endfacet" << endl;
      if(dirId == 0) ofl << "  facet normal -1.0  0.0  0.0 " << endl;
      if(dirId == 1) ofl << "  facet normal  1.0  0.0  0.0 " << endl;
      if(dirId == 2) ofl << "  facet normal  0.0 -1.0  0.0 " << endl;
      if(dirId == 3) ofl << "  facet normal  0.0  1.0  0.0 " << endl;
      if(dirId == 4) ofl << "  facet normal  0.0  0.0 -1.0 " << endl;
      if(dirId == 5) ofl << "  facet normal  0.0  0.0  1.0 " << endl;
      ofl << "    outer loop" << endl;
      ofl << "      vertex " << point4[0] << "  " << point4[1] << "  " << point4[2] << endl;
      ofl << "      vertex " << point2[0] << "  " << point2[1] << "  " << point2[2] << endl;
      ofl << "      vertex " << point3[0] << "  " << point3[1] << "  " << point3[2] << endl;
      ofl << "    endloop" << endl;
      ofl << "  endfacet" << endl;
    }
    ofl << "endsolid amazonas cell " << cellId << endl;
  }
}

//----------------------------------------------------------------------------

/** \brief writes the resulting cut surfacs (polygons) as .vtk-file
 *
 * needs the fvlookuptable.h
 * cell structure is determined based on a modified marching cubes algorithm
 *
 * is able to handle split cells and cells with ambiguous MC states
 * if compiled with #define plotall, the complete surface is plottet
 * otherwise, only the cells with ambigous states are plotted
 *
 * IMPORTANT: after this method is called, the cells can not be processed
 * further! Program has to be stopped!
 *
 * \author Claudia Guenther, March 2010
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::plotSurface() {
  TRACE();

  static constexpr MInt cornerIndices[8][3] = {{-1, -1, -1}, {1, -1, -1}, {-1, 1, -1}, {1, 1, -1},
                                               {-1, -1, 1},  {1, -1, 1},  {-1, 1, 1},  {1, 1, 1}};
  static constexpr MInt cornersSOLVERtoMC[8] = {1, 2, 0, 3, 5, 6, 4, 7};
  static constexpr MInt edgesMCtoSOLVER[12] = {0, 2, 1, 3, 4, 6, 5, 7, 10, 8, 9, 11};

  unsigned char outcode_MC = 0;
  MInt noCells = m_bndryCells->size();
  MInt cellId;
  MFloat corner[8][3] = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}};
  MInt currentCase;
  MBool currentOutcode = false;
  MInt currentSubCase;
  MInt subCaseDummy;
  MInt p_1;
  MInt p_2;
  MInt p_3;
  MInt p_0s;
  MInt p_1s;
  MInt p_2s;
  MInt p_3s;
  MInt p_0ss;
  MInt p_1ss;
  MInt p_2ss;
  MInt p_3ss;
  MInt p_1sss;
  MInt p_2sss;
  MInt p_3sss;
  MInt pP[7];
  MInt cutDummy;
  MInt cutPoints[12] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
  MInt noCutPoints = 0;
  MInt noPlotCells = 0;
  const MChar* fileName = "cutSurface_";
  stringstream fileName2;
  fileName2 << fileName << domainId() << ".vtk";
  ofstream ofl;
  MInt pointsCount = 0;
  MIntScratchSpace mcCases_scratch(noCells, AT_, "mcCases_scratch");
  MIntScratchSpace subCases_scratch(noCells, AT_, "subCases_scratch");
  MInt* mcCases = mcCases_scratch.getPointer();
  MInt* subCases = subCases_scratch.getPointer();
  for(MInt i = 0; i < m_bndryCells->size(); i++) {
    mcCases[i] = -1;
    subCases[i] = -1;
  }
  MIntScratchSpace ambiguousCells_scratch(noCells, AT_, "ambiguousCells_scratch");
  MIntScratchSpace disambiguation_scratch(noCells, AT_, "disambiguation_scratch");
  MInt* ambiguousCells = ambiguousCells_scratch.getPointer();
  MInt* disambiguation = disambiguation_scratch.getPointer();
  MInt noAmbiguousCells = 0;
  MInt bdAmbId;
  MInt faceTMP = std::numeric_limits<MInt>::min();
  static constexpr MInt facesMCtoSOLVER[6] = {0, 2, 1, 3, 4, 5};
  MInt nghbrCellId;
  stack<MInt> ambStack;
  MInt case6_2_counter = 0;
  MInt case7_3l_counter = 0;
  MInt case7_3h_counter = 0;
  MInt case3_2_counter = 0;
  MInt disamb_tmp;
  MIntScratchSpace levelSetCornerSigns(8, AT_, "levelSetCornerSigns");


  //-----------------------------------------
  cerr << " begin of plot routine! " << endl;

  // 1. Determine Case/Subcase of each bndry cell
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    cellId = m_bndryCells->a[bndryId].m_cellId;
    m_bndryCells->a[bndryId].m_noSrfcs = 1;
    outcode_MC = 0;

    if(m_solver->c_noChildren(cellId) > 0) {
      continue;
    }
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;

    // get In/Outcode of the corners of the voxel
    // 0 -> Corner is outside Fluid Domain
    // 1 -> Corner is inside Fluid Domain or on Boundary
    for(MInt j = 0; j < 8; j++) {
      for(MInt dim = 0; dim < nDim; dim++) {
        corner[j][dim] = m_solver->a_coordinate(cellId, dim)
                         + cornerIndices[j][dim] * F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId));
      }
      currentOutcode = !((MBool)m_solver->m_geometry->pointIsInside2(corner[j]));
      if(currentOutcode) outcode_MC = outcode_MC | (1 << cornersSOLVERtoMC[j]);
    }

    // Determine Case and check if case is implemented
    currentCase = (MInt)cases[outcode_MC][0];
    cerr << " cell " << cellId << " bndryId " << bndryId << " currentCase " << currentCase << endl;
    mcCases[bndryId] = currentCase;
    currentSubCase = (MInt)cases[outcode_MC][1];
    subCases[bndryId] = currentSubCase;
    if(!caseStatesSTL[currentCase][0]) {
      cerr << "Error in plotSurface: Case not implemented: " << currentCase << endl;
      continue;
    }
  }

  // 2. Determine ambiguous cells
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    disambiguation[bndryId] = -1;
    cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->c_noChildren(cellId) > 0) {
      continue;
    }
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(!caseStatesSTL[mcCases[bndryId]][0]) {
      continue;
    }
    if(!caseStatesSTL[mcCases[bndryId]][1]) { // ambiguous case
      ambiguousCells[noAmbiguousCells++] = bndryId;
      cerr << " cell " << bndryId << " is ambiguous " << endl;
    }
  }

  // 3. Determine case of ambiguous cells by states of surface midpoints - new!
  for(MInt ambId = 0; ambId < noAmbiguousCells; ambId++) {
    bdAmbId = ambiguousCells[ambId];
    disambiguation[bdAmbId] = 0;
    cellId = m_bndryCells->a[bdAmbId].m_cellId;
    currentCase = mcCases[bdAmbId];
    currentSubCase = subCases[bdAmbId];

    MInt faceMax = 0;
    switch(currentCase) {
      case 3:
        faceMax = 1;
        break;
      case 4:
        m_bndryCells->a[bdAmbId].m_noSrfcs = 2;
        continue;
      case 6:
        faceMax = 1;
        break;
      case 7:
        faceMax = 3;
        break;
      case 10:
        faceMax = 2;
        break;
      case 12:
        faceMax = 2;
        break;
      default: {
        stringstream errorMessage;
        errorMessage << " Error in FvBndryCndXD::plotSurface: cell in ambigous cells does not have an ambiguous "
                        "case... cellId: "
                     << cellId << " case: " << currentCase << " bndryId: " << bdAmbId << endl;
        writeStlFileOfCell(cellId, "errorcell.stl");
        mTerm(1, AT_, errorMessage.str());
      }
    }

    for(MInt i = 0; i < faceMax; i++) {
      // compute ambigous face centroid and check if it is fluid or solid. If fluid, choose connected, else choose
      // separated.
      switch(currentCase) {
        case 3:
          faceTMP = facesMCtoSOLVER[tiling3_1STL[currentSubCase][2 + i]];
          break;
        case 6:
          faceTMP = facesMCtoSOLVER[tiling6_1STL[currentSubCase][2 + i]];
          break;
        case 7:
          faceTMP = facesMCtoSOLVER[tiling7_1STL[currentSubCase][3 + i]];
          break;
        case 10:
          faceTMP = facesMCtoSOLVER[tiling10_1STL[currentSubCase][2 + i]];
          break;
        case 12:
          faceTMP = facesMCtoSOLVER[tiling12_1STL[currentSubCase][2 + i]];
          break;
        default: {
          stringstream errorMessage;
          errorMessage << " Error in FvBndryCndXD::plotSurface: cell in ambigous cells does not have an ambiguous "
                          "case... cellId: "
                       << cellId << " case: " << currentCase << " bndryId: " << bdAmbId << endl;
          mTerm(1, AT_, errorMessage.str());
        }
      }
      nghbrCellId = m_solver->c_neighborId(cellId, faceTMP);
      if(nghbrCellId < 0) {
        stringstream errorMessage;
        errorMessage << " Error in FvBndryCndXD::plotSurface: no neighbor in ambiguous direction... exiting." << endl;
        errorMessage << " cellId: " << cellId << ", ambiguous face: " << faceTMP << endl;
        writeStlFileOfCell(cellId, "errorcell.stl");
        mTerm(1, AT_, errorMessage.str());
      }

      // compute ambiguous face centroid
      // returns true if point is not located in fluid domain, false if it is located in the fluid domain
      for(MInt dim = 0; dim < nDim; dim++) {
        corner[0][dim] = (m_solver->a_coordinate(cellId, dim) + m_solver->a_coordinate(nghbrCellId, dim)) * F1B2;
      }
      currentOutcode = (MBool)m_solver->m_geometry->pointIsInside2(corner[0]);

      if(currentOutcode) {
        disambiguation[bdAmbId] += IPOW2(faceMax - i - 1);
      }
    }

    // find correct number of surfaces etc.
    switch(currentCase) {
      case 3: {
        if(disambiguation[bdAmbId] == 0) {
          if(currentSubCase < 12) {
            m_bndryCells->a[bdAmbId].m_noSrfcs = 1;
            //             m_bndryCells->a[bdAmbId].m_noSrfcs = 2;
            //             case3_2_counter++;
          } else {
            m_bndryCells->a[bdAmbId].m_noSrfcs = 2;
          }
        }
        if(disambiguation[bdAmbId] == 1) {
          if(currentSubCase < 12) {
            m_bndryCells->a[bdAmbId].m_noSrfcs = 2;
          } else {
            m_bndryCells->a[bdAmbId].m_noSrfcs = 1;
            //             m_bndryCells->a[bdAmbId].m_noSrfcs = 2;
            //             case3_2_counter++;
          }
        }
        break;
      }
      case 6: {
        if(disambiguation[bdAmbId] == 0) {
          if(currentSubCase < 24) {
            m_bndryCells->a[bdAmbId].m_noSrfcs = 3;
            case6_2_counter++;
          } else {
            m_bndryCells->a[bdAmbId].m_noSrfcs = 2;
          }
        }
        if(disambiguation[bdAmbId] == 1) {
          if(currentSubCase < 24) {
            m_bndryCells->a[bdAmbId].m_noSrfcs = 2;
          } else {
            m_bndryCells->a[bdAmbId].m_noSrfcs = 3;
            case6_2_counter++;
          }
        }
        break;
      }
      case 7: {
        // find correct cell type for myself
        if(currentSubCase < 8) {
          switch(disambiguation[bdAmbId]) {
            case 0:
              m_bndryCells->a[bdAmbId].m_noSrfcs = 2;
              break;
            case 1:
            case 2:
            case 4:
              m_bndryCells->a[bdAmbId].m_noSrfcs = 2;
              case7_3l_counter++;
              break;
            case 3:
            case 5:
            case 6:
              m_bndryCells->a[bdAmbId].m_noSrfcs = 2; // eig. 2 x 1
              break;
            case 7:
              m_bndryCells->a[bdAmbId].m_noSrfcs = 3; // eig. 3 x 1
              break;
            default: {
              stringstream errorMessage;
              errorMessage << "ERROR: Switch variable 'disambiguation[bdAmbId]' with value " << disambiguation[bdAmbId]
                           << " not matching any case." << endl;
              mTerm(1, AT_, errorMessage.str());
            }
          }
        } else {
          switch(disambiguation[bdAmbId]) {
            case 0:
              m_bndryCells->a[bdAmbId].m_noSrfcs = 3;
              break;
            case 1:
            case 2:
            case 4:
              m_bndryCells->a[bdAmbId].m_noSrfcs = 2;
              break;
            case 3:
            case 5:
            case 6:
              m_bndryCells->a[bdAmbId].m_noSrfcs = 3;
              case7_3h_counter++;
              break;
            case 7:
              m_bndryCells->a[bdAmbId].m_noSrfcs = 2;
              break;
            default: {
              stringstream errorMessage;
              errorMessage << "ERROR: Switch variable 'disambiguation[bdAmbId]' with value " << disambiguation[bdAmbId]
                           << " not matching any case." << endl;
              mTerm(1, AT_, errorMessage.str());
            }
          }
        }
        break;
      }
      case 10: {
        m_bndryCells->a[bdAmbId].m_noSrfcs = 2;
        break;
      }
      case 12: {
        m_bndryCells->a[bdAmbId].m_noSrfcs = 2;
        break;
      }
      default: {
        stringstream errorMessage;
        errorMessage << " Error in FvBndryCndXD::plotSurface: cell in ambigous cells does not have an ambiguous "
                        "case... cellId: "
                     << cellId << " case: " << currentCase << " bndryId: " << bdAmbId << endl;
        writeStlFileOfCell(cellId, "errorcell.stl");
        mTerm(1, AT_, errorMessage.str());
      }
    }
  }

  // 6. Count cut points and surfaces
#ifdef plotall
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
#else
  for(MInt ambId = 0; ambId < noAmbiguousCells; ambId++) {
    MInt bndryId = ambiguousCells[ambId];
#endif
    cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->c_noChildren(cellId) > 0) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    noCutPoints += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
    noPlotCells += m_bndryCells->a[bndryId].m_noSrfcs;
  }

  // 7. Plot cut surfaces
  ofl.open((fileName2.str()).c_str(), ofstream::trunc);

  if(ofl) {
    // set fixed floating point output
    ofl.setf(ios::fixed);
    ofl.precision(7);

    ofl << "# vtk DataFile Version 3.0" << endl
        << "MAIAD cutsurface file" << endl
        << "ASCII" << endl
        << endl
        << "DATASET UNSTRUCTURED_GRID" << endl
        << endl;

    ofl << "POINTS " << noCutPoints << " float" << endl;

    // write out cut coordiates of all boundary cells
#ifdef plotall
    for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
#else
    for(MInt ambId = 0; ambId < noAmbiguousCells; ambId++) {
      MInt bndryId = ambiguousCells[ambId];
#endif

      cellId = m_bndryCells->a[bndryId].m_cellId;
      outcode_MC = 0;

      if(m_solver->c_noChildren(cellId) > 0) {
        continue;
      }
      if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;

      for(MInt cutPoint = 0; cutPoint < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cutPoint++) {
        for(MInt i = 0; i < 3; i++)
          ofl << m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoint][i] << " ";
        ofl << endl;
      }
      if(m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints != caseCutPoints[mcCases[bndryId]]) {
        stringstream errorMessage;
        errorMessage << "Problem in FvBndryCndXD::plotSurface: "
                     << " cell " << bndryId << " case " << mcCases[bndryId] << endl;
        errorMessage << " cell with subcase " << subCases[bndryId] << " has "
                     << m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints << " cutpoints instead of "
                     << caseCutPoints[mcCases[bndryId]] << endl;
        writeStlFileOfCell(cellId, "problemacell.stl");
        mTerm(1, AT_, errorMessage.str());
      }

      ofl << endl;
    }

    ofl << endl;
    ofl << "CELLS " << noPlotCells << " "
        << noPlotCells + noCutPoints + case6_2_counter * 4 + case7_3l_counter * 2 + case7_3h_counter * 4
               + case3_2_counter * 2
        << endl;


    // determine polygonal structure of the cut faces and write polygons defined by point indices out
#ifdef plotall
    for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
#else
    for(MInt ambId = 0; ambId < noAmbiguousCells; ambId++) {
      MInt bndryId = ambiguousCells[ambId];
#endif
      cellId = m_bndryCells->a[bndryId].m_cellId;

      if(m_solver->c_noChildren(cellId) > 0) {
        continue;
      }
      if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;

      for(MInt cutPoint = 0; cutPoint < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cutPoint++) {
        cutPoints[m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cutPoint]] = cutPoint;
      }

      for(MInt i = 0; i < 8; i++) {
        for(MInt dim = 0; dim < nDim; dim++) {
          corner[i][dim] = m_solver->a_coordinate(cellId, dim)
                           + cornerIndices[i][dim] * F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId));
        }
      }

      currentCase = mcCases[bndryId];
      currentSubCase = subCases[bndryId];

      if(!caseStatesSTL[currentCase][0]) {
        cerr << "Error in plotSurface: Case not implemented: " << currentCase << endl;
        continue;
      }

      if(!caseStatesSTL[currentCase][1]) {
        switch(currentCase) {
          case 3: {
            if(disambiguation[bndryId] == -1) {
              stringstream errorMessage;
              errorMessage << "Error in plotSurface: case 3 cell not disambiguated! cell: " << cellId << ", exiting!"
                           << endl;
              mTerm(1, AT_, errorMessage.str());
            }
            if((currentSubCase < 12 && disambiguation[bndryId] == 0)
               || (currentSubCase >= 12 && disambiguation[bndryId] == 1)) { // case 3.2
              cerr << " plotting case 3.2 - 1 surface " << endl;
              // 	  continue;
              cutDummy = edgesMCtoSOLVER[tiling3_2STL[currentSubCase][2]];
              p_1 = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling3_2STL[currentSubCase][3]];
              p_2 = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling3_2STL[currentSubCase][4]];
              p_3 = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling3_2STL[currentSubCase][5]];
              p_1s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling3_2STL[currentSubCase][6]];
              p_2s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling3_2STL[currentSubCase][7]];
              p_3s = cutPoints[cutDummy];

              pP[0] = p_1;
              pP[1] = p_2;
              pP[2] = p_3;
              pP[3] = p_1s;
              pP[4] = p_2s;
              pP[5] = p_3s;
              pP[6] = p_1;

              ofl << 6 << " ";

              for(MInt i = 0; i < 6; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;

              //               pP[0] = p_2;
              //               pP[1] = p_3;
              //               pP[2] = p_1s;
              //               pP[3] = p_2s;
              //
              //               ofl << 4 << " ";
              //
              //               for(MInt i = 0; i < 4; i++){
              //                 ofl << pP[i] + pointsCount << " ";
              //               }
              //               ofl << endl;
              //
              //               pP[0] = p_2s;
              //               pP[1] = p_3s;
              //               pP[2] = p_1;
              //               pP[3] = p_2;
              //
              //               ofl << 4 << " ";
              //
              //               for(MInt i = 0; i < 4; i++){
              //                 ofl << pP[i] + pointsCount << " ";
              //               }
              //               ofl << endl;
              pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;

            } else if((currentSubCase < 12 && disambiguation[bndryId] == 1)
                      || (currentSubCase >= 12 && disambiguation[bndryId] == 0)) {
              cerr << " plotting case 3.1 - 2 surfaces " << endl;
              // 1st Pyramid + 1st cutFace
              subCaseDummy = tiling3_1STL[currentSubCase][0];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
              pP[0] = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
              pP[1] = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
              pP[2] = cutPoints[cutDummy];

              ofl << 3 << " ";

              for(MInt i = 0; i < 3; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;

              // 2nd Pyramid + 2nd cutFace
              subCaseDummy = tiling3_1STL[currentSubCase][1];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
              pP[0] = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
              pP[1] = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
              pP[2] = cutPoints[cutDummy];

              ofl << 3 << " ";

              for(MInt i = 0; i < 3; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;
              pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
            }
            break;
          }
          case 4: {
            cerr << " plotting case 4 - 2 surfaces " << endl;
            // 1st Pyramid + 1st cutFace
            subCaseDummy = tiling4_1STL[currentSubCase][0];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
            pP[0] = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
            pP[1] = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
            pP[2] = cutPoints[cutDummy];

            ofl << 3 << " ";

            for(MInt i = 0; i < 3; i++) {
              ofl << pP[i] + pointsCount << " ";
            }
            ofl << endl;

            // 2nd Pyramid + 2nd cutFace
            subCaseDummy = tiling4_1STL[currentSubCase][1];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
            pP[0] = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
            pP[1] = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
            pP[2] = cutPoints[cutDummy];

            ofl << 3 << " ";

            for(MInt i = 0; i < 3; i++) {
              ofl << pP[i] + pointsCount << " ";
            }
            ofl << endl;
            pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;

            break;
          }
          case 6: {
            if((currentSubCase < 24 && disambiguation[bndryId] == 0)
               || (currentSubCase >= 24 && disambiguation[bndryId] == 1)) { // case 3.2
              cerr << " plotting case 6.2 - 3 surfaces " << endl;
              // 	  continue;
              cutDummy = edgesMCtoSOLVER[tiling6_2STL[currentSubCase][5]];
              p_0s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling6_2STL[currentSubCase][6]];
              p_0ss = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling6_2STL[currentSubCase][7]];
              p_1s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling6_2STL[currentSubCase][8]];
              p_1ss = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling6_2STL[currentSubCase][9]];
              p_2s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling6_2STL[currentSubCase][10]];
              p_2ss = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling6_2STL[currentSubCase][11]];
              p_3 = cutPoints[cutDummy];

              pP[0] = p_0s;
              pP[1] = p_3;
              pP[2] = p_2s;
              pP[3] = p_1s;

              ofl << 4 << " ";

              for(MInt i = 0; i < 4; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;

              pP[0] = p_0ss;
              pP[1] = p_1ss;
              pP[2] = p_2ss;
              pP[3] = p_3;

              ofl << 4 << " ";

              for(MInt i = 0; i < 4; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;

              pP[0] = p_0s;
              pP[1] = p_0ss;
              pP[2] = p_3;

              ofl << 3 << " ";

              for(MInt i = 0; i < 3; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;
              pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;

            } else if((currentSubCase < 24 && disambiguation[bndryId] == 1)
                      || (currentSubCase >= 24 && disambiguation[bndryId] == 0)) {
              cerr << " plotting case 6.1 - 2 surfaces " << endl;
              // 1st prism & 1st cutFace
              subCaseDummy = tiling6_1STL[currentSubCase][0];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][2]];
              p_3 = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][3]];
              p_2 = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][4]];
              p_3s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][5]];
              p_2s = cutPoints[cutDummy];

              pP[0] = p_3;
              pP[1] = p_3s;
              pP[2] = p_2s;
              pP[3] = p_2;
              pP[4] = p_3;

              ofl << 4 << " ";

              for(MInt i = 0; i < 4; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;


              // 2nd Pyramid + 2nd cutFace
              subCaseDummy = tiling6_1STL[currentSubCase][1];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
              pP[0] = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
              pP[1] = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
              pP[2] = cutPoints[cutDummy];

              ofl << 3 << " ";

              for(MInt i = 0; i < 3; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;
              pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
            }
            break;
          }
          case 7: {
            disamb_tmp = disambiguation[bndryId];
            if(currentSubCase >= 8) disamb_tmp = 7 - disamb_tmp;
            switch(disamb_tmp) {
              case 0: { // case 7.4.1

                cerr << " plotting case 7.4.1 - 2 surfaces " << endl;
                // 1st Pyramid + 1st cutFace
                subCaseDummy = tiling7_4_1STL[currentSubCase][0];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
                pP[0] = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
                pP[1] = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
                pP[2] = cutPoints[cutDummy];

                ofl << 3 << " ";

                for(MInt i = 0; i < 3; i++) {
                  ofl << pP[i] + pointsCount << " ";
                }
                ofl << endl;

                subCaseDummy = tiling7_4_1STL[currentSubCase][1];

                cutDummy = edgesMCtoSOLVER[tiling9STL[subCaseDummy][4]];
                p_1s = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling9STL[subCaseDummy][5]];
                p_1ss = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling9STL[subCaseDummy][6]];
                p_2s = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling9STL[subCaseDummy][7]];
                p_2ss = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling9STL[subCaseDummy][8]];
                p_3s = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling9STL[subCaseDummy][9]];
                p_3ss = cutPoints[cutDummy];

                pP[0] = p_1ss;
                pP[1] = p_1s;
                pP[2] = p_2ss;
                pP[3] = p_2s;
                pP[4] = p_3ss;
                pP[5] = p_3s;
                pP[6] = p_1ss;

                ofl << 6 << " ";

                for(MInt i = 0; i < 6; i++) {
                  ofl << pP[i] + pointsCount << " ";
                }
                ofl << endl;
                pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;

                break;
              }
              case 1: { // case 7.3, disamb 1
                cutDummy = edgesMCtoSOLVER[tiling7_3_1STL[currentSubCase][6]];
                p_1s = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_1STL[currentSubCase][7]];
                p_1ss = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_1STL[currentSubCase][8]];
                p_1sss = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_1STL[currentSubCase][9]];
                p_2s = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_1STL[currentSubCase][10]];
                p_2ss = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_1STL[currentSubCase][11]];
                p_2sss = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_1STL[currentSubCase][12]];
                p_3s = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_1STL[currentSubCase][13]];
                p_3ss = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_1STL[currentSubCase][14]];
                p_3sss = cutPoints[cutDummy];

                if(currentSubCase < 8) {
                  cerr << " plotting case 7.3 - 2 surfaces, disamb 1, low SC " << endl;

                  pP[0] = p_1sss;
                  pP[1] = p_2sss;
                  pP[2] = p_2s;
                  pP[3] = p_3ss;
                  pP[4] = p_3sss;

                  ofl << 5 << " ";

                  for(MInt i = 0; i < 5; i++) {
                    ofl << pP[i] + pointsCount << " ";
                  }
                  ofl << endl;

                  pP[0] = p_1s;
                  pP[1] = p_1ss;
                  pP[2] = p_3s;
                  pP[3] = p_3ss;
                  pP[4] = p_2s;
                  pP[5] = p_2ss;

                  ofl << 6 << " ";

                  for(MInt i = 0; i < 6; i++) {
                    ofl << pP[i] + pointsCount << " ";
                  }
                  ofl << endl;
                } else {
                  cerr << " plotting case 7.3 - 3 surfaces, disamb 1, high SC " << endl;

                  pP[0] = p_1ss;
                  pP[1] = p_1sss;
                  pP[2] = p_3sss;
                  pP[3] = p_3ss;
                  pP[4] = p_3s;

                  ofl << 5 << " ";

                  for(MInt i = 0; i < 5; i++) {
                    ofl << pP[i] + pointsCount << " ";
                  }
                  ofl << endl;

                  pP[0] = p_1sss;
                  pP[1] = p_1s;
                  pP[2] = p_2ss;
                  pP[3] = p_2s;
                  pP[4] = p_2sss;

                  ofl << 5 << " ";

                  for(MInt i = 0; i < 5; i++) {
                    ofl << pP[i] + pointsCount << " ";
                  }
                  ofl << endl;

                  pP[0] = p_1s;
                  pP[1] = p_1sss;
                  pP[2] = p_1ss;

                  ofl << 3 << " ";

                  for(MInt i = 0; i < 3; i++) {
                    ofl << pP[i] + pointsCount << " ";
                  }
                  ofl << endl;
                }
                pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;

                break;
              }
              case 2: { // case 7.3, disamb 2
                cerr << " plotting case 7.3 - 3 surfaces, disamb 2 " << endl;

                cutDummy = edgesMCtoSOLVER[tiling7_3_2STL[currentSubCase][6]];
                p_1s = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_2STL[currentSubCase][7]];
                p_1ss = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_2STL[currentSubCase][8]];
                p_1sss = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_2STL[currentSubCase][9]];
                p_2s = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_2STL[currentSubCase][10]];
                p_2ss = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_2STL[currentSubCase][11]];
                p_2sss = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_2STL[currentSubCase][12]];
                p_3s = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_2STL[currentSubCase][13]];
                p_3ss = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_2STL[currentSubCase][14]];
                p_3sss = cutPoints[cutDummy];

                if(currentSubCase < 8) {
                  cerr << " plotting case 7.3 - 2 surfaces, disamb 2, low SC " << endl;

                  pP[0] = p_1sss;
                  pP[1] = p_2sss;
                  pP[2] = p_2s;
                  pP[3] = p_3ss;
                  pP[4] = p_3sss;

                  ofl << 5 << " ";

                  for(MInt i = 0; i < 5; i++) {
                    ofl << pP[i] + pointsCount << " ";
                  }
                  ofl << endl;

                  pP[0] = p_1s;
                  pP[1] = p_1ss;
                  pP[2] = p_3s;
                  pP[3] = p_3ss;
                  pP[4] = p_2s;
                  pP[5] = p_2ss;

                  ofl << 6 << " ";

                  for(MInt i = 0; i < 6; i++) {
                    ofl << pP[i] + pointsCount << " ";
                  }
                  ofl << endl;
                } else {
                  cerr << " plotting case 7.3 - 3 surfaces, disamb 2, high SC " << endl;

                  pP[0] = p_1ss;
                  pP[1] = p_1sss;
                  pP[2] = p_3sss;
                  pP[3] = p_3ss;
                  pP[4] = p_3s;

                  ofl << 5 << " ";

                  for(MInt i = 0; i < 5; i++) {
                    ofl << pP[i] + pointsCount << " ";
                  }
                  ofl << endl;

                  pP[0] = p_1sss;
                  pP[1] = p_1s;
                  pP[2] = p_2ss;
                  pP[3] = p_2s;
                  pP[4] = p_2sss;

                  ofl << 5 << " ";

                  for(MInt i = 0; i < 5; i++) {
                    ofl << pP[i] + pointsCount << " ";
                  }
                  ofl << endl;

                  pP[0] = p_1s;
                  pP[1] = p_1sss;
                  pP[2] = p_1ss;

                  ofl << 3 << " ";

                  for(MInt i = 0; i < 3; i++) {
                    ofl << pP[i] + pointsCount << " ";
                  }
                  ofl << endl;
                }
                pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;

                break;
              }
              case 4: { // case 7.3, disamb 4
                cerr << " plotting case 7.3 - 3 surfaces, disamb 4 " << endl;

                cutDummy = edgesMCtoSOLVER[tiling7_3_4STL[currentSubCase][6]];
                p_1s = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_4STL[currentSubCase][7]];
                p_1ss = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_4STL[currentSubCase][8]];
                p_1sss = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_4STL[currentSubCase][9]];
                p_2s = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_4STL[currentSubCase][10]];
                p_2ss = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_4STL[currentSubCase][11]];
                p_2sss = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_4STL[currentSubCase][12]];
                p_3s = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_4STL[currentSubCase][13]];
                p_3ss = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling7_3_4STL[currentSubCase][14]];
                p_3sss = cutPoints[cutDummy];

                if(currentSubCase < 8) {
                  cerr << " plotting case 7.3 - 2 surfaces, disamb 4, low SC " << endl;

                  pP[0] = p_1sss;
                  pP[1] = p_2sss;
                  pP[2] = p_2s;
                  pP[3] = p_3ss;
                  pP[4] = p_3sss;

                  ofl << 5 << " ";

                  for(MInt i = 0; i < 5; i++) {
                    ofl << pP[i] + pointsCount << " ";
                  }
                  ofl << endl;

                  pP[0] = p_1s;
                  pP[1] = p_1ss;
                  pP[2] = p_3s;
                  pP[3] = p_3ss;
                  pP[4] = p_2s;
                  pP[5] = p_2ss;

                  ofl << 6 << " ";

                  for(MInt i = 0; i < 6; i++) {
                    ofl << pP[i] + pointsCount << " ";
                  }
                  ofl << endl;
                } else {
                  cerr << " plotting case 7.3 - 3 surfaces, disamb 4, high SC " << endl;

                  pP[0] = p_1ss;
                  pP[1] = p_1sss;
                  pP[2] = p_3sss;
                  pP[3] = p_3ss;
                  pP[4] = p_3s;

                  ofl << 5 << " ";

                  for(MInt i = 0; i < 5; i++) {
                    ofl << pP[i] + pointsCount << " ";
                  }
                  ofl << endl;

                  pP[0] = p_1sss;
                  pP[1] = p_1s;
                  pP[2] = p_2ss;
                  pP[3] = p_2s;
                  pP[4] = p_2sss;

                  ofl << 5 << " ";

                  for(MInt i = 0; i < 5; i++) {
                    ofl << pP[i] + pointsCount << " ";
                  }
                  ofl << endl;

                  pP[0] = p_1s;
                  pP[1] = p_1sss;
                  pP[2] = p_1ss;

                  ofl << 3 << " ";

                  for(MInt i = 0; i < 3; i++) {
                    ofl << pP[i] + pointsCount << " ";
                  }
                  ofl << endl;
                }
                pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;

                break;
              }
              case 3: { // case 7.2, disamb 3

                cerr << " plotting case 7.2 - 2 surfaces, disamb 3 " << endl;
                // 1st Pyramid + 1st cutFace
                subCaseDummy = tiling7_2_3STL[currentSubCase][0];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
                pP[0] = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
                pP[1] = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
                pP[2] = cutPoints[cutDummy];

                ofl << 3 << " ";

                for(MInt i = 0; i < 3; i++) {
                  ofl << pP[i] + pointsCount << " ";
                }
                ofl << endl;

                subCaseDummy = tiling7_2_3STL[currentSubCase][1];
                cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][2]];
                p_1 = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][3]];
                p_2 = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][4]];
                p_3 = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][5]];
                p_1s = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][6]];
                p_2s = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][7]];
                p_3s = cutPoints[cutDummy];

                pP[0] = p_1;
                pP[1] = p_2;
                pP[2] = p_3;
                pP[3] = p_1s;
                pP[4] = p_2s;
                pP[5] = p_3s;
                pP[6] = p_1;

                ofl << 6 << " ";

                for(MInt i = 0; i < 6; i++) {
                  ofl << pP[i] + pointsCount << " ";
                }
                ofl << endl;
                pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;

                break;
              }
              case 5: { // case 7.2, disamb 5
                cerr << " plotting case 7.2 - 2 surfaces, disamb 5 " << endl;
                // 1st Pyramid + 1st cutFace
                subCaseDummy = tiling7_2_5STL[currentSubCase][0];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
                pP[0] = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
                pP[1] = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
                pP[2] = cutPoints[cutDummy];

                ofl << 3 << " ";

                for(MInt i = 0; i < 3; i++) {
                  ofl << pP[i] + pointsCount << " ";
                }
                ofl << endl;

                subCaseDummy = tiling7_2_5STL[currentSubCase][1];
                cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][2]];
                p_1 = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][3]];
                p_2 = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][4]];
                p_3 = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][5]];
                p_1s = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][6]];
                p_2s = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][7]];
                p_3s = cutPoints[cutDummy];

                pP[0] = p_1;
                pP[1] = p_2;
                pP[2] = p_3;
                pP[3] = p_1s;
                pP[4] = p_2s;
                pP[5] = p_3s;
                pP[6] = p_1;

                ofl << 6 << " ";

                for(MInt i = 0; i < 6; i++) {
                  ofl << pP[i] + pointsCount << " ";
                }
                ofl << endl;
                pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;

                break;
              }
              case 6: { // case 7.2, disamb 6
                cerr << " plotting case 7.2 - 2 surfaces, disamb 6 " << endl;
                // 1st Pyramid + 1st cutFace
                subCaseDummy = tiling7_2_6STL[currentSubCase][0];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
                pP[0] = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
                pP[1] = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
                pP[2] = cutPoints[cutDummy];

                ofl << 3 << " ";

                for(MInt i = 0; i < 3; i++) {
                  ofl << pP[i] + pointsCount << " ";
                }
                ofl << endl;

                subCaseDummy = tiling7_2_6STL[currentSubCase][1];
                cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][2]];
                p_1 = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][3]];
                p_2 = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][4]];
                p_3 = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][5]];
                p_1s = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][6]];
                p_2s = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling3_2STL[subCaseDummy][7]];
                p_3s = cutPoints[cutDummy];

                pP[0] = p_1;
                pP[1] = p_2;
                pP[2] = p_3;
                pP[3] = p_1s;
                pP[4] = p_2s;
                pP[5] = p_3s;
                pP[6] = p_1;

                ofl << 6 << " ";

                for(MInt i = 0; i < 6; i++) {
                  ofl << pP[i] + pointsCount << " ";
                }
                ofl << endl;
                pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;

                break;
              }
              case 7: {
                cerr << " plotting case 7.1 - 3 surfaces " << endl;
                // 1st Pyramid + 1st cutFace
                subCaseDummy = tiling7_1STL[currentSubCase][0];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
                pP[0] = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
                pP[1] = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
                pP[2] = cutPoints[cutDummy];

                ofl << 3 << " ";

                for(MInt i = 0; i < 3; i++) {
                  ofl << pP[i] + pointsCount << " ";
                }
                ofl << endl;


                // 2nd Pyramid + 2nd cutFace
                subCaseDummy = tiling7_1STL[currentSubCase][1];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
                pP[0] = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
                pP[1] = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
                pP[2] = cutPoints[cutDummy];

                ofl << 3 << " ";

                for(MInt i = 0; i < 3; i++) {
                  ofl << pP[i] + pointsCount << " ";
                }
                ofl << endl;

                // 3rd Pyramid + 3rd cutFace
                subCaseDummy = tiling7_1STL[currentSubCase][2];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
                pP[0] = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
                pP[1] = cutPoints[cutDummy];
                cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
                pP[2] = cutPoints[cutDummy];

                ofl << 3 << " ";

                for(MInt i = 0; i < 3; i++) {
                  ofl << pP[i] + pointsCount << " ";
                }
                ofl << endl;

                pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
                break;
              }
              default: {
                stringstream errorMessage;
                errorMessage << "ERROR: Switch variable 'disamb_tmp' with value " << disamb_tmp
                             << " not matching any case." << endl;
                mTerm(1, AT_, errorMessage.str());
              }
            }


            break;
          }
          case 10: {
            if(disambiguation[bndryId] == 3) { // case 10.2
              cerr << " plotting case 10.2 (really 10.1.1 split) - 2 surfaces " << endl;
              // 1st prism & 1st cutFace
              subCaseDummy = tiling10_2STL[currentSubCase][0];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][2]];
              p_3 = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][3]];
              p_2 = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][4]];
              p_3s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][5]];
              p_2s = cutPoints[cutDummy];

              pP[0] = p_3;
              pP[1] = p_3s;
              pP[2] = p_2s;
              pP[3] = p_2;
              pP[4] = p_3;

              ofl << 4 << " ";

              for(MInt i = 0; i < 4; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;

              // 2nd prism & 2nd cutFace
              subCaseDummy = tiling10_2STL[currentSubCase][1];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][2]];
              p_3 = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][3]];
              p_2 = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][4]];
              p_3s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][5]];
              p_2s = cutPoints[cutDummy];

              pP[0] = p_3;
              pP[1] = p_3s;
              pP[2] = p_2s;
              pP[3] = p_2;
              pP[4] = p_3;

              ofl << 4 << " ";

              for(MInt i = 0; i < 4; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;

              pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;


            } else if(disambiguation[bndryId] == 0) {
              cerr << " plotting case 10.1 - 2 surfaces " << endl;
              // 1st prism & 1st cutFace
              subCaseDummy = tiling10_1STL[currentSubCase][0];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][2]];
              p_3 = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][3]];
              p_2 = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][4]];
              p_3s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][5]];
              p_2s = cutPoints[cutDummy];

              pP[0] = p_3;
              pP[1] = p_3s;
              pP[2] = p_2s;
              pP[3] = p_2;
              pP[4] = p_3;

              ofl << 4 << " ";

              for(MInt i = 0; i < 4; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;

              // 2nd prism & 2nd cutFace
              subCaseDummy = tiling10_1STL[currentSubCase][1];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][2]];
              p_3 = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][3]];
              p_2 = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][4]];
              p_3s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][5]];
              p_2s = cutPoints[cutDummy];

              pP[0] = p_3;
              pP[1] = p_3s;
              pP[2] = p_2s;
              pP[3] = p_2;
              pP[4] = p_3;

              ofl << 4 << " ";

              for(MInt i = 0; i < 4; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;

              pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;

            } else {
              cerr << "Error in plotSurface: Type 10.2 (real 10.2) detected, but not implemented."
                   << " cell " << cellId << " with bndryId " << bndryId << " and disambiguation "
                   << disambiguation[bndryId] << endl;
              writeStlFileOfCell(cellId, "10_2_cell.stl");
              cerr << " plotting cell as 10.1 cell... " << endl;
              // 1st prism & 1st cutFace

              subCaseDummy = tiling10_1STL[currentSubCase][0];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][2]];
              p_3 = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][3]];
              p_2 = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][4]];
              p_3s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][5]];
              p_2s = cutPoints[cutDummy];

              pP[0] = p_3;
              pP[1] = p_3s;
              pP[2] = p_2s;
              pP[3] = p_2;
              pP[4] = p_3;

              ofl << 4 << " ";

              for(MInt i = 0; i < 4; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;

              // 2nd prism & 2nd cutFace
              subCaseDummy = tiling10_1STL[currentSubCase][1];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][2]];
              p_3 = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][3]];
              p_2 = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][4]];
              p_3s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling2STL[subCaseDummy][5]];
              p_2s = cutPoints[cutDummy];

              pP[0] = p_3;
              pP[1] = p_3s;
              pP[2] = p_2s;
              pP[3] = p_2;
              pP[4] = p_3;

              ofl << 4 << " ";

              for(MInt i = 0; i < 4; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;

              pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
            }

            break;
          }
          case 12: {
            if(disambiguation[bndryId] == 0) {
              cerr << " plotting case 12.1 - 2 surfaces - connected" << endl;
              // 1st case 5 part & 1st cutFace
              subCaseDummy = tiling12_1STL[currentSubCase][0];

              cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][3]];
              p_0s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][4]];
              p_0ss = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][5]];
              p_1s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][6]];
              p_2s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][7]];
              p_2ss = cutPoints[cutDummy];

              pP[0] = p_0s;
              pP[1] = p_1s;
              pP[2] = p_2s;
              pP[3] = p_2ss;
              pP[4] = p_0ss;
              pP[5] = p_0s;

              ofl << 5 << " ";

              for(MInt i = 0; i < 5; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;

              // 2nd Pyramid + 2nd cutFace
              subCaseDummy = tiling12_1STL[currentSubCase][1];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
              pP[0] = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
              pP[1] = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
              pP[2] = cutPoints[cutDummy];

              ofl << 3 << " ";

              for(MInt i = 0; i < 3; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;
              pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
            } else if(disambiguation[bndryId] == 3) {
              cerr << " plotting case 12.1 - 2 surfaces - separated" << endl;
              // 1st case 5 part & 1st cutFace
              subCaseDummy = tiling12_1STL[23 - currentSubCase][0];

              cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][3]];
              p_0s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][4]];
              p_0ss = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][5]];
              p_1s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][6]];
              p_2s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][7]];
              p_2ss = cutPoints[cutDummy];

              pP[0] = p_0s;
              pP[1] = p_1s;
              pP[2] = p_2s;
              pP[3] = p_2ss;
              pP[4] = p_0ss;
              pP[5] = p_0s;

              ofl << 5 << " ";

              for(MInt i = 0; i < 5; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;

              // 2nd Pyramid + 2nd cutFace
              subCaseDummy = tiling12_1STL[23 - currentSubCase][1];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
              pP[0] = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
              pP[1] = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
              pP[2] = cutPoints[cutDummy];

              ofl << 3 << " ";

              for(MInt i = 0; i < 3; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;
              pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
            } else {
              cerr << "Error in plotSurface: Type 12.2 or 12.3 detected, but not implemented."
                   << " cell " << cellId << " with bndryId " << bndryId << " and disambiguation "
                   << disambiguation[bndryId] << endl;
              cerr << " plotting as 12.1 cell... " << endl;
              writeStlFileOfCell(cellId, "12.2_12.3_cell.stl");

              // 1st case 5 part & 1st cutFace
              subCaseDummy = tiling12_1STL[23 - currentSubCase][0];

              cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][3]];
              p_0s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][4]];
              p_0ss = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][5]];
              p_1s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][6]];
              p_2s = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling5STL[subCaseDummy][7]];
              p_2ss = cutPoints[cutDummy];

              pP[0] = p_0s;
              pP[1] = p_1s;
              pP[2] = p_2s;
              pP[3] = p_2ss;
              pP[4] = p_0ss;
              pP[5] = p_0s;

              ofl << 5 << " ";

              for(MInt i = 0; i < 5; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;

              // 2nd Pyramid + 2nd cutFace
              subCaseDummy = tiling12_1STL[23 - currentSubCase][1];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][1]];
              pP[0] = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][2]];
              pP[1] = cutPoints[cutDummy];
              cutDummy = edgesMCtoSOLVER[tiling1STL[subCaseDummy][3]];
              pP[2] = cutPoints[cutDummy];

              ofl << 3 << " ";

              for(MInt i = 0; i < 3; i++) {
                ofl << pP[i] + pointsCount << " ";
              }
              ofl << endl;
              pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
            }

            break;
          }
          default: {
            stringstream errorMessage;
            errorMessage << "Error in plotSurface: Inconsistent type implementation." << endl;
            mTerm(1, AT_, errorMessage.str());
          }
        }
      } else {
        switch(currentCase) {
          case 0: {
            cerr << "Error in plotSurface: Cell is not a boundary cell!" << endl;
            cerr << "CellId: " << cellId << "   BndryId: " << bndryId << endl;
            break;
          }
          case 1: {
            cutDummy = edgesMCtoSOLVER[tiling1STL[currentSubCase][1]];
            pP[0] = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling1STL[currentSubCase][2]];
            pP[1] = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling1STL[currentSubCase][3]];
            pP[2] = cutPoints[cutDummy];

            ofl << 3 << " ";

            for(MInt i = 0; i < 3; i++) {
              ofl << pP[i] + pointsCount << " ";
            }
            ofl << endl;
            pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
            break;
          }
          case 2: {
            cutDummy = edgesMCtoSOLVER[tiling2STL[currentSubCase][2]];
            p_3 = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling2STL[currentSubCase][3]];
            p_2 = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling2STL[currentSubCase][4]];
            p_3s = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling2STL[currentSubCase][5]];
            p_2s = cutPoints[cutDummy];
            pP[0] = p_3;
            pP[1] = p_3s;
            pP[2] = p_2s;
            pP[3] = p_2;
            pP[4] = p_3;

            ofl << 4 << " ";

            for(MInt i = 0; i < 4; i++) {
              ofl << pP[i] + pointsCount << " ";
            }
            ofl << endl;
            pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;


            break;
          }
          case 5: {
            cutDummy = edgesMCtoSOLVER[tiling5STL[currentSubCase][3]];
            p_0s = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling5STL[currentSubCase][4]];
            p_0ss = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling5STL[currentSubCase][5]];
            p_1s = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling5STL[currentSubCase][6]];
            p_2s = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling5STL[currentSubCase][7]];
            p_2ss = cutPoints[cutDummy];

            pP[0] = p_0s;
            pP[1] = p_1s;
            pP[2] = p_2s;
            pP[3] = p_2ss;
            pP[4] = p_0ss;
            pP[5] = p_0s;

            ofl << 5 << " ";

            for(MInt i = 0; i < 5; i++) {
              ofl << pP[i] + pointsCount << " ";
            }
            ofl << endl;
            pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;

            break;
          }
          case 8: {
            cutDummy = edgesMCtoSOLVER[tiling8STL[currentSubCase][4]];
            p_0s = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling8STL[currentSubCase][5]];
            p_1s = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling8STL[currentSubCase][6]];
            p_2s = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling8STL[currentSubCase][7]];
            p_3s = cutPoints[cutDummy];

            pP[0] = p_0s;
            pP[1] = p_1s;
            pP[2] = p_2s;
            pP[3] = p_3s;
            pP[4] = p_0s;

            ofl << 4 << " ";

            for(MInt i = 0; i < 4; i++) {
              ofl << pP[i] + pointsCount << " ";
            }
            ofl << endl;
            pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;


            break;
          }
          case 9: {
            cutDummy = edgesMCtoSOLVER[tiling9STL[currentSubCase][4]];
            p_1s = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling9STL[currentSubCase][5]];
            p_1ss = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling9STL[currentSubCase][6]];
            p_2s = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling9STL[currentSubCase][7]];
            p_2ss = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling9STL[currentSubCase][8]];
            p_3s = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling9STL[currentSubCase][9]];
            p_3ss = cutPoints[cutDummy];

            pP[0] = p_1ss;
            pP[1] = p_1s;
            pP[2] = p_2ss;
            pP[3] = p_2s;
            pP[4] = p_3ss;
            pP[5] = p_3s;
            pP[6] = p_1ss;

            ofl << 6 << " ";

            for(MInt i = 0; i < 6; i++) {
              ofl << pP[i] + pointsCount << " ";
            }
            ofl << endl;
            pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;

            break;
          }
          case 11: {
            cutDummy = edgesMCtoSOLVER[tiling11STL[currentSubCase][4]];
            p_0s = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling11STL[currentSubCase][5]];
            p_0ss = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling11STL[currentSubCase][6]];
            p_1s = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling11STL[currentSubCase][7]];
            p_2s = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling11STL[currentSubCase][8]];
            p_3s = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling11STL[currentSubCase][9]];
            p_3ss = cutPoints[cutDummy];

            pP[0] = p_0ss;
            pP[1] = p_0s;
            pP[2] = p_2s;
            pP[3] = p_3ss;
            pP[4] = p_3s;
            pP[5] = p_1s;
            pP[6] = p_0ss;

            ofl << 6 << " ";

            for(MInt i = 0; i < 6; i++) {
              ofl << pP[i] + pointsCount << " ";
            }
            ofl << endl;
            pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;


            break;
          }
          case 14: {
            cutDummy = edgesMCtoSOLVER[tiling14STL[currentSubCase][4]];
            p_0s = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling14STL[currentSubCase][5]];
            p_0ss = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling14STL[currentSubCase][6]];
            p_1s = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling14STL[currentSubCase][7]];
            p_2s = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling14STL[currentSubCase][8]];
            p_3s = cutPoints[cutDummy];
            cutDummy = edgesMCtoSOLVER[tiling14STL[currentSubCase][9]];
            p_3ss = cutPoints[cutDummy];

            pP[0] = p_0ss;
            pP[1] = p_0s;
            pP[2] = p_1s;
            pP[3] = p_3ss;
            pP[4] = p_3s;
            pP[5] = p_2s;
            pP[6] = p_0ss;

            ofl << 6 << " ";

            for(MInt i = 0; i < 6; i++) {
              ofl << pP[i] + pointsCount << " ";
            }
            ofl << endl;

            pointsCount += m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;

            break;
          }
          default: {
            //            mTerm(1, AT_, "Error in plotSurface: Inconsistent type implementation.");
            break;
          }
        }
      }
    }

    ofl << "CELL_TYPES " << noPlotCells << endl;
    for(MInt i = 0; i < noPlotCells; i++) {
      ofl << 7 << endl;
    }

    ofl.close();
  }
}

//---------------------------------------------------------------------------.

/** \brief writes a .vtk file of the edges in featureEdges
 *
 * featureEdges has stored length 2*noFeatureEdges points (each edge has start and end point)
 *
 * \author Claudia Guenther, April 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::plotEdges(MInt& noFeatureEdges, MFloat**& featureEdges) {
  TRACE();

  MInt& iter = m_static_plotEdges_iter;
  stringstream fileName;
  fileName << "FeatureEdges" << domainId() << "_" << iter++ << ".vtk";

  ofstream ofl;
  ofl.open((fileName.str()).c_str(), ofstream::trunc);

  if(ofl) {
    ofl.setf(ios::fixed);
    ofl.precision(7);

    ofl << "# vtk DataFile Version 3.0" << endl
        << "MAIAD featureEdge file" << endl
        << "ASCII" << endl
        << "DATASET POLYDATA" << endl
        << "POINTS " << noFeatureEdges * 2 << " float" << endl;

    for(MInt i = 0; i < noFeatureEdges; i++) {
      for(MInt j = 0; j < 2; j++) {
        for(MInt k = 0; k < 3; k++) {
          ofl << featureEdges[2 * i + j][k] << " ";
        }
        ofl << endl;
      }
    }

    ofl << "LINES " << noFeatureEdges << " " << noFeatureEdges * 3 << endl;
    for(MInt i = 0; i < noFeatureEdges; i++) {
      ofl << "2 " << 2 * i << " " << 2 * i + 1 << endl;
    }
  }

  ofl.close();
}


// ---------------------------------------------------------------------------------

/** \brief writes a .vtk file of the points in intersectionPoints
 *
 *	noIntersectionPoints is an array where the entry [i] gives the number of intersectionPoints on the i-th face of a
 *cell intersectionPoints is an array which holds the intersectionPoints; first index: face, second index: i-th
 *intersection Point on this face
 *
 * \author Claudia Guenther, April 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::plotIntersectionPoints(MInt* noIntersectionPoints, MFloat***& intersectionPoints) {
  TRACE();

  MInt& iter = m_static_plotIntersectionPoints_iter;
  stringstream fileName;
  fileName << "IntersectionPoints" << domainId() << "_" << iter++ << ".vtk";

  ofstream ofl;
  ofl.open((fileName.str()).c_str(), ofstream::trunc);
  MInt totalPoints = 0;

  for(MInt i = 0; i < 6; i++) {
    totalPoints += noIntersectionPoints[i];
  }

  if(ofl) {
    ofl.setf(ios::fixed);
    ofl.precision(7);

    ofl << "# vtk DataFile Version 3.0" << endl
        << "MAIAD intersectionPoints file" << endl
        << "ASCII" << endl
        << "DATASET POLYDATA" << endl
        << "POINTS " << totalPoints << " float" << endl;

    for(MInt face = 0; face < 6; face++) {
      for(MInt i = 0; i < noIntersectionPoints[face]; i++) {
        for(MInt k = 0; k < 3; k++) {
          ofl << intersectionPoints[face][i][k] << " ";
        }
        ofl << endl;
      }
    }

    ofl << "VERTICES " << totalPoints << " " << totalPoints * 2 << endl;
    for(MInt i = 0; i < totalPoints; i++) {
      ofl << "1 " << i << endl;
    }
  }

  ofl.close();
}

// ---------------------------------------------------------------------------------

/** \brief writes the nodes in nodeList in a .stl file
 *
 * \author Claudia Guenther, March 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::writeStlOfNodes(MInt noNodes, MInt*& nodeList, const MChar* filename) {
  TRACE();

  MFloat* point1;
  MFloat* point2;
  MFloat* point3;
  MFloat normal[3] = {0.0, 0.0, 0.0};
  MFloat dummy_1[3] = {0, 0, 0};
  MFloat dummy_2[3] = {0, 0, 0};
  MFloat dummy_3[3] = {0, 0, 0};
  MFloat area;
  MInt& iter = m_static_writeStlOfNodes_iter;
  stringstream fileName2;
  fileName2 << filename << domainId() << "_" << iter++ << ".stl";

  ofstream ofl;
  ofl.open((fileName2.str()).c_str(), ofstream::trunc);

  if(ofl) {
    // set fixed floating point output
    ofl.setf(ios::fixed);
    ofl.precision(7);

    ofl << " solid feature triangles " << endl;

    for(MInt i = 0; i < noNodes; i++) {
      point1 = m_solver->m_geometry->elements[nodeList[i]].m_vertices[0];
      point2 = m_solver->m_geometry->elements[nodeList[i]].m_vertices[1];
      point3 = m_solver->m_geometry->elements[nodeList[i]].m_vertices[2];

      vecSub(point2, point1, dummy_1);
      vecSub(point3, point1, dummy_2);
      maia::math::cross(dummy_1, dummy_2, dummy_3);
      area = maia::math::norm(dummy_3, 3);
      vecScalarMul(-1.0 / area, dummy_3, normal);

      ofl << "  facet normal " << normal[0] << "  " << normal[1] << "  " << normal[2] << endl;
      ofl << "    outer loop" << endl;
      ofl << "      vertex " << point1[0] << "  " << point1[1] << "  " << point1[2] << endl;
      ofl << "      vertex " << point2[0] << "  " << point2[1] << "  " << point2[2] << endl;
      ofl << "      vertex " << point3[0] << "  " << point3[1] << "  " << point3[2] << endl;
      ofl << "    endloop" << endl;
      ofl << "  endfacet" << endl;
    }

    ofl << " endsolid feature triangles " << endl;
  }

  ofl.close();
}

// ---------------------------------------------------------------------------------------------

/** \brief writes the triangle given by A, B, C and normal in the stl-format in the ofstream
 *
 * \author Claudia Guenther, March 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::plotTriangle(ofstream& ofl, MFloat* A, MFloat* B, MFloat* C, MFloat* normal) {
  TRACE();

  ofl << "  facet normal " << normal[0] << "  " << normal[1] << "  " << normal[2] << endl;
  ofl << "    outer loop" << endl;
  ofl << "      vertex " << A[0] << "  " << A[1] << "  " << A[2] << endl;
  ofl << "      vertex " << B[0] << "  " << B[1] << "  " << B[2] << endl;
  ofl << "      vertex " << C[0] << "  " << C[1] << "  " << C[2] << endl;
  ofl << "    endloop" << endl;
  ofl << "  endfacet" << endl;
}


// ---------------------------------------------------------------------------------
// ----------------------------	geometric help routines  ---------------------------
// ---------------------------------------------------------------------------------


/** \brief subtracts vector b from vector a and returns the result in vector res
 *
 * \author Claudia Guenther, March 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
MFloat* FvBndryCndXD<nDim, SysEqn>::vecSub(MFloat* a, MFloat* b, MFloat* res) {
  TRACE();

  for(MInt dim = 0; dim < nDim; dim++) {
    res[dim] = a[dim] - b[dim];
  }
  return res;
}

// -------------------------------------------------------------------------------

/** \brief multiplies vector a with the scalar value s and returns the result in res
 *
 * \author Claudia Guenther, March 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
MFloat* FvBndryCndXD<nDim, SysEqn>::vecScalarMul(MFloat s, MFloat* a, MFloat* res) {
  TRACE();

  for(MInt dim = 0; dim < nDim; dim++) {
    res[dim] = s * a[dim];
  }
  return res;
}

// -------------------------------------------------------------------------------

/** \brief computes area and centroid of a triangle given by the points abc
 *
 * \author Claudia Guenther, March 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::computeTri(MFloat* a, MFloat* b, MFloat* c, MFloat* area, MFloat* centroid) {
  TRACE();

  MFloat dummy_1[3] = {0, 0, 0};
  MFloat dummy_2[3] = {0, 0, 0};
  MFloat dummy_3[3] = {0, 0, 0};

  vecSub(b, a, dummy_1);
  vecSub(c, a, dummy_2);
  maia::math::cross(dummy_1, dummy_2, dummy_3);
  *area = 0.5 * maia::math::norm(dummy_3, 3);
  std::fill(dummy_1, dummy_1 + 3, 0.0);
  centroid = vecScalarMul(F1B3, maia::math::vecAdd<3>(dummy_1, a, b, c), centroid);
  return;
}

// -------------------------------------------------------------------------------

/** \brief computes area, centroid and normal of a triangle given by the points abc
 *
 *	normal is -((b-a) x (c-a)) -> careful!
 *
 * \author Claudia Guenther, March 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::computeTri(MFloat* a, MFloat* b, MFloat* c, MFloat* area, MFloat* centroid,
                                            MFloat* normal) {
  TRACE();

  computePoly3(a, b, c, area, centroid, normal);
  return;
}

// -----------------------------------------------------------------------------

/** \brief computes area, centroid and normal of a trapezoid given by the points abcd
*
*	normal is -((b-a) x (c-a)) -> careful!
*
* order of the points should be in the mathematically correct sense of rotation if the normal
* defined by -((b-a)x(c-a)) points in the computational (fluid) domain

* \author Claudia Guenther, March 2009
*/
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::computeTrapez(MFloat* a, MFloat* b, MFloat* c, MFloat* d, MFloat* area,
                                               MFloat* centroid, MFloat* normal) {
  TRACE();

  MFloat dummy_1[3] = {0, 0, 0};
  MFloat dummy_2[3] = {0, 0, 0};
  MFloat A1, A2;

  computeTri(a, b, c, &A1, dummy_1, normal);
  computeTri(c, d, a, &A2, dummy_2);
  *area = A1 + A2;
  std::fill_n(centroid, 3, 0.0);
  maia::math::vecAdd<3>(centroid, vecScalarMul(A1, dummy_1, dummy_1), vecScalarMul(A2, dummy_2, dummy_2));
  centroid = vecScalarMul(F1 / *area, centroid, centroid);
  return;
}

// -------------------------------------------------------------------------------

/** \brief computes area, centroid and normal of a 3-point polygon given by the points abc
 *
 *	normal is -((b-a) x (c-a)) -> careful!
 *
 * order of the points should be in the mathematically correct sense of rotation if the normal
 * defined by -((b-a)x(c-a)) points in the computational (fluid) domain
 *
 * \author Claudia Guenther, March 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::computePoly3(MFloat* a, MFloat* b, MFloat* c, MFloat* area, MFloat* centroid,
                                              MFloat* normal) {
  TRACE();

  MFloat dummy_1[3] = {0, 0, 0};
  MFloat dummy_2[3] = {0, 0, 0};
  MFloat dummy_3[3] = {0, 0, 0};

  vecSub(b, a, dummy_1);
  vecSub(c, a, dummy_2);
  maia::math::cross(dummy_1, dummy_2, dummy_3);
  *area = 0.5 * maia::math::norm(dummy_3, 3);
  normal = vecScalarMul(-F1B2 / *area, dummy_3, normal);
  std::fill_n(dummy_1, 3, 0.0);
  centroid = vecScalarMul(F1B3, maia::math::vecAdd<3>(dummy_1, a, b, c), centroid);
  return;
}

// -------------------------------------------------------------------------------

/** \brief computes area, centroid and normal of a 4-point polygon given by the points abcd
 *
 *	normal is -((b-a) x (c-a)) -> careful!
 *
 * order of the points should be in the mathematically correct sense of rotation if the normal
 * defined by -((b-a)x(c-a)) points in the computational (fluid) domain
 *
 * \author Claudia Guenther, March 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::computePoly4(MFloat* a, MFloat* b, MFloat* c, MFloat* d, MFloat* area,
                                              MFloat* centroid, MFloat* normal) {
  TRACE();

  MFloat c_1[3] = {0, 0, 0};
  MFloat c_2[3] = {0, 0, 0};
  MFloat c_3[3] = {0, 0, 0};
  MFloat c_4[3] = {0, 0, 0};
  MFloat n_1[3] = {0, 0, 0};
  MFloat n_2[3] = {0, 0, 0};
  MFloat n_3[3] = {0, 0, 0};
  MFloat n_4[3] = {0, 0, 0};
  MFloat M[3] = {0, 0, 0};
  MFloat A1, A2, A3, A4;

  maia::math::vecAvg<3>(M, a, b, c, d);
  computePoly3(a, b, M, &A1, c_1, n_1);
  computePoly3(b, c, M, &A2, c_2, n_2);
  computePoly3(c, d, M, &A3, c_3, n_3);
  computePoly3(d, a, M, &A4, c_4, n_4);

  *area = A1 + A2 + A3 + A4;
  vecScalarMul(A1, c_1, c_1);
  vecScalarMul(A2, c_2, c_2);
  vecScalarMul(A3, c_3, c_3);
  vecScalarMul(A4, c_4, c_4);
  std::fill_n(centroid, 3, 0.0);
  centroid = vecScalarMul(F1 / *area, maia::math::vecAdd<3>(centroid, c_1, c_2, c_3, c_4), centroid);

  vecScalarMul(A1, n_1, n_1);
  vecScalarMul(A2, n_2, n_2);
  vecScalarMul(A3, n_3, n_3);
  vecScalarMul(A4, n_4, n_4);
  std::fill_n(normal, 3, 0.0);
  normal = vecScalarMul(F1 / *area, maia::math::vecAdd<3>(normal, n_1, n_2, n_3, n_4), normal);
  return;
}

// -------------------------------------------------------------------------------

/** \brief computes area, centroid and normal of a 5-point polygon given by the points abcde
 *
 *	normal is -((b-a) x (c-a)) -> careful!
 *
 * order of the points should be in the mathematically correct sense of rotation if the normal
 * defined by -((b-a)x(c-a)) points in the computational (fluid) domain
 *
 * \author Claudia Guenther, March 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::computePoly5(MFloat* a, MFloat* b, MFloat* c, MFloat* d, MFloat* e, MFloat* area,
                                              MFloat* centroid, MFloat* normal) {
  TRACE();

  MFloat c_1[3] = {0, 0, 0};
  MFloat c_2[3] = {0, 0, 0};
  MFloat c_3[3] = {0, 0, 0};
  MFloat c_4[3] = {0, 0, 0};
  MFloat c_5[3] = {0, 0, 0};
  MFloat n_1[3] = {0, 0, 0};
  MFloat n_2[3] = {0, 0, 0};
  MFloat n_3[3] = {0, 0, 0};
  MFloat n_4[3] = {0, 0, 0};
  MFloat n_5[3] = {0, 0, 0};
  MFloat M[3] = {0, 0, 0};
  MFloat A1, A2, A3, A4, A5;

  maia::math::vecAvg<3>(M, a, b, c, d, e);
  computePoly3(a, b, M, &A1, c_1, n_1);
  computePoly3(b, c, M, &A2, c_2, n_2);
  computePoly3(c, d, M, &A3, c_3, n_3);
  computePoly3(d, e, M, &A4, c_4, n_4);
  computePoly3(e, a, M, &A5, c_5, n_5);

  *area = A1 + A2 + A3 + A4 + A5;
  vecScalarMul(A1, c_1, c_1);
  vecScalarMul(A2, c_2, c_2);
  vecScalarMul(A3, c_3, c_3);
  vecScalarMul(A4, c_4, c_4);
  vecScalarMul(A5, c_5, c_5);
  std::fill_n(centroid, 3, 0.0);
  centroid = vecScalarMul(F1 / *area, maia::math::vecAdd<3>(centroid, c_1, c_2, c_3, c_4, c_5), centroid);

  vecScalarMul(A1, n_1, n_1);
  vecScalarMul(A2, n_2, n_2);
  vecScalarMul(A3, n_3, n_3);
  vecScalarMul(A4, n_4, n_4);
  vecScalarMul(A5, n_5, n_5);
  std::fill_n(normal, 3, 0.0);
  normal = vecScalarMul(F1 / *area, maia::math::vecAdd<3>(normal, n_1, n_2, n_3, n_4, n_5), normal);
  return;
}


// -------------------------------------------------------------------------------

/** \brief computes area, centroid and normal of a 6-point polygon given by the points abcdef
 *
 *	normal is -((b-a) x (c-a)) -> careful!
 *
 * order of the points should be in the mathematically correct sense of rotation if the normal
 * defined by -((b-a)x(c-a)) points in the computational (fluid) domain
 *
 * \author Claudia Guenther, March 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::computePoly6(MFloat* a, MFloat* b, MFloat* c, MFloat* d, MFloat* e, MFloat* f,
                                              MFloat* area, MFloat* centroid, MFloat* normal) {
  TRACE();

  MFloat c_1[3] = {0, 0, 0};
  MFloat c_2[3] = {0, 0, 0};
  MFloat c_3[3] = {0, 0, 0};
  MFloat c_4[3] = {0, 0, 0};
  MFloat c_5[3] = {0, 0, 0};
  MFloat c_6[3] = {0, 0, 0};
  MFloat n_1[3] = {0, 0, 0};
  MFloat n_2[3] = {0, 0, 0};
  MFloat n_3[3] = {0, 0, 0};
  MFloat n_4[3] = {0, 0, 0};
  MFloat n_5[3] = {0, 0, 0};
  MFloat n_6[3] = {0, 0, 0};
  MFloat M[3] = {0, 0, 0};
  MFloat A1, A2, A3, A4, A5, A6;

  maia::math::vecAvg<3>(M, a, b, c, d, e, f);
  computePoly3(a, b, M, &A1, c_1, n_1);
  computePoly3(b, c, M, &A2, c_2, n_2);
  computePoly3(c, d, M, &A3, c_3, n_3);
  computePoly3(d, e, M, &A4, c_4, n_4);
  computePoly3(e, f, M, &A5, c_5, n_5);
  computePoly3(f, a, M, &A6, c_6, n_6);

  *area = A1 + A2 + A3 + A4 + A5 + A6;
  vecScalarMul(A1, c_1, c_1);
  vecScalarMul(A2, c_2, c_2);
  vecScalarMul(A3, c_3, c_3);
  vecScalarMul(A4, c_4, c_4);
  vecScalarMul(A5, c_5, c_5);
  vecScalarMul(A6, c_6, c_6);
  std::fill_n(centroid, 3, 0.0);
  centroid = vecScalarMul(F1 / *area, maia::math::vecAdd<3>(centroid, c_1, c_2, c_3, c_4, c_5, c_6), centroid);

  vecScalarMul(A1, n_1, n_1);
  vecScalarMul(A2, n_2, n_2);
  vecScalarMul(A3, n_3, n_3);
  vecScalarMul(A4, n_4, n_4);
  vecScalarMul(A5, n_5, n_5);
  vecScalarMul(A6, n_6, n_6);
  std::fill_n(normal, 3, 0.0);
  normal = vecScalarMul(F1 / *area, maia::math::vecAdd<3>(normal, n_1, n_2, n_3, n_4, n_5, n_6), normal);
  return;
}

// -------------------------------------------------------------------------------

/** \brief computes the volume and centroid of a tetrahedron given by the points abcd
 *
 * \author Claudia Guenther, March 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::computeTetra(MFloat* a, MFloat* b, MFloat* c, MFloat* d, MFloat* volume,
                                              MFloat* centroid) {
  TRACE();

  MFloat dummy_1[3] = {0, 0, 0};
  MFloat dummy_2[3] = {0, 0, 0};
  MFloat dummy_3[3] = {0, 0, 0};
  MFloat dummy_4[3] = {0, 0, 0};

  vecSub(b, a, dummy_1);
  vecSub(c, a, dummy_2);
  vecSub(d, a, dummy_3);

  maia::math::cross(dummy_1, dummy_2, dummy_4);
  *volume = F1B6 * abs(inner_product(dummy_4, dummy_4 + 3, dummy_3, 0.0));
  std::fill_n(dummy_4, 3, 0.0);
  centroid = vecScalarMul(F1B4, maia::math::vecAdd<3>(dummy_4, a, b, c, d), centroid);
  return;
}

// -------------------------------------------------------------------------------

/** \brief computes the volume and centroid of a pyramid build of a base face (area, center base_centroid) and a point M
 *
 * \author Claudia Guenther, March 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::computePyra(MFloat* area, MFloat* base_centroid, MFloat* normal, MFloat* M,
                                             MFloat* volume, MFloat* centroid) {
  TRACE();

  MFloat h_vec[3] = {0, 0, 0};
  MFloat dummy_2[3] = {0, 0, 0};

  vecSub(M, base_centroid, h_vec);
  std::fill_n(centroid, 3, 0.0);
  centroid = maia::math::vecAdd<3>(centroid, vecScalarMul(F1B4, h_vec, dummy_2), base_centroid);
  *volume = F1B3 * (*area) * abs(inner_product(h_vec, h_vec + 3, normal, 0.0));
  return;
}

// -------------------------------------------------------------------------------

/** \brief corrects area and centroid of a cut face; area_0 and centroid_0 correspond to the original, non-cut face
 *
 *	returns area and centroid of the "other" part of the original cartesian face;
 * input parameters: area and centroid of the first part of the cut face
 *										area0 and centroid0 of the non-cut face
 * return parameters: area and centroid of the second part of the cut face (overwritten)
 *
 * \author Claudia Guenther, March 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::correctFace(MFloat* area, MFloat* centroid, MFloat* area_0, MFloat* centroid_0) {
  TRACE();

  MFloat dummy_1[3] = {0, 0, 0};
  MFloat dummy_2[3] = {0, 0, 0};
  vecSub(vecScalarMul(*area_0, centroid_0, dummy_1), vecScalarMul(*area, centroid, dummy_2), centroid);
  *area = *area_0 - *area;
  vecScalarMul(F1 / *area, centroid, centroid);
  return;
}

// -------------------------------------------------------------------------------

/** \brief corrects volume and centroid of a cut cell; volume_0 and centroid_0 correspond to the original, non-cut cell
 *
 *	returns volume and centroid of the "other" part of the original cartesian cell;
 * input parameters: volume and centroid of the first part of the cut cell
 *										volume0 and centroid0 of the non-cut cell
 * return parameters: volume and centroid of the second part of the cut cell (overwritten)
 *
 * \author Claudia Guenther, March 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::correctCell(MFloat* volume, MFloat* centroid, MFloat* volume_0, MFloat* centroid_0) {
  TRACE();

  MFloat dummy_1[3] = {0, 0, 0};
  MFloat dummy_2[3] = {0, 0, 0};
  vecSub(vecScalarMul(*volume_0, centroid_0, dummy_1), vecScalarMul(*volume, centroid, dummy_2), centroid);
  *volume = *volume_0 - *volume;
  vecScalarMul(F1 / *volume, centroid, centroid);
  return;
}

// -------------------------------------------------------------------------------

/** \brief returns the input vector pointing in the opposite direction
 *
 * \author Claudia Guenther, March 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::correctNormal(MFloat* normal) {
  TRACE();

  vecScalarMul(-F1, normal, normal);
  return;
}

// ---------------------------------------------------------------------------------
// -----------------	other help routines for cut cell generation  -----------------
// ---------------------------------------------------------------------------------

/** \brief corrects cells located on interface bcId/wall such that bcId plane is conserved
 *
 *	needs the normal of the bcId surface (should be planar in original geometry description!) and
 * a point located in this plane (basePoint).
 *
 * cutCells have to be previously computed with createCutFaceMGC
 *
 * method is based on createCutFaceMGC
 * if volume of corrected cells should be decreased, variables 'inside' has to be changed to false (see initialization)
 *
 * \author Claudia Guenther, September 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::correctInflowBoundary(MInt bcId, MFloat*& meanNormal, MFloat*& basePoint) {
  TRACE();

  static constexpr MInt edgeCode[24] = {8, 10, 0, 4, 9, 11, 1, 5, 2, 6, 8, 9, 3, 7, 10, 11, 0, 1, 2, 3, 4, 5, 6, 7};
  static constexpr MInt faceCode[24] = {0, 4, 1, 4, 2, 4, 3, 4, 0, 5, 1, 5, 2, 5, 3, 5, 0, 2, 1, 2, 0, 3, 1, 3};
  static constexpr MInt cornerIndices[8][3] = {{-1, -1, -1}, {1, -1, -1}, {-1, 1, -1}, {1, 1, -1},
                                               {-1, -1, 1},  {1, -1, 1},  {-1, 1, 1},  {1, 1, 1}};
  static constexpr MInt cornersMCtoSOLVER[8] = {2, 0, 1, 3, 6, 4, 5, 7};
  static constexpr MInt cornersSOLVERtoMC[8] = {1, 2, 0, 3, 5, 6, 4, 7};
  static constexpr MInt edgesMCtoSOLVER[12] = {0, 2, 1, 3, 4, 6, 5, 7, 10, 8, 9, 11};
  static constexpr MInt facesMCtoSOLVER[6] = {0, 2, 1, 3, 4, 5};
  MFloat target[6] = {0, 0, 0, 0, 0, 0};
  unsigned char outcode_MC = 0;
  MInt noCells = m_bndryCells->size();
  MInt cellId;
  MFloat gridCellVolume;
  MFloat corner[8][3] = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}};
  MInt currentCase;
  MBool currentOutcode = false;
  MInt nghbrId;
  MInt sideId;
  MInt otherSideId;
  MInt srfcId;
  MInt spaceId;
  MFloat* faceCentroid[6];
  MFloatScratchSpace faceCentroid_scratch(nDim * 6, AT_, "faceCentroid_scratch");
  for(MInt i = 0; i < 6; i++)
    faceCentroid[i] = &faceCentroid_scratch.p[i * nDim];
  MFloat* faceCentroid_0[6];
  MFloatScratchSpace faceCentroid_0_scratch(nDim * 6, AT_, "faceCentroid_0_scratch");
  for(MInt i = 0; i < 6; i++)
    faceCentroid_0[i] = &faceCentroid_0_scratch.p[i * nDim];
  MFloat* normal[6];
  MFloatScratchSpace normal_scratch(nDim * 6, AT_, "normal_scratch");
  for(MInt i = 0; i < 6; i++)
    normal[i] = &normal_scratch.p[i * nDim];
  const MInt maxNoPyramids = 8;
  MFloat* pyraCentroid[maxNoPyramids];
  MFloatScratchSpace pyraCentroid_scratch(nDim * maxNoPyramids, AT_, "pyraCentroid_scratch");
  for(MInt i = 0; i < maxNoPyramids; i++)
    pyraCentroid[i] = &pyraCentroid_scratch.p[i * nDim];
  MFloatScratchSpace faceVolume_scratch(F2 * m_noDirs, AT_, "faceVolume_scratch");
  MFloatScratchSpace pyraVolume_scratch(2 * m_noDirs + 2, AT_, "pyraVolume_scratch");
  MFloatScratchSpace faceVolume_0_scratch(F2 * m_noDirs, AT_, "faceVolume_0_scratch");
  MFloat* faceVolume = faceVolume_scratch.getPointer();
  MFloat* pyraVolume = pyraVolume_scratch.getPointer();
  MFloat* faceVolume_0 = faceVolume_0_scratch.getPointer();
  MInt currentSubCase;
  MFloat* p_0;
  MFloat* p_1;
  MFloat* p_2;
  MFloat* p_3;
  MFloat* p_0s;
  MFloat* p_1s;
  MFloat* p_2s;
  MFloat* p_3s;
  MFloat* p_0ss;
  MFloat* p_1ss;
  MFloat* p_2ss;
  MFloat* p_3ss;
  MInt cutDummy;
  MInt face1;
  MInt face2;
  MInt face3;
  MInt face4;
  MInt face5;
  MInt face6;
  MInt* facepointers[6] = {&face1, &face2, &face3, &face4, &face5, &face6};
  MInt cutPoints[12] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
  MFloatScratchSpace normalVec_c_scratch(nDim, AT_, "normalVec_c_scratch");
  MFloat* normalVec_c = normalVec_c_scratch.getPointer();
  MFloat area_c;
  MFloatScratchSpace coordinates_c_scratch(nDim, AT_, "coordinates_c_scratch");
  MFloat* coordinates_c = coordinates_c_scratch.getPointer();
  MFloat volume_C;
  MFloatScratchSpace coordinates_Cell_scratch(nDim, AT_, "coordinates_Cell_scratch");
  MFloat* coordinates_Cell = coordinates_Cell_scratch.getPointer();
  MFloat M[3] = {0, 0, 0};
  MFloat dummy_1[3] = {0, 0, 0};
  MFloat dummy_2[3] = {0, 0, 0};
  MFloat dummy_3[3] = {0, 0, 0};
  MBool nfs_cur[6] = {false, false, false, false, false, false};
  MInt noFaces;
  MBool cornerCell = false;
  MFloat normalDiff = F0;
  MFloat normalEps = 1e-4; // works, but is no sophisticated value :)
  const MInt maxNoEdges = 800;
  MFloatPointerScratchSpace featureEdges_scratch(maxNoEdges, AT_, "featureEdges_scratch");
  MFloat** featureEdges = featureEdges_scratch.getPointer();
  const MInt maxNoIntersectPointsPerFace = 10;
  MFloatPointerPointerScratchSpace intersectionPoints_scratchPP(2 * nDim, AT_, "intersectionPoints_scratchPP");
  MFloatPointerScratchSpace intersectionPoints_scratchP(2 * nDim * maxNoIntersectPointsPerFace, AT_,
                                                        "intersectionPoints_scratchP");
  MFloatScratchSpace intersectionPoints_scratch(2 * nDim * maxNoIntersectPointsPerFace * nDim, AT_,
                                                "intersectionPoints_scratch");
  MFloat*** intersectionPoints = intersectionPoints_scratchPP.getPointer();
  for(MInt i = 0; i < 2 * nDim; i++) {
    intersectionPoints[i] = &intersectionPoints_scratchP.p[i * maxNoIntersectPointsPerFace];
    for(MInt j = 0; j < maxNoIntersectPointsPerFace; j++) {
      intersectionPoints[i][j] = &intersectionPoints_scratch.p[i * maxNoIntersectPointsPerFace * nDim + j * nDim];
    }
  }
  MInt noWallNodes, noInflowNodes, noFeatureEdges;
  MInt noIntersectionPoints[6] = {0, 0, 0, 0, 0, 0};
  const MInt maxNoNodes =
      1000; // might be necessary to increase for extremely detailed .stl geometries! See error output below
  MIntScratchSpace wallNodes_scratch(maxNoNodes, AT_, "wallNodes_scratch");
  MIntScratchSpace inflowNodes_scratch(maxNoNodes, AT_, "inflowNodes_scratch");
  MInt* wallNodes = wallNodes_scratch.getPointer();
  MInt* inflowNodes = inflowNodes_scratch.getPointer();
  MFloatPointerScratchSpace target2_scratchP(nDim, AT_, "target2_scratchP");
  MFloat** target2 = target2_scratchP.getPointer();
  MFloatScratchSpace target2_scratch(nDim * nDim, AT_, "target2_scratch");
  for(MInt i = 0; i < nDim; i++)
    target2[i] = &target2_scratch.p[i * nDim];
  MInt index1, index2, index3;
  MInt pointCount;
  MInt pointIndices[2] = {0, 0};
  MInt faceStart;
  MFloat newArea;
  MFloat* points1[8];
  MInt noPoints1;
  MFloat* points2[8];
  MInt noPoints2;
  noPoints1 = 0;
  noPoints2 = 0;
  MIntScratchSpace facePoints_scratch(12, AT_, "facePoints_scratch");
  MInt* facePoints = facePoints_scratch.getPointer();
  MFloat* points[6];
  MFloatScratchSpace points_scratch(6 * nDim, AT_, "points_scratch");
  for(MInt i = 0; i < 6; i++) {
    points[i] = &points_scratch.p[i * nDim];
  }
  MIntScratchSpace nextFaces_scratch(2 * nDim, AT_, "nextFaces_scratch");
  MInt* nextFaces = nextFaces_scratch.getPointer();
  MFloat area1, area2;
  MFloatScratchSpace normal1_scratch(nDim, AT_, "normal1_scratch");
  MFloatScratchSpace normal2_scratch(nDim, AT_, "normal2_scratch");
  MFloatScratchSpace centroid1_scratch(nDim, AT_, "centroid1_scratch");
  MFloatScratchSpace centroid2_scratch(nDim, AT_, "centroid2_scratch");
  MFloat* normal1 = normal1_scratch.getPointer();
  MFloat* normal2 = normal2_scratch.getPointer();
  MFloat* centroid1 = centroid1_scratch.getPointer();
  MFloat* centroid2 = centroid2_scratch.getPointer();
  MInt bcId1 = 0;
  MInt bcId2 = 0;
  MInt bcWall = 0;
  MInt bcInlet = 0;
  MInt noUnusedCutPoints;
  MIntScratchSpace unusedCutPoints_scratch(2, AT_, "unusedCutPoints_scratch");
  MInt* unusedCutPoints = unusedCutPoints_scratch.getPointer();
  MInt& iter = m_static_correctInflowBoundary_iter;
  stringstream fileName2;
  fileName2 << "cutSurface_newParts" << domainId() << "_" << iter++ << ".stl";
  ofstream ofl;
  ofl.open((fileName2.str()).c_str(), ofstream::trunc);
  MBool secondHalf = false;
  MInt cutEdge, cutEdgeNghbr;
  MInt cutFace1, cutFace2, cutFaceNghbr1, cutFaceNghbr2;
  MFloat delta_IP;
  MIntScratchSpace levelSetCornerSigns(8, AT_, "levelSetCornerSigns");
  MBool inside = true;
  if(bcId < 3000) // special treatment for bc30040 (cube testcase)
    inside = false;

  if(ofl) {
    // set fixed floating point output
    ofl.setf(ios::fixed);
    ofl.precision(7);

    ofl << "solid cutsurface " << endl;

    //-----------------------------------------

    // 1) find cornerCells (normal differs from mean normal, inflow BC)
    for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
      noUnusedCutPoints = 0;
      cornerCell = false;
      cellId = m_bndryCells->a[bndryId].m_cellId;
      if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
          if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == bcId) {
            normalDiff = POW2(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[0] - meanNormal[0])
                         + POW2(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[1] - meanNormal[1])
                         + POW2(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[2] - meanNormal[2]);
            if(normalDiff > normalEps) {
              cornerCell = true;
            }
          }
        }
      }

      // process Corner Cells
      if(cornerCell) {
        gridCellVolume = m_solver->grid().gridCellVolume(m_solver->a_level(cellId));
        outcode_MC = 0;
        volume_C = 0;
        coordinates_Cell[0] = 0;
        coordinates_Cell[1] = 0;
        coordinates_Cell[2] = 0;
        noFaces = 0;

        for(MInt cutPoint = 0; cutPoint < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cutPoint++) {
          cutPoints[m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cutPoint]] = cutPoint;
        }

        for(MInt i = 0; i < nDim; i++) {
          target[i] = m_solver->a_coordinate(cellId, i)
                      - F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId)) * 1.05;
          target[i + nDim] = m_solver->a_coordinate(cellId, i)
                             + F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId)) * 1.05;
          faceVolume[2 * i] = POW2(m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId)));
          faceVolume[2 * i + 1] = faceVolume[2 * i];
          for(MInt j = 0; j < 3; j++) {
            faceCentroid[2 * i][j] = m_solver->a_coordinate(cellId, j);
            faceCentroid[2 * i + 1][j] = m_solver->a_coordinate(cellId, j);
          }
          faceCentroid[2 * i][i] -= F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId));
          faceCentroid[2 * i + 1][i] += F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId));
        }

        // 1. get all triangles in currentCell (target)
        std::vector<MInt> nodeList;
        m_solver->m_geometry->getIntersectionElements(target, nodeList);
        const MInt noNodes = nodeList.size();
        if(noNodes > maxNoNodes) {
          stringstream errorMessage;
          errorMessage << "Error in FvBndryCndXD::correctInflowBoundary - noNodes = " << noNodes
                       << " > maxNoNodes = " << maxNoNodes << ". Please increase maxNoNodes! ";
          mTerm(1, AT_, errorMessage.str());
        }

        // 2. get In/Outcode of the corners of the voxel
        // 0 -> Corner is outside Fluid Domain
        // 1 -> Corner is inside Fluid Domain or on Boundary
        for(MInt j = 0; j < 8; j++) {
          for(MInt dim = 0; dim < nDim; dim++) {
            corner[j][dim] = m_solver->a_coordinate(cellId, dim)
                             + cornerIndices[j][dim] * F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId));
          }
          currentOutcode = !((MBool)m_solver->m_geometry->pointIsInside2(corner[j]));
          if(currentOutcode) outcode_MC = outcode_MC | (1 << cornersSOLVERtoMC[j]);
        }

        // 3. Determine Case and check if case is implemented and if case is unambiguous
        currentCase = (MInt)cases[outcode_MC][0];
        currentSubCase = (MInt)cases[outcode_MC][1];
        if(!(m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints == caseCutPoints[currentCase])) {
          cerr << "FvBndryCndXD::correctInflowBoundary: Detected special inlet correction cell! cellId " << cellId
               << ", bndryId: " << bndryId << " cutPointsTheory: " << caseCutPoints[currentCase]
               << " actual Cut Points: " << m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints
               << " case: " << currentCase << endl;
        }
        if(!caseStatesSTL[currentCase][0]) {
          cerr << "FvBndryCndXD::correctInflowBoundary - Error: Case not implemented: " << currentCase << endl;
          continue;
        }


        // 2) Make a list of Wall-triangles and one of Inflow-triangles
        getSortedElements(nodeList, noWallNodes, wallNodes, noInflowNodes, inflowNodes, bcId);
        if(noWallNodes > 0)
          bcWall = m_solver->m_geometry->elements[wallNodes[0]].m_bndCndId;
        else {
          stringstream fileName;
          fileName << cellId << ".stl";
          writeStlFileOfCell(cellId, (fileName.str()).c_str());
          plotEdges(noFeatureEdges, featureEdges);
          plotIntersectionPoints(noIntersectionPoints, intersectionPoints);
          stringstream errorMessage;
          errorMessage << "cell " << cellId << " has no wall nodes!";
          mTerm(1, AT_, errorMessage.str());
        }

        if(noInflowNodes > 0)
          bcInlet = m_solver->m_geometry->elements[inflowNodes[0]].m_bndCndId;
        else {
          stringstream errorMessage;
          errorMessage << " cell " << cellId << " has no inflow nodes!";
          mTerm(1, AT_, errorMessage.str());
        }

        // 3) Get feature Edges (Edges between Wall triangles and Inflow triangles) as a list of start/endpoints
        getFeatureEdges(noFeatureEdges, featureEdges, noWallNodes, wallNodes, meanNormal, basePoint);

        // 4) Get Intersection points of featureEdges with Voxel faces and store them
        for(MInt face = 0; face < 6; face++) {
          index1 = face / 2;
          index2 = (index1 + 1) % 3;
          index3 = (index2 + 1) % 3;
          for(MInt i = 0; i < 3; i++)
            for(MInt j = 0; j < 3; j++)
              target2[i][j] = faceCentroid[face][j];

          target2[0][index2] -= F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId));
          target2[0][index3] -= F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId));
          target2[1][index2] += F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId));
          target2[1][index3] -= F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId));
          target2[2][index2] -= F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId));
          target2[2][index3] += F1B2 * m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId));


          getIntersectionPoints(target2, featureEdges, noFeatureEdges, (MInt)(face / 2), intersectionPoints[face],
                                noIntersectionPoints[face]);
        }

        // 5) Compute cornerCells as usual - cells with multiple cut faces can not be corrected!
        if(!caseStatesSTL[currentCase][1]) {
          stringstream errorMessage;
          errorMessage << " Case " << currentCase << " not allowed for Inflow/Outflow boundary correction!";
          mTerm(1, AT_, errorMessage.str());
        } else {
          m_bndryCells->a[bndryId].m_noSrfcs = 1;
          secondHalf = false;
          switch(currentCase) {
            case 0:
              cerr << "FvBndryCndXD::correctInflowBoundary - Error: Cell is not a boundary cell!" << endl;
              cerr << "CellId: " << cellId << "   BndryId: " << bndryId << endl;
              break;
            case 1: {
              // cerr << "Case 1 detected. Starting Cutface computation..." << endl;
              for(MInt face = 0; face < 6; face++) {
                nfs_cur[face] = nfs1[currentSubCase][face];
              }
              p_0 = corner[cornersMCtoSOLVER[tiling1STL[currentSubCase][0]]];
              noFaces = 3;
              if(currentSubCase < 8) { // 1 Point is inside, 5 Points are outside
              } else {                 // 1 Point is outside, 5 Points are inside
                for(MInt i = 0; i < 6; i++) {
                  faceVolume_0[i] = faceVolume[i];
                  for(MInt j = 0; j < 3; j++) {
                    faceCentroid_0[i][j] = faceCentroid[i][j];
                  }
                }
              }
              cutDummy = edgesMCtoSOLVER[tiling1STL[currentSubCase][1]];
              p_1 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling1STL[currentSubCase][2]];
              p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling1STL[currentSubCase][3]];
              p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              face1 = facesMCtoSOLVER[tiling1STL[currentSubCase][4]];
              face2 = facesMCtoSOLVER[tiling1STL[currentSubCase][5]];
              face3 = facesMCtoSOLVER[tiling1STL[currentSubCase][6]];

              // identify unused (=special) cut points
              for(MInt cp = 0; cp < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cp++) {
                if(p_1 == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_2 == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_3 == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]) {
                  continue;
                } else {
                  unusedCutPoints[noUnusedCutPoints++] = cp;
                }
              }

              for(MInt face = 0; face < noFaces; face++) {
                facePoints[face] = -1;
                facePoints[2 * face] = -1;
                nextFaces[face] = -1;
              }
              nextFaces[face1] = face3;
              nextFaces[face2] = face1;
              nextFaces[face3] = face2;
              facePoints[2 * face1] = 2;
              facePoints[2 * face1 + 1] = 0;
              facePoints[2 * face2] = 1;
              facePoints[2 * face2 + 1] = 2;
              facePoints[2 * face3] = 0;
              facePoints[2 * face3 + 1] = 1;
              for(MInt i = 0; i < 3; i++) {
                points[0][i] = p_1[i];
                points[1][i] = p_2[i];
                points[2][i] = p_3[i];
              }

              computeTri(p_0, p_1, p_3, &faceVolume[face1], faceCentroid[face1], normal[face1]);
              computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2], normal[face2]);
              computeTri(p_0, p_2, p_1, &faceVolume[face3], faceCentroid[face3], normal[face3]);

              computePoly3(p_1, p_2, p_3, &area_c, coordinates_c, normalVec_c);

              maia::math::vecAvg<3>(M, p_0, p_1, p_2, p_3);

              computeTetra(p_0, p_1, p_2, p_3, &volume_C, coordinates_Cell);

              if(currentSubCase >= 8) {
                secondHalf = true;
              }

              m_bndryCells->a[bndryId].m_volume = volume_C;
              // create 1 Cut face
              m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
                m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
                m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
              }
            } break;
            case 2: {
              // cerr << "Case 2 detected. Starting Cutface computation..." << endl;
              for(MInt face = 0; face < 6; face++) {
                nfs_cur[face] = nfs2[currentSubCase][face];
              }
              noFaces = 4;
              p_0 = corner[cornersMCtoSOLVER[tiling2STL[currentSubCase][0]]];
              p_0s = corner[cornersMCtoSOLVER[tiling2STL[currentSubCase][1]]];
              if(currentSubCase < 12) { // 2 Points are inside, 4 Points are outside
              } else {                  // 2 Points are outside, 4 Points are inside
                for(MInt i = 0; i < 6; i++) {
                  faceVolume_0[i] = faceVolume[i];
                  for(MInt j = 0; j < 3; j++) {
                    faceCentroid_0[i][j] = faceCentroid[i][j];
                  }
                }
              }

              cutDummy = edgesMCtoSOLVER[tiling2STL[currentSubCase][2]];
              p_3 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling2STL[currentSubCase][3]];
              p_2 = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling2STL[currentSubCase][4]];
              p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling2STL[currentSubCase][5]];
              p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              face1 = facesMCtoSOLVER[tiling2STL[currentSubCase][6]];
              face2 = facesMCtoSOLVER[tiling2STL[currentSubCase][7]];
              face3 = facesMCtoSOLVER[tiling2STL[currentSubCase][8]];
              face4 = facesMCtoSOLVER[tiling2STL[currentSubCase][9]];

              // identify unused (=special) cut points
              for(MInt cp = 0; cp < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cp++) {
                if(p_3 == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_2 == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_3s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_2s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]) {
                  continue;
                } else {
                  unusedCutPoints[noUnusedCutPoints++] = cp;
                }
              }

              for(MInt face = 0; face < noFaces; face++) {
                facePoints[face] = -1;
                facePoints[2 * face] = -1;
                nextFaces[face] = -1;
              }
              nextFaces[face1] = face3;
              nextFaces[face2] = face1;
              nextFaces[face3] = face4;
              nextFaces[face4] = face2;
              facePoints[2 * face1] = 0;
              facePoints[2 * face1 + 1] = 1;
              facePoints[2 * face2] = 3;
              facePoints[2 * face2 + 1] = 0;
              facePoints[2 * face3] = 1;
              facePoints[2 * face3 + 1] = 2;
              facePoints[2 * face4] = 2;
              facePoints[2 * face4 + 1] = 3;
              for(MInt i = 0; i < 3; i++) {
                points[0][i] = p_3[i];
                points[1][i] = p_3s[i];
                points[2][i] = p_2s[i];
                points[3][i] = p_2[i];
              }

              computeTri(p_0, p_3, p_2, &faceVolume[face2], faceCentroid[face2], normal[face2]);
              computeTri(p_0s, p_3s, p_2s, &faceVolume[face3], faceCentroid[face3], normal[face3]);
              computeTrapez(p_0, p_0s, p_3s, p_3, &faceVolume[face1], faceCentroid[face1], normal[face1]);
              computeTrapez(p_2, p_2s, p_0s, p_0, &faceVolume[face4], faceCentroid[face4], normal[face4]);

              computePoly4(p_3, p_3s, p_2s, p_2, &area_c, coordinates_c, normalVec_c);

              maia::math::vecAvg<3>(M, p_0, p_0s, p_2, p_2s, p_3, p_3s);

              for(MInt i = 0; i < 4; i++) {
                computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                            &pyraVolume[i], pyraCentroid[i]);
              }
              computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[4], pyraCentroid[4]);
              for(MInt i = 0; i < 5; i++) {
                volume_C += pyraVolume[i];
                maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
              }
              vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

              if(currentSubCase >= 12) {
                secondHalf = true;
              }

              m_bndryCells->a[bndryId].m_volume = volume_C;
              // create 1 Cut face
              m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
                m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
                m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
              }
            } break;
            case 5: {
              // cerr << "Case 5 detected. Starting Cutface computation..." << endl;
              for(MInt face = 0; face < 6; face++) {
                nfs_cur[face] = nfs5[currentSubCase][face];
              }
              noFaces = 5;
              p_0 = corner[cornersMCtoSOLVER[tiling5STL[currentSubCase][0]]];
              p_1 = corner[cornersMCtoSOLVER[tiling5STL[currentSubCase][1]]];
              p_2 = corner[cornersMCtoSOLVER[tiling5STL[currentSubCase][2]]];
              if(currentSubCase < 24) { // 3 Points are inside, 5 Points are outside
              } else {                  // 3 Points are outside, 5 Points are inside
                for(MInt i = 0; i < 6; i++) {
                  faceVolume_0[i] = faceVolume[i];
                  for(MInt j = 0; j < 3; j++) {
                    faceCentroid_0[i][j] = faceCentroid[i][j];
                  }
                }
              }

              cutDummy = edgesMCtoSOLVER[tiling5STL[currentSubCase][3]];
              p_0s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling5STL[currentSubCase][4]];
              p_0ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling5STL[currentSubCase][5]];
              p_1s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling5STL[currentSubCase][6]];
              p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling5STL[currentSubCase][7]];
              p_2ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              face1 = facesMCtoSOLVER[tiling5STL[currentSubCase][8]];
              face2 = facesMCtoSOLVER[tiling5STL[currentSubCase][9]];
              face3 = facesMCtoSOLVER[tiling5STL[currentSubCase][10]];
              face4 = facesMCtoSOLVER[tiling5STL[currentSubCase][11]];
              face5 = facesMCtoSOLVER[tiling5STL[currentSubCase][12]];

              // identify unused (=special) cut points
              for(MInt cp = 0; cp < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cp++) {
                if(p_0s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_0ss == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_1s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_2s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_2ss == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]) {
                  continue;
                } else {
                  unusedCutPoints[noUnusedCutPoints++] = cp;
                }
              }

              for(MInt face = 0; face < noFaces; face++) {
                facePoints[face] = -1;
                facePoints[2 * face] = -1;
                nextFaces[face] = -1;
              }
              nextFaces[face1] = face2;
              nextFaces[face2] = face3;
              nextFaces[face3] = face4;
              nextFaces[face4] = face5;
              nextFaces[face5] = face1;
              facePoints[2 * face1] = 3;
              facePoints[2 * face1 + 1] = 4;
              facePoints[2 * face2] = 4;
              facePoints[2 * face2 + 1] = 0;
              facePoints[2 * face3] = 0;
              facePoints[2 * face3 + 1] = 1;
              facePoints[2 * face4] = 1;
              facePoints[2 * face4 + 1] = 2;
              facePoints[2 * face5] = 2;
              facePoints[2 * face5 + 1] = 3;
              for(MInt i = 0; i < 3; i++) {
                points[0][i] = p_0s[i];
                points[1][i] = p_1s[i];
                points[2][i] = p_2s[i];
                points[3][i] = p_2ss[i];
                points[4][i] = p_0ss[i];
              }

              computePoly5(p_0, p_0ss, p_2ss, p_2, p_1, &faceVolume[face1], faceCentroid[face1], normal[face1]);
              computeTri(p_0ss, p_0, p_0s, &faceVolume[face2], faceCentroid[face2], normal[face2]);
              computeTrapez(p_0, p_1, p_1s, p_0s, &faceVolume[face3], faceCentroid[face3], normal[face3]);
              computeTrapez(p_1, p_1s, p_2s, p_2, &faceVolume[face4], faceCentroid[face4], normal[face4]);
              computeTri(p_2s, p_2, p_2ss, &faceVolume[face5], faceCentroid[face5], normal[face5]);

              computePoly5(p_0s, p_1s, p_2s, p_2ss, p_0ss, &area_c, coordinates_c, normalVec_c);

              maia::math::vecAvg<3>(M, p_0, p_1, p_2, p_0s, p_1s, p_2s, p_0ss, p_2ss);

              for(MInt i = 0; i < 5; i++) {
                computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                            &pyraVolume[i], pyraCentroid[i]);
              }
              computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[5], pyraCentroid[5]);
              for(MInt i = 0; i < 6; i++) {
                volume_C += pyraVolume[i];
                maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
              }
              vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

              if(currentSubCase >= 24) {
                secondHalf = true;
              }

              m_bndryCells->a[bndryId].m_volume = volume_C;
              // 	  create 1 Cut face
              m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
                m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
                m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
              }
            } break;
            case 8: {
              // cerr << "Case 8 detected. Starting Cutface computation..." << endl;
              for(MInt face = 0; face < 6; face++) {
                nfs_cur[face] = nfs8[currentSubCase][face];
              }
              noFaces = 4;
              p_0 = corner[cornersMCtoSOLVER[tiling8STL[currentSubCase][0]]];
              p_1 = corner[cornersMCtoSOLVER[tiling8STL[currentSubCase][1]]];
              p_2 = corner[cornersMCtoSOLVER[tiling8STL[currentSubCase][2]]];
              p_3 = corner[cornersMCtoSOLVER[tiling8STL[currentSubCase][3]]];

              cutDummy = edgesMCtoSOLVER[tiling8STL[currentSubCase][4]];
              p_0s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling8STL[currentSubCase][5]];
              p_1s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling8STL[currentSubCase][6]];
              p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling8STL[currentSubCase][7]];
              p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              face5 = facesMCtoSOLVER[tiling8STL[currentSubCase][8]];
              face1 = facesMCtoSOLVER[tiling8STL[currentSubCase][9]];
              face2 = facesMCtoSOLVER[tiling8STL[currentSubCase][10]];
              face3 = facesMCtoSOLVER[tiling8STL[currentSubCase][11]];
              face4 = facesMCtoSOLVER[tiling8STL[currentSubCase][12]];

              // identify unused (=special) cut points
              for(MInt cp = 0; cp < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cp++) {
                if(p_0s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_1s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_2s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_3s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]) {
                  continue;
                } else {
                  unusedCutPoints[noUnusedCutPoints++] = cp;
                }
              }

              for(MInt face = 0; face < noFaces; face++) {
                facePoints[face] = -1;
                facePoints[2 * face] = -1;
                nextFaces[face] = -1;
              }
              nextFaces[face1] = face2;
              nextFaces[face2] = face3;
              nextFaces[face3] = face4;
              nextFaces[face4] = face1;
              facePoints[2 * face1] = 0;
              facePoints[2 * face1 + 1] = 1;
              facePoints[2 * face2] = 1;
              facePoints[2 * face2 + 1] = 2;
              facePoints[2 * face3] = 2;
              facePoints[2 * face3 + 1] = 3;
              facePoints[2 * face4] = 3;
              facePoints[2 * face4 + 1] = 0;
              for(MInt i = 0; i < 3; i++) {
                points[0][i] = p_0s[i];
                points[1][i] = p_1s[i];
                points[2][i] = p_2s[i];
                points[3][i] = p_3s[i];
              }

              computeTrapez(p_0, p_1, p_1s, p_0s, &faceVolume[face1], faceCentroid[face1], normal[face1]);
              computeTrapez(p_1, p_2, p_2s, p_1s, &faceVolume[face2], faceCentroid[face2], normal[face2]);
              computeTrapez(p_2, p_3, p_3s, p_2s, &faceVolume[face3], faceCentroid[face3], normal[face3]);
              computeTrapez(p_3, p_0, p_0s, p_3s, &faceVolume[face4], faceCentroid[face4], normal[face4]);

              computeTrapez(p_0, p_3, p_2, p_1, &faceVolume[face5], faceCentroid[face5], normal[face5]);

              computePoly4(p_0s, p_1s, p_2s, p_3s, &area_c, coordinates_c, normalVec_c);

              maia::math::vecAvg<3>(M, p_0, p_0s, p_1, p_1s, p_2, p_2s, p_3, p_3s);

              for(MInt i = 0; i < 5; i++) {
                computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                            &pyraVolume[i], pyraCentroid[i]);
              }
              computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[5], pyraCentroid[5]);
              for(MInt i = 0; i < 6; i++) {
                volume_C += pyraVolume[i];
                maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
              }
              vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

              m_bndryCells->a[bndryId].m_volume = volume_C;

              // create 1 Cut face
              m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
                m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
                m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
              }
            } break;
            case 9: {
              // cerr << "Case 9 detected. Starting Cutface computation..." << endl;
              for(MInt face = 0; face < 6; face++) {
                nfs_cur[face] = nfs9[currentSubCase][face];
              }
              noFaces = 6;
              p_0 = corner[cornersMCtoSOLVER[tiling9STL[currentSubCase][0]]];
              p_1 = corner[cornersMCtoSOLVER[tiling9STL[currentSubCase][1]]];
              p_2 = corner[cornersMCtoSOLVER[tiling9STL[currentSubCase][2]]];
              p_3 = corner[cornersMCtoSOLVER[tiling9STL[currentSubCase][3]]];

              cutDummy = edgesMCtoSOLVER[tiling9STL[currentSubCase][4]];
              p_1s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling9STL[currentSubCase][5]];
              p_1ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling9STL[currentSubCase][6]];
              p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling9STL[currentSubCase][7]];
              p_2ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling9STL[currentSubCase][8]];
              p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling9STL[currentSubCase][9]];
              p_3ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];

              // identify unused (=special) cut points
              for(MInt cp = 0; cp < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cp++) {
                if(p_1ss == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_1s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_2s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_2ss == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_3s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_3ss == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]) {
                  continue;
                } else {
                  unusedCutPoints[noUnusedCutPoints++] = cp;
                }
              }
              face1 = facesMCtoSOLVER[tiling9STL[currentSubCase][10]];
              face2 = facesMCtoSOLVER[tiling9STL[currentSubCase][11]];
              face3 = facesMCtoSOLVER[tiling9STL[currentSubCase][12]];
              face4 = facesMCtoSOLVER[tiling9STL[currentSubCase][13]];
              face5 = facesMCtoSOLVER[tiling9STL[currentSubCase][14]];
              face6 = facesMCtoSOLVER[tiling9STL[currentSubCase][15]];

              for(MInt face = 0; face < noFaces; face++) {
                facePoints[face] = -1;
                facePoints[2 * face] = -1;
                nextFaces[face] = -1;
              }
              nextFaces[face1] = face6;
              nextFaces[face2] = face5;
              nextFaces[face3] = face2;
              nextFaces[face4] = face1;
              nextFaces[face5] = face4;
              nextFaces[face6] = face3;
              facePoints[2 * face1] = 3;
              facePoints[2 * face1 + 1] = 4;
              facePoints[2 * face2] = 0;
              facePoints[2 * face2 + 1] = 1;
              facePoints[2 * face3] = 5;
              facePoints[2 * face3 + 1] = 0;
              facePoints[2 * face4] = 2;
              facePoints[2 * face4 + 1] = 3;
              facePoints[2 * face5] = 1;
              facePoints[2 * face5 + 1] = 2;
              facePoints[2 * face6] = 4;
              facePoints[2 * face6 + 1] = 5;
              for(MInt i = 0; i < 3; i++) {
                points[0][i] = p_1ss[i];
                points[1][i] = p_1s[i];
                points[2][i] = p_2ss[i];
                points[3][i] = p_2s[i];
                points[4][i] = p_3ss[i];
                points[5][i] = p_3s[i];
              }

              computePoly5(p_0, p_3, p_3ss, p_2s, p_2, &faceVolume[face1], faceCentroid[face1], normal[face1]);
              computePoly5(p_0, p_1, p_1ss, p_3s, p_3, &faceVolume[face3], faceCentroid[face3], normal[face3]);
              computePoly5(p_0, p_2, p_2ss, p_1s, p_1, &faceVolume[face5], faceCentroid[face5], normal[face5]);
              computeTri(p_1, p_1s, p_1ss, &faceVolume[face2], faceCentroid[face2], normal[face2]);
              computeTri(p_2, p_2s, p_2ss, &faceVolume[face4], faceCentroid[face4], normal[face4]);
              computeTri(p_3, p_3s, p_3ss, &faceVolume[face6], faceCentroid[face6], normal[face6]);

              computePoly6(p_1ss, p_1s, p_2ss, p_2s, p_3ss, p_3s, &area_c, coordinates_c, normalVec_c);

              maia::math::vecAvg<3>(M, p_0, p_1, p_2, p_3, p_1s, p_2s, p_3s, p_1ss, p_2ss, p_3ss);

              for(MInt i = 0; i < 6; i++) {
                computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                            &pyraVolume[i], pyraCentroid[i]);
              }
              computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[6], pyraCentroid[6]);
              for(MInt i = 0; i < 7; i++) {
                volume_C += pyraVolume[i];
                maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
              }
              vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

              m_bndryCells->a[bndryId].m_volume = volume_C;
              // create 1 Cut face
              m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
                m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
                m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
              }
            }

            break;
            case 11: {
              // cerr << "Case 11 detected. Starting Cutface computation..." << endl;
              for(MInt face = 0; face < 6; face++) {
                nfs_cur[face] = nfs11[currentSubCase][face];
              }
              noFaces = 6;
              p_0 = corner[cornersMCtoSOLVER[tiling11STL[currentSubCase][0]]];
              p_1 = corner[cornersMCtoSOLVER[tiling11STL[currentSubCase][1]]];
              p_2 = corner[cornersMCtoSOLVER[tiling11STL[currentSubCase][2]]];
              p_3 = corner[cornersMCtoSOLVER[tiling11STL[currentSubCase][3]]];

              cutDummy = edgesMCtoSOLVER[tiling11STL[currentSubCase][4]];
              p_0s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling11STL[currentSubCase][5]];
              p_0ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling11STL[currentSubCase][6]];
              p_1s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling11STL[currentSubCase][7]];
              p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling11STL[currentSubCase][8]];
              p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling11STL[currentSubCase][9]];
              p_3ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              face1 = facesMCtoSOLVER[tiling11STL[currentSubCase][10]];
              face2 = facesMCtoSOLVER[tiling11STL[currentSubCase][11]];
              face3 = facesMCtoSOLVER[tiling11STL[currentSubCase][12]];
              face4 = facesMCtoSOLVER[tiling11STL[currentSubCase][13]];
              face5 = facesMCtoSOLVER[tiling11STL[currentSubCase][14]];
              face6 = facesMCtoSOLVER[tiling11STL[currentSubCase][15]];

              // identify unused (=special) cut points
              for(MInt cp = 0; cp < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cp++) {
                if(p_0ss == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_0s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_1s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_2s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_3s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_3ss == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]) {
                  continue;
                } else {
                  unusedCutPoints[noUnusedCutPoints++] = cp;
                }
              }

              for(MInt face = 0; face < noFaces; face++) {
                facePoints[face] = -1;
                facePoints[2 * face] = -1;
                nextFaces[face] = -1;
              }
              nextFaces[face1] = face5;
              nextFaces[face2] = face4;
              nextFaces[face3] = face6;
              nextFaces[face4] = face1;
              nextFaces[face5] = face3;
              nextFaces[face6] = face2;
              facePoints[2 * face1] = 0;
              facePoints[2 * face1 + 1] = 1;
              facePoints[2 * face2] = 4;
              facePoints[2 * face2 + 1] = 5;
              facePoints[2 * face3] = 2;
              facePoints[2 * face3 + 1] = 3;
              facePoints[2 * face4] = 5;
              facePoints[2 * face4 + 1] = 0;
              facePoints[2 * face5] = 1;
              facePoints[2 * face5 + 1] = 2;
              facePoints[2 * face6] = 3;
              facePoints[2 * face6 + 1] = 4;
              for(MInt i = 0; i < 3; i++) {
                points[0][i] = p_0ss[i];
                points[1][i] = p_0s[i];
                points[2][i] = p_2s[i];
                points[3][i] = p_3ss[i];
                points[4][i] = p_3s[i];
                points[5][i] = p_1s[i];
              }

              computeTri(p_0, p_0s, p_0ss, &faceVolume[face1], faceCentroid[face1], normal[face1]);
              computePoly5(p_3s, p_3, p_2, p_1, p_1s, &faceVolume[face2], faceCentroid[face2], normal[face2]);
              computeTrapez(p_2, p_3, p_3ss, p_2s, &faceVolume[face3], faceCentroid[face3], normal[face3]);
              computeTrapez(p_1, p_0, p_0ss, p_1s, &faceVolume[face4], faceCentroid[face4], normal[face4]);
              computePoly5(p_1, p_2, p_2s, p_0s, p_0, &faceVolume[face5], faceCentroid[face5], normal[face5]);
              computeTri(p_3, p_3s, p_3ss, &faceVolume[face6], faceCentroid[face6], normal[face6]);

              computePoly6(p_0ss, p_0s, p_2s, p_3ss, p_3s, p_1s, &area_c, coordinates_c, normalVec_c);

              maia::math::vecAvg<3>(M, p_0, p_1, p_2, p_3, p_0s, p_1s, p_2s, p_3s, p_0ss, p_3ss);

              for(MInt i = 0; i < 6; i++) {
                computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                            &pyraVolume[i], pyraCentroid[i]);
              }
              computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[6], pyraCentroid[6]);
              for(MInt i = 0; i < 7; i++) {
                volume_C += pyraVolume[i];
                maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
              }
              vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

              m_bndryCells->a[bndryId].m_volume = volume_C;
              // create 1 Cut face
              m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
                m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
                m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
              }
              break;
            }
            case 14: {
              // cerr << "Case 14 detected. Starting Cutface computation..." << endl;
              for(MInt face = 0; face < 6; face++) {
                nfs_cur[face] = nfs14[currentSubCase][face];
              }
              noFaces = 6;
              p_0 = corner[cornersMCtoSOLVER[tiling14STL[currentSubCase][0]]];
              p_1 = corner[cornersMCtoSOLVER[tiling14STL[currentSubCase][1]]];
              p_2 = corner[cornersMCtoSOLVER[tiling14STL[currentSubCase][2]]];
              p_3 = corner[cornersMCtoSOLVER[tiling14STL[currentSubCase][3]]];

              cutDummy = edgesMCtoSOLVER[tiling14STL[currentSubCase][4]];
              p_0s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling14STL[currentSubCase][5]];
              p_0ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling14STL[currentSubCase][6]];
              p_1s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling14STL[currentSubCase][7]];
              p_2s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling14STL[currentSubCase][8]];
              p_3s = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              cutDummy = edgesMCtoSOLVER[tiling14STL[currentSubCase][9]];
              p_3ss = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutPoints[cutDummy]];
              face1 = facesMCtoSOLVER[tiling14STL[currentSubCase][10]];
              face2 = facesMCtoSOLVER[tiling14STL[currentSubCase][11]];
              face3 = facesMCtoSOLVER[tiling14STL[currentSubCase][12]];
              face4 = facesMCtoSOLVER[tiling14STL[currentSubCase][13]];
              face5 = facesMCtoSOLVER[tiling14STL[currentSubCase][14]];
              face6 = facesMCtoSOLVER[tiling14STL[currentSubCase][15]];

              // identify unused (=special) cut points
              for(MInt cp = 0; cp < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cp++) {
                if(p_0ss == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_0s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_1s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_2s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_3s == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]
                   || p_3ss == m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp]) {
                  continue;
                } else {
                  unusedCutPoints[noUnusedCutPoints++] = cp;
                }
              }

              for(MInt face = 0; face < noFaces; face++) {
                facePoints[face] = -1;
                facePoints[2 * face] = -1;
                nextFaces[face] = -1;
              }
              nextFaces[face1] = face4;
              nextFaces[face2] = face6;
              nextFaces[face3] = face5;
              nextFaces[face4] = face2;
              nextFaces[face5] = face1;
              nextFaces[face6] = face3;
              facePoints[2 * face1] = 0;
              facePoints[2 * face1 + 1] = 1;
              facePoints[2 * face2] = 2;
              facePoints[2 * face2 + 1] = 3;
              facePoints[2 * face3] = 4;
              facePoints[2 * face3 + 1] = 5;
              facePoints[2 * face4] = 1;
              facePoints[2 * face4 + 1] = 2;
              facePoints[2 * face5] = 5;
              facePoints[2 * face5 + 1] = 0;
              facePoints[2 * face6] = 3;
              facePoints[2 * face6 + 1] = 4;
              for(MInt i = 0; i < 3; i++) {
                points[0][i] = p_0ss[i];
                points[1][i] = p_0s[i];
                points[2][i] = p_1s[i];
                points[3][i] = p_3ss[i];
                points[4][i] = p_3s[i];
                points[5][i] = p_2s[i];
              }

              computeTri(p_0, p_0s, p_0ss, &faceVolume[face1], faceCentroid[face1], normal[face1]);
              computePoly5(p_2, p_3, p_3ss, p_1s, p_1, &faceVolume[face2], faceCentroid[face2], normal[face2]);
              computeTrapez(p_2s, p_3s, p_3, p_2, &faceVolume[face3], faceCentroid[face3], normal[face3]);
              computeTrapez(p_1s, p_0s, p_0, p_1, &faceVolume[face4], faceCentroid[face4], normal[face4]);
              computePoly5(p_2, p_1, p_0, p_0ss, p_2s, &faceVolume[face5], faceCentroid[face5], normal[face5]);
              computeTri(p_3, p_3s, p_3ss, &faceVolume[face6], faceCentroid[face6], normal[face6]);

              computePoly6(p_0ss, p_0s, p_1s, p_3ss, p_3s, p_2s, &area_c, coordinates_c, normalVec_c);

              maia::math::vecAvg<3>(M, p_0, p_1, p_2, p_3, p_0s, p_1s, p_2s, p_3s, p_0ss, p_3ss);

              for(MInt i = 0; i < 6; i++) {
                computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                            &pyraVolume[i], pyraCentroid[i]);
              }
              computePyra(&area_c, coordinates_c, normalVec_c, M, &pyraVolume[6], pyraCentroid[6]);
              for(MInt i = 0; i < 7; i++) {
                volume_C += pyraVolume[i];
                maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
              }
              vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

              m_bndryCells->a[bndryId].m_volume = volume_C;
              // create 1 Cut face
              m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area_c;
              for(MInt dim = 0; dim < 3; dim++) {
                m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = coordinates_c[dim];
                m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normalVec_c[dim];
                m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
              }

              break;
            }
            default: {
              mTerm(1, AT_, "Inconsistent type implementation.");
            }
          }
        }

        // 5a) Check if cell contains one additional cut Point
        if(noUnusedCutPoints > 2) {
          mTerm(1, AT_, "FvBndryCndXD::correctInflowBoundary - Error: Too many unused CutPoints!");
        }
        // cell contains special cut points and needs special treatment - 1 special cut point
        // relevant cut points are identified, cut points which must be treated as intersectionPoints are stored
        if(noUnusedCutPoints < 2) {
          for(MInt cp = 0; cp < noUnusedCutPoints; cp++) {
            cutEdge = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[unusedCutPoints[cp]];
            cutFace1 = faceCode[2 * cutEdge];
            cutFace2 = faceCode[2 * cutEdge + 1];
            // simple case: move IntersectionPoint to cutPoint, exchange cutFace
            if(noIntersectionPoints[cutFace1] == 1 && noIntersectionPoints[cutFace2] == 0) {
              for(MInt dir = 0; dir < 3; dir++) {
                intersectionPoints[cutFace2][0][dir] =
                    m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[unusedCutPoints[cp]][dir];
                intersectionPoints[cutFace1][0][dir] = F0;
              }
              noIntersectionPoints[cutFace1] = 0;
              noIntersectionPoints[cutFace2] = 1;
            } // simple case: move IntersectionPoint to cutPoint, exchange cutFace
            else if(noIntersectionPoints[cutFace2] == 1 && noIntersectionPoints[cutFace1] == 0) {
              for(MInt dir = 0; dir < 3; dir++) {
                intersectionPoints[cutFace1][0][dir] =
                    m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[unusedCutPoints[cp]][dir];
                intersectionPoints[cutFace2][0][dir] = F0;
              }
              noIntersectionPoints[cutFace2] = 0;
              noIntersectionPoints[cutFace1] = 1;
            } // special case: move IntersectionPoint to cutPoint, both faces are cutFaces
            else if(noIntersectionPoints[cutFace2] == 0 && noIntersectionPoints[cutFace1] == 0) {
              for(MInt dir = 0; dir < 3; dir++) {
                intersectionPoints[cutFace1][0][dir] =
                    m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[unusedCutPoints[cp]][dir];
                intersectionPoints[cutFace2][0][dir] =
                    m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[unusedCutPoints[cp]][dir];
              }
              noIntersectionPoints[cutFace2] = 1;
              noIntersectionPoints[cutFace1] = 1;
            }
          }
        }
        // cell contains special cut points and needs special treatment - 2 special cut points
        // relevant cut points are identified, cut points which must be treated as intersectionPoints are stored
        if(noUnusedCutPoints == 2) {
          cutEdge = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[unusedCutPoints[0]];
          cutFace1 = faceCode[2 * cutEdge];
          cutFace2 = faceCode[2 * cutEdge + 1];
          cutEdgeNghbr = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[unusedCutPoints[1]];
          cutFaceNghbr1 = faceCode[2 * cutEdgeNghbr];
          cutFaceNghbr2 = faceCode[2 * cutEdgeNghbr + 1];
          // difficult case, first consider the possibility that no cutPoints exist
          if(noIntersectionPoints[cutFace2] == 0 && noIntersectionPoints[cutFace1] == 0
             && noIntersectionPoints[cutFaceNghbr2] == 0 && noIntersectionPoints[cutFaceNghbr1] == 0) {
            // left cut face of the other cut point == left cut face of this cut point
            if(cutFaceNghbr1 == cutFace1) {
              for(MInt dir = 0; dir < 3; dir++) {
                intersectionPoints[cutFace2][0][dir] =
                    m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[unusedCutPoints[0]][dir];
                intersectionPoints[cutFaceNghbr2][0][dir] =
                    m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[unusedCutPoints[1]][dir];
              }
              noIntersectionPoints[cutFace2]++;
              noIntersectionPoints[cutFaceNghbr2]++;
            }
            // right cut face of the other cut point == left cut face of this cut point
            if(cutFaceNghbr2 == cutFace1) {
              for(MInt dir = 0; dir < 3; dir++) {
                intersectionPoints[cutFace2][0][dir] =
                    m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[unusedCutPoints[0]][dir];
                intersectionPoints[cutFaceNghbr1][0][dir] =
                    m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[unusedCutPoints[1]][dir];
              }
              noIntersectionPoints[cutFace2]++;
              noIntersectionPoints[cutFaceNghbr1]++;
            }
            // left cut face of the other cut point == right cut face of this cut point
            if(cutFaceNghbr1 == cutFace2) {
              for(MInt dir = 0; dir < 3; dir++) {
                intersectionPoints[cutFace1][0][dir] =
                    m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[unusedCutPoints[0]][dir];
                intersectionPoints[cutFaceNghbr2][0][dir] =
                    m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[unusedCutPoints[1]][dir];
              }
              noIntersectionPoints[cutFace1]++;
              noIntersectionPoints[cutFaceNghbr2]++;
            }
            // right cut face of the other cut point == right cut face of this cut point
            if(cutFaceNghbr2 == cutFace2) {
              for(MInt dir = 0; dir < 3; dir++) {
                intersectionPoints[cutFace1][0][dir] =
                    m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[unusedCutPoints[0]][dir];
                intersectionPoints[cutFaceNghbr1][0][dir] =
                    m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[unusedCutPoints[1]][dir];
              }
              noIntersectionPoints[cutFace1]++;
              noIntersectionPoints[cutFaceNghbr1]++;
            }
          } else {
            stringstream fileName;
            fileName << cellId << ".stl";
            writeStlFileOfCell(cellId, (fileName.str()).c_str());
            plotEdges(noFeatureEdges, featureEdges);
            plotIntersectionPoints(noIntersectionPoints, intersectionPoints);
            writeStlOfNodes(noWallNodes, wallNodes, "WallNodes.stl");
            cerr << "Wrote stl-file of cell and wall nodes. Cell-file: " << fileName.str()
                 << ", Node-file: WallNodes.stl" << endl;
            mTerm(1, AT_, "Unhandled exception in special cell handling!");
          }
        }

        // delete the special (nonused) cut points and resort the remaining cut points - only regular cut points should
        // be used in the following
        for(MInt cpCount = noUnusedCutPoints - 1; cpCount >= 0; cpCount--) {
          m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints--;
          for(MInt count = unusedCutPoints[cpCount]; count < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
              count++) {
            m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[count] =
                m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[count + 1];
            for(MInt dir = 0; dir < 3; dir++)
              m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[count][dir] =
                  m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[count + 1][dir];
          }
        }

        // check if number of intersectionPoints on each face is ok and prepare array of all intersection points
        for(MInt face = 0; face < 6; face++) {
          if(noIntersectionPoints[face] == 2) {
            noIntersectionPoints[face] = 0;
          } else if(noIntersectionPoints[face] > 1) {
            cerr << "FvBndryCndXD::correctInflowBoundary - Error: More than 1 intersection Point!"
                 << "  cellId: " << cellId << endl;
            stringstream fileName;
            fileName << cellId << ".stl";
            writeStlFileOfCell(cellId, (fileName.str()).c_str());
            plotEdges(noFeatureEdges, featureEdges);
            plotIntersectionPoints(noIntersectionPoints, intersectionPoints);
            writeStlOfNodes(noWallNodes, wallNodes, "WallNodes.stl");
            stringstream errorMessage;
            errorMessage << "Wrote stl-file of cell and wall nodes. Cell-file: " << fileName.str()
                         << ", Node-file: WallNodes.stl";
            mTerm(1, AT_, errorMessage.str());
          }
          //                                         if(noIntersectionPoints[face] == 1){
          //                                                 for(MInt k=0; k < 3; k++){
          //                                                         allIntersectionPoints[noAllIntersectionPoints][k] =
          //                                                         intersectionPoints[face][0][k];
          //                                                 }
          //                                                 noAllIntersectionPoints++;
          //                                         }
        }


        // 6) Recompute voxel face parameters - only if noIntersectionPoints[face] > 0
        if(!caseStatesSTL[currentCase][1]) {
          mTerm(1, AT_, "Case not resolved for Inlet Correction!");
        }

        faceStart = -1;
        for(MInt face = 0; face < 6; face++) {
          pointCount = 0;
          if(!(noIntersectionPoints[face] == 1)) {
            continue;
          }
          for(MInt cP = 0; cP < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cP++) {
            for(MInt edge = 0; edge < 4; edge++) {
              if(m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cP] == edgeCode[face * 4 + edge]) {
                if(pointCount < 2) {
                  pointIndices[pointCount++] = cP;
                } else {
                  mTerm(1, AT_, "Too many cut Points!");
                }
              }
            }
          }
          if(!(pointCount == 2)) {
            cerr << "FvBndryCndXD::correctInflowBoundary - Error: Not two Cut points..."
                 << " face: " << face << "faceNormal: " << normal[face][0] << " " << normal[face][1] << " "
                 << normal[face][2] << endl;
            plotIntersectionPoints(noIntersectionPoints, intersectionPoints);
            plotEdges(noFeatureEdges, featureEdges);
            writeStlOfNodes(noWallNodes, wallNodes, "WallNodes.stl");
            stringstream fileName;
            fileName << cellId << ".stl";
            writeStlFileOfCell(cellId, (fileName.str()).c_str());
            stringstream errorMessage;
            errorMessage << "Wrote stl-file of cell, wall nodes, feature edges and intersection points. Cell-file: "
                         << fileName.str();
            mTerm(1, AT_, errorMessage.str());
          }

          // store the face on which to start collecting the points for the resulting boundary cut surfaces
          faceStart = face;
          // compute and plot the new part resulting from the consideration of the cut point
          computeTri(m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[pointIndices[0]],
                     m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[pointIndices[1]],
                     intersectionPoints[face][0], &newArea, dummy_1);
          plotTriangle(ofl, m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[pointIndices[0]],
                       m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[pointIndices[1]],
                       intersectionPoints[face][0], normal[face]);

          // regularly, the cell volume should grow by boundary correction, if this should be otherwise "inside" must be
          // specified (e.g. cube testcase)
          if(inside) {
            if(secondHalf)
              secondHalf = false;
            else
              secondHalf = true;
          }
          // decide if the new triangle increases or decreases the face area
          if(secondHalf) {
            newArea = -newArea;
          }
          vecScalarMul(faceVolume[face], faceCentroid[face], dummy_2);
          vecScalarMul(newArea, dummy_1, dummy_3);
          std::fill_n(faceCentroid[face], 3, 0.0);
          maia::math::vecAdd<3>(faceCentroid[face], dummy_2, dummy_3);
          faceVolume[face] = faceVolume[face] + newArea;
          vecScalarMul(1. / (faceVolume[face]), faceCentroid[face], faceCentroid[face]);

          if(inside) {
            if(secondHalf)
              secondHalf = false;
            else
              secondHalf = true;
          }
        }

        // 7.) compute Cut Faces
        if(faceStart == -1) {
          plotIntersectionPoints(noIntersectionPoints, intersectionPoints);
          plotEdges(noFeatureEdges, featureEdges);
          writeStlOfNodes(noWallNodes, wallNodes, "WallNodes.stl");
          stringstream fileName;
          fileName << cellId << ".stl";
          writeStlFileOfCell(cellId, (fileName.str()).c_str());
          cerr << "Wrote stl-file of cell, wall nodes, feature edges and intersection points. Cell-file: "
               << fileName.str() << endl;

          stringstream errorMessage;
          errorMessage << "No suitable start face found on cell " << cellId << "!";
          mTerm(1, AT_, errorMessage.str());
        }
        noPoints1 = 0;
        noPoints2 = 0;
        points1[noPoints1++] = intersectionPoints[faceStart][0];
        // collect points of first new cut face
        do {
          points1[noPoints1++] = points[facePoints[2 * faceStart + 1]];
          faceStart = nextFaces[faceStart];
        } while(noIntersectionPoints[faceStart] == 0);
        delta_IP = sqrt(POW2(intersectionPoints[faceStart][0][0] - points1[0][0])
                        + POW2(intersectionPoints[faceStart][0][1] - points1[0][1])
                        + POW2(intersectionPoints[faceStart][0][2] - points1[0][2]));
        if(delta_IP > 1e-5) {
          points1[noPoints1++] = intersectionPoints[faceStart][0];
        } else {
        }

        points2[noPoints2++] = intersectionPoints[faceStart][0];
        // collect points of second new cut face
        do {
          points2[noPoints2++] = points[facePoints[2 * faceStart + 1]];
          faceStart = nextFaces[faceStart];
        } while(noIntersectionPoints[faceStart] == 0);
        delta_IP = sqrt(POW2(intersectionPoints[faceStart][0][0] - points2[0][0])
                        + POW2(intersectionPoints[faceStart][0][1] - points2[0][1])
                        + POW2(intersectionPoints[faceStart][0][2] - points2[0][2]));
        if(delta_IP > 1e-5) {
          points2[noPoints2++] = intersectionPoints[faceStart][0];
        }

        switch(noPoints1) {
          case 1:
          case 2: {
            cerr << "FvBndryCndXD::correctInflowBoundaryCondition - Error 1: Not enough Points to create a cut face"
                 << endl;
            plotIntersectionPoints(noIntersectionPoints, intersectionPoints);
            plotEdges(noFeatureEdges, featureEdges);
            writeStlOfNodes(noWallNodes, wallNodes, "WallNodes.stl");
            stringstream fileName;
            fileName << cellId << ".stl";
            writeStlFileOfCell(cellId, (fileName.str()).c_str());
            cerr << " cut Points: " << m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints << " : ";
            for(MInt cp = 0; cp < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cp++)
              cerr << m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp][0] << " "
                   << m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp][1] << " "
                   << m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp][2] << "; ";
            cerr << endl;
            stringstream errorMessage;
            errorMessage << "Wrote stl-file of cell, wall nodes, feature edges and intersection points. Cell-file: "
                         << fileName.str();
            mTerm(1, AT_, errorMessage.str());
          } break;
          case 3:
            computePoly3(points1[0], points1[1], points1[2], &area1, centroid1, normal1);
            plotTriangle(ofl, points1[0], points1[1], points1[2], normal1);
            break;
          case 4:
            computePoly4(points1[0], points1[1], points1[2], points1[3], &area1, centroid1, normal1);
            plotTriangle(ofl, points1[0], points1[1], points1[2], normal1);
            plotTriangle(ofl, points1[2], points1[3], points1[0], normal1);
            break;
          case 5:
            computePoly5(points1[0], points1[1], points1[2], points1[3], points1[4], &area1, centroid1, normal1);
            plotTriangle(ofl, points1[0], points1[1], points1[2], normal1);
            plotTriangle(ofl, points1[2], points1[3], points1[4], normal1);
            plotTriangle(ofl, points1[2], points1[4], points1[0], normal1);
            break;
          case 6:
            computePoly6(points1[0], points1[1], points1[2], points1[3], points1[4], points1[5], &area1, centroid1,
                         normal1);
            plotTriangle(ofl, points1[0], points1[1], points1[2], normal1);
            plotTriangle(ofl, points1[2], points1[3], points1[4], normal1);
            plotTriangle(ofl, points1[2], points1[4], points1[5], normal1);
            plotTriangle(ofl, points1[2], points1[5], points1[0], normal1);
            break;
          default: {
            stringstream errorMessage;
            errorMessage << "ERROR: Switch variable 'noPoints1' with value " << noPoints1 << " not matching any case."
                         << endl;
            mTerm(1, AT_, errorMessage.str());
          }
        }
        switch(noPoints2) {
          case 1:
          case 2: {
            cerr << "FvBndryCndXD::correctInflowBoundaryCondition - Error 2: Not enough Points to create a cut face"
                 << endl;
            plotIntersectionPoints(noIntersectionPoints, intersectionPoints);
            plotEdges(noFeatureEdges, featureEdges);
            writeStlOfNodes(noWallNodes, wallNodes, "WallNodes.stl");
            stringstream fileName;
            fileName << cellId << ".stl";
            writeStlFileOfCell(cellId, (fileName.str()).c_str());
            stringstream errorMessage;
            errorMessage << "Wrote stl-file of cell, wall nodes, feature edges and intersection points. Cell-file: "
                         << fileName.str();
            cerr << " cut Points: " << m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints << " : ";
            for(MInt cp = 0; cp < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cp++)
              cerr << m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp][0] << " "
                   << m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp][1] << " "
                   << m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp][2] << "; ";
            cerr << endl;
            mTerm(1, AT_, errorMessage.str());
          } break;
          case 3:
            computePoly3(points2[0], points2[1], points2[2], &area2, centroid2, normal2);
            plotTriangle(ofl, points2[0], points2[1], points2[2], normal2);
            break;
          case 4:
            computePoly4(points2[0], points2[1], points2[2], points2[3], &area2, centroid2, normal2);
            plotTriangle(ofl, points2[0], points2[1], points2[2], normal2);
            plotTriangle(ofl, points2[2], points2[3], points2[0], normal2);
            break;
          case 5:
            computePoly5(points2[0], points2[1], points2[2], points2[3], points2[4], &area2, centroid2, normal2);
            plotTriangle(ofl, points2[0], points2[1], points2[2], normal2);
            plotTriangle(ofl, points2[2], points2[3], points2[4], normal2);
            plotTriangle(ofl, points2[2], points2[4], points2[0], normal2);
            break;
          case 6:
            computePoly6(points2[0], points2[1], points2[2], points2[3], points2[4], points2[5], &area2, centroid2,
                         normal2);
            plotTriangle(ofl, points2[0], points2[1], points2[2], normal2);
            plotTriangle(ofl, points2[2], points2[3], points2[4], normal2);
            plotTriangle(ofl, points2[2], points2[4], points2[5], normal2);
            plotTriangle(ofl, points2[2], points2[5], points2[0], normal2);
            break;
          default: {
            stringstream errorMessage;
            errorMessage << "ERROR: Switch variable 'noPoints2' with value " << noPoints2 << " not matching any case."
                         << endl;
            mTerm(1, AT_, errorMessage.str());
          }
        }

        // recompute the cell volume and centroid
        volume_C = F0;
        coordinates_Cell[0] = F0;
        coordinates_Cell[1] = F0;
        coordinates_Cell[2] = F0;
        for(MInt i = 0; i < noFaces; i++) {
          computePyra(&faceVolume[*facepointers[i]], faceCentroid[*facepointers[i]], normal[*facepointers[i]], M,
                      &pyraVolume[i], pyraCentroid[i]);
        }
        computePyra(&area1, centroid1, normal1, M, &pyraVolume[noFaces], pyraCentroid[noFaces]);
        computePyra(&area2, centroid2, normal2, M, &pyraVolume[noFaces + 1], pyraCentroid[noFaces + 1]);
        for(MInt i = 0; i < noFaces + 2; i++) {
          volume_C += pyraVolume[i];
          maia::math::vecAdd<3>(coordinates_Cell, vecScalarMul(pyraVolume[i], pyraCentroid[i], dummy_1));
        }
        vecScalarMul(F1 / volume_C, coordinates_Cell, coordinates_Cell);

        normalDiff =
            POW2(normal1[0] - meanNormal[0]) + POW2(normal1[1] - meanNormal[1]) + POW2(normal1[2] - meanNormal[2]);
        if(normalDiff < normalEps) {
          bcId1 = bcInlet;
          bcId2 = bcWall;
        } else {
          bcId1 = bcWall;
          bcId2 = bcInlet;
        }

        if(secondHalf) {
          switch(currentCase) {
            case 1: {
              correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
              correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
              correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);

              correctCell(&volume_C, coordinates_Cell, &gridCellVolume, &m_solver->a_coordinate(cellId, 0));

              correctNormal(normalVec_c);
              if(inside) {
                correctNormal(normal1);
                correctNormal(normal2);
              }
              break;
            }
            case 2: {
              correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
              correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
              correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);
              correctFace(&faceVolume[face4], faceCentroid[face4], &faceVolume_0[face4], faceCentroid_0[face4]);

              correctCell(&volume_C, coordinates_Cell, &gridCellVolume, &m_solver->a_coordinate(cellId, 0));

              correctNormal(normalVec_c);
              if(inside) {
                correctNormal(normal1);
                correctNormal(normal2);
              }
              break;
            }
            case 5: {
              correctFace(&faceVolume[face1], faceCentroid[face1], &faceVolume_0[face1], faceCentroid_0[face1]);
              correctFace(&faceVolume[face2], faceCentroid[face2], &faceVolume_0[face2], faceCentroid_0[face2]);
              correctFace(&faceVolume[face3], faceCentroid[face3], &faceVolume_0[face3], faceCentroid_0[face3]);
              correctFace(&faceVolume[face4], faceCentroid[face4], &faceVolume_0[face4], faceCentroid_0[face4]);
              correctFace(&faceVolume[face5], faceCentroid[face5], &faceVolume_0[face5], faceCentroid_0[face5]);

              correctCell(&volume_C, coordinates_Cell, &gridCellVolume, &m_solver->a_coordinate(cellId, 0));

              correctNormal(normal1);
              correctNormal(normal2);

              break;
            }
            default: {
              mTerm(1, AT_, "Inconsistent type implementation.");
            }
          }
        }

        MFloat faceDiff[3];
        MFloat absA = F0;
        // compute differences in cell surface areas
        for(MInt i = 0; i < nDim; i++) {
          if(!nfs_cur[2 * i + 1]) faceVolume[2 * i + 1] = 0;
          if(!nfs_cur[2 * i]) faceVolume[2 * i] = 0;
          faceDiff[i] = faceVolume[2 * i + 1] - faceVolume[2 * i];
          absA += POW2(faceDiff[i]);
        }

        // correct values such that cell is closed!
        // (if 1 indicates inlet face -> normal1 should keep direction)
        if(bcInlet == bcId1) {
          for(MInt dim = 0; dim < 3; dim++)
            normal1[dim] = meanNormal[dim];
          // normalize inlet normal
          absA = F0;
          for(MInt dim = 0; dim < 3; dim++)
            absA += normal1[dim] * normal1[dim];
          absA = sqrt(absA);
          for(MInt dim = 0; dim < 3; dim++)
            normal1[dim] /= absA;

          // compute area1
          area1 = F0;
          for(MInt dim = 0; dim < 3; dim++)
            area1 += faceDiff[dim] * normal1[dim];

          // update FaceDiff:
          absA = F0;
          for(MInt i = 0; i < nDim; i++) {
            faceDiff[i] -= area1 * normal1[i];
            absA += POW2(faceDiff[i]);
          }

          // compute normal2, area2 such that cell is closed
          for(MInt i = 0; i < nDim; i++)
            normal2[i] = faceDiff[i] / sqrt(absA);
          area2 = sqrt(absA);
        } else {
          for(MInt dim = 0; dim < 3; dim++)
            normal2[dim] = meanNormal[dim];
          // normalize inlet normal
          absA = F0;
          for(MInt dim = 0; dim < 3; dim++)
            absA += normal2[dim] * normal2[dim];
          absA = sqrt(absA);
          for(MInt dim = 0; dim < 3; dim++)
            normal2[dim] /= absA;

          // compute area1
          area2 = F0;
          for(MInt dim = 0; dim < 3; dim++)
            area2 += faceDiff[dim] * normal2[dim];

          // update FaceDiff:
          absA = F0;
          for(MInt i = 0; i < nDim; i++) {
            faceDiff[i] -= area2 * normal2[i];
            absA += POW2(faceDiff[i]);
          }

          // compute normal2, area2 such that cell is closed
          for(MInt i = 0; i < nDim; i++)
            normal1[i] = faceDiff[i] / sqrt(absA);
          area1 = sqrt(absA);
        }

        // 				// correct values such that cell is closed!
        // 				// first: create orthonormalbasis (if 1 indicates inlet face -> normal1 should keep direction)
        //         // then correct srfcs
        // 				if(bcInlet == bcId1){
        //
        //           //test take meanNormal
        //           for(MInt dim = 0; dim < 3; dim++)
        //             normal1[dim] = meanNormal[dim];
        //
        //           // normalize inlet normal
        //           absA = F0;
        //           for(MInt dim = 0; dim < 3; dim++)
        //             absA += normal1[dim] * normal1[dim];
        //           absA = sqrt(absA);
        //           for(MInt dim = 0; dim < 3; dim++)
        //             normal1[dim] /= absA;
        //
        //           // compute direction of wall normal
        //           absA = F0;
        //           for(MInt dim = 0; dim < 3; dim++)
        //             absA += normal1[dim] * normal2[dim];
        //           for(MInt dim = 0; dim < 3; dim++)
        //             normal2[dim] = normal2[dim] - absA * normal1[dim];
        //
        //           // normalize wall normal
        //           absA = F0;
        //           for(MInt dim = 0; dim < 3; dim++)
        //             absA += normal2[dim] * normal2[dim];
        //           for(MInt dim = 0; dim < 3; dim++)
        //             normal2[dim] /= absA;
        //
        //           area1 = F0;
        //           for(MInt dim = 0; dim < 3; dim++)
        //             area1 += faceDiff[dim] * normal1[dim];
        //           area2 = F0;
        //           for(MInt dim = 0; dim < 3; dim++)
        //             area2 += faceDiff[dim] * normal2[dim];
        //         }
        //         else{ // first: create orthonormalbasis (if 2 indicates inlet face -> normal2 should keep direction)
        //           // then correct srfcs
        //           // normalize inlet normal
        //           for(MInt dim = 0; dim < 3; dim++)
        //             normal2[dim] = meanNormal[dim];
        //
        //           absA = F0;
        //           for(MInt dim = 0; dim < 3; dim++)
        //             absA += normal2[dim] * normal2[dim];
        //           absA = sqrt(absA);
        //           for(MInt dim = 0; dim < 3; dim++)
        //             normal2[dim] /= absA;
        //
        //           // compute direction of wall normal
        //           absA = F0;
        //           for(MInt dim = 0; dim < 3; dim++)
        //             absA += normal2[dim] * normal1[dim];
        //           for(MInt dim = 0; dim < 3; dim++)
        //             normal1[dim] = normal1[dim] - absA * normal2[dim];
        //
        //           // normalize wall normal
        //           absA = F0;
        //           for(MInt dim = 0; dim < 3; dim++)
        //             absA += normal1[dim] * normal1[dim];
        //           for(MInt dim = 0; dim < 3; dim++)
        //             normal1[dim] /= absA;
        //
        //           area1 = F0;
        //           for(MInt dim = 0; dim < 3; dim++)
        //             area1 += faceDiff[dim] * normal1[dim];
        //           area2 = F0;
        //           for(MInt dim = 0; dim < 3; dim++)
        //             area2 += faceDiff[dim] * normal2[dim];
        //         }

        m_bndryCells->a[bndryId].m_noSrfcs = 2;
        m_bndryCells->a[bndryId].m_volume = volume_C;

        if(bcInlet == bcId1) { // make sure srfc 0 is the inlet bndry srfc
          m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area1;
          m_bndryCells->a[bndryId].m_srfcs[1]->m_area = area2;
          m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId = bcId1;
          m_bndryCells->a[bndryId].m_srfcs[1]->m_bndryCndId = bcId2;
          for(MInt dim = 0; dim < 3; dim++) {
            m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = centroid1[dim];
            m_bndryCells->a[bndryId].m_srfcs[1]->m_coordinates[dim] = centroid2[dim];
            m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normal1[dim];
            m_bndryCells->a[bndryId].m_srfcs[1]->m_normalVector[dim] = normal2[dim];
            m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
          }
        } else {
          m_bndryCells->a[bndryId].m_srfcs[0]->m_area = area2;
          m_bndryCells->a[bndryId].m_srfcs[1]->m_area = area1;
          m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId = bcId2;
          m_bndryCells->a[bndryId].m_srfcs[1]->m_bndryCndId = bcId1;
          for(MInt dim = 0; dim < 3; dim++) {
            m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[dim] = centroid2[dim];
            m_bndryCells->a[bndryId].m_srfcs[1]->m_coordinates[dim] = centroid1[dim];
            m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[dim] = normal2[dim];
            m_bndryCells->a[bndryId].m_srfcs[1]->m_normalVector[dim] = normal1[dim];
            m_bndryCells->a[bndryId].m_coordinates[dim] = coordinates_Cell[dim];
          }
        }

        for(MInt i = 0; i < nDim; i++) {
          m_bndryCells->a[bndryId].m_coordinates[i] -= m_solver->a_coordinate(cellId, i);
        }

        for(MInt face = 0; face < 6; face++) {
          for(MInt i = 0; i < noFaces; i++) {
            if(!(*facepointers[i] == face)) continue;
            sideId = face % 2;
            spaceId = face / 2;
            if(nfs_cur[face]) {
              if(m_solver->a_hasNeighbor(cellId, face) > 0)
                nghbrId = m_solver->c_neighborId(cellId, face);
              else {
                if(m_solver->c_parentId(cellId) > -1) {
                  if(m_solver->a_hasNeighbor(m_solver->c_parentId(cellId), face) > 0)
                    nghbrId = m_solver->c_neighborId(m_solver->c_parentId(cellId), face);
                  else
                    continue;
                } else
                  continue;
              }
              if(m_solver->c_noChildren(nghbrId) > 0) continue;
              otherSideId = (sideId + 1) % 2;
              srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[face];
              m_solver->a_surfaceOrientation(srfcId) = spaceId;
              m_solver->a_surfaceNghbrCellId(srfcId, sideId) = nghbrId;
              m_solver->a_surfaceNghbrCellId(srfcId, otherSideId) = cellId;
              for(MInt dim = 0; dim < nDim; dim++) {
                m_solver->a_surfaceCoordinate(srfcId, dim) = faceCentroid[face][dim];
              }
              m_solver->a_surfaceArea(srfcId) = faceVolume[face];
              m_bndryCells->a[bndryId].m_associatedSrfc[face] = srfcId;
            } else {
              cerr << "FvBndryCndXD::correctInflowBoundary - Error for face: " << face << endl;
              cerr << "bndryId: " << bndryId << endl;
              cerr << "cellId: " << cellId << endl;
              cerr << "bndryCnd: " << m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId;
              cerr << "case, subcase: " << currentCase << ", " << currentSubCase << endl;
              cerr << "face Volumes: " << faceVolume[0] << ", " << faceVolume[1] << ", " << faceVolume[2] << ", "
                   << faceVolume[3] << ", " << faceVolume[4] << ", " << faceVolume[5] << endl;
              cerr << "faceCentroids: ";
              for(MInt j = 0; j < 6; j++) {
                cerr << faceCentroid[j][0] << ", " << faceCentroid[j][1] << ", " << faceCentroid[j][2] << "; " << endl;
              }
              cerr << "area_c = " << area_c << endl;
              cerr << "normalVec_c = " << normalVec_c[0] << ", " << normalVec_c[1] << ", " << normalVec_c[2] << endl;
              cerr << "coordinates_c = " << coordinates_c[0] << ", " << coordinates_c[1] << ", " << coordinates_c[2]
                   << endl;
              cerr << "coordinates_Cell = " << coordinates_Cell[0] << ", " << coordinates_Cell[1] << ", "
                   << coordinates_Cell[2] << endl;
              cerr << "volume_C = " << volume_C << endl;
              mTerm(1, AT_, "error in face");
            }
          }
        }
      }
    }

    ofl << "endsolid cutsurface " << endl;
  }
  ofl.close();
}

// ---------------------------------------------------------------------------------------------

/** \brief "hull" method for correctInflowBoundary(MInt, MFloat*&, MFloat*&) when meanNormal and basePoint are not
 *previously known
 *
 *	computes the mean normal to the surface with the boundary condition bcId (surface should be planar in .stl geometry
 *description!) and a reference point located in this plane (should correspond to the midpoint) and then calls
 *correctInflowBoundary(MInt, MFloat*&, MFloat*&) with these parameters
 *
 * \author Claudia Guenther, September 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::correctInflowBoundary(MInt bcId) {
  TRACE();

  MFloatScratchSpace meanNormal_scratch(nDim, AT_, "meanNormal_scratch");
  MFloat* meanNormal = meanNormal_scratch.getPointer();
  MFloatScratchSpace basePoint_scratch(nDim, AT_, "basePoint_scratch");
  MFloat* basePoint = basePoint_scratch.getPointer();
  for(MInt i = 0; i < 3; i++) {
    meanNormal[i] = F0;
    basePoint[i] = F0;
  }
  MInt noBcCells = 0;
  MFloat radius = F0;
  MFloat R = F0;
  MFloat referencePoint2[3] = {0.0, 0.0, 0.0};
  MFloat referencePoint[3] = {0.0, 0.0, 0.0};
  MInt noCells = m_bndryCells->size();
  MInt cellId;
  MFloat newArea = F0;
  MFloatScratchSpace comm_buff_scratch(5, AT_, "comm_buff_scratch");
  MFloatScratchSpace comm_buff_result_scratch(5, AT_, "comm_buff_result_scratch");
  MFloat* comm_buff = comm_buff_scratch.getPointer();
  MFloat* comm_buff_result = comm_buff_result_scratch.getPointer();

  // 0) compute referencePoint (a point located in the plane of bcId, preferably midpoint) and radius R of boundary
  // surface with bcId

  // first guess - take all cut surfaces with this bcId into account
  referencePoint2[0] = F0;
  referencePoint2[1] = F0;
  referencePoint2[2] = F0;
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == bcId) {
          noBcCells++;
          newArea += m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
          for(MInt i = 0; i < 3; i++) {
            referencePoint2[i] += m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i];
          }
        }
      }
    }
  }

  comm_buff[0] = newArea;
  comm_buff[1] = referencePoint2[0];
  comm_buff[2] = referencePoint2[1];
  comm_buff[3] = referencePoint2[2];
  comm_buff[4] = noBcCells;

  MPI_Allreduce(comm_buff, comm_buff_result, 5, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "comm_buff", "comm_buff_result");

  newArea = comm_buff_result[0];
  referencePoint2[0] = comm_buff_result[1];
  referencePoint2[1] = comm_buff_result[2];
  referencePoint2[2] = comm_buff_result[3];
  noBcCells = (MInt)comm_buff_result[4];

  for(MInt i = 0; i < 3; i++) {
    referencePoint2[i] /= noBcCells;
  }
  // take a smaller radius to generate a "trusted region" for the more precise computation
  R = 0.7 * sqrt(newArea / PI);

  // second run - only on trusted region surfaces
  newArea = F0;
  noBcCells = 0;
  referencePoint[0] = F0;
  referencePoint[1] = F0;
  referencePoint[2] = F0;
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        radius = sqrt(POW2(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[0] - referencePoint2[0])
                      + POW2(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[1] - referencePoint2[1])
                      + POW2(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[2] - referencePoint2[2]));
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == bcId && radius < R) {
          noBcCells++;
          newArea += m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
          for(MInt i = 0; i < 3; i++) {
            referencePoint[i] += m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i];
          }
        }
      }
    }
  }
  comm_buff[0] = newArea;
  comm_buff[1] = referencePoint[0];
  comm_buff[2] = referencePoint[1];
  comm_buff[3] = referencePoint[2];
  comm_buff[4] = noBcCells;

  MPI_Allreduce(comm_buff, comm_buff_result, 5, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "comm_buff", "comm_buff_result");

  newArea = comm_buff_result[0];
  referencePoint[0] = comm_buff_result[1];
  referencePoint[1] = comm_buff_result[2];
  referencePoint[2] = comm_buff_result[3];
  noBcCells = (MInt)comm_buff_result[4];
  for(MInt i = 0; i < 3; i++) {
    referencePoint[i] /= noBcCells;
  }
  noBcCells = 0;
  //   cerr << "bcId, referencePoint, R: " << bcId << ", " << referencePoint[0] << " "<< referencePoint[1] << " "<<
  //   referencePoint[2] << ", " << R << endl;

  // 1) compute mean normal of inflow boundary with correct referencePoint
  meanNormal[0] = F0;
  meanNormal[1] = F0;
  meanNormal[2] = F0;
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    cellId = m_bndryCells->a[bndryId].m_cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        radius = sqrt(POW2(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[0] - referencePoint[0])
                      + POW2(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[1] - referencePoint[1])
                      + POW2(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[2] - referencePoint[2]));
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId == bcId && radius < R) {
          noBcCells++;
          for(MInt i = 0; i < 3; i++) {
            meanNormal[i] += m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
          }
        }
      }
    }
  }
  comm_buff[0] = meanNormal[0];
  comm_buff[1] = meanNormal[1];
  comm_buff[2] = meanNormal[2];

  MPI_Allreduce(comm_buff, comm_buff_result, 3, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "comm_buff", "comm_buff_result");

  meanNormal[0] = comm_buff_result[0];
  meanNormal[1] = comm_buff_result[1];
  meanNormal[2] = comm_buff_result[2];
  for(MInt i = 0; i < 3; i++) {
    meanNormal[i] /= noBcCells;
    basePoint[i] = referencePoint[i];
  }

  // call "real" correctInflowBoundary routine
  cerr << " computed base point and normal of bcId " << bcId << " as: normal: " << meanNormal[0] << " " << meanNormal[1]
       << " " << meanNormal[2] << ". base point: " << basePoint[0] << " " << basePoint[1] << " " << basePoint[2]
       << endl;
  correctInflowBoundary(bcId, meanNormal, basePoint);
}

// ---------------------------------------------------------------------------------------------

/** \brief computes the intersection points of the feature edges with the target face (normal to dir)
 *
 *	input:
 *		target: three points that span the face which should be examined
 *		featureEdges: the feature edges identified for the respective cell (contains 2*noFeatureEdges entries, each edge
 *needs start and end point) noFeatureEdges: the number of edges in featureEdges dir: the direction normal to which
 *target is aligned return: intersectionPoints: here, the identified intersectionPoints are stored noIntersectionPoints:
 *here, the number of intersection points found is returned
 *
 * \author Claudia Guenther, August 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::getIntersectionPoints(MFloat**& target, MFloat**& featureEdges, MInt noFeatureEdges,
                                                       MInt dir, MFloat**& intersectionPoints,
                                                       MInt& noIntersectionPoints) {
  TRACE();
  MFloat* a; // 1. Corner
  MFloat* b; // 2. Corner
  MFloat* c; // 3. Corner
  MFloat* d; // Start Feature Edge
  MFloat* e; // End Feature Edge
  MFloat pP[3] = {0.0, 0.0, 0.0};
  MFloat gamma, s;
  MBool rejected = false;
  MBool accepted = false;
  MBool identical;
  MInt spaceId1, spaceId2;
  MFloat diff;
  MFloat eps;
  noIntersectionPoints = 0;

  a = target[0];
  b = target[1];
  c = target[2];

  spaceId1 = (dir + 1) % 3;
  spaceId2 = (dir + 2) % 3;

  eps = abs(a[spaceId1] - b[spaceId1]) / 100;

  for(MInt i = 0; i < noFeatureEdges; i++) {
    d = featureEdges[2 * i];
    e = featureEdges[2 * i + 1];

    rejected = false;
    accepted = false;

    if(d[dir] < a[dir] && e[dir] < a[dir])
      rejected = true;
    else if(d[dir] > a[dir] && e[dir] > a[dir])
      rejected = true;
    else if(d[dir] <= a[dir] && e[dir] >= a[dir])
      accepted = true;
    else if(d[dir] >= a[dir] && e[dir] <= a[dir])
      accepted = true;

    if(rejected == false && accepted == false) {
      cerr << "no trivial rejection, no trivial acception, continue..." << endl;
      continue;
    } else if(rejected) {
      continue;
    }

    gamma = ((e[0] - d[0]) * ((a[2] - c[2]) * (c[1] - b[1]) - (a[1] - c[1]) * (c[2] - b[2]))
             - (e[1] - d[1]) * ((a[2] - c[2]) * (c[0] - b[0]) - (a[0] - c[0]) * (c[2] - b[2]))
             + (e[2] - d[2]) * ((a[1] - c[1]) * (c[0] - b[0]) - (a[0] - c[0]) * (c[1] - b[1])));

    s = ((c[0] - d[0]) * ((a[2] - c[2]) * (c[1] - b[1]) - (a[1] - c[1]) * (c[2] - b[2]))
         - (c[1] - d[1]) * ((a[2] - c[2]) * (c[0] - b[0]) - (a[0] - c[0]) * (c[2] - b[2]))
         + (c[2] - d[2]) * ((a[1] - c[1]) * (c[0] - b[0]) - (a[0] - c[0]) * (c[1] - b[1])))
        / gamma;

    // 1. b Pierce point pP in plane j:
    for(MInt k = 0; k < 3; k++) {
      pP[k] = d[k] + s * (e[k] - d[k]);
    }

    // check if Pierce point is located in target => must be really in target, otherwise cutPoint
    if(mMin(a[spaceId1], b[spaceId1]) <= pP[spaceId1] && pP[spaceId1] <= mMax(a[spaceId1], b[spaceId1])) {
      if(mMin(a[spaceId2], c[spaceId2]) <= pP[spaceId2] && pP[spaceId2] <= mMax(a[spaceId2], c[spaceId2])) {
        identical = false;
        for(MInt j = 0; j < noIntersectionPoints; j++) {
          diff = sqrt(POW2(pP[0] - intersectionPoints[j][0]) + POW2(pP[1] - intersectionPoints[j][1])
                      + POW2(pP[2] - intersectionPoints[j][2]));
          if(diff < eps) {
            identical = true;
            break;
          }
        }
        if(!identical && noIntersectionPoints < 10) {
          for(MInt j = 0; j < 3; j++) {
            intersectionPoints[noIntersectionPoints][j] = pP[j];
          }
          noIntersectionPoints++;
        } else if(noIntersectionPoints == 10)
          cerr << "FvBndryCndXD::getIntersectionPoints - Error: Too many intersection points, array too small.."
               << endl;
      }
    }
  }
}

// ---------------------------------------------------------------------------------------------

/** \brief computes a list of .stl triangle edges which are adjacent to an inlet/outlet and a wall boundary condition
 *
 *	input:
 *		noWallNodes: number of nodes in wallNodes
 *		wallNodes: a list of the numbers of the nodes which are wall nodes
 *		meanNormal: the normal which defines the plane of the inflow/outflow boundary surface
 *   basePoint: a point in the inflow/outflow normal, preferably the midpoint
 *
 * return:
 *		noFeatureEdges: the number of identified feature edges is returned
 *		featureEdges: the feature edges identified for this set are stored here (contains 2*noFeatureEdges entries, each
 *edge has start and end point) a feature edge belongs to a node which is not aligned to the plane normal to meanNormal
 *but the feature edge itself is contained in this plane
 *
 * \author Claudia Guenther, August 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::getFeatureEdges(MInt& noFeatureEdges, MFloat**& featureEdges, MInt noWallNodes,
                                                 MInt*& wallNodes, MFloat*& meanNormal, MFloat*& basePoint) {
  TRACE();

  MFloat* edgeStart;
  MFloat* edgeEnd;
  MFloatScratchSpace edgeVec_scratch(nDim, AT_, "edgeVec_scratch");
  MFloat* edgeVec = edgeVec_scratch.getPointer();
  MInt index1;
  MInt index2;
  MFloat normalEps = 1e-3;
  MFloat planeEps = 1e-4;
  MBool normalTest;
  MBool planeTest1;
  MBool planeTest2;
  MFloat eps, diff;

  noFeatureEdges = 0;
  eps = 1e-5;

  for(MInt i = 0; i < noWallNodes; i++) {
    for(MInt j = 0; j < nDim; j++) {
      index1 = j;
      index2 = (j + 1) % nDim;

      edgeStart = m_solver->m_geometry->elements[wallNodes[i]].m_vertices[index1];
      edgeEnd = m_solver->m_geometry->elements[wallNodes[i]].m_vertices[index2];

      diff = sqrt(POW2(edgeStart[0] - edgeEnd[0]) + POW2(edgeStart[1] - edgeEnd[1]) + POW2(edgeStart[2] - edgeEnd[2]));
      if(diff < eps) {
        // 	cerr << "Warning - small Edge!" << endl;
        continue;
      }

      vecSub(edgeEnd, edgeStart, edgeVec);
      normalTest = (abs(inner_product(edgeVec, edgeVec + 3, meanNormal, 0.0)) < normalEps);

      vecSub(edgeStart, basePoint, edgeVec);
      planeTest1 = (abs(inner_product(edgeVec, edgeVec + 3, meanNormal, 0.0)) < planeEps);

      vecSub(edgeEnd, basePoint, edgeVec);
      planeTest2 = (abs(inner_product(edgeVec, edgeVec + 3, meanNormal, 0.0)) < planeEps);

      if(normalTest && (planeTest1 || planeTest2)) {
        featureEdges[2 * noFeatureEdges] = edgeStart;
        featureEdges[2 * noFeatureEdges + 1] = edgeEnd;

        noFeatureEdges++;
      }
    }
  }
}

// ---------------------------------------------------------------------------------------------

/** \brief computes a list of .stl triangle edges which are adjacent to an inlet/outlet and a wall boundary condition
 *
 *	input:
 *		bcId: the boundary condition id which should be conserved as a planar surface (inflow/outflow id)
 *		noNodes: number of nodes in nodeList
 *		nodeList: list of nodes which should be sorted
 *
 * return:
 *		wallNodes: a list of the numbers of the nodes which are wall nodes
 *		noWallNodes: number of nodes in wallNodes
 *		inflowNodes: a list of the numbers of the nodes which belong to bcId
 *		noInflowNodes: number of nodes in inflowNodes
 *
 * \author Claudia Guenther, August 2009
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::getSortedElements(const std::vector<MInt>& nodeList, MInt& noWallNodes,
                                                   MInt*& wallNodes, MInt& noInflowNodes, MInt*& inflowNodes,
                                                   MInt bcId) {
  TRACE();

  noInflowNodes = 0;
  noWallNodes = 0;
  for(MInt i = 0; i < (signed)nodeList.size(); i++) {
    if(m_solver->m_geometry->elements[nodeList[i]].m_bndCndId == bcId) {
      inflowNodes[(noInflowNodes)++] = nodeList[i];
    } else {
      wallNodes[(noWallNodes)++] = nodeList[i];
    }
  }
}

// ---------------------------------------------------------------------------------

/** \brief Computes the reconstruction constants for the interpolation of the image point variables with MGC formulation
 *
 * If the multiple ghost cells formulation is used where the ghost cells are located normal to
 * the boundary surfaces from the surface centroids, this function is needed to provide the reconstruction
 * stencil for the first interpolation on the image point variables. This interpolation uses the slopes
 * computed on the boundary cell which is based only on regular cells surrounding the respective boundary
 * cell without the ghost cells.
 *
 * Reconstruction constants are saved per boundary cell in the memory corresponding to the boundary cell/ bndryCondition
 * solver
 *
 * \author Claudia Guenther, Mai 2010
 */
template <MInt nDim, class SysEqn>
// template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::computeReconstructionConstants_interpolation() {
  TRACE();

  const MInt noSmallCells = m_smallBndryCells->size();
  const MInt noBndryCells = m_bndryCells->size();
  MInt bndryId, nghbrId, cellId, noNghbrIds, id;
  MInt noUnknowns = nDim;
  MFloatScratchSpace x_scratch(nDim, AT_, "x_scratch");
  MFloat* x = x_scratch.getPointer();
  //---


  // to make errors visible (if reconstruction constants are not set for certain cells)
  // initialize with non-sense number which will produce non-sense solutions
  for(bndryId = 0; bndryId < noBndryCells; bndryId++) {
    for(MInt n = 0; n < nDim * m_solver->m_cells.noRecNghbrs(); n++)
      m_reconstructionConstants[bndryId][n] = -9999;
  }

  // cell-center reconstruction
  for(bndryId = 0; bndryId < noBndryCells; bndryId++) {
    cellId = m_bndryCells->a[bndryId].m_cellId;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    if(m_bndryCells->a[bndryId].m_linkedCellId > -1) continue;

    noNghbrIds = m_solver->a_noReconstructionNeighbors(cellId);

    // loop over least-squares cell cluster
    for(MInt cell = 0; cell < noNghbrIds; cell++) {
      id = m_solver->a_reconstructionNeighborId(cellId, cell);
      if(!m_solver->a_isBndryGhostCell(id)) {
        for(MInt i = 0; i < nDim; i++) {
          x[i] = m_solver->a_coordinate(id, i);
        }
      } else {
        // do not take ghost cell	s into account
        for(MInt i = 0; i < nDim; i++)
          x[i] = m_solver->a_coordinate(cellId, i);
      }

      for(MInt i = 0; i < nDim; i++)
        m_solver->m_A[cell][i] = x[i] - m_solver->a_coordinate(cellId, i);
    }

    // compute ATA
    for(MInt i = 0; i < noUnknowns; i++) {
      for(MInt j = 0; j < noUnknowns; j++) {
        m_solver->m_ATA[i][j] = F0;
        for(MInt k = 0; k < noNghbrIds; k++) {
          m_solver->m_ATA[i][j] += m_solver->m_A[k][i] * m_solver->m_A[k][j];
        }
      }
    }

    // invert ATA
    const MFloat epsilon = POW3(m_solver->c_cellLengthAtLevel(m_solver->maxRefinementLevel()) / (1000.0));
    maia::math::inverse(m_solver->m_ATA, m_solver->m_ATAi, noUnknowns, epsilon);

    // compute (ATA)^(-1) * AT
    for(MInt i = 0; i < noUnknowns; i++) {
      for(MInt j = 0; j < noNghbrIds; j++) {
        m_solver->m_ATA[i][j] = F0;
        for(MInt k = 0; k < noUnknowns; k++) {
          m_solver->m_ATA[i][j] += m_solver->m_ATAi[i][k] * m_solver->m_A[j][k];
        }
      }
    }

    // loop over least-squares cell cluster
    for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
      nghbrId = m_solver->a_reconstructionNeighborId(cellId, nghbr);

      // compute the constants
      if(!m_solver->a_isBndryGhostCell(nghbrId))
        for(MInt i = 0; i < nDim; i++)
          m_reconstructionConstants[bndryId][nDim * nghbr + i] = m_solver->m_ATA[i][nghbr];
      else
        for(MInt i = 0; i < nDim; i++)
          m_reconstructionConstants[bndryId][nDim * nghbr + i] = F0;
    }
  }

  // loop over all slave cells which are regular computing cells on the current level
  for(MInt sid = 0; sid < noSmallCells; sid++) {
    bndryId = m_smallBndryCells->a[sid];
    cellId = m_bndryCells->a[bndryId].m_linkedCellId;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(!m_solver->a_hasProperty(m_bndryCells->a[bndryId].m_cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsFlux)) continue;
    if(m_solver->a_isBndryGhostCell(cellId)) continue;
    if(m_solver->a_isBndryGhostCell(m_bndryCells->a[bndryId].m_cellId)) continue;
    // 		if( m_solver->a_hasProperty( cellId , SolverCell::IsCutOff) )
    // 			continue;
    // 		if( m_solver->a_hasProperty( m_bndryCells->a[bndryId].m_cellId , SolverCell::IsCutOff) )
    // 			continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    if(m_solver->a_hasProperty(m_bndryCells->a[bndryId].m_cellId, SolverCell::IsNotGradient)) continue;

    // take all neighbors of the master cell
    noNghbrIds = m_solver->a_noReconstructionNeighbors(cellId);

    // loop over least-squares cell cluster
    for(MInt cell = 0; cell < noNghbrIds; cell++) {
      id = m_solver->a_reconstructionNeighborId(cellId, cell);
      if(!m_solver->a_isBndryGhostCell(id)) {
        for(MInt i = 0; i < nDim; i++) {
          x[i] = m_solver->a_coordinate(id, i);
        }
      } else {
        // do not take ghost cells into account
        for(MInt i = 0; i < nDim; i++)
          x[i] = m_solver->a_coordinate(cellId, i);
      }

      for(MInt i = 0; i < nDim; i++)
        m_solver->m_A[cell][i] = x[i] - m_solver->a_coordinate(cellId, i);
    }

    // compute ATA
    for(MInt i = 0; i < noUnknowns; i++) {
      for(MInt j = 0; j < noUnknowns; j++) {
        m_solver->m_ATA[i][j] = F0;
        for(MInt k = 0; k < noNghbrIds; k++) {
          m_solver->m_ATA[i][j] += m_solver->m_A[k][i] * m_solver->m_A[k][j];
        }
      }
    }

    // invert ATA
    const MFloat epsilon = POW3(m_solver->c_cellLengthAtLevel(m_solver->maxRefinementLevel()) / (1000.0));
    maia::math::inverse(m_solver->m_ATA, m_solver->m_ATAi, noUnknowns, epsilon);

    // compute (ATA)^(-1) * AT
    for(MInt i = 0; i < noUnknowns; i++) {
      for(MInt j = 0; j < noNghbrIds; j++) {
        m_solver->m_ATA[i][j] = F0;
        for(MInt k = 0; k < noUnknowns; k++) {
          m_solver->m_ATA[i][j] += m_solver->m_ATAi[i][k] * m_solver->m_A[j][k];
        }
      }
    }

    // loop over least-squares cell cluster
    for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
      nghbrId = m_solver->a_reconstructionNeighborId(cellId, nghbr);

      // compute the constants
      if(!m_solver->a_isBndryGhostCell(nghbrId))
        for(MInt i = 0; i < nDim; i++)
          m_reconstructionConstants[bndryId][nDim * nghbr + i] = m_solver->m_ATA[i][nghbr];
      else
        for(MInt i = 0; i < nDim; i++)
          m_reconstructionConstants[bndryId][nDim * nghbr + i] = F0;
    }
  }
}
// template void FvBndryCndXD<3, FvSysEqnRANS<3>>::computeReconstructionConstants_interpolation();
// template void FvBndryCndXD<3, FvSysEqnNS<3>>::computeReconstructionConstants_interpolation();
#undef plotall

////////////////////////////////////////////////////////////////////////////////
/// ONLY 2D VERSIONS
////////////////////////////////////////////////////////////////////////////////
/**
 * \brief computes centroid and area of a N-point polygon
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 2, _*>>
void FvBndryCndXD<nDim, SysEqn>::computePolygon(MFloat* x, const MInt N, MFloat* centroid, MFloat* area) {
  TRACE();
  MFloat tmp = F0;
  if(N < 3) {
    cerr << "Warning: Insufficient amount of points provided in FvBndryCndXD::computePolygon(...)." << endl;
  } else if(N == 3) {
    centroid[0] = F1B3 * (x[0] + x[2] + x[4]);
    centroid[1] = F1B3 * (x[1] + x[3] + x[5]);
    *area = F1B2 * fabs(((x[0] - x[4]) * (x[3] - x[1])) - ((x[0] - x[2]) * (x[5] - x[1])));
  } else {
    centroid[0] = F0;
    centroid[1] = F0;
    *area = F0;
    for(MInt i = 0; i < N; i++) {
      tmp = x[i * 2] * x[((i + 1) % N) * 2 + 1] - x[i * 2 + 1] * x[((i + 1) % N) * 2];
      *area += tmp;
      centroid[0] += tmp * (x[i * 2] + x[((i + 1) % N) * 2]);
      centroid[1] += tmp * (x[i * 2 + 1] + x[((i + 1) % N) * 2 + 1]);
    }
    centroid[0] /= (F3 * (*area));
    centroid[1] /= (F3 * (*area));
    *area = F1B2 * fabs((*area));
  }
}

/** \brief Initiates CBC boundary conditions
 * \author Thomas Hoesgen
 * \date May 2020
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bcInitCbc(MInt bcId) {
  TRACE();
  TERMM_IF_COND(m_solver->m_reConstSVDWeightMode == 3 || m_solver->m_reConstSVDWeightMode == 4,
                "Possibly not yet implemented!");

  MInt cbcId = m_cbcBndryCndIds[bcId];
  // Store the cbc flow directions
  MInt otherDir[2 * nDim];
  for(MInt dim = 0; dim < nDim; dim++) {
    otherDir[2 * dim] = 2 * dim + 1;
    otherDir[2 * dim + 1] = 2 * dim;
  }
  MInt direction = Context::getSolverProperty<MInt>("cutOffDirections", m_solverId, AT_, cbcId);
  std::vector<MInt> dirs;
  dirs.resize(nDim + 1);
  dirs[0] = otherDir[direction];
  dirs[1] = (MInt)dirs[0] / 2;
  dirs[2] = (dirs[1] + 1) % nDim;
  IF_CONSTEXPR(nDim == 3) { dirs[nDim] = (dirs[2] + 1) % nDim; }
  m_cbcDir[cbcId] = dirs;

  // Store the cbc relaxation coefficients
  std::vector<MFloat> relaxCoef;
  relaxCoef.resize(CV->noVariables);
  for(MInt var = 0; var < CV->noVariables; var++) {
    MInt ind = var + CV->noVariables * cbcId;
    relaxCoef[var] = Context::getSolverProperty<MFloat>("cbcRelaxation", m_solverId, AT_, ind);
  }
  m_cbcRelax[cbcId] = relaxCoef;
  // Store the cbc reference length
  MInt dimN = dirs[1];
  MFloat tmp[nDim * 2];
  if(m_solver->m_geometry->GetNoElements() < 1) {
    m_solver->m_geometry->getBoundingBoxMB(tmp);
  } else {
    m_solver->m_geometry->getBoundingBox(tmp);
  }
  m_cbcLref[cbcId] = (tmp[dimN + nDim] - tmp[dimN]);
  // new cbcLref calculation based on cutOff rather than Bounding box from stl
  if(Context::propertyExists("cutOffCoordinates", m_solverId) && Context::propertyExists("cutOffMethod", m_solverId)
     && Context::getSolverProperty<MString>("cutOffMethod", m_solverId, AT_) == "B") {
    std::vector<MFloat> cutOffCoordinates;
    cutOffCoordinates.resize(2 * nDim);
    for(MInt i = 0; i < (2 * nDim); i++) {
      cutOffCoordinates[i] = Context::getSolverProperty<MFloat>("cutOffCoordinates", m_solverId, AT_, i);
    }
    if(cutOffCoordinates[dimN + nDim] - cutOffCoordinates[dimN] < m_cbcLref[cbcId]) {
      m_cbcLref[cbcId] = cutOffCoordinates[dimN + nDim] - cutOffCoordinates[dimN];
    }
  }

  // needed for turbulence injection, always on (set stresses in property file to 0.0 if unwanted)
  m_cbcTurbulence = false;
  m_cbcTurbulence = Context::getSolverProperty<MBool>("cbcTurbulenceGeneration", m_solverId, AT_, &m_cbcTurbulence);
  if(m_cbcTurbulence) {
    bcInit1601(bcId);
    if(m_sortedCutOffCells[bcId]->size() > 0) {
      mDeallocate(m_oldFluctChol);
      mAlloc(m_oldFluctChol, m_sortedCutOffCells[bcId]->size(), nDim, "m_oldFluctChol", F0, AT_);
    }
  }
  if(m_sortedCutOffCells[bcId]->size() < 1) return;
  // Compute cbc inflow area
  MInt dirN = dirs[0];
  std::vector<MFloat> refPoint;
  refPoint.resize(nDim);
  m_cbcInflowArea[cbcId] = computeCutoffBoundaryGeometry(bcId, dirN, &refPoint[0]);

  // Store cbc reference point
  m_cbcReferencePoint[cbcId] = refPoint;

  // set default direction values;
  m_dirNormal[cbcId].resize(nDim);
  m_dirTangent[cbcId].resize(nDim);

  m_dirNormal[cbcId][m_cbcDir[cbcId][1]] = 1.0;
  m_dirNormal[cbcId][m_cbcDir[cbcId][2]] = 0.0;
  IF_CONSTEXPR(nDim == 3) { m_dirNormal[cbcId][m_cbcDir[cbcId][3]] = 0.0; }

  m_dirTangent[cbcId][m_cbcDir[cbcId][1]] = 0.0;
  m_dirTangent[cbcId][m_cbcDir[cbcId][2]] = 1.0;
  IF_CONSTEXPR(nDim == 3) { m_dirTangent[cbcId][m_cbcDir[cbcId][3]] = 0.0; }

  // Calculate tangential directions
  if(Context::propertyExists("cbcNormalDir")) {
    for(MInt n = 0; n < nDim; n++) {
      m_dirNormal[cbcId][n] = Context::getSolverProperty<MFloat>("cbcNormalDir", m_solverId, AT_, nDim * cbcId + n);
    }
    m_dirTangent[cbcId][m_cbcDir[cbcId][1]] =
        sqrt(POW2(m_dirNormal[cbcId][m_cbcDir[cbcId][2]] / m_dirNormal[cbcId][m_cbcDir[cbcId][1]])
             / (1 + POW2(m_dirNormal[cbcId][m_cbcDir[cbcId][2]] / m_dirNormal[cbcId][m_cbcDir[cbcId][1]])));
    m_dirTangent[cbcId][m_cbcDir[cbcId][2]] = sqrt(1 - POW2(m_dirTangent[cbcId][m_cbcDir[cbcId][1]]));
    IF_CONSTEXPR(nDim == 3) { m_dirTangent[cbcId][m_cbcDir[cbcId][3]] = 0; }
  }
  // Activate viscous terms
  m_cbcViscous = false;
  m_cbcViscous = Context::getSolverProperty<MBool>("cbcViscous", m_solverId, AT_, &m_cbcViscous);

  MInt domainMin = domainId();
  if(noDomains() > 1) {
    MPI_Allreduce(MPI_IN_PLACE, &domainMin, 1, MPI_INT, MPI_MIN, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                  "MPI_IN_PLACE", "domainMin");
  }
  m_cbcDomainMin[cbcId] = domainMin;

  if(domainId() == m_cbcDomainMin[cbcId]) {
    cerr << " Characteristic length is " << m_cbcLref[cbcId] << endl;
    cerr << bcId << " Normal vector is     : " << m_dirNormal[cbcId][0] << " " << m_dirNormal[cbcId][1] << endl;
    IF_CONSTEXPR(nDim == 3) { cerr << " " << m_dirNormal[cbcId][2] << endl; }
    cerr << bcId << " Tangential vector is : " << m_dirTangent[cbcId][0] << " " << m_dirTangent[cbcId][1] << endl;
    IF_CONSTEXPR(nDim == 3) { cerr << " " << m_dirTangent[cbcId][2] << endl; }
    cerr << bcId << " Inflow normal Area is: " << m_cbcInflowArea[cbcId] << endl;
  }

  if(m_cutOffBndryCndIds[bcId] == 109910 || m_cutOffBndryCndIds[bcId] == 109911) {
    // Read BC data
    stringstream fn;
    fn.clear();
    fn << "bc109910.txt";
    MString fname = fn.str();
    if(domainId() == m_cbcDomainMin[cbcId]) cerr << "loading BC data from " << fname << "...";

    ifstream unData;
    unData.open(fname);
    vector<MFloat> data;
    MFloat num;
    string line;

    while(unData >> num) {
      data.push_back(num);
    }

    // MInt count = 0;
    MInt unDataVarCount = Context::getSolverProperty<MInt>("bc109910DataCount", m_solverId, AT_, &unDataVarCount); // 14
    m_unTargetDataCount = data.size() / unDataVarCount;
    mAlloc(m_unTargetData, m_unTargetDataCount, "m_unTargetData", AT_);

    for(MInt d = 0; d < m_unTargetDataCount; d++) {
      MInt index = unDataVarCount * d;
      MFloat y = data[index];
      MFloat un = data[index + 1];
      m_unTargetData[d] = make_pair(y, un);
    }

    unData.close();
  }

  if(m_cutOffBndryCndIds[bcId] == 109921) {
    // Read BC data
    stringstream fn;
    fn.clear();
    fn << "bc109921.txt";
    MString fname = fn.str();
    if(m_solver->domainId() == 0) cerr << "loading BC data from " << fname << "...";

    ifstream vnData;
    vnData.open(fname);
    vector<MFloat> data;
    MFloat num;
    string line;

    while(vnData >> num) {
      data.push_back(num);
    }

    // MInt count = 0;
    MInt vnDataVarCount = 13;
    m_vnTargetDataCount = data.size() / vnDataVarCount;
    mAlloc(m_vnTargetData, m_vnTargetDataCount, "m_vnTargetData", AT_);

    for(MInt d = 0; d < m_vnTargetDataCount; d++) {
      MInt index = vnDataVarCount * d;
      MFloat y = data[index];
      MFloat vn = data[index + 2];
      m_vnTargetData[d] = make_pair(y, vn);
    }

    vnData.close();
  }
}

/**
 * \brief Initialize the small-cell RHS correction for the RHS interpolation method
 *        The cell vars are computed using a weighted least squares approach
 *        For details see Schneiders,Hartmann,Meinke,Schrder, J.Comput.Phys. 235 (2013)
 *        For more details see the dissertation of Lennart Schneiders, "Particle-Resolved
 *        Analysis of Turbulent Multiphase Flow by a Cut-Cell Method" Chapter 3.4
 *        If bndryCndId is specified (standard value=-1) only boundary cells corresponding
 *        to the stated boundary are initialized
 * \author Lennart Schneiders
 * \modified Felix Wietbuescher
 */
template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::initSmallCellRHSCorrection(MInt updateOnlyBndryCndId) {
  TRACE();

  const MInt minRecDim = nDim + 1;
  const MInt medRecDim = 2 * nDim + 1;
  const MInt maxRecDim = m_secondOrderRec ? (IPOW2(nDim) + 2) : minRecDim;
  const MInt noBndryCells = m_bndryCells->size();
  const MInt maxNoSrfcs = 14;
  const MInt volFactor = nDim == 3 ? 4 : 2;
  if(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces > maxNoSrfcs) {
    mTerm(1, AT_, "Increase maxNoSrfcs. " + to_string(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces));
  }
  const MInt maxNoNghbrs = 200;
  const MFloat condNumThreshold = 1e7;
  if(updateOnlyBndryCndId < 0) {
    m_log << "Initializing small cell RHS treatment." << endl;
  }

  MFloatScratchSpace normal(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, nDim, AT_, "normal");
  MFloatScratchSpace deltaXSurf(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, nDim, AT_, "deltaXSurf");
  MFloatScratchSpace deltaXSurfProj(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, nDim, AT_, "deltaXSurfProj");
  MFloatScratchSpace deltaNSurf(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, AT_, "deltaNSurf");
  MFloatScratchSpace backup(FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, maxRecDim, AT_, "backup");
  MFloatScratchSpace mat(maxNoNghbrs, maxRecDim, AT_, "mat_smallCells");
  MFloatScratchSpace matInv(maxRecDim, maxNoNghbrs, AT_, "matInv");
  MFloatScratchSpace weights(maxNoNghbrs, AT_, "weights");

  MFloat maxCondNum0 = F0;
  MFloat maxCondNum1 = F0;
  MFloat avgCondNum0 = F0;
  MFloat avgCondNum1 = F0;
  MFloat condCnt0 = F0;
  MFloat condCnt1 = F0;

  m_smallCutCells.clear();
  for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    const MInt noSrfcs = m_bndryCells->a[bndryId].m_noSrfcs;
    MInt gridcellId = cellId;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsSplitClone)) {
      gridcellId = m_solver->m_splitChildToSplitCell.find(cellId)->second;
    }

    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      continue;
    }
    if(m_solver->a_hasProperty(cellId, SolverCell::IsNotGradient)) {
      continue;
    }
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsSplitChild) && m_solver->c_noChildren(gridcellId) > 0) {
      continue;
    }
    if(m_solver->a_hasProperty(cellId, SolverCell::IsSplitCell)) {
      continue;
    }
    if(m_solver->a_isPeriodic(cellId)) {
      continue;
    }
    if(m_solver->a_isHalo(cellId)) {
      continue;
    }

    // commented version also applies smallCellCorrection for cutCells on lower levels, however
    // they only need to be stabilised if their volume falls below the threshold of the fines cells!
    // maxLevelChange
    MFloat vfrac = m_solver->a_cellVolume(cellId) / m_solver->grid().gridCellVolume(m_solver->maxLevel());
    if(m_solver->m_localTS) {
      vfrac = m_solver->a_cellVolume(cellId) / m_solver->grid().gridCellVolume(m_solver->a_level(cellId));
    }

    MBool atWall = false;
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      if(m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId / 1000 == 3) {
        atWall = true;
      }
    }
    MFloat volumeLimit = atWall ? m_volumeLimitWall : m_volumeLimitOther;

    if(m_solver->a_level(cellId) < m_solver->maxLevel() && m_solver->m_bndryLevelJumps) {
      volumeLimit = volumeLimit * volFactor * (m_solver->maxLevel() - m_solver->a_level(cellId));
    }

    if(vfrac < volumeLimit) {
      m_smallCutCells.push_back(bndryId);
    }

    MBool skip = false;
    if(updateOnlyBndryCndId > -1) {
      skip = true;
      for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
        if(m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId == updateOnlyBndryCndId) {
          skip = false;
        }
      }
    }
#ifndef NDEBUG
    if(skip && vfrac < volumeLimit
       && m_bndryCell[bndryId].m_cellVarsRecConst.size()
              != IPOW2(noSrfcs) * m_bndryCell[bndryId].m_recNghbrIds.size()) {
      cerr << domainId() << ": strange skip " << cellId << " " << m_solver->c_globalId(cellId) << endl;
    }
#endif
    if(skip) {
      continue;
    }


    const MFloat normalizationFactor = FPOW2(m_solver->a_level(cellId)) / m_solver->c_cellLengthAtLevel(0);
    // scaling factor to reduce the condition number of the resulting eq. sys.
    const MInt recSize = m_bndryCell[bndryId].m_recNghbrIds.size();
    ASSERT(recSize > 0, "");

    mat.fill(F0);
    weights.fill(F0);

    const MInt recDim = maxRecDim;
    ASSERT(minRecDim, "");
    ASSERT(medRecDim, "");

    for(MInt k = noSrfcs + 1; k < recSize; k++) { // Srfcs and smallCell itself not used
      MInt nghbrId = m_bndryCell[bndryId].m_recNghbrIds[k];
      MFloat* nghbrCoord = &(m_solver->a_coordinate(nghbrId, 0));
      MInt nghbrLevel = m_solver->a_level(nghbrId);
      MFloat volume = m_solver->a_cellVolume(nghbrId);
      array<MFloat, nDim> deltaX;
      MFloat dx = F0;
      for(MInt i = 0; i < nDim; i++) {
        deltaX[i] = (nghbrCoord[i] - m_solver->a_coordinate(cellId, i)) * normalizationFactor;
        dx += POW2(nghbrCoord[i] - m_solver->a_coordinate(cellId, i));
      }

      MFloat vfracNghbr = volume / m_solver->grid().gridCellVolume(nghbrLevel);
      weights(k) = maia::math::RBF(dx, POW2(m_solver->c_cellLengthAtLevel(m_solver->a_level(cellId))))
                   * maia::math::deltaFun(vfracNghbr, 1e-8, 1.0);

      MInt cnt = 0;
      mat(k, cnt) = F1;
      cnt++;
      for(MInt i = 0; i < nDim; i++) {
        mat(k, cnt) = deltaX[i];
        cnt++;
      }
      for(MInt i = 0; i < nDim; i++) {
        if(cnt >= recDim) {
          continue;
        }
        mat(k, cnt) = F1B2 * POW2(deltaX[i]);
        cnt++;
      }
      for(MInt i = 0; i < nDim; i++) {
        for(MInt j = i + 1; j < nDim; j++) {
          if(cnt >= recDim) {
            continue;
          }
          mat(k, cnt) = deltaX[i] * deltaX[j];
          cnt++;
        }
      }
    }

    maia::math::invert(mat, weights, matInv, recSize, recDim);
    const MFloat condNum = maia::math::frobeniusMatrixNormSquared(mat, recSize, recDim);

    maxCondNum0 = mMax(maxCondNum0, condNum);
    avgCondNum0 += condNum;
    condCnt0 += F1;
    if(condNum < F0 || condNum > condNumThreshold) {
      cerr << "(1) Warning: SVD failed (" << condNum << ") cell " << cellId << " (" << m_solver->c_globalId(cellId)
           << ") "
           << ", " << recSize << "x" << recDim << " vfrac " << setprecision(14)
           << m_bndryCells->a[bndryId].m_volume / m_solver->grid().gridCellVolume(m_solver->a_level(cellId))
           << setprecision(6) << ", p13: " << m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)
           << ", p15: " << m_solver->a_isHalo(cellId) << " at timestep " << globalTimeStep
           << ", coords: " << m_solver->a_coordinate(cellId, 0) << " " << m_solver->a_coordinate(cellId, 10) << " "
           << m_solver->a_coordinate(cellId, mMin(nDim - 1, 2)) << endl;
      const MFloat rank = maia::math::invertR(mat, weights, matInv, recSize, minRecDim);
      if(rank >= min(recSize, minRecDim)) {
        cerr << "Succeeded using reduced-order reconstruction." << endl;
      } else {
        cerr << "Failed also with reduced-order reconstruction, using fallback solution." << endl;
      }
    }

    for(MInt k = 0; k < recSize; k++) {
      MInt cnt = 1;
      for(MInt i = 0; i < nDim; i++) {
        matInv(cnt, k) *= normalizationFactor;
        cnt++;
      }
      for(cnt = nDim + 1; cnt < recDim; cnt++) {
        matInv(cnt, k) *= POW2(normalizationFactor);
      }
    }

    // for single boundary surface there is a Dirichlet and a Neumann stencil for the different
    // boundary conditions for multiple boundary surfaces, there can be combinations of
    // Neumann-Dirichlet or Dirichlet-Neumann boundary conditions, e.g., when a solid wall and an
    // outflow boundary intersect the cell, therefore IPOW2[noSrfcs] combinations
    m_bndryCell[bndryId].m_cellVarsRecConst.resize(recSize * IPOW2(noSrfcs));
    for(MInt p = 0; p < recSize; p++) {
      m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * p] = matInv(0, p);
    }

    if(condNum < F0 || condNum > condNumThreshold) {
      MFloat sumcnt = F0;
      for(MInt k = 0; k < recSize; k++) {
        const MInt nghbrId = m_bndryCell[bndryId].m_recNghbrIds[k];
        m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * k] = F0;
        if(k < noSrfcs + 1) {
          continue;
        }
        if(nghbrId == cellId) {
          continue;
        }
        MFloat dx = F0;
        MFloat volume = F0;
        MInt level = -1;
        volume = m_solver->a_cellVolume(nghbrId);
        for(MInt i = 0; i < nDim; i++) {
          dx += POW2(m_solver->a_coordinate(nghbrId, i) - m_solver->a_coordinate(cellId, i));
        }
        level = m_solver->a_level(nghbrId);
        MFloat fac = maia::math::deltaFun(volume / m_solver->grid().gridCellVolume(level), 1e-8, 1.0);
        m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * k] = fac / mMax(1e-14, sqrt(dx));
        sumcnt += m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * k];
      }
      for(MInt k = 0; k < recSize; k++) {
        m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * k] /= sumcnt;
      }
      cerr << m_solver->c_globalId(cellId) << " has special con.Numer treatment" << endl;
    }
  }

  if(updateOnlyBndryCndId < 0 || globalTimeStep % 100 == 0) {
    m_log << "Small cell treatment average (maximum) condition numbers == Dirichlet stencil: " << avgCondNum0 / condCnt0
          << " (" << maxCondNum0 << "), Neumann stencil: " << avgCondNum1 / condCnt1 << " (" << maxCondNum1 << ")."
          << endl;
    MInt noSmallCells = m_smallCutCells.size();
    if(updateOnlyBndryCndId < 0 || globalTimeStep <= 0) {
      MPI_Allreduce(MPI_IN_PLACE, &noSmallCells, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "noSmallCells");
    }
    m_log << "Number of small cut cells for flux redistribution: " << noSmallCells << " in solver " << m_solverId
          << endl;
  }
}

template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvBndryCndXD<nDim, SysEqn>::cbc1099_1091_engineOld(MInt bcId) {
  TRACE();
  ASSERT(m_cbcCutOff, "");

  if(m_sortedCutOffCells[bcId]->size() == 0) {
    return;
  }

  // debug, should be true
  const MBool transversal = false;

  const MInt otherDir[6] = {1, 0, 3, 2, 5, 4};

  MBool& first = m_static_cbc1099_1091_engine_first;
  MInt& dirN = m_static_cbc1099_1091_engine_dirN;
  MInt& dimN = m_static_cbc1099_1091_engine_dimN;
  MInt& dimT1 = m_static_cbc1099_1091_engine_dimT1;
  MFloat& inflowArea = m_static_cbc1099_1091_engine_inflowArea;
  MInt& domainMin = m_static_cbc1099_1091_engine_domainMin;

  MFloat(&dirNormal)[3] = m_static_cbc1099_1091_engine_normal;
  MFloat(&dirTangent)[3] = m_static_cbc1099_1091_engine_tangent;

  MInt& dimT2 = m_static_cbc1099_1091_engine_dimT2;

  if(first) {
    MInt noCutOffBndryIds = Context::propertyLength("cutOffBndryIds", m_solverId);
    MInt noCutOffDirections = Context::propertyLength("cutOffDirections", m_solverId);
    if(noCutOffDirections != noCutOffBndryIds) {
      mTerm(1, AT_,
            "Wrong number of cut off directions. Must be identical to number of cut off bndryIds! Please check!");
    }
    MInt cutOffBndryIdTmp, cutOffDirectionTmp;
    for(MInt i = 0; i < noCutOffBndryIds; i++) {
      cutOffBndryIdTmp = Context::getSolverProperty<MInt>("cutOffBndryIds", m_solverId, AT_, i);
      cutOffDirectionTmp = Context::getSolverProperty<MInt>("cutOffDirections", m_solverId, AT_, i);
      if(cutOffBndryIdTmp == m_cutOffBndryCndIds[bcId]) {
        dirN = otherDir[cutOffDirectionTmp];
        break;
      }
    }
    dimN = (MInt)dirN / 2;
    dimT1 = (dimN + 1) % nDim;

    MFloatScratchSpace referencePoint_Scratch(3, AT_, "referencePoint_Scratch");
    MFloat* referencePoint = referencePoint_Scratch.getPointer();

    inflowArea = computeCutoffBoundaryGeometry(bcId, dirN, referencePoint);

    dimT2 = (dimT1 + 1) % nDim;

    domainMin = domainId();
    if(noDomains() > 1) {
      MPI_Allreduce(MPI_IN_PLACE, &domainMin, 1, MPI_INT, MPI_MIN, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                    "MPI_IN_PLACE", "domainMin");
    }

    first = false;

    MFloat tmp1[2 * nDim];
    m_solver->m_geometry->getBoundingBox(tmp1);
    // xmin, ymin, zmin, xmax, ymax, zmax
    // full domain-size!
    MFloat LN1 = (tmp1[dimN + nDim] - tmp1[dimN]);

    if(LN1 < m_solver->m_eps || std::isnan(LN1)) {
      m_solver->m_geometry->getBoundingBoxMB(tmp1);
      LN1 = (tmp1[dimN + nDim] - tmp1[dimN]);
    }

    if(domainId() == domainMin) {
      cerr << " Characteristic length is " << LN1 << endl;
    }

    for(MInt n = 0; n < 3; n++) {
      dirNormal[n] = -2;
      dirTangent[n] = -2;
    }

    /*! \page propertiesFV
      \section cbcNormalDir
      <code>MFloat FvCartesianSolver::cbc1099_1091_engine::dirNormal </code>\n
      default = <code>-2</code>\n \n
      Specify the vector of the cut-Off bndry Normal,
      if the bndry does not align with the cartesian direction! \n
      <ul>
      <li> nDim floating array </li>
      </ul>
      Keywords: <i>CBC, ENGINE, CHARACTERISTIC BNDRY-CONDITION </i>
    */

    if(Context::propertyExists("cbcNormalDir")) {
      for(MInt n = 0; n < nDim; n++) {
        dirNormal[n] = Context::getSolverProperty<MFloat>("cbcNormalDir", m_solverId, AT_, nDim * bcId + n);
      }

      dirTangent[0] = sqrt(POW2(dirNormal[1] / dirNormal[0]) / (1 + POW2(dirNormal[1] / dirNormal[0])));
      dirTangent[1] = sqrt(1 - POW2(dirTangent[0]));
      dirTangent[2] = 0;

      if(dirNormal[0] > -2) {
        inflowArea = inflowArea * dirTangent[1];
      }
    }

    if(domainId() == domainMin && dirNormal[0] > -2) {
      cerr << bcId << " Normal vector is     : " << dirNormal[0] << " " << dirNormal[1] << " " << dirNormal[2] << endl;
      cerr << bcId << " Tangential vector is : " << dirTangent[0] << " " << dirTangent[1] << " " << dirTangent[2]
           << endl;
      cerr << bcId << " Inflow normal Area is: " << inflowArea << endl;
    }
  }

  ASSERT(dimN >= 0 && dimT1 >= 0, "No initialisation for this rank!");

  MFloat eta2 = -0.28;
  MFloat eta3 = 0.28;
  MFloat sigma = 3.5;

  // reducing sigma at inflow and outflow globally to hanlde incoming eddies is not working!
  // trying global sigma increase!
  // trying local sigma reduction for eddy detection!

  // increase sigma at outflow!
  if(dirN % 2 == 0 && m_solver->m_engineSetup) {
    sigma = 6.5;
    eta2 = -4.5;
  }

  // for diagonal in/out-flow the sponging values need to have the same magnitude!
  if(dirNormal[0] > -2) {
    sigma = 4.5;
    eta2 = -4.5;
    eta3 = 4.5;
  }

  const MFloat sigma_Inflow = sigma;
  const MFloat sigma_Outflow = sigma;

  // literature values:
  // for stationary variable: +-0.278
  // for instationary values: 3-5
  // for outflow when coupled with inflow: sigma_Outflow = 0

  MFloat tmp[2 * nDim];
  m_solver->m_geometry->getBoundingBox(tmp); // xmin, ymin, zmin, xmax, ymax, zmax
  // full domain-size!
  MFloat LN = (tmp[dimN + nDim] - tmp[dimN]);

  if(LN < m_solver->m_eps || std::isnan(LN)) {
    m_solver->m_geometry->getBoundingBoxMB(tmp);
    LN = (tmp[dimN + nDim] - tmp[dimN]);
  }
  // reduce LN at outflow (possibly only when the valve is closed!)
  if(dirN % 2 == 0) {
    LN = LN / 2;
  } else {
  }
  // for closed vales the value should be halfed => sigma doubled!

  //---

  MFloat massflux = F0;
  MFloat M_max = MFloatEps;
  MFloat M_mean = F0;
  MFloat T_mean = F0;
  MFloat rho_mean = F0;
  MFloat rho_max = F0;
  MFloat rho_min = 99;

  MFloat massflux_pos = F0;
  MFloat massflux_neg = F0;
  MFloat area_pos = F0;
  MFloat area_neg = F0;

  // first: compute maximum and average mach number over boundary surface
  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    const MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    const MInt bndryId = m_solver->a_bndryId(cellId);
    MFloat area = -1;
    if(bndryId > -1) {
      // identify the "boundary surface" between cutoff boundary cell and neighboring layer cell if cell is a boundary
      // cell
      MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dirN];
      if(srfcId > -1) {
        area = m_solver->a_surfaceArea(srfcId);
        ASSERT(area <= POW2(m_solver->c_cellLengthAtCell(cellId)), "");

      } else {
        for(MInt dir = 0; dir < m_noDirs; dir++) {
          srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dir];
          if(srfcId > -1) break;
        }
        if(srfcId == -1) {
          mTerm(1, AT_, "something went wrong!");
        }
        area = m_solver->a_surfaceArea(srfcId);
      }
    } else {
      area = POW2(m_solver->c_cellLengthAtCell(cellId));
    }

    ASSERT(area > 0, "");

    // recompute area
    if(dirNormal[0] > -2) {
      area = area * dirTangent[1];
    }

    // NOTE: update primary Variables for all used cutOff cells!
    m_solver->setPrimitiveVariables(cellId);

    // cell properties and cell normal velocity
    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    const MFloat p = m_solver->a_pvariable(cellId, PV->P);
    const MFloat T = sysEqn().temperature_ES(rho, p);
    const MFloat a = sysEqn().speedOfSound(T);

    MFloat un = m_solver->a_pvariable(cellId, PV->VV[dimN]);
    // recompute un
    if(dirNormal[0] > -2) {
      un = 0;
      for(MInt n = 0; n < nDim; n++) {
        un += m_solver->a_pvariable(cellId, PV->VV[n]) * dirNormal[n];
      }
    }

    const MFloat M = fabs(un) / a;

    // get and neighbor normal velocity
    MFloat un_N = 0;
    MFloat T_N = 1;
    if(m_solver->checkNeighborActive(cellId, dirN) && m_solver->a_hasNeighbor(cellId, dirN)) {
      const MInt nghbrN = m_solver->c_neighborId(cellId, dirN);

      if(dirNormal[0] > -2) {
        for(MInt n = 0; n < nDim; n++) {
          un_N += m_solver->a_variable(nghbrN, CV->RHO_VV[n]) / m_solver->a_variable(nghbrN, CV->RHO) * dirNormal[n];
        }
      } else {
        un_N = m_solver->a_variable(nghbrN, CV->RHO_VV[dimN]) / m_solver->a_variable(nghbrN, CV->RHO);
      }

      if(std::isnan(un_N)) {
        cerr << "NAN detected in cutOff-Neighbor! " << endl;
      }

      T_N = sysEqn().temperature_ES(m_solver->a_variable(nghbrN, CV->RHO), m_solver->a_pvariable(nghbrN, PV->P));
    }

    if(rho < F0 || std::isnan(rho) || std::isnan(un)) {
      cerr << "NAN detected in cutOff-Cell " << m_solver->c_globalId(cellId) << " " << m_solver->a_isHalo(cellId) << " "
           << m_solver->a_bndryId(cellId) << " " << rho << " " << bcId << endl;
    }

    if(un_N > F0) {
      massflux_pos += un_N * area;
      area_pos += area;
    } else {
      massflux_neg += un_N * area;
      area_neg += area;
    }

    M_max = mMax(M_max, M);
    M_mean += fabs(M) * area;
    // NOTE: intentionally without density!
    massflux += un_N * area;
    T_mean += T_N * area;
    rho_mean += rho * area;
    rho_min = mMin(rho, rho_min);
    rho_max = mMax(rho, rho_max);
  }

  if(noDomains() > 1) {
    const MInt noExchangeData = 8;
    MFloatScratchSpace comm_buff(noExchangeData, AT_, "comm_buff");

    comm_buff[0] = massflux;
    comm_buff[1] = M_mean;
    comm_buff[2] = T_mean;
    comm_buff[3] = massflux_pos;
    comm_buff[4] = massflux_neg;
    comm_buff[5] = rho_mean;
    comm_buff[6] = area_pos;
    comm_buff[7] = area_neg;

    if(noDomains() > 1) {
      MPI_Allreduce(MPI_IN_PLACE, &comm_buff[0], noExchangeData, MPI_DOUBLE, MPI_SUM,
                    m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_, "MPI_IN_PLACE", "comm_buff[0]");
      MPI_Allreduce(MPI_IN_PLACE, &M_max, 1, MPI_DOUBLE, MPI_MAX, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                    "MPI_IN_PLACE", "M_max");
      MPI_Allreduce(MPI_IN_PLACE, &rho_max, 1, MPI_DOUBLE, MPI_MAX, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                    "MPI_IN_PLACE", "rho_max");
      MPI_Allreduce(MPI_IN_PLACE, &rho_min, 1, MPI_DOUBLE, MPI_MIN, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                    "MPI_IN_PLACE", "rho_min");
    }

    massflux = comm_buff[0];
    M_mean = comm_buff[1];
    T_mean = comm_buff[2];
    massflux_pos = comm_buff[3];
    massflux_neg = comm_buff[4];
    rho_mean = comm_buff[5];
    area_pos = comm_buff[6];
    area_neg = comm_buff[7];
  }

  M_mean /= inflowArea;
  T_mean /= inflowArea;
  rho_mean /= inflowArea;
  const MFloat p_mean = sysEqn().pressure_ES(T_mean, rho_mean);

  // originally claudias version, with slight error!
  // MFloat T_out = 1 - gammaMinusOne * F1B2 *
  // (massflux * massflux / inflowArea / inflowArea);

  // isentropic acceleration from T0/p0 to the area averaged Ma-number in the plane
  // of the domain next to the bndry!
  MFloat T_out = sysEqn().temperature_IR(massflux / inflowArea);
  MFloat p_out = sysEqn().pressure_IR(T_out);

  // limiting isentropically calculated temperature and pressure
  // for any inconsistencies/errors!
  if(p_out / sysEqn().p_Ref() > 1) p_out = sysEqn().p_Ref();
  if(T_out > 1) T_out = 1;
  // const MFloat deltaPLoss = 0.0588;

  const MFloat p_target = p_out;
  MFloat T_target = T_out;
  if(dirN % 2 == 0) {
    T_target = T_mean; // exhaust side
  }

  // other available options:
  // T_target = T_mix, T_out, T_mean
  // p_target = p_out, p_out-deltaPLoss, 1/gamma

  if(/*globalTimeStep % 10 == 0 && */ m_solver->m_RKStep == 0 && domainId() == domainMin) {
    cerr << globalTimeStep << " " << bcId << " " << (dirN % 2)
         << " M_mean, M_max, T_target, p_target, rho_mean, massflux, T_mean, rho_min, rho_max" << setprecision(9)
         << M_mean << ", " << M_max << ", " << T_target << ", " << p_target << ", " << rho_mean << ", " << rho_min
         << ", " << rho_max << ", " << massflux << " " << T_mean << endl;
    // check engine inflow
    if(dirN % 2 == 1 && globalTimeStep % 10 == 0) {
      const MFloat flux = massflux / inflowArea;
      const MFloat flux_pos = area_pos > 0 ? massflux_pos / area_pos : F0;
      const MFloat flux_neg = area_neg > 0 ? massflux_neg / area_neg : F0;
      cerr << "Mean flux " << flux << " positive flux " << flux_pos << " negative flux " << flux_neg << endl;
    }
  }

  ASSERT(!std::isnan(massflux), "ERROR: Mass-flux is nan!");

  // debug!
  // limit M_max to 0.3!
  // M_max = mMin(M_max, 0.3);

  MFloat pTotal = F0;
  MInt noInflowCells = 0;
  MInt totalNoCutOffCell = 0;

  for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
    const MInt cellId = m_sortedCutOffCells[bcId]->a[id];

    if(m_solver->a_isHalo(cellId)) continue;
    if(!m_solver->a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(m_solver->a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    // get the velocity from the next inward neighbor!
    MFloat un_N = 0;
    MFloat ut_N = 0;
    MFloat ut2_N = 0;
    MFloat un_N2 = 0;

    // check neighbor active!
    if(m_solver->checkNeighborActive(cellId, dirN) && m_solver->a_hasNeighbor(cellId, dirN)) {
      const MInt nghbrN = m_solver->c_neighborId(cellId, dirN);

      if(dirNormal[0] > -2) {
        for(MInt n = 0; n < nDim; n++) {
          un_N += m_solver->a_variable(nghbrN, CV->RHO_VV[n]) * dirNormal[n];
          ut_N += m_solver->a_variable(nghbrN, CV->RHO_VV[n]) * dirTangent[n];
        }
        ut2_N = m_solver->a_variable(nghbrN, CV->RHO_VV[dimT2]);

      } else {
        un_N = m_solver->a_variable(nghbrN, CV->RHO_VV[dimN]);
        ut_N = m_solver->a_variable(nghbrN, CV->RHO_VV[dimT1]);
        ut2_N = m_solver->a_variable(nghbrN, CV->RHO_VV[dimT2]);
      }
      // inflow/outflow switch based on cartesian velocity!
      un_N2 = m_solver->a_variable(nghbrN, CV->RHO_VV[dimN]);
      // if the cell is a bndryCell, always apply inflow-cbc
      // this is wokring for TINA, but not for the diaginal inflow!
      // in this case the intake flux needs to be reduced for
      // bndry-cells for 0 < cad < 183!
      // see special inflow treatment below!
      // if(m_solver->a_bndryId(cellId) > -1 ) {
      //  un_N2 = 0;
      //}
    }
    // at corners, where no neighbor exists (u_N = 0 => inflow-cbc)

    const MFloat p = m_solver->a_pvariable(cellId, PV->P);
    const MFloat rho = m_solver->a_pvariable(cellId, PV->RHO);
    const MFloat T = sysEqn().temperature_ES(rho, p);
    const MFloat a = sysEqn().speedOfSound(T);

    MFloat un = m_solver->a_pvariable(cellId, PV->VV[dimN]);
    MFloat ut1 = m_solver->a_pvariable(cellId, PV->VV[dimT1]);

    MFloat dpdn = m_solver->a_slope(cellId, PV->P, dimN);
    MFloat dpdt1 = m_solver->a_slope(cellId, PV->P, dimT1);

    MFloat drhodn = m_solver->a_slope(cellId, PV->RHO, dimN);
    MFloat drhodt1 = m_solver->a_slope(cellId, PV->RHO, dimT1);

    MFloat dundn = m_solver->a_slope(cellId, PV->VV[dimN], dimN);
    MFloat dundt1 = m_solver->a_slope(cellId, PV->VV[dimN], dimT1);

    MFloat dut1dn = m_solver->a_slope(cellId, PV->VV[dimT1], dimN);
    MFloat dut1dt1 = m_solver->a_slope(cellId, PV->VV[dimT1], dimT1);

    const MFloat ut2 = m_solver->a_pvariable(cellId, PV->VV[dimT2]);

    MFloat dpdt2 = m_solver->a_slope(cellId, PV->P, dimT2);
    MFloat drhodt2 = m_solver->a_slope(cellId, PV->RHO, dimT2);
    MFloat dut2dt2 = m_solver->a_slope(cellId, PV->VV[dimT2], dimT2);

    MFloat dut2dn = m_solver->a_slope(cellId, PV->VV[dimT2], dimN);

    MFloat dundt2 = m_solver->a_slope(cellId, PV->VV[dimN], dimT2);
    MFloat dut1dt2 = m_solver->a_slope(cellId, PV->VV[dimT1], dimT2);

    MFloat dut2dt1 = m_solver->a_slope(cellId, PV->VV[dimT2], dimT1);


    // correction when the flow normal does not align with the cartesian normals!
    // =>re-compute slopes!
    if(dirNormal[0] > -2) {
      un = 0;
      ut1 = 0;
      dpdn = 0;
      drhodn = 0;
      dpdt1 = 0;
      drhodt1 = 0;
      dundn = 0;
      dut1dn = 0;
      dundt1 = 0;
      dut1dt1 = 0;

      dut2dt1 = 0;
      dut2dn = 0;

      for(MInt n = 0; n < nDim; n++) {
        un += m_solver->a_pvariable(cellId, PV->VV[n]) * dirNormal[n];
        ut1 += m_solver->a_pvariable(cellId, PV->VV[n]) * dirTangent[n];
      }

      // compute slopes in normal-direction, but use the slopes from inside-cells when possible!
      if(m_solver->checkNeighborActive(cellId, dirN) && m_solver->a_hasNeighbor(cellId, dirN)) {
        const MInt nghbrN = m_solver->c_neighborId(cellId, dirN);

        dpdn = m_solver->a_slope(cellId, PV->P, dimN) * dirNormal[dimN];
        drhodn = m_solver->a_slope(cellId, PV->RHO, dimN) * dirNormal[dimN];
        dundn = m_solver->a_slope(cellId, PV->VV[dimN], dimN) * dirNormal[dimN];
        dut1dn = m_solver->a_slope(cellId, PV->VV[dimT1], dimN) * dirNormal[dimN];
        dut2dn += m_solver->a_slope(cellId, PV->VV[dimT2], dimN) * dirNormal[dimN];

        for(MInt n = 0; n < nDim; n++) {
          if(n == dimN) continue;
          un += m_solver->a_pvariable(nghbrN, PV->VV[n]) * dirNormal[n];
          dpdn += m_solver->a_slope(nghbrN, PV->P, n) * dirNormal[n];
          drhodn += m_solver->a_slope(nghbrN, PV->RHO, n) * dirNormal[n];
          dundn += m_solver->a_slope(nghbrN, PV->VV[dimN], n) * dirNormal[n];
          dut1dn += m_solver->a_slope(nghbrN, PV->VV[dimT1], n) * dirNormal[n];
          dut2dn += m_solver->a_slope(nghbrN, PV->VV[dimT2], n) * dirNormal[n];
        }

      } else {
        for(MInt n = 0; n < nDim; n++) {
          dpdn += m_solver->a_slope(cellId, PV->P, n) * dirNormal[n];
          drhodn += m_solver->a_slope(cellId, PV->RHO, n) * dirNormal[n];

          dpdt1 += m_solver->a_slope(cellId, PV->P, n) * dirTangent[n];
          drhodt1 += m_solver->a_slope(cellId, PV->RHO, n) * dirTangent[n];

          dundn += m_solver->a_slope(cellId, PV->VV[dimN], n) * dirNormal[n];
          dut1dn += m_solver->a_slope(cellId, PV->VV[dimT1], n) * dirNormal[n];

          dundt1 += m_solver->a_slope(cellId, PV->VV[dimN], n) * dirTangent[n];
          dut1dt1 += m_solver->a_slope(cellId, PV->VV[dimT1], n) * dirTangent[n];

          dut2dn += m_solver->a_slope(cellId, PV->VV[dimT2], n) * dirNormal[n];
          dut2dt1 += m_solver->a_slope(cellId, PV->VV[dimT2], n) * dirTangent[n];
        }
      }
    }

    MBool upperBndry = false;
    for(MInt n = m_solver->a_noReconstructionNeighbors(cellId); n--;) {
      MInt recNghbr = m_solver->a_reconstructionNeighborId(cellId, n);
      if(m_solver->a_isBndryGhostCell(recNghbr)
         //|| m_bndryCellIds->a[recNghbr] > -1)
         ////NOT-as good! procuded lower velocity on the bottom of the slide, which means,
         // that the inflow does not align with the tube!
      ) {
        upperBndry = true;
        break;
      }
    }

    MFloat Sum_u = un * un + ut1 * ut1;


    Sum_u = Sum_u + ut2 * ut2;


    const MFloat E = sysEqn().internalEnergy(p, rho, Sum_u);

    MFloat Sum_du = un * dundt1 + ut1 * dut1dt1;
    Sum_du = Sum_du + ut2 * dut2dt1;

    MFloat dEdt1 = sysEqn().cp_Ref() * (F1 / rho * dpdt1 - p / POW2(rho) * drhodt1) + (Sum_du);
    MFloat dEdt2 = sysEqn().cp_Ref() * (F1 / rho * dpdt2 - p / POW2(rho) * drhodt2)
                   + (un * dundt2 + ut1 * dut1dt2 + ut2 * dut2dt2);

    // compute engine pressure loss statistics:
    if(globalTimeStep % 10 == 0 && m_solver->m_RKStep == 0) {
      MFloat area;
      const MInt bndryId = m_solver->a_bndryId(cellId);
      if(bndryId > -1) {
        // identify the "boundary surface" between cutoff boundary cell and
        // neighboring layer cell if cell is a boundary cell
        MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dirN];
        if(srfcId > -1) {
          area = m_solver->a_surfaceArea(srfcId);
        } else {
          for(MInt dir = 0; dir < m_noDirs; dir++) {
            srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[dir];
            if(srfcId > -1) {
              break;
            }
          }
          if(srfcId == -1) {
            mTerm(1, AT_, "something went wrong!");
          }
          area = m_solver->a_surfaceArea(srfcId);
        }
      } else {
        area = POW2(m_solver->c_cellLengthAtCell(cellId));
      }

      // recompute area
      if(dirNormal[0] > -2) {
        area = area * dirTangent[1];
      }

      pTotal += area * (p / sysEqn().p_Ref() + F1B2 * rho * sqrt(Sum_u));
    }

    // compute all Ls using the one-sided dervatives given above
    const MFloat lambda1 = (un - a);
    const MFloat lambda2 = un;
    const MFloat lambda5 = (un + a);
    MFloat L1 = lambda1 * (dpdn - rho * a * dundn);
    MFloat L2 = lambda2 * (a * a * drhodn - dpdn);
    MFloat L3 = lambda2 * (dut1dn);
    MFloat L5 = lambda5 * (dpdn + rho * a * dundn);
    MFloat L4 = lambda2 * (dut2dn);

    // tangential correction terms
    MFloat T1 = -rho * (dut1dt1)-ut1 * drhodt1;
    MFloat T2 = -ut1 * dundt1;
    MFloat T3 = -ut1 * dut1dt1 - F1 / rho * dpdt1;
    MFloat T5 = -ut1 * dpdt1 - p / sysEqn().p_Ref() * dut1dt1;

    T1 += -rho * dut2dt2 - ut2 * drhodt2;
    T2 += -ut2 * dundt2;
    T3 += -ut2 * dut1dt2;
    MFloat T4 = -ut1 * dut2dt1 - ut2 * dut2dt2 - F1 / rho * dpdt2;
    T5 += -ut2 * dpdt2 - p / sysEqn().p_Ref() * dut2dt2;


    // eddy detection:
    const MFloat eddy = (POW2(ut_N) + POW2(ut2_N)) / POW2(un_N);

    /*
    MBool nearBndry = false;
    if(m_solver->a_bndryId(cellId) > -1 ) {
      nearBndry = true;
    } else {
      for(MInt idN = 0; idN < m_solver->a_noReconstructionNeighbors(cellId); idN++) {
        MInt recNghbr = m_solver->a_reconstructionNeighborId(cellId, idN);
        if(m_bndryCellIds->a[recNghbr] > -1){
          nearBndry = true;
          break;
        }
      }
    }
    */

    if(dirNormal[0] > -2 /*|| nearBndry */ || !transversal) {
      T1 = 0;
      T2 = 0;
      T3 = 0;
      T5 = 0;
      T4 = 0;
    }

    MBool isInflow = true;
    totalNoCutOffCell++;

    if(dirN % 2 == 0) {
      if(un_N2 > F0) {
        isInflow = false;
      }
    } else {
      if(un_N2 < F0) {
        isInflow = false;
      }
    }

    if(isInflow) { // inflow

      noInflowCells++;

      // damping coefficients
      const MFloat K1 = sigma_Inflow * a * (1 - M_max * M_max) / LN;
      const MFloat K2 = eta2 * rho * a / LN;
      const MFloat K3 = eta3 * a / LN;

      if(dirN % 2 == 0) { // inflow on pos. coordinate direction (right) -> un < 0
        L1 = K1 * (p - p_target) + (T5 - rho * a * T2);
      } else { // inflow on neg. coordinate direction (left) -> un > 0
        L5 = K1 * (p - p_target) + (T5 + rho * a * T2);
      }
      L2 = K2 * (T - T_target) + (a * a * T1 - T5);
      L3 = K3 * ut1 + T3;
      L4 = K3 * ut2 + T4;

      MBool limitVariable = false;
      if(m_solver->a_pvariable(cellId, PV->RHO) > 1.0000001) {
        m_solver->a_pvariable(cellId, PV->RHO) = 1;
        limitVariable = true;
      }
      if(m_solver->a_pvariable(cellId, PV->P) / sysEqn().p_Ref() > 1.0000001) {
        m_solver->a_pvariable(cellId, PV->P) = sysEqn().p_Ref();
        limitVariable = true;
      }

      if(limitVariable) {
        m_solver->setConservativeVariables(cellId);
      }

    } else { // outflow

      MFloat K1 = sigma_Outflow * a * (1 - M_max * M_max) / LN;
      const MFloat beta = M_mean;
      // possibly set beta to zero, which increases transversal damping!

      // const MFloat K3 = eta3 * a / LN;

      // eddy correction as non-reflecting!
      if(eddy > 1) {
        // TODO: update testcase to new version!
        if(!m_solver->m_engineSetup) {
          K1 = 0;
        } else {
          // update: only set K1 to zero for considerable mass-flux through the
          //        boundary!
          // if(fabs(massflux) > 0.05 ) {
          if(fabs(un_N2) > 0.05 && fabs(massflux) > 0.05) {
            K1 = 0;
          } else {
            // surpress fluctuations in transversal velocities (sponging)
            // const MFloat K3 = eta3 * a / LN;
            // possibly to large, when eta3 is already increased at the inflow-side!
            // const MFloat K3 = (dirN % 2 == 0 ) ? eta3 * 10 * a / LN : eta3 * a / LN;
            const MFloat K3 = eta3 * a * 10 / LN;
            L3 = K3 * ut1 + T3;
            L4 = K3 * ut2 + T4;
          }
        }
      }


      // correct L1/L5 (depends on outflow direction) by boundary condition
      if(dirN % 2 == 0) {
        // outflow on pos. coordinate direction -> L1 has to be modeled
        L1 = K1 * (p - p_target) + (F1 - beta) * (T5 - rho * a * T2);
      } else { // outflow on neg. coordinate direction -> L5 has to be modeled
        L5 = K1 * (p - p_target) + (F1 - beta) * (T5 + rho * a * T2);
      }

      // instead of the L1 prescription at engine outflow with large eddies
      // L2 is presribed with T_target interpolated from the domain!
      MBool walllike = false;
      if(eddy > 1 && dirN % 2 == 0) walllike = true;
      // if global and local velocities are low, set additional sponge on
      // density/temperature to stabilise the inflow!
      if(fabs(un_N2) < 0.005 /*&& fabs(massflux) < 0.005*/) {
        walllike = true;
      }

      // prescribe additioan L2 amplitude just as for a wall
      if(walllike && m_solver->m_engineSetup) {
        const MFloat K2_outflow = -sigma * rho * a / LN;
        L2 = K2_outflow * (T - T_target) + (a * a * T1 - T5);
        // from time to time necessary to resolve problems at the exhaust-outflow!
        if(dirN % 2 == 0 && eddy < 1) {
          const MFloat K3 = eta3 * a / LN;
          L3 = K3 * ut1 + T3;
          L4 = K3 * ut2 + T4;
        }
      }
    }

    // if(m_solver->crankAngle(m_solver->m_physicalTime,0) < 185 &&
    //   m_solver->a_pvariable(cellId,  PV->U) < 0  ) {

    // if(abs(m_solver->a_pvariable(cellId,  PV->W)) > 0.005 &&
    //    m_solver->crankAngle(m_solver->m_physicalTime,0) < 170
    //    && m_solver->a_coordinate(cellId ,0) < 0
    //    ) {
    if((abs(m_solver->a_pvariable(cellId, PV->W)) > 0.005 || abs(m_solver->a_pvariable(cellId, PV->U)) > 0.3)
       && m_solver->crankAngle(m_solver->m_physicalTime, 0) > 240) {
      //       globalTimeStep > 1443600 && globalTimeStep < 1444000 ) {
      //         globalTimeStep > 1474000 ) {

      if(globalTimeStep % 10 == 0 && m_solver->m_RKStep == 0) {
        cerr << "Limiting-cell " << m_solver->a_coordinate(cellId, 1) << " " << m_solver->a_coordinate(cellId, nDim - 1)
             << " " << upperBndry << " " << m_solver->a_pvariable(cellId, PV->U) << endl;
      }


      m_solver->a_pvariable(cellId, PV->P) = 0.71428;
      m_solver->a_pvariable(cellId, PV->RHO) = 1;
      m_solver->a_pvariable(cellId, PV->VV[2]) = 0;
      m_solver->a_pvariable(cellId, PV->VV[0]) = 0.01 * dirNormal[0];
      m_solver->a_pvariable(cellId, PV->VV[1]) = 0.01 * dirNormal[1];

      L1 = 0;
      L2 = 0;
      L3 = 0;
      L4 = 0;
      L5 = 0;

      m_solver->setConservativeVariables(cellId);
    }

    if(abs(m_solver->a_pvariable(cellId, PV->W)) > 0.005) {
      m_solver->a_pvariable(cellId, PV->P) = p_mean;
      m_solver->a_pvariable(cellId, PV->RHO) = rho_mean;
      m_solver->a_pvariable(cellId, PV->VV[2]) = 0;
      if(m_solver->crankAngle(m_solver->m_physicalTime, 0) < 170) {
        m_solver->a_pvariable(cellId, PV->VV[0]) = 0.01 * dirNormal[0];
        m_solver->a_pvariable(cellId, PV->VV[1]) = 0.01 * dirNormal[1];
      }

      L1 = 0;
      L2 = 0;
      L3 = 0;
      L4 = 0;
      L5 = 0;
      if(globalTimeStep % 10 == 0 && m_solver->m_RKStep == 0) {
        cerr << "Limiting-cell " << m_solver->a_coordinate(cellId, 1) << " " << m_solver->a_coordinate(cellId, nDim - 1)
             << " " << upperBndry << endl;
      }
      m_solver->setConservativeVariables(cellId);
    }


    // stronger wall affect
    // treated as normal inflow with dirNormal[1] = 0!
    if(upperBndry && dirNormal[0] > -2) {
      // wall bndry-cnd or also stationary subsonic inflow
      if(/*m_solver->crankAngle(m_solver->m_physicalTime,0) < 185 && */ isInflow) {
        if(dirN % 2 == 0) {
          L1 = L5;
        } else {
          L5 = L1;
        }
      } else {
        // stationary reflecting subsonic outflow! (not working!)
        /*
        if(m_solver->crankAngle(m_solver->m_physicalTime,0) > 191) {
          if(dirN % 2 == 0) {
            L1 = -L5;
          } else {
            L5 = -L1;
          }
        }
        */
        /*
        if(m_solver->crankAngle(m_solver->m_physicalTime,0) < 110 ) {
           m_solver->a_pvariable(cellId, PV->U) = 0.0001;
           m_solver->a_pvariable(cellId, PV->V) = 0;
           m_solver->a_pvariable(cellId, PV->W) = 0;
           m_solver->a_pvariable(cellId, PV->RHO) = 1;
           m_solver->a_pvariable(cellId, PV->P) = 0.71428;

           m_solver->setConservativeVariables(cellId);

        }
        */

        // stronger sponge towards zero tangential/wall-normal velocity
        const MFloat K3 = sigma * a / LN;
        L3 = K3 * ut1 + T3;
        L4 = K3 * ut2 + T4;

        // stronger sponging towards stagnation temperature
        const MFloat K2_outflow = -sigma * rho * a / LN;
        L2 = K2_outflow * (T - T_target) + (a * a * T1 - T5);
      }
      // also prescribe L1/L5 based on zero velocity instead of pressure
      // nice try, but diverging quickly!
      /*
      const MFloat K1 = sigma_Outflow * a * (1 - M_max * M_max) / LN * a * rho;
      if(dirN % 2 == 0) {
        L1 = K1 * un_N;
      } else {
        L5 = K1 * un_N;
      }
      */
      // reduced order of slopes increase order of sponging instead!
      // This is definitely contra-productive!
      /*
      if(dirN % 2 == 0) {
        //L5 = lambda5 * (dpdn + rho * a * dundn);
        L5 = L5 /100;
        L1 = L1 * 10;
      } else {
        //L1 = lambda1 * (dpdn - rho * a * dundn);
        L1 = L1 /100;
        L5 = L5 * 10;
      }
      */
    }

    /*
    if(abs(m_solver->a_pvariable(cellId, PV->W) > 0.015) ||
           m_solver->a_pvariable(cellId, PV->RHO) > 1 ) {
      m_solver->a_pvariable(cellId, PV->U) = 0.1;
      m_solver->a_pvariable(cellId, PV->V) = -0.0512;
      m_solver->a_pvariable(cellId, PV->W) = 0;
      m_solver->a_pvariable(cellId, PV->RHO) = 0.9924;
      m_solver->a_pvariable(cellId, PV->P) = 0.710;

      m_solver->setConservativeVariables(cellId);
      L1 = 0;
      L2 = 0;
      L3 = 0;
      L4 = 0;
      L5 = 0;

    }
    */


    MFloat d1 = F1 / (a * a) * (L2 + F1B2 * (L5 + L1));
    MFloat d2 = F1B2 * (L5 + L1);
    MFloat d3 = F1B2 / (rho * a) * (L5 - L1);
    MFloat d4 = L3;

    MFloat d5 = L4;

    // correct ds for normlar vectors
    if(dirNormal[0] > -2) {
      d1 = dirNormal[0] * F1 / (a * a) * L2 + dirNormal[1] * L4 - dirNormal[2] * L3 + F1B2 * F1 / (a * a) * (L5 + L1);
      // d2 = d2 no correction necessary in d2!
      const MFloat d3_old = d3;
      d3 = dirNormal[0] * d3_old - dirNormal[2] * L4 - dirNormal[1] * L3;
      d4 = dirNormal[0] * L3 + dirNormal[1] * d3_old + dirNormal[2] * F1 / (a * a) * L2;
      d5 = dirNormal[0] * L4 + dirNormal[2] * d3_old - dirNormal[1] * F1 / (a * a) * L2;
    }

    // compute corrected RHS for cut off cell:
    MFloat rhs_rho = -d1 - rho * (dut1dt1)-ut1 * drhodt1;

    MFloat rhs_rhoun = -un * d1 - rho * (d3 + un * dut1dt1 + ut1 * dundt1) - un * (ut1 * drhodt1);

    MFloat rhs_rhout1 = -ut1 * d1 - rho * (d4 + F2 * ut1 * dut1dt1) - ut1 * (ut1 * drhodt1) - dpdt1;

    MFloat rhs_rhoe = -F1B2 * (POW2(un) + POW2(ut1)) * d1 - d2 * sysEqn().cp_Ref() - rho * (un * d3 + ut1 * d4)
                      - ut1 * (rho * dEdt1 + E * drhodt1 + dpdt1) - (rho * E + p) * dut1dt1;

    rhs_rho += -rho * dut2dt2 - ut2 * drhodt2;


    rhs_rhoun += -rho * (un * dut2dt2 + ut2 * dundt2) - un * ut2 * drhodt2;


    rhs_rhout1 += -rho * (ut1 * dut2dt2 + ut2 * dut1dt2) - ut1 * ut2 * drhodt2;


    MFloat rhs_rhout2 = -ut2 * d1 - rho * (d5 + ut2 * dut1dt1 + ut1 * dut2dt1 + F2 * ut2 * dut2dt2)
                        - ut2 * (ut1 * drhodt1 + ut2 * drhodt2) - dpdt2;


    rhs_rhoe +=
        -F1B2 * (POW2(ut2)) * d1 - rho * ut2 * d5 - ut2 * (rho * dEdt2 + E * drhodt2 + dpdt2) - (rho * E + p) * dut2dt2;


    // compute rightHandside without transversal terms!
    if(dirNormal[0] > -2 /*|| nearBndry */ || !transversal) {
      rhs_rho = -d1;
      rhs_rhoun = -un * d1 - rho * d3;
      rhs_rhout1 = -ut1 * d1 - rho * d4;
      rhs_rhoe = -F1B2 * (POW2(un) + POW2(ut1)) * d1 - d2 * sysEqn().cp_Ref() - rho * (un * d3 + ut1 * d4);
      rhs_rhout2 = -ut2 * d1 - rho * d5;
      rhs_rhoe += -F1B2 * POW2(ut2) * d1 - rho * ut2 * d5;
    }


    m_solver->a_rightHandSide(cellId, CV->RHO) = -m_solver->a_cellVolume(cellId) * rhs_rho;
    m_solver->a_rightHandSide(cellId, CV->RHO_VV[dimN]) = -m_solver->a_cellVolume(cellId) * rhs_rhoun;
    m_solver->a_rightHandSide(cellId, CV->RHO_VV[dimT1]) = -m_solver->a_cellVolume(cellId) * rhs_rhout1;
    m_solver->a_rightHandSide(cellId, CV->RHO_E) = -m_solver->a_cellVolume(cellId) * rhs_rhoe;
    m_solver->a_rightHandSide(cellId, CV->RHO_VV[dimT2]) = -m_solver->a_cellVolume(cellId) * rhs_rhout2;
  }

  if(globalTimeStep % 10 == 0 && m_solver->m_RKStep == 0) {
    if(noDomains() > 1) {
      MPI_Allreduce(MPI_IN_PLACE, &pTotal, 1, MPI_DOUBLE, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                    "MPI_IN_PLACE", "pTotal");

      MPI_Allreduce(MPI_IN_PLACE, &noInflowCells, 1, MPI_INT, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                    "MPI_IN_PLACE", "noInflowCells");

      MPI_Allreduce(MPI_IN_PLACE, &totalNoCutOffCell, 1, MPI_INT, MPI_SUM, m_comm_bcCo[m_bcCo_comm_pointer[bcId]], AT_,
                    "MPI_IN_PLACE", "totalNoCutOffCell");
    }

    pTotal /= inflowArea;

    if(dirN % 2 == 0 && domainId() == domainMin) {
      cerr << "Average total pressure at outlet is: " << pTotal << endl;
    } else if(domainId() == domainMin) {
      cerr << "Average total pressure at inlet is: " << pTotal << endl;
    }

    const MFloat ratio = (MFloat)noInflowCells / ((MFloat)totalNoCutOffCell);
    if(dirN % 2 == 1 && domainId() == domainMin) {
      cerr << "Inflow cell percentage: " << ratio << " at inlet!" << endl;
    } else if(domainId() == domainMin) {
      cerr << "Inflow cell percentage: " << ratio << " at outlet!" << endl;
    }
  }
}

template <MInt nDim, class SysEqn>
void FvBndryCndXD<nDim, SysEqn>::bcInit30022(MInt bcId) {
  TRACE();

  // Read BC data
  stringstream fn;
  fn.clear();
  fn << "bc30022.txt";
  MString fname = fn.str();
  if(m_solver->domainId() == 0) cerr << "loading BC data from " << fname << "...";

  ifstream vnData;
  vnData.open(fname);
  vector<MFloat> data;
  MFloat num;
  string line;

  while(vnData >> num) {
    data.push_back(num);
  }

  vnData.close();

  MInt horDataVarCount = Context::getSolverProperty<MInt>("bc30022DataCount", m_solverId, AT_, &horDataVarCount); // 14
  MInt horTargetDataCount = data.size() / horDataVarCount;

  mAlloc(m_horTargetData, m_sortedCutOffCells[bcId]->size(), 3, "m_horTargetData", F0, AT_);

  for(MInt d = 0; d < horTargetDataCount - 1; d++) {
    MInt index1 = horDataVarCount * d;
    MInt index2 = horDataVarCount * (d + 1);
    MFloat xTarget1 = data[index1];
    MFloat xTarget2 = data[index2];
    MFloat uTarget1 = data[index1 + 1];
    MFloat uTarget2 = data[index2 + 1];
    MFloat vTarget1 = data[index1 + 2];
    MFloat vTarget2 = data[index2 + 2];
    MFloat rhoTarget1 = data[index1 + 3];
    MFloat rhoTarget2 = data[index2 + 3];

    for(MInt id = 0; id < m_sortedCutOffCells[bcId]->size(); id++) {
      MInt cellId = m_sortedCutOffCells[bcId]->a[id];
      MFloat x = m_solver->a_coordinate(cellId, 0);
      if(xTarget2 > x && xTarget1 <= x) {
        m_horTargetData[id][0] = uTarget1 + (uTarget2 - uTarget1) / (xTarget2 - xTarget1) * (x - xTarget1);
        m_horTargetData[id][1] = vTarget1 + (vTarget2 - vTarget1) / (xTarget2 - xTarget1) * (x - xTarget1);
        m_horTargetData[id][2] = rhoTarget1 + (rhoTarget2 - rhoTarget1) / (xTarget2 - xTarget1) * (x - xTarget1);
      }
    }
  }
}
