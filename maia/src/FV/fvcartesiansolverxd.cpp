// Copyright (C) 2024 The m-AIA AUTHORS
//
// This file is part of m-AIA (https://git.rwth-aachen.de/aia/m-AIA/m-AIA)
//
// SPDX-License-Identifier: LGPL-3.0-only

#include "fvcartesiansolverxd.h"

#include <chrono>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <ctime>
#include <iomanip>
#include <iostream>
#include <map>
#include <random>
#include <set>
#include <stack>
#include <string>

#include "COMM/mpioverride.h"
#include "GEOM/geometryelement.h"
#include "GRID/cartesiangrid.h"
#include "GRID/cartesiannetcdf.h"
#include "IO/iovtk.h"
#include "IO/parallelio.h"
#include "UTIL/hilbert.h"
#include "UTIL/tensor.h"
#include "fvcartesianbndrycell.h"
#include "fvcartesianbndrycndxd.h"
#include "fvcartesiancellproperties.h"
#include "fvransmodelconstants.h"
#include "globals.h"
#include "typetraits.h"

// Required for nDim=3
#include "UTIL/kdtree.h"
#include "UTIL/pointbox.h"

#include "fvstg.h"

using namespace std;
using namespace maia;
using namespace maia::fv;

// TODO labels:FV fix this!
#undef RAND_MAX
#define RAND_MAX 9999999


template <MInt nDim_, class SysEqn>
const constexpr MInt FvCartesianSolverXD<nDim_, SysEqn>::MV::LAMB0;
template <MInt nDim_, class SysEqn>
const constexpr MInt FvCartesianSolverXD<nDim_, SysEqn>::MV::VORT0;
template <MInt nDim_, class SysEqn>
const constexpr MInt FvCartesianSolverXD<nDim_, SysEqn>::MV::DU;
template <MInt nDim_, class SysEqn>
const constexpr MInt FvCartesianSolverXD<nDim_, SysEqn>::MV::DRHO;
template <MInt nDim_, class SysEqn>
const constexpr MInt FvCartesianSolverXD<nDim_, SysEqn>::MV::DP;
template <MInt nDim_, class SysEqn>
const constexpr MInt FvCartesianSolverXD<nDim_, SysEqn>::MV::RHODIVU;
template <MInt nDim_, class SysEqn>
const constexpr MInt FvCartesianSolverXD<nDim_, SysEqn>::MV::UGRADRHO;
template <MInt nDim_, class SysEqn>
const constexpr MInt FvCartesianSolverXD<nDim_, SysEqn>::MV::GRADPRHO;
template <MInt nDim_, class SysEqn>
const constexpr MInt FvCartesianSolverXD<nDim_, SysEqn>::MV::GRADU;
template <MInt nDim_, class SysEqn>
const constexpr MInt FvCartesianSolverXD<nDim_, SysEqn>::MV::UGRADU;
template <MInt nDim_, class SysEqn>
constexpr MFloat FvCartesianSolverXD<nDim_, SysEqn>::m_volumeThreshold; // for stupid PGI compiler

using namespace std;
using namespace maia;

#define SWAP_ENDIAN


/* \brief Constructor of the FV Solver: reads properties, allocates solver resources.
 */
template <MInt nDim_, class SysEqn>
FvCartesianSolverXD<nDim_, SysEqn>::FvCartesianSolverXD(MInt solverId_, MInt noSpecies, const MBool* propertiesGroups,
                                                        maia::grid::Proxy<nDim_>& gridProxy_,
                                                        Geometry<nDim_>& geometry_, const MPI_Comm comm)
  : maia::CartesianSolver<nDim, FvCartesianSolverXD<nDim_, SysEqn>>(solverId_, gridProxy_, comm, true),
    m_geometry(&geometry_),
    m_eps(std::numeric_limits<MFloat>::epsilon()),
    m_noSpecies(noSpecies),
    m_sysEqn(solverId_, noSpecies),
    m_time(0.0),
    PV(sysEqn().PV),
    CV(sysEqn().CV),
    FV(sysEqn().FV),
    AV(sysEqn().AV),
    SC(sysEqn().SC) {
  TRACE();

  // NOTE: everything in the constructor should be written that also inactive ranks are supported,
  // i.e., those who do not participate in the computation. For load balancing it is
  // required that the main initialization of all member variables and properties is performed
  // globally
  // const MBool isActive = gridProxy_.isActive();

  /*! \page propertiesFV
    \section multilevel
    <code>MBool FvCartesianSolver::m_multilevel</code>\n
    default = <code>0</code>\n \n
    Indicates that this solver is part of a multilevel execution.
    Possible values are:
    <ul>
    <li>0: deactivated</li>
    <li>1: activated</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, MULTILEVEL, MULTIGRID</i>
  */
  m_multilevel = false;
  m_multilevel = Context::getBasicProperty<MBool>("multilevel", AT_, &m_multilevel);

  m_pressureRatioChannel = F1;
  if(Context::propertyExists("pressureRatioChannel", m_solverId))
    m_pressureRatioChannel = Context::getSolverProperty<MFloat>("pressureRatioChannel", m_solverId, AT_);
  m_pressureRatioStartTimeStep = -1;
  if(Context::propertyExists("pressureRatioStartTimeStep", m_solverId))
    m_pressureRatioStartTimeStep = Context::getSolverProperty<MFloat>("pressureRatioStartTimeStep", m_solverId, AT_);
  m_pressureRatioEndTimeStep = -1;
  if(Context::propertyExists("pressureRatioEndTimeStep", m_solverId))
    m_pressureRatioEndTimeStep = Context::getSolverProperty<MFloat>("pressureRatioEndTimeStep", m_solverId, AT_);


  m_levelSet = propertiesGroups[LEVELSET];
  m_levelSetMb = propertiesGroups[LEVELSETMB];
  m_combustion = propertiesGroups[COMBUSTION];
  m_LSSolver = propertiesGroups[LS_SOLVER];
  m_levelSetRans = propertiesGroups[LS_RANS];

  //-------------Initialize Wall Normal Output & set appropriate properties
  m_wallNormalOutput = false;
  if(Context::propertyExists("wallNormalOutput", m_solverId)) {
    m_log << endl << endl << "Reading Wall Normal Output properties ... " << endl;
    m_wallNormalOutput = Context::getSolverProperty<MBool>("wallNormalOutput", m_solverId, AT_);
    if(m_wallNormalOutput == true) {
      if(Context::propertyExists("useWallNormalInterpolation", m_solverId)) {
        m_useWallNormalInterpolation = Context::getSolverProperty<MBool>("useWallNormalInterpolation", m_solverId, AT_);
      }
      // get the target BC Id for the output
      m_normalBcId = Context::getSolverProperty<MInt>("normalBcId", m_solverId, AT_);

      // Set Output interval
      if(Context::propertyExists("normalOutputInterval", m_solverId)) {
        m_normalOutputInterval = Context::getSolverProperty<MInt>("normalOutputInterval", m_solverId, AT_);
        m_log << "normalOutputInterval = " << m_normalOutputInterval << endl;
      } else {
        mTerm(1, "normalOutputInterval not given in property file!");
      }

      // Set Normal length
      if(Context::propertyExists("normalLength", m_solverId)) {
        m_normalLength = Context::getSolverProperty<MFloat>("normalLength", m_solverId, AT_);
      } else {
        mTerm(1, "normalLength not given in property file!");
      }

      // Set Normal point number
      if(Context::propertyExists("normalNoPoints", m_solverId)) {
        m_normalNoPoints = Context::getSolverProperty<MInt>("normalNoPoints", m_solverId, AT_);
        if(m_normalNoPoints < 2) {
          mTerm(1, "normalNoPoints should be at least 2");
        }
      } else {
        mTerm(1, "normalNoPoints not given in property file");
      }

      MInt noCoords = Context::propertyLength("normalSamplingCoords", m_solverId);
      for(MInt c = 0; c < noCoords; c++) {
        m_normalSamplingCoords.push_back(
            Context::getSolverProperty<MFloat>("normalSamplingCoords", m_solverId, AT_, c));
      }

      for(MInt c = 0; c < (noCoords / 2); c++) {
        m_normalSamplingSide.push_back(Context::getSolverProperty<MInt>("normalSamplingSide", m_solverId, AT_, c));
      }
      m_log << "done." << endl;
    }
  }

  // spanwise averaged surface probes
  // only for uniform, uncut cells, otherwise area-weighting is necessary
  // would generally make more sense to move into postprocessing block
  m_saSrfcProbeInterval = 0;
  if(Context::propertyExists("saSrfcProbeInterval", m_solverId)) {
    m_saSrfcProbeInterval =
        Context::getSolverProperty<MInt>("saSrfcProbeInterval", m_solverId, AT_, &m_saSrfcProbeInterval);
    if(m_saSrfcProbeInterval > 0) {
      Context::getSolverProperty<MInt>("saSrfcProbeStart", m_solverId, AT_, &m_saSrfcProbeStart);
    }
    m_saSrfcProbeDir = "";
    if(Context::propertyExists("saSrfcProbeDir", m_solverId)) {
      m_saSrfcProbeDir = Context::getSolverProperty<MString>("saSrfcProbeDir", m_solverId, AT_, &m_saSrfcProbeDir);
    }
  }

  // Sandpaper Tripping
  m_useSandpaperTrip = false;
  if(Context::propertyExists("useSandpaperTrip", m_solverId)) {
    m_useSandpaperTrip = Context::getSolverProperty<MBool>("useSandpaperTrip", m_solverId, AT_, &m_useSandpaperTrip);
  }

  // Channel Volume Forcing
  m_useChannelForce = false;
  if(Context::propertyExists("useChannelForce", m_solverId)) {
    m_useChannelForce = Context::getSolverProperty<MBool>("useChannelForce", m_solverId, AT_, &m_useChannelForce);
  }

  /*! \page propertiesFV
    \section EEGas
    <code>MBool FvCartesianSolverXD::m_isEEGas </code>\n
    default = <code>false</code>\n \n
    Enable the FV-component of the coupled LB-FV Euler-Euler method for bubbly flows.\n
    Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
  */
  m_isEEGas = Context::getSolverProperty<MBool>("EEGas", m_solverId, AT_, &m_isEEGas);

  // sets detailed chemistry model specific properties
  IF_CONSTEXPR(isDetChem<SysEqn>) setAndAllocateDetailedChemistryProperties();

  // set the fv-Collector type to reduce fv-Cell memory!
  MInt fvCollectorMode = 0;
  IF_CONSTEXPR(isDetChem<SysEqn>) fvCollectorMode = 1;
  if(m_combustion) {
    fvCollectorMode = 2;
  }
  if(m_isEEGas) {
    fvCollectorMode = 3;
  }

  MInt fvTimeStepMode = 0;
  /*! \page propertiesFV
    \section dualTimeStepping
    <code>MBool FvCartesianSolver::m_dualTimeStepping</code>\n
    default = <code>false</code>\n\n
    Activates the dual-time stepping\n
    Possible values are:\n
    <ul>\n
    <li>0, 1</li>\n
    </ul>\n
    Keywords: <i>GENERAL</i>
  */
  m_dualTimeStepping = false;
  m_dualTimeStepping = Context::getSolverProperty<MBool>("dualTimeStepping", m_solverId, AT_, &m_dualTimeStepping);

  /*! \page propertiesFVMB
    \section localTimeSteppingMb
    <code>MInt FvMbCartesianSolverXD::localTS</code>\n
    default = <code> none </code>\n \n
    Switch to use local time stepping in Runge Kutta Scheme
    Possible values are:
    <ul>
      <li> true/false  </li>
    </ul>
    Keywords: <i>FINITE VOLUME, MOVING BOUNDARY, LOCAL TIME STEPPING</i>
  */
  m_localTS = false;
  m_localTS = Context::getSolverProperty<MBool>("localTimeStepping", m_solverId, AT_, &m_localTS);

  if(m_dualTimeStepping) {
    fvTimeStepMode = 2;
  }
  if(m_localTS) {
    fvTimeStepMode = 1;
  }

  const MLong oldAllocatedBytes = allocatedBytes();
  m_cells.setFvCollectorType(fvCollectorMode);
  m_cells.setFvTimeStepType(fvTimeStepMode);
  m_cells.setNoCVariables(CV->noVariables, m_noSpecies);
  m_cells.setNoPVariables(PV->noVariables);
  m_cells.setNoFVariables(FV->noVariables);
  m_cells.setNoAVariables(AV->noVariables);
  m_cells.isMultilevel(m_multilevel);
  m_cells.reset(grid().maxNoCells());
  m_cells.append(c_noCells());
  m_totalnosplitchilds = 0;
  m_totalnoghostcells = 0;

  for(MInt c = 0; c < a_noCells(); c++) {
    a_resetPropertiesSolver(c);
  }

  // Copy grid-properties to the fvcellcollector
  copyGridProperties();

  initializeFvCartesianSolver(propertiesGroups);

  // Initialize postprocessing
  // initPostProcessingSolver(&grid().raw());

  // communication:
  allocateCommunicationMemory();

  // physical and other testcase specific properties:
  setTestcaseProperties();

  // in/output:
  setInputOutputProperties();

  // numerical method:
  setNumericalProperties();

  // adaptation:
  setAndAllocateAdaptationProperties();

  // sponge layer:
  setAndAllocateSpongeLayerProperties();

  // jet:
  setAndAllocateJetProperties();

  // combustion GequPv model (G-equation)
  setAndAllocateCombustionGequPvProperties();

  // combustion thickened flame (TF)
  setAndAllocateCombustionTFProperties();

  // zonal and rans properties
  setAndAllocateZonalProperties();

  // wall-model properties
  readWallModelProperties();

  // allocate general FvCartesianSolver memory
  allocateAndInitSolverMemory();

  // creates the FV Solver timers
  initializeTimers();

  IF_CONSTEXPR(isDetChem<SysEqn>) if(m_heatReleaseDamp) initHeatReleaseDamp();

  if(m_geometry->m_parallelGeometry) {
    this->receiveWindowTriangles();
  }

  this->checkNoHaloLayers();

  // old constructor
  // initialize
  m_physicalTime = 0.;
  m_gridConvergence = false;
  m_counterCx = 0;
  m_storeNghbrIds = nullptr;
  m_identNghbrIds = nullptr;

  // set function pointers
  if(m_limiter) {
    m_reconstructSurfaceData = &FvCartesianSolverXD::computeLimitedSurfaceValues;
    m_log << "* Using limited surface data reconstruction." << endl;
  } else {
    switch(string2enum(m_surfaceValueReconstruction)) {
      case HOCD:
        m_reconstructSurfaceData = &FvCartesianSolverXD::computeSurfaceValues;
        m_log << "* Using unlimited high-order surface data reconstruction." << endl;
        break;
      case HOCD_LIMITED:
        m_reconstructSurfaceData = &FvCartesianSolverXD::computeSurfaceValuesLimited;
        m_log << "* Using limited high-order surface data reconstruction." << endl;
        break;
      case LOCD:
        m_reconstructSurfaceData = &FvCartesianSolverXD::computeSurfaceValuesLOCD;
        m_log << "* Using unlimited low-order (pressure)/high-order surface data reconstruction." << endl;
        break;
      case HOCD_LIMITED_SLOPES:
        m_reconstructSurfaceData = &FvCartesianSolverXD::computeSurfaceValuesLimitedSlopes;
        m_log << "* Using sensor slope-limited high-order surface data reconstruction." << endl;
        break;
      case HOCD_LIMITED_SLOPES_MAN:
        m_reconstructSurfaceData = &FvCartesianSolverXD::computeSurfaceValuesLimitedSlopesMan;
        m_log << "* Using manual slope-limited high-order surface data reconstruction." << endl;
        this->setCellProperties();
        this->initComputeSurfaceValuesLimitedSlopesMan1();
        break;
      default: {
        stringstream errorMessage;
        errorMessage << "FvCartesianSolverXD::FvCartesianSolverXD(): switch variable "
                        "'m_surfaceValueReconstruction' with value "
                     << m_surfaceValueReconstruction << " not matching any case." << endl;
        mTerm(1, AT_, errorMessage.str());
      }
    }
  }

  printAllocatedMemory(oldAllocatedBytes, "FvCartesianSolverXD", this->globalMpiComm());

  m_fvBndryCnd = new FvBndryCndXD<nDim_, SysEqn>(this);

  if(isActive()) {
    // compute min and max coordinates in the grid
    computeDomainAndSpongeDimensions();
  }

  // set infinity variabbles once and for all!
  setInfinityState();

  // set rotation properties for azimuthal periodic exchange of velocity vector
  if(grid().azimuthalPeriodicity()) {
    m_rotIndVarsPV.assign(PV->noVariables, 0);
    m_rotIndVarsPV[PV->VV[grid().azimuthalDir(0)]] = 1;
    m_rotIndVarsPV[PV->VV[grid().azimuthalDir(1)]] = 1;
    m_rotIndVarsCV.assign(CV->noVariables, 0);
    m_rotIndVarsCV[CV->RHO_VV[grid().azimuthalDir(0)]] = 1;
    m_rotIndVarsCV[CV->RHO_VV[grid().azimuthalDir(1)]] = 1;
  }
}

/* Computes heat release for OUTPUT-File
Author: Pedro, Borja, Betreuer: Herff, Sohel
Contact: borja.pedro@rwth-aachen.de
*/
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeAcousticSourceTermQe(MFloatScratchSpace& QeI, MFloatScratchSpace& QeIII,
                                                                     MFloatScratchSpace& cSquared,
                                                                     MFloatScratchSpace& drhodt) {
  for(MInt cellId = 0; cellId < a_noCells(); ++cellId) {
    QeI[cellId] = F0;
    QeIII[cellId] = F0;
    cSquared[cellId] = F0;
    drhodt[cellId] = F0;

    IF_CONSTEXPR(isDetChem<SysEqn>) {
      const MFloat dt = m_timeStep;

      MFloat oldVelPow2 = F0;
      for(MInt dim = 0; dim < nDim; dim++)
        oldVelPow2 += POW2(a_oldVariable(cellId, CV->RHO_VV[dim]) / a_oldVariable(cellId, CV->RHO));

      MFloat oldT = F0;
#if defined(WITH_CANTERA)
      sysEqn().iterateTemperature(oldT, &a_oldVariable(cellId, 0), &a_pvariable(cellId, 0), &a_avariable(cellId, 0),
                                  oldVelPow2);
#endif

      const MFloat oldP = a_oldVariable(cellId, CV->RHO) * oldT * m_gasConstant / a_avariable(cellId, AV->W_MEAN);
      const MFloat curP = a_pvariable(cellId, PV->P);
      const MFloat dpdt = (curP - oldP) / dt;

      MFloat divU = 0.0;
      for(MInt dim = 0; dim < nDim; dim++) {
        divU += a_slope(cellId, PV->VV[dim], dim);
      }

      MFloat DrhoDt = a_pvariable(cellId, PV->RHO) * divU;
      MFloat UgradRho = 0.0;
      MFloat UgradP = 0.0;
      for(MInt dim = 0; dim < nDim; dim++) {
        UgradRho = a_pvariable(cellId, PV->VV[dim]) * a_slope(cellId, PV->RHO, dim);
        UgradP = a_pvariable(cellId, PV->VV[dim]) * a_slope(cellId, PV->P, dim);
      }

      const MFloat DpDt = dpdt + UgradP;

      drhodt[cellId] = DrhoDt + UgradRho;
      cSquared[cellId] = a_avariable(cellId, AV->GAMMA) * curP / a_variable(cellId, CV->RHO);
      QeI[cellId] = DpDt - cSquared[cellId] * DrhoDt;
      QeIII[cellId] = cSquared[cellId] * UgradRho - UgradP;
    }
  }
}

/* Adds the computed species reaction rates to the LHS of conservation equations.
Computes the heat release term as:
w_t = -SUMM(formationEnthalpy * reactionRate)
and adds it to the energy conservation equation
Author: Pedro, Borja, Betreuer: Herff, Sohel
Contact: borja.pedro@rwth-aachen.de
*/
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::addSpeciesReactionRatesAndHeatRelease() {
  const MUint noSpecies = m_noSpecies;

  calculateHeatRelease();

  for(MInt cellId = 0; cellId < a_noCells(); ++cellId) {
    if(a_isBndryGhostCell(cellId)) continue;
    if(a_isHalo(cellId)) continue;

    const MFloat dampeningFactor = m_heatReleaseDamp ? m_dampFactor[cellId] : F1;

    // Add species reaction rates to species transport equation
    for(MUint s = 0; s < noSpecies; ++s) {
      a_rightHandSide(cellId, CV->RHO_Y[s]) -=
          dampeningFactor * a_cellVolume(cellId) * a_speciesReactionRate(cellId, s);
    }

    a_rightHandSide(cellId, CV->RHO_E) -= a_cellVolume(cellId) * m_heatRelease[cellId];
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initHeatReleaseDamp() {
  MInt dampDist = 9;
  if(Context::propertyExists("dampDist", m_solverId))
    dampDist = Context::getSolverProperty<MInt>("dampDist", m_solverId, AT_, &dampDist);

  MInt noDampedWalls = 0;
  if(Context::propertyExists("noDampedWalls", m_solverId))
    noDampedWalls = Context::getSolverProperty<MInt>("noDampedWalls", m_solverId, AT_, &noDampedWalls);

  if(noDampedWalls == 0)
    mTerm(1, "initHeatReleaseDamp() has been called, but noDampedWalls = 0. Check properties file.");

  std::vector<MString> filename;
  for(MInt Id = 0; Id < noDampedWalls; Id++) {
    stringstream name;
    name << "dampedWall." << Id;
    filename.push_back(name.str());
  }

  m_dampFactor.assign(a_noCells(), F1);

  for(MUint Id = 0; Id < filename.size(); Id++) {
    vector<MInt> markedCells;
    MIntScratchSpace propDist(grid().raw().treeb().size(), AT_, "propDist");
    propDist.fill(numeric_limits<MInt>::max());

    IF_CONSTEXPR(nDim == 2) {
      Geometry2D* auxGeom = new Geometry2D(0, filename[Id], mpiComm());
      for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
        const MFloat cellHalfLength = c_cellLengthAtLevel(a_level(cellId) + 1);
        if(!c_noChildren(cellId) && auxGeom->isOnGeometry(cellHalfLength, &a_coordinate(cellId, 0), "SAT"))
          if(grid().tree().solver2grid(cellId) > -1) markedCells.push_back(grid().tree().solver2grid(cellId));
      }
    }
    IF_CONSTEXPR(nDim == 3) {
      Geometry3D* auxGeom = new Geometry3D(0, filename[Id], mpiComm());
      for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
        const MFloat cellHalfLength = c_cellLengthAtLevel(a_level(cellId) + 1);
        if(!c_noChildren(cellId) && auxGeom->isOnGeometry(cellHalfLength, &a_coordinate(cellId, 0), "SAT"))

          if(grid().tree().solver2grid(cellId) > -1) markedCells.push_back(grid().tree().solver2grid(cellId));
      }
    }

    MLong tmp = markedCells.size();
    MPI_Allreduce(MPI_IN_PLACE, &tmp, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "tmp");
    m_log << "  overall cells on damping region: " << tmp << endl;
    tmp = 0;

    grid().raw().propagateDistance(markedCells, propDist, dampDist);

    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      if(a_isBndryGhostCell(cellId)) continue;
      const MInt gridCellId = grid().tree().solver2grid(cellId);
      if(gridCellId < 0) continue;
      if(propDist[gridCellId] != numeric_limits<MInt>::max()) {
        m_dampFactor[cellId] = (MFloat)propDist[gridCellId] / ((MFloat)dampDist);
        tmp++;
      }
    }

    MPI_Allreduce(MPI_IN_PLACE, &tmp, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "tmp");
    m_log << "  overall damped cells: " << tmp << endl;
  }
}


//-----------------------------------------------------------------------------
/* Set and allocates all important values and properties concerning the detailed chemistry model
Author: Pedro, Borja, Betreuer: Herff, Sohel
Contact: borja.pedro@rwth-aachen.de
*/
template <MInt nDim_, class SysEqn>
template <class _, std::enable_if_t<isDetChem<SysEqn>, _*>>
void FvCartesianSolverXD<nDim_, SysEqn>::setAndAllocateDetailedChemistryProperties() {
  TRACE();

  if(domainId() == 0) cout << "Starting a full detailed chemistry simulation." << endl;

  m_detChemExtendedOutput = true;
  m_detChemExtendedOutput =
      Context::getSolverProperty<MBool>("detChemExtendedOutput", m_solverId, AT_, &m_detChemExtendedOutput);

  m_acousticAnalysis = false;
  m_acousticAnalysis = Context::getSolverProperty<MBool>("acousticAnalysis", m_solverId, AT_, &m_acousticAnalysis);

  m_YInfinity = nullptr;
  m_molarMass = nullptr;
  m_fMolarMass = nullptr;
  m_standardHeatFormation = nullptr;

  m_detChem.infSpeciesName = nullptr;
  m_detChem.infSpeciesMassFraction = nullptr;


  m_heatReleaseDamp = true;
  m_heatReleaseDamp = Context::getSolverProperty<MBool>("heatReleaseDamp", m_solverId, AT_, &m_heatReleaseDamp);

  m_detChem.hasChemicalReaction =
      Context::getSolverProperty<MBool>("hasChemicalReaction", m_solverId, AT_, &m_detChem.hasChemicalReaction);

  // Infinity Values
  m_detChem.infTemperature =
      Context::getSolverProperty<MFloat>("infTemperature", m_solverId, AT_, &m_detChem.infTemperature);
  m_detChem.infVelocity = Context::getSolverProperty<MFloat>("infVelocity", m_solverId, AT_, &m_detChem.infVelocity);
  m_detChem.infPressure = Context::getSolverProperty<MFloat>("infPressure", m_solverId, AT_, &m_detChem.infPressure);

  m_detChem.laminarFlameSpeedFactor = 1.0;
  m_detChem.laminarFlameSpeedFactor = Context::getSolverProperty<MFloat>("laminarFlameSpeedFactor", m_solverId, AT_,
                                                                         &m_detChem.laminarFlameSpeedFactor);

  const MInt speciesArrayLength = Context::propertyLength("infSpeciesName", m_solverId);
  const MInt massFractionArrayLength = Context::propertyLength("infSpeciesMassFraction", m_solverId);

  ASSERT(speciesArrayLength == massFractionArrayLength,
         "Check speciesArrayLength and massFractionArrayLength. Unequal.");

  mAlloc(m_detChem.infSpeciesName, speciesArrayLength, "infSpeciesName", AT_);
  mAlloc(m_detChem.infSpeciesMassFraction, massFractionArrayLength, "infSpeciesMassFraction", AT_);

  // Array containing species mass fractions at infinity (uniform)
  mAlloc(m_YInfinity, PV->m_noSpecies, "m_YInfinity", F0, AT_);
  mAlloc(m_molarMass, PV->m_noSpecies, "m_molarMass", 0.0, AT_);
  mAlloc(m_fMolarMass, PV->m_noSpecies, "m_fMolarMass", 0.0, AT_);
  mAlloc(m_standardHeatFormation, PV->m_noSpecies, "m_standardHeatFormation", 0.0, AT_);

  MFloat summSpecies = F0;
  for(MInt i = 0; i < speciesArrayLength; ++i) {
    m_detChem.infSpeciesName[i] = Context::getSolverProperty<MString>("infSpeciesName", m_solverId, AT_, i);
    m_detChem.infSpeciesMassFraction[i] =
        Context::getSolverProperty<MFloat>("infSpeciesMassFraction", m_solverId, AT_, i);
    summSpecies += m_detChem.infSpeciesMassFraction[i];
  }

  ASSERT(summSpecies - F1 < m_eps,
         "Initial species mass fraction composition does not equal 1. Check properties file.");

  m_detChem.infPhi = Context::getSolverProperty<MFloat>("infPhi", m_solverId, AT_, &m_detChem.infPhi);

  // Get the name of the reaction mechanism for detailed chemistry computation
  m_detChem.reactionMechanism =
      Context::getSolverProperty<MString>("reactionMechanism", m_solverId, AT_, &m_detChem.reactionMechanism);

  m_detChem.phaseName = Context::getSolverProperty<MString>("phaseName", m_solverId, AT_, &m_detChem.phaseName);

  m_detChem.transportModel =
      Context::getSolverProperty<MString>("transportModel", m_solverId, AT_, &m_detChem.transportModel);

  for(MUint s = 0; s < PV->m_noSpecies; ++s) {
    m_speciesName.push_back(sysEqn().m_species->speciesName[s]);
    m_molarMass[s] = sysEqn().m_species->molarMass[s];
    m_fMolarMass[s] = sysEqn().m_species->fMolarMass[s];
    m_standardHeatFormation[s] = sysEqn().m_species->standardHeatFormation[s];
  }

  // Fill m_YInfinity with non-zero values given in the properties file
  for(MInt i = 0; i < speciesArrayLength; ++i) {
    const MString species = m_detChem.infSpeciesName[i];
    const MInt speciesNameFound = sysEqn().m_species->speciesMap.count(species);
    if(speciesNameFound == true) {
      const MInt speciesIndex = sysEqn().m_species->speciesMap[species];
      m_YInfinity[speciesIndex] = m_detChem.infSpeciesMassFraction[i];
    } else {
      mTerm(1, AT_, "Species name given in the properties file could not be found in the reaction mechanism.");
    }
  }

  if(domainId() == 0) cout << "Allocation of detailed chemistry primary values done." << endl;

  initCanteraObjects();

  m_oneDimFlame = std::make_unique<OneDFlame>(m_detChem.infTemperature, m_detChem.infPressure, m_YInfinity, domainId(),
                                              m_solverId, m_speciesName);

#if defined(WITH_CANTERA)
  m_oneDimFlame->setCanteraObjects(m_canteraSolution, m_canteraThermo, m_canteraKinetics, m_canteraTransport);
#endif

  m_oneDimFlame->run();

  m_oneDimFlame->log(c_cellLengthAtLevel(maxRefinementLevel()));
}

/**
 * @brief Allocates the Cantera objects that define a thermodynamic phase, reaction kinetics and transport properties
 * for a given reaction mechanism.
 *
 */
template <MInt nDim_, class SysEqn>
template <class _, std::enable_if_t<isDetChem<SysEqn>, _*>>
void FvCartesianSolverXD<nDim_, SysEqn>::initCanteraObjects() {
#if defined(WITH_CANTERA)
  m_canteraSolution = Cantera::newSolution(m_detChem.reactionMechanism, m_detChem.phaseName, m_detChem.transportModel);
  m_canteraThermo = m_canteraSolution->thermo();
  m_canteraTransport = m_canteraSolution->transport();
  m_canteraKinetics = m_canteraSolution->kinetics();
#endif
}


/** \brief Dispatches the transport coefficients computation at each surfaces by calling the relevant function from the
detChemSysEqn class. Distinction between "Multi" and "Mix" transport models!
Author: Borja Pedro
*/
#if defined(WITH_CANTERA)
template <MInt nDim_, class SysEqn>
template <class _, std::enable_if_t<isDetChem<SysEqn>, _*>>
void FvCartesianSolverXD<nDim_, SysEqn>::computeSurfaceCoefficients() {
  const MInt noSurfaces = a_noSurfaces();

  const MFloat* const RESTRICT surfaceVars = ALIGNED_F(&a_surfaceVariable(0, 0, 0));
  MFloat* const RESTRICT surfaceCoefficients = hasSC ? ALIGNED_F(&a_surfaceCoefficient(0, 0)) : nullptr;

  const MInt noPVars = PV->noVariables;
  const MUint noSurfaceCoefficients = hasSC ? SC->m_noSurfaceCoefficients : 0;
  const MInt surfaceVarMemory = 2 * PV->noVariables;

  for(MInt srfcId = 0; srfcId < noSurfaces; ++srfcId) {
    const MInt offset = srfcId * surfaceVarMemory;
    const MFloat* const RESTRICT vars0 = ALIGNED_F(surfaceVars + offset);
    const MFloat* const RESTRICT vars1 = ALIGNED_F(vars0 + noPVars);

    const MInt coefficientOffset = srfcId * noSurfaceCoefficients;
    MFloat* const RESTRICT srfcCoeff = hasSC ? ALIGNED_F(surfaceCoefficients + coefficientOffset) : nullptr;
    // MFloat* const RESTRICT srfcCoeff = hasSC ? ALIGNED_F(&a_srfcCoeffs(srfcId, 0)) : nullptr;

    sysEqn().computeSurfaceCoefficients(m_RKStep, vars0, vars1, srfcCoeff, m_canteraThermo, m_canteraTransport);
  }
}
#endif

/** \brief Dispatches the species reaction rate computation at each cell by calling the relevant method from the
detChemSysEqn class.
Author: Borja Pedro
*/
#if defined(WITH_CANTERA)
template <MInt nDim_, class SysEqn>
template <class _, std::enable_if_t<isDetChem<SysEqn>, _*>>
void FvCartesianSolverXD<nDim_, SysEqn>::computeSpeciesReactionRates() {
  Cantera::IdealGasReactor zeroD_reactor;
  zeroD_reactor.insert(m_canteraSolution);

  Cantera::ReactorNet zeroD_reactorNet;
  zeroD_reactorNet.setVerbose(false);
  zeroD_reactorNet.addReactor(zeroD_reactor);
  zeroD_reactorNet.setTolerances(1e-9, 1e-9);

  const MUint noCells = a_noCells();
  const MUint noPVars = PV->noVariables;
  const MUint noAVars = hasAV ? AV->noVariables : 0;

  MFloat* const RESTRICT pvars = &a_pvariable(0, 0);
  MFloat* const RESTRICT reactionRates = &a_speciesReactionRate(0, 0);
  MFloat* const RESTRICT avars = hasAV ? &a_avariable(0, 0) : nullptr;

  for(MUint cellId = 0; cellId < noCells; ++cellId) {
    // Skip halo cells
    if(a_isHalo(cellId)) {
      for(MUint s = 0; s < PV->m_noSpecies; ++s) {
        a_speciesReactionRate(cellId, s) = F0;
      }
      continue;
    }

    const MUint cellPVarOffset = cellId * noPVars;
    const MUint cellAVarOffset = hasAV ? cellId * noAVars : 0;
    const MUint reactionRateOffset = cellId * PV->m_noSpecies;

    const MFloat* const RESTRICT pvarsCell = pvars + cellPVarOffset;
    const MFloat* const RESTRICT avarsCell = hasAV ? avars + cellAVarOffset : nullptr;
    MFloat* const RESTRICT reactionRatesCell = reactionRates + reactionRateOffset;

    sysEqn().computeSpeciesReactionRates(m_timeStep, a_cellVolume(cellId), pvarsCell, avarsCell, reactionRatesCell,
                                         &zeroD_reactor, &zeroD_reactorNet, m_canteraSolution, m_canteraThermo);
  }
}
#endif

/* Computation of relevant detailed chemistry values in the main integration loop
Author: Pedro, Borja, Betreuer: Herff, Sohel
Contact: borja.pedro@rwth-aachen.de
*/
template <MInt nDim_, class SysEqn>
template <class _, std::enable_if_t<isDetChem<SysEqn>, _*>>
void FvCartesianSolverXD<nDim_, SysEqn>::computeDetailedChemistryVariables() {
#if defined(WITH_CANTERA)
  computeSurfaceCoefficients();
#endif
}


/** \brief Dispatches the gamma computation at each cell by calling the relevant function from the
detChemSysEqn class. It is stored inside the additional variables array, and used to compute the time step.
Author: Borja Pedro
*/
#if defined(WITH_CANTERA)
template <MInt nDim_, class SysEqn>
template <class _, std::enable_if_t<isDetChem<SysEqn>, _*>>
void FvCartesianSolverXD<nDim_, SysEqn>::computeGamma() {
  const MUint noCells = a_noCells();
  const MUint noPVars = PV->noVariables;
  const MUint noAVars = hasAV ? AV->noVariables : 0;

  const MFloat* const RESTRICT pvars = &a_pvariable(0, 0);
  MFloat* const RESTRICT avars = hasAV ? &a_avariable(0, 0) : nullptr;

  for(MUint cellId = 0; cellId < noCells; ++cellId) {
    const MUint cellPVarOffset = cellId * noPVars;
    const MUint cellAVarOffset = hasAV ? cellId * noAVars : 0;

    const MFloat* const RESTRICT pvarsCell = pvars + cellPVarOffset;
    MFloat* const RESTRICT avarsCell = hasAV ? avars + cellAVarOffset : nullptr;

    sysEqn().computeGamma(pvarsCell, avarsCell, m_canteraThermo);
  }
}
#endif

/** \brief Dispatches the mean molar weight computation at the cell center from the conservative variables by calling
the relevant function from the detChemSysEqn class. The mean molar weight is stored inside the additional variables
array.
Author: Borja Pedro
*/
template <MInt nDim_, class SysEqn>
template <class _, std::enable_if_t<isDetChem<SysEqn>, _*>>
void FvCartesianSolverXD<nDim_, SysEqn>::computeMeanMolarWeights_CV() {
  const MUint noCells = a_noCells();
  const MUint noCVars = CV->noVariables;
  const MUint noAVars = hasAV ? AV->noVariables : 0;

  MFloat* const RESTRICT cvars = &a_variable(0, 0);
  MFloat* const RESTRICT avars = hasAV ? &a_avariable(0, 0) : nullptr;

  for(MUint cellId = 0; cellId < noCells; ++cellId) {
    const MUint cellCVarOffset = cellId * noCVars;
    const MUint cellAVarOffset = hasAV ? cellId * noAVars : 0;

    const MFloat* const RESTRICT cvarsCell = cvars + cellCVarOffset;
    MFloat* const RESTRICT avarsCell = hasAV ? avars + cellAVarOffset : nullptr;

    sysEqn().computeMeanMolarWeight_CV(cvarsCell, avarsCell);
  }
}

/** \brief Dispatches the mean molar weight computation at the cell center from the primitive variables by calling
the relevant function from the detChemSysEqn class. The mean molar weight is stored inside the additional variables
array.
Author: Borja Pedro
*/
template <MInt nDim_, class SysEqn>
template <class _, std::enable_if_t<isDetChem<SysEqn>, _*>>
void FvCartesianSolverXD<nDim_, SysEqn>::computeMeanMolarWeights_PV() {
  const MUint noCells = a_noCells();
  const MUint noPVars = PV->noVariables;
  const MUint noAVars = hasAV ? AV->noVariables : 0;

  MFloat* const RESTRICT pvars = &a_pvariable(0, 0);
  MFloat* const RESTRICT avars = hasAV ? &a_avariable(0, 0) : nullptr;

  for(MUint cellId = 0; cellId < noCells; ++cellId) {
    const MUint cellPVarOffset = cellId * noPVars;
    const MUint cellAVarOffset = hasAV ? cellId * noAVars : 0;

    const MFloat* const RESTRICT pvarsCell = pvars + cellPVarOffset;
    MFloat* const RESTRICT avarsCell = hasAV ? avars + cellAVarOffset : nullptr;

    sysEqn().computeMeanMolarWeight_PV(pvarsCell, avarsCell);
  }
}

/** \brief Computes the mean molar weight at the given cell ID from the primitive variables. The mean molar weight is
stored inside the additional variables array.
Author: Borja Pedro
*/
template <MInt nDim_, class SysEqn>
template <class _, std::enable_if_t<isDetChem<SysEqn>, _*>>
void FvCartesianSolverXD<nDim_, SysEqn>::setMeanMolarWeight_CV(MInt cellId) {
  const MFloat* const cvarsCell = &a_variable(cellId, 0);
  MFloat* const avarsCell = hasAV ? &a_avariable(cellId, 0) : nullptr;

  sysEqn().computeMeanMolarWeight_CV(cvarsCell, avarsCell);
}

template <MInt nDim_, class SysEqn>
template <class _, std::enable_if_t<isDetChem<SysEqn>, _*>>
void FvCartesianSolverXD<nDim_, SysEqn>::setMeanMolarWeight_PV(MInt cellId) {
  const MFloat* const pvarsCell = &a_pvariable(cellId, 0);
  MFloat* const avarsCell = hasAV ? &a_avariable(cellId, 0) : nullptr;

  sysEqn().computeMeanMolarWeight_PV(pvarsCell, avarsCell);
}

/** \brief Corrects the mass fraction of the predominant species to ensure conservation due to numerical or
approximation erros For combustion with air: N2 is the major species Author: Borja Pedro
*/
template <MInt nDim_, class SysEqn>
template <class _, std::enable_if_t<isDetChem<SysEqn>, _*>>
void FvCartesianSolverXD<nDim_, SysEqn>::correctMajorSpeciesMassFraction() {
  const MInt majorSpeciesIndex = sysEqn().m_species->majorSpeciesIndex;

  for(MInt cellId = 0; cellId < a_noCells(); ++cellId) {
    MFloat massFractionSum = F0;
    for(MInt s = 0; s < m_noSpecies; ++s) {
      if(s == majorSpeciesIndex) {
        continue;
      }
      massFractionSum += a_variable(cellId, CV->RHO_Y[s]);
    }
    a_variable(cellId, CV->RHO_Y[majorSpeciesIndex]) = a_variable(cellId, CV->RHO) - massFractionSum;
  }
}

/*! \brief Allocates and initializes send/receive buffers for multiSolver computations
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::allocateCommunicationMemory() {
  TRACE();

  // Deallocate all previous communication buffers
  mDeallocate(m_maxLevelHaloCells);
  mDeallocate(m_maxLevelWindowCells);
  mDeallocate(m_noMaxLevelHaloCells);
  mDeallocate(m_noMaxLevelWindowCells);
  mDeallocate(m_sendBuffers);
  mDeallocate(m_receiveBuffers);
  mDeallocate(m_mpi_request);
  mDeallocate(m_sendBuffersNoBlocking);
  mDeallocate(m_receiveBuffersNoBlocking);
  mDeallocate(m_mpi_sendRequest);
  mDeallocate(m_mpi_receiveRequest);

  // Init all communication properties to false
  m_nonBlockingComm = false;

  // Allocate memory and really initialize communication properties
  if(noNeighborDomains() > 0 && isActive()) {
    ScratchSpace<MInt> haloCellsCnt(noNeighborDomains(), AT_, "noHaloCells");
    ScratchSpace<MInt> windowCellsCnt(noNeighborDomains(), AT_, "noWindowCells");
    MInt totalNoWindowCells = 0;
    MInt totalNoHaloCells = 0;
    for(MInt d = 0; d < noNeighborDomains(); d++) {
      haloCellsCnt[d] = noHaloCells(d);
      totalNoHaloCells += noHaloCells(d);
      windowCellsCnt[d] = noWindowCells(d);
      totalNoWindowCells += noWindowCells(d);
    }

    MPI_Allreduce(MPI_IN_PLACE, &totalNoWindowCells, 1, type_traits<MInt>::mpiType(), MPI_MAX, mpiComm(), AT_,
                  "MPI_IN_PLACE", "totalNoWindowCells");
    MPI_Allreduce(MPI_IN_PLACE, &totalNoHaloCells, 1, type_traits<MInt>::mpiType(), MPI_MAX, mpiComm(), AT_,
                  "MPI_IN_PLACE", "totalNoHaloCells");

    stringstream message;
    message << "Solver #" << solverId() << " - maximum number of window cells among ranks: " << totalNoWindowCells
            << std::endl;
    message << "Solver #" << solverId() << " - maximum number of halo cells among ranks: " << totalNoHaloCells
            << std::endl;
    m_log << message.str();
    cerr0 << message.str();

    mAlloc(m_maxLevelHaloCells, noNeighborDomains(), &haloCellsCnt[0], "m_maxLevelHaloCells", AT_);
    mAlloc(m_maxLevelWindowCells, noNeighborDomains(), &windowCellsCnt[0], "m_maxLevelWindowCells", AT_);
    mAlloc(m_noMaxLevelHaloCells, noNeighborDomains(), "m_noMaxLevelHaloCells", 0, AT_);
    mAlloc(m_noMaxLevelWindowCells, noNeighborDomains(), "m_noMaxLevelWindowCells", 0, AT_);

    mAlloc(m_sendBuffers, noNeighborDomains(), &windowCellsCnt[0], m_dataBlockSize, "m_sendBuffers", AT_);
    mAlloc(m_receiveBuffers, noNeighborDomains(), &haloCellsCnt[0], m_dataBlockSize, "m_receiveBuffers", AT_);
    mAlloc(m_mpi_request, noNeighborDomains(), "m_mpi_request", AT_);

    m_nonBlockingComm = Context::getSolverProperty<MBool>("nonBlockingComm", m_solverId, AT_, &m_nonBlockingComm);

    if(g_splitMpiComm && !m_nonBlockingComm) {
      mTerm(1, "Activate nonBlockingComm to make split MPI communication work (splitMpiComm).");
    }

    // Allocate space for non-blocking send and receive buffers:
    if(m_nonBlockingComm) {
      mAlloc(m_sendBuffersNoBlocking, noNeighborDomains(), &windowCellsCnt[0], m_dataBlockSize,
             "m_sendBuffersNoBlocking", AT_);
      mAlloc(m_receiveBuffersNoBlocking, noNeighborDomains(), &haloCellsCnt[0], m_dataBlockSize,
             "m_receiveBuffersNoBlocking", AT_);
      mAlloc(m_mpi_receiveRequest, noNeighborDomains(), "m_mpi_receiveRequest ", AT_);
      mAlloc(m_mpi_sendRequest, noNeighborDomains(), "m_mpi_sendRequest", AT_);
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        m_mpi_receiveRequest[i] = MPI_REQUEST_NULL;
        m_mpi_sendRequest[i] = MPI_REQUEST_NULL;
      }
    }
  }
}

/* \brief copies grid-properties to the fvcellcollector
 *  This includes the coordinates, the level, IsHalo and IsPeriodic-properties
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::copyGridProperties() {
  // a) Copy coordinates from grid-tree to fvcellcollector
  for(MInt id = 0; id < a_noCells(); ++id) {
    assertValidGridCellId(id);
    for(MInt dir = 0; dir < nDim; ++dir) {
      a_coordinate(id, dir) = c_coordinate(id, dir);
    }
  }

  // b) Copy level from grid-tree to fvcellcollector
  for(MInt id = 0; id < a_noCells(); ++id) {
    a_level(id) = c_level(id);
  }

  // c) Initialize Properties
  for(MInt c = 0; c < a_noCells(); c++) {
    a_isHalo(c) = false;
    a_isWindow(c) = false;
    a_isPeriodic(c) = false;
  }

  // d) Set Properties for valid-grid-cells
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    for(MInt c = 0; c < noHaloCells(i); c++) {
      a_isHalo(haloCellId(i, c)) = true;
    }
  }
  // Azimuthal periodicity exchange halos
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MInt c = 0; c < grid().noAzimuthalHaloCells(i); c++) {
      a_isHalo(grid().azimuthalHaloCell(i, c)) = true;
    }
  }
  for(MInt c = 0; c < grid().noAzimuthalUnmappedHaloCells(); c++) {
    a_isHalo(grid().azimuthalUnmappedHaloCell(c)) = true;
  }

  // e) Set Properties for valid-grid-cells
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    for(MInt c = 0; c < noWindowCells(i); c++) {
      a_isWindow(windowCellId(i, c)) = true;
    }
  }
  // Azimuthal periodicity exchange windows
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MInt c = 0; c < grid().noAzimuthalWindowCells(i); c++) {
      a_isWindow(grid().azimuthalWindowCell(i, c)) = true;
    }
  }

  // Inactive can only have halo cells, however noNeighborDomains=-1
  if(!isActive()) {
    for(MInt c = 0; c < a_noCells(); c++) {
      a_isHalo(c) = true;
    }
  }

  for(MInt id = 0; id < a_noCells(); ++id) {
    //      if (a_hasProperty( id , SolverCell::IsSplitChild )) continue;
    assertValidGridCellId(id);
    a_isPeriodic(id) = grid().isPeriodic(id);
  }
}


/* \brief Initializes the properties of the FvCartesianSolver.
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initializeFvCartesianSolver(const MBool* /* propertiesGroups */) {
  TRACE();

  // Output FVSubSolvers status:
  m_log << endl << "------------Properties Groups----------" << endl;
  m_log << "Levelset is   " << (m_levelSet ? "on" : "off") << "!" << endl;
  m_log << "Mb is         " << (m_levelSetMb ? "on" : "off") << "!" << endl;
  m_log << "Combustion is " << (m_combustion ? "on" : "off") << "!" << endl;
  m_log << "LS with RANS is " << (m_levelSetRans ? "on" : "off") << "!" << endl;
  m_log << endl << "-------------Other Switches-----------" << endl;
  m_log << "Thickened Flame is " << (m_thickenedFlame ? "on" : "off") << "!" << endl;
  m_log << endl;

  m_hasExternalSource = false;
  m_hasExternalSource =
      m_hasExternalSource
      || Context::getSolverProperty<MBool>("particleMomentumCoupling", m_solverId, AT_, &m_hasExternalSource)
      || Context::getSolverProperty<MBool>("particleHeatCoupling", m_solverId, AT_, &m_hasExternalSource)
      || Context::getSolverProperty<MBool>("particleMassCoupling", m_solverId, AT_, &m_hasExternalSource);


  // initialize externalSource data which is added to the right hand side
  if(m_hasExternalSource) {
    mAlloc(m_externalSource, maxNoGridCells(), CV->noVariables, "m_externalForces", 0.0, AT_);
    m_log << "Allocated memory for external sources." << endl;
  }

  // initialize external mass flux
  if(m_sensorParticle) {
    ASSERT(this->m_adaptation, "");
    mAlloc(m_noParts, grid().maxNoCells(), "m_noParts", 0, AT_);
  }

  m_bndryGhostCellsOffset = a_noCells();

  // Memory parameters:
  m_maxNoSurfaces = Context::getSolverProperty<MInt>("maxNoSurfaces", m_solverId, AT_);

  m_dataBlockSize = mMax(CV->noVariables, PV->noVariables);
  m_slopeMemory = PV->noVariables * nDim;   // slope offsets
  m_surfaceVarMemory = 2 * PV->noVariables; // surface offsets

  // Post-processing parameters:
  m_oldMomentOfVorticity = F0;         // only required if m_recordLandA is true
  m_oldNegativeMomentOfVorticity = F0; // only required if m_recordLandA is true
  m_oldPositiveMomentOfVorticity = F0; // only required if m_recordLandA is true

  // Array for MB use - will be allocated in fvmbsolver2d/3d construcors
  m_associatedBodyIds = (MInt*)nullptr;
  m_internalBodyId = (MInt*)nullptr;

  // Basic initialization of m_timeStep -> will be done correctly later in computeTimeStep()
  forceTimeStep(0);

  /*! \page propertiesFV
    \section calcSlopesAfterStep
    <code>MBool FvCartesianSolver::m_calcSlopesAfterStep</code>\n
    default = <code>0</code>\n \n
    Calculate the cell center slopes at the end of each Runge-Kutta stage and
    not at the start of the next one. This should be activated if the slopes are
    used outside of the FV time-step loop in order to have the correct
    derivatives belonging to the current primitive variables. Possible use cases
    are: averaging of derivatives/vorticity/..., calculation of acoustic source
    terms for the APE.
    Possible values are:
    <ul>
    <li>0: deactivated</li>
    <li>1: activated</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, POSTPROCESSING, COUPLING</i>
  */
  m_calcSlopesAfterStep = false;
  m_calcSlopesAfterStep =
      Context::getSolverProperty<MBool>("calcSlopesAfterStep", m_solverId, AT_, &m_calcSlopesAfterStep);

  m_lsCutCellBaseLevel = maxRefinementLevel();
}

/**
 * \fn void FvCartesianSolverXD::allocateAndInitSolverMemory()
 * \brief Allocates the resources of the FV solver.
   Mostly arrays of size maxNoCells used in the main part of the FV code
   plus - if required - moving grid arrays.
   IMPORTANT: This method should be called at the end of the FvCartesianSolver-Constructor,
   since other properties might be used in here, or datastructures previosly allocated might be referenced!
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::allocateAndInitSolverMemory() {
  TRACE();

  const MInt maxNoCells = maxNoGridCells();

  /*! \page propertiesFV
    \section rotAxisCoord
    <code>MBool FvCartesianSolver::m_rotAxisCoord</code>\n
    default = <code>0.0</code>\n \n
    Coordinates of the rotational axis for azimuthal perodicity
    Possible values are:
    <ul>
    <li>Floating point numbers</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, FAN, AZIMUTHAL PERIODICITY</i>
  */
  // Periodic bc recources (azimuthal periodicity concept)
  if(m_periodicCells == 1 || m_periodicCells == 2 || m_periodicCells == 3) {
    MInt m_maxNoPeriodicCells = 0;
    /*! \page propertiesFV
      \section maxNoPeriodicCells
      <code>MInt FvCartesianSolver::m_maxNoPeriodicCells</code>\n
      default = <code>0</code>\n \n
      Maximum number of periodic cells. Used to allocate memory for the periodic cells.
      Possible values are:
      <ul>
      <li>Integer numbers</li>
      </ul>
      Keywords: <i>FINITE_VOLUME, PERIODIC, MAXIMUM</i>
    */
    m_maxNoPeriodicCells =
        Context::getSolverProperty<MInt>("maxNoPeriodicCells", m_solverId, AT_, &m_maxNoPeriodicCells);

    mAlloc(m_sortedPeriodicCells, m_maxNoPeriodicCells, "m_sortedPeriodicCells", -1, AT_);
    mAlloc(m_rotAxisCoord, 2, "rotAxisCoord", F0, AT_);
    for(MInt i = 0; i < 2; i++) {
      m_rotAxisCoord[i] = 0.0;
      m_rotAxisCoord[i] = Context::getSolverProperty<MFloat>("rotAxisCoord", m_solverId, AT_, &m_rotAxisCoord[i], i);
    }
  }

  // Finite volume resources:
  MBool bndryRfnJump = false;
  bndryRfnJump = Context::getSolverProperty<MBool>("bndryRfnJump", m_solverId, AT_, &bndryRfnJump);
  if(bndryRfnJump) {
    mAlloc(m_bndryRfnJumpInformation_, maxNoCells, "m_bndryRfnJumpInformation_", -1, AT_);
    mAlloc(m_bndryRfnJumpInformation, maxNoCells * 4, "m_bndryRfnJumpInformation", -1, AT_);
  }

  m_surfaces.setNoSpecies(m_noSpecies);
  m_surfaces.setNoMaxSrfcs(m_maxNoSurfaces);
  m_surfaces.setNoVariables(PV->noVariables);
  m_surfaces.setNoFVariables(FV->noVariables);
  const MInt noSurfaceCoefficients = hasSC ? SC->m_noSurfaceCoefficients : 0;
  m_surfaces.setNoSurfaceCoefficients(noSurfaceCoefficients);
  m_surfaces.setSolverType(string2enum(Context::getSolverProperty<MString>("solvertype", m_solverId, AT_)));
  m_surfaces.reset(m_maxNoSurfaces);

  m_noActiveCells = 0;
  m_reconstructionConstants.reserve(2 * nDim * a_noCells() * nDim);
  m_reconstructionCellIds.reserve(2 * nDim * a_noCells());
  m_reconstructionNghbrIds.reserve(2 * nDim * a_noCells());
  mAlloc(m_A, m_cells.noRecNghbrs(), m_cells.noRecNghbrs(), "m_A", F0, AT_);
  mAlloc(m_ATA, m_cells.noRecNghbrs(), m_cells.noRecNghbrs(), "m_ATA", F0, AT_);
  mAlloc(m_ATAi, m_cells.noRecNghbrs(), m_cells.noRecNghbrs(), "m_ATAi", F0, AT_);
  mAlloc(m_cellSurfaceMapping, maxNoGridCells(), m_noDirs, "m_cellSurfaceMapping", -1, AT_);

  // Allocate memory for vorticity if vorticity averaging is enabled, otherwise
  // make sure that MAIA fails fast if the m_vorticity member variable is used
  if(m_averageVorticity) {
    mAlloc(m_vorticity, noInternalCells(), m_vorticitySize, "m_vorticity", AT_);
    for(MInt i = 0; i < noInternalCells(); i++) {
      for(MInt j = 0; j < m_vorticitySize; j++) {
        m_vorticity[i][j] = 0.0;
      }
    }
  } else {
    m_vorticity = nullptr;
  }

  // domain sizes:
  mAlloc(m_domainBoundaries, 2 * nDim, "m_domainBoundaries", F0, AT_);

  // Kronecker delta:
  mAlloc(m_kronecker, nDim, nDim, "m_kronecker", F0, AT_);
  for(MInt i = 0; i < nDim; i++) {
    m_kronecker[i][i] = F1;
  }

  m_bodyCenter = nullptr;
  m_bodyVelocity = nullptr;
  m_bodyVelocityDt1 = nullptr;
  m_bodyVelocityDt2 = nullptr;
  m_bodyTemperature = nullptr;
}

/*! \fn void FvCartesianSolverXD<nDim_,SysEqn>::setTestcaseProperties()
 * \brief Reads and initializes properties associated with the physics of the simulation
   and allocates small arrays of these properties.
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setTestcaseProperties() {
  TRACE();
  MBool tmpFalse = false;

  /*! \page propertiesFV
    \section maxIterations
    <code>MBool FvCartesianSolver::m_maxIterations</code>\n
    default = <code>1</code> \n \n
    Sets the number of maximum iterations in solutionStep\n
    Possible values are:
    <ul>
    <li> Any int value greater than 0 </li>
    </ul>
    Keywords: <i>FINITE_VOLUME</i>
  */
  m_maxIterations = 1;
  m_maxIterations = Context::getSolverProperty<MInt>("maxIterations", m_solverId, AT_, &m_maxIterations);

  /*! \page propertiesFV
  \section periodicCells
  default = 0 \n \n
  Chooses the method in which cells are identified in the azimuthal periodicity concept.\n
  Possible values are:
  <ul>
  <li>0 Deactivated </li>
  <li>1 azimuthal periodicity (with LS interpolation) </li>
  <li>2 special case: periodicity in x-direction (without LS interpolation) </li>
  <li>3 special case: periodicity in x-direction (without LS interpolation + volume forcing) </li>
  </ul>
  Keywords: <i>FINITE_VOLUME</i>
 */
  m_periodicCells = 0;
  m_periodicCells = Context::getSolverProperty<MInt>("periodicCells", m_solverId, AT_, &m_periodicCells);

  m_referenceLength = F1;
  /*! \page propertiesFV
    \section referenceLength
    <code>MFloat FvCartesianSolver::m_Pr </code>\n
    default = <code>1.0</code>\n \n
    WARNING: Do NOT use any value different than 1.0 - The correct implementation of this is not checked, so it probably
    will not do what you think it does/should do. Don't use it unless you REALLY know what you are doing. Reference
    Length L - The length = 1.0 of the grid is scaled with L. Possible values are: <ul> <li>1.0 +- eps</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, VARIABLES</i>
  */
  m_referenceLength = Context::getSolverProperty<MFloat>("referenceLength", m_solverId, AT_, &m_referenceLength);

  if(fabs(m_referenceLength - F1) > m_eps) {
    m_log << "WARNING: referenceLength != 1.0. The correct implementation of this is not checked. Don't use it "
             "unless you REALLY know what you are doing."
          << endl;
  }

  /*! \page propertiesFV
    \section Re
    <code>MFloat FvCartesianSolver::m_Re </code>\n
    default = <code>no default value</code>\n \n
    Reynolds number is defined with your infinity variables. \n
    In the code the Reynolds number is nondimensionalized to a Reynolds number based on the stagnation variables a_0,
    mu_0, rho_0 \n \f$ Re_{0} = Re_{\infty}  \frac{\mu_{\infty}}{\rho_{\infty} Ma \sqrt{T_{\infty}} } = \frac{\rho_0 a_0
    l}{\mu_{0}}\f$: <ul> <li> \f$ mu_{\infty} \f$,  \f$ mu_{0} \f$ - viscosity  by the infinity, stagnation temperature
    </li> <li> \f$ Ma \f$ is the mach number </li> <li> \f$ T_{\infty} \f$ is the infinity temperature (free stream
    temperature)</li>
    </ul>
    possible values are:
    <ul>
    <li>Non-negative floating point values of the order of 0.1</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, VARIABLES</i>
  */
  m_Re = Context::getSolverProperty<MFloat>("Re", m_solverId, AT_) / m_referenceLength;

  /*! \page propertiesFV
    \section Pr
    <code>MFloat FvCartesianSolver::m_Pr </code>\n
    default = <code>0.72</code>\n \n
    Prandtl number  - non-dimensionalized with stagnant flow conditions
    \f$ \mu_{0},  \lambda_{0}, c_{p} \f$:
    possible values are:
    <ul>
    <li>Non-negative floating point values</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, VARIABLES</i>
  */
  m_Pr = 0.72;
  m_Pr = Context::getSolverProperty<MFloat>("Pr", m_solverId, AT_, &m_Pr);
  m_rPr = 1. / m_Pr;

  /*! \page propertiesFV
    \section Ma
    <code>MFloat FvCartesianSolver::m_Ma </code>\n
    default = <code>no default value</code>\n \n
    Mach's number - \f$ M_{\infty} = \frac{u_\infty}{a_\infty} \f$:
    possible values are:
    <ul>
    <li>Non-negative floating point values</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, VARIABLES</i>
  */
  m_Ma = Context::getSolverProperty<MFloat>("Ma", m_solverId, AT_);

  /*! \page propertiesFV
    \section angle
    <code>MFloat* FvCartesianSolver::m_angle </code>\n
    default = <code>no default value</code>\n \n
    m_angle[nDim] - Angles of rotation around the z, and y axes.
    possible values are:
    <ul>
    <li>Non-negative floating point values</li>
    </ul>
    Keywords: <i>FINITE_VOLUME,BOUNDARY CONDITION</i>
  */
  mAlloc(m_angle, nDim, "m_angle", F0, AT_);
  m_angle[0] = 0;
  m_angle[1] = 0.;
  if(Context::propertyExists("angle", m_solverId)) {
    for(MInt i = 0; i < (nDim - 1); i++) {
      m_angle[i] = Context::getSolverProperty<MFloat>("angle", m_solverId, AT_, i);
      m_angle[i] *= PI / 180.0;
    }
  }

  m_gamma = 1.4;
  /*! \page propertiesFV
    \section gamma
    <code>MFloat FvCartesianSolver::m_gamma </code>\n
    default = <code>1.4</code>\n \n
    Ratio of specific heats - \f$ \gamma = c_p / c_v \f$
    possible values are:
    <ul>
    <li>Non-negative floating point values</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, VARIABLES</i>
  */
  m_gamma = Context::getSolverProperty<MFloat>("gamma", m_solverId, AT_, &m_gamma);

  m_considerVolumeForces = false;
  /*! \page propertiesFV
    \section considerVolumeForces
    <code>MBool FvCartesianSolver::m_considerVolumeForces </code>\n
    default = <code>false</code>\n \n
    Enables volume forces, possible values are: true/false
    <ul>
    <li>Non-negative floating point values</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, VARIABLES</i>
  */
  m_considerVolumeForces = Context::getSolverProperty<MBool>("considerVolumeForces", m_solverId, AT_, &tmpFalse);

  /*! \page propertiesFV
    \section considerRotForces
    <code>MBool FvCartesianSolver::m_considerRotForces</code>\n
    default = <code>false</code>\n \n
    Incorporate centrifugal and coriolis forces for computations in a rotationg frame of reference.
    \n \n Possible values are:
    <ul>
      <li><code>0</code> (off)</li>
      <li><code>1</code> (on)</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, FORCES, ROTATION</i>
  */
  m_considerRotForces = false;
  m_considerRotForces = Context::getSolverProperty<MBool>("considerRotForces", m_solverId, AT_, &tmpFalse);

  mAlloc(m_volumeAcceleration, nDim, "m_volumeAcceleration", F0, AT_);

  if(m_considerVolumeForces) {
    // NOTE: the volume acceleration in the property file needs to be non-dimensionalised
    //      as the entire fv-code, i.e. by * L_ref / (a_ref^2)
    //      with L_ref as the physical reference length and a_ref as the reference speed of sound!
    for(MInt i = 0; i < nDim; i++) {
      m_volumeAcceleration[i] =
          Context::getSolverProperty<MFloat>("volumeForce", m_solverId, AT_, &m_volumeAcceleration[i], i);
    }
  }

  /*! \page propertiesFV
    \section initialCondition
    <code>MInt FvCartesianSolver::m_initialCondition </code>\n
    default = <code>no default value</code>\n \n
    Selects the initial condition.
    possible values are:
    <ul>
    <li>See the initialCondition</li>
    </ul>
    Keywords: <i>INITIAL_CONDITION, FINITE_VOLUME</i>
  */
  m_initialCondition = Context::getSolverProperty<MInt>("initialCondition", m_solverId, AT_);

  /*! \page propertiesFV
  \section govEqs
  default = <code>NAVIER_STOKES</code>\n \n
  Choose between Navier-Stokes and Euler equation.
  Possible values are:
  <ul>
  <li>EULER or NAVIER_STOKES</li>
  </ul>
  Keywords: <i>FINITE_VOLUME</i>
*/
  MString govEqs = "NAVIER_STOKES";
  govEqs = Context::getSolverProperty<MString>("govEqs", m_solverId, AT_, &govEqs);

  m_euler = false;
  if(string2enum(govEqs) == EULER) {
    m_euler = true;
  }

  m_gasConstant = 8.314472; // J/K/mol
  /*! \page propertiesFV
    \section gasConstant
    <code>MFloat FvCartesianSolver::m_gasConstant </code>\n
    default = <code>8.314472 J/K/mol</code>\n \n
    Universal Gas Constant -  \f$ R = c_p - c_v = (\gamma - 1) c_v \f$
    possible values are:
    <ul>
    <li>Non-negative floating point values</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, VARIABLES</i>
  */
  m_gasConstant = Context::getSolverProperty<MFloat>("gasConstant", m_solverId, AT_, &m_gasConstant);

  m_referenceTemperature = 273.15;
  /*! \page propertiesFV
    \section referenceTemperature
    <code>MFloat FvCartesianSolver::m_referenceTemperature </code>\n
    default = <code>273.15</code>\n \n
   Reference temperature \f$ T_{\mathrm{ref}}\f$
   Used to scale the Sutherland's constant as follows: \f$ S/T_{\mathrm{ref}} \f$
   Also used for the computation of the reference sound speed and combustion (TF) related quantities
    possible values are:
    <ul>
    <li>Non-negative floating point values</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, VARIABLES</i>
  */
  m_referenceTemperature =
      Context::getSolverProperty<MFloat>("referenceTemperature", m_solverId, AT_, &m_referenceTemperature);

  m_sutherlandConstant = 110.4;
  /*! \page propertiesFV
    \section sutherlandConstant
    <code>MFloat FvCartesianSolver::m_sutherlandConstant </code>\n
    default = <code>110.4 K</code>\n \n
    Sutherland's constant. Used by Sutherland's law.
    possible values are:
    <ul>
    <li>Non-negative floating point values</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, VARIABLES</i>
  */
  m_sutherlandConstant =
      Context::getSolverProperty<MFloat>("sutherlandConstant", m_solverId, AT_, &m_sutherlandConstant);

  m_sutherlandConstantThermal = m_sutherlandConstant; // default value assumes a constant Prandtl number
  /*! \page propertiesFV
    \section sutherlandConstantThermal
    <code>MFloat FvCartesianSolver::m_sutherlandConstantThermal </code>\n
    default = <code>110.4 K</code>\n \n
    Sutherland's constant for thermal conductivity. Recommended value: 194.0. See 'Viscous Fluid Flow' by F.M. White.
    possible values are:
    <ul>
    <li>Non-negative floating point values</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, VARIABLES</i>
  */
  m_sutherlandConstantThermal =
      Context::getSolverProperty<MFloat>("sutherlandConstantThermal", m_solverId, AT_, &m_sutherlandConstantThermal);

  m_sutherlandConstant /= m_referenceTemperature;
  m_sutherlandPlusOne = m_sutherlandConstant + F1;
  m_sutherlandConstantThermal /= m_referenceTemperature;
  m_sutherlandPlusOneThermal = m_sutherlandConstantThermal + F1;


  m_changeMa = false;
  /*! \page propertiesFV
    \section changeMa
    <code>MBool FvCartesianSolver::m_changeMa </code>\n
    default = <code>0</code>\n \n
   Used to change the Ma number without generating a wave at the inlet
   the primitive restart variables are converted
    possible values are:
    <ul>
    <li>integers</li>
    </ul>
    Keywords: <i>RESTART, VARIABLES</i>
  */
  m_changeMa = Context::getSolverProperty<MBool>("changeMa", m_solverId, AT_, &m_changeMa);


  m_previousMa = m_Ma;
  /*! \page propertiesFV
    \section previousMa
    <code>MFloat FvCartesianSolver::m_previousMa </code>\n
    default = <code>m_Ma</code>\n \n
   Used to change the Ma number without generating a wave at the inlet
   needed for the conversion that is activated with the changeMa property
    possible values are:
    <ul>
    <li>Non-negative floating point values</li>
    </ul>
    Keywords: <i>RESTART, VARIABLES</i>
  */
  m_previousMa = Context::getSolverProperty<MFloat>("previousMa", m_solverId, AT_, &m_previousMa);


  m_useCreateCutFaceMGC = false;
  /*! \page propertiesFV
    \section useCreateCutFaceMGC
    <code>MBool FvCartesianSolver::m_useCreateCutFaceMGC </code>\n
    default = <code>0</code>\n \n
    enables the usage of createCutFaceMGC without setting m_mutipleGhostCells, only matters for 3D
    possible values are:
    <ul>
    <li>integers</li>
    </ul>
    Keywords: <i>MGC, CutFace</i>
  */
  m_useCreateCutFaceMGC =
      Context::getSolverProperty<MBool>("useCreateCutFaceMGC", m_solverId, AT_, &m_useCreateCutFaceMGC);


  /*! \page propertiesFV
    \section Strouhal
    <code>MFloat FvCartesianSolver::m_strouhal</code>\n
    default = <code>2 * pi</code>\n \n
    Set the Strouhal number needed for certain combustion related cases. \n
    Possible values are:
    <ul>
    <li>any positive floating point value</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, COMBUSTION, STROUHAL</i>
  */
  m_strouhal = F2 * PI;
  m_strouhal = Context::getSolverProperty<MFloat>("Strouhal", m_solverId, AT_, &m_strouhal);

  // Parameters for flow forcing:
  m_forcing = false;
  m_forcingAmplitude = F1B2;
  m_noForcingCycles = 5;

  m_forcing = Context::getSolverProperty<MBool>("forcing", m_solverId, AT_, &m_forcing);
  if(m_forcing) {
    /*! \page propertiesFV
      \section forcingAmplitude
      <code>MFloat FvCartesianSolver::m_forcingAmplitude</code>\n
      default = <code>0.5</code>\n \n
      Sets the forcing amplitude.  \n \n
      Possible values are:
      <ul>
      <li>any positive floating point value</li>
      </ul>
      Keywords: <i>FINITE_VOLUME, COMBUSTION, STROUHAL</i>
    */
    m_forcingAmplitude = Context::getSolverProperty<MFloat>("forcingAmplitude", m_solverId, AT_, &m_forcingAmplitude);

    /*! \page propertiesFV
     \section noForcingCycles
     <code>MInt FvCartesianSolver::m_noForcingCycles </code>\n
     default = <code>5</code>\n \n
     sets the number of forcing cycles
     possible values are:
     <ul>
     <li>Non-negative integers</li>
     </ul>
     Keywords: <i>FINITE_VOLUME, FORCING, INFLOW </i>
   */
    m_noForcingCycles = Context::getSolverProperty<MInt>("noForcingCycles", m_solverId, AT_, &m_noForcingCycles);
  }

  /*! \page propertiesFV
      \section cutOffInterface
      <code>MInt FvCartesianSolver::m_cutOffInterface</code>\n
      default = <code>none</code>\n \n
      Takes ids of cut off boundary conditions that are applied to interface cells.
      These interface cells are excluded from m_bndryCells.
      <ul>
      <li> any existing cut off bndryId </li>
      </ul>
      Keywords: <i> FINITE_VOLUME, CUTOFF </i>
    */
  if(Context::propertyExists("cutOffInterface", m_solverId)) {
    MInt noCutOffInterface = Context::propertyLength("cutOffInterface", m_solverId);
    for(MInt i = 0; i < noCutOffInterface; i++) {
      m_cutOffInterface.insert(Context::getSolverProperty<MInt>("cutOffInterface", m_solverId, AT_, i));
    }
  }

  // read test case identifier
  // (used for some ugly hardcoded parts of the code, mainly with the MGC Method... (claudia)
  /*! \page propertiesFV
      \section testCaseName
      <code>MInt FvCartesianSolver::m_testCaseName</code>\n
      default = <code>none</code>\n \n
      Read test case identifier (used for some ugly hardcoded parts of the code, mainly with the MGC Method... (claudia)
      Keywords: <i> FINITE_VOLUME, CUTOFF </i>
    */
  m_testCaseName = "NONE";
  m_testCaseName = Context::getSolverProperty<MString>("testCaseName", m_solverId, AT_, &m_testCaseName);


  /*! \page propertiesFV
    \section weightFvBndryCells
    <code>MBool FvCartesianSolver::m_weightBndryCells</code>\n
    default = <code>true</code>\n \n
    Enable weighting of boundary cells for balancing or when setting new grid partition workloads.\n
    Keywords: <i> FINITE_VOLUME, WEIGHTING, BALANCE</i>
  */
  m_weightBndryCells = true;
  m_weightBndryCells = Context::getSolverProperty<MBool>("weightFvBndryCells", m_solverId, AT_, &m_weightBndryCells);

  /*! \page propertiesFV
    \section weightFvCutOffCells
    <code>MBool FvCartesianSolver::m_weightCutOffCells</code>\n
    default = <code>true</code>\n \n
    Enable weighting of cut off cells for balancing or when setting new grid partition workloads.\n
    Keywords: <i> FINITE_VOLUME, WEIGHTING, BALANCE</i>
  */
  m_weightCutOffCells = true;
  m_weightCutOffCells = Context::getSolverProperty<MBool>("weightFvCutOffCells", m_solverId, AT_, &m_weightCutOffCells);

  /*! \page propertiesFV
    \section weightFvBc1601
    <code>MBool FvCartesianSolver::m_weightBc1601</code>\n
    default = <code>true</code>\n \n
    Enable weighting of Bc1601 cells for balancing or when setting new grid partition workloads.\n
    Keywords: <i> FINITE_VOLUME, WEIGHTING, BALANCE</i>
  */
  m_weightBc1601 = true;
  m_weightBc1601 = Context::getSolverProperty<MBool>("weightFvBc1601", m_solverId, AT_, &m_weightBc1601);

  /*! \page propertiesFV
    \section weightInactiveCell
    <code>MBool FvCartesianSolver::m_weightInactiveCell</code>\n
    default = <code>true</code>\n \n
    Enable weighting of inactive fv-cells for balancing or when setting new grid partition workloads.\n
    Keywords: <i> FINITE_VOLUME, WEIGHTING, BALANCE</i>
  */
  m_weightInactiveCell = false;
  m_weightInactiveCell =
      Context::getSolverProperty<MBool>("weightFvInactiveCell", m_solverId, AT_, &m_weightInactiveCell);

  /*! \page propertiesFV
  \section weightLvlJumps
  <code>MBool FvCartesianSolver::m_weightLvlJumps</code>\n
  default = <code>false</code>\n \n
  Enable weighting of cells at a Level-Jump for balancing or when setting new grid
  partition workloads.\n Keywords: <i> FINITE_VOLUME, WEIGHTING, BALANCE</i>
  */
  m_weightLvlJumps = false;
  m_weightLvlJumps = Context::getSolverProperty<MBool>("weightFvLvlJumps", m_solverId, AT_, &m_weightLvlJumps);


  /*! \page propertiesFV
  \section weightNearBndryCells
  <code>MBool FvCartesianSolver::m_weightNearBndryCells</code>\n
  default = <code>false</code>\n \n
  Enable weighting of near bndry cells for balancing or when setting new grid
  partition workloads.\n Keywords: <i> FINITE_VOLUME, WEIGHTING, BALANCE</i>
  */
  m_weightNearBndryCells = false;
  m_weightNearBndryCells =
      Context::getSolverProperty<MBool>("weightFvNearBndryCells", m_solverId, AT_, &m_weightNearBndryCells);

  /*! \page propertiesFV
  \section weightSmallCells
  <code>MBool FvCartesianSolver::m_weightSmallCells</code>\n
  default = <code>false</code>\n \n
  Enable weighting of FV small cut cells at the bndry for balancing or when setting new grid
  partition workloads.\n Keywords: <i> FINITE_VOLUME, WEIGHTING, BALANCE</i>
  */
  m_weightSmallCells = false;
  m_weightSmallCells = Context::getSolverProperty<MBool>("weightFvSmallCells", m_solverId, AT_, &m_weightSmallCells);

  /*! \page propertiesFV
    \section limitWeights
    <code>MBool FvCartesianSolver::m_limitWeights</code>\n
    default = <code>false</code>\n \n
    Limit weight of fv-cells by a factor of the largest weight, due to ensure a more even distribution
    of solver memory across ranks.
    Keywords: <i> FINITE_VOLUME, WEIGHTING, BALANCE</i>
  */
  m_limitWeights = false;
  m_limitWeights = Context::getSolverProperty<MBool>("limitDLBWeights", solverId(), AT_, &m_limitWeights);
  /*! \page propertiesFV
    \section weightBaseCell
    <code>MFloat FvCartesianSolver::m_weightBaseCell</code>\n
    default = <code>0.0</code>\n \n
    Weight applied for any fv-cell during static weight computation for domain decomposition during
    balance.
    Keywords: <i> FINITE_VOLUME, WEIGHTING, BALANCE</i>
  */
  m_weightBaseCell = 1.0;
  m_weightBaseCell = Context::getSolverProperty<MFloat>("weightBaseCell", solverId(), AT_, &m_weightBaseCell);
  /*! \page propertiesFV
    \section weightLeafCell
    <code>MFloat FvCartesianSolver::m_weightLeafCell</code>\n
    default = <code>0.05</code>\n \n
    Weight applied for any fv leaf-cell during static weight computation for domain decomposition during
    balance.
    Keywords: <i> FINITE_VOLUME, WEIGHTING, BALANCE</i>
  */
  m_weightLeafCell = 1.0;
  m_weightLeafCell = Context::getSolverProperty<MFloat>("weightLeafCell", solverId(), AT_, &m_weightLeafCell);
  /*! \page propertiesFV
    \section weightActiveCell
    <code>MFloat FvCartesianSolver::m_weightActiveCell</code>\n
    default = <code>0.1</code>\n \n
    Weight applied for any active fv leaf-cell during static weight computation for domain decomposition during
    balance.
    Keywords: <i> FINITE_VOLUME, WEIGHTING, BALANCE</i>
  */
  m_weightActiveCell = 1.0;
  m_weightActiveCell = Context::getSolverProperty<MFloat>("weightAvticeCell", solverId(), AT_, &m_weightLeafCell);

  /*! \page propertiesFV
    \section weightBndryCell
    <code>MFloat FvCartesianSolver::m_weightBndryCell</code>\n
    default = <code>0.0</code>\n \n
    Weight applied for all bndry-cells during static weight computation for domain decomposition during
    balance.
    Keywords: <i> FINITE_VOLUME, WEIGHTING, BALANCE</i>
  */
  m_weightBndryCell = 0.0;
  m_weightBndryCell = Context::getSolverProperty<MFloat>("weightBndryCell", solverId(), AT_, &m_weightBndryCell);

  /*! \page propertiesFV
    \section weightNearBndryCell
    <code>MFloat FvCartesianSolver::m_weightNearBndryCell</code>\n
    default = <code>0.0</code>\n \n
    Weight applied for all near bndry-cells during static weight computation for domain decomposition during
    balance.
    Keywords: <i> FINITE_VOLUME, WEIGHTING, BALANCE</i>
  */
  m_weightNearBndryCell = 0.0;
  m_weightNearBndryCell =
      Context::getSolverProperty<MFloat>("weightNearBndryCell", solverId(), AT_, &m_weightNearBndryCell);


  /*! \page propertiesFV
    \section weightMulitSolverFactor
    <code>MFloat FvCartesianSolver::m_weightMulitSolverFactor</code>\n
    default = <code>1.0</code>\n \n
    Mutli-solver weight factor applied to all fv-cell weights for static weight computation for
    domain decomposition during balance. 1.0 for single solver application, otherwise setup
    dependent.
    Keywords: <i> FINITE_VOLUME, WEIGHTING, BALANCE</i>
  */
  m_weightMulitSolverFactor = 1.0;
  m_weightMulitSolverFactor =
      Context::getSolverProperty<MFloat>("weightMulitSolverFactor", solverId(), AT_, &m_weightMulitSolverFactor);

  // EEGas
  if(Context::propertyExists("EEGas", m_solverId)) {
    /*! \page propertiesFV
      \section RKSemiImplicitFactor
      <code>MFloat FvCartesianSolverXD::m_EEGas.RKSemiImplicitFactor </code>\n
      default = <code>0.5</code>\n \n
      This factor determines the weighting of the classical RK-scheme (0.0) and the semi-implicit scheme (1.0)
      for the E-E method.
      Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
    */
    m_EEGas.RKSemiImplicitFactor = 0.5;
    m_EEGas.RKSemiImplicitFactor =
        Context::getSolverProperty<MFloat>("RKSemiImplicitFactor", m_solverId, AT_, &m_EEGas.RKSemiImplicitFactor);
    if(m_isEEGas) {
      mAlloc(m_EEGas.uOtherPhase, maxNoGridCells(), nDim, "m_EEGas.uOtherPhase", F0, AT_);
      mAlloc(m_EEGas.uOtherPhaseOld, maxNoGridCells(), nDim, "m_EEGas.uOtherPhaseOld", F0, AT_);
      mAlloc(m_EEGas.gradUOtherPhase, maxNoGridCells(), nDim * nDim, "m_EEGas.gradUOtherPhase", F0, AT_);
      mAlloc(m_EEGas.vortOtherPhase, maxNoGridCells(), nDim, "m_EEGas.vortOtherPhase", F0, AT_);
      mAlloc(m_EEGas.nuTOtherPhase, maxNoGridCells(), "m_EEGas.nuTOtherPhase", F0, AT_);
      mAlloc(m_EEGas.nuEffOtherPhase, maxNoGridCells(), "m_EEGas.nuEffOtherPhase", F0, AT_);

      if(m_noSpecies != 1) {
        mTerm(1, AT_, "noSpecies has to be 1 for gas-liquid Euler-Euler simulations");
      }
      if(domainId() == 0) cerr << "FV Solver EEGas!" << endl;
    }
  }

  /*! \page propertiesFV
    \section EEGasDragModel
    <code>MFloat FvCartesianSolverXD::m_EEGas.dragModel </code>\n
    default = <code>0</code>\n \n
    Set the drag model for EEGas.\n
    possible values are:
    <ul>
    <li>0 : Tomiyama drag model</li>
    <li>1 : Stokes drag model (based on old velocities)</li>
    <li>2 : prescribed drag coefficient</li>
    <li>3 : Stokes drag model (implicit, not working properly!)</li>
    </ul>
    Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
  */
  m_EEGas.dragModel = 0;
  m_EEGas.dragModel = Context::getSolverProperty<MInt>("EEGasDragModel", m_solverId, AT_, &m_EEGas.dragModel);

  if(m_EEGas.dragModel == 2) {
    /*! \page propertiesFV
      \section EEGasCD
      <code>MFloat FvCartesianSolverXD::m_EEGas.CD </code>\n
      default = <code>1.0</code>\n \n
      Coefficient of drag.\n
      Only used in EEGasDragModel 2!
      Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
    */
    m_EEGas.CD = 1.0;
    m_EEGas.CD = Context::getSolverProperty<MFloat>("EEGasCD", m_solverId, AT_, &m_EEGas.CD);
  }

  /*! \page propertiesFV
    \section EEGasEo0
    <code>MFloat FvCartesianSolverXD::m_EEGas.Eo0 </code>\n
    default = <code>2.24</code>\n \n
    The Etvs (or Bond) number of the bubbles.\n
    Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
  */
  m_EEGas.Eo0 = 2.24;
  m_EEGas.Eo0 = Context::getSolverProperty<MFloat>("EEGasEo0", m_solverId, AT_, &m_EEGas.Eo0);

  /*! \page propertiesFV
    \section bubbleDiameter
    <code>MFloat FvCartesianSolverXD::m_EEGas.bubbleDiameter </code>\n
    default = <code>0.001</code>\n \n
    Bubble diameter in dimensionless units (/ physicalReferenceLength).\n
    Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
  */
  m_EEGas.bubbleDiameter = 0.001;
  m_EEGas.bubbleDiameter =
      Context::getSolverProperty<MFloat>("bubbleDiameter", m_solverId, AT_, &m_EEGas.bubbleDiameter);

  /*! \page propertiesFV
    \section EEGasLiquidDensity
    <code>MFloat FvCartesianSolverXD::m_EEGas.liquidDensity </code>\n
    default = <code>774</code>\n \n
    density of liquid in dimensionless units (/ rho_0).\n
    Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
  */
  m_EEGas.liquidDensity = 774;
  m_EEGas.liquidDensity =
      Context::getSolverProperty<MFloat>("EEGasLiquidDensity", m_solverId, AT_, &m_EEGas.liquidDensity);

  /*! \page propertiesFV
    \section EEGasEps
    <code>MFloat FvCartesianSolverXD::m_EEGas.eps </code>\n
    default = <code>1.0e-10</code>\n \n
    eps used as minimum rhoAlpha for calculation of primitive variables u, alpha, etc.\n
    Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
  */
  m_EEGas.eps = 1.0e-10;
  m_EEGas.eps = Context::getSolverProperty<MFloat>("EEGasEps", m_solverId, AT_, &m_EEGas.eps);

  /*! \page propertiesFV
    \section EEGasCL
    <code>MFloat FvCartesianSolverXD::m_EEGas.CL </code>\n
    default = <code>0.288</code>\n \n
    Lift coefficient used in the E-E method.\n
    Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
  */
  m_EEGas.CL = 0.288; // C_L = 0.288 used by Mohammadi19
  m_EEGas.CL = Context::getSolverProperty<MFloat>("EEGasCL", m_solverId, AT_, &m_EEGas.CL);

  /*! \page propertiesFV
    \section EEGasGasSource
    <code>MInt FvCartesianSolverXD::m_EEGas.gasSource </code>\n
    default = <code>0</code>\n \n
    Gas Source method used for the E-E method.\n
    <li>0 : no gas sources</li>
    <li>9 : gas sources in used defined boxes</li>
    Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
  */
  m_EEGas.gasSource = 0;
  m_EEGas.gasSource = Context::getSolverProperty<MInt>("EEGasGasSource", m_solverId, AT_, &m_EEGas.gasSource);

  /*! \page propertiesFV
    \section EEGasGasSourceMassFlow
    <code>MFloat FvCartesianSolverXD::m_EEGas.gasSourceMassFlow </code>\n
    default = <code>0.0</code>\n \n
    Mass flow of gass added in the gas sources.\n
    Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
  */
  m_EEGas.gasSourceMassFlow = 0.0;
  m_EEGas.gasSourceMassFlow =
      Context::getSolverProperty<MFloat>("EEGasGasSourceMassFlow", m_solverId, AT_, &m_EEGas.gasSourceMassFlow);

  if(m_EEGas.gasSource > 1 && m_EEGas.gasSourceMassFlow < 1.0e-16) {
    mTerm(1, AT_, "EEGasGasSourceMassFlow needed!");
  }

  if(m_EEGas.gasSource == 9) {
    const MInt l_noElements = Context::propertyLength("EEGasGasSourceBox");
    if(l_noElements % nDim * 2 != 0) {
      mTerm(1, AT_, "number of elements in EEGasGasSourceBox has to be a multiple of 2*nDim");
    }
    m_EEGas.noGasSourceBoxes = l_noElements / (nDim * 2);
    if(domainId() == 0) cerr << "number of gasSourceBoxes detected: " << m_EEGas.noGasSourceBoxes << endl;
    for(MInt i = 0; i < m_EEGas.noGasSourceBoxes * nDim * 2; i++) {
      /*! \page propertiesFV
        \section EEGasGasSourceBox
        <code>std::vector<MFloat> FvCartesianSolverXD::m_EEGas.gasSourceBox </code>\n
        Boxes in which gas is added.\n
        Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
      */
      m_EEGas.gasSourceBox.push_back(Context::getSolverProperty<MFloat>("EEGasGasSourceBox", m_solverId, AT_, i));
    }
  }

  /*! \page propertiesFV
    \section bubblePathDispersion
    <code>MBool FvCartesianSolverXD::m_EEGas.bubblePathDispersion </code>\n
    default = <code>true</code>\n \n
    Enable bubblePathDispersion\n
    Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
  */
  m_EEGas.bubblePathDispersion = true;
  m_EEGas.bubblePathDispersion =
      Context::getSolverProperty<MBool>("bubblePathDispersion", m_solverId, AT_, &m_EEGas.bubblePathDispersion);

  /*! \page propertiesFV
    \section initialAlpha
    <code>MFloat FvCartesianSolverXD::m_EEGas.initialAlpha </code>\n
    default = <code>0.0</code>\n \n
    Initial value of alpha in the domain.\n
    Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
  */
  m_EEGas.initialAlpha = 0.0;
  m_EEGas.initialAlpha = Context::getSolverProperty<MFloat>("initialAlpha", m_solverId, AT_, &m_EEGas.initialAlpha);

  /*! \page propertiesFV
    \section alphaInf
    <code>MFloat FvCartesianSolverXD::m_EEGas.alphaInf </code>\n
    default = <code>m_EEGas.initialAlpha</code>\n \n
    Infinity value of alpha.\n
    Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
  */
  m_EEGas.alphaInf = m_EEGas.initialAlpha;
  m_EEGas.alphaInf = Context::getSolverProperty<MFloat>("alphaInf", m_solverId, AT_, &m_EEGas.alphaInf);

  /*! \page propertiesFV
    \section alphaIn
    <code>MFloat FvCartesianSolverXD::m_EEGas.alphaIn </code>\n
    default = <code>m_EEGas.initialAlpha</code>\n \n
    Value of alpha at the inflow BC.\n
    Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
  */
  m_EEGas.alphaIn = m_EEGas.initialAlpha;
  m_EEGas.alphaIn = Context::getSolverProperty<MFloat>("alphaIn", m_solverId, AT_, &m_EEGas.alphaIn);

  /*! \page propertiesFV
    \section schmidtNumber
    <code>MFloat FvCartesianSolverXD::m_EEGas.schmidtNumber </code>\n
    default = <code>1.0</code>\n \n
    The Schmidt number of the bubbles.\n
    Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
  */
  m_EEGas.schmidtNumber = 1.0;
  m_EEGas.schmidtNumber = Context::getSolverProperty<MFloat>("schmidtNumber", m_solverId, AT_, &m_EEGas.schmidtNumber);

  /*! \page propertiesFV
    \section uDLimiter
    <code>MBool FvCartesianSolverXD::m_EEGas.uDLimiter </code>\n
    default = <code>true</code>\n \n
    Enable the limiter for u_d.\n
    Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
  */
  m_EEGas.uDLimiter = true;
  m_EEGas.uDLimiter = Context::getSolverProperty<MBool>("uDLimiter", m_solverId, AT_, &m_EEGas.uDLimiter);

  /*! \page propertiesFV
    \section uDLim
    <code>MFloat FvCartesianSolverXD::m_EEGas.uDLim </code>\n
    default = <code>0.2</code>\n \n
    Maximum u_d, if the uDLimiter is active.\n
    Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
  */
  m_EEGas.uDLim = 0.2;
  m_EEGas.uDLim = Context::getSolverProperty<MFloat>("uDLim", m_solverId, AT_, &m_EEGas.uDLim);

  /*! \page propertiesFV
    \section EEMultiphaseInterpolationFactor
    <code>MFloat FvCartesianSolverXD::m_EEGas.interpolationFactor </code>\n
    default = <code>0.5</code>\n \n
    This factor determines to which point in time the values of the other phase are inter/extrapolated.\n
    0.0 is the level of the old timestep, 1.0 is the level of the new timestep.
    Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
  */
  m_EEGas.interpolationFactor = 0.5;
  m_EEGas.interpolationFactor = Context::getSolverProperty<MFloat>("EEMultiphaseInterpolationFactor", m_solverId, AT_,
                                                                   &m_EEGas.interpolationFactor);

  /*! \page propertiesFV
    \section depthCorrection
    <code>MBool FvCartesianSolverXD::m_EEGas.depthCorrection </code>\n
    default = <code>true</code>\n \n
    Use the depthCorrection mechanism for the E-E method.\n
    This means, that the effects of buoyancy are not added to the bubbles through a pressure gradient.
    Instead a momentum source is applied.\n
    The density is corrected to reflect the pressure gradient.
    Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
  */
  m_EEGas.depthCorrection = m_isEEGas;
  m_EEGas.depthCorrection =
      Context::getSolverProperty<MBool>("depthCorrection", m_solverId, AT_, &m_EEGas.depthCorrection);

  if(m_EEGas.depthCorrection) {
    if(!Context::propertyExists("gravityRefCoords", m_solverId)
       || !Context::propertyExists("depthCorrectionCoefficients", m_solverId)) {
      mTerm(1, AT_, "gravityRefCoords and depthCorrectionCoefficients are required for depthCorrection!");
    }

    for(MInt i = 0; i < nDim; i++) {
      /*! \page propertiesFV
        \section gravityRefCoords
        <code>std::vector<MFloat> FvCartesianSolverXD::m_EEGas.gravityRefCoords </code>\n
        Reference Coordinates for density correction as a function of depth below the surface
        Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
      */
      m_EEGas.gravityRefCoords.push_back(Context::getSolverProperty<MFloat>("gravityRefCoords", m_solverId, AT_, i));
      /*! \page propertiesFV
        \section depthCorrectionCoefficients
        <code>std::vector<MFloat> FvCartesianSolverXD::m_EEGas.depthCorrectionCoefficients </code>\n
        The depthCorrectioncoefficients are dimensionless coefficients for the change in density as a function of depth
        They are defined as (g L_ref)/(R T) with the compontents of the gravity vector g,
        the specific gas constant R (=287.06 J/kgK for air) and
        the Reference Temperature
        Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
      */
      m_EEGas.depthCorrectionCoefficients.push_back(
          Context::getSolverProperty<MFloat>("depthCorrectionCoefficients", m_solverId, AT_, i));
    }
  }

  if(m_isEEGas && !Context::propertyExists("EEGasGravity", m_solverId)) {
    mTerm(1, AT_, "EEGasGravity required for EEGas!");
  } else if(m_isEEGas) {
    for(MInt i = 0; i < nDim; i++) {
      /*! \page propertiesFV
        \section EEGasGravity
        <code>std::vector<MFloat> FvCartesianSolverXD::m_EEGas.gravity </code>\n
        gravity Vector for calculation of the static pressure from the liquid phase
        Keywords: <i>EEMultiphase, FINITE_VOLUME</i>
      */
      m_EEGas.gravity.push_back(Context::getSolverProperty<MFloat>("EEGasGravity", m_solverId, AT_, i));
    }
  }
}

/*! \fn void FvCartesianSolverXD<nDim_,SysEqn>::setAndAllocateCombustionTFProperties()
 * \brief Reads and initializes properties associated with combustion simulations.
 * \todo labels:FV Stephan: clean up combustion stuff if possible!
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setAndAllocateCombustionTFProperties() {
  TRACE();
  // initially set all pointers to nullptr pointer
  m_molecularWeight = nullptr;
  m_FmolecularWeight = nullptr;
  m_molarFormationEnthalpy = nullptr;
  m_formationEnthalpy = nullptr;
  m_referenceComposition = nullptr;
  m_secondaryReferenceComposition = nullptr;


  if(m_combustion && m_thickenedFlame) {
    mAlloc(m_molecularWeight, m_noSpecies, "m_molecularWeight", F1, AT_);
    mAlloc(m_FmolecularWeight, m_noSpecies, "m_FmolecularWeight", F1, AT_);


    for(MInt s = 0; s < m_noSpecies; s++) {
      /*! \page propertiesFV
     \section molecularWeight
     <code>MFloat FvCartesianSolver::m_molecularWeight</code>\n
     default = <code>none</code>\n \n
     molecular weight of species
     possible values are:
     <ul>
     <li>Non-negative floating point values</li>
     </ul>
     Keywords: <i>FINITE_VOLUME, VARIABLES, SPECIES</i>
      */
      m_molecularWeight[s] =
          Context::getSolverProperty<MFloat>("molecularWeight", m_solverId, AT_, &m_molecularWeight[s], s);
      m_FmolecularWeight[s] = F1 / m_molecularWeight[s];
    }
    /*! \page propertiesFV
      \section referenceComposition
      <code>MFloat FvCartesianSolver::m_referenceComposition</code>\n
      default = <code>0</code>\n \n
      Reference species composition
      possible values are:
      <ul>
      <li>Non-negative floating point values</li>
      </ul>
      Keywords: <i>FINITE_VOLUME, VARIABLES, SPECIES</i>
    */
    /*! \page propertiesFV
      \section secondaryReferenceComposition
      <code>MFloat FvCartesianSolver::m_secondaryReferenceComposition</code>\n
      default = <code>0</code>\n \n
      Reference species composition
      possible values are:
      <ul>
      <li>Non-negative floating point values</li>
      </ul>
      Keywords: <i>FINITE_VOLUME, VARIABLES, SPECIES</i>
    */

    mAlloc(m_molarFormationEnthalpy, m_noSpecies, "m_molarFormationEnthalpy", F1, AT_);
    mAlloc(m_formationEnthalpy, m_noSpecies, "m_formationEnthalpy", F1, AT_);
    mAlloc(m_referenceComposition, m_noSpecies, "m_referenceComposition", F1, AT_);
    mAlloc(m_secondaryReferenceComposition, m_noSpecies, "m_secondaryReferenceComposition", F0, AT_);

    for(MInt s = 0; s < m_noSpecies; s++) {
      m_molarFormationEnthalpy[s] = Context::getSolverProperty<MFloat>("molarFormationEnthalpy", m_solverId, AT_,
                                                                       &m_molarFormationEnthalpy[s], s);
      m_referenceComposition[s] =
          Context::getSolverProperty<MFloat>("referenceComposition", m_solverId, AT_, &m_referenceComposition[s], s);
      m_secondaryReferenceComposition[s] = Context::getSolverProperty<MFloat>(
          "secondaryReferenceComposition", m_solverId, AT_, &m_secondaryReferenceComposition[s], s);
      m_formationEnthalpy[s] = m_molarFormationEnthalpy[s] / m_molecularWeight[s];
    }

    m_referenceDensityTF = 1.25;
    /*! \page propertiesFV
      \section referenceDensity
      <code>MFloat FvCartesianSolver::m_referenceDensityTF </code>\n
      default = <code>1.25</code>\n \n
      Reference density for thickened flame model
      possible values are:
      <ul>
      <li>Non-negative floating point values</li>
      </ul>
      Keywords: <i>FINITE_VOLUME, VARIABLES, TODO</i>
    */
    m_referenceDensityTF =
        Context::getSolverProperty<MFloat>("referenceDensity", m_solverId, AT_, &m_referenceDensityTF);

    /*! \page propertiesFV
      \section heatReleaseReductionFactor
      <code>MFloat FvCartesianSolver::m_heatReleaseReductionFactor</code>\n
      default = <code>1.0</code>\n\n
      The heat release is reduced by this factor (currently not in use)\n
      Possible values are:\n
      <ul>\n
      <li>floating-point values</li>\n
      </ul>\n
      Keywords: <i>FINITE_VOLUME, COMBUSTION</i>
      */
    m_heatReleaseReductionFactor = F1;
    m_heatReleaseReductionFactor = Context::getSolverProperty<MFloat>("heatReleaseReductionFactor", m_solverId, AT_,
                                                                      &m_heatReleaseReductionFactor);
    m_thickeningFactor = F1;
    /*! \page propertiesFV
      \section thickeningFactor
      <code>MFloat FvCartesianSolver::m_thickeningFactor </code>\n
      default = <code>1.0</code>\n \n
      Set the thickening factor of (probably ?) a flame. \n
      Value is currently not used ? \n
      possible values are:
      <ul>
      <li>Non-negative floating point values</li>
      </ul>
      Keywords: <i>FINITE_VOLUME, VARIABLES, FLAME</i>
    */
    m_thickeningFactor = Context::getSolverProperty<MFloat>("thickeningFactor", m_solverId, AT_, &m_thickeningFactor);
    /*! \page propertiesFV
      \section reactionScheme
      <code>MFloat FvCartesianSolver::reactionScheme </code>\n
      default = <code>METHANE_2_STEP</code>\n \n
      Set the reactionScheme \n
      possible values are:
      <ul>
      <li>METHANE_2_STEP</li>
      </ul>
      Keywords: <i>FINITE_VOLUME, VARIABLES, FLAME</i>
    */
    m_reactionScheme =
        "METHANE_2_STEP"; ///< only used in compute computeTFSourceTerms = thickened flame model -> AUSM_TF
    m_reactionScheme = Context::getSolverProperty<MString>("reactionScheme", m_solverId, AT_, &m_reactionScheme);
  }
}

/*! \fn void FvCartesianSolverXD<nDim_,SysEqn>::setAndAllocateSpongeLayerProperties()
 * \brief Reads and initializes properties associated with sponge boundary conditions.
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setAndAllocateSpongeLayerProperties() {
  TRACE();
  // initialize sponge variables
  m_spongeLayerThickness = F0;
  m_createSpongeBoundary = false;
  m_spongeLayerLayout = 0;
  m_spongeLayerType = 0;
  m_targetDensityFactor = F1;
  m_noSpongeFactors = 0;
  m_sigmaSponge = F0;
  m_sigmaSpongeInflow = F0;
  m_noSpongeBndryCndIds = 0;
  m_spongeTimeDep = false;
  m_noMaxSpongeBndryCells = 0;
  m_velocitySponge = 0;

  /*! \page propertiesFV
    \section spongeLayerThickness
    <code>MFloat FvCartesianSolver::m_spongeLayerThickness </code>\n
    default = <code>0.0</code>\n \n
    The property controls the thickness of the sponge layer in which the sponge layer forcing is applied. The sponge
    forcing term added to the rhs of a cell inside the sponge layer is given by \n \f$ \Delta L(\phi) = V \sigma
    \frac{\Delta x_{sp}^2}{L_s^2} \Delta \phi  \f$,  \n where \f$ V \f$ is the cell volume, \f$  \sigma  \f$ is the
    forcing amplitude, \f$  x_{sp} \f$ is the inner sponge layer boundary, \f$  L_{sp} \f$ is the sponge layer thickness
    and \f$  \Delta \phi = \phi - \phi_{target}  \f$ is the difference between the local and the freesteam values of \f$
    \phi  \f$.\n See also \ref spongeLayerLayout and \ref spongeFactor. \n \n possible values are: <ul> <li> Any
    non-negative floating point value. </li>
    </ul>
    Keywords: <i> FINITE_VOLUME, SPONGE </i>
  */
  m_spongeLayerThickness =
      Context::getSolverProperty<MFloat>("spongeLayerThickness", m_solverId, AT_, &m_spongeLayerThickness);

  /*! \page propertiesFV
  \section spongeLayerThickness_int
  <code>MFloat FvCartesianSolver::m_spongeLayerThickness </code>\n
  default = <code>0.0</code>\n \n
  The property controls the thickness of the sponge layer in which the sponge layer forcing is applied. See \ref
  spongeLayerThickness. The thickness is given as a multiple of the cell length of the maximum geometrical refinement
  level \n \n possible values are: <ul> <li> Any non-negative integer value. </li>
  </ul>
  Keywords: <i> FINITE_VOLUME, SPONGE </i>
  */
  if(Context::propertyExists("spongeLayerThickness_int", m_solverId)) {
    MFloat cellLength = c_cellLengthAtLevel(maxUniformRefinementLevel());
    m_spongeLayerThickness =
        (MFloat)Context::getSolverProperty<MInt>("spongeLayerThickness_int", m_solverId, AT_) * cellLength;

    cerr << " m_spongeLayerThickness is: " << m_spongeLayerThickness << endl;
  }

  // check if sponge variables should be read
  if(m_spongeLayerThickness > 0) {
    /*! \page propertiesFV
      \section createSpongeBoundary
      <code>MBool FvCartesianSolver::m_createSpongeBoundary </code>\n
      default = <code>0</code>\n \n
      The property controls the use of sponge zones for specific boundaries, defined by the boundary Ids in your
      geometry file geometry.cdl, \ref spongeBndryCndIds. If the property is set to zero the sponge zones are defined at
      the domain boundaries, see readSpongeDomainBoundaries(). \n \n possible values are: <ul> <li> 0 - off </li> <li> 1
      - on </li>
      </ul>
      Keywords: <i> FINITE_VOLUME, SPONGE, SPECIFIC, BOUNDARIES, BOUNDARY, ID </i>
    */
    m_createSpongeBoundary =
        Context::getSolverProperty<MBool>("createSpongeBoundary", m_solverId, AT_, &m_createSpongeBoundary);

    if(m_createSpongeBoundary) {
      // read in sponge variables for specific cartesian boundaries (only 2D implemented) and add the additional memory
      setAndAllocateSpongeBoundaryProperties();
    } else {
      // read in sponge variables for the domain boundaries  and add the additional memory
      setAndAllocateSpongeDomainProperties(F0);
    }
  }

  mDeallocate(m_cellsInsideSpongeLayer);
  // Allocate sponge cell array - must be allocated even if no sponge layer is applied! Size of array is different
  m_noCellsInsideSpongeLayer = 0;
  if(!m_createSpongeBoundary) {
    mAlloc(m_cellsInsideSpongeLayer, maxNoGridCells(), "m_cellsInsideSpongeLayer", -1, AT_);
  } else {
    mAlloc(m_cellsInsideSpongeLayer, m_noMaxSpongeBndryCells, "m_cellsInsideSpongeLayer", -1, AT_);
  }
}

/*! \fn void FvCartesianSolverXD<nDim_,SysEqn>::setNumericalProperties()
 * \brief Reads and initializes properties associated with the numerical method.
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setNumericalProperties() {
  TRACE();
  // initialization of limited vars
  m_noLimitedSlopesVar = 0;
  m_limitedSlopesVar = nullptr;

  /*! \page propertiesFV
      \section cfl
      <code>MFloat FvCartesianSolver::m_cfl </code>\n
      default = <code>no default</code>\n \n
      Courant number C - Factor of the CFL condition \n \n
      possible values are:
      <ul>
      <li> positive floating point values < stability limit of the time-stepping method </li>
      <li> For default RK5 scheme the theoretical stability limit is C<4. Due to cut and small cells C<1.5 or even C
     <= 1.0 is recommended. </li>
      </ul>
      Keywords: <i> FINITE_VOLUME, STABILITY, TIME_INTEGRATION </i>
    */
  m_cfl = Context::getSolverProperty<MFloat>("cfl", m_solverId, AT_);

  /*! \page propertiesFV
    \section cflViscous
    <code>MFloat FvCartesianSolver::m_cflViscous </code>\n
    default = <code>1/4</code>\n \n
    Quasi-Courant number C_vis - Factor of the viscous "CFL condition" \n \n
    The time-step restriction for the stability of an explicity Euler-forward step for the
    diffusion equation is $\Delta t <= C_{vis} \frac{\Delta x^2}{\nu}$ where $C_{vis} \in (0, 1/4].
    For the Enthalpy solver $\nu$ is the diffusion coefficient, that is, the thermal diffusivity. For
    compressible-flow at constant Prandtl' number $\nu$ is the specific viscosity.
    Note that the unsteady diffusion equation is a parabolic problem, and although explicit schemes can
    be used to solve it stably, the restriction on the time-step increases with the square of the mesh
    size, so refining the grid makes the number of time-steps required to solve the problem explode.
    Keywords: <i> FINITE_VOLUME, STABILITY, TIME_INTEGRATION </i>
  */
  m_cflViscous = F1B4;
  m_cflViscous = Context::getSolverProperty<MFloat>("cflViscous", m_solverId, AT_, &m_cflViscous);

  /*! \page propertiesFV
    \section orderOfReconstruction
    <code>MFloat FvCartesianSolver::m_orderOfReconstruction </code>\n
    default = <code>1</code>\n \n
    Sets the order of the reconstruction  \n \n
    possible values are:
    <ul>
    <li> 1 or higher </li>
    </ul>
    Keywords: <i> FINITE_VOLUME, STABILITY, HIGHER_ORDER </i>
  */
  m_orderOfReconstruction = 1;
  m_orderOfReconstruction =
      Context::getSolverProperty<MInt>("orderOfReconstruction", m_solverId, AT_, &m_orderOfReconstruction);

  m_RKalpha = nullptr;
  m_RKStep = 0;

  m_limiter = 0;
  /*! \page propertiesFV
      \section limiter
      <code>MInt FvCartesianSolver::m_limiter </code>\n
      default = <code>0</code>\n \n
      Does nothing \n \n
      possible values are:
      <ul>
      <li> 0 </li>
      </ul>
      Keywords: <i> FINITE_VOLUME, STABILITY, LIMITER </i>
    */
  m_limiter = Context::getSolverProperty<MInt>("limiter", m_solverId, AT_, &m_limiter);

  m_surfaceValueReconstruction = "HOCD";
  /*! \page propertiesFV
      \section surfaceValueReconstruction
      <code>MInt FvCartesianSolver::m_surfaceValueReconstruction </code>\n
      default = <code>HOCD</code>\n \n
      Selects the reconstruction method. \n \n
      possible values are:
      <ul>
      <li> HOCD: unlimited high-order surface data reconstruction. </li>
      <li> HOCD_LIMITED: limited high-order surface data reconstruction. </li>
      <li> LOCD: unlimited low-order (pressure)/high-order surface data reconstruction. </li>
      </ul>
      Keywords: <i> FINITE_VOLUME, STABILITY, LIMITER </i>
    */
  m_surfaceValueReconstruction =
      Context::getSolverProperty<MString>("surfaceValueReconstruction", m_solverId, AT_, &m_surfaceValueReconstruction);

  if(string2enum(m_surfaceValueReconstruction) == HOCD_LIMITED_SLOPES
     || string2enum(m_surfaceValueReconstruction) == HOCD_LIMITED_SLOPES_MAN) {
    m_noLimitedSlopesVar = 0;
    MInt tmp = Context::propertyLength("limitedSlopesVar", m_solverId);
    if(tmp != 3) {
      mTerm(1, AT_, "no limited variables is wrong");
    }

    mAlloc(m_limitedSlopesVar, PV->noVariables - m_noSpecies, "m_limitedSlopesVar", -1, AT_);
    MInt* tmpRead = (MInt*)nullptr;
    mAlloc(tmpRead, tmp, "tmpRead", -1, AT_);

    for(MInt i = 0; i < tmp; i++) {
      /*! \page propertiesFV
  \section limitedSlopesVar
  <code>MInt FvCartesianSolver::m_limitedSlopesVar </code>\n
  default = <code> -1 </code>\n
  possible values for each entry are:
  <ul>
  <li> 0 or 1 -> limited slopes for velocities is off/on </li>
  <li> 0 or 1 -> limited slopes for density is off/on </li>
  <li> 0 or 1 -> limited slopes for pressure is off/on </li>
  </ul>
  Keywords: <i>FINITE_VOLUME, LIMITED, SLOPES, VARIABLES</i>
      */
      tmpRead[i] = Context::getSolverProperty<MInt>("limitedSlopesVar", m_solverId, AT_, &tmpRead[i], i);
      if(tmpRead[i] < 0 || tmpRead[i] > 1) {
        mTerm(1, AT_, "ERROR: limitedSlopesVar should be 0 or 1");
      }
    }

    // setting limited slopes for the velocities
    for(MInt d = 0; d < nDim; d++) {
      if(tmpRead[0] > 0) {
        m_limitedSlopesVar[d] = PV->VV[d];
        m_noLimitedSlopesVar++;
        m_log << "setting variable " << d << " as limited variable" << endl;
      } else {
        break;
      }
    }

    // setting limited slopes for the density or pressure
    for(MInt d = nDim; d < (PV->noVariables - m_noSpecies); d++) {
      if(tmpRead[d - nDim + 1] != 0) {
        m_limitedSlopesVar[m_noLimitedSlopesVar] = d;
        m_noLimitedSlopesVar++;
        m_log << "setting variable " << d << " as limited variable" << endl;
      }
    }
    m_log << m_noLimitedSlopesVar << " number of limited variables" << endl;
    for(MInt d = 0; d < m_noLimitedSlopesVar; d++) {
      m_log << "limited variable is: " << m_limitedSlopesVar[d] << endl;
    }
  }

  /*! \page propertiesFV
    \section viscousFluxScheme
    <code>MString FvCartesianSolver::m_viscousFluxScheme </code>\n
    default = <code>FIVE_POINT</code>\n
    Scheme for the calculation of the viscous flux\n
    Possible values are:
    <ul>
      <li>THREE_POINT </li>
      <li>FIVE_POINT </li>
      <li>FIVE_POINT_STABILIZED </li>
    </ul>
    Keywords: <i>FINITE VOLUME, NUMERICS, FLUX</i>
  */
  m_viscousFluxScheme = "FIVE_POINT";
  m_viscousFluxScheme = Context::getSolverProperty<MString>("viscousFluxScheme", m_solverId, AT_, &m_viscousFluxScheme);
  m_log << endl << "viscous-flux scheme: " << m_viscousFluxScheme << endl << endl;

  /*! \page propertiesFV
    \section viscousFluxScheme
    <code>MFloat FvCartesianSolver::m_enhanceThreePointViscFluxFactor </code>\n
    default = <code>0.1</code>\n
    FIVE_POINT_STABILIZED combines the THREE_POINT stencil and the FIVE_POINT stencil for the viscous flux computation\n
    This property provides further control and the final stencil of the viscous flux is
    (1-enhanceThreePointViscFluxFactor)*FIVE_POINT + * enhanceThreePointViscFluxFactor*THREE_POINT
    \n
    Possible values are:
    <ul>
      Floats between 0 and 1
    </ul>
    Keywords: <i>FINITE VOLUME, NUMERICS, FLUX</i>
  */
  if(string2enum(m_viscousFluxScheme) == FIVE_POINT_STABILIZED
     && Context::propertyExists("enhanceThreePointViscFluxFactor", m_solverId)) {
    m_enhanceThreePointViscFluxFactor = Context::getSolverProperty<MFloat>(
        "enhanceThreePointViscFluxFactor", m_solverId, AT_, &m_enhanceThreePointViscFluxFactor);
  } else {
    m_enhanceThreePointViscFluxFactor = 0.1;
  }


  m_advectiveFluxScheme = "AUSM";
  if(Context::propertyExists("advectiveFluxScheme", m_solverId)) {
    m_advectiveFluxScheme =
        Context::getSolverProperty<MString>("advectiveFluxScheme", m_solverId, AT_, &m_advectiveFluxScheme);
  }


  /*! \page propertiesFV
    \section gridInterfaceFilter
    <code>MString FvCartesianSolver::m_gridInterfaceFilter </code>\n
    default = <code>False</code>\n
    Switches on/off a filter of the conservative variables at \n
    coarse/fine grid interfaces. \n

    Possible values are:
    <ul>
      <li>True/False </li>
    </ul>
    Keywords: <i>FINITE VOLUME, NUMERICS, INTERFACE, FILTER</i>
  */
  m_gridInterfaceFilter = false;
  m_gridInterfaceFilter =
      Context::getSolverProperty<MBool>("gridInterfaceFilter", m_solverId, AT_, &m_gridInterfaceFilter);

  /*! \page propertiesFV
  \section force1D
  <code>MBool FvCartesianSolver::m_force1DFiltering </code>\n
  default = <code>False</code>\n
  Sets x-velocity to 0.\n
  Possible values are:
  <ul>
    <li>0 Deactivated </li>
    <li>1 Activated</li>
  </ul>
  Keywords: <i>FINITE VOLUME</i>
*/
  m_force1DFiltering = false;
  m_force1DFiltering = Context::getSolverProperty<MBool>("force1D", m_solverId, AT_, &m_force1DFiltering);


  /*! \page propertiesFV
    \section physicalTimeStep
    <code>MFloat FvCartesianSolver::m_physicalTimeStep </code>\n
    default = <code>no default value</code>\n \n
    The property is the "external" time increment used for dualtimestepping, usually reads from restart file.
    m_physicalTimeStep=m_timeStep*m_timeRef. possible values are: <ul> <li> Any non-negative float value</li>
    </ul>
    Keywords: <i> Timestep  </i>
  */
  if(m_dualTimeStepping) {
    m_physicalTimeStep = Context::getSolverProperty<MFloat>("physicalTimeStep", m_solverId, AT_);
  }

  m_maxNoTimeSteps = Context::getSolverProperty<MInt>("timeSteps", m_solverId, AT_);

  /*! \page propertiesFV
    \section timeStepMethod
    <code>MInt FvCartesianSolver::m_timeStepMethod </code>\n
    default = <code> -1 </code>\n
    Specifies the time step method
    <ul>
    <li> 1  -> computes the time step based on the CFL condition of the Euler equations</li>
    <li> 6 -> time step method based on the cell length of the GCells</li>
    <li> 17511 -> use flame based time steps but write the time step of case 1 in the solution files</li>
    <li> 100 -> Same as 1, but uses the infinity values and fulfills additionally the viscous cfl number</li>
    </ul>
    Keywords: <i>FINITE_VOLUME</i>
  */
  m_timeStepMethod = Context::getSolverProperty<MInt>("timeStepMethod", m_solverId, AT_);

  /*! \page propertiesFV
     \section timeStepNonBlocking
     <code>MInt FvCartesianSolver::m_timeStepNonBlocking </code>\n
     default = <code> 0 </code>\n
     If activated, the timeStep is reduced using non-blocking communication
     <ul>
     <li> 0: disable </li>
     <li> 1: enable </li>
     </ul>
     Keywords: <i>FINITE_VOLUME, TIME</i>
   */
  m_timeStepNonBlocking = false;
  m_timeStepNonBlocking =
      Context::getSolverProperty<MBool>("timeStepNonBlocking", m_solverId, AT_, &m_timeStepNonBlocking);

  // Initialize timeStepComputationInterval
  // When restarting the default is to read the time-step from the restart file. Otherwise,
  // the time-step is computed only once, at the beginning.
  m_timeStepComputationInterval = m_restart ? -1 : 0;

  /*! \page propertiesFV
    \section timeStepVar
    <code>MInt FvCartesianSolver::m_timeStepComputationInterval </code>\n
    default = <code> -1 </code>\n
    Specifies on which interval the time-step will be recomputed.
    <ul>
    <li> -1 -> default (when restart): never - read from restart file, requires m_restart == true. </li>
    <li> 0  -> default (when no restart): once at the beginning </li>
    <li> 1  -> every time-step </li>
    <li> 2  -> every two time-steps </li>
    <li> N  -> every Ntime-steps </li>
    </ul>
    Keywords: <i>FINITE_VOLUME</i>
  */
  m_timeStepComputationInterval =
      Context::getSolverProperty<MInt>("timeStepComputationInterval", m_solverId, AT_, &m_timeStepComputationInterval);


  m_log << "TimeStepComputationInterval: ";
  switch(m_timeStepComputationInterval) {
    case 0: {
      m_log << "0 (default)";
      break;
    }
    case -1: {
      m_log << "-1 (never, using time step from restart file)";
      break;
    }
    default: {
      if(m_timeStepComputationInterval < 0) {
        mTerm(1, AT_, "timeStepComputationInterval out-of-range [-1, infinity)");
      }
      m_log << m_timeStepComputationInterval << " (recompute dt every " << m_timeStepComputationInterval
            << " time steps)";
      break;
    }
  }
  m_log << endl;

  if(Context::propertyExists("usePreviousTimeStep", m_solverId)) {
    mTerm(-1, "ERROR: usePreviousTimeStep has been removed. Set timeStepComputationInterval instead. If you were using "
              "usePreviousTimeStep = 0 you have to set timeStepComputationInterval = 0. If you were using "
              "usePreviousTimeStep = 1 you can either set timeStepComputationInterval = -1, or remove the property "
              "completely because -1 is the default value of timeStepComputationInterval when restarting. Check the "
              "aiawiki for more information.");
  }


  m_timeStepVolumeWeighted = false;
  /*! \page propertiesFV
    \section timeStepVolumeWeighted
    <code>MInt FvCartesianSolver::m_timeStepVolumeWeighted </code>\n
    default = <code> 0 (false) </code>\n
    When enabled includes the boundary cells in the time-step computation
    and weights it using the cell volume (the smaller the cell, the smaller the time-step).
    Keywords: <i>FINITE_VOLUME</i>
  */
  m_timeStepVolumeWeighted =
      Context::getSolverProperty<MBool>("timeStepVolumeWeighted", m_solverId, AT_, &m_timeStepVolumeWeighted);

  m_timeStepFixedValue = -1.0;
  m_timeStepFixedValue = Context::getSolverProperty<MFloat>("fixedTimeStep", m_solverId, AT_, &m_timeStepFixedValue);

  m_log << "Time step computation settings: volumeWeighted = " << m_timeStepVolumeWeighted
        << "; fixedTimeStepValue = " << m_timeStepFixedValue << std::endl;

  /*! \page propertiesFV
    \section globalUpwindCoefficient
    <code>MInt FvCartesianSolver::m_globalUpwindCoefficient </code>\n
    default = <code> 0 </code>\n
    Set the upwind coefficient for the pressure splitting\n
    <ul>
    <li> positive floating point values smaller 1.0 </li>
    </ul>
    Keywords: <i> FINITE_VOLUME, NUMERICS, AUSM</i>

  */
  m_globalUpwindCoefficient = F0;
  m_globalUpwindCoefficient =
      Context::getSolverProperty<MFloat>("globalUpwindCoefficient", m_solverId, AT_, &m_globalUpwindCoefficient);
  m_chi = Context::getSolverProperty<MFloat>("upwindCoefficient", m_solverId, AT_);

  m_upwindMethod = 0;
  m_upwindMethod = Context::getSolverProperty<MInt>("upwindMethod", m_solverId, AT_, &m_upwindMethod);
  m_2ndOrderWeights = false;
  m_2ndOrderWeights = Context::getSolverProperty<MBool>("weights2ndOrder", m_solverId, AT_, &m_2ndOrderWeights);
  m_reExcludeBndryDiagonals = false;
  m_reExcludeBndryDiagonals =
      Context::getSolverProperty<MBool>("reExcludeBndryDiagonals", m_solverId, AT_, &m_reExcludeBndryDiagonals);

  /*! \page propertiesFV
      \section surfaceValueReconstruction
      <code>MInt MAIAFvCartesianSolver::m_reConstSVDWeightMode </code>\n
      default = <code>0/1</code>\n \n
      Selects the weight mode for the weights in the reconstruction Constant
      computation in SVD for cells near the moving bndry! \n \n
      possible values are:
      <ul>
      <li> 0: only use distance weights </li>
      <li> 1: only use distance weights and set weight = 0 for diagonal neighbors  </li>
      <li> 2: use distance and cellFraction weights for all neighbors </li>
      <li> 3: no distance weights & special treatment at rfn-interfaces </li>
      <li> 4: no distance weights & special treatment at rfn-interfaces (recommended) </li>
      </ul>
      Keywords: <i> FINITE_VOLUME, SVD, reconstructionConstants </i>
    */
  m_reConstSVDWeightMode = 0;
  m_reConstSVDWeightMode =
      Context::getSolverProperty<MInt>("reConstSVDWeightMode", m_solverId, AT_, &m_reConstSVDWeightMode);
  m_relocateCenter = false;
  m_relocateCenter = Context::getSolverProperty<MBool>("relocateCenter", m_solverId, AT_, &m_relocateCenter);

  if(m_bndryLevelJumps) {
    ASSERT(m_reConstSVDWeightMode != 1, "Mode not working for bndry-level-jumps!");
  }

  /*! \page propertiesFV
      \section convergenceCriterion
      <code>MInt FvCartesianSolver::m_convergenceCriterion </code>\n
      default = <code>1e-12</code>\n \n
      Sets the convergence criterion for the residuals of the time step loop.
      <ul>
      <li> positive floating point values </li>
      </ul>
      Keywords: <i> FINITE_VOLUME, NUMERICS</i>
    */
  // Residual properties - chosen as in 3D sphere Testcase:
  m_convergenceCriterion = 1e-12;
  m_convergenceCriterion =
      Context::getSolverProperty<MFloat>("convergenceCriterion", m_solverId, AT_, &m_convergenceCriterion);

  m_timeStepConvergenceCriterion = 1e-6;
  m_timeStepConvergenceCriterion = Context::getSolverProperty<MFloat>("timeStepConvergenceCriterion", m_solverId, AT_,
                                                                      &m_timeStepConvergenceCriterion);

  m_useCentralDifferencingSlopes = false;
  m_useCentralDifferencingSlopes = Context::getSolverProperty<MBool>("useCentralDifferencingSlopes", m_solverId, AT_,
                                                                     &m_useCentralDifferencingSlopes);

  m_spongeTimeVelocity = 0;
  m_spongeTimeVelocity = Context::getSolverProperty<MInt>("spongeTimeVelocity", m_solverId, AT_, &m_spongeTimeVelocity);
}

/*! \fn void FvCartesianSolverXD<nDim_,SysEqn>::setInputOutputProperties()
 * \brief Reads properties and initializes variables associated with input/output.
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setInputOutputProperties() {
  TRACE();
  MBool tmpFalse = false;
  MBool tmpTrue = true;

  /*! \page propertiesFV
    \section solutionOffset
    <code>MInt solver::m_solutionOffset</code>\n
    default = <code>0</code>\n \n
    which time step to start writing out solution
    Possible values are:
    <ul>
      <li> Int </li>
    </ul>
    Keywords: <i>output</i>
  */
  m_solutionOffset = 0;
  m_solutionOffset = Context::getSolverProperty<MInt>("solutionOffset", m_solverId, AT_, &m_solutionOffset);

  /*! \page propertiesFV
    \section outputPhysicalTime
    <code>MInt solver::m_outputPhysicalTime</code>\n
    default = <code>false</code>\n \n
    Write m_physicalTime in all time-outputs instead of m_time
    Keywords: <i>output</i>
  */
  m_outputPhysicalTime = false;
  m_outputPhysicalTime =
      Context::getSolverProperty<MBool>("outputPhysicalTime", m_solverId, AT_, &m_outputPhysicalTime);

  /*! \page propertiesFV
    \section solutionTimeSteps
    <code>MInt solver::noSolutionTimeSteps</code>\n
    default = <code></code>\n \n
    Sets the solution time step
    Possible values are:
    <ul>
      <li> Int </li>
    </ul>
    Keywords: <i>output</i>
  */
  if(Context::propertyExists("solutionTimeSteps", m_solverId)) {
    MInt noSolutionTimeSteps = Context::propertyLength("solutionTimeSteps", m_solverId);
    for(MInt i = 0; i < noSolutionTimeSteps; i++) {
      MInt sts = Context::getSolverProperty<MInt>("solutionTimeSteps", m_solverId, AT_, i);
      m_solutionTimeSteps.insert(sts);
      cerr << " inserted time step " << sts << " to solution time steps! " << endl;
    }
  }

  m_integratedHeatReleaseOutput = false;
  m_integratedHeatReleaseOutput =
      Context::getSolverProperty<MBool>("integratedHeatReleaseOutput", m_solverId, AT_, &m_integratedHeatReleaseOutput);

  m_integratedHeatReleaseOutputInterval = 0;
  m_integratedHeatReleaseOutputInterval = Context::getSolverProperty<MInt>(
      "integratedHeatReleaseOutputInterval", m_solverId, AT_, &m_integratedHeatReleaseOutputInterval);

  m_dragOutputInterval = 0;
  m_dragOutputInterval = Context::getSolverProperty<MInt>("dragOutputInterval", m_solverId, AT_, &m_dragOutputInterval);

  /*! \page propertiesFV
      \section surfaceDistributionParallel
      <code>MBool FvCartesianSolver::m_surfDistParallel </code>\n
      default = <code>false</code>\n \n
      write out the distribution of the force coefficients into one file during a parallel run in
     computeForceCoefficients() (unsorted)  \n \n possible values are: <ul> <li> 1 (true) </li> <li> 0( false) </li>
      </ul>
      Keywords: <i> FINITE_VOLUME, OUTPUT </i>
    */
  m_surfDistParallel = Context::getSolverProperty<MBool>("surfaceDistributionParallel", m_solverId, AT_, &tmpFalse);

  /*! \page propertiesFV
      \section surfaceDistributionCartesian
      <code>MBool FvCartesianSolver::m_surfDistCartesian </code>\n
      default = <code>false</code>\n \n
      write out the distribution of the force coefficients in Cartesian coordinates (instead of angle)
      <ul>
      <li> 1 (true) </li>
      <li> 0( false) </li>
      </ul>
      Keywords: <i> FINITE_VOLUME, OUTPUT </i>
    */
  m_surfDistCartesian = Context::getSolverProperty<MBool>("surfaceDistributionCartesian", m_solverId, AT_, &tmpFalse);

  /*! \page propertiesFV
      \section saveVorticityToRestart
      <code>MBool FvCartesianSolver::m_saveVorticityToRestart </code>\n
      default = <code>false</code>\n \n
      Save vorticity to restart file.  \n \n
      possible values are:
      <ul>
      <li> 1 (true) </li>
      <li> 0( false, default value) </li>
      </ul>
      Keywords: <i> FINITE_VOLUME, OUTPUT </i>
    */
  m_saveVorticityToRestart = false;
  m_saveVorticityToRestart =
      Context::getSolverProperty<MBool>("saveVorticityToRestart", m_solverId, AT_, &m_saveVorticityToRestart);

  m_vorticityOutput = Context::getSolverProperty<MBool>("vorticityOutput", m_solverId, AT_, &tmpTrue);

  /*! \page propertiesFV
   \section qCriterionOutput
   <code> MBool FvCartesianSolverPar::m_qCriterionOutput </code>  \n
   default = <code>""</code>\n \n
   Triggers whether the q-criterium is calculated and written to all output files.
   <ul>
   <li>0 or 1 (false or true)</li>
   </ul>
   Keywords: <i>FINITE_VOLUME, OUTPUT, GENERAL</i>
  */

  m_qCriterionOutput = Context::getSolverProperty<MBool>("qCriterionOutput", m_solverId, AT_, &tmpTrue);

  /*! \page propertiesFV
    \section vtuWritePointData
    <code> MBool FvCartesianSolverPar::m_vtuWritePointData </code>  \n
    default = <code>false</code>\n \n
    Triggers whether the vtu point data is written \n
    <ul>
    <li>0 or 1 (false or true)</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, OUTPUT, GENERAL</i>
  */
  m_vtuWritePointData = false;
  m_vtuWritePointData = Context::getSolverProperty<MBool>("vtuWritePointData", m_solverId, AT_, &m_vtuWritePointData);
  m_log << "m_vtuWritePointData: " << m_vtuWritePointData << endl;
  /*! \page propertiesFV
      \section vtuCutCellOutput
      <code>MBool FvCartesianSolver::m_vtuCutCellOutput </code>\n
      default = <code>false</code>\n \n
      Contorols the output in vtu file format. If activated (=1), the cut faces are included in the output.\n \n
      possible values are:
      <ul>
      <li> 1 (true, default for three dimensions) </li>
      <li> 0( false) </li>
      </ul>
      Keywords: <i> FINITE_VOLUME, OUTPUT </i>
    */
  m_vtuCutCellOutput = (nDim == 3);
  IF_CONSTEXPR(nDim == 3)
  m_vtuCutCellOutput = Context::getSolverProperty<MBool>("vtuCutCellOutput", m_solverId, AT_, &m_vtuCutCellOutput);
  m_vtuGeometryOutput.clear();
  IF_CONSTEXPR(nDim == 3) {
    if(Context::propertyExists("vtuGeometryOutput", m_solverId)) {
      m_log << "VTU geometry output for boundaryIds: ";
      /*! \page propertiesFV
        \section vtuGeometryOutput
        <code>MBool FvCartesianSolver::m_vtuGeometryOutput </code>\n
        default = <code>false</code>\n \n
        Enables/disables writing geometry output to VTU files.
        Keywords: <i> FINITE_VOLUME, IO, VTU </i>
      */
      MInt cnt = Context::propertyLength("vtuGeometryOutput", m_solverId);
      for(MInt i = 0; i < cnt; i++) {
        MInt bcId = Context::getSolverProperty<MInt>("vtuGeometryOutput", m_solverId, AT_, i);
        m_vtuGeometryOutput.insert(bcId);
        m_log << bcId << " ";
      }
      m_log << endl;
    }
  }

  /*! \page propertiesFV
    \section vtuGeometryOutputExtended
    <code>MBool FvCartesianSolver::m_vtuGeometryOutputExtended </code>\n
    default = <code>false</code>\n \n
    Enables/disables writing extended geometry output to VTU files.
    Keywords: <i> FINITE_VOLUME, IO, VTU </i>
  */
  m_vtuGeometryOutputExtended = false;
  m_vtuGeometryOutputExtended =
      Context::getSolverProperty<MBool>("vtuGeometryOutputExtended", m_solverId, AT_, &m_vtuGeometryOutputExtended);
  m_vtuWriteGeometryFile = true;
  m_vtuWriteGeometryFile =
      Context::getSolverProperty<MBool>("vtuGeometryFile", m_solverId, AT_, &m_vtuWriteGeometryFile);

  m_vtuWriteParticleFile = true;
  m_vtuWriteParticleFile =
      Context::getSolverProperty<MBool>("vtuParticleFile", m_solverId, AT_, &m_vtuWriteParticleFile);

  /*! \page propertiesFV
    \section vtuGlobalIdOutput
    <code>MBool FvCartesianSolver::m_vtuGlobalIdOutput </code>\n
    default = <code>false</code>\n \n
    Enables/disables writing global cell Ids to VTU files.
    Keywords: <i> FINITE_VOLUME, IO, VTU </i>
  */
  m_vtuGlobalIdOutput = false;
  m_vtuGlobalIdOutput = Context::getSolverProperty<MBool>("vtuGlobalIdOutput", m_solverId, AT_, &m_vtuGlobalIdOutput);

  /*! \page propertiesFV
    \section vtuDomainIdOutput
    <code>MBool FvCartesianSolver::m_vtuDomainIdOutput </code>\n
    default = <code>false</code>\n \n
    Enables/disables writing the domain Id of the cells to VTU files.
    Keywords: <i> FINITE_VOLUME, IO, VTU </i>
  */
  m_vtuDomainIdOutput = false;
  m_vtuDomainIdOutput = Context::getSolverProperty<MBool>("vtuDomainIdOutput", m_solverId, AT_, &m_vtuDomainIdOutput);

  /*! \page propertiesFV
    \section vtuDensityOutput
    <code>MBool FvCartesianSolver::m_vtuDensityOutput </code>\n
    default = <code>false</code>\n \n
    Enables/disables writing the cell density to VTU files.
    Keywords: <i> FINITE_VOLUME, IO, VTU </i>
  */
  m_vtuDensityOutput = true;
  m_vtuDensityOutput = Context::getSolverProperty<MBool>("vtuDensityOutput", m_solverId, AT_, &m_vtuDensityOutput);

  /*! \page propertiesFV
    \section vtuLevelSetOutput
    <code>MBool FvCartesianSolver::m_vtuLevelSetOutput </code>\n
    default = <code>false</code>\n \n
    Enables/disables writing the cell level-set value to VTU files.
    Keywords: <i> FINITE_VOLUME, IO, VTU </i>
  */
  m_vtuLevelSetOutput = false;
  m_vtuLevelSetOutput = Context::getSolverProperty<MBool>("vtuLevelSetOutput", m_solverId, AT_, &m_vtuLevelSetOutput);

  /*! \page propertiesFV
    \section vtuQCriterionOutput
    <code>MBool FvCartesianSolver::m_vtuQCriterionOutput </code>\n
    default = <code>false</code>\n \n
    Enables/disables writing of the Q vortex criterion to VTU output files.
    See: Hunt, J.C.R., Wray, A.A., Moin, P., Eddies, stream, and convergence
    zones in turbulent flows. Center for Turbulence Research Report
    CTR-S88, pp. 193208, 1988.
    Keywords: <i> FINITE_VOLUME, IO, VTU </i>
  */
  m_vtuQCriterionOutput = false;
  m_vtuQCriterionOutput =
      Context::getSolverProperty<MBool>("vtuQCriterionOutput", m_solverId, AT_, &m_vtuQCriterionOutput);

  /*! \page propertiesFV
    \section vtuLambda2Output
    <code>MBool FvCartesianSolver::m_vtuLambda2Output </code>\n
    default = <code>false</code>\n \n
    Enables/disables writing of the $\lambda_2$ vortex criterion to VTU output files.
    See: J. Jeong and F. Hussain. On the Identification of a Vortex.
    J. Fluid Mechanics, 285:69-94, 1995.
    Keywords: <i> FINITE_VOLUME, IO, VTU </i>
  */
  m_vtuLambda2Output = false;
  m_vtuLambda2Output = Context::getSolverProperty<MBool>("vtuLambda2Output", m_solverId, AT_, &m_vtuLambda2Output);

  /*! \page propertiesFV
    \section vtuVorticityOutput
    <code>MBool FvCartesianSolver::m_vtuVorticityOutput </code>\n
    default = <code>false</code>\n \n
    Enables/disables writing the cell vorticity to VTU files.
    Keywords: <i> FINITE_VOLUME, IO, VTU </i>
  */
  m_vtuVorticityOutput = false;
  m_vtuVorticityOutput =
      Context::getSolverProperty<MBool>("vtuVorticityOutput", m_solverId, AT_, &m_vtuVorticityOutput);
  IF_CONSTEXPR(nDim == 2) { m_vtuVorticityOutput = false; } // will be stored anyways

  /*! \page propertiesFV
    \section vtuVelocityGradientOutput
    <code>MBool FvCartesianSolver::m_vtuvelocityGradientOutput </code>\n
    default = <code>false</code>\n \n
    Enables/disables writing the cell velocity gradients to VTU files.
    Keywords: <i> FINITE_VOLUME, IO, VTU </i>
  */
  m_vtuVelocityGradientOutput = false;
  m_vtuVelocityGradientOutput =
      Context::getSolverProperty<MBool>("vtuVelocityGradientOutput", m_solverId, AT_, &m_vtuVelocityGradientOutput);

  /*! \page propertiesFV
    \section vtuSaveHeaderTesting
    <code>MBool FvCartesianSolver::m_vtuSaveHeaderTesting</code>\n
    default = <code>false</code>\n\n
    Outputs to stdout when a vtu file is written.\n
    Keywords: <i>FINITE_VOLUME, I/O</i>
  */
  m_vtuSaveHeaderTesting = false;
  m_vtuSaveHeaderTesting =
      Context::getSolverProperty<MBool>("vtuSaveHeaderTesting", m_solverId, AT_, &m_vtuSaveHeaderTesting);

  /*! \page propertiesFV
    \section vtuLevelThreshold
    <code>MInt FvCartesianSolver::m_vtuLevelThreshold</code>\n
    default = <code> maxRefinementLevel()</code>\n\n
    Optionally specifies the maximum cell level to be saved\n
    Possible values are:
    <ul>
    <li>positve integers smaller or equal maxRefinementLevel() </li>
    </ul>
    Keywords: <i>FINITE_VOLUME, I/O</i>
  */
  m_vtuLevelThreshold = maxRefinementLevel();
  if(Context::propertyExists("vtuLevelThreshold", m_solverId))
    m_vtuLevelThreshold = Context::getSolverProperty<MInt>("vtuLevelThreshold", m_solverId, AT_, &m_vtuLevelThreshold);
  if(m_vtuLevelThreshold <= 0) m_vtuLevelThreshold = maxRefinementLevel();
  m_log << "m_vtuLevelThreshold: " << m_vtuLevelThreshold << endl;

  /*! \page propertiesFV
    \section vtuCoordinatesThreshold
    <code>MFloat FvCartesianSolver::m_vtuCoordinatesThreshold</code>\n
    default = <code>none</code>\n \n
    Specify a bounding box to which the output domain is truncated when writing VTU output. \n \n
    Possible values are:
    <ul>
      <li>list of 2*nDim floating point values</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, IO, VTU</i>
  */
  m_vtuCoordinatesThreshold = nullptr;
  if(Context::propertyExists("vtuCoordinatesThreshold", m_solverId)) {
    mAlloc(m_vtuCoordinatesThreshold, 6, "m_vtuCoordinatesThreshold", F0, AT_);
    for(MInt i = 0; i < 2 * nDim; i++) {
      m_vtuCoordinatesThreshold[i] = Context::getSolverProperty<MFloat>("vtuCoordinatesThreshold", m_solverId, AT_,
                                                                        &m_vtuCoordinatesThreshold[i], i);
    }
  }
  m_log << "m_vtuCoordinatesThreshold: ";
  if(m_vtuCoordinatesThreshold == nullptr)
    m_log << "nullptr";
  else
    for(MInt i = 0; i < 2 * nDim; i++) {
      m_log << m_vtuCoordinatesThreshold[i] << " ";
    }
  m_log << endl;


  m_variablesName = new const MChar*[PV->noVariables];
  for(MInt i = 0; i < PV->noVariables; ++i) {
    m_variablesName[i] = new MChar[10];
  }

  MInt count = 0;
  m_variablesName[count] = "u";
  count++;
  m_variablesName[count] = "v";
  count++;
  IF_CONSTEXPR(nDim == 3) {
    m_variablesName[count] = "w";
    count++;
  }
  m_variablesName[count] = "rho";
  count++;
  m_variablesName[count] = "p";
  count++;
  IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
    IF_CONSTEXPR(SysEqn::m_ransModel == RANS_SA_DV || SysEqn::m_ransModel == RANS_FS) {
      m_variablesName[count] = "nu";
      count++;
    }
    IF_CONSTEXPR(SysEqn::m_ransModel == RANS_KOMEGA || SysEqn::m_ransModel == RANS_SST) {
      m_variablesName[count] = "k";
      count++;
      m_variablesName[count] = "omega";
      count++;
    }
  }

  if(m_combustion) {
    m_variablesName[count] = "c";
    count++;
  } else {
    if(m_noSpecies == 1) {
      m_variablesName[count] = "Y";
      count++;
    }

    IF_CONSTEXPR(isDetChem<SysEqn>) {
      if(m_noSpecies > 1) {
        for(MInt s = 0; s < m_noSpecies; s++) {
          MString str = ("Y" + m_speciesName[s]);
          MChar* c = new MChar[10];
          strcpy(c, str.c_str());
          m_variablesName[count] = c;
          count++;
        }
      }
    }
  }


  count = 0;
  m_vorticitySize = 0;
  if(m_vorticityOutput) {
    IF_CONSTEXPR(nDim == 3) {
      m_vorticitySize = 3;
      m_vorticityName = new const MChar*[m_vorticitySize];
      for(MInt i = 0; i < 3; ++i)
        m_vorticityName[i] = new MChar[16];

      m_vorticityName[0] = "vorticity(x)";
      m_vorticityName[1] = "vorticity(y)";
      m_vorticityName[2] = "vorticity(z)";
    }
    else IF_CONSTEXPR(nDim == 2) {
      m_vorticitySize = 1;
      m_vorticityName = new const MChar*[m_vorticitySize];
      for(MInt i = 0; i < 1; ++i)
        m_vorticityName[i] = new MChar[16];
      m_vorticityName[0] = "vorticity(z)";
    }
    else {
      m_vorticityName = (const MChar**)nullptr;
    }
  } else {
    m_vorticityName = (const MChar**)nullptr;
  }

  /*! \page propertiesFV
    \section outputFormat
    <code>MString FvCartesianSolver::m_outputFormat </code>\n
    default = <code> levelSetMb ? "VTU" : "NETCDF" </code>\n
    Defines the output file format of the finite volume solver\n
    Possible values are:
    <ul>
      <li>VTU</li>
      <li>NETCDF</li>
    </ul>
    Keywords: <i>FINITE VOLUME, FILE FORMAT, NETCDF, VTU</i>
  */
  m_outputFormat = m_levelSetMb ? "VTU" : "NETCDF";
  m_outputFormat = Context::getSolverProperty<MString>("outputFormat", m_solverId, AT_, &m_outputFormat);

  if((string2enum(m_outputFormat) != NETCDF) && (string2enum(m_outputFormat) != VTU)) {
    m_log << "WARNING: Output format changed to " << m_outputFormat << " for massive parallel computation! " << endl;
    m_outputFormat = "NETCDF";
  }
  if(noDomains() > 1 && (string2enum(m_outputFormat) == VTK)) {
    m_log << "WARNING: Output format changed to " << m_outputFormat << " for massive parallel computation! " << endl;
    m_outputFormat = "VTU";
  }

  m_log << " * Using output format " << m_outputFormat << endl;

  m_outputOffset = 0;
  m_outputOffset = Context::getSolverProperty<MInt>("outputOffset", m_solverId, AT_, &m_outputOffset);

  // set write-out parameters
  /*! \page propertiesFV
      \section writeOutData
      <code>MBool FvCartesianSolver::m_writeOutData </code>\n
      default = <code>none</code>\n \n
      Controls the centerline data writeOut.\n
      possible values are:
      <ul>
      <li> 0 - disable </li>
      <li> 1 - enable </li>
      </ul>
      Keywords: <i> FINITE_VOLUME, OUTPUT </i>
  */
  m_writeOutData = 0;
  m_writeOutData = Context::getSolverProperty<MInt>("writeOutData", m_solverId, AT_, &m_writeOutData);

  /*! \page propertiesFV
      \section recordBodyData
      <code>MBool FvCartesianSolver::m_recordBodyData </code>\n
      default = <code>none</code>\n \n
      If enabled (set to 1), extra output is generated with e.g. the body position.\n
      possible values are:
      <ul>
      <li> 0 - disable </li>
      <li> 1 - enable </li>
      </ul>
      Keywords: <i> FINITE_VOLUME, OUTPUT, MOVING_BOUNDARY </i>
  */
  m_recordBodyData = Context::getSolverProperty<MBool>("recordBodyData", m_solverId, AT_, &tmpFalse);
  m_recordLandA = Context::getSolverProperty<MBool>("recordLandA", m_solverId, AT_, &tmpFalse);

  /*! \page propertiesFV
    \section recordWallVorticity
    <code>MBool FvCartesianSolver::m_recordWallVorticity</code>\n
    default = <code>false</code>\n \n
    Determine minimum and maximum wall vorticity (for boundary condition 3006, not covered in
    testcases). \n \n
    Possible values are:
    <ul>
      <li><code>0</code> (off)</li>
      <li><code>1</code> (on)</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, I/O, WALL, BOUNDARY, VORTICITY</i>
  */
  m_recordWallVorticity = Context::getSolverProperty<MBool>("recordWallVorticity", m_solverId, AT_, &tmpFalse);

  // Set parameter for writing out cut-cell information
  /*! \page propertiesFV
      \section writeCutCellsToGridFile
      <code>MBool FvCartesianSolver::m_writeCutCellsToGridFile </code>\n
      default = <code>0</code>\n \n
      If enabled (set to 1), all cut cell information necessary for visualizing the cut cells in Paraview
      is written to the grid file.\n \n
      possible values are:
      <ul>
      <li> 0 - disable </li>
      <li> 1 - enable </li>
      </ul>
      Keywords: <i> FINITE_VOLUME, OUTPUT, CUT_CELLS </i>
  */
  m_writeCutCellsToGridFile = Context::getSolverProperty<MBool>("writeCutCellsToGridFile", m_solverId, AT_, &tmpFalse);

  // set restart properties
  /*! \page propertiesFV
      \section restartBc2800
      <code>MBool FvCartesianSolver::m_restartBc2800</code>\n
      default = <code>0</code>\n \n
      restarts the boundary condition bc2800 (actually all boundary conditions that call
     FvBndryCndXD::initModes(MInt)).\n Start: inserts plane waves starting smoothly with zero amplitude at the
     lowest argument found in the computational domain.\n Restart: reads the lowest argument from the restart file and
     continues the continuous insertion of plane waves\n possible values are: <ul> <li> 0 - start bc </li> <li> 1 -
     restart bc </li>
      </ul>
      Keywords: <i>TUNNEL NOISE, RECEPTIVITY, bc2800</i>
  */
  m_restartBc2800 = false;
  m_restartBc2800 = Context::getSolverProperty<MBool>("restartBc2800", m_solverId, AT_, &m_restartBc2800);

  if(m_useNonSpecifiedRestartFile && isMultilevel()) {
    mTerm(1, "Error: useNonSpecifiedRestartFile needs to be disables for a multilevel computation");
  }

  /*! \page propertiesFV
      \section restartBackupInterval
      <code>MInt FvCartesianSolver::m_restartBackupInterval</code>\n
      default = <code>25000</code>\n
      Defines the interval in which restart backup files are created\n
      Possible values are:
      <ul>
      <li>positive integers</li>
      </ul>
      Keywords: <i>FINITE_VOLUME, RESTART, I/O</i>
  */
  m_restartBackupInterval = 25000;
  m_restartBackupInterval =
      Context::getSolverProperty<MInt>("restartBackupInterval", m_solverId, AT_, &m_restartBackupInterval);

  /*! \page propertiesFV
      \section restartOldVariables
      <code>MBool FvCartesianSolver::m_restartOldVariables </code>\n
      default = <code>false</code>\n \n
      If enabled, oldVariables are saved to and restored from restart files.\n \n
      Possible values are:
      <ul>
      <li> 0 - disable </li>
      <li> 1 - enable </li>
      </ul>
      Keywords: <i> FINITE_VOLUME, RESTART, OUTPUT, OLD_VARIABLES </i>
  */
  m_restartOldVariables = false;
  m_restartOldVariables =
      Context::getSolverProperty<MBool>("restartOldVariables", m_solverId, AT_, &m_restartOldVariables);

  /*! \page propertiesFV
      \section restartOldVariablesReset
      <code>MBool FvCartesianSolver::m_restartOldVariablesReset </code>\n
      default = <code>false</code>\n \n
      If enabled, oldVariables are initialized with the current variables and not loaded from a
      restart file. To be used if one wants to enable restartOldVariables at a restart.\n \n
      Possible values are:
      <ul>
      <li> 0 - disable </li>
      <li> 1 - enable </li>
      </ul>
      Keywords: <i> FINITE_VOLUME, RESTART, OUTPUT, OLD_VARIABLES </i>
  */
  m_restartOldVariablesReset = false;
  m_restartOldVariablesReset =
      Context::getSolverProperty<MBool>("restartOldVariablesReset", m_solverId, AT_, &m_restartOldVariablesReset);

  /*! \page propertiesFV
      \section checkCellSurfaces
      <code>MBool FvCartesianSolver::checkCellSurfaces </code>\n
      default = <code>none</code>\n \n
      If enabled, cell surfaces are checked for consistency.\n \n
      Possible values are:
      <ul>
      <li> 0 - disable </li>
      <li> 1 - enable </li>
      </ul>
      Keywords: <i> FINITE_VOLUME, SURFACES</i>
  */
  // set surface check parameter
  m_checkCellSurfaces = Context::getSolverProperty<MBool>("checkCellSurfaces", m_solverId, AT_, &tmpFalse);
  if(m_checkCellSurfaces) m_log << " * Checking cell surfaces for consistency! " << endl;

  m_bodyIdOutput = false;
  /*! \page propertiesFV
    \section bodyIdOutput
    <code>MBool FvMbSolver::m_bodyIdOutput </code>\n
    default = <code>!m_constructGField</code>\n \n
    Determines whether the additionale bodyIdOutput output should be written!
    Default is !m_constructGField, but the output is not necessary for a restart and
    should be set to false for large applications, to reduce the amount of data!
    Keywords: <i>LEVELSET, MOVING BOUNDARY</i>
  */
  m_bodyIdOutput = Context::getSolverProperty<MBool>("bodyIdOutput", m_solverId, AT_, &m_bodyIdOutput);

  m_levelSetOutput = false;
  /*! \page propertiesFV
    \section levelSetOutput
    <code>MBool FvMbSolver::m_levelSetOutput </code>\n
    default = <code>!m_constructGField</code>\n \n
    Determines whether the additional levelset values output should be written!
    Default is !m_constructGField, but the output is not necessary for a restart and
    should be set to false for large applications, to reduce the amount of data!
    Use isActiveOutput instead, which is just a bool and more accurate!
    Keywords: <i>LEVELSET, MOVING BOUNDARY</i>
  */
  m_levelSetOutput = Context::getSolverProperty<MBool>("levelSetOutput", m_solverId, AT_, &m_levelSetOutput);

  m_isActiveOutput = false;
  /*! \page propertiesFV
    \section isActiveOutput
    <code>MBool FvMbSolver::m_isActiveOutput </code>\n
    default = <code>false</code>\n \n
    Default is false, but the output is not necessary for a restart and
    should be set to false for large applications, to reduce the amount of data!
    IsActiveOutput can be used, to limit the visualization to the valid fluid domain
    in moving-boundary applications.
    Keywords: <i>FINITE_VOLUME, MOVING BOUNDARY</i>
  */
  m_isActiveOutput = Context::getSolverProperty<MBool>("isActiveOutput", m_solverId, AT_, &m_isActiveOutput);

  /*! \page propertiesFV
    \section domainIdOutput
    <code>MBool FvMbSolver::m_domainIdOutput </code>\n
    default = <code>false</code>\n \n
    Determines whether the domainId should be written to the file.
    The output is not necessary for a restar and only useful to display the
    current partitioning.
    Keywords: <i>FINITE_VOLUME, OUTPUT</i>
  */
  m_domainIdOutput = false;
  m_domainIdOutput = Context::getSolverProperty<MBool>("domainIdOutput", m_solverId, AT_, &m_domainIdOutput);

  setSamplingProperties();
}

/**
 * \fn void FvCartesianSolverXD::setSamplingProperties()
 * \brief Reads properties associated with variable sampling
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setSamplingProperties() {
  TRACE();

  // Sampling properties - used for sample output in writeRestartFile:
  /*! \page propertiesFV
  \section sampleRate
  <code>MFloat FvCartesianSolver::m_sampleRate</code>\n
  default:  0.000001\n \n
  Determines how often sampling is performed. \n
  Keywords: <i>FINITE_VOLUME</i>
*/
  m_sampleRate = 0.000001;
  m_sampleRate = Context::getSolverProperty<MFloat>("sampleRate", m_solverId, AT_, &m_sampleRate);

  m_noSamples = 0;
  /*! \page propertiesFV
  \section samplingTimeBegin
  <code>MFloat FvCartesianSolver::m_samplingTimeBegin</code>\n
  default:  infinity\n \n
  Set beginning of sampling time \n
  Keywords: <i>FINITE_VOLUME</i>
*/
  m_samplingTimeBegin = std::numeric_limits<MFloat>::max();
  m_samplingTimeBegin = Context::getSolverProperty<MFloat>("samplingTimeBegin", m_solverId, AT_, &m_samplingTimeBegin);

  /*! \page propertiesFV
   \section m_samplingTimeEnd
   <code>MFloat FvCartesianSolver::m_samplingTimeEnd</code>\n
   default:  0.0 \n \n
   Determines the time step at which sampling will be deactivated.  \n
   Keywords: <i>FINITE_VOLUME, SAMPLE </i>
 */
  m_samplingTimeEnd = 0;
  m_samplingTimeEnd = Context::getSolverProperty<MFloat>("samplingTimeEnd", m_solverId, AT_, &m_samplingTimeEnd);

  // Sampling properties - used for structuredFlameOutput

  /*! \page propertiesFV
    \section samplingStartCycle
    <code>MFloat FvCartesianSolver::m_samplingStartCycle</code>\n
    default: <code>-1</code>\n
    Sets the first cycle that is sampled in the 17511 2D_steady_bunsen_flame test-case starts. \n
    Keywords: <i>FINITE_VOLUME, SAMPLE </i>
  */
  m_samplingStartCycle = -1;
  m_samplingStartCycle = Context::getSolverProperty<MInt>("samplingStartCycle", m_solverId, AT_, &m_samplingStartCycle);

  /*! \page propertiesFV
    \section samplingEndCycle
    <code>MInt FvCartesianSolver::m_samplingEndCycle</code>\n
    default:  -1 \n \n
    Sets the last cycle that is sampled in the 17511 2D_steady_bunsen_flame test-case starts. \n
    Keywords: <i>FINITE_VOLUME, SAMPLING</i>
  */
  m_samplingEndCycle = -1;
  m_samplingEndCycle = Context::getSolverProperty<MInt>("samplingEndCycle", m_solverId, AT_, &m_samplingEndCycle);

  // used by computeTimeStep case 17511 used by the 2D_steady_bunsen_flame testcase and in structuredFlameOutput
  m_samplesPerCycle = 100.;
  /*! \page propertiesFV
    \section samplesPerCycle
    <code>MFloat FvCartesianSolver::m_samplesPerCycle</code>\n
    default: <code>100</code>\n
    Sets the number of samples per cycle in the 17511 2D_steady_bunsen_flame test-case starts. \n
    Keywords: <i>FINITE_VOLUME, SAMPLE </i>
  */
  m_samplesPerCycle = Context::getSolverProperty<MFloat>("samplesPerCycle", m_solverId, AT_, &m_samplesPerCycle);

  /*! \page propertiesFV
    \section samplingStartIteration
    <code>MFloat FvCartesianSolver::m_samplingStartIteration</code>\n
    default:  -99999.0 \n \n
    Determines at which time-step the sampling for the 17511 2D_steady_bunsen_flame test-case starts. \n
    Keywords: <i>FINITE_VOLUME, SAMPLING</i>
  */
  m_samplingStartIteration = -99999.0;
  m_samplingStartIteration =
      Context::getSolverProperty<MInt>("samplingStartIteration", m_solverId, AT_, &m_samplingStartIteration);

  /*! \page propertiesFV
  \section noSamplingCycles
  <code>MInt FvCartesianSolver::m_noSamplingCylces</code>\n
  default:  2\n \n
  Determines how many sampling cycles are performed. \n
  Keywords: <i>FINITE_VOLUME, SAMPLING</i>
*/
  m_noSamplingCycles = 2;
  m_noSamplingCycles = Context::getSolverProperty<MInt>("noSamplingCycles", m_solverId, AT_, &m_noSamplingCycles);

  // initialize number of time steps between samples
  m_noTimeStepsBetweenSamples = -1;

  // force no time steps -> avoids the adaption of the timeSteps to the required number of timeSteps determined by the
  // applied noSamplingCycles
  m_forceNoTimeSteps = 0;
  m_forceNoTimeSteps = Context::getSolverProperty<MInt>("forceNoTimeSteps", m_solverId, AT_, &m_forceNoTimeSteps);
}

/** \fn void FvCartesianSolverXD<nDim_,SysEqn>::setAndAllocateCombustionGequPvProperties()
 * \brief reads in the combustion properties
 *
 * \author Stephan Schlimpert
 * \date 12.12.2010, 17.06.2011
 */

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setAndAllocateCombustionGequPvProperties() {
  TRACE();

  MBool tmpFalse = false;

  // Basic initialization for all variables which belong to GequPv method
  m_massFlux = false;
  m_plenum = false;
  m_confinedFlame = false;
  m_plenumWall = false;
  m_useCorrectedBurningVelocity = false;
  m_totalDamp = false;
  m_MaFlameTube = m_Ma;
  m_pressureLossFlameSpeed = 1;
  m_pressureLossCorrection = F0;
  m_recordPressure = false;
  m_recordFlameFrontPosition = false;
  m_structuredFlameOutput = false;
  m_structuredFlameOutputLevel = 0;
  m_twoFlames = false;
  m_acousticAnalysis = false;
  m_ScT = 0;

  if(m_combustion) {
    m_marksteinLength = 0.1;
    /*! \page propertiesFV
    \section marksteinLength
    <code>MFloat FvCartesianSolver::m_marksteinLength </code>\n
    default = <code>0.1</code>\n \n
    controls the flame curvature effects on the flame. The local flame speed is corrected by the local curvature
    \f$ s_{l} = s_{l,0} (1 - l_{c}*\kappa) \f$:
    <ul>
    <li> \f$ l_{c} \f$ is the markstein length</li>
    <li> \f$ s_{l} \f$ is the local flame speed</li>
    <li> \f$ s_{l,0} \f$ is the constant flame speed of an uncurved flat flame, \ref flameSpeed</li>
    <li> \f$ \kappa \f$ is the local curvature calculated in the level set band.</li>
    </ul>
    possible values are:
    <ul>
    <li>Non-negative floating point values of the order of 0.1</li>
    </ul>
    Keywords: <i>MARKSTEIN, COMBUSTION, LEVELSET, CURVATURE, FLAME</i>
  */
    m_marksteinLength = Context::getSolverProperty<MFloat>("marksteinLength", m_solverId, AT_);

    m_marksteinLengthPercentage = F1;
    /*! \page propertiesFV
    \section marksteinLengthPercentage
    <code>MFloat FvCartesianSolver::m_marksteinLengthPercentage </code>\n
    default = <code>1</code>\n \n
    controls wether a neutrally stable flame (m_marksteinLengthPercentage = 1), stable (>1) or instable (<1) is
    computed, see also \ref marksteinLength : <ul> possible values are: <ul> <li>Non-negative floating point values of
    the order of 0.0 - 2.0 </li>
    </ul>
    Keywords: <i>MARKSTEIN, LENGTH, PERCENTAGE, COMBUSTION, LEVELSET, CURVATURE, FLAME</i>
  */
    m_marksteinLengthPercentage =
        Context::getSolverProperty<MFloat>("marksteinLengthPercentage", m_solverId, AT_, &m_marksteinLengthPercentage);

    m_log << "neutral markstein length is:" << m_marksteinLength << endl;

    m_marksteinLength *= m_marksteinLengthPercentage;
    m_log << "markstein length is changed to :" << m_marksteinLength << endl;
    m_log << "markstein length percentage is :" << m_marksteinLengthPercentage << endl;


    /*! \page propertiesFV
    \section zeroLineCorrection
    <code>MBool FvCartesianSolver::m_zeroLineCorrection </code>\n
    default = <code>0</code>\n \n
    controls the correction of the grwoth rate computation. \n
    possible values are:
    <ul>
    <li>0 - off</li>
    <li>1 - on</li>
    </ul>
    Keywords: <i>MARKSTEIN, COMBUSTION, LEVELSET, ZERO, LINE, CORRECTION</i>
  */
    m_zeroLineCorrection = Context::getSolverProperty<MBool>("zeroLineCorrection", m_solverId, AT_, &tmpFalse);

    m_inletTubeAreaRatio = F1;
    /*! \page propertiesFV
    \section inletTubeAreaRatio
    <code>MFloat FvCartesianSolver::m_inletTubeAreaRatio </code>\n
    default = <code>1</code>\n \n
    this property depends on your geometry and is used for the calculation of the pressure loss caused by the area
    change inlet-tube. \n possible values are: <ul> <li>Non-negative floating point values</li>
    </ul>
    Keywords: <i>COMBUSTION, INLET, TUBE, AREA, RATIO</i>
  */
    m_inletTubeAreaRatio =
        Context::getSolverProperty<MFloat>("inletTubeAreaRatio", m_solverId, AT_, &m_inletTubeAreaRatio);

    m_inletOutletAreaRatio = F1;
    /*! \page propertiesFV
    \section inletOutletAreaRatio
    <code>MFloat FvCartesianSolver::m_inletOutletAreaRatio </code>\n
    default = <code>1</code>\n \n
    this property depends on your geometry and is used for the calculation of the outlet velocity needed for the sponge
    zone at the outlet. The property is only needed if there are no slip walls used in the outlet \ref plenumWall \n
    possible values are:
    <ul>
    <li>Non-negative floating point value</li>
    </ul>
    Keywords: <i>COMBUSTION, INLET, TUBE, AREA, RATIO</i>
  */
    m_inletOutletAreaRatio =
        Context::getSolverProperty<MFloat>("inletOutletAreaRatio", m_solverId, AT_, &m_inletOutletAreaRatio);

    m_flameOutletAreaRatio = F1;
    /*! \page propertiesFV
    \section flameOutletAreaRatio
    <code>MFloat FvCartesianSolver::m_flameOutletAreaRatio </code>\n
    default = <code>1</code>\n \n
    this property depends on your geometry and is used for the calculation pressure loss, needed for the sponge zone at
    the outlet. The property is only needed if there are no slip walls used in the outlet \ref plenumWall \n possible
    values are: <ul> <li>Non-negative floating point value</li>
    </ul>
    Keywords: <i>COMBUSTION, INLET, TUBE, AREA, RATIO</i>
  */
    m_flameOutletAreaRatio =
        Context::getSolverProperty<MFloat>("flameOutletAreaRatio", m_solverId, AT_, &m_flameOutletAreaRatio);

    /*! \page propertiesFV
    \section massFlux
    <code>MBool FvCartesianSolver::m_massFlux </code>\n
    default = <code>0</code>\n \n
    this property triggers the calculation of the mass flux at the inlet and outlet of your geometry but only if the
    inlet boundary condition 17514 (17614,17714) and the outlet condition 1753 (1743,1763,1773). Only meaningful if the
    inflow conditions 17514 (17614,17714) and the outflow conditions 1753 (1743,1763,1773) and if no slip walls are used
    at the outlet \ref plenumWall \n to do!!: general mass flux function should be implemented. \n possible values are:
    <ul>
    <li>0 - off</li>
    <li>1 - on</li>
    </ul>
    Keywords: <i>COMBUSTION, INLET, OUTLET, MASS, FLUX</i>
  */
    m_massFlux = Context::getSolverProperty<MBool>("massFlux", m_solverId, AT_, &tmpFalse);

    /*! \page propertiesFV
    \section confinedFlame
    <code>MBool FvCartesianSolver::m_confinedFlame </code>\n
    default = <code>0</code>\n \n
    this property triggers the use of higher pressure in the inlet tube section because of the pressure differences
    induced by the flame and the walls in the outlet \n possible values are: <ul> <li>0 - flames without confinedFlame
    at the inlet</li> <li>1 - flames with confinedFlame at the inlet</li>
    </ul>
    Keywords: <i>COMBUSTION, OUTLET, CONFINED, FLAME, WALL</i>
  */
    m_confinedFlame = Context::getSolverProperty<MBool>("confinedFlame", m_solverId, AT_, &tmpFalse);

    /*! \page propertiesFV
    \section plenum
    <code>MBool FvCartesianSolver::m_plenum </code>\n
    default = <code>0</code>\n \n
    this property triggers the use of the averaged variables in the flame tube if a plenum as inlet is used. And is
    automatically turned on for the use of a plenum with walls in the outlet, see \ref plenumWall \n possible values
    are: <ul> <li>0 - flames without plenum at the inlet</li> <li>1 - flames with plenum at the inlet</li>
    </ul>
    Keywords: <i>COMBUSTION, OUTLET, TUBE, WALL</i>
  */
    m_plenum = Context::getSolverProperty<MBool>("plenum", m_solverId, AT_, &tmpFalse);

    /*! \page propertiesFV
    \section plenumWall
    <code>MBool FvCartesianSolver::m_plenumWall </code>\n
    default = <code>0</code>\n \n
    this property triggers an additional pressure loss because of the no slip walls used in the outlet, needed for the
    sponge zone at the outlet. The property is only needed if there are no slip walls used in the outlet \ref plenumWall
    \n possible values are: <ul> <li>0 - if slip walls in the outlet</li> <li>1 - if no slip walls in the outlet</li>
    </ul>
    Keywords: <i>COMBUSTION, OUTLET, TUBE, WALL</i>
  */
    m_plenumWall = Context::getSolverProperty<MBool>("plenumWall", m_solverId, AT_, &tmpFalse);

    if(m_plenumWall) {
      m_plenum = m_plenumWall;
    }

    /*! \page propertiesFV
    \section useCorrectedBurningVelocity
    <code>MInt FvCartesianSolver::m_useCorrectedBurningVelocity </code>\n
    default = <code>0</code>\n \n
    this property triggers the use of the corrected burning velocity which is calculated via the hyperbolic extension
    \ref extVelCFL, extVelBC, \ref hyperbolicCurvature, needed for the heat release source term and for the total
    mass consumption. See also the Paper from Peng, Journal of Computational Physics 155, 410-438 (1999) \n possible
    values are: <ul> <li>0 - off</li> <li>1 - on</li>
    </ul>
    Keywords: <i>COMBUSTION, CORRECTED, BURNING, VELOCITY, HEAT, RELEASE, SOURCE, TERM, HYPERBOLIC, EXTENSION </i>
  */
    m_useCorrectedBurningVelocity = Context::getSolverProperty<MBool>("useCorrectedBurningVelocity", m_solverId, AT_,
                                                                      &m_useCorrectedBurningVelocity);

    /*! \page propertiesFV
    \section filterFlameTubeEdges
    <code>MBool FvCartesianSolver::m_filterFlameTubeEdges </code>\n
    default = <code>0</code>\n \n
    temporarly trigger for second order filtering of the fourth order discretization (normal and curvature computation)
    at the flame tube edges dependent on the \ref dampingDistanceFlameBase \n. possible values are: <ul> <li>0 -
    off</li> <li>1 - on</li>
    </ul>
    Keywords: <i>COMBUSTION, FILTERING, FLAME, BASE</i>
  */
    m_filterFlameTubeEdges = Context::getSolverProperty<MBool>("filterFlameTubeEdges", m_solverId, AT_, &tmpFalse);

    m_filterFlameTubeEdgesDistance = -9999.9;
    /*! \page propertiesFV
    \section filterFlameTubeEdgesDistance
    <code>MFloat FvCartesianSolver::m_filterFlameTubeEdgesDistance </code>\n
    default = <code>-9999.9</code>\n \n
    Up to this distance relative to the flame tube edges the second order filtering (normal and curvature computation)
    is applied \ref filterFlameTubeEdges \n. possible values are: <ul> <li>0 - off</li> <li>1 - on</li>
    </ul>
    Keywords: <i>COMBUSTION, FILTERING, FLAME, BASE</i>
  */
    m_filterFlameTubeEdgesDistance = Context::getSolverProperty<MFloat>("filterFlameTubeEdgesDistance", m_solverId, AT_,
                                                                        &m_filterFlameTubeEdgesDistance);

    /*! \page propertiesFV
    \section totalDamp
    <code>MBool FvCartesianSolver::m_totalDamp </code>\n
    default = <code>0</code>\n \n
    temporarly trigger for testing the damping at the flame base the curvature or corrected burning velocity, \ref
    dampingDistanceFlameBase \n possible values are: <ul> <li>0 - off</li> <li>1 - on</li>
    </ul>
    Keywords: <i>COMBUSTION, DAMPING, FLAME, BASE</i>
  */
    m_totalDamp = Context::getSolverProperty<MBool>("totalDamp", m_solverId, AT_, &tmpFalse);

    m_heatReleaseDamp = 1;
    /*! \page propertiesFV
    \section heatReleaseDamp
    <code>MInt FvCartesianSolver::m_heatReleaseDamp </code>\n
    default = <code>0</code>\n \n
    temporarly trigger for testing the damping at the flame base the heat release, \ref dampingDistanceFlameBase \n
    possible values are:
    <ul>
    <li>0 - off</li>
    <li>1 - on</li>
    </ul>
    Keywords: <i>COMBUSTION, DAMPING, FLAME, BASE</i>
  */
    m_heatReleaseDamp = Context::getSolverProperty<MBool>("heatReleaseDamp", m_solverId, AT_, &m_heatReleaseDamp);

    /*! \page propertiesFV
    \section modelCheck
    <code>MBool FvCartesianSolver::m_modelCheck </code>\n
    default = <code>0</code>\n \n
    temporarly trigger for testing the model \n
    possible values are:
    <ul>
    <li>0 - off</li>
    <li>1 - on</li>
    </ul>
    Keywords: <i>COMBUSTION, PROGRESS, MODEL, CHECK</i>
  */
    m_modelCheck = Context::getSolverProperty<MBool>("modelCheck", m_solverId, AT_, &tmpFalse);

    /*! \page propertiesFV
    \section flameSpeed
    <code>MFloat FvCartesianSolver::m_flameSpeed </code>\n
    no default value \n \n
    This variable defines the constant flame speed of an uncurved flat flame. The local flame speed is corrected by the
    local curvature \f$ \kappa \f$ in the code \f$ s_{l} = s_{l,0} (1 - l_{c}*\kappa) \f$. \n This correction is
    controlled by the markstein length \f$ l_{c} \f$ \ref marksteinLength. <ul> <li> \f$ s_{l,0} \f$ is the constant
    flame speed of an uncurved flat flame,</li> <li> \f$ l_{c} \f$ is the markstein length \ref marksteinLength,</li>
    <li> \f$ s_{l} \f$ is the local flame speed,</li>
    <li> \f$ \kappa \f$ is the local curvature calculated in the level set band \ref .</li>
    </ul>
    possible values are:
    <ul>
    <li>Non-negative floating point values of the order of 0.02</li>
    </ul>
    Keywords: <i>COMBUSTION, LEVELSET, CURVATURE, FLAME, SPEED, MARKSTEIN, LENGTH</i>
  */
    m_flameSpeed = Context::getSolverProperty<MFloat>("flameSpeed", m_solverId, AT_);

    m_analyticIntegralVelocity = m_Ma;
    /*! \page propertiesFV
    \section analyticIntegralVelocity
    <code>MFloat FvCartesianSolver::m_analyticIntegralVelocity </code>\n
    no default value \n \n
    This variable defines the integral velocity of the inflow profile determined by matlab or other tools.
    possible values are:
    <ul>
    <li>Non-negative floating point values of the order of the velocity </li>
    </ul>
    Keywords: <i>COMBUSTION, INTEGRAL, VELOCITY</i>
  */
    m_analyticIntegralVelocity =
        Context::getSolverProperty<MFloat>("analyticIntegralVelocity", m_solverId, AT_, &m_analyticIntegralVelocity);

    m_meanVelocity = F1B2 * m_Ma;
    /*! \page propertiesFV
    \section meanVelocity
    <code>MFloat FvCartesianSolver::m_meanVelocity </code>\n
    no default value \n \n
    This variable defines the integral velocity of the inflow profile determined by matlab or other tools.
    possible values are:
    <ul>
    <li>Non-negative floating point values of the order of the velocity </li>
    </ul>
    Keywords: <i>COMBUSTION, INTEGRAL, VELOCITY</i>
  */
    m_meanVelocity = Context::getSolverProperty<MFloat>("meanVelocity", m_solverId, AT_, &m_meanVelocity);


    m_pressureLossFlameSpeed = 0;
    /*! \page propertiesFV
    \section pressureLossFlameSpeed
    <code>MInt FvCartesianSolver::m_pressureLossFlameSpeed </code>\n
    default = <code>0</code>\n \n
    <ul>
    <li> off - 0 </li>
    <li> on - 1 </li>
    </ul>
    possible values are:
    <ul>
    <li>Non-negative integer value 1 or 0</li>
    </ul>
    Keywords: <i>COMBUSTION, LEVELSET, FLAME, SPEED, PRESSURE, LOSS</i>
  */
    m_pressureLossFlameSpeed =
        Context::getSolverProperty<MInt>("pressureLossFlameSpeed", m_solverId, AT_, &m_pressureLossFlameSpeed);

    m_pressureLossCorrection = F0;
    /*! \page propertiesFV
    \section pressureLossCorrection
    <code>MFloat FvCartesianSolver::m_pressureLossCorrection </code>\n
    pressure loss correction.
    default = <code>0.0</code>\n \n
    possible values are:
    <ul>
    <li>Non-negative double value</li>
    </ul>
    Keywords: <i>COMBUSTION, LEVELSET, PRESSURE, LOSS</i>
  */
    m_pressureLossCorrection =
        Context::getSolverProperty<MFloat>("pressureLossCorrection", m_solverId, AT_, &m_pressureLossCorrection);

    m_constantFlameSpeed = 0;
    /*! \page propertiesFV
    \section constantFlameSpeed
    <code>MInt FvCartesianSolver::m_constantFlameSpeed </code>\n
    default = <code>0</code>\n \n
    <ul>
    <li> off - 0 </li>
    <li> on - 1 </li>
    </ul>
    possible values are:
    <ul>
    <li>Non-negative integer value 1 or 0</li>
    </ul>
    Keywords: <i>COMBUSTION, LEVELSET, CONSTANT, FLAME, SPEED, MARKSTEIN, LENGTH</i>
  */
    m_constantFlameSpeed =
        Context::getSolverProperty<MInt>("constantFlameSpeed", m_solverId, AT_, &m_constantFlameSpeed);

    m_neutralFlameStrouhal = -F1;
    /*! \page propertiesFV
    \section neutralFlameStrouhal
    <code>MFloat FvCartesianSolver::m_neutralFlameStrouhal </code>\n
    default = -1.0 \n \n
    This variable defines a flame strouhal number based on length one, needed for comparison to neutral markstein length
    computations. \n possible values are: <ul> <li>Non-negative floating point values</li>
    </ul>
    Keywords: <i>COMBUSTION, FLAME, STROUHAL, NUMBER, NEUTRAL, MARKSTEIN, LENGTH</i>
  */
    m_neutralFlameStrouhal =
        Context::getSolverProperty<MFloat>("neutralFlameStrouhal", m_solverId, AT_, &m_neutralFlameStrouhal);

    m_noReactionCells = 0.026367201;
    /*! \page propertiesFV
    \section noReactionCells
    <code>MFloat FvCartesianSolver::m_noReactionCells </code>\n
    default = <code>4</code>\n \n
    This variable controls the number of reaction cells which are used for the heat release calculation.
     This is applied for the initial condition 17516 via a tanh-function
     \f[ (((F1/m_noReactionCells)*m_FgCellDistance )) *(F1-tanh(a_levelSetFunction[ IDX_LSSET(gc , 0) ]
     * (F1/m_noReactionCells) * m_FgCellDistance )) \f] with \n
    <ul>
    <li> \f$ m_FgCellDistance \f$ - inverse of GCell distance,</li>
    <li> \f$ a_levelSetFunction \f$ - level set function which is zero at the flame front,</li>
    </ul>
    possible values are:
    <ul>
    <li> Non-negative floating point values of the order of 4.0 </li>
    </ul>
    Keywords: <i>COMBUSTION, REACTION, LEVELSET, HEAT, RELEASE, SOURCE, TERM, FLAME </i>
  */
    m_noReactionCells = Context::getSolverProperty<MFloat>("noReactionCells", m_solverId, AT_, &m_noReactionCells);

    m_MaFlameTube = m_Ma;
    /*! \page propertiesFV
    \section MaFlameTube
    <code>MFloat FvCartesianSolver::m_MaFlameTube </code>\n
    default = <code>Ma</code>\n \n
    Mach number defined with the averaged velocity and the averaged speed of sound at the flame tube. Depends on your
    geometry and the infinity values at the inlet. \n possible values are: <ul> <li> Non-negative floating point values
    of the order of 4.0 </li>
    </ul>
    Keywords: COMBUSTION, MACH, NUMBER, FLAME, TUBE, SPEED OF SOUND, VELOCITY
  */
    m_MaFlameTube = Context::getSolverProperty<MFloat>("MaFlameTube", m_solverId, AT_, &m_MaFlameTube);

    /*! \page propertiesFV
    \section recordPressure
    <code>MBool FvCartesianSolver::m_recordPressure </code>\n
    default = <code>0</code>\n \n
    controls output of ascii file pressureSensor, with output of:
    <ul>
    <li> globalTimeStep - iteration</li>
    <li> m_time - physical time</li>
    <li> a_pvariable( m_cellToRecordData ,  PV->P ) - pressure of a specific cell to record, should be still
    implemented</li> <li> m_meanPressure - mean pressure, should be generally implemented</li> <li> a_pvariable(
    m_cellToRecordData ,  PV->V ) - velocity of a specific cell to record, should be still implemented</li>
    <li> m_arcLength - flame surface area</li> <li> m_totalHeatReleaseRate - total heat release rate </li> <li>
    m_minFlameFrontPosition[1] - minimum flame front position</li> <li> m_maxFlameFrontPosition[1] - maximum flame front
    position</li> <li> m_meanFlameFrontPosition[1] - mean flame front position</li>
    </ul>
    possible values are:
    <ul>
    <li>0 - off</li>
    <li>1 - on</li>
    </ul>
    Keywords: COMBUSTION, FLAME, FRONT, SURFACE, AREA, FILE, ASCII, OUTPUT
  */
    m_recordPressure = Context::getSolverProperty<MBool>("recordPressure", m_solverId, AT_, &tmpFalse);

    /*! \page propertiesFV
    \section recordFlameFrontPosition
    <code>MBool FvCartesianSolver::m_recordFlameFrontPosition </code>\n
    default = <code>0</code>\n \n
    controls output of ascii file flameFrontData, with output of:
    <ul>
    <li> globalTimeStep - iteration</li>
    <li> m_time - physical time</li>
    <li> m_arcLength - flame surface area</li>
    <li> m_minFlameFrontPosition[1] - minimum flame front position</li>
    <li> m_maxFlameFrontPosition[1] - maximum flame front position</li>
    </ul>
    possible values are:
    <ul>
    <li>0 - off</li>
    <li>1 - on</li>
    </ul>
    Keywords: COMBUSTION, FLAME, FRONT, SURFACE, AREA, FILE, ASCII, OUTPUT
  */
    m_recordFlameFrontPosition =
        Context::getSolverProperty<MBool>("recordFlameFrontPosition", m_solverId, AT_, &tmpFalse);

    /*! \page propertiesFV
    \section structuredFlameOutput
    <code>MBool FvCartesianSolver::m_structuredFlameOutput </code>\n
    default = <code>0</code>\n \n
    controls the structured output of a 2D flame geometry
    possible values are:
    <ul>
    <li>0 - off</li>
    <li>1 - on</li>
    </ul>
    Keywords: COMBUSTION, FLAME, STRUCTURED, OUTPUT
  */
    m_structuredFlameOutput = Context::getSolverProperty<MBool>("structuredFlameOutput", m_solverId, AT_, &tmpFalse);

    /*! \page propertiesFV
    \section structuredFlameOutputLevel
    <code>MInt FvCartesianSolver::m_structuredFlameOutputLevel </code>\n
    default = <code>0</code>\n \n
    controls the structured output of a 2D flame geometry
    possible values are:
    <ul>
    <li>1 - single bunsen flame: output of flame tube + outlet (output only within flame tube radius)  </li>
    <li>2 - single bunsen flame: output of flame tube + outlet (output only within flame tube radius) (optimized
    version) </li> <li>3 - single bunsen flame with plenum: output of flame tube + outlet (output only within flame tube
    radius) (optimized version)</li> <li>4 - single bunsen flame with plenum: full domain output (with plenum)
    (optimized version), could be used probably for all 2D geometries, but not tested </li> <li>any other value ->
    default: output on finest level</li>
    </ul>
    Keywords: COMBUSTION, FLAME, STRUCTURED, OUTPUT, LEVEL
  */
    m_structuredFlameOutputLevel = 0;
    m_structuredFlameOutputLevel =
        Context::getSolverProperty<MInt>("structuredFlameOutputLevel", m_solverId, AT_, &m_structuredFlameOutputLevel);

    /*! \page propertiesFV
      \section twoFlames
      <code>MBool FvCartesianSolver::m_twoFlames </code>\n
      default = <code>0</code>\n \n
      trigger for computation of two bunsen flames. Only meaningful if the initial condition 17516 \ref initialCondition
      is used. \n possible values are: <ul> <li>0 - off</li> <li>1 - on</li>
      </ul>
      Keywords: COMBUSTION, TWO, FLAMES
  */
    m_twoFlames = Context::getSolverProperty<MBool>("twoFlames", m_solverId, AT_, &tmpFalse);

    m_dampingDistanceFlameBaseExtVel = 0.05;
    /*! \page propertiesFV
      \section dampingDistanceFlameBaseExtVel
      <code>MFloat FvCartesianSolver::m_dampingDistanceFlameBase </code>\n
      default = <code>0.259</code>\n \n
      damps out the heat release at the flame base. Only meaningful if the initial condition 17516 \ref initialCondition
      is used. \n possible values are: <ul> <li> Non-negative floating point values of the order of 4.0 </li>
      </ul>
      Keywords: COMBUSTION, FLAME, BASE, DAMPING, DISTANCE, EXTENSION, VELOCITY
  */
    m_dampingDistanceFlameBaseExtVel = Context::getSolverProperty<MFloat>("dampingDistanceFlameBaseExtVel", m_solverId,
                                                                          AT_, &m_dampingDistanceFlameBaseExtVel);


    m_dampingDistanceFlameBase = 0.259;
    /*! \page propertiesFV
      \section dampingDistanceFlameBase
      <code>MFloat FvCartesianSolver::m_dampingDistanceFlameBase </code>\n
      default = <code>0.259</code>\n \n
      damps out the heat release at the flame base. Only meaningful if the initial condition 17516 \ref initialCondition
      is used. \n possible values are: <ul> <li> Non-negative floating point values of the order of 4.0 </li>
      </ul>
      Keywords: COMBUSTION, FLAME, BASE, DAMPING, DISTANCE
  */
    m_dampingDistanceFlameBase =
        Context::getSolverProperty<MFloat>("dampingDistanceFlameBase", m_solverId, AT_, &m_dampingDistanceFlameBase);

    m_initialFlameHeight = F1;
    /*! \page propertiesFV
      \section initialFlameHeight
      <code>MFloat FvCartesianSolver::m_initialFlameHeight </code>\n
      default = <code>1.0</code>\n \n
      initial flame height. Used for initial conditions \ref initialCondition:
      <ul>
      <li> 1751600 </li>
      </ul>
      possible values are:
      <ul>
      <li> Non-negative floating point values of the order of 4.0 </li>
      </ul>
      Keywords: COMBUSTION, FLAME, TUBE, HEIGHT
  */
    m_initialFlameHeight =
        Context::getSolverProperty<MFloat>("initialFlameHeight", m_solverId, AT_, &m_initialFlameHeight);

    m_radiusFlameTube = 0.5;
    /*! \page propertiesFV
      \section radiusFlameTube
      <code>MFloat FvCartesianSolver::m_radiusFlameTube </code>\n
      default = <code>0.5</code>\n \n
      flame tube radius of a bunsen flame or used as radius for first flame of a multiple flame configuration. Used for
      initial conditions \ref initialCondition: <ul> <li> 17513 (single bunsen flame), </li> <li> 17514 (original
      version of flame with plenum), </li> <li> 17515 (test version flame with plenum),  </li> <li> 17516 (main current
      version of flame with plenum or two flames with plenum), </li> <li> 17517 (test version of a symmetric flame).
      </li>
      </ul>
      possible values are:
      <ul>
      <li> Non-negative floating point values of the order of 4.0 </li>
      </ul>
      Keywords: COMBUSTION, FLAME, TUBE, RADIUS
  */
    m_radiusFlameTube = Context::getSolverProperty<MFloat>("radiusFlameTube", m_solverId, AT_, &m_radiusFlameTube);

    /*! \page propertiesFV
      \section radiusVelFlameTube
      <code>MFloat FvCartesianSolver::m_radiusVelFlameTube </code>\n
      default = <code>0.5</code>\n \n
      flame tube radius of a bunsen flame used as radius for velocity profile. \n
      possible values are:
      <ul>
      <li> Non-negative floating point values of the order of 4.0 </li>
      </ul>
      Keywords: COMBUSTION, FLAME, TUBE, RADIUS
  */
    m_radiusVelFlameTube =
        Context::getSolverProperty<MFloat>("radiusVelFlameTube", m_solverId, AT_, &m_radiusFlameTube);

    /*! \page propertiesFV
      \section radiusOutlet
      <code>MFloat FvCartesianSolver::m_radiusOutlet </code>\n
      default = <code>0.5</code>\n \n
      flame tube radius of a bunsen flame used as radius for velocity profile. \n
      possible values are:
      <ul>
      <li> Non-negative floating point values of the order of 4.0 </li>
      </ul>
      Keywords: COMBUSTION, FLAME, TUBE, RADIUS
  */
    m_radiusOutlet = Context::getSolverProperty<MFloat>("radiusOutlet", m_solverId, AT_, &m_radiusFlameTube);

    m_realRadiusFlameTube = m_radiusFlameTube;
    /*! \page propertiesFV
      \section realRadiusFlameTube
      <code>MFloat FvCartesianSolver::m_realRadiusFlameTube </code>\n
      default = <code>\ref radiusFlameTube</code>\n \n
      flame tube radius of a bunsen flame or used as radius for first flame of a multiple flame configuration. Used for
      initial conditions \ref initialCondition: possible values are: <ul> <li> Non-negative floating point values of the
      order of \ref radiusFlameTube </li>
      </ul>
      Keywords: COMBUSTION, FLAME, TUBE, REAL, RADIUS
  */
    m_realRadiusFlameTube =
        Context::getSolverProperty<MFloat>("realRadiusFlameTube", m_solverId, AT_, &m_realRadiusFlameTube);

    /*! \page propertiesFV
      \section radiusFlameTube2
      <code>MFloat FvCartesianSolver::m_radiusFlameTube2 </code>\n
      default = <code>m_radiusFlameTube</code>\n \n
      flame tube radius of a second flame for a multiple flame configuration. Used for initial condition \ref
      initialCondition: <ul> <li> 17516 (main current version of flame with plenum or two flames with plenum), </li>
      </ul>
      possible values are:
      <ul>
      <li> Non-negative floating point values of the order of 4.0 </li>
      </ul>
      Keywords: COMBUSTION, MULTIPLE, FLAMES, TUBE, RADIUS
  */
    m_radiusFlameTube2 = Context::getSolverProperty<MFloat>("radiusFlameTube2", m_solverId, AT_, &m_radiusFlameTube);


    m_radiusInjector = F2;
    /*! \page propertiesFV
      \section radiusInjector
      <code>MFloat FvCartesianSolver::m_radiusInjector </code>\n
      default = <code>2.0</code>\n \n
      injector radius (SFB686 Bielefeld burner). \n
      possible values are:
      <ul>
      <li> Non-negative floating point values of the order of 2.0 </li>
      </ul>
      Keywords: COMBUSTION, INJECTOR, RADIUS
  */
    m_radiusInjector = Context::getSolverProperty<MFloat>("radiusInjector", m_solverId, AT_, &m_radiusInjector);

    m_yOffsetInjector = -12.48535161836571205000;
    /*! \page propertiesFV
      \section yOffsetInjector
      <code>MFloat FvCartesianSolver::m_yOffsetInjector </code>\n
      default = <code>2.0</code>\n \n
      injector radius (SFB686 Bielefeld burner). \n
      possible values are:
      <ul>
      <li> Non-negative floating point values of the order of 2.0 </li>
      </ul>
      Keywords: COMBUSTION, INJECTOR, RADIUS
  */
    m_yOffsetInjector = Context::getSolverProperty<MFloat>("yOffsetInjector", m_solverId, AT_, &m_yOffsetInjector);

    m_yOffsetFlameTube = 0.04;
    /*! \page propertiesFV
      \section yOffsetFlameTube
      <code>MFloat FvCartesianSolver::m_yOffsetFlameTube </code>\n
      default = <code>0.04</code>\n \n
      flame tube offset of a bunsen flame in y - direction. Used for initial conditions \ref initialCondition:
      <ul>
      <li> 17513 (single bunsen flame), </li>
      <li> 17514 (original version of flame with plenum), </li>
      <li> 17515 (test version flame with plenum),  </li>
      <li> 17516 (main current version of flame with plenum or two flames with plenum), </li>
      <li> 17517 (test version of a symmetric flame). </li>
      </ul>
      possible values are:
      <ul>
      <li> Non-negative floating point values of the order of 4.0 </li>
      </ul>
      Keywords: COMBUSTION, FLAME, TUBE, OFFSET
  */
    m_yOffsetFlameTube = Context::getSolverProperty<MFloat>("yOffsetFlameTube", m_solverId, AT_, &m_yOffsetFlameTube);

    /*! \page propertiesFV
      \section yOffsetFlameTube2
      <code>MFloat FvCartesianSolver::m_yOffsetFlameTube2 </code>\n
      default = <code>m_yOffsetFlameTube</code>\n \n
      flame tube offset of a second flame in y - direction. Used for initial condition \ref initialCondition:
      <ul>
      <li> 17516 (main current version of flame with plenum or two flames with plenum), </li>
      </ul>
      possible values are:
      <ul>
      <li> Non-negative floating point values of the order of 4.0 </li>
      </ul>
      Keywords: COMBUSTION, SECOND, FLAME, TUBE, OFFSET
  */
    m_yOffsetFlameTube2 = Context::getSolverProperty<MFloat>("yOffsetFlameTube2", m_solverId, AT_, &m_yOffsetFlameTube);

    m_xOffsetFlameTube = 0.0;
    /*! \page propertiesFV
      \section xOffsetFlameTube
      <code>MFloat FvCartesianSolver::m_xOffsetFlameTube </code>\n
      default = <code>0.0</code>\n \n
      flame tube offset of a flame in x - direction. Used for initial condition \ref initialCondition:
      <ul>
      <li> 17513 (single bunsen flame), </li>
      <li> 17514 (original version of flame with plenum), </li>
      <li> 17515 (test version flame with plenum),  </li>
      <li> 17516 (main current version of flame with plenum or two flames with plenum), </li>
      <li> 17517 (test version of a symmetric flame). </li>
      </ul>
      meaningful values are:
      <ul>
      <li> Non-negative floating point values if a non-symmetrical or a multiple flame configuration is used </li>
      </ul>
      Keywords: COMBUSTION, SECOND, FLAME, TUBE, OFFSET
  */
    m_xOffsetFlameTube = Context::getSolverProperty<MFloat>("xOffsetFlameTube", m_solverId, AT_, &m_xOffsetFlameTube);

    m_xOffsetFlameTube2 = -m_xOffsetFlameTube;
    /*! \page propertiesFV
      \section xOffsetFlameTube2
      <code>MFloat FvCartesianSolver::m_xOffsetFlameTube2 </code>\n
      default = <code>-m_xOffsetFlameTube</code>\n \n
      flame tube offset of a second flame in x - direction. Used for initial condition \ref initialCondition:
      <ul>
      <li> 17513 (single bunsen flame), </li>
      <li> 17514 (original version of flame with plenum), </li>
      <li> 17515 (test version flame with plenum),  </li>
      <li> 17516 (main current version of flame with plenum or two flames with plenum), </li>
      <li> 17517 (test version of a symmetric flame). </li>
      </ul>
      meaningful values are:
      <ul>
      <li> Non-negative floating point values if a non-symmetrical or a multiple flame configuration is used </li>
      </ul>
      Keywords: COMBUSTION, SECOND, FLAME, TUBE, OFFSET
  */
    m_xOffsetFlameTube2 = Context::getSolverProperty<MFloat>("xOffsetFlameTube2", m_solverId, AT_, &m_xOffsetFlameTube);

    m_tubeLength = 0;
    /*! \page propertiesFV
      \section tubeLength
      <code>MFloat FvCartesianSolver::m_tubeLength </code>\n
      default = <code>-m_xOffsetFlameTube</code>\n \n
      flame tube offset of a second flame in x - direction. Used for initial condition \ref initialCondition:
      <ul>
      <li> 17513 (single bunsen flame), </li>
      <li> 17514 (original version of flame with plenum), </li>
      <li> 17515 (test version flame with plenum),  </li>
      <li> 17516 (main current version of flame with plenum or two flames with plenum), </li>
      <li> 17517 (test version of a symmetric flame). </li>
      </ul>
      meaningful values are:
      <ul>
      <li> Non-negative floating point values if a non-symmetrical or a multiple flame configuration is used </li>
      </ul>
      Keywords: COMBUSTION, SECOND, FLAME, TUBE, OFFSET
  */
    m_tubeLength = Context::getSolverProperty<MFloat>("tubeLength", m_solverId, AT_, &m_tubeLength);

    m_outletLength = 0;
    /*! \page propertiesFV
      \section outletLength
      <code>MFloat FvCartesianSolver::m_outletLength </code>\n
      default = <code>-m_xOffsetFlameTube</code>\n \n
      flame tube offset of a second flame in x - direction. Used for initial condition \ref initialCondition:
      <ul>
      <li> 17513 (single bunsen flame), </li>
      <li> 17514 (original version of flame with plenum), </li>
      <li> 17515 (test version flame with plenum),  </li>
      <li> 17516 (main current version of flame with plenum or two flames with plenum), </li>
      <li> 17517 (test version of a symmetric flame). </li>
      </ul>
      meaningful values are:
      <ul>
      <li> Non-negative floating point values if a non-symmetrical or a multiple flame configuration is used </li>
      </ul>
      Keywords: COMBUSTION, SECOND, FLAME, TUBE, OFFSET
  */
    m_outletLength = Context::getSolverProperty<MFloat>("outletLength", m_solverId, AT_, &m_outletLength);

    m_laminarFlameThickness = c_cellLengthAtLevel(maxRefinementLevel());
    /*! \page propertiesFV
      \section laminarFlameThickness
      <code>MFloat FvCartesianSolver::m_laminarFlameThickness </code>\n
      default = <code>smallest cell distance</code>\n \n
      controls the flame thickness which should be caluclated via \f$ l_{f} = D_{flame}/(Re_{flame} * Pr * s_{l,0} )
      \f$. <ul> <li> \f$ D_{flame} \f$ diffusivity which equals the averaged viscosity in the flame tube,</li> <li> \f$
      Re_{flame} \f$ is the Reynolds number calculated with the averaged values of the flame tube \ref Re,</li> <li> \f$
      Pr \f$ Prandtl number \ref Pr.</li> <li> \f$ s_{l,0} \f$ is the constant flame speed of an uncurved flat flame
      \ref flameSpeed,</li>
      </ul>
      possible values are:
      <ul>
      <li> Non-negative floating point values.  </li>
      </ul>
      Keywords: COMBUSTION, LAMINAR, FLAME, THICKNESS
  */
    m_laminarFlameThickness =
        Context::getSolverProperty<MFloat>("laminarFlameThickness", m_solverId, AT_, &m_laminarFlameThickness);

    m_subfilterVariance = F1; ///< for filtering of the laminar flame thickness
    /*! \page propertiesFV
      \section subfilterVariance
      <code>MFloat FvCartesianSolver::m_subfilterVariance </code>\n
      default = <code>1.0</code>\n \n
      the subfilter variance \f$ /sigma \f$ controls the Gaussian sub-filter distribution within the flame model, see
      thesis D.Hartmann: "A level-Set Based Method for Premixed Combustion in Compressible Flow", p.17. \n In the
      corrguted Flamelet regime \f$ l_{f} < l_{Kolm}\f$ there are two different model cases, see V.Moureau (2009) "A
      level set formulation for premixed combustion les considering the turbulent flame structure": \n Case 1 -
      \f$\sigma < l_{f}\f$: <ul> <li> flame is resolved -> filtered flame thickness \f$ l_{F,f}\f$ = laminar flame
      thickness \f$ l_{f}\f$, \ref laminarFlameThickness;</li> <li> there is no turbulent contribution;</li> <li> Info:
      filtered flame speed \f$ s_{F} = s_{l} \f$ laminar flame speed;</li> <li> Info: Dth_{turb,F} (subfilter eddy
      diffusivity) = Dth_{lam} (laminar diffusivity);</li>
      </ul>

      Case 2 -  \f$ \sigma > l_{f}\f$:
      <ul>
      <li> sub-filter flame front wrinkling increases the resolved burning velocity;</li>
      <li> filtered flame speed s_F > s_l (laminar flame speed);</li>
      <li> Info: if the flame front is not altered by
           turbulence the chemical time scale of the turbulent flame \f$time_{c_{F}} \f$ remains
           the same as the laminar one \f$ time_{c} \f$ </li></ul>
      possible values are:
      <ul>
      <li> Non-negative floating point values </li>
      </ul>
      Keywords: COMBUSTION, FLAMELET, REGIME, SUBFILTER, VARIANCE, FLAME, THICKNESS
  */
    m_subfilterVariance =
        Context::getSolverProperty<MFloat>("subfilterVariance", m_solverId, AT_, &m_subfilterVariance);

    m_c0 = 0.5;
    /*! \page propertiesFV
      \section c0
      <code>MFloat FvCartesianSolver::m_c0 </code>\n
      default = <code>0.5</code>\n \n
      c0 is a contour of the progress variable \f$ c = [0,1] \f$ which could be interpreted as the flame surface
      contour. /n possible values are: <ul> <li> Non-negative floating point values in the range of the progress
      variable \f$ c = [0,1] \f$ .  </li>
      </ul>
      Keywords: COMBUSTION, FLAME, PROGRESS, VARIABLE, SURFACE, CONTOUR
  */
    m_c0 = Context::getSolverProperty<MFloat>("c0", m_solverId, AT_, &m_c0);

    if(m_restart) {
      m_rhoUnburnt = -99999.0;
      /*! \page propertiesFV
      \section rhoUnburnt
      <code>MFloat FvCartesianSolver::m_rhoUnburnt </code>\n
      default = <code>1</code>\n \n
      Controls the unbunrt density for the DL instability for restart simulations. Has to be set otherwise the restart
      will produce wrong solutions. /n possible values are: <ul> <li> Non-negative floating point values of the order
      of 1. See the HeatChange file of your simulation for setting the last computed rhoUnburnt. </li>
      </ul>
      Keywords: COMBUSTION, DENSITY, UNBURNT
    */
      m_rhoUnburnt = Context::getSolverProperty<MFloat>("rhoUnburnt", m_solverId, AT_, &m_rhoUnburnt);
      if(approx(m_rhoUnburnt, -99999.0, MFloatEps)
         && (m_initialCondition == 1990 || m_initialCondition == 19901 || m_initialCondition == 1991
             || m_initialCondition == 19911)) {
        cerr << " rho unburnt should be set in your property file, as well TbTu and marksteinLength, see file "
                "HeatChange and MarksteinNeutral files !!!"
             << endl;
        mTerm(1, AT_, "Error for rhoUnburnt property");
      }
    }

    m_burntUnburntTemperatureRatio = F1;
    /*! \page propertiesFV
      \section burntUnburntTemperatureRatio
      <code>MFloat FvCartesianSolver::m_burntUnburntTemperatureRatio </code>\n
      default = <code>1</code>\n \n
      Controls the ratio between the burnt and unburnt gas temperature \f$ \frac{T_{burnt}}{T_{unburnt}} \f$. /n
      possible values are:
      <ul>
      <li> Non-negative floating point values of the order of 1..6.  </li>
      </ul>
      Keywords: COMBUSTION, TEMPERATURE, BURNT, UNBURNT, RATIO
  */
    m_burntUnburntTemperatureRatio = Context::getSolverProperty<MFloat>("burntUnburntTemperatureRatio", m_solverId, AT_,
                                                                        &m_burntUnburntTemperatureRatio);

    m_temperatureChange = 0;
    /*! \page propertiesFV
      \section temperatureChange
      <code>MInt FvCartesianSolver::m_temperatureChange </code>\n
      default = <code>0</code>\n \n
      Controls whether temperature adaption should be activated. /n
      possible values are:
      <ul>
      <li> 0 - off </li>
      <li> 1 - on </li>
      </ul>
      Keywords: COMBUSTION, TEMPERATURE, BURNT, UNBURNT, RATIO
  */
    m_temperatureChange = Context::getSolverProperty<MInt>("temperatureChange", m_solverId, AT_, &m_temperatureChange);

    if(m_temperatureChange != 0) {
      /*! \page propertiesFV
      \section burntUnburntTemperatureRatioStart
      <code>MFloat FvCartesianSolver::m_burntUnburntTemperatureRatioStart </code>\n
      default = <code>1</code>\n \n
      Controls the ratio between the burnt and unburnt gas temperature \f$ \frac{T_{burnt}}{T_{unburnt}} \f$. /n
      possible values are:
      <ul>
      <li> Non-negative floating point values of the order of 1..6.  </li>
      </ul>
      Keywords: COMBUSTION, TEMPERATURE, BURNT, UNBURNT, RATIO
    */
      m_burntUnburntTemperatureRatioStart =
          Context::getSolverProperty<MFloat>("burntUnburntTemperatureRatioStart", m_solverId, AT_);

      m_burntUnburntTemperatureRatioEnd = m_burntUnburntTemperatureRatio;
      /*! \page propertiesFV
      \section burntUnburntTemperatureRatioEnd
      <code>MFloat FvCartesianSolver::m_burntUnburntTemperatureRatioEnd </code>\n
      default = <code>1</code>\n \n
      Controls the ratio between the burnt and unburnt gas temperature \f$ \frac{T_{burnt}}{T_{unburnt}} \f$. /n
      possible values are:
      <ul>
      <li> Non-negative floating point values of the order of 1..6.  </li>
      </ul>
      Keywords: COMBUSTION, TEMPERATURE, BURNT, UNBURNT, RATIO
    */
      m_burntUnburntTemperatureRatioEnd = Context::getSolverProperty<MFloat>(
          "burntUnburntTemperatureRatioEnd", m_solverId, AT_, &m_burntUnburntTemperatureRatioEnd);
    }

    m_targetDensityFactor = F1 / m_burntUnburntTemperatureRatio;
    /*! \page propertiesFV
    \section targetDensityFactor
    <code>MFloat FvCartesianSolver::m_targetDensityFactor </code>\n
    default = <code>1/m_burntUnburntTemperatureRatio</code>\n \n
    The property controls the Intensity of the sponge layer correction regarding the density forcing term for some
    values of the spongeLayerType. The sponge forcing term added to the rhs of a cell inside the sponge layer is given
    by \n \f$ \Delta L(\phi) = V \sigma \frac{\Delta x_{sp}^2}{L_s^2} \Delta \phi  \f$,  \n where \f$ V \f$ is the cell
    volume, \f$  \sigma  \f$ is the forcing amplitude, \f$  x_{sp} \f$ is the inner sponge layer boundary, \f$  L_{sp}
    \f$ is the sponge layer thickness and \f$  \Delta \phi = \phi - \phi_{target}  \f$ is the difference between the
    local and the freesteam values of \f$  \phi  \f$.\n The targetDensityFactor should be chosen to the inverse of the
    burnt unburnt temperature ratio for a combustion simulation. \n The density target value is in these cases given as:
    \n <code> deltaRho =a_pvariable( cellId ,  PV->RHO ) - m_rhoInfinity * m_targetDensityFactor;</code>\n See
    also spongeLayerType. Only meaningful and required with certain values for \ref spongeLayerType and if both \ref
    spongeLayerThickness and \ref sigmaSponge are specified and nonzero! ! \n \n possible values are: <ul>
    <li>1/m_burntUnburntTemperatureRatio</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, SPONGE</i>
  */
    m_targetDensityFactor =
        Context::getSolverProperty<MFloat>("targetDensityFactor", m_solverId, AT_, &m_targetDensityFactor);
    if(!approx(m_targetDensityFactor, (F1 / m_burntUnburntTemperatureRatio), MFloatEps)) {
      cerr << "Warning: target density factor is not equal to the inverse of the burnt unburnt temperature ratio!!!"
           << endl;
      cerr << "targetDensityFactor = " << m_targetDensityFactor << endl;
      cerr << "-> change the targetDensityFactor to " << F1 / m_burntUnburntTemperatureRatio << endl;
    }

    m_deltaXtemperatureProfile = 0.00;
    /*! \page propertiesFV
      \section deltaXtemperatureProfile
      <code>MFloat FvCartesianSolver::m_deltaXtemperatureProfile </code>\n
      default = <code>0.02</code>\n \n
      Controls the temperature profile of the isothermal boundary conditions 4905 (bcNeumannIsothermalBurntProfile). In
      between this distance the temperature is rising from the unburnt temperature at the tube edges, see \ref
      radiusFlameTube, up to the burnt temperature controlled by the \ref burntUnburntTemperatureRatio /n possible
      values are: <ul> <li> Non-negative floating point values of the order of 0.01 -0.1.  </li>
      </ul>
      Keywords: COMBUSTION, TEMPERATURE, BURNT, UNBURNT, PROFILE, THERMAL, BOUNDARY, CONDITION
  */
    m_deltaXtemperatureProfile =
        Context::getSolverProperty<MFloat>("deltaXtemperatureProfile", m_solverId, AT_, &m_deltaXtemperatureProfile);

    m_deltaYtemperatureProfile = 0.01;
    /*! \page propertiesFV
      \section deltaYtemperatureProfile
      <code>MFloat FvCartesianSolver::m_deltaYtemperatureProfile </code>\n
      default = <code>0.01</code>\n \n
      Controls the temperature profile of the isothermal boundary conditions 3909 (bcNeumannIsothermalUnburntProfile).
      In between this distance the temperature is rising from the unburnt temperature in the inflow tube up to the burnt
      temperature controlled by the \ref burntUnburntTemperatureRatio /n possible values are: <ul> <li> Non-negative
      floating point values of the order of 0.01 -0.1.  </li>
      </ul>
      Keywords: COMBUSTION, TEMPERATURE, BURNT, UNBURNT, PROFILE, THERMAL, BOUNDARY, CONDITION
  */
    m_deltaYtemperatureProfile =
        Context::getSolverProperty<MFloat>("deltaYtemperatureProfile", m_solverId, AT_, &m_deltaYtemperatureProfile);

    m_thermalProfileStartFactor = F1;
    /*! \page propertiesFV
      \section thermalProfileStartFactor
      <code>MFloat FvCartesianSolver::m_thermalProfileStartFactor </code>\n
      default = <code>1.0</code>\n \n
      Controls the temperature profile starting point of the isothermal boundary conditions 4905
      (bcNeumannIsothermalBurntProfile). /n possible values are: <ul> <li> Non-negative floating point values of the
      order of 1.  </li>
      </ul>
      Keywords: COMBUSTION, TEMPERATURE, BURNT, UNBURNT, PROFILE, THERMAL, BOUNDARY, CONDITION
  */
    m_thermalProfileStartFactor =
        Context::getSolverProperty<MFloat>("thermalProfileStartFactor", m_solverId, AT_, &m_thermalProfileStartFactor);

    m_flameRadiusOffset = F0;
    /*! \page propertiesFV
      \section flameRadiusOffset
      <code>MFloat FvCartesianSolver::m_flameRadiusOffset </code>\n
      default = <code>0.0</code>\n \n
      Controls the temperature profile of the isothermal boundary conditions 4905 (bcNeumannIsothermalBurntProfile). In
      between this distance the temperature is rising from the unburnt temperature at the tube edges, see \ref
      radiusFlameTube, up to the burnt temperature controlled by the \ref burntUnburntTemperatureRatio /n possible
      values are: <ul> <li> Non-negative floating point values of the order of 0.01 -0.1.  </li>
      </ul>
      Keywords: COMBUSTION, TEMPERATURE, BURNT, UNBURNT, PROFILE, THERMAL, BOUNDARY, CONDITION
  */
    m_flameRadiusOffset =
        Context::getSolverProperty<MFloat>("flameRadiusOffset", m_solverId, AT_, &m_flameRadiusOffset);

    m_shearLayerStrength = 50.0;
    /*! \page propertiesFV
      \section shearLayerStrength
      <code>MFloat FvCartesianSolver::m_shearLayerStrength </code>\n
      default = <code>50.0</code>\n \n
      Controls the boundary layer thickness of the velocity  top hat profile of a bunsen flame with the cut off boundary
      condition 17515 and the corresponding sponge layer type 17515, \ref spongeLayerType /n possible values are: <ul>
      <li> Non-negative floating point values of the order of 10.0 - 100.0.  </li>
      </ul>
      Keywords: COMBUSTION, VELOCITY, TOP, HAT, PROFILE, STRENGTH
  */
    m_shearLayerStrength =
        Context::getSolverProperty<MFloat>("shearLayerStrength", m_solverId, AT_, &m_shearLayerStrength);

    m_inflowTemperatureRatio = F1;
    /*! \page propertiesFV
      \section inflowTemperatureRatio
      <code>MFloat FvCartesianSolver::m_inflowTemperatureRatio </code>\n
      default = <code>1</code>\n \n
      Controls the inflow temperature ratio. /n
      possible values are:
      <ul>
      <li> Non-negative floating point value of the order of 1..6.  </li>
      </ul>
      Keywords: COMBUSTION, TEMPERATURE, BURNT, UNBURNT, RATIO
  */
    m_inflowTemperatureRatio =
        Context::getSolverProperty<MFloat>("inflowTemperatureRatio", m_solverId, AT_, &m_inflowTemperatureRatio);

    m_lambdaPerturbation = F1;
    /*! \page propertiesFV
      \section lambdaPerturbation
      <code>MFloat FvCartesianSolver::m_lambdaPerturbation </code>\n
      default = <code>1</code>\n \n
      Controls ?? /n
      possible values are:
      <ul>
      <li> Non-negative floating point value of the order of 1..6.  </li>
      </ul>
      Keywords: COMBUSTION, TEMPERATURE, BURNT, UNBURNT, RATIO
  */
    m_lambdaPerturbation =
        Context::getSolverProperty<MFloat>("lambdaPerturbation", m_solverId, AT_, &m_lambdaPerturbation);

    m_perturbationAmplitude = 0.001;
    /*! \page propertiesFV
      \section perturbationAmplitude
      <code>MFloat FvCartesianSolver::m_perturbationAmplitude </code>\n
      default = <code>0.001</code>\n \n
      Perturbation amplitude of a flame surface. /n
      possible values are:
      <ul>
      <li> Non-negative floating point value.  </li>
      </ul>
      Keywords: COMBUSTION, TEMPERATURE, BURNT, UNBURNT, RATIO
  */
    m_perturbationAmplitude =
        Context::getSolverProperty<MFloat>("perturbationAmplitude", m_solverId, AT_, &m_perturbationAmplitude);

    m_perturbationAmplitudeCorr = m_perturbationAmplitude;
    /*! \page propertiesFV
      \section perturbationAmplitudeCorr
      <code>MFloat FvCartesianSolver::m_perturbationAmplitudeCorr </code>\n
      default = <code>0.001</code>\n \n
      Code calculated perturbation amplitude of a flame surface. Used for exact growth rate computations. /n
      possible values are:
      <ul>
      <li> Non-negative floating point value.  </li>
      </ul>
      Keywords: COMBUSTION, TEMPERATURE, BURNT, UNBURNT, RATIO
  */
    m_perturbationAmplitudeCorr =
        Context::getSolverProperty<MFloat>("perturbationAmplitudeCorr", m_solverId, AT_, &m_perturbationAmplitudeCorr);

    /*! \page propertiesFV
      \section divergenceTreatment
      <code>MBool FvCartesianSolver::m_divergenceTreatment </code>\n
      default = <code>false</code>\n \n
      Sets the divergency to zero in the flame tube area, needed if there is a defined velocity profile /n
      possible values are:
      <ul>
      <li> true - on  </li>
      <li> false - off </li>
      </ul>
      Keywords: COMBUSTION, DIVERGENCE, TREATMENT, VELOCITY, PROFILE
  */
    m_divergenceTreatment = Context::getSolverProperty<MBool>("divergenceTreatment", m_solverId, AT_, &tmpFalse);

    /*! \page propertiesFV
      \section acousticAnalysis
      <code>MBool FvCartesianSolver::m_acousticAnalysis </code>\n
      default = <code>false</code>\n \n
      Sets the acoustic analysis /n
      possible values are:
      <ul>
      <li> true - on  </li>
      <li> false - off </li>
      </ul>
      Keywords: COMBUSTION, ACOUSTIC, ANALYSIS
  */
    m_acousticAnalysis = Context::getSolverProperty<MBool>("acousticAnalysis", m_solverId, AT_, &m_acousticAnalysis);

    m_ScT = 0.4; //  Pitsch et al. 2005 (ScT=0.4) and 2000 (ScT=0.5) -> a constant value can be used
    /*! \page propertiesFV
      \section ScT
      <code>MFloat FvCartesianSolver::m_ScT </code>\n
      default = <code>0.4</code>\n \n
      Turbulent Schmidt number. /n
      possible values are:
      <ul>
      <li> Non-negative floating point value.  </li>
      </ul>
      Keywords: COMBUSTION, SCHMIDT, NUMBER, TURBULENT
  */
    m_ScT = Context::getSolverProperty<MFloat>("ScT", m_solverId, AT_, &m_ScT);

    m_NuT = 0.0017169; // computed by cold slot jet with grid refinement r11 at y=-0.5
    /*! \page propertiesFV
      \section NuT
      <code>MFloat FvCartesianSolver::m_NuT </code>\n
      default = <code>0.0017169</code>\n \n
      Turbulent viscosity. /n
      possible values are:
      <ul>
      <li> Non-negative floating point value.  </li>
      </ul>
      Keywords: COMBUSTION, TURBULENT, VISCOSITY
  */
    m_NuT = Context::getSolverProperty<MFloat>("NuT", m_solverId, AT_, &m_NuT);

    m_integralAmplitude = 0.015188;
    /*! \page propertiesFV
      \section integralAmplitude
      <code>MFloat FvCartesianSolver::m_integralAmplitude </code>\n
      default = <code>0.0155</code>\n \n
      Integral amplitude evaluated at integral length scale. /n
      possible values are:
      <ul>
      <li> Non-negative floating point value.  </li>
      </ul>
      Keywords: COMBUSTION, INTEGRAL, AMPLITUDE
  */
    m_integralAmplitude =
        Context::getSolverProperty<MFloat>("integralAmplitude", m_solverId, AT_, &m_integralAmplitude);

    m_integralLengthScale = 0.3;
    /*! \page propertiesFV
      \section integralLengthScale
      <code>MFloat FvCartesianSolver::m_integralLengthScale </code>\n
      default = <code>0.3</code>\n \n
      Integral length scale. /n
      possible values are:
      <ul>
      <li> Non-negative floating point value.  </li>
      </ul>
      Keywords: COMBUSTION, INTEGRAL, LENGTH, SCALE
  */
    m_integralLengthScale =
        Context::getSolverProperty<MFloat>("integralLengthScale", m_solverId, AT_, &m_integralLengthScale);
  }
}


//------------------------------------------------------------------------------------------------------------------------------------------

/**
 * \fn void FvCartesianSolverXD::setAndAllocateJetProperties()
 * \brief reads in the jet properties
 *
 * \authors Onur Cetin, Stephan Schlimpert
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setAndAllocateJetProperties() {
  TRACE();

  /*! \page propertiesFV
    \section jet
    <code>MBool FvCartesianSolverXD<nDim_,SysEqn>::m_jet </code>\n
    default = <code>false</code>\n
    Sets the problem to be a "jet" problem.\n
    Possible values are:
    <ul>
    <li> false: no jet</li>
    <li> true: jet</li>
    </ul>
    Keywords: <i>FINITE VOLUME, JET</i>
  */
  m_jet = false;
  m_jet = Context::getSolverProperty<MBool>("jet", m_solverId, AT_, &m_jet);

  /*! \page propertiesFV
    \section chevron
    <code>MBool FvCartesianSolver::m_chevron</code>\n
    default = <code>false</code>\n \n
    Enables some specifications for jet physics with chevron nozzles.\n
    Keywords: <i>FINITE_VOLUME, JET, NOZZLE</i>
  */
  m_chevron = false;
  m_chevron = Context::getSolverProperty<MBool>("chevron", m_solverId, AT_, &m_chevron);

  if(m_chevron) {
    /*! \page propertiesFV
      \section machNozzleExit
      <code>MFloat FvCartesianSolver::m_maNozzleExit </code>\n
      default = <code>none</code>\n \n
      Desired Mach number of the jet at the exit of the nozzle (see chevron).\n
      <ul>
      <li>non negative floating number</li>
      </ul>\n
      Keywords: <i>FINITE_VOLUME, JET, NOZZLE</i>
    */
    m_maNozzleExit = -1.0;
    m_maNozzleExit = Context::getSolverProperty<MFloat>("machNozzleExit", m_solverId, AT_);

    /*! \page propertiesFV
      \section inletRadius
      <code>MFloat FvCartesianSolver::m_inletRadius </code>\n
      default = <code>none</code>\n \n
      Inlet radius of the nozzle (see chevron).\n
      <ul>
      <li>non negative floating number</li>
      </ul>\n
      Keywords: <i>FINITE_VOLUME, JET, NOZZLE</i>
    */
    m_inletRadius = -1.0;
    m_inletRadius = Context::getSolverProperty<MFloat>("inletRadius", m_solverId, AT_);

    /*! \page propertiesFV
      \section outletRadius
      <code>MFloat FvCartesianSolver::m_outletRadius </code>\n
      default = <code>none</code>\n \n
      Outlet radius of the nozzle (see chevron).\n
      <ul>
      <li>non negative floating number</li>
      </ul>\n
      Keywords: <i>FINITE_VOLUME, JET, NOZZLE</i>
    */
    m_outletRadius = -1.0;
    m_outletRadius = Context::getSolverProperty<MFloat>("outletRadius", m_solverId, AT_);

    /*! \page propertiesFV
      \section jetTemperature
      <code>MFloat FvCartesianSolver::m_normJetTemperature </code>\n
      default = <code>1.0</code>\n \n
      Normalized jet temperature at the nozzle exit.
      E.g. Xia et. al. 2009, Int.J.Heat&Fluid: m_normJetTemperature = T_jet/T_infinity = 0.84
      <ul>
      <li>non negative floating number</li>
      </ul>
      Keywords: <i>FINITE_VOLUME, JET, NOZZLE</i>
    */
    m_normJetTemperature = 1.0;
    m_normJetTemperature = Context::getSolverProperty<MFloat>("jetTemperature", m_solverId, AT_);

    // Note: also read below for m_jet
    m_momentumThickness = 0.05;
    m_momentumThickness =
        Context::getSolverProperty<MFloat>("momentumThickness", m_solverId, AT_, &m_momentumThickness);
  }

  if(m_jet) {
    /*! \page propertiesFV
      \section jetForcing
      <code>MBool FvCartesianSolverXD<nDim_,SysEqn>::m_jetForcing </code>\n
      default = <code>false</code>\n
      Jet forcing switch for a jet associated with property jet and boundary condition bc18516.\n
      Possible values are:
      <ul>
        <li>false: no forcing</li>
        <li>true: some random sinusoidal forcing</li>
      </ul>
      Keywords: <i>FINITE VOLUME, JET, FORCING</i>
    */
    m_jetForcing = false;
    m_jetForcing = Context::getSolverProperty<MBool>("jetForcing", m_solverId, AT_, &m_jetForcing);

    /*! \page propertiesFV
      \section shearLayerThickness
      <code>MFloat FvCartesianSolverXD<nDim_,SysEqn>::m_shearLayerThickness </code>\n
      default = <code>0</code>\n
      Shear layer thickness of a jet associated with property jet.\n
      Possible values are:
      <ul>
        <li>values > 0 and < O(lengthLevel0) </li>
      </ul>
      Keywords: <i>FINITE VOLUME, JET, SHEAR LAYER</i>
    */
    m_shearLayerThickness = F0;
    m_shearLayerThickness =
        Context::getSolverProperty<MFloat>("shearLayerThickness", m_solverId, AT_, &m_shearLayerThickness);

    /*! \page propertiesFV
     \section MaCoflow
     <code>MFloat FvCartesianSolverXD<nDim_,SysEqn>::m_MaCoflow </code>\n
     default = <code>0</code>\n
     Mach number of the co flow.\n
     Possible values are:
     <ul>
       <li>floating point values greater than 0.0 </li>
     </ul>
     Keywords: <i>FINITE VOLUME, JET, SHEAR LAYER</i>
   */
    m_MaCoflow = F0;
    m_MaCoflow = Context::getSolverProperty<MFloat>("MaCoflow", m_solverId, AT_, &m_MaCoflow);
    m_jetHalfWidth = 0.5;
    m_jetCoflowOffset = m_jetHalfWidth + 0.125;
    m_jetCoflowEndOffset = m_jetHalfWidth + 2.375;
    m_jetHalfLength = 4.165;
    m_jetHalfLength = Context::getSolverProperty<MFloat>("jetHalfLength", m_solverId, AT_, &m_jetHalfLength);
    m_primaryJetRadius = F1B4;
    m_secondaryJetRadius = F1B2;
    m_forceCoefficient = F0;
    m_densityRatio = F1;
    m_targetVelocityFactor = F1;
    m_modeNumbers = F0;
    m_momentumThickness = F0;
    m_jetType = 0;

    /*! \page propertiesFV
      \section jetHeight
      <code>MFloat FvCartesianSolverXD<nDim_,SysEqn>::m_jetHeight </code>\n
      default = <code>0.5</code>\n
      Radial extend of a jet associated with property jet. Used in bc19516 with reference to
      "Effects of Inflow Conditions and Forcing on Subsonic Jet Flows and Noise AIAA 2005" Bogey and Bailly.\n
      Also used for jet forcing in FvCartesianSolver3D::updateJet() for the jet forcing in case 19516.\n
      Possible values are:
      <ul>
        <li> values > 0 and < O(lengthLevel0) </li>
      </ul>
      Keywords: <i>FINITE VOLUME, JET, RADIAL EXTEND</i>
    */
    m_jetHeight = F1B2;
    m_jetHeight = Context::getSolverProperty<MFloat>("jetHeight", m_solverId, AT_, &m_jetHeight);

    /*! \page propertiesFV
       \section primaryJetRadius
       <code> MFloat FvCartesianSolver::m_primaryJetRadius </code>\n
       default = <code>0.25</code>\n \n
       Radius of core jet in a coaxial configuration. Therewith it is the inner radius of the outer jet.\n
       Possible values are:
       <ul>
       <li> 0 < primaryJetRadius < secondaryJetRadius </li>
       </ul>
       Keywords: <i>FINITE_VOLUME, VARIABLES, JET</i>
     */
    m_primaryJetRadius = Context::getSolverProperty<MFloat>("primaryJetRadius", m_solverId, AT_, &m_primaryJetRadius);
    /*! \page propertiesFV
       \section secondaryJetRadius
       <code>MFloat FvCartesianSolver::m_secondaryJetRadius </code>\n
       default = <code>0.5</code>\n \n
       Outer radius of outer jet in a coaxial configuration.\n
       Possible values are:
       <ul>
       <li>primaryJetRadius<secondaryJetRadius</li>
       </ul>
       Keywords: <i>FINITE_VOLUME, VARIABLES, JET</i>
     */
    m_secondaryJetRadius =
        Context::getSolverProperty<MFloat>("secondaryJetRadius", m_solverId, AT_, &m_secondaryJetRadius);
    /*! \page propertiesFV
       \section targetVelocityFactor
       <code>MFloat FvCartesianSolver::m_targetVelocityFactor </code>\n
       default = <code>0.5</code>\n \n
       no use. should be removed.\n
       Possible values are:
       <ul>
       <li>primaryJetRadius<secondaryJetRadius</li>
       </ul>
       Keywords: <i>FINITE_VOLUME, VARIABLES, JET</i>
    */
    m_targetVelocityFactor =
        Context::getSolverProperty<MFloat>("targetVelocityFactor", m_solverId, AT_, &m_targetVelocityFactor);

    /*! \page propertiesFV
       \section jetForcingPosition
       <code>MFloat FvCartesianSolver::m_jetForcingPosition</code>\n
       default = <code>0.5</code>\n \n
       Defines the x-location where the jet forcing is applied.
       Only relevant for 3D jet with vortex ring forcing.\n
       possible values are:
       <ul>
       <li> A real number/position within the computational domain </li>
       </ul>
       Keywords: <i>FINITE_VOLUME, JET, FORCING</i>
    */
    m_jetForcingPosition = 0.5;
    m_jetForcingPosition =
        Context::getSolverProperty<MFloat>("jetForcingPosition", m_solverId, AT_, &m_jetForcingPosition);

    /*! \page propertiesFV
       \section jetRandomSeed
       <code>MFloat FvCartesianSolver::m_jetRandomSeed </code>\n
       default = <code>1</code>\n \n
       Defines random number seed for jet vortex ring forcing.
       Only relevant for 3D jet with vortex ring forcing.\n
       possible values are:
       <ul>
       <li> Any real number </li>
       </ul>
       Keywords: <i>FINITE_VOLUME, JET, FORCING</i>
    */
    m_jetRandomSeed = 1;
    m_jetRandomSeed = Context::getSolverProperty<MFloat>("jetRandomSeed", m_solverId, AT_, &m_jetRandomSeed);

    /*! \page propertiesFV
     \section modeNumbers
     <code>MInt FvCartesianSolver::m_modeNumbers </code>\n
     default = <code>0</code>\n \n
     Defines number of modes to be considered for 3D jet with vortex ring forcing.\n
     possible values are:
     <ul>
     <li> Non-negative integers </li>
     </ul>
     Keywords: FINITE_VOLUME, FORCING, MODES
    */
    m_modeNumbers = Context::getSolverProperty<MInt>("modeNumbers", m_solverId, AT_, &m_modeNumbers);

    /*! \page propertiesFV
       \section momentumThickness
       <code>MFloat FvCartesianSolver::m_momentumThickness </code>\n
       default = <code>0.025</code>\n \n
       Momentum thickness for non-dimensionalization in (coaxial) jet initial condition/boundary
       conditions.\n
       Possible values are: <ul> <li>any value > 0</li>
       </ul>
       Keywords: <i>FINITE_VOLUME, VARIABLES, JET</i>
     */
    m_momentumThickness = 0.025;
    m_momentumThickness =
        Context::getSolverProperty<MFloat>("momentumThickness", m_solverId, AT_, &m_momentumThickness);

    /*! \page propertiesFV
      \section jetType
      <code>MInt FvCartesianSolver::jetType </code>\n
      default = <code>0</code>\n \n
      Type of jet case volume forcing,\n
      possible values:
      <ul>
      <li>19516: Single jet forcing</li>
      <li>1156: Coaxial jet forcing</li>
      </ul>
      Keywords: <i>FV, JET, FORCING</i>
    */
    m_jetType = Context::getSolverProperty<MInt>("jetType", m_solverId, AT_, &m_jetType);

    /*! \page propertiesFV
      \section forceCoefficient
      <code>MFloat FvCartesianSolver::m_forceCoefficient</code>\n
      default = <code>0.007</code>\n\n
      Force coefficient for calculation of uy11 and ur by \n
      Choose forceCoefficient 0.007 for Bogey&Bailly reference \n
      <code> uy11 = (m_forceCoefficient * az * uy1) </code> and\n
      <code> ur = (m_forceCoefficient * az * ur0) </code>\n
      Keywords: <i>FINITE_VOLUME</i>
    */
    m_forceCoefficient = 0.007;
    m_forceCoefficient = Context::getSolverProperty<MFloat>("forceCoefficient", m_solverId, AT_, &m_forceCoefficient);
    m_densityRatio = Context::getSolverProperty<MFloat>("densityRatio", m_solverId, AT_, &m_densityRatio);

    if(Context::propertyExists("jetConst", m_solverId)) {
      /*! \page propertiesFV
       \section jetConst
       <code>MFloat FvCartesianSolver::m_jetConst </code>\n
       default = None \n \n
       Set jet constants.\n
       Possible values are:
       <ul>
       <li>Any number of floating point values.</li>
       </ul>
       Keywords: <i>FINITE_VOLUME, VARIABLES, JET</i>
     */
      m_noJetConst = Context::propertyLength("jetConst", m_solverId);

      mAlloc(m_jetConst, m_noJetConst, "m_jetConst", F0, AT_);
      for(MInt i = 0; i < m_noJetConst; i++) {
        m_jetConst[i] = Context::getSolverProperty<MFloat>("jetConst", m_solverId, AT_, &m_jetConst[i], i);
        m_log << "jet constants a = " << m_jetConst[i] << endl;
      }
    }
  }
}


/** \fn  void FvCartesianSolverXD<nDim_,SysEqn>::setAndAllocateSpongeBoundaryProperties()
 * \brief reads in the sponge properties for specific boundaries
 *
 * \author Stephan Schlimpert
 * \date 17.06.2011
 */

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setAndAllocateSpongeBoundaryProperties() {
  TRACE();
  MBool tmpFalse = false;

  // used for debugging
  m_noSpongeBndryCndIds = Context::propertyLength("spongeBndryCndIds", m_solverId);

  if(Context::propertyLength("spongeBndryCndIds", m_solverId) != Context::propertyLength("spongeFactor", m_solverId)
     || Context::propertyLength("spongeFactor", m_solverId) != Context::propertyLength("spongeDirections", m_solverId)
     || Context::propertyLength("spongeDirections", m_solverId) != Context::propertyLength("sigmaSponge", m_solverId)) {
    cerr << "ERROR: sponge properties don't have the same size" << endl << endl;
    cerr << "check the number of the following properties: " << endl;
    cerr << " - spongeBndryCndIds " << endl;
    cerr << " - sigmaSponge " << endl;
    cerr << " - spongeDirections " << endl;
    cerr << " - spongeFactor " << endl;
    mTerm(1, AT_, "ERROR: sponge properties don't have the same array size");
  }

  // Deallocate all previously allocated memory (if not nullptr)
  mDeallocate(m_spongeDirections);
  mDeallocate(m_spongeBndryCndIds);
  mDeallocate(m_spongeFactor);
  mDeallocate(m_sigmaSpongeBndryId);
  mDeallocate(m_sigmaEndSpongeBndryId);
  mDeallocate(m_spongeTimeDependent);
  mDeallocate(m_spongeStartIteration);
  mDeallocate(m_spongeEndIteration);
  mDeallocate(m_spongeCoord);

  // allocate space for sponge variables
  mAlloc(m_spongeDirections, m_noSpongeBndryCndIds, "m_spongeDirections", -1, AT_);
  mAlloc(m_spongeBndryCndIds, m_noSpongeBndryCndIds, "m_spongeBndryCndIds", 1, AT_);
  mAlloc(m_spongeFactor, m_noSpongeBndryCndIds, "m_spongeFactor", F1, AT_);
  mAlloc(m_sigmaSpongeBndryId, m_noSpongeBndryCndIds, "m_sigmaSpongeBndryId", F0, AT_);
  mAlloc(m_sigmaEndSpongeBndryId, m_noSpongeBndryCndIds, "m_sigmaEndSpongeBndryId", 100000.0, AT_);
  mAlloc(m_spongeTimeDependent, m_noSpongeBndryCndIds, "m_spongeTimeDependent", 0, AT_);
  mAlloc(m_spongeStartIteration, m_noSpongeBndryCndIds, "m_spongeStartIteration", F0, AT_);
  mAlloc(m_spongeEndIteration, m_noSpongeBndryCndIds, "m_spongeEndIteration", 100000.0, AT_);
  mAlloc(m_spongeCoord, m_noSpongeBndryCndIds, "m_spongeCoord", -100000.0, AT_);

  for(MInt i = 0; i < m_noSpongeBndryCndIds; i++) {
    /*! \page propertiesFV
      \section spongeFactor
      <code>MFloat FvCartesianSolver::m_spongeFactor </code>\n
      default = <code> 1.0, ... , 1.0</code>\n
      The property controls on which boundaries a sponge layer is active. Each entry corresponds to the respecive sponge
      boundary Id \ref spongeBndryCndIds and controls the specific sponge layer thickness on this specific boundary. If
      a factor is zero, no sponge layer is generated at this boundary. Only meaningful and required if both \ref
      spongeLayerThickness and \ref sigmaSponge are specified and nonzero! \n \n possible values for each entry are:
      <ul>
      <li> Any non-negative floating point value smaller than the extent of the domain in the respective direction.
      </li>
      </ul>
      Keywords: <i>FINITE_VOLUME, SPONGE, FACTOR</i>
    */
    m_spongeFactor[i] = Context::getSolverProperty<MFloat>("spongeFactor", m_solverId, AT_, &m_spongeFactor[i], i);

    /*! \page propertiesFV
      \section spongeDirections
      <code>MString FvCartesianSolver::m_spongeDirections </code>\n
      no default values used, the values are dependent on your sponge boundaries\n
      The property should be specified so that the  Each entry corresponds to the respecive sponge boundary Id specified
      in your properties as spongeBndryCndIds (Id_1, Id_2, ..., Id_n) and controls the specific sponge layer thickness
      on this specific boundary. If a factor is zero, no sponge layer is generated at this boundary. Only meaningful and
      required if both \ref spongeLayerThickness and \ref sigmaSponge are specified and nonzero! \n \n possible values
      for each entry are: <ul> <li> NEGATIVE_XWALL, POSITIVE_XWALL, NEGATIVE_YWALL, POSITIVE_YWALL  </li>
      </ul>
      Keywords: <i>FINITE_VOLUME, SPONGE, DIRECTION</i>
    */
    m_spongeDirections[i] =
        Context::getSolverProperty<MInt>("spongeDirections", m_solverId, AT_, &m_spongeDirections[i], i);

    /*! \page propertiesFV
      \section spongeBndryCndIds
      <code>MInt FvCartesianSolver::m_spongeBndryCndIds </code>\n
      no defalut value \n
      The property controls on which boundaries a sponge layer is active. Each entry corresponds to a boundary Id of
      your geometry (Id_1, Id_2, ..., Id_n) \n \n possible values for each entry are: <ul> <li> Any non-negative
      boundary Id which is specified as boundary Id in your geometry.cdl file </li>
      </ul>
      Keywords: <i>FINITE_VOLUME, SPONGE, BOUNDARY, ID, GEOMETRY</i>
    */
    m_spongeBndryCndIds[i] =
        Context::getSolverProperty<MInt>("spongeBndryCndIds", m_solverId, AT_, &m_spongeBndryCndIds[i], i);

    /*! \page propertiesFV
      \section sigmaSpongeBndryId
      <code>MInt FvCartesianSolver::m_sigmaSpongeBndryId </code>\n
      no defalut value \n
      The property controls the sigma sponge at the corresponding sponge boundary Id, see \ref spongeBndryCndIds \n \n
      possible values for each entry are:
      <ul>
      <li> Any non-negative floating point number </li>
      </ul>
      Keywords: <i>FINITE_VOLUME, SIGMA, SPONGE</i>
    */
    m_sigmaSpongeBndryId[i] =
        Context::getSolverProperty<MFloat>("sigmaSponge", m_solverId, AT_, &m_sigmaSpongeBndryId[i], i);

    /*! \page propertiesFV
      \section sigmaEndSponge
      <code>MInt FvCartesianSolver::m_sigmaEndSponge </code>\n
      no defalut value \n
      The property controls the sigma end sponge factor at the corresponding time dependent sponge boundary Id, see \ref
      spongeBndryCndIds, \ref spongeTimeDep. \n This property should be set if the sponge time dependent function 3 is
      used, see \ref spongeTimeDependent.\n possible values for each entry are: <ul> <li> Any non-negative floating
      point number which is lower than \ref sigmaSpongeBndryId </li>
      </ul>
      Keywords: <i>FINITE_VOLUME, SIGMA, TIME, DEPENDENT, SPONGE</i>
    */
    m_sigmaEndSpongeBndryId[i] =
        Context::getSolverProperty<MFloat>("sigmaEndSponge", m_solverId, AT_, &m_sigmaEndSpongeBndryId[i], i);

    /*! \page propertiesFV
      \section spongeStartIteration
      <code>MInt FvCartesianSolver::m_spongeStartIteration </code>\n
      no defalut value \n
      The property controls the start of a increasing or decreasing sponge factor triggered with \ref
      spongeTimeDependent \n \n possible values for each entry are: <ul> <li> Any non-negative integer point number
      smaller than \ref spongeEndIteration </li>
      </ul>
      Keywords: <i>FINITE_VOLUME, TIME, DEPENDENT, SPONGE, LAYER, START, ITERATION</i>
    */
    m_spongeStartIteration[i] =
        Context::getSolverProperty<MFloat>("spongeStartIteration", m_solverId, AT_, &m_spongeStartIteration[i], i);


    /*! \page propertiesFV
      \section spongeEndIteration
      <code>MInt FvCartesianSolver::m_spongeEndIteration </code>\n
      no defalut value \n
      The property controls the end of a increasing or decreasing sponge factor triggered with \ref spongeTimeDependent
      \n \n possible values for each entry are: <ul> <li> Any non-negative integer point number greater than \ref
      spongeStartIteration </li>
      </ul>
      Keywords: <i>FINITE_VOLUME, TIME, DEPENDENT, SPONGE, LAYER, END, ITERATION</i>
    */
    m_spongeEndIteration[i] =
        Context::getSolverProperty<MFloat>("spongeEndIteration", m_solverId, AT_, &m_spongeEndIteration[i], i);

    /*! \page propertiesFV
      \section spongeTimeDependent
      <code>MInt FvCartesianSolver::m_spongeTimeDependent </code>\n
      no defalut value \n
      The property controls the use of a time dependent sponge layer at the corresponding sponge boundary Id, see \ref
      spongeBndryCndIds. \n \n possible values for each entry are (only implemented for\\ref  spongeLayerTpe 17515
      (should be general implemented via function pointers in the boundary solver): <ul> <li> 0 - no time dependent
      sponge layer active </li> <li> 1 - decreasing time dependent sponge layer active (decreases from chosen sponge
      factor to zero, see \ref spongeFactor) </li> <li> 2 - increasing time dependent sponge layer active (increases
      from zero to chosen sponge factor, see \ref spongeFactor) </li>
      </ul>
      Keywords: <i>FINITE_VOLUME, TIME, DEPENDENT, SPONGE, LAYER, END, ITERATION</i>
    */
    m_spongeTimeDependent[i] =
        Context::getSolverProperty<MInt>("spongeTimeDependent", m_solverId, AT_, &m_spongeTimeDependent[i], i);

    if(!m_spongeTimeDep && m_spongeTimeDependent[i] >= 1) {
      m_spongeTimeDep = true;
    }
  }

  /*! \page propertiesFV
    \section noMaxSpongeBndryCells
    <code>MInt FvCartesianSolver::m_noMaxSpongeBndryCells </code>\n
    default = <code>0</code>\n \n
    The property should be specified so that there is enough memory for the total amount of founded sponge cells. Only
    meaningful and required if both \ref spongeLayerThickness and \ref sigmaSponge are specified and nonzero! \n \n
    possible values for each entry are:
    <ul>
    <li> Any non-negative integer value smaller than maximum number of cells.  </li>
    </ul>
    Keywords: <i>FINITE_VOLUME, SPONGE, DIRECTION</i>
  */
  m_noMaxSpongeBndryCells =
      Context::getSolverProperty<MInt>("noMaxSpongeBndryCells", m_solverId, AT_, &m_noMaxSpongeBndryCells);

  /*! \page propertiesFV
    \section spongeLayerLayout
    <code>MInt FvCartesianSolver::m_spongeLayerLayout </code>\n
    default = <code>0</code>\n \n
    The property controls the layout of the sponge layer. The sponge forcing term added to the rhs of a cell inside the
    sponge layer is given by \n \f$ \Delta L(\phi) = V \sigma \frac{\Delta x_{sp}^2}{L_s^2} \Delta \phi  \f$,  \n where
    \f$ V \f$ is the cell volume, \f$  \sigma  \f$ is the forcing amplitude, \f$  x_{sp} \f$ is the inner sponge layer
    boundary, \f$  L_{sp} \f$ is the sponge layer thickness and \f$  \Delta \phi = \phi - \phi_{target}  \f$ is the
    difference between the local and the freesteam values of \f$  \phi  \f$.\n

    Up to now, the user can choose only Cartesian layout for the new sponge layers. The inner sponge layer boundaries
    are interpreted as parallel to the Cartesian grid lines. That means, for the Cartesian layout, the effective sponge
    layer thickness is the maximum distance to the boundaries for which a cell is located in the sponge layer. Only
    meaningful and required if both \ref spongeLayerThickness and \ref sigmaSponge are specified and nonzero! \n \n

    possible values are:
    <ul>
    <li><code>0</code> (Cartesian layout)</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, SPONGE, LAYER. LAYOUT</i>
  */
  m_spongeLayerLayout = Context::getSolverProperty<MInt>("spongeLayerLayout", m_solverId, AT_, &m_spongeLayerLayout);
  if(m_spongeLayerLayout != 0) {
    cerr << "WARNING: spongeLayerLayout " << m_spongeLayerLayout
         << " not yet implemented for the new create sponge at a specified boundary" << endl;
  }

  /*! \page propertiesFV
    \section spongeLayerType
    <code>MInt FvCartesianSolver::m_spongeLayerType </code>\n
    default = <code>0</code>\n \n
    The property controls the type of the sponge layer forcing. The sponge forcing term added to the rhs of a cell
    inside the sponge layer is given by \n \f$ \Delta L(\phi) = V \sigma \frac{\Delta x_{sp}^2}{L_s^2} \Delta \phi  \f$,
    \n where \f$ V \f$ is the cell volume, \f$  \sigma  \f$ is the forcing amplitude, \f$  x_{sp} \f$ is the inner
    sponge layer boundary, \f$  L_{sp} \f$ is the sponge layer thickness and \f$  \Delta \phi = \phi - \phi_{target} \f$
    is the difference between the local and the freesteam values of \f$  \phi  \f$.\n

    This property controls which variables \f$ \phi \f$ will be forced and how the target value \f$ \phi_{target}  \f$
    is defined. For details, see the functions  FvCartesianSolver3D::updateSpongeLayer() and
    FvCartesianSolver2D::updateSpongeLayer(). Only meaningful and required if both \ref spongeLayerThickness and
    \ref sigmaSponge are specified and nonzero! \n possible values are:  \n \n <ul> <li> different non-negative integer
    values; For details see functions FvCartesianSolver3D::updateSpongeLayer() and
    FvCartesianSolver2D::updateSpongeLayer(). </li>
    </ul>
    Keywords: <i>FINITE_VOLUME, SPONGE</i>
  */
  m_spongeLayerType = Context::getSolverProperty<MInt>("spongeLayerType", m_solverId, AT_, &m_spongeLayerType);

  if(!m_combustion) {
    /*! \page propertiesFV
      \section targetDensityFactor
      <code>MFloat FvCartesianSolver::m_targetDensityFactor </code>\n
      default = <code>1.0</code>\n \n
      The property controls the Intensity of the sponge layer correction regarding the density forcing term for some
      values of the spongeLayerType. The sponge forcing term added to the rhs of a cell inside the sponge layer is given
      by \n \f$ \Delta L(\phi) = V \sigma \frac{\Delta x_{sp}^2}{L_s^2} \Delta \phi  \f$,  \n where \f$ V \f$ is the
      cell volume, \f$  \sigma  \f$ is the forcing amplitude, \f$  x_{sp} \f$ is the inner sponge layer boundary, \f$
      L_{sp} \f$ is the sponge layer thickness and \f$  \Delta \phi = \phi - \phi_{target}  \f$ is the difference
      between the local and the freesteam values of \f$  \phi  \f$.\n The density target value is in these cases given
      as:    \n <code> deltaRho =a_pvariable( cellId ,  PV->RHO ) - m_rhoInfinity *
      m_targetDensityFactor;</code>\n See also spongeLayerType. Only meaningful and required with certain values for
      \ref spongeLayerType and if both \ref spongeLayerThickness and \ref sigmaSponge are specified and nonzero! ! \n \n
      possible values are: <ul> <li>Non-negative floating point values.</li>
      </ul>
      Keywords: <i>FINITE_VOLUME, SPONGE</i>
    */
    m_targetDensityFactor =
        Context::getSolverProperty<MFloat>("targetDensityFactor", m_solverId, AT_, &m_targetDensityFactor);
  }

  m_spongeReductionFactor = F1;
  /*! \page propertiesFV
    \section spongeReductionFactor
    <code>MFloat FvCartesianSolver::m_spongeReductionFactor </code>\n
    default = <code>1.0</code>\n \n
    The property controls the intensity of the sponge layer velocity forcing. The sponge forcing term added to the rhs
    of a cell inside the sponge layer is given by \n \f$ \Delta L(\phi) = V \sigma \frac{\Delta x_{sp}^2}{L_s^2} \Delta
    \phi  \f$,  \n where \f$ V \f$ is the cell volume, \f$  \sigma  \f$ is the forcing amplitude, \f$  x_{sp} \f$ is the
    inner sponge layer boundary, \f$  L_{sp} \f$ is the sponge layer thickness and \f$  \Delta \phi = \phi -
    \phi_{target}  \f$ is the difference between the local and the freesteam values of \f$  \phi  \f$.\n The velocity
    target value is in these cases given as:    \n <code> deltaV =a_pvariable( cellId ,  PV->VV[1] ) - velocity
    ) * m_rhoInfinity;</code>\n See also spongeLayerType. Only meaningful and required with certain values for \ref
    spongeLayerType and if both \ref spongeLayerThickness and \ref sigmaSponge are specified and nonzero! ! \n \n
    possible values are:
    <ul>
    <li>Non-negative floating point values.</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, SPONGE, REDUCTION, FACTOR</i>
  */
  m_spongeReductionFactor =
      Context::getSolverProperty<MFloat>("spongeReductionFactor", m_solverId, AT_, &m_spongeReductionFactor);

  /*! \page propertiesFV
    \section velocitySponge
    <code>MBool FvCartesianSolver:: m_velocitySponge  </code>\n
    default = <code>0</code>\n \n
    The property controls wether a velocity sponge is apllied or not \n
    The velocity target value is in these cases depending on the \ref spongeWeigth which is a local moving time
    averaging given as:    \n <code> deltaV =a_pvariable( cellId ,  PV->VV[1] ) - velocityAv ) *
    m_rhoInfinity;</code>\n and <code> velocityAv = (1-\alpha)*velocityOld + \alpha*velocityNew </code>\n with <code>
    \alpha = 1/m_spongeWeight </code>\n Only applied for \ref spongeLayerType = 17515. ! \n \n possible values are: <ul>
    <li>0 - off</li>
    <li>1 - on</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, VELOCITY, SPONGE</i>
  */
  m_velocitySponge = Context::getSolverProperty<MBool>("velocitySponge", m_solverId, AT_, &tmpFalse);

  //  if(m_velocitySponge){
  m_spongeWeight = 1.0;
  /*! \page propertiesFV
      \section spongeWeight
      <code>MFloat FvCartesianSolver:: m_spongeWeight  </code>\n
      default = <code>10</code>\n \n
      The property controls the strength of the time averaging sponge, see \ref velocitySponge. It's actually the number
     of iteration to take into account for time averaging. \n Only applied for \ref spongeLayerType = 17515. ! \n \n
      possible values are:
      <ul>
      <li>Non-negative floating point values.</li>
      </ul>
      Keywords: <i>FINITE_VOLUME, VELOCITY, SPONGE</i>
    */
  m_spongeWeight = Context::getSolverProperty<MFloat>("spongeWeight", m_solverId, AT_, &m_spongeWeight);
  //  }

  m_spongeBeta = F1;
  /*! \page propertiesFV
    \section spongeBeta
    <code>MFloat FvCartesianSolver:: m_spongeBeta  </code>\n
    default = <code>0</code>\n \n
    The property controls the sponge function. Linear sponge spongeBeta = 1, quadratic spongeBeta = 2, etc. \n
    possible values are:
    <ul>
    <li>floating point values.</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, SPONGE, BETA, PROFIL</i>
  */
  m_spongeBeta = Context::getSolverProperty<MFloat>("spongeBeta", m_solverId, AT_, &m_spongeBeta);

  /*! \page propertiesFV
      \section specialSpongeTreatment
      <code>MBool FvCartesianSolver::m_specialSpongeTreatment </code>\n
      default = <code>false</code>\n \n
      Fixes the velocity profile instead of damping it to the desired profile, u component is set to zero /n
      possible values are:
      <ul>
      <li> true - on  </li>
      <li> false - off </li>
      </ul>
      Keywords: <i>FINITE_VOLUME, SPONGE, TREATMENT, VELOCITY, PROFILE</i>
  */
  m_specialSpongeTreatment = Context::getSolverProperty<MBool>("specialSpongeTreatment", m_solverId, AT_, &tmpFalse);
}

//----------------------------------------------------------------------------


/** \fn double FvCartesianSolverXD<nDim_,SysEqn>::setAndAllocateSpongeDomainProperties(MFloat allocatedBytes)
 * \brief reads in the sponge properties for the domain boundaries
 *
 * \author Stephan Schlimpert
 * \date 17.06.2011
 */
template <MInt nDim_, class SysEqn>
MFloat FvCartesianSolverXD<nDim_, SysEqn>::setAndAllocateSpongeDomainProperties(MFloat allocatedBytes) {
  TRACE();

  mDeallocate(m_spongeFactor);
  mAlloc(m_spongeFactor, 2 * nDim, "m_spongeFactor", F0, AT_);
  mDeallocate(m_spongeCoord);
  mAlloc(m_spongeCoord, 4 * nDim, "m_spongeFactor", F0, AT_);

  /*! \page propertiesFV
    \section sigmaSponge
    <code>MFloat FvCartesianSolver::m_sigmaSponge </code>\n
    default = <code>nullptr</code> \n \n
    The property controls the amplitude of the forcing term \f$ \sigma \f$ for the sponge layer forcing. The sponge
    forcing term added to the rhs of a cell inside the sponge layer is given by \n \f$ \Delta L(\phi) = V \sigma
    \frac{\Delta x_{sp}^2}{L_s^2} \Delta \phi  \f$,  \n where \f$ V \f$ is the cell volume, \f$  \sigma  \f$ is the
    forcing amplitude, \f$  x_{sp} \f$ is the inner sponge layer boundary, \f$  L_{sp} \f$ is the sponge layer thickness
    and \f$ \Delta \phi = \phi - \phi_{target} \f$ is the difference between the local and the freesteam values of \f$
    \phi  \f$.\n \n possible values are: <ul> <li> Non-negative floating point values. Meaningful values may be problem
    dependent. Relatively low values suggested. </li>
    </ul>
    Keywords: <i>FINITE_VOLUME, SPONGE</i>
  */
  m_sigmaSponge = Context::getSolverProperty<MFloat>("sigmaSponge", m_solverId, AT_);

  /*! \page propertiesFV
    \section sigmaSpongeInflow
    <code>MFloat FvCartesianSolver::m_sigmaSpongeInflow </code>\n
    default = <code>nullptr</code> \n \n
    The property controls the amplitude of the forcing term \f$ \sigma \f$ for the sponge layer forcing at the inflow.
    The sponge forcing term added to the rhs of a cell inside the sponge layer is given by \n \f$ \Delta L(\phi) = V
    \sigma \frac{\Delta x_{sp}^2}{L_s^2} \Delta \phi  \f$,  \n where \f$ V \f$ is the cell volume, \f$  \sigma  \f$ is
    the forcing amplitude, \f$  x_{sp} \f$ is the inner sponge layer boundary, \f$  L_{sp} \f$ is the sponge layer
    thickness and \f$ \Delta \phi = \phi - \phi_{target} \f$ is the difference between the local and the freesteam
    values of \f$  \phi  \f$.\n \n possible values are: <ul> <li> Non-negative floating point values. Meaningful values
    may be problem dependent. Relatively low values suggested. </li>
    </ul>
    Keywords: <i>FINITE_VOLUME, SPONGE</i>
  */
  m_sigmaSpongeInflow = Context::getSolverProperty<MFloat>("sigmaSpongeInflow", m_solverId, AT_, &m_sigmaSponge);

  if((m_sigmaSponge > F0) || (m_sigmaSpongeInflow > F0)) {
    /*! \page propertiesFV
      \section spongeFactor
      <code>MFloat FvCartesianSolver::m_spongeFactor </code>\n
      default = <code> 1.0, 1.0, 1.0, 1.0 (2D)</code>\n
      default = <code> 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 (3D)</code>\n \n
      The property controls on which domain boundaries a sponge layer is active. 2 * nDim values are required. Each
      entry corresponds to the respecive direction (0: -x, 1: +x, 2: -y, ...) and controls the specific sponge layer
      thickness on this domain boundary. If a factor is zero, no sponge layer is generated in this direction. Only
      meaningful and required if both \ref spongeLayerThickness and \ref sigmaSponge are specified and nonzero! \n \n
      possible values for each entry are:
      <ul>
      <li> Any non-negative floating point value smaller than the extent of the domain in the respective direction.
      </li>
      </ul>
      Keywords: <i>FINITE_VOLUME, SPONGE</i>
    */
    for(MInt i = 0; i < 2 * nDim; i++) {
      m_spongeFactor[i] = F1;
    }
    m_noSpongeFactors = 2 * nDim;
    if(Context::propertyExists("spongeFactor", m_solverId))
      m_noSpongeFactors = Context::propertyLength("spongeFactor", m_solverId);
    if(m_noSpongeFactors != 2 * nDim) {
      stringstream errorMessage;
      errorMessage << " Error in FvCartesianSolver::FvCartesianSolver Constructor: number of sponge factors is "
                      "not equal 2 * space "
                      "dimensions -> please provide "
                   << 2 * nDim << " sponge factors in property spongeFactor! Exiting!";
      mTerm(1, AT_, errorMessage.str());
    }
    for(MInt i = 0; i < m_noSpongeFactors; i++) {
      m_spongeFactor[i] = Context::getSolverProperty<MFloat>("spongeFactor", m_solverId, AT_, &m_spongeFactor[i], i);
    }

    /*! \page propertiesFV
      \section spongeLayerLayout
      <code>MInt FvCartesianSolver::m_spongeLayerLayout </code>\n
      default = <code>0</code>\n \n
      The property controls the layout of the sponge layer. The sponge forcing term added to the rhs of a cell inside
      the sponge layer is given by \n \f$ \Delta L(\phi) = V \sigma \frac{\Delta x_{sp}^2}{L_s^2} \Delta \phi  \f$,  \n
      where \f$ V \f$ is the cell volume, \f$  \sigma  \f$ is the forcing amplitude, \f$  x_{sp} \f$ is the inner sponge
      layer boundary, \f$  L_{sp} \f$ is the sponge layer thickness and \f$  \Delta \phi = \phi - \phi_{target}  \f$ is
      the difference between the local and the freesteam values of \f$  \phi  \f$.\n

      Up to now, the user can choose between Cartesian and Zylindrical layout. The inner sponge layer boundaries are
      interpreted either as parallel to the Cartesian grid lines or cylinder surface. That means, for the Cartesian
      layout, the effective sponge layer thickness is the maximum distance to the domain boundaries for which a cell is
      located in the sponge layer. For the cylindrical layout (only meaningful if the domain boundaries are symmetrical
      in x and z, the sponge layer includes all cells with a (xz) radius bigger than the maximum x-domain boundary value
      minus the effective sponge layer thickness. In y-direction, this sponge layer layout is the same as the Cartesian
      layout. See also \ref spongeLayerThickness and \ref spongeFactor. Only meaningful and required if both \ref
      spongeLayerThickness and \ref sigmaSponge are specified and nonzero! \n \n

      possible values are:
      <ul>
      <li><code>0</code> (Cartesian layout)</li>
      <li><code>2</code> (layout in cylindrical coordinate system (streamwise direction is y, radial (xz)))</li>
      </ul>
      Keywords: <i>FINITE_VOLUME, SPONGE</i>
    */
    m_spongeLayerLayout = Context::getSolverProperty<MInt>("spongeLayerLayout", m_solverId, AT_, &m_spongeLayerLayout);

    /*! \page propertiesFV
      \section spongeLayerType
      <code>MInt FvCartesianSolver::m_spongeLayerType </code>\n
      default = <code>0</code>\n \n
      The property controls the type of the sponge layer forcing. The sponge forcing term added to the rhs of a cell
      inside the sponge layer is given by \n \f$ \Delta L(\phi) = V \sigma \frac{\Delta x_{sp}^2}{L_s^2} \Delta \phi
      \f$,  \n where \f$ V \f$ is the cell volume, \f$  \sigma  \f$ is the forcing amplitude, \f$  x_{sp} \f$ is the
      inner sponge layer boundary, \f$  L_{sp} \f$ is the sponge layer thickness and \f$  \Delta \phi = \phi -
      \phi_{target} \f$ is the difference between the local and the freesteam values of \f$  \phi  \f$.\n

      This property controls which variables \f$ \phi \f$ will be forced and how the target value \f$ \phi_{target}  \f$
      is defined. For details, see the functions  FvCartesianSolver3D::updateSpongeLayer() and
      FvCartesianSolver2D::updateSpongeLayer(). Only meaningful and required if both \ref spongeLayerThickness and
      \ref sigmaSponge are specified and nonzero! \n possible values are:  \n \n <ul> <li> different non-negative
      integer values; For details see functions FvCartesianSolver3D::updateSpongeLayer() and
      FvCartesianSolver2D::updateSpongeLayer(). </li>
      </ul>
      Keywords: <i>FINITE_VOLUME, SPONGE</i>
    */
    m_spongeLayerType = Context::getSolverProperty<MInt>("spongeLayerType", m_solverId, AT_, &m_spongeLayerType);

    if(!m_combustion) {
      /*! \page propertiesFV
  \section targetDensityFactor
template <MInt nDim_, class SysEqn>
  <code>MFloat FvCartesianSolverXD<nDim_,SysEqn>::m_targetDensityFactor </code>\n
  default = <code>1.0</code>\n \n
  The property controls the Intensity of the sponge layer correction regarding the density forcing term for some values
of the spongeLayerType. The sponge forcing term added to the rhs of a cell inside the sponge layer is given by \n \f$
\Delta L(\phi) = V \sigma \frac{\Delta x_{sp}^2}{L_s^2} \Delta \phi  \f$,  \n where \f$ V \f$ is the cell volume, \f$
\sigma  \f$ is the forcing amplitude, \f$  x_{sp} \f$ is the inner sponge layer boundary, \f$  L_{sp} \f$ is the sponge
layer thickness and \f$  \Delta \phi = \phi - \phi_{target}  \f$ is the difference between the local and the freesteam
values of \f$  \phi  \f$.\n The density target value is in these cases given as:    \n <code> deltaRho =a_pvariable(
cellId ,  PV->RHO ) - m_rhoInfinity * m_targetDensityFactor;</code>\n See also spongeLayerType. Only meaningful
and required with certain values for \ref spongeLayerType and if both \ref spongeLayerThickness and \ref sigmaSponge are
specified and nonzero! ! \n \n possible values are: <ul> <li>Non-negative floating point values.</li>
  </ul>
  Keywords: <i>FINITE_VOLUME, SPONGE</i>
      */
      m_targetDensityFactor =
          Context::getSolverProperty<MFloat>("targetDensityFactor", m_solverId, AT_, &m_targetDensityFactor);
    }
  }

  return allocatedBytes;
}


/**
 * \fn void FvCartesianSolverXD::setAndAllocateAdaptationProperties()
 * \brief This function reads the properties required for adaptive mesh refinement.
 *  \author Gonzalo Brito Gadeschi
 *  \date October, 2012
 **/
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setAndAllocateAdaptationProperties() {
  TRACE();

  const MInt maxNoCells = maxNoGridCells();

  // the following properties are always used and thus must be initialized!
  m_adaptationSinceLastRestart = false; // if no adaptation is used, the grid is never adapted since the last restart!
  m_adaptationSinceLastRestartBackup =
      false; // if no adaptation is used, the grid is never adapted since the last restart!

  m_currentGridFileName = grid().gridInputFileName();

  m_forceRestartGrid = false;
  m_forceRestartGrid = Context::getSolverProperty<MBool>("forceRestartGrid", m_solverId, AT_, &m_forceRestartGrid);

  m_recalcIds = nullptr;


  /*! \page propertiesFV
  \section adaptationInterval
  <code>MInt FvCartesianSolver::m_adaptationInterval </code>\n
  default = <code>0</code>\n
  Number of timesteps between adaptations.
  Possible values are:
  <ul>
  <li> integer >=0 </li>
  </ul>
  Keywords: <i>FINITE_VOLUME, ADAPTION</i>
  */
  this->m_adaptationInterval = 0;
  this->m_adaptationInterval =
      Context::getSolverProperty<MInt>("adaptationInterval", m_solverId, AT_, &this->m_adaptationInterval);

  m_allowInterfaceRefinement = false;
  m_allowInterfaceRefinement =
      Context::getSolverProperty<MBool>("allowInterfaceRefinement", m_solverId, AT_, &m_allowInterfaceRefinement);

  mAlloc(m_recalcIds, maxNoCells, "m_recalcIds", -1, AT_);

  for(MInt i = 0; i < maxNoCells; i++) {
    m_recalcIds[i] = i;
  }


  mAlloc(m_innerBandWidth, maxRefinementLevel(), "m_innerBandWidth", F0, AT_);
  mAlloc(m_outerBandWidth, maxRefinementLevel(), "m_outerBandWidth", F0, AT_);
  mAlloc(m_bandWidth, maxRefinementLevel(), "m_bandWidth", 0, AT_);
  if(m_sensorParticle) {
    mAlloc(m_particleWidth, maxRefinementLevel(), "m_particleWidth", 0, AT_);
    MInt range[2] = {2, 0};
    for(MInt i = 0; i < 2; i++) {
      range[i] = Context::getSolverProperty<MInt>("particleAdapRange", solverId(), AT_, &range[i], i);
    }
    if(range[1] < 2) {
      mTerm(1, AT_, "Particle adaptation range in FV solver not set correctly!");
    }
    m_particleWidth[maxRefinementLevel() - 1] = range[0];
    for(MInt i = maxRefinementLevel() - 2; i >= 0; i--) {
      m_particleWidth[i] = (m_particleWidth[i + 1] / 2) + 1 + range[1];
    }
  }

  /*! \page propertiesFV
  \section mbBandwidth
  <code>MFloat FvMbCartesianSolverXD::distFac </code>\n
  default = {18.0, 9.0}\n
  Sets the distance factor which is used to calculate the inner (distFac[0]) and outer (distFac[1]) bandwidth.\n
  Possible values are:
  <ul>
    <li>Any floating point values.</li>
  </ul>
  Keywords: <i>MOVING BOUNDARY, FINITE_VOLUME</i>
*/
  MFloat distFac[2] = {18.0, 9.0};
  for(MInt i = 0; i < 2; i++) {
    distFac[i] = Context::getSolverProperty<MFloat>("mbBandWidth", m_solverId, AT_, &distFac[i], i);
  }
  m_outerBandWidth[maxRefinementLevel() - 1] = distFac[0] * c_cellLengthAtLevel(maxRefinementLevel());
  m_bandWidth[maxRefinementLevel() - 1] = distFac[0];
  for(MInt i = maxRefinementLevel() - 2; i >= 0; i--) {
    m_outerBandWidth[i] = m_outerBandWidth[i + 1] + (distFac[1] * c_cellLengthAtLevel(i + 1));
    m_bandWidth[i] = (m_bandWidth[i + 1] / 2) + 1 + distFac[1];
  }
  for(MInt i = 0; i < maxRefinementLevel(); i++) {
    m_innerBandWidth[i] = -m_outerBandWidth[i];
    m_log << "bandwidth level " << i << ": " << m_innerBandWidth[i] << " " << m_outerBandWidth[i] << endl;
  }

  m_adaptationDampingDistance = std::numeric_limits<MFloat>::max();


  m_refineDiagonals = true;
  /*! \page propertiesFV
    \section refineDiagonals
    <code>MBool FvCartesianSolver::m_refineDiagonals </code>\n
    default = <code>true</code>\n \n
    Determines whether the diagonal cells for the interface sensor should be refined as well!
    <ul>
    <li>true</li>
    <li>false</li>
    </ul>
    Keywords: <i>SENSOR, ADAPTATION</i>
  */
  m_refineDiagonals = Context::getSolverProperty<MBool>("refineDiagonals", m_solverId, AT_, &m_refineDiagonals);
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setAndAllocateZonalProperties() {
  TRACE();

  // RANS
  MBool fullRANS = false;
  m_zonal = false;
  m_zonalRestartInterpolationSolverId = 0;
  m_rans = false;
  m_noRansEquations = 0;
  m_turbulenceDegree = F0;

  /*! \page propertiesFV
    \section fullRANS
    <code>MFloat FvCartesianSolver::m_fullRANS </code>\n
    default = <code>0</code>\n \n
    Trigger a zonal computation.\n
    possible values are:
    <ul>
    <li>true/false</li>
    </ul>
    Keywords: <i>RANS, ZONAL, STRUCTURED</i>
  */
  if(Context::propertyExists("fullRANS", m_solverId)) {
    fullRANS = Context::getSolverProperty<MBool>("fullRANS", m_solverId, AT_, &fullRANS);
  }

  if(fullRANS) {
    m_log << "Starting a full RANS computation" << endl;
    m_rans = true;
  }

  m_azimuthalAngle = F0;
  m_azimuthalAngle = Context::getBasicProperty<MFloat>("azimuthalAngle", AT_, &m_azimuthalAngle);

  /*! \page propertiesFV
    \section bodyIdOutput
    <code>MBool FvMbSolver::m_multipleFvSolver </code>\n
    default = <code>false</code>\n \n
    Triggers if the solverId is added to the Fv-solution/restartFiles
    Keywords: <i>FV, MULTI-SOLVER</i>
  */
  m_multipleFvSolver = Context::getSolverProperty<MBool>("multipleFv", m_solverId, AT_, &m_multipleFvSolver);

  if(Context::propertyExists("zonal")) {
    m_zonal = Context::getBasicProperty<MBool>("zonal", AT_, &m_zonal);
  }

  if(m_zonal) {
    if(Context::getBasicProperty<MInt>("noRANSSolvers", AT_) > 0) {
      MInt noRANSSolvers = Context::getBasicProperty<MInt>("noRANSSolvers", AT_, &noRANSSolvers);
      for(MInt b = 0; b < noRANSSolvers; b++) {
        MInt RANSSolver = Context::getBasicProperty<MInt>("RANSSolver", AT_, &RANSSolver, b);

        if(m_solverId == RANSSolver) {
          m_rans = true;
        }
      }
    }
    m_zonalTransferInterval = Context::getSolverProperty<MInt>("zonalTransferInterval", m_solverId, AT_);
    m_multipleFvSolver = true;

    m_zonalAveragingTimeStep =
        Context::getSolverProperty<MInt>("zonalAveragingTimeStep", m_solverId, AT_, &m_zonalAveragingTimeStep);
  }

  if(Context::propertyExists("calcLESAverage")) {
    m_calcLESAverage = Context::getSolverProperty<MBool>("calcLESAverage", m_solverId, AT_, &m_calcLESAverage);
  }

  if(Context::propertyExists("preliminarySponge")) {
    m_preliminarySponge = Context::getSolverProperty<MBool>("preliminarySponge", m_solverId, AT_, &m_preliminarySponge);
  }

  if(m_zonal || m_preliminarySponge) {
    m_STGSponge = Context::getSolverProperty<MBool>("STGSponge", m_solverId, AT_, &m_STGSponge);

    if(m_STGSponge) {
      m_stgSpongeTimeStep =
          Context::getSolverProperty<MInt>("stgSpongeTimeStep", m_solverId, AT_, &m_stgSpongeTimeStep);
      m_noStgSpongePositions = Context::propertyLength("stgSpongePositions", m_solverId);
      mAlloc(m_stgSpongePositions, m_noStgSpongePositions, "m_stgSpongePositions", FUN_);
      for(MInt i = 0; i < m_noStgSpongePositions; i++) {
        m_stgSpongePositions[i] =
            Context::getSolverProperty<MFloat>("stgSpongePositions", m_solverId, AT_, &m_stgSpongePositions[i], i);
      }
      if(Context::propertyExists("limitFactor")) {
        m_spongeLimitFactor = Context::getBasicProperty<MFloat>("limitFactor", AT_, &m_spongeLimitFactor);
      }
    }
  }

  /*! \page propertyPage1
    \section zonal
    <code>MBool MAIAFvCartesianSolver::m_restartLESAverage</code>\n
    default = <code>False</code>\n
    Triggers loading of LES Average
    Keywords: <i>FINITE_VOLUME, FV_ZONAL</i>
  */
  if(m_calcLESAverage) {
    m_restartLESAverage = Context::getSolverProperty<MBool>("restartLESAverage", m_solverId, AT_, &m_restartLESAverage);
    m_averageStartTimeStep =
        Context::getSolverProperty<MInt>("averageStartTimeStep", m_solverId, AT_, &m_averageStartTimeStep);
    m_LESNoVarAverage = Context::getSolverProperty<MInt>("noLESAverageVar", m_solverId, AT_, &m_LESNoVarAverage);

    m_7901Position = Context::getBasicProperty<MFloat>("bc7901Position", AT_, &m_7901Position);
    m_7901faceNormalDir = Context::getBasicProperty<MInt>("bc7901faceNormalDir", AT_, &m_7901faceNormalDir);
    m_7901periodicDir = Context::getBasicProperty<MInt>("bc7901periodicDir", AT_, &m_7901periodicDir);
    m_7901wallDir = Context::getBasicProperty<MInt>("bc7901wallDir", AT_, &m_7901wallDir);
  }

  if(m_STGSponge && !m_calcLESAverage) mTerm(1, "calcLESAverage has to be turned on while using STGSponge");

  if(Context::propertyExists("stgStartTimeStep")) {
    m_stgStartTimeStep = Context::getSolverProperty<MInt>("stgStartTimeStep", m_solverId, AT_, &m_stgStartTimeStep);
  }
  if(Context::propertyExists("rntStartTimeStep")) {
    m_rntStartTimeStep = Context::getSolverProperty<MInt>("rntStartTimeStep", m_solverId, AT_, &m_rntStartTimeStep);
  }

  m_resetInitialCondition = false;
  if(Context::propertyExists("resetInitialCondition")) {
    m_resetInitialCondition = Context::getBasicProperty<MBool>("resetInitialCondition", AT_, &m_resetInitialCondition);
  } else if(Context::propertyExists("nonZonalRestart")) {
    m_resetInitialCondition = Context::getBasicProperty<MBool>("nonZonalRestart", AT_, &m_resetInitialCondition);
  }

  if(m_resetInitialCondition) {
    m_zonalRestartInterpolationSolverId = Context::getSolverProperty<MInt>(
        "zonalRestartInterpolationSolverId", m_solverId, AT_, &m_zonalRestartInterpolationSolverId);
  }

  if(m_resetInitialCondition && domainId() == 0) {
    cerr << "Resetting initial Condition and times!" << endl;
  }

  if(m_rans) {
    m_noRansEquations = SysEqn::m_noRansEquations;

    if(m_noRansEquations == 0) mTerm(1, "RANS activated, but noRansEquations equal to 0");

    m_ransTransPos = -1000000.0;
    if(Context::propertyExists("ransTransPos", m_solverId)) {
      m_ransTransPos = Context::getSolverProperty<MFloat>("ransTransPos", m_solverId, AT_, &m_ransTransPos);
    }
    IF_CONSTEXPR(SysEqn::m_ransModel == RANS_FS) {
      m_turbulenceDegree = Context::getSolverProperty<MFloat>("turbulenceDegree", m_solverId, AT_, &m_turbulenceDegree);
    }
  }

  // STG
  /*! \page propertiesFV
    \section useSTG
    <code>MFloat FvCartesianSolver::m_stgIsActive </code>\n
    default = <code>0</code>\n \n
    Trigger the use of the STG BC.\n
    possible values are:
    <ul>
    <li>true/false</li>
    </ul>
    Keywords: <i>STG, FINITE_VOLUME</i>
  */
  m_stgIsActive = false;
  if(Context::propertyExists("useSTG", m_solverId)) {
    m_stgIsActive = Context::getSolverProperty<MBool>("useSTG", m_solverId, AT_, &m_stgIsActive);
  }

  if(m_stgIsActive) {
    /*! \page propertiesFV
      \section bc7909RANSSolverType
      <code>MInt FvCartesianSolver::m_bc7909RANSSolverType </code>\n
      default = <code> nullptr </code>\n
      Solver type used for STG.
      Keywords: <i>FINITE_VOLUME</i>
    */
    if(!Context::propertyExists("bc7909RANSSolverType", m_solverId)) {
      mTerm(-1, "Property 'bc7909RANSSolverType' required for bc7909, but not found!");
    }
    m_bc7909RANSSolverType =
        Context::getSolverProperty<MString>("bc7909RANSSolverType", m_solverId, AT_, &m_bc7909RANSSolverType);

    mAlloc(m_stgEddieCoverage, 3, maxNoGridCells(), "m_stgEddieCoverage", F0, AT_);
  }
}


/// \fn void FvCartesianSolverXD<nDim_,SysEqn>::setRungeKuttaProperties()
/// \brief This function reads the properties required for Runge Kutta time stepping.
/// \author Gonzalo Brito Gadeschi
/// \date October, 2012
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setRungeKuttaProperties() {
  TRACE();

  // Allocate and initialize Runge-Kutta coefficients:
  m_noRKSteps = 5;
  /*! \page propertiesFV
    \section noRKSteps
    <code>MInt FvCartesianSolver::m_noRKSteps </code>\n
    default = <code>5</code>\n \n
    Number of steps in the Runge-Kutta time-stepping method.
    possible values are:
    <ul>
    <li>Positive integers.</li>
    </ul>
    Keywords: <i>FV, RUNGE KUTTA, TIME STEPPING</i>
  */
  m_noRKSteps = Context::getSolverProperty<MInt>("noRKSteps", m_solverId, AT_, &m_noRKSteps);

  mDeallocate(m_RKalpha);
  mAlloc(m_RKalpha, m_noRKSteps, "m_RKalpha", -F1, AT_);

  MFloat RK5DefaultCoeffs[5] = {0.25, 0.16666666666, 0.375, 0.5, 1.};
  /*! \page propertiesFV
    \section rkalpha-step
    <code>MFloat FvCartesianSolver::m_RKalpha[m_noRKSteps] </code>\n
    default = <code>0.25, 0.16666666666, 0.375, 0.5, 1</code> IF noRKSteps is 5.\n \n
    Coeffients of the Runge-Kutta time-stepping method.
    possible values are:
    <ul>
    <li>Floating point numbers (as many as Runge-Kutta steps).</li>
    </ul>
    Keywords: <i>FV, RUNGE KUTTA, TIME STEPPING</i>
  */
  if(m_noRKSteps == 5) { // default only valid m_noRKSteps == 5
    for(MInt i = 0; i < m_noRKSteps; i++) {
      m_RKalpha[i] = Context::getSolverProperty<MFloat>("rkalpha-step", m_solverId, AT_, &RK5DefaultCoeffs[i], i);
    }
  } else { // otherwise currently no default is set  -> can be extended later
    for(MInt i = 0; i < m_noRKSteps; i++) {
      m_RKalpha[i] = Context::getSolverProperty<MFloat>("rkalpha-step", m_solverId, AT_, i);
    }
  }

  m_rungeKuttaOrder = 2;
  /*! \page propertiesFV
    \section rungeKuttaOrder
    <code>MFloat FvCartesianSolver::m_rungeKuttaOrder </code>\n
    default = <code>2</code>\n \n
    Defines the runge kutta method (order).
    possible values are:
    <ul>
    <li>2 - second order</li>
    <li>3 - third order</li>
    </ul>
    Keywords: <i>TIME_INTEGRATION, RUNGE_KUTTA</i>
  */
  m_rungeKuttaOrder = Context::getSolverProperty<MInt>("rungeKuttaOrder", m_solverId, AT_, &m_rungeKuttaOrder);
}

/** \fn void FvCartesianSolverXD<nDim_,SysEqn>::setCombustionGequPvVariables()
 * \brief reads in the combustion properties
 *
 * \author Stephan Schlimpert
 * \date 12.12.2010, 17.06.2011
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setCombustionGequPvVariables() {
  TRACE();

  MFloat pressureLoss = F0;

  m_log << "TbTu = " << m_burntUnburntTemperatureRatio << endl;
  // compute the flame strouhal number for forced cases
  if(m_forcing || m_structuredFlameOutput) {
    const MFloat slOverU = m_flameSpeed / m_MaFlameTube;
    const MFloat Lf = m_realRadiusFlameTube * tan(acos(slOverU)); // nominal flame length (measured: 1.57)
    m_flameStrouhal = m_strouhal / Lf;
    // for slot burner with strouhal number based on length one!!! (otherwise neutral markstein lengths not comparable)
    if(m_neutralFlameStrouhal > 0) {
      m_flameStrouhal = m_neutralFlameStrouhal;
    }
  } else {
    m_flameStrouhal = F0;
  }
  // nondimensilization of strouhal to stagnation point
  m_flameStrouhal *= m_timeRef;
  m_neutralFlameStrouhal *= m_timeRef;

  // compute theorethical marksetin length
  m_marksteinLengthTh = (F1 - m_rhoInfinity * F1 / m_burntUnburntTemperatureRatio) / (F2 * m_strouhal);

  m_log << "neutral markstein length (theory) = " << m_marksteinLengthTh << endl << endl;

  // initialize flame tube variables as infinity variables (used also for simulations without plenum, than the flame
  // tube variables are the same as the infinity variables)
  m_temperatureFlameTube = m_TInfinity;
  //  m_jetTemperature = m_burntUnburntTemperatureRatio;

  m_pressureFlameTube = m_PInfinity;
  //  m_jetPressure = m_PInfinity;

  m_velocityFlameTube = m_VInfinity;

  m_rhoFlameTube = m_rhoInfinity;
  //  m_jetDensity = m_rhoInfinity*m_targetDensityFactor;

  if(!(m_initialCondition == 1991 || m_initialCondition == 19911)) {
    m_rhoUnburnt = m_rhoInfinity;

    m_rhoBurnt = m_rhoInfinity / m_burntUnburntTemperatureRatio;
  }
  // needed for DL instability, updated in boundary conditions 17517, 1752
  m_pressureUnburnt = m_PInfinity + m_rhoInfinity * POW2(m_flameSpeed) * (m_burntUnburntTemperatureRatio - F1);

  m_log << "CFL number: " << m_cfl << endl;
  m_log << "smallest Cell distance according to max refinement Level: " << c_cellLengthAtLevel(maxRefinementLevel())
        << endl;

  // update needed for computing the correct burnt and unburnt density values for DL instability growth rate computation
  if(m_restart && (m_initialCondition == 1991 || m_initialCondition == 19911)) {
    // correct burnt unburnt temperature ratio only for restart
    m_log << "corrected m_rhoUnburnt = " << m_rhoUnburnt << endl;
    m_log << "corrected TbTu = " << m_burntUnburntTemperatureRatio << endl;

    m_rhoBurnt = m_rhoUnburnt / m_burntUnburntTemperatureRatio;
    m_log << "corrected m_rhoBurnt = " << m_rhoBurnt << endl;


    // correct thermal diffusivity
    m_DthInfinity = sysEqn().m_muInfinity / (m_rhoUnburnt * m_Pr);
    m_log << "corrected DthInfinity = " << m_DthInfinity << endl;

    m_marksteinLengthTh = (F1 - m_rhoUnburnt * F1 / m_burntUnburntTemperatureRatio) / (F2 * m_strouhal);

    m_log << "corrected neutral markstein length (theory) = " << m_marksteinLengthTh << endl;
    m_log << "perturbation amplitude = " << m_perturbationAmplitude << endl;
    // don't correct rho infinity because it shouldn't be changed for the sponge layer!!!
  }

  // update needed for computing the correct burnt and unburnt density values for DL instability neutral Markstein
  // length computation
  if(m_restart && (m_initialCondition == 1990 || m_initialCondition == 19901)) {
    // correct burnt unburnt temperature ratio only for restart
    m_log << "corrected m_rhoUnburnt (should be set by your properties file) = " << m_rhoUnburnt << endl;
    m_log << "corrected TbTu (should be set by your properties file) = " << m_burntUnburntTemperatureRatio << endl;
    m_rhoBurnt = m_rhoUnburnt / m_burntUnburntTemperatureRatio;
    m_log << "corrected m_rhoBurnt = " << m_rhoBurnt << endl;

    // correct thermal diffusivity
    m_DthInfinity = sysEqn().m_muInfinity / (m_rhoUnburnt * m_Pr);
    m_log << "corrected DthInfinity = " << m_DthInfinity << endl;

    m_marksteinLengthTh = (F1 - m_rhoUnburnt * F1 / m_burntUnburntTemperatureRatio) / (F2 * m_strouhal);

    m_log << "corrected neutral markstein length (theory) = " << m_marksteinLengthTh << endl;
    m_log << "CFL number: " << m_cfl << endl;
    m_log << "smallest Cell distance according to max refinement Level: " << c_cellLengthAtLevel(maxRefinementLevel())
          << endl;

    // calculate actual markstein length
    m_log << "actual used markstein length (should be set by your properties file)" << m_marksteinLength << endl;
  }

  if(m_confinedFlame) {
    m_velocityOutlet = m_rhoInfinity / (m_rhoFlameTube * m_targetDensityFactor) * m_VInfinity * m_inletOutletAreaRatio;
    // nondimensionalization of the mean velocity which is caluclated based on the Ma not on VInf
    m_meanVelocity *= sqrt(m_TInfinity);

    m_meanVelocityOutlet =
        m_rhoInfinity / (m_rhoFlameTube * m_targetDensityFactor) * m_meanVelocity * m_inletOutletAreaRatio;
    m_log << "mean velocity " << m_meanVelocity << endl;
    m_log << "mean velocity outlet" << m_meanVelocityOutlet << endl;

    m_deltaPL = m_rRe0 * sysEqn().m_muInfinity * m_meanVelocity * F3 * m_tubeLength / POW2(m_radiusVelFlameTube);
    m_log << "friction deltaP tube " << m_deltaPL << endl;
    m_deltaPL += m_rRe0 * SUTHERLANDLAW(m_burntUnburntTemperatureRatio) * m_meanVelocityOutlet * F3 * m_outletLength
                 / POW2(m_radiusOutlet);
    m_log << "friction deltaP total " << m_deltaPL << endl;

    MFloat pressureLossFlame = m_rhoInfinity * (m_burntUnburntTemperatureRatio - F1);
    if(m_pressureLossFlameSpeed != 0) {
      pressureLossFlame *= POW2(m_flameSpeed);
    } else {
      pressureLossFlame *= POW2(m_VInfinity);
    }
    pressureLossFlame += m_rhoFlameTube * m_targetDensityFactor * POW2(m_meanVelocityOutlet) * m_flameOutletAreaRatio;
    pressureLossFlame -= m_rhoFlameTube * POW2(m_meanVelocity);
    m_log << "pressureLoss" << pressureLossFlame << endl;
    m_deltaPL += pressureLossFlame;
    m_log << "deltaP total = friction deltaP + pressureLoss " << m_deltaPL << endl;
    m_deltaPL += m_pressureLossCorrection;
    m_log << "deltaP total = friction deltaP + pressureLoss + pressureLossCorrection " << m_deltaPL << endl;
    m_log << " pressure forced at inlet p = pInf + totaldeltaP " << m_PInfinity + m_deltaPL << endl;
    m_meanPressure = m_PInfinity + m_deltaPL;
    m_log << "mean pressure is initialized according to the inlet pressure" << endl;
    m_log << " pressure forced at outlet p = pInf " << m_PInfinity << endl;
  }

  // for flame testcase the reference values are set to the flame tube variables if there is a plenum
  if(m_plenum && !m_confinedFlame) {
    // compute primitive variables of flame tube
    m_temperatureFlameTube = sysEqn().temperature_IR(m_MaFlameTube);

    m_velocityFlameTube = m_MaFlameTube * sqrt(m_temperatureFlameTube);

    m_timeRef = m_velocityFlameTube;
    // compute conservative variables
    m_rhoFlameTube = sysEqn().density_IR(m_temperatureFlameTube);

    // velocity of the outlet needed for target pressure calculation, see spongeLayerLayout 17513, if a plenum and no
    // slip walls are used at the outlet sides
    if(m_combustion && m_plenumWall) {
      m_velocityOutlet =
          m_rhoInfinity / (m_rhoFlameTube * m_targetDensityFactor) * m_VInfinity * m_inletOutletAreaRatio;
    }
    m_pressureFlameTube = sysEqn().pressure_IR(m_temperatureFlameTube);
    sysEqn().m_muInfinity = SUTHERLANDLAW(m_temperatureFlameTube);
    // heat release model (progress variable) assumption of unity Lewis number Le=1 -> lambda(T)=D(T), see Dissertation
    // D.Hartmann page 13
    m_DInfinity = sysEqn().m_muInfinity; ///< Diffusion time (D) equals convection time (lambda) (mu=lambda)
    sysEqn().m_Re0 = m_Re * sysEqn().m_muInfinity / (m_rhoFlameTube * m_MaFlameTube * sqrt(m_temperatureFlameTube));
    m_rRe0 = 1. / sysEqn().m_Re0;
    // - - assuming m_TInfinity is the temperature of the unburnt gas
    // - - Dth = mue^u / ( rho^u *Pr )
    m_DthInfinity = sysEqn().m_muInfinity / (m_rhoFlameTube * m_Pr);

    m_rhoEInfinity = sysEqn().internalEnergy(m_pressureFlameTube, m_rhoFlameTube, POW2(m_velocityFlameTube));

    // pressure loss inlet -> tube
    pressureLoss = m_rhoInfinity * POW2(m_VInfinity) * (m_inletTubeAreaRatio - F1);

    m_log << "***************************************************************************" << endl;
    m_log << "Plenum - Computation:" << endl;
    m_log << "Initial Condition summary referred to the averaged values of the flame tube" << endl;
    m_log << "***************************************************************************" << endl;
    m_log << "Re  = " << m_Re << endl;
    m_log << "Re0 (used in code) = " << sysEqn().m_Re0 << endl;
    m_log << "Ma_fl (used in code) = " << m_MaFlameTube << endl;
    m_log << "T_fl = " << m_temperatureFlameTube << endl;
    m_log << "V_fl = " << m_velocityFlameTube << endl;
    m_log << "P_fl = " << m_pressureFlameTube << endl;
    m_log << "rho_fl (used in code) = " << m_rhoFlameTube << endl;
    m_log << "rhoEInfinity (used in code) = " << m_rhoEInfinity << endl;
    m_log << "mu_Infinity (used in code) = " << sysEqn().m_muInfinity << endl;
    m_log << "D_Infinity (used in code) = " << m_DInfinity << endl;
    m_log << "Dth_Infinity (used in code) = " << m_DthInfinity << endl << endl;
    m_log << "Tb/Tu (used in code) = " << m_burntUnburntTemperatureRatio << endl << endl;

    if(m_plenumWall) {
      m_log << "******************************************************************" << endl;
      m_log << "Plenum + Wall - Computation:" << endl;
      m_log << "Additional information for the use of no slip walls at the outlet:" << endl;
      m_log << "******************************************************************" << endl;
      m_log << "inletOutletAreaRatio = " << m_inletOutletAreaRatio << endl;
      m_log << "inletTubeAreaRatio = " << m_inletTubeAreaRatio << endl;
      m_log << "flameOutletAreaRatio = " << m_flameOutletAreaRatio << endl;
      m_log << "averaged velocity outlet = " << m_velocityOutlet << endl;
      m_log << "Calculating additional pressure loss ... " << pressureLoss << endl;

      pressureLoss += m_rhoFlameTube * m_targetDensityFactor
                      * (POW2(m_velocityOutlet) - POW2(m_flameSpeed) * m_flameOutletAreaRatio);
    }
    // pressure loss = pressure loss (inlet -> tube) + pressure loss (tube -> outlet )
    m_log << "pressure loss = " << pressureLoss << endl;
  }

  if(m_confinedFlame) {
    m_log << "******************************************************************" << endl;
    m_log << "Confined flame - Computation:" << endl;
    m_log << "Additional information for the use of no slip walls at the outlet:" << endl;
    m_log << "******************************************************************" << endl;
    m_log << "inletOutletAreaRatio = " << m_inletOutletAreaRatio << endl;
    m_log << "flameOutletAreaRatio = " << m_flameOutletAreaRatio << endl;
    m_log << "averaged velocity outlet = " << m_velocityOutlet << endl;
    m_log << "Calculating additional pressure loss ... " << pressureLoss << endl;

    //    pressureLoss +=
    //        m_rhoFlameTube * m_targetDensityFactor * (POW2(m_velocityOutlet) - POW2(m_flameSpeed) *
    //        m_flameOutletAreaRatio);
  }


  IF_CONSTEXPR(nDim == 3) {
    // turb flame speed contribution Pitsch et al. 2005
    MFloat FDL = 1 / m_DthInfinity;
    MFloat DL = m_DthInfinity;
    MFloat b3T = 1.0;
    MFloat b1T = 2.0;
    //  MFloat m_ScT = 0.4; // Pitsch et al. 2005 and 2000 (0.5) -> a constant value can be used
    //  MFloat m_NuT = 0.0017169;// max value determined from cold jet with grid refinement r11 at y=-0.5

    MFloat Dt = m_NuT / m_ScT;
    // lam. flame speed
    MFloat flameSpeed = m_flameSpeed;

    MFloat delta = c_cellLengthAtLevel(maxLevel()); // LES filter width equals grid siz
    MFloat uAmpl = pow(m_integralAmplitude, 3);     // filtered velocity
    uAmpl *= delta;
    uAmpl /= m_integralLengthScale;
    uAmpl = pow(uAmpl, F1B3);                                      // filtered velocity Pitsch et al. 2005
    m_Da = flameSpeed * delta / (uAmpl * m_laminarFlameThickness); // Eq. 2 in Pitsch et al. 2002

    MFloat bFactor = pow(b3T, 2) / (F2 * b1T * m_ScT);

    bFactor *= m_NuT * FDL * m_flameSpeed / uAmpl;

    MFloat b3Factor = pow(b3T, 2) * m_NuT;
    b3Factor /= (m_ScT * DL);

    // -bFactor + sqrt(bFactor + b3Factor)
    MFloat turbFlameSpeed = -bFactor;
    turbFlameSpeed += sqrt(pow(bFactor, 2) + b3Factor);
    turbFlameSpeed *= m_flameSpeed;

    m_turbFlameSpeed = turbFlameSpeed;
    m_log << "Da = " << m_Da << endl;
    MFloat Ka = sqrt(pow((uAmpl / m_flameSpeed), 3) * m_laminarFlameThickness / delta);
    m_log << "Ka = " << Ka << endl;

    m_log << "turbulent flame speed = " << m_turbFlameSpeed << endl;
    m_log << "turbulent flame speed/lam flame speed = " << m_turbFlameSpeed / m_flameSpeed << endl;

    MFloat FDa = Dt;
    if(m_Da > 1) {
      FDa *= F1 / pow(m_Da, 2);
      m_log << "Pitsch model for Da > 1 " << endl;
    } else {
      m_log << "Pitsch model for Da < 1 " << endl;
    }
    m_log << "turbulent diffusivity D_tk = " << FDa << endl;
    m_log << "ratio of integral velocity to flame speed " << m_integralAmplitude / m_flameSpeed << endl;
  }
}
//----------------------------------------------------------------------------


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::resetRHS() {
  TRACE();

  const MInt noFVars = FV->noVariables;
  //---

#ifdef _OPENMP
#pragma omp parallel for collapse(2)
#endif
  for(MInt id = 0; id < a_noCells(); id++) {
    for(MInt varId = 0; varId < noFVars; varId++) {
      a_rightHandSide(id, varId) = F0;
    }
  }
}


//----------------------------------------------------------------------------


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computePV() {
  TRACE();

  copyVarsToSmallCells();

  if(m_gridInterfaceFilter) {
    filterConservativeVariablesAtFineToCoarseGridInterfaces();
  }

  computePrimitiveVariables();
}


//----------------------------------------------------------------------------

/**
 * \compute centrifugal and coriolis forces (for computations in a rotating frame of reference)
 * \author Alexej Pogorelov
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeRotForces() {
  MFloat radius = NAN;
  MFloat v_t = NAN;
  MInt cellId = 0;

  for(MInt ac = 0; ac < m_noActiveCells; ac++) {
    cellId = m_activeCellIds[ac];
    radius = 0.0;

    for(MInt i = 0; i < 2; i++) {
      radius += pow(a_coordinate(cellId, i + 1) - m_rotAxisCoord[i], 2.0);
    }
    radius = sqrt(radius);


    MFloat phi_mid = 74.9355804414;
    MFloat v_t_mid = m_UInfinity * sin(phi_mid / 180.0 * PI);
    v_t = v_t_mid / ((150.0 + 67.5) / 2.0) * radius;

    // momentum equation
    a_rightHandSide(m_activeCellIds[ac], CV->RHO_VV[1]) -=
        a_cellVolume(m_activeCellIds[ac])
        * (F2 * v_t * a_pvariable(cellId, PV->RHO) * a_pvariable(cellId, PV->W) / radius
           + a_pvariable(cellId, PV->RHO) * pow(v_t / radius, 2.0) * (a_coordinate(cellId, 1) - m_rotAxisCoord[0]));

    a_rightHandSide(m_activeCellIds[ac], CV->RHO_VV[2]) -=
        a_cellVolume(m_activeCellIds[ac])
        * (-F2 * v_t * a_pvariable(cellId, PV->RHO) * a_pvariable(cellId, PV->V) / radius
           + a_pvariable(cellId, PV->RHO) * pow(v_t / radius, 2.0) * (a_coordinate(cellId, 2) - m_rotAxisCoord[1]));

    // energy equation
    IF_CONSTEXPR(hasE<SysEqn>)
    a_rightHandSide(m_activeCellIds[ac], CV->RHO_E) -=
        a_cellVolume(m_activeCellIds[ac]) * a_pvariable(cellId, PV->RHO) * pow(v_t / radius, 2.0)
        * ((a_coordinate(cellId, 1) - m_rotAxisCoord[0]) * a_pvariable(cellId, PV->V)
           + (a_coordinate(cellId, 2) - m_rotAxisCoord[1]) * a_pvariable(cellId, PV->W));
  }
}

/**
 *
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeVolumeForces() {
  TRACE();
  // Volume forces are added in rhsEEGas() if m_isEEGas
  if(m_isEEGas) return;

#ifdef _OPENMP
#pragma omp parallel for collapse(2)
#endif
  for(MInt ac = 0; ac < m_noActiveCells; ac++) {
    for(MInt i = 0; i < nDim; i++) {
      a_rightHandSide(m_activeCellIds[ac], CV->RHO_VV[i]) -=
          a_pvariable(m_activeCellIds[ac], PV->RHO) * m_volumeAcceleration[i] * a_cellVolume(m_activeCellIds[ac]);
      IF_CONSTEXPR(hasE<SysEqn>)
      a_rightHandSide(m_activeCellIds[ac], CV->RHO_E) -= a_pvariable(m_activeCellIds[ac], PV->VV[i])
                                                         * a_pvariable(m_activeCellIds[ac], PV->RHO)
                                                         * m_volumeAcceleration[i] * a_cellVolume(m_activeCellIds[ac]);
    }
  }
}


template <MInt nDim_, class SysEqn>
MInt FvCartesianSolverXD<nDim_, SysEqn>::samplingInterval() {
  TRACE();
  return mMax(1, (MInt)(F1 / (timeStep() * m_timeRef * m_sampleRate)));
}


/** \brief parallel: Store all necessary data in send buffer
 *  \author Lennart Schneiders
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initializeMaxLevelExchange() {
  TRACE();

  if(noNeighborDomains() == 0) return;

  ScratchSpace<MInt> haloCellsCnt(noNeighborDomains(), AT_, "noHaloCells");
  ScratchSpace<MInt> windowCellsCnt(noNeighborDomains(), AT_, "noWindowCells");
  for(MInt d = 0; d < noNeighborDomains(); d++) {
    haloCellsCnt[d] = noHaloCells(d);
    windowCellsCnt[d] = noWindowCells(d);
  }

  mDeallocate(m_maxLevelHaloCells);
  mAlloc(m_maxLevelHaloCells, noNeighborDomains(), &haloCellsCnt[0], "m_maxLevelHaloCells", AT_);
  mDeallocate(m_maxLevelWindowCells);
  mAlloc(m_maxLevelWindowCells, noNeighborDomains(), &windowCellsCnt[0], "m_maxLevelWindowCells", AT_);

  ScratchSpace<MInt> isOnMaxLevel(a_noCells(), AT_, "isOnMaxLevel");
  isOnMaxLevel.fill(0);

  for(MInt i = 0; i < noNeighborDomains(); i++) {
    m_noMaxLevelHaloCells[i] = 0;
    for(MInt j = 0; j < noHaloCells(i); j++) {
      if(!a_hasProperty(haloCellId(i, j), SolverCell::IsOnCurrentMGLevel)) {
        continue;
      }
      m_maxLevelHaloCells[i][m_noMaxLevelHaloCells[i]] = haloCellId(i, j);
      m_noMaxLevelHaloCells[i]++;
      isOnMaxLevel(haloCellId(i, j)) = 1;
    }
  }

  MUint recvSize = maia::mpi::getBufferSize(grid().windowCells());
  ScratchSpace<MInt> recvBuffer(mMax(1u, recvSize), AT_, "recvBuffer");
  maia::mpi::reverseExchangeData(grid().neighborDomains(), grid().haloCells(), grid().windowCells(), mpiComm(),
                                 &isOnMaxLevel[0], &recvBuffer[0]);

  recvSize = 0;
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    m_noMaxLevelWindowCells[i] = 0;
    for(MInt j = 0; j < noWindowCells(i); j++) {
      if(recvBuffer[recvSize]) {
        // ASSERT(a_hasProperty(windowCellId(i, j), SolverCell::IsOnCurrentMGLevel), "");
        m_maxLevelWindowCells[i][m_noMaxLevelWindowCells[i]] = windowCellId(i, j);
        m_noMaxLevelWindowCells[i]++;
      }
      recvSize++;
    }
  }

  prepareMpiExchange();

  if(grid().noAzimuthalNeighborDomains() > 0) {
    initAzimuthalMaxLevelExchange();
  }

  initNearBoundaryExchange();
}


// Prepare persistent MPI requests for start/finish MpiExchange and exchange
// of primitive variable exchange during lhsBndry formulation
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::prepareMpiExchange() {
  TRACE();


  if(m_nonBlockingComm) {
    m_maxLvlMpiSendNeighbor.clear();
    m_maxLvlMpiRecvNeighbor.clear();
    MInt noSendNghbrs = 0;
    MInt noRecvNghbrs = 0;


    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_mpi_receiveRequest[i] != MPI_REQUEST_NULL) {
        MPI_Request_free(&m_mpi_receiveRequest[i], AT_);
      }
      if(m_mpi_sendRequest[i] != MPI_REQUEST_NULL) {
        MPI_Request_free(&m_mpi_sendRequest[i], AT_);
      }
    }

    for(MInt i = 0; i < noNeighborDomains(); i++) {
      MInt bufferCounter = m_noMaxLevelHaloCells[i] * m_dataBlockSize;
      if(bufferCounter > 0) {
        MPI_Recv_init(m_receiveBuffersNoBlocking[i], bufferCounter, MPI_DOUBLE, neighborDomain(i), MAIA_MPI_FV_TAG,
                      mpiComm(), &m_mpi_receiveRequest[noRecvNghbrs], AT_, "m_receiveBuffersNoBlocking[i]");
        m_maxLvlMpiRecvNeighbor.push_back(i);
        noRecvNghbrs++;
      }
      bufferCounter = m_noMaxLevelWindowCells[i] * m_dataBlockSize;
      if(bufferCounter > 0) {
        MPI_Send_init(m_sendBuffersNoBlocking[i], bufferCounter, MPI_DOUBLE, neighborDomain(i), MAIA_MPI_FV_TAG,
                      mpiComm(), &m_mpi_sendRequest[noSendNghbrs], AT_, "m_sendBuffersNoBlocking[i]");
        m_maxLvlMpiSendNeighbor.push_back(i);
        noSendNghbrs++;
      }
    }
    // Set status of MPI requests
    m_mpiSendRequestsOpen = false;
    m_mpiRecvRequestsOpen = false;
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::exchangeAll() {
  TRACE();

  RECORD_TIMER_START(m_tcomm);
  RECORD_TIMER_START(m_texchange);

  gather<true>();
  send(true);
  receive(true);
  scatter<true>();

  if(grid().azimuthalPeriodicity()) {
    exchangeFloatDataAzimuthal(&a_pvariable(0, 0), PV->noVariables, m_rotIndVarsPV);
  }


  RECORD_TIMER_STOP(m_texchange);
  RECORD_TIMER_STOP(m_tcomm);
}

//----------------------------------------------------------------------------


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::exchange() {
  TRACE();

  RECORD_TIMER_START(m_tcomm);
  RECORD_TIMER_START(m_texchange);

  // periodic exchange is included in normal window and halo cell exchange, quasi periodic exchange is not yet applied
  if(!m_nonBlockingComm) {
    gather<false>();
    send();
    receive();
    scatter<false>();

  } else {
    if(grid().azimuthalPeriodicity()) {
      mTerm(1, AT_, "non blocking comm is not implemented for azimuthal periodicity");
    }
    startMpiExchange();
    finishMpiExchange();
  }

  if(grid().azimuthalPeriodicity()) {
    exchangeFloatDataAzimuthal<false>(&a_pvariable(0, 0), PV->noVariables, m_rotIndVarsPV);
  }
  RECORD_TIMER_STOP(m_texchange);
  RECORD_TIMER_STOP(m_tcomm);

  if(m_wmLES && m_RKStep == m_noRKSteps - 1) {
    RECORD_TIMER_START(m_timers[Timers::WMExchange]);
    exchangeWMVars();
    RECORD_TIMER_STOP(m_timers[Timers::WMExchange]);
  }

  // DISPLAY_TIMER_OFFSET(m_tcomm, m_restartInterval);
}

/// \brief Begin non-blocking communication by posting new send requests.
///
/// \author Michael Schlottke-Lakemper (mic) <mic@aia.rwth-aachen.de>
/// \date 2016-11-16
///
/// First, waits for previous send requests to finish.
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::startMpiExchange() {
  TRACE();

  // SEND: Wait for old send requests to finish (blocking)
  RECORD_TIMER_START(m_tgatherAndSend);
  RECORD_TIMER_START(m_tgatherAndSendWait);
  if(m_mpiSendRequestsOpen) {
    MPI_Waitall((MInt)m_maxLvlMpiSendNeighbor.size(), m_mpi_sendRequest, MPI_STATUSES_IGNORE, AT_);
  }
  RECORD_TIMER_STOP(m_tgatherAndSendWait);

  // Start receive requests if not already open
  if(!m_mpiRecvRequestsOpen) {
    MPI_Startall((MInt)m_maxLvlMpiRecvNeighbor.size(), m_mpi_receiveRequest, AT_);
    m_mpiRecvRequestsOpen = true;
  }

  // SEND: Fill send buffer and start sending (non-blocking)
  for(MInt i = 0; i < (MInt)m_maxLvlMpiSendNeighbor.size(); i++) {
    const MInt completedId = m_maxLvlMpiSendNeighbor[i];
    MInt bufferCounter = 0;
    for(MInt j = 0; j < m_noMaxLevelWindowCells[completedId]; j++) {
      copy_n(&a_pvariable(m_maxLevelWindowCells[completedId][j], 0),
             PV->noVariables,
             &m_sendBuffersNoBlocking[completedId][bufferCounter]);
      bufferCounter += m_dataBlockSize;
    }
  }

  MPI_Startall((MInt)m_maxLvlMpiSendNeighbor.size(), m_mpi_sendRequest, AT_);

  m_mpiSendRequestsOpen = true;

  RECORD_TIMER_STOP(m_tgatherAndSend);
}


/// \brief Finish non-blocking communication by waiting for receive requests.
///
/// \author Michael Schlottke-Lakemper (mic) <mic@aia.rwth-aachen.de>
/// \date 2016-11-16
///
/// Afterwards, new receive requests are posted.
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::finishMpiExchange() {
  TRACE();

  if(!m_mpiRecvRequestsOpen) {
    mTerm(1, "MPI receive requests are not open.");
  }

  MBool useWaitsome = false; // true;
  RECORD_TIMER_START(m_tscatter);

  if(useWaitsome) {
    const MBool loadWasRunning = this->isLoadTimerRunning();
    if(loadWasRunning) {
      this->stopLoadTimer(AT_);
      this->startIdleTimer(AT_);
      this->disableDlbTimers();
    }

    // RECV: Wait for old receive requests to finish (blocking) and unpack buffers
    MIntScratchSpace completedIds(noNeighborDomains(), AT_, "completedIds");
    while(true) {
      // Wait for old receive requests (blocking)
      MInt noCompleted = 0;
      RECORD_TIMER_START(m_tscatterWaitSome);
      MPI_Waitsome((MInt)m_maxLvlMpiRecvNeighbor.size(), m_mpi_receiveRequest, &noCompleted, &completedIds[0],
                   MPI_STATUSES_IGNORE, AT_);
      RECORD_TIMER_STOP(m_tscatterWaitSome);

      // Exit loop if no more unfinished requests are found
      if(noCompleted == MPI_UNDEFINED) {
        break;
      }

      // Unpack buffers
      for(MInt i = 0; i < noCompleted; i++) {
        const MInt completedId = completedIds[i];
        MInt bufferCounter = 0;
        for(MInt j = 0; j < m_noMaxLevelHaloCells[completedId]; j++) {
          copy_n(&m_receiveBuffersNoBlocking[completedId][bufferCounter],
                 m_dataBlockSize,
                 &a_pvariable(m_maxLevelHaloCells[completedId][j], 0));
          bufferCounter += m_dataBlockSize;
        }
      }
    }

    if(loadWasRunning) {
      this->reEnableDlbTimers();
      this->stopIdleTimer(AT_);
      this->startLoadTimer(AT_);
    }
  } else {
    RECORD_TIMER_START(m_tscatterWaitSome);
    MPI_Waitall((MInt)m_maxLvlMpiRecvNeighbor.size(), m_mpi_receiveRequest, MPI_STATUSES_IGNORE, AT_);
    RECORD_TIMER_STOP(m_tscatterWaitSome);

    // Unpack all buffers
    // for(MInt i = 0; i < noNeighborDomains(); i++) {
    for(MInt n = 0; n < (MInt)m_maxLvlMpiRecvNeighbor.size(); n++) {
      const MInt i = m_maxLvlMpiRecvNeighbor[n];
      MInt bufferCounter = 0;
      for(MInt j = 0; j < m_noMaxLevelHaloCells[i]; j++) {
        std::copy_n(&m_receiveBuffersNoBlocking[i][bufferCounter], m_dataBlockSize,
                    &a_pvariable(m_maxLevelHaloCells[i][j], 0));
        bufferCounter += m_dataBlockSize;
      }
    }
  }

  RECORD_TIMER_STOP(m_tscatter);

  // RECV: Start receiving (non-blocking)
  // open new receive
  RECORD_TIMER_START(m_treceive);
  MPI_Startall((MInt)m_maxLvlMpiRecvNeighbor.size(), m_mpi_receiveRequest, AT_);
  m_mpiRecvRequestsOpen = true;
  RECORD_TIMER_STOP(m_treceive);
}


/// \brief Cancel open MPI (receive) requests
///
/// Cancel opened receive request that do not have a matching send initiated yet.
/// Note: canceling send requests might cause MPI errors depending on the MPI implementation.
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::cancelMpiRequests() {
  TRACE();

  // Make sure all send requests are completed
  if(m_mpiSendRequestsOpen) {
    MPI_Waitall((MInt)m_maxLvlMpiSendNeighbor.size(), m_mpi_sendRequest, MPI_STATUSES_IGNORE, AT_);
    m_mpiSendRequestsOpen = false;
  }

  // Cancel opened receive requests
  if(m_mpiRecvRequestsOpen) {
    std::vector<MBool> waitForCancel(noNeighborDomains(), false);
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_mpi_receiveRequest[i] != MPI_REQUEST_NULL) {
        MPI_Cancel(&m_mpi_receiveRequest[i], AT_);
        waitForCancel[i] = true;
      }
    }
    // Wait for all requests until they are canceled
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(waitForCancel[i]) {
        MPI_Wait(&m_mpi_receiveRequest[i], MPI_STATUS_IGNORE, AT_);
      }
    }
    m_mpiRecvRequestsOpen = false;
  }
}


/// \brief Finalize non-blocking MPI communication (cancel open requests, free all requests)
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::finalizeMpiExchange() {
  // Cancel and free MPI requests
  if(m_nonBlockingComm && noNeighborDomains() > 0) {
    // Wait for open send requests to finish
    if(m_mpiSendRequestsOpen) {
      MPI_Waitall((MInt)m_maxLvlMpiSendNeighbor.size(), m_mpi_sendRequest, MPI_STATUSES_IGNORE, AT_);
    }

    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_mpi_receiveRequest != nullptr) {
        if(m_mpi_receiveRequest[i] != MPI_REQUEST_NULL) {
          // Cancel opened receive request that do not have a matching send initiated yet
          if(m_mpiRecvRequestsOpen) {
            MPI_Cancel(&m_mpi_receiveRequest[i], AT_);
          }
          MPI_Request_free(&m_mpi_receiveRequest[i], AT_);
        }
      }
      if(m_mpi_sendRequest != nullptr) {
        if(m_mpi_sendRequest[i] != MPI_REQUEST_NULL) {
          // Free send request (cannot be canceled)
          MPI_Request_free(&m_mpi_sendRequest[i], AT_);
        }
      }
    }

    m_mpiSendRequestsOpen = false;
    m_mpiRecvRequestsOpen = false;
  }
}


//----------------------------------------------------------------------------


/**
 * \exchanges PV at periodic bc (azimuthal periodicity concept)
 * \author Alexej Pogorelov, Sven Berger
 * TODO labels:FV move the periodicCells into the cartesain grid and treat just as halo-cells
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::exchangePeriodic() {
  if(m_periodicCells > 0 && m_periodicCells != 3) {
    // init
    MFloat v_comp = 0;
    MFloat w_comp = 0;
    MFloat rot_times = 0;
    MInt n_Id = -1;
    MInt off_ = 0;

    if(m_periodicCells == 1) {
      for(MInt d = 0; d < noDomains(); d++) {
        // No OMP possible here because off_ needs to be sequentially increased...
        for(MInt c = 0; c < m_noPerCellsToSend[d]; c++) {
          const auto sortedId = static_cast<MInt>(m_periodicDataToSend[d][5 + c * m_noPeriodicData]);

          v_comp = F0;
          w_comp = F0;
          m_periodicDataToSend[d][0 + c * m_noPeriodicData] = F0;
          m_periodicDataToSend[d][1 + c * m_noPeriodicData] = F0;
          m_periodicDataToSend[d][2 + c * m_noPeriodicData] = F0;
          m_periodicDataToSend[d][3 + c * m_noPeriodicData] = F0;
          m_periodicDataToSend[d][4 + c * m_noPeriodicData] = F0;

          // LS interpolation
          MInt noNeighboursRec =
              (m_reconstructionDataPeriodic[off_ + c + 1] - m_reconstructionDataPeriodic[off_ + c]) / 2;
          for(MInt n = (m_reconstructionDataPeriodic[off_ + c] + noNeighboursRec);
              n < m_reconstructionDataPeriodic[off_ + c + 1];
              n++) {
            n_Id = static_cast<MInt>(m_reconstructionConstantsPeriodic[n - noNeighboursRec]);

            v_comp += m_reconstructionConstantsPeriodic[n] * a_pvariable(n_Id, PV->VV[1]);
            w_comp += m_reconstructionConstantsPeriodic[n] * a_pvariable(n_Id, PV->VV[2]);

            m_periodicDataToSend[d][0 + c * m_noPeriodicData] +=
                m_reconstructionConstantsPeriodic[n] * a_pvariable(n_Id, PV->RHO);
            m_periodicDataToSend[d][1 + c * m_noPeriodicData] +=
                m_reconstructionConstantsPeriodic[n] * a_pvariable(n_Id, PV->VV[0]);
            m_periodicDataToSend[d][4 + c * m_noPeriodicData] +=
                m_reconstructionConstantsPeriodic[n] * a_pvariable(n_Id, PV->P);
          }


          if(m_periodicCellDataDom[d][4 + sortedId * m_noPeriodicCellData] < 0.0) // left Cells ..rotate anticlockwise
          {
            rot_times = -m_periodicCellDataDom[d][4 + sortedId * m_noPeriodicCellData];
            m_periodicDataToSend[d][2 + c * m_noPeriodicData] =
                cos(72.0 / 180.0 * PI * rot_times) * v_comp + sin(72.0 / 180.0 * PI * rot_times) * w_comp;
            m_periodicDataToSend[d][3 + c * m_noPeriodicData] =
                -sin(72.0 / 180.0 * PI * rot_times) * v_comp + cos(72.0 / 180.0 * PI * rot_times) * w_comp;
          } else { // right cells ..rotate clockwise
            rot_times = m_periodicCellDataDom[d][4 + sortedId * m_noPeriodicCellData];
            m_periodicDataToSend[d][2 + c * m_noPeriodicData] =
                cos(72.0 / 180.0 * PI * rot_times) * v_comp - sin(72.0 / 180.0 * PI * rot_times) * w_comp;
            m_periodicDataToSend[d][3 + c * m_noPeriodicData] =
                sin(72.0 / 180.0 * PI * rot_times) * v_comp + cos(72.0 / 180.0 * PI * rot_times) * w_comp;
          }
        }
        off_ += m_noPerCellsToSend[d];
      }
    } else if(m_periodicCells == 2) {
      for(MInt d = 0; d < noDomains(); d++) {
        for(MInt c = 0; c < m_noPerCellsToSend[d]; c++) {
          const auto cell_Id = static_cast<MInt>(m_periodicDataToSend[d][6 + c * m_noPeriodicData]);

          m_periodicDataToSend[d][0 + c * m_noPeriodicData] = a_pvariable(cell_Id, PV->RHO);
          m_periodicDataToSend[d][1 + c * m_noPeriodicData] = a_pvariable(cell_Id, PV->U);
          m_periodicDataToSend[d][2 + c * m_noPeriodicData] = a_pvariable(cell_Id, PV->V);
          m_periodicDataToSend[d][3 + c * m_noPeriodicData] = a_pvariable(cell_Id, PV->W);
          m_periodicDataToSend[d][4 + c * m_noPeriodicData] = a_pvariable(cell_Id, PV->P);
        }
      }
    }

    // set Data for current domain
    for(MInt c = 0; c < m_noPerCellsToSend[domainId()]; c++) {
      for(MInt v = 0; v < 7; v++) {
        m_periodicDataToReceive[domainId()][v + c * m_noPeriodicData] =
            m_periodicDataToSend[domainId()][v + c * m_noPeriodicData];
      }
    }


    // exchange interpolated PV Variables
    ScratchSpace<MPI_Request> send_Req(noDomains(), AT_, "sendReq");
    ScratchSpace<MPI_Request> recv_Req(noDomains(), AT_, "recvReq");
    send_Req.fill(MPI_REQUEST_NULL);
    recv_Req.fill(MPI_REQUEST_NULL);


    for(MInt snd = 0; snd < domainId(); snd++) {
      if(m_noPerCellsToReceive[snd] > 0) {
        MInt bufSize = m_noPerCellsToReceive[snd] * m_noPeriodicData;
        MPI_Irecv(m_periodicDataToReceive[snd], bufSize, MPI_DOUBLE, snd, 0, mpiComm(), &recv_Req[snd], AT_,
                  "m_periodicDataToReceive[snd]");
      }
    }

    for(MInt rcv = 0; rcv < noDomains(); rcv++) {
      if(m_noPerCellsToSend[rcv] > 0 && rcv != domainId()) {
        MInt bufSize = m_noPerCellsToSend[rcv] * m_noPeriodicData;
        MPI_Isend(m_periodicDataToSend[rcv], bufSize, MPI_DOUBLE, rcv, 0, mpiComm(), &send_Req[rcv], AT_,
                  "m_periodicDataToSend[rcv]");
      }
    }

    if(domainId() < noDomains() - 1) {
      for(MInt snd = domainId() + 1; snd < noDomains(); snd++) {
        if(m_noPerCellsToReceive[snd] > 0) {
          MInt bufSize = m_noPerCellsToReceive[snd] * m_noPeriodicData;
          MPI_Irecv(m_periodicDataToReceive[snd], bufSize, MPI_DOUBLE, snd, 0, mpiComm(), &recv_Req[snd], AT_,
                    "m_periodicDataToReceive[snd]");
        }
      }
    }


    MPI_Waitall(noDomains(), &recv_Req[0], MPI_STATUSES_IGNORE, AT_);
    MPI_Waitall(noDomains(), &send_Req[0], MPI_STATUSES_IGNORE, AT_);


    for(MInt d = 0; d < noDomains(); d++) {
      for(MInt c = 0; c < m_noPerCellsToReceive[d]; c++) {
        const auto sortedId = static_cast<MInt>(m_periodicDataToReceive[d][5 + c * m_noPeriodicData]);
        const MInt cell_Id = m_sortedPeriodicCells->a[sortedId];

        a_pvariable(cell_Id, PV->RHO) = m_periodicDataToReceive[d][0 + c * m_noPeriodicData];
        a_pvariable(cell_Id, PV->U) = m_periodicDataToReceive[d][1 + c * m_noPeriodicData];
        a_pvariable(cell_Id, PV->V) = m_periodicDataToReceive[d][2 + c * m_noPeriodicData];
        a_pvariable(cell_Id, PV->W) = m_periodicDataToReceive[d][3 + c * m_noPeriodicData];
        a_pvariable(cell_Id, PV->P) = m_periodicDataToReceive[d][4 + c * m_noPeriodicData];
      }
    }
    computeConservativeVariables();
  }

  if(m_periodicCells == 3) {
    exchangePipe(); // volume forcing for periodic pipe
  }
}


/**
 * \exchanges PV for periodic pipe with volume forcing
 * \author Alexej Pogorelov, Sven Berger
 *         TODO labels:FV move the periodicCells into the cartesain grid and treat just as halo-cells!
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::exchangePipe() {
  for(MInt d = 0; d < noDomains(); d++) {
    for(MInt c = 0; c < m_noPerCellsToSend[d]; c++) {
      const auto cell_Id = static_cast<MInt>(m_periodicDataToSend[d][6 + c * m_noPeriodicData]);

      m_periodicDataToSend[d][0 + c * m_noPeriodicData] = a_pvariable(cell_Id, PV->RHO);
      m_periodicDataToSend[d][1 + c * m_noPeriodicData] = a_pvariable(cell_Id, PV->U);
      m_periodicDataToSend[d][2 + c * m_noPeriodicData] = a_pvariable(cell_Id, PV->V);
      m_periodicDataToSend[d][3 + c * m_noPeriodicData] = a_pvariable(cell_Id, PV->W);
      m_periodicDataToSend[d][4 + c * m_noPeriodicData] = a_pvariable(cell_Id, PV->P);
    }
  }

  // set Data for current domain
  for(MInt c = 0; c < m_noPerCellsToSend[domainId()]; c++) {
    for(MInt v = 0; v < 7; v++) {
      m_periodicDataToReceive[domainId()][v + c * 7] = m_periodicDataToSend[domainId()][v + c * m_noPeriodicData];
    }
  }

  // exchange interpolated PV Variables
  ScratchSpace<MPI_Request> send_Req(noDomains(), AT_, "sendReq");
  ScratchSpace<MPI_Request> recv_Req(noDomains(), AT_, "recvReq");
  send_Req.fill(MPI_REQUEST_NULL);
  recv_Req.fill(MPI_REQUEST_NULL);


  // MPI_Status status;

  for(MInt snd = 0; snd < domainId(); snd++) {
    if(m_noPerCellsToReceive[snd] > 0) {
      MInt bufSize = m_noPerCellsToReceive[snd] * m_noPeriodicData;
      MPI_Irecv(m_periodicDataToReceive[snd], bufSize, MPI_DOUBLE, snd, 0, mpiComm(), &recv_Req[snd], AT_,
                "m_periodicDataToReceive[snd]");
    }
  }

  for(MInt rcv = 0; rcv < noDomains(); rcv++) {
    if(m_noPerCellsToSend[rcv] > 0 && rcv != domainId()) {
      MInt bufSize = m_noPerCellsToSend[rcv] * m_noPeriodicData;
      MPI_Isend(m_periodicDataToSend[rcv], bufSize, MPI_DOUBLE, rcv, 0, mpiComm(), &send_Req[rcv], AT_,
                "m_periodicDataToSend[rcv]");
    }
  }

  if(domainId() < noDomains() - 1) {
    for(MInt snd = domainId() + 1; snd < noDomains(); snd++) {
      if(m_noPerCellsToReceive[snd] > 0) {
        MInt bufSize = m_noPerCellsToReceive[snd] * m_noPeriodicData;
        MPI_Irecv(m_periodicDataToReceive[snd], bufSize, MPI_DOUBLE, snd, 0, mpiComm(), &recv_Req[snd], AT_,
                  "m_periodicDataToReceive[snd]");
      }
    }
  }

  MPI_Waitall(noDomains(), &recv_Req[0], MPI_STATUSES_IGNORE, AT_);
  MPI_Waitall(noDomains(), &send_Req[0], MPI_STATUSES_IGNORE, AT_);

  // inlet
  MFloat area = 0;
  MFloat localArea = 0;
  MFloat globalArea = 0;
  MFloat localPressure_1 = 0;
  MFloat globalPressure_1 = 0;
  MFloat localPressure_2 = 0;
  MFloat globalPressure_2 = 0;
  MFloat localMass = 0;
  MFloat globalMass = 0;
  MFloat localUbulk = 0;
  MFloat globalUbulk = 0;
  MFloat localDensity_2 = 0;
  MFloat globalDensity_2 = 0;
  MFloat localMeanMach_2 = 0;
  MFloat globalMeanMach_2 = 0;

  for(MInt d = 0; d < noDomains(); d++) {
    for(MInt c = 0; c < m_noPerCellsToReceive[d]; c++) {
      const auto sortedId = static_cast<MInt>(m_periodicDataToReceive[d][5 + c * m_noPeriodicData]);
      const MInt cell_Id = m_sortedPeriodicCells->a[sortedId];

      // inlet
      if(a_hasNeighbor(cell_Id, 0) == 0 && a_isHalo(cell_Id) == false) {
        MInt nghbrId = c_neighborId(cell_Id, 1);
        MInt bndryId = a_bndryId(nghbrId);


        if(bndryId > -1) {
          MFloat vfrac = m_bndryCells->a[bndryId].m_volume / POW3(c_cellLengthAtCell(nghbrId));
          MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[1];
          if(srfcId > -1) {
            area = POW2(c_cellLengthAtCell(cell_Id)) * vfrac;
          } else {
            mTerm(1, AT_, "something went wrong!");
          }
        } else {
          area = POW2(c_cellLengthAtCell(cell_Id)); // m_lengthLevel0 / FPOW2( a_level( cell_Id )));
        }

        localPressure_1 += area * a_pvariable(cell_Id, PV->P);
        localMeanMach_2 += area
                           * sqrt(m_periodicDataToReceive[d][1 + c * m_noPeriodicData]
                                      * m_periodicDataToReceive[d][1 + c * m_noPeriodicData]
                                  + m_periodicDataToReceive[d][2 + c * m_noPeriodicData]
                                        * m_periodicDataToReceive[d][2 + c * m_noPeriodicData]
                                  + m_periodicDataToReceive[d][3 + c * m_noPeriodicData]
                                        * m_periodicDataToReceive[d][3 + c * m_noPeriodicData])
                           / sqrt(1.4 * m_periodicDataToReceive[d][4 + c * m_noPeriodicData]
                                  / m_periodicDataToReceive[d][0 + c * m_noPeriodicData]);
        localPressure_2 += area * m_periodicDataToReceive[d][4 + c * m_noPeriodicData];
        localDensity_2 += area * m_periodicDataToReceive[d][0 + c * m_noPeriodicData];
        localMass += area * m_periodicDataToReceive[d][1 + c * m_noPeriodicData]
                     * m_periodicDataToReceive[d][0 + c * m_noPeriodicData];
        localUbulk += area * m_periodicDataToReceive[d][1 + c * m_noPeriodicData];
        localArea += area;
      }
    }
  }

  MPI_Allreduce(&localMass, &globalMass, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "localMass", "globalMass");
  MPI_Allreduce(&localPressure_1, &globalPressure_1, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "localPressure_1",
                "globalPressure_1");
  MPI_Allreduce(&localPressure_2, &globalPressure_2, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "localPressure_2",
                "globalPressure_2");
  MPI_Allreduce(&localDensity_2, &globalDensity_2, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "localDensity_2",
                "globalDensity_2");
  MPI_Allreduce(&localArea, &globalArea, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "localArea", "globalArea");
  MPI_Allreduce(&localUbulk, &globalUbulk, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "localUbulk", "globalUbulk");
  MPI_Allreduce(&localMeanMach_2, &globalMeanMach_2, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "localMeanMach_2",
                "globalMeanMach_2");

  globalPressure_1 = globalPressure_1 / globalArea;
  globalPressure_2 = globalPressure_2 / globalArea;
  globalMass = globalMass / globalArea;
  globalUbulk = globalUbulk / globalArea;
  globalDensity_2 = globalDensity_2 / globalArea;
  globalMeanMach_2 = globalMeanMach_2 / globalArea;


  // inlet2
  localArea = 0;
  globalArea = 0;
  area = 0;
  MFloat localPressure_3 = 0;
  MFloat globalPressure_3 = 0;
  MFloat localPressure_4 = 0;
  MFloat globalPressure_4 = 0;

  for(MInt d = 0; d < noDomains(); d++) {
    for(MInt c = 0; c < m_noPerCellsToReceive[d]; c++) {
      const auto sortedId = static_cast<MInt>(m_periodicDataToReceive[d][5 + c * m_noPeriodicData]);
      const MInt cell_Id = m_sortedPeriodicCells->a[sortedId];

      // inlet
      if(a_hasNeighbor(cell_Id, 0) > 0 && a_isHalo(cell_Id) == false && a_coordinate(cell_Id, 0) < 1.5) {
        MInt nghbrId = c_neighborId(cell_Id, 0);
        MInt bndryId = a_bndryId(nghbrId);

        if(bndryId > -1) {
          MFloat vfrac = m_bndryCells->a[bndryId].m_volume / POW3(c_cellLengthAtCell(nghbrId));
          MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[1];
          if(srfcId > -1) {
            area = POW2(c_cellLengthAtCell(cell_Id)) * vfrac;
          } else {
            mTerm(1, AT_, "something went wrong!");
          }
        } else {
          area = POW2(c_cellLengthAtCell(cell_Id)); // m_lengthLevel0 / FPOW2( a_level( cell_Id )));
        }

        localPressure_3 += area * a_pvariable(cell_Id, PV->P);
        localPressure_4 += area * m_periodicDataToReceive[d][4 + c * m_noPeriodicData];
        localArea += area;
      }
    }
  }

  MPI_Allreduce(&localPressure_3, &globalPressure_3, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "localPressure_3",
                "globalPressure_3");
  MPI_Allreduce(&localPressure_4, &globalPressure_4, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "localPressure_4",
                "globalPressure_4");
  MPI_Allreduce(&localArea, &globalArea, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "localArea", "globalArea");

  globalPressure_3 = globalPressure_3 / globalArea;
  globalPressure_4 = globalPressure_4 / globalArea;

  // outlet
  area = 0;
  MFloat localPressure_5 = 0;
  MFloat globalPressure_5 = 0;
  MFloat localPressure_6 = 0;
  MFloat globalPressure_6 = 0;
  globalArea = 0;
  localArea = 0;


  for(MInt d = 0; d < noDomains(); d++) {
    for(MInt c = 0; c < m_noPerCellsToReceive[d]; c++) {
      const MInt sortedId = static_cast<MInt>(m_periodicDataToReceive[d][5 + c * m_noPeriodicData]);
      const MInt cell_Id = m_sortedPeriodicCells->a[sortedId];

      // outlet
      if(a_hasNeighbor(cell_Id, 1) > 0 && a_isHalo(cell_Id) == false && a_coordinate(cell_Id, 0) > 1.5) {
        MInt nghbrId = c_neighborId(cell_Id, 1);
        MInt bndryId = a_bndryId(nghbrId);

        if(bndryId > -1) {
          MFloat vfrac = m_bndryCells->a[bndryId].m_volume / POW3(c_cellLengthAtCell(nghbrId));
          MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[0];
          if(srfcId > -1) {
            area = POW2(c_cellLengthAtCell(cell_Id)) * vfrac;
          } else {
            mTerm(1, AT_, "something went wrong!");
          }
        } else {
          area = POW2(c_cellLengthAtCell(cell_Id)); // m_lengthLevel0 / FPOW2( a_level( cell_Id )));
        }

        localPressure_5 += area * a_pvariable(cell_Id, PV->P);
        localPressure_6 += area * m_periodicDataToReceive[d][4 + c * m_noPeriodicData];
        localArea += area;
      }
    }
  }

  MPI_Allreduce(&localPressure_5, &globalPressure_5, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "localPressure_5",
                "globalPressure_5");
  MPI_Allreduce(&localPressure_6, &globalPressure_6, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "localPressure_6",
                "globalPressure_6");
  MPI_Allreduce(&localArea, &globalArea, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "localArea", "globalArea");

  globalPressure_5 = globalPressure_5 / globalArea;
  globalPressure_6 = globalPressure_6 / globalArea;

  // outlet2
  area = 0;
  MFloat localPressure_7 = 0;
  MFloat globalPressure_7 = 0;
  MFloat localPressure_8 = 0;
  MFloat globalPressure_8 = 0;
  globalArea = 0;
  localArea = 0;


  for(MInt d = 0; d < noDomains(); d++) {
    for(MInt c = 0; c < m_noPerCellsToReceive[d]; c++) {
      const MInt sortedId = static_cast<MInt>(m_periodicDataToReceive[d][5 + c * m_noPeriodicData]);
      const MInt cell_Id = m_sortedPeriodicCells->a[sortedId];

      // outlet
      if(a_hasNeighbor(cell_Id, 1) == 0 && a_isHalo(cell_Id) == false) {
        MInt nghbrId = c_neighborId(cell_Id, 0);
        MInt bndryId = a_bndryId(nghbrId);

        if(bndryId > -1) {
          MFloat vfrac = m_bndryCells->a[bndryId].m_volume / POW3(c_cellLengthAtCell(nghbrId));
          MInt srfcId = m_bndryCells->a[bndryId].m_associatedSrfc[0];
          if(srfcId > -1) {
            area = POW2(c_cellLengthAtCell(cell_Id)) * vfrac;
          } else {
            mTerm(1, AT_, "something went wrong!");
          }
        } else {
          area = POW2(c_cellLengthAtCell(cell_Id)); // m_lengthLevel0 / FPOW2( a_level( cell_Id )));
        }

        localPressure_7 += area * a_pvariable(cell_Id, PV->P);
        localPressure_8 += area * m_periodicDataToReceive[d][4 + c * m_noPeriodicData];
        localArea += area;
      }
    }
  }

  MPI_Allreduce(&localPressure_7, &globalPressure_7, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "localPressure_7",
                "globalPressure_7");
  MPI_Allreduce(&localPressure_8, &globalPressure_8, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "localPressure_8",
                "globalPressure_8");
  MPI_Allreduce(&localArea, &globalArea, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "localArea", "globalArea");

  globalPressure_7 = globalPressure_7 / globalArea;
  globalPressure_8 = globalPressure_8 / globalArea;

  m_TInfinity = 1.0 / (1.0 + F1B2 * 0.4 * POW2(m_Ma));
  // MFloat UT = m_Ma * sqrt(m_TInfinity);
  // MFloat m_delta_P = 0.3164 / sqrt(sqrt(sysEqn().m_Re0)) * m_referenceLength * F1B2 * m_rhoInfinity *
  // POW2(UT);//*4.94140625;

  for(MInt d = 0; d < noDomains(); d++) {
    for(MInt c = 0; c < m_noPerCellsToReceive[d]; c++) {
      const MInt sortedId = static_cast<MInt>(m_periodicDataToReceive[d][5 + c * m_noPeriodicData]);
      const MInt cell_Id = m_sortedPeriodicCells->a[sortedId];

      a_pvariable(cell_Id, PV->RHO) = m_periodicDataToReceive[d][0 + c * m_noPeriodicData];
      a_pvariable(cell_Id, PV->U) = m_periodicDataToReceive[d][1 + c * m_noPeriodicData];
      a_pvariable(cell_Id, PV->V) = m_periodicDataToReceive[d][2 + c * m_noPeriodicData];
      a_pvariable(cell_Id, PV->W) = m_periodicDataToReceive[d][3 + c * m_noPeriodicData];
      a_pvariable(cell_Id, PV->P) = m_periodicDataToReceive[d][4 + c * m_noPeriodicData];
    }
  }

  m_target_Ubulk = m_Ma * sqrt(m_TInfinity); // m_rhoUInfinity;

  if(globalTimeStep <= 1 || globalTimeStep == m_restartTimeStep) {
    m_oldUbulk = globalUbulk;
    m_oldPressure_Gradient = m_volumeAcceleration[0]; // m_delta_P;
  }

  if(globalTimeStep > 1 && globalTimeStep > m_oldTimeStep) {
    UbulkDiff = (1 / timeStep()) * ((m_target_Ubulk - 2 * globalUbulk + m_oldUbulk));

    MFloat m_delta_P = m_oldPressure_Gradient + UbulkDiff;

    m_volumeAcceleration[0] = m_delta_P;

    if(domainId() == 0) {
      cout << " step " << globalTimeStep << " deltaT " << timeStep() << " newPresGrad " << m_delta_P << " oldPresGrad "
           << m_oldPressure_Gradient << " Pinf " << m_PInfinity << " meanPres " << globalPressure_2 << " meanDens "
           << globalDensity_2 << " Mass_mean " << globalMass << " Umean " << globalUbulk << " UTarget "
           << m_Ma * sqrt(m_TInfinity) << " UmeanDiff" << globalUbulk - m_Ma * sqrt(m_TInfinity) << " meanMach "
           << globalMeanMach_2 << " machDiff" << m_Ma - globalMeanMach_2 << endl;
    }

    m_oldPressure_Gradient = m_delta_P;
    m_oldUbulk = globalUbulk;
  }

  m_oldTimeStep = globalTimeStep;
  computeConservativeVariables();
}


/// \brief Gather data of all window cells for all neighbors in the send buffers
///
/// \tparam exchangeAll_ gather all window cell data and not just the data of the max-level window cells
template <MInt nDim_, class SysEqn>
template <MBool exchangeAll_>
void FvCartesianSolverXD<nDim_, SysEqn>::gather() {
  TRACE();
  RECORD_TIMER_START(m_tgatherAndSend);
  RECORD_TIMER_START(m_tgather);
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    MInt sendBufferCounter = 0;
    const MInt noWindows = (exchangeAll_) ? noWindowCells(i) : m_noMaxLevelWindowCells[i];
    for(MInt j = 0; j < noWindows; j++) {
      const MInt windowCell = (exchangeAll_) ? windowCellId(i, j) : m_maxLevelWindowCells[i][j];
      std::copy_n(&a_pvariable(windowCell, 0), m_dataBlockSize, &m_sendBuffers[i][sendBufferCounter]);
      sendBufferCounter += m_dataBlockSize;
    }
  }
  RECORD_TIMER_STOP(m_tgather);
  RECORD_TIMER_STOP(m_tgatherAndSend);
}


/// \brief Scatter received data of all neighbors to the corresponding halo cells
///
/// \tparam exchangeAll_ scatter all halo cell data and not just the data of the max-level halo cells
template <MInt nDim_, class SysEqn>
template <MBool exchangeAll_>
void FvCartesianSolverXD<nDim_, SysEqn>::scatter() {
  TRACE();
  RECORD_TIMER_START(m_tscatter);
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    MInt receiveBufferCounter = 0;
    const MInt noHalos = (exchangeAll_) ? noHaloCells(i) : m_noMaxLevelHaloCells[i];
    for(MInt j = 0; j < noHalos; j++) {
      const MInt haloCell = (exchangeAll_) ? haloCellId(i, j) : m_maxLevelHaloCells[i][j];
      std::copy_n(&m_receiveBuffers[i][receiveBufferCounter], m_dataBlockSize, &a_pvariable(haloCell, 0));
      receiveBufferCounter += m_dataBlockSize;
    }
  }
  RECORD_TIMER_STOP(m_tscatter);
}


/// \brief Send window cell data to corresponding neighbors
///
/// \param exchangeAll send all window cell data and not just the data of the max-level window cells
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::send(const MBool exchangeAll) {
  TRACE();
  RECORD_TIMER_START(m_tgatherAndSend);
  RECORD_TIMER_START(m_tsend);
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    const MInt noWindows = (exchangeAll) ? noWindowCells(i) : m_noMaxLevelWindowCells[i];
    const MInt bufSize = noWindows * m_dataBlockSize;
    MPI_Issend(m_sendBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &m_mpi_request[i], AT_,
               "m_sendBuffers[i]");
  }
  RECORD_TIMER_STOP(m_tsend);
  RECORD_TIMER_STOP(m_tgatherAndSend);
}


/// \brief Receive halo cell data from corresponding neighbors
///
/// \param exchangeAll receive all halo cell data and not just the data of the max-level halo cells
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::receive(const MBool exchangeAll) {
  TRACE();
  if(noNeighborDomains() == 0) {
    return; // No neighbor -> serial + nonperiodic case
  }
  RECORD_TIMER_START(m_treceive);

  ScratchSpace<MPI_Request> recvRequests(noNeighborDomains(), AT_, "recvRequests");
  recvRequests.fill(MPI_REQUEST_NULL);

  RECORD_TIMER_START(m_treceiving);
  // Start receiving from all neighbors
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    const MInt noHalos = (exchangeAll) ? noHaloCells(i) : m_noMaxLevelHaloCells[i];
    const MInt bufSize = noHalos * m_dataBlockSize;
    MPI_Irecv(m_receiveBuffers[i], bufSize, type_traits<MFloat>::mpiType(), neighborDomain(i), 0, mpiComm(),
              &recvRequests[i], AT_, "m_receiveBuffer[i]");
  }
  RECORD_TIMER_STOP(m_treceiving);

  RECORD_TIMER_START(m_treceiveWait);
  // Wait for all send and receive requests to finish
  MPI_Waitall(noNeighborDomains(), &m_mpi_request[0], MPI_STATUSES_IGNORE, AT_);
  MPI_Waitall(noNeighborDomains(), &recvRequests[0], MPI_STATUSES_IGNORE, AT_);
  RECORD_TIMER_STOP(m_treceiveWait);

  RECORD_TIMER_STOP(m_treceive);
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::cellSurfaceMapping() {
  if(m_levelSetMb) return; // m_cellSurfaceMapping is filled in a different way inside the FvMb Solver

  const MUint noSurfaces = a_noSurfaces();

  for(MUint srfcId = 0; srfcId < noSurfaces; srfcId++) {
    const MInt orientation = a_surfaceOrientation(srfcId);
    const MInt nghbrId0 = a_surfaceNghbrCellId(srfcId, 0);
    const MInt nghbrId1 = a_surfaceNghbrCellId(srfcId, 1);

    if(a_level(nghbrId1) > a_level(nghbrId0)) {
      m_cellSurfaceMapping[nghbrId0][2 * orientation + 1] = -1;
      m_cellSurfaceMapping[nghbrId1][2 * orientation] = srfcId;
    } else {
      m_cellSurfaceMapping[nghbrId0][2 * orientation + 1] = srfcId;
      m_cellSurfaceMapping[nghbrId1][2 * orientation] = -1;
    }

    if(a_level(nghbrId0) == a_level(nghbrId1)) {
      m_cellSurfaceMapping[nghbrId0][2 * orientation + 1] = srfcId;
      m_cellSurfaceMapping[nghbrId1][2 * orientation] = srfcId;
    }
  }
}

template <MInt nDim_, class SysEqn>
template <class _, std::enable_if_t<isDetChem<SysEqn>, _*>>
void FvCartesianSolverXD<nDim_, SysEqn>::interpolateSurfaceDiffusionFluxOnCellCenter(MFloat* const NotUsed(JA),
                                                                                     MFloat* const dtdn) {
  TRACE();

  const MInt noDirs = 2 * nDim;
  const MUint noPVars = PV->noVariables;
  const MUint noSurfaceCoefficients = hasSC ? SC->m_noSurfaceCoefficients : 0;
  const MUint surfaceVarMemory = 2 * noPVars;
  const MUint noSlopes = nDim * noPVars;

  const MInt* const RESTRICT orientations = ALIGNED_I(&a_surfaceOrientation(0));
  const MInt* const RESTRICT nghbrCellIds = ALIGNED_I(&a_surfaceNghbrCellId(0, 0));
  const MFloat* const RESTRICT surfaceVars = ALIGNED_F(&a_surfaceVariable(0, 0, 0));
  const MFloat* const RESTRICT surfaceCoefficients = hasSC ? ALIGNED_F(&a_surfaceCoefficient(0, 0)) : nullptr;
  const MFloat* const RESTRICT factor = ALIGNED_F(&a_surfaceFactor(0, 0));
  const MFloat* const RESTRICT slope = ALIGNED_F(&a_slope(0, 0, 0));

#ifdef _OPENMP
#pragma omp parallel for
#endif

  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    vector<vector<MFloat>> J(noDirs, vector<MFloat>(PV->m_noSpecies, F0));
    vector<vector<MFloat>> J_noSoret(noDirs, vector<MFloat>(PV->m_noSpecies, F0));
    vector<vector<MFloat>> dXdn(noDirs, vector<MFloat>(PV->m_noSpecies, F0));
    vector<vector<MFloat>> dXdn_int(nDim, vector<MFloat>(PV->m_noSpecies, F0));
    vector<MFloat> dXH2dn1(2, F0);
    vector<MFloat> dTdn(noDirs, F0);
    vector<MFloat> DH2(noDirs, F0);
    vector<vector<MFloat>> J_int(nDim, vector<MFloat>(PV->m_noSpecies, F0));
    vector<vector<MFloat>> J_noSoret_int(nDim, vector<MFloat>(PV->m_noSpecies, F0));
    vector<MFloat> dTdn_int(nDim, F0);


    for(MInt dir = 0; dir < noDirs; dir++) {
      const MInt srfcId = m_cellSurfaceMapping[cellId][dir];
      if(srfcId < 0) continue;

      ASSERT((nghbrCellIds[2 * srfcId] == cellId) || (nghbrCellIds[2 * srfcId + 1] == cellId), "");

      const MUint offset = srfcId * surfaceVarMemory;
      const MFloat* const RESTRICT vars0 = ALIGNED_F(surfaceVars + offset);
      const MFloat* const RESTRICT vars1 = ALIGNED_F(vars0 + noPVars);
      const MFloat f0 = factor[srfcId * 2];
      const MFloat f1 = factor[srfcId * 2 + 1];
      const MUint offset0 = nghbrCellIds[2 * srfcId] * noSlopes;
      const MUint offset1 = nghbrCellIds[2 * srfcId + 1] * noSlopes;
      const MFloat* const RESTRICT slope0 = ALIGNED_F(slope + offset0);
      const MFloat* const RESTRICT slope1 = ALIGNED_F(slope + offset1);
      const MUint coefficientOffset = srfcId * noSurfaceCoefficients;
      const MFloat* const RESTRICT srfcCoeff = hasSC ? ALIGNED_F(surfaceCoefficients + coefficientOffset) : nullptr;

      sysEqn().getSpeciesDiffusionMassFluxes(orientations[srfcId], vars0, vars1, slope0, slope1, srfcCoeff, f0, f1,
                                             J[dir], dXdn[dir], dTdn[dir], sysEqn().m_soretEffect);
      sysEqn().getSpeciesDiffusionMassFluxes(orientations[srfcId], vars0, vars1, slope0, slope1, srfcCoeff, f0, f1,
                                             J_noSoret[dir], dXdn[dir], dTdn[dir], false);
      for(MUint s = 0; s < PV->m_noSpecies; s++) {
        if(m_speciesName[s] == "H2") DH2[dir] = a_srfcCoeffs(srfcId, SC->D[s]);
        if(m_speciesName[s] == "H2" && (dir == 0 || dir == 1)) dXH2dn1[dir] = dXdn[dir][s];
      }
    }

    for(MInt dim = 0; dim < nDim; dim++) {
      dTdn_int[dim] = dTdn[2 * dim] + F1B2 * (dTdn[2 * dim + 1] - dTdn[2 * dim]);
      dtdn[cellId * nDim + dim] = dTdn_int[dim];
      for(MUint s = 0; s < PV->m_noSpecies; s++) {
        J_int[dim][s] = J[2 * dim][s] + F1B2 * (J[2 * dim + 1][s] - J[2 * dim][s]);
        dXdn_int[dim][s] = dXdn[2 * dim][s] + F1B2 * (dXdn[2 * dim + 1][s] - dXdn[2 * dim][s]);
        dXdn[cellId * nDim * PV->m_noSpecies + dim * PV->m_noSpecies + s] = dXdn_int[dim][s];
        J[cellId * nDim * PV->m_noSpecies + dim * PV->m_noSpecies + s] = J_int[dim][s];
      }
    }
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setUpwindCoefficient() {
  TRACE();

  MBool flag;
  const MInt noSrfcs = a_noSurfaces();
  const MInt noDirs = 2 * nDim;

  //---
  switch(m_upwindMethod) {
    default: {
      for(MInt s = 0; s < noSrfcs; s++) {
        flag = false;
        for(MInt side = 0; side < 2; side++) {
          for(MInt d = 0; d < noDirs; d++) {
            MInt gridcellId = a_surfaceNghbrCellId(s, side);
            MInt gridcellId2 = a_surfaceNghbrCellId(s, side);
            if(a_hasProperty(gridcellId, SolverCell::IsSplitClone)) {
              gridcellId = m_splitChildToSplitCell.find(gridcellId)->second;
            }
            if(a_hasProperty(gridcellId2, SolverCell::IsSplitClone)) {
              gridcellId2 = m_splitChildToSplitCell.find(gridcellId2)->second;
            }
            if(a_isBndryGhostCell(a_surfaceNghbrCellId(s, side)) || c_parentId(gridcellId) == -1) {
              continue;
            }
            if(a_hasNeighbor(gridcellId, d) > 0) {
              continue;
            }
            if(a_hasNeighbor(c_parentId(gridcellId2), d) == 0) {
              continue;
            }
            if(c_noChildren(c_neighborId(c_parentId(gridcellId2), d)) > 0) {
              continue;
            }
            flag = true;
            d = noDirs;
          }
        }
        if(flag) {
          a_surfaceUpwindCoefficient(s) = m_chi;
        } else {
          a_surfaceUpwindCoefficient(s) = m_globalUpwindCoefficient;
        }
      }
      if(m_combustion && m_jet) {
        m_log << "upwinding on coarse level is set to max upwind coefficient 0.5, only valid when the coarse level "
                 "is not of interest !!!!"
              << endl;
        for(MInt s = 0; s < noSrfcs; s++) {
          if(a_isBndryGhostCell(a_surfaceNghbrCellId(s, 0)) || a_isBndryGhostCell(a_surfaceNghbrCellId(s, 1))) {
            continue;
          }
          if(a_surfaceNghbrCellId(s, 0) == -1 || a_surfaceNghbrCellId(s, 1) == -1) {
            continue;
          }
          if(a_level(a_surfaceNghbrCellId(s, 0)) == maxLevel() && a_level(a_surfaceNghbrCellId(s, 1)) == maxLevel()) {
            continue;
          }

          a_surfaceUpwindCoefficient(s) = m_chi;
        }
      }

      break;
    }

    // Upwinding at coarse-fine surfaces only
    case 1: {
      for(MInt s = 0; s < noSrfcs; s++) {
        flag = false;
        for(MInt side = 0; side < 2; side++) {
          MInt gridcellId = a_surfaceNghbrCellId(s, side);
          MInt orientation = a_surfaceOrientation(s);
          MInt d = 2 * orientation + (1 - side);
          TERMM_IF_NOT_COND(gridcellId == a_surfaceNghbrCellId(s, side), "");
          if(a_hasProperty(gridcellId, SolverCell::IsSplitClone)) {
            gridcellId = m_splitChildToSplitCell.find(gridcellId)->second;
          }
          if(a_isBndryGhostCell(a_surfaceNghbrCellId(s, side)) || c_parentId(gridcellId) == -1) {
            continue;
          }
          if(a_hasNeighbor(gridcellId, d) > 0) {
            continue;
          }
          if(a_hasNeighbor(c_parentId(gridcellId), d) == 0) {
            continue;
          }
          if(c_noChildren(c_neighborId(c_parentId(gridcellId), d)) > 0) {
            continue;
          }
          flag = true;
        }
        if(flag) {
          a_surfaceUpwindCoefficient(s) = m_chi;
        } else {
          a_surfaceUpwindCoefficient(s) = m_globalUpwindCoefficient;
        }
      }
      break;
    }

    // Upwinding on coarse-fine surface and its opposite surface on fine cell
    case 2: {
      for(MInt s = 0; s < noSrfcs; s++) {
        flag = false;
        for(MInt side = 0; side < 2; side++) {
          MInt gridcellId = a_surfaceNghbrCellId(s, side);
          MInt orientation = a_surfaceOrientation(s);
          TERMM_IF_NOT_COND(gridcellId == a_surfaceNghbrCellId(s, side), "");
          for(MInt side2 = 0; side2 < 2; ++side2) {
            MInt d = 2 * orientation + side2;
            if(a_hasProperty(gridcellId, SolverCell::IsSplitClone)) {
              gridcellId = m_splitChildToSplitCell.find(gridcellId)->second;
            }
            if(a_isBndryGhostCell(a_surfaceNghbrCellId(s, side)) || c_parentId(gridcellId) == -1) {
              continue;
            }
            if(a_hasNeighbor(gridcellId, d) > 0) {
              continue;
            }
            if(a_hasNeighbor(c_parentId(gridcellId), d) == 0) {
              continue;
            }
            if(c_noChildren(c_neighborId(c_parentId(gridcellId), d)) > 0) {
              continue;
            }
            flag = true;
            break;
          }
        }
        if(flag) {
          a_surfaceUpwindCoefficient(s) = m_chi;
        } else {
          a_surfaceUpwindCoefficient(s) = m_globalUpwindCoefficient;
        }
      }
      break;
    }

      // FAN --> Alexej Pogorelov
    case 38:
    case 36: {
      if(m_periodicCells == 1) { // azimuthal periodicity concept

        MFloat radius = 0.0;
        MInt cellId = -1;

        for(MInt s = 0; s < noSrfcs; s++) {
          flag = false;
          for(MInt side = 0; side < 2; side++) {
            for(MInt d = 0; d < noDirs; d++) {
              cellId = a_surfaceNghbrCellId(s, side);
              if(a_isBndryGhostCell(cellId)) continue;
              radius = 0.0;
              for(MInt i = 0; i < 2; i++) {
                radius += pow(a_coordinate(cellId, i + 1) - m_rotAxisCoord[i], 2.0);
              }
              radius = sqrt(radius);

              const MFloat halfLength = c_cellLengthAtLevel(minLevel() + 1);

              if(a_hasProperty(a_surfaceNghbrCellId(s, side), SolverCell::IsPeriodicWithRot)
                 && radius < 8.0 * halfLength) {
                flag = true;
                break;
              }
              MInt gridcellId = a_surfaceNghbrCellId(s, side);
              MInt gridcellId2 = a_surfaceNghbrCellId(s, side);
              if(a_hasProperty(gridcellId, SolverCell::IsSplitClone)) {
                gridcellId = m_splitChildToSplitCell.find(gridcellId)->second;
              }
              if(a_hasProperty(gridcellId2, SolverCell::IsSplitClone)) {
                gridcellId2 = m_splitChildToSplitCell.find(gridcellId2)->second;
              }
              if(a_hasNeighbor(gridcellId, d) > 0) {
                cellId = c_neighborId(gridcellId, d);
                radius = 0.0;
                for(MInt i = 0; i < 2; i++) {
                  radius += pow(a_coordinate(cellId, i + 1) - m_rotAxisCoord[i], 2.0);
                }
                radius = sqrt(radius);


                if(a_hasProperty(c_neighborId(gridcellId, d), SolverCell::IsPeriodicWithRot)
                   && radius < 8.0 * halfLength) {
                  flag = true;
                  d = noDirs;
                  break;
                }
              }


              if(a_hasNeighbor(gridcellId, d) > 0) {
                continue;
              }
              if(c_parentId(gridcellId) == -1) {
                continue;
              }
              if(a_hasNeighbor(c_parentId(gridcellId2), d) == 0) {
                continue;
              }
              if(c_noChildren(c_neighborId(c_parentId(gridcellId2), d)) > 0) {
                continue;
              }
              if(!a_hasProperty(c_neighborId(c_parentId(gridcellId2), d), SolverCell::IsOnCurrentMGLevel)) {
                continue;
              }
              flag = true;
              d = noDirs;
            }
          }


          if(flag) {
            a_surfaceUpwindCoefficient(s) = m_chi;
          } else {
            a_surfaceUpwindCoefficient(s) = m_globalUpwindCoefficient;
          }
        }
      }

    } break;

    case 1949: {
      for(MInt s = 0; s < noSrfcs; s++) {
        flag = false;
        for(MInt side = 0; side < 2; side++) {
          for(MInt d = 0; d < noDirs; d++) {
            MInt gridcellId = a_surfaceNghbrCellId(s, side);
            if(a_hasProperty(gridcellId, SolverCell::IsSplitClone)) {
              gridcellId = m_splitChildToSplitCell.find(gridcellId)->second;
            }
            if(a_hasNeighbor(gridcellId, d) > 0) {
              continue;
            }
            if(c_parentId(gridcellId) == -1) {
              continue;
            }
            if(a_hasNeighbor(c_parentId(gridcellId), d) == 0) {
              continue;
            }
            flag = true;
            d = noDirs;
          }
        }
        if(flag || ABS(a_surfaceCoordinate(s, 1) - 50) < 10) {
          a_surfaceUpwindCoefficient(s) = m_chi;
        } else {
          a_surfaceUpwindCoefficient(s) = m_globalUpwindCoefficient;
        }
      }
    } break;
  }
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setNghbrInterface() {
  TRACE();

  for(MInt cellId = 0; cellId < a_noCells(); ++cellId) {
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      continue;
    }
    if(a_hasProperty(cellId, SolverCell::IsNotGradient)) {
      continue;
    }
    if(a_isBndryGhostCell(cellId)) {
      continue;
    }
    if(a_hasProperty(cellId, SolverCell::IsSplitClone)) {
      continue;
    }

    for(MInt dir = 0; dir < m_noDirs; ++dir) {
      if(a_hasNeighbor(cellId, dir) > 0) { // nghbr on same or higher lvl
        const MInt nghbrId = c_neighborId(cellId, dir);
        if(c_noChildren(nghbrId) > 0) { // finer neighbor
          TERMM_IF_COND(a_hasProperty(nghbrId, SolverCell::IsOnCurrentMGLevel),
                        "Nghbr can't have children & be on curent MG lvl!");
          // Ensure that at least one of the children is adjacent to current cell.
          // If cell is not bndry cell, it must have IPOW2(nDim-1) nghbrs on higher lvl.
          MInt noNghbrChilds = 0;
          for(MInt child = 0; child < IPOW2(nDim); child++) {
            if(c_childId(nghbrId, child) > -1) {
              if(childCodePro[dir] & 1 << child) { // check if adjacent to current cell.
                TERMM_IF_NOT_COND(a_hasProperty(c_childId(nghbrId, child), SolverCell::IsOnCurrentMGLevel),
                                  "Unkown situation!");
                ++noNghbrChilds;
              }
            }
          }
          TERMM_IF_COND(!a_isBndryCell(cellId) && noNghbrChilds != IPOW2(nDim - 1), "");
          if(noNghbrChilds > 0) {
            // a bndry cell may have less then IPOW2(nDim-1) finer nghbrs
            m_cells.nghbrInterface(cellId, dir, 2);
          } else { // no neighbor at all
            m_cells.nghbrInterface(cellId, dir, 0);
          }
        } else { // neighbor on same level
          m_cells.nghbrInterface(cellId, dir, 1);
        }
      } else if(c_parentId(cellId) > -1 && a_hasNeighbor(c_parentId(cellId), dir) > 0
                && a_hasProperty(c_neighborId(c_parentId(cellId), dir),
                                 SolverCell::IsOnCurrentMGLevel)) { // coarse neighbor
        const MInt parentId = c_parentId(cellId);
        for(MInt child = 0; child < IPOW2(nDim); child++) {
          if(c_childId(parentId, child) == cellId) {
            if((childCodePro[m_revDir[dir]] & 1 << child) == (uint_fast8_t)0) {
              m_cells.nghbrInterface(cellId, dir, 0);
            } else {
              m_cells.nghbrInterface(cellId, dir, 3);
            }
            break;
          }
        }
      } else { // no neighbor at all
        m_cells.nghbrInterface(cellId, dir, 0);
      }
    }

    a_hasProperty(cellId, SolverCell::HasCoarseNghbr) = false;
    for(MInt d = 0; d < nDim; ++d) {
      if(m_cells.nghbrInterface(cellId, 2 * d) == 3 || m_cells.nghbrInterface(cellId, 2 * d + 1) == 3) {
        a_hasProperty(cellId, SolverCell::HasCoarseNghbr) = true;
        break;
      }
    }
  }
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::resetRHSNonInternalCells() {
  TRACE();

  const MInt noFVars = FV->noVariables;
  const MInt noCells = a_noCells();

  const MInt offset = noInternalCells();
  //---

#ifdef _OPENMP
#pragma omp parallel for collapse(2)
#endif
  for(MInt c = offset; c < noCells; c++) {
    for(MInt varId = 0; varId < noFVars; varId++) {
      a_rightHandSide(c, varId) = F0;
    }
  }
}

/** \brief Deletes all surfaces existing.
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::deleteSrfcs() {
  TRACE();

  m_surfaces.clear(); // invalidate all elements and set size to 0
}


// if no multisolver is used properties 11 and 13 are equivalent
// uses b_properties[SolverCell::IsFlux], which is set in tagCellsNeededForSurfaceFlux
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::writeListOfActiveFlowCells() {
  TRACE();

  // reset
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    a_hasProperty(cellId, SolverCell::IsActive) = a_hasProperty(cellId, SolverCell::IsFlux);
  }

  // include all cells involved in the reconstruction process
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    if(a_hasProperty(cellId, SolverCell::IsActive)) {
      for(MInt c = 0; c < a_noReconstructionNeighbors(cellId); c++) {
        a_hasProperty(a_reconstructionNeighborId(cellId, c), SolverCell::IsActive) = true;
      }
    }
  }

  m_noActiveCells = 0;
  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    if(a_hasProperty(cellId, SolverCell::IsActive)) {
      m_activeCellIds[m_noActiveCells] = cellId;
      m_noActiveCells++;
    }
  }
  m_noActiveHaloCellOffset = m_noActiveCells;
  for(MInt cellId = noInternalCells(); cellId < a_noCells(); cellId++) {
    if(a_hasProperty(cellId, SolverCell::IsActive)) {
      m_activeCellIds[m_noActiveCells] = cellId;
      m_noActiveCells++;
    }
  }
  m_log << "Time step - Active cells: " << globalTimeStep << " " << m_noActiveHaloCellOffset << " " << m_noActiveCells
        << endl;
}


// --------------------------------------------------------------------------------------


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setCellProperties() {
  TRACE();
  const MInt noCells = a_noCells();
  const MInt noDirs = 2 * nDim;

  //---

  // set property 13 - cell is on the current computing level
  // if multilevel computation is applied the maxRfnmntLevel should be changed to a new variable like
  // m_currentMultiGridLevel
  for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
    a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) =
        ((c_isLeafCell(cellId) && a_level(cellId) <= maxRefinementLevel())
         || (!c_isLeafCell(cellId) && a_level(cellId) == maxRefinementLevel()))
        && !a_hasProperty(cellId, SolverCell::IsInvalid);
  }


  // set property defaults:
#ifdef _OPENMP
#pragma omp parallel for simd
#endif
  for(MInt c = 0; c < noCells; c++) {
    a_isHalo(c) = false;
    a_hasProperty(c, SolverCell::IsNotGradient) = false;
  }

  // set property 15 - cell is a multisolver halo cell
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    for(MInt c = 0; c < noHaloCells(i); c++) {
      a_isHalo(haloCellId(i, c)) = true;
    }
  }
  // Azimuthal periodicty exchange halos
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MInt c = 0; c < grid().noAzimuthalHaloCells(i); c++) {
      a_isHalo(grid().azimuthalHaloCell(i, c)) = true;
    }
  }
  for(MInt c = 0; c < grid().noAzimuthalUnmappedHaloCells(); c++) {
    a_isHalo(grid().azimuthalUnmappedHaloCell(c)) = true;
  }

  // set property 7 - cell is a not gradient
  // no gradient needs to be computed on those cells
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    for(MInt c = 0; c < noHaloCells(i); c++) {
      a_hasProperty(haloCellId(i, c), SolverCell::IsNotGradient) = true;
      if(!a_hasProperty(haloCellId(i, c), SolverCell::IsOnCurrentMGLevel)) continue;
      for(MInt d = 0; d < noDirs; d++) {
        if(a_hasNeighbor(haloCellId(i, c), d) > 0) {
          if(!a_isHalo(c_neighborId(haloCellId(i, c), d))) {
            a_hasProperty(haloCellId(i, c), SolverCell::IsNotGradient) = false;
          }
        } else {
          MInt parentId = c_parentId(haloCellId(i, c));
          if(parentId > -1) {
            if(a_hasNeighbor(parentId, d) > 0) {
              if(!a_isHalo(c_neighborId(parentId, d))) {
                a_hasProperty(haloCellId(i, c), SolverCell::IsNotGradient) = false;
              }
            }
          }
        }
      }
    }
  }

  // Azimuthal periodicty exchange halos
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MInt c = 0; c < grid().noAzimuthalHaloCells(i); c++) {
      MInt cellId = grid().azimuthalHaloCell(i, c);
      a_hasProperty(cellId, SolverCell::IsNotGradient) = true;
      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
      for(MInt d = 0; d < noDirs; d++) {
        if(a_hasNeighbor(cellId, d) > 0) {
          if(!a_isHalo(c_neighborId(cellId, d))) {
            a_hasProperty(cellId, SolverCell::IsNotGradient) = false;
          }
        } else {
          MInt parentId = c_parentId(cellId);
          if(parentId > -1) {
            if(a_hasNeighbor(parentId, d) > 0) {
              if(!a_isHalo(c_neighborId(parentId, d))) {
                a_hasProperty(cellId, SolverCell::IsNotGradient) = false;
              }
            }
          }
        }
      }
    }
  }
  for(MInt c = 0; c < grid().noAzimuthalUnmappedHaloCells(); c++) {
    MInt cellId = grid().azimuthalUnmappedHaloCell(c);
    a_hasProperty(cellId, SolverCell::IsNotGradient) = true;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    for(MInt d = 0; d < noDirs; d++) {
      if(a_hasNeighbor(cellId, d) > 0) {
        if(!a_isHalo(c_neighborId(cellId, d))) {
          a_hasProperty(cellId, SolverCell::IsNotGradient) = false;
        }
      } else {
        MInt parentId = c_parentId(cellId);
        if(parentId > -1) {
          if(a_hasNeighbor(parentId, d) > 0) {
            if(!a_isHalo(c_neighborId(parentId, d))) {
              a_hasProperty(cellId, SolverCell::IsNotGradient) = false;
            }
          }
        }
      }
    }
  }

  // Copy Periodic-Cell-Property as a grid-property!
  for(MInt id = 0; id < a_noCells(); ++id) {
    if(a_hasProperty(id, SolverCell::IsSplitChild)) continue;
    if(a_isBndryGhostCell(id)) continue;
    if(a_hasProperty(id, SolverCell::IsSplitClone)) continue;
    assertValidGridCellId(id);
    a_isPeriodic(id) = grid().isPeriodic(id);
  }

  // Set Cell-Properties for Splitchilds:
  for(MInt splitId = 0; (unsigned)splitId < m_splitCells.size(); splitId++) {
    MInt scId = m_splitCells[splitId];
    if(a_isHalo(scId)) {
      for(MInt ssc = 0; (unsigned)ssc < m_splitChilds[splitId].size(); ssc++) {
        MInt splitChildId = m_splitChilds[splitId][ssc];
        a_isHalo(splitChildId) = true;
      }
    }
    if(a_isPeriodic(scId)) {
      for(MInt ssc = 0; (unsigned)ssc < m_splitChilds[splitId].size(); ssc++) {
        MInt splitChildId = m_splitChilds[splitId][ssc];
        a_isPeriodic(splitChildId) = true;
      }
    }
  }

  initSpongeLayer();
}


// --------------------------------------------------------------------------------------


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initSpongeLayer() {
  TRACE();

  const MInt noCells = a_noCells();
  const MInt noDirs = 2 * nDim;
  const MFloat epsilon = m_spongeLayerThickness / 10000000.0;
  MFloat constant = NAN;
  MFloatScratchSpace delta(noDirs, AT_, "delta");
  MFloatScratchSpace dis(nDim, AT_, "dis");
  MFloat beta = 1.0;
  MFloat maxSpongeFactor = 0.0;
  MFloat minSpongeFactor = 100.0;

  //---

  // initialize the arrays containing the list of cells in the sponge layer
  if(!m_createSpongeBoundary) {
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      a_hasProperty(cellId, SolverCell::IsInSpongeLayer) = false;
      a_spongeFactor(cellId) = F0;
    }

    m_noCellsInsideSpongeLayer = 0;
    if(m_spongeLayerThickness > F0) {
      switch(m_spongeLayerLayout) {
        case 0: {
          for(MInt cellId = 0; cellId < noCells; cellId++) {
            if(a_isBndryGhostCell(cellId)) {
              continue;
            }
            a_hasProperty(cellId, SolverCell::IsInSpongeLayer) = false;
            a_spongeFactor(cellId) = F0;
            if(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
              // compute the distance from the sponge layer
              // if the cell is not inside the sponge layer, the distance is set to zero
              for(MInt i = 0; i < nDim; i++) {
                delta.p[2 * i] =
                    mMax(F0, (a_coordinate(cellId, i) - m_spongeCoord[2 * i + 1]) * m_spongeCoord[noDirs + 2 * i + 1]);
                delta.p[2 * i + 1] =
                    mMin(F0, (a_coordinate(cellId, i) - m_spongeCoord[2 * i]) * m_spongeCoord[noDirs + 2 * i]);
                delta.p[2 * i + 1] = fabs(delta.p[2 * i + 1]);
                dis.p[i] = mMax(delta.p[2 * i], delta.p[2 * i + 1]);
              }

              // compute the dissipation function...
              constant = F0;
              for(MInt i = 0; i < nDim; i++) {
                constant = mMax(constant, ABS(dis.p[i]));
              }
              constant = pow(constant, beta);
              constant *= m_sigmaSponge;

              if(constant > epsilon) {
                m_cellsInsideSpongeLayer[m_noCellsInsideSpongeLayer] = cellId;
                m_noCellsInsideSpongeLayer++;
                a_hasProperty(cellId, SolverCell::IsInSpongeLayer) = true;
                a_spongeFactor(cellId) = constant;
                maxSpongeFactor = mMax(maxSpongeFactor, a_spongeFactor(cellId));
                minSpongeFactor = mMin(minSpongeFactor, a_spongeFactor(cellId));
              }
            }
          }
          if(globalTimeStep < 1) {
            m_log << endl;
            m_log << "*************************************************************" << endl;
            m_log << "Information for domain sponge: " << endl;
            m_log << "*************************************************************" << endl;

            m_log << "number of cells inside sponge layer " << m_noCellsInsideSpongeLayer << endl;
            m_log << "max sponge factor: " << maxSpongeFactor << endl;
            m_log << "min sponge factor: " << minSpongeFactor << endl << endl;
          }
          break;
        }
        case 2: {
          MFloat radius = NAN;
          IF_CONSTEXPR(nDim == 3) {
            for(MInt cellId = 0; cellId < noCells; cellId++) {
              a_hasProperty(cellId, SolverCell::IsInSpongeLayer) = false;
              a_spongeFactor(cellId) = F0;
              if(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
                // compute the distance from the sponge layer (streamwise direction is y)
                // if the cell is not inside the sponge layer, the distance is set to zero
                // radial (xz)
                radius = sqrt(POW2(a_coordinate(cellId, 0)) + POW2(a_coordinate(cellId, 2)));
                delta.p[0] = mMax(F0, (radius - ABS(m_spongeCoord[1])) * m_spongeCoord[noDirs + 1]);
                dis.p[0] = delta.p[0];
                dis.p[2] = F0;
                // streamwise (y)
                delta.p[2] = mMax(F0, (a_coordinate(cellId, 1) - m_spongeCoord[3]) * m_spongeCoord[noDirs + 3]);
                delta.p[3] = mMin(F0, (a_coordinate(cellId, 1) - m_spongeCoord[2]) * m_spongeCoord[noDirs + 2]);
                delta.p[3] = fabs(delta.p[3]);
                dis.p[1] = mMax(delta.p[2], delta.p[3]);

                // compute the dissipation function...
                constant = F0;
                for(MInt i = 0; i < nDim; i++) {
                  constant = mMax(constant, ABS(dis.p[i]));
                }

                constant *= m_sigmaSponge;

                if(constant > epsilon) {
                  m_cellsInsideSpongeLayer[m_noCellsInsideSpongeLayer] = cellId;
                  m_noCellsInsideSpongeLayer++;
                  a_hasProperty(cellId, SolverCell::IsInSpongeLayer) = true;
                  a_spongeFactor(cellId) = constant;
                }
              }
            }
          }
          else {
            for(MInt cellId = 0; cellId < noCells; cellId++) {
              a_hasProperty(cellId, SolverCell::IsInSpongeLayer) = false;
              a_spongeFactor(cellId) = F0;
              if(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
                // compute the distance from the sponge layer radial (xy)
                // if the cell is not inside the sponge layer, the distance is set to zero
                radius = sqrt(POW2(a_coordinate(cellId, 0)) + POW2(a_coordinate(cellId, 1)));
                // compute the dissipation function...
                constant = mMax(F0, (radius - ABS(m_spongeCoord[0])) * m_spongeCoord[noDirs]);
                constant *= m_sigmaSponge;

                if(constant > epsilon) {
                  m_cellsInsideSpongeLayer[m_noCellsInsideSpongeLayer] = cellId;
                  m_noCellsInsideSpongeLayer++;
                  a_hasProperty(cellId, SolverCell::IsInSpongeLayer) = true;
                  a_spongeFactor(cellId) = constant;
                }
              }
            }
          }
          break;
        }
        default: {
          mTerm(1, AT_,
                "FvCartesianSolver::setCellProperties(): switch variable 'm_spongeLayerLayout' not matching any "
                "case");
        }
      }
    }
  }
}


// --------------------------------------------------------------------------------------


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::determineStructuredCells() {
  TRACE();
  const MInt noCells = a_noCells();
  MBoolScratchSpace atBnd(noCells, AT_, "atBnd");
  MBoolScratchSpace nearBnd(noCells, AT_, "nearBnd");
  atBnd.fill(false);
  nearBnd.fill(false);
  // std::vector< std::vector<MInt> > structuredCells( maxLevel()-minLevel()+1 );
  // std::vector<MInt> nearBoundaryCells;

  for(MInt level = minLevel(); level <= maxLevel(); level++) {
    // structuredCells[level-minLevel()].clear();
  }
  for(MInt level = minLevel(); level < maxRefinementLevel(); level++) {
    // centralDiffConst[level] = F1 / ( F2*c_cellLengthAtLevel(level) );
  }
  for(MInt cellId = 0; cellId < noCells; cellId++) {
    a_hasProperty(cellId, SolverCell::AtStructuredRegion) = false;
  }
  for(MInt bndryId = 0; bndryId < m_bndryCells->size(); bndryId++) {
    MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    atBnd(cellId) = true;
    MInt parentId = a_hasProperty(cellId, SolverCell::IsSplitChild) ? c_parentId(getAssociatedInternalCell(cellId))
                                                                    : c_parentId(cellId);
    while(parentId > -1) {
      atBnd(parentId) = true;
      parentId = c_parentId(parentId);
    }
  }
  for(MInt cellId = 0; cellId < noCells; cellId++) {
    if(a_bndryId(cellId) < -1) continue;
    if(a_hasProperty(cellId, SolverCell::IsCutOff)) continue;
    if(a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    //---
    if(atBnd(cellId)) {
      // nearBoundaryCells.push_back( cellId );
      nearBnd(cellId) = true;
      continue;
    }
    MBool nearb = false;
    a_hasProperty(cellId, SolverCell::AtStructuredRegion) = true;
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      if(!a_hasNeighbor(cellId, dir)) {
        a_hasProperty(cellId, SolverCell::AtStructuredRegion) = false;
        MInt parentId = c_parentId(cellId);
        while(parentId > -1) {
          if(a_hasNeighbor(parentId, dir)) {
            if(atBnd(c_neighborId(parentId, dir))) {
              nearb = true;
            }
            break;
          }
          parentId = c_parentId(parentId);
        }
      } else if(atBnd(c_neighborId(cellId, dir))) {
        a_hasProperty(cellId, SolverCell::AtStructuredRegion) = false;
        nearb = true;
        break;
      }
    }
    if(nearb) {
      // nearBoundaryCells.push_back( cellId );
      nearBnd(cellId) = true;
      continue;
    }
    if(a_hasProperty(cellId, SolverCell::AtStructuredRegion)) {
      // structuredCells[ a_level(cellId) - minLevel() ].push_back( cellId );
    } else {
      MInt parentId = c_parentId(cellId);
      if(parentId > -1) {
        if(!a_hasProperty(parentId, SolverCell::AtStructuredRegion)) {
          a_hasProperty(parentId, SolverCell::AtStructuredRegion) = true;
          for(MInt dir = 0; dir < m_noDirs; dir++) {
            if(!a_hasNeighbor(parentId, dir)) {
              a_hasProperty(parentId, SolverCell::AtStructuredRegion) = false;
              break;
            }
          }
          if(a_hasProperty(parentId, SolverCell::AtStructuredRegion)) {
            // structuredCells[ a_level(parentId) - minLevel() ].push_back( parentId );
          } else {
            mTerm(1, "strange grid configuration (1).");
          }
        }
      } else {
        cerr << c_globalId(cellId) << " " << a_hasProperty(cellId, Cell::IsHalo) << endl;
        mTerm(1, "strange grid configuration (2).");
      }
    }
  }
}


// this sets b_properties[SolverCell::IsFlux]
// see also writeListOfActiveFlowCells
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::tagCellsNeededForSurfaceFlux() {
  TRACE();

  const MInt noCells = a_noCells();
  const MInt noDirs = 2 * nDim;
  const MInt noSurfaces = a_noSurfaces();
  //---end of initialization

  // reset the property 10 (flux computation)
  for(MInt cellId = 0; cellId < noCells; cellId++) {
    a_hasProperty(cellId, SolverCell::IsDummy) = false;
    a_hasProperty(cellId, SolverCell::IsFlux) = false;
  }

  // tag those cells which are needed for the surface flux computation
  // add two additional layers
  for(MInt s = 0; s < noSurfaces; s++) {
    ASSERT(a_surfaceNghbrCellId(s, 0) > -1 && a_surfaceNghbrCellId(s, 1) > -1, to_string(s));
    a_hasProperty(a_surfaceNghbrCellId(s, 0), SolverCell::IsFlux) = true;
    a_hasProperty(a_surfaceNghbrCellId(s, 1), SolverCell::IsFlux) = true;
  }

  for(MInt addLayer = 0; addLayer < 2; addLayer++) {
    for(MInt cellId = 0; cellId < noCells; cellId++) {
      if(a_hasProperty(cellId, SolverCell::IsFlux) && !a_isBndryGhostCell(cellId)) {
        for(MInt dir = 0; dir < noDirs; dir++) {
          MInt gridcellId = cellId;
          if(a_hasProperty(cellId, SolverCell::IsSplitClone)) {
            gridcellId = m_splitChildToSplitCell.find(cellId)->second;
          }
          if(a_hasNeighbor(gridcellId, dir) > 0) {
            a_hasProperty(c_neighborId(gridcellId, dir), SolverCell::IsDummy) = true;
          }
        }
      }
    }
    // refresh
    for(MInt cellId = 0; cellId < noCells; cellId++) {
      if(a_hasProperty(cellId, SolverCell::IsDummy)) {
        a_hasProperty(cellId, SolverCell::IsFlux) = true;
      }
    }
  }
}


/** \brief Checks whether cells' isGhost and the boundary Id coincede. Cells' isGhost is
 *        is used to tell the grid about ghost cells. In the solver sometimes boundaryId == -2
 *        is used to check for ghost cells
 *
 * @author Thomas Schilden, 5.9.17
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::checkGhostCellIntegrity() {
  TRACE();
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    const MBool isGhost = a_isBndryGhostCell(cellId);
    const MInt boundaryId = a_bndryId(cellId);
    if((isGhost && boundaryId != -2) || (!isGhost && boundaryId == -2)) {
      cout << "ERROR: globalId: " << c_globalId(cellId) << " " << isGhost << " " << boundaryId << endl;
      mTerm(1, AT_, "ERROR in checkGhostCellIntegrity");
    }
  }
}

//-------------------------------------------------------------------------------------

template <MInt nDim_, class SysEqn>
inline MBool FvCartesianSolverXD<nDim_, SysEqn>::gridPointIsInside(MInt exId, MInt node) {
  MFloat x[nDim];
  ASSERT(exId > -1 && exId < m_extractedCells->size() && node > -1 && node < IPOW2(nDim), "");
  MInt gridPointId = m_extractedCells->a[exId].m_pointIds[node];
  ASSERT(gridPointId > -1 && gridPointId < m_gridPoints->size(), "");
  for(MInt i = 0; i < nDim; i++) {
    x[i] = m_gridPoints->a[gridPointId].m_coordinates[i];
  }
  return m_geometry->pointIsInside2(x);
}


/**
 * \brief Writes cut cell information to an existing grid file in order to visualize it in ParaView.
 *
 * \author Michael Schlottke (mic) <mic@aia.rwth-aachen.de>
 * \author Lennart Schneiders
 * \date 2012-11-20, 2013-07-30
 * \note substituted cut-faces output by cut-edges to save disk space and simplify the grid reader, Lennart
 * \note added output of boundary surface centroids, Lennart
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::writeCutCellsToGridFile() {
  TRACE();

  // Open grid file
  using namespace maia::parallel_io;
  ParallelIo parallelIo(outputDir() + grid().gridInputFileName(), PIO_APPEND, mpiComm());

  // Check if cut cell information is already in the grid file - if yes, inform the user
  // that modifying that data is not possible and return from the method.
  if(parallelIo.hasDataset("cutCellIds", 1)) {
    // m_log << "Cannot add cut cell information as it is already in the grid file." << endl;
    return;
  }

  // Collect all necessary information for cut cell visualization
  MInt noBndryCells = 0;
  for(MInt bndryId = 0; bndryId < m_bndryCells->size(); bndryId++) {
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(!a_isHalo(cellId)) {
      noBndryCells++;
    }
  }

  // Save number of cut points for boundary cells
  MIntScratchSpace noCutPoints(noBndryCells, FUN_, "noCutPoints");
  MInt localNoCutPoints = 0;
  MInt bcnt = 0;
  for(MInt bndryId = 0; bndryId < m_bndryCells->size(); bndryId++) {
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(a_isHalo(cellId)) continue;
    noCutPoints[bcnt] = m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
    localNoCutPoints += noCutPoints[bcnt];
    bcnt++;
  }

  // Save cut edges and cut point coordinates
  MIntScratchSpace cutEdges(localNoCutPoints, FUN_, "cutEdges");
  MFloatScratchSpace cutCoordinates(localNoCutPoints, nDim, FUN_, "cutCoordinates");
  MInt ccId = 0;
  bcnt = 0;
  for(MInt bndryId = 0; bndryId < m_bndryCells->size(); bndryId++) {
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(a_isHalo(cellId)) continue;
    // Create array to keep track of checked edges
    MInt edgeChecked[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    for(MInt cutId = 0; cutId < m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cutId++) {
      MInt edge;
      edge = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cutId];

      // Skip if edge was already checked
      if(edgeChecked[edge]) {
        continue;
      }

      cutEdges[ccId] = edge;
      edgeChecked[edge] = 1;

      for(MInt dim = 0; dim < nDim; dim++) {
        cutCoordinates(ccId, dim) = m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cutId][dim];
      }
      ccId++;
    }
    bcnt++;
  }


  // Save whether original cell vertices are inside or outside the domain
  // signStencil is needed for the calculation of the vertex coordinates
  const MFloat signStencil[8][3] = {{-F1, -F1, -F1}, {F1, -F1, -F1}, {-F1, F1, -F1}, {F1, F1, -F1},
                                    {-F1, -F1, F1},  {F1, -F1, F1},  {-F1, F1, F1},  {F1, F1, F1}};
  // cellLengths holds the length of all cells depending on their refinement level
  vector<MFloat> cellLengths(maxRefinementLevel() + 1);
  for(vector<MFloat>::size_type i = 0; i < cellLengths.size(); i++) {
    cellLengths[i] = c_cellLengthAtLevel(i);
  }
  // Iterate over all cells, then all points to calculate and store whether the point is inside or not
  MIntScratchSpace pointInside(noBndryCells, IPOW2(nDim), FUN_, "pointInside");
  bcnt = 0;
  for(MInt bndryId = 0; bndryId < m_bndryCells->size(); bndryId++) {
    const MInt cellId = m_bndryCells->a[bndryId].m_cellId;
    if(a_isHalo(cellId)) continue;
    for(MInt pointId = 0; pointId < IPOW2(nDim); pointId++) {
      // Here we loop over all directions to calculate the coordinate of the corner point,
      // then we check whether it is inside or not
      MFloat pointCoordinates[MAX_SPACE_DIMENSIONS];
      for(MInt dir = 0; dir < nDim; dir++) {
        const MFloat cellCenterCoord = a_coordinate(cellId, dir);
        const MFloat cellLength = cellLengths[a_level(cellId)];
        pointCoordinates[dir] = cellCenterCoord + signStencil[pointId][dir] * F1B2 * cellLength;
      }
      pointInside(bcnt, pointId) = m_geometry->pointIsInside2(pointCoordinates);
    }
    bcnt++;
  }

  // Determine data offsets for cells, boundary cells, and cut points in the grid file
  ParallelIo::size_type cellOffset, bndryCellOffset, cutPointOffset;
  ParallelIo::size_type globalNoCells, globalNoBndryCells, globalNoCutPoints;
  parallelIo.calcOffset(noInternalCells(), &cellOffset, &globalNoCells, mpiComm());
  parallelIo.calcOffset(noBndryCells, &bndryCellOffset, &globalNoBndryCells, mpiComm());
  parallelIo.calcOffset(localNoCutPoints, &cutPointOffset, &globalNoCutPoints, mpiComm());

  // Add new variables to grid file
  parallelIo.defineArray(PIO_INT, "cutCellIds", globalNoCells);
  parallelIo.defineArray(PIO_INT, "noCutPoints", globalNoBndryCells);
  parallelIo.defineArray(PIO_INT, "cutEdges", globalNoCutPoints);
  parallelIo.defineArray(PIO_FLOAT, "cutCoordinates", globalNoCutPoints * nDim);
  parallelIo.defineArray(PIO_INT, "pointIsInside", globalNoBndryCells * IPOW2(nDim));

  // Write data to file
  // This field is used to show whether a cell has cut cell information or not
  parallelIo.setOffset(noInternalCells(), cellOffset);
  parallelIo.writeArray(&a_bndryId(0), "cutCellIds");

  parallelIo.setOffset(noBndryCells, bndryCellOffset);
  parallelIo.writeArray(noCutPoints.getPointer(), "noCutPoints");

  parallelIo.setOffset(localNoCutPoints, cutPointOffset);
  parallelIo.writeArray(cutEdges.getPointer(), "cutEdges");

  parallelIo.setOffset(localNoCutPoints * nDim, cutPointOffset * nDim);
  parallelIo.writeArray(cutCoordinates.getPointer(), "cutCoordinates");

  parallelIo.setOffset(noBndryCells * IPOW2(nDim), bndryCellOffset * IPOW2(nDim));
  parallelIo.writeArray(pointInside.getPointer(), "pointIsInside");
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeVorticity3D(MFloat* const vorticity) {
  TRACE();

  MInt offset = a_noCells();
  for(MInt c = 0; c < noInternalCells(); c++) {
    vorticity[c] = F1B2 * (a_slope(c, PV->W, 1) - a_slope(c, PV->V, 2));
    vorticity[offset + c] = F1B2 * (a_slope(c, PV->U, 2) - a_slope(c, PV->W, 0));
    vorticity[offset * 2 + c] = F1B2 * (a_slope(c, PV->V, 0) - a_slope(c, PV->U, 1));
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeVorticity2D(MFloat* const vorticity) {
  TRACE();

  for(MInt c = 0; c < noInternalCells(); c++) {
    vorticity[c] = F1B2 * (a_slope(c, PV->V, 0) - a_slope(c, PV->U, 1));
  }
}


/// \brief Compute vorticity and store in vorticity pointer (transposed version)
///
/// \author Michael Schlottke-Lakemper (mic) <mic@aia.rwth-aachen.de>
/// \date 2015-11-24
///
/// \param[out] vorticity Pointer to enough storage for vorticity
///
/// Vorticity w for cells 0, 1, 2 is stored as follows:
/// wx_0, wy_0, wz_0, wx_1, wy_1, wz_1, wx_2, wy_2, wz_2
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeVorticity3DT(MFloat* const vorticity) {
  TRACE();

  for(MInt c = 0; c < noInternalCells(); c++) {
    vorticity[3 * c + 0] = F1B2 * (a_slope(c, PV->W, 1) - a_slope(c, PV->V, 2));
    vorticity[3 * c + 1] = F1B2 * (a_slope(c, PV->U, 2) - a_slope(c, PV->W, 0));
    vorticity[3 * c + 2] = F1B2 * (a_slope(c, PV->V, 0) - a_slope(c, PV->U, 1));
  }
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeQCriterion(MFloatScratchSpace& qCriterion) {
  TRACE();
  // Q - criterion
  MFloat normS, normO;
  MInt offsetS = nDim * nDim;
  MInt tmpSize = offsetS + offsetS;
  MFloatScratchSpace grad(offsetS, AT_, "grad");
  MFloatScratchSpace q(tmpSize, AT_, "q");

  for(MInt c = 0; c < noInternalCells(); c++) {
    // compute the velocity vector gradient
    for(MInt i = 0; i < nDim; i++) {
      for(MInt j = 0; j < nDim; j++) {
        grad.p[i * nDim + j] = a_slope(c, PV->VV[i], j);
      }
    }
    // compute the strain rate and vorticity tensor
    for(MInt i = 0; i < nDim; i++) {
      for(MInt j = 0; j < nDim; j++) {
        q.p[j + i * nDim] = F1B2 * (grad.p[i * nDim + j] + grad.p[j * nDim + i]);
        q.p[j + i * nDim + offsetS] = F1B2 * (grad.p[i * nDim + j] - grad.p[j * nDim + i]);
      }
    }
    // compute the value of Q
    normS = F0;
    normO = F0;
    for(MInt i = 0; i < nDim; i++) {
      for(MInt j = 0; j < nDim; j++) {
        normS += POW2(q.p[i * nDim + j]);
        normO += POW2(q.p[i * nDim + offsetS + j]);
      }
    }
    qCriterion.p[c] = F1B2 * (normO - normS);
  }
}

// ---------------------------------------------------------------------------------------------


/** \brief This function stores the massivley parallel flow information of the cells
 *
 * possible variables: doubles, integers collected by this->collectVariables()
 * possible parameters: doubles, integers collected by this->collectParameters()
 *
 * \todo labels:FV,IO writing an IO class
 *
 * \author Stephan Schlimpert, update Tim Wegmann
 * \date October 2011, Nov. 2020
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::saveGridFlowVarsPar(
    const MChar* fileName, MInt noTotalCells, MLong noInternalCellIds, MFloatScratchSpace& dbVariables,
    vector<MString>& dbVariablesName, MInt noDbVars, MIntScratchSpace& idVariables, vector<MString>& idVariablesName,
    MInt noIdVars, MFloatScratchSpace& dbParameters, vector<MString>& dbParametersName, MIntScratchSpace& idParameters,
    vector<MString>& idParametersName, const MInt* recalcIds) {
  TRACE();

  IF_CONSTEXPR(nDim != 2 && nDim != 3) {
    stringstream errorMessage;
    errorMessage << " In global function saveGridFlowVarsPar: wrong number of dimensions !" << endl;
    mTerm(1, AT_, errorMessage.str());
    return;
  }

  // File creation.
  MString tmpNcVariablesName;
  noDbVars = dbVariablesName.size();
  noIdVars = idVariablesName.size();
  MInt noIdPars = idParametersName.size();
  MInt noDbPars = dbParametersName.size();
  vector<MString> ncVariablesName;
  MFloat* tmpDbVariables;
  MInt* tmpIdVariables;

  using namespace parallel_io;
  ParallelIo parallelIo(fileName, PIO_REPLACE, mpiComm());

  // Creating file header
  MLong num = -1;
  auto longNoInternalCells = (MLong)noInternalCellIds;
  MPI_Allreduce(&longNoInternalCells, &num, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "longNoInternalCells", "num");
  parallelIo.setAttribute(num, "noCells");

  parallelIo.setAttribute(solverId(), "solverId");


  for(MInt j = 0; j < noDbVars; j++) {
    tmpNcVariablesName = "variables" + to_string(j);
    ncVariablesName.push_back(tmpNcVariablesName);

    parallelIo.defineArray(PIO_FLOAT, ncVariablesName[j], num);
    m_log << dbVariablesName[j].c_str() << endl;
    parallelIo.setAttribute(dbVariablesName[j], "name", ncVariablesName[j]);
  }

  for(MInt j = 0; j < noIdVars; j++) {
    MInt k = j + noDbVars;
    tmpNcVariablesName = "variables" + to_string(k);
    ncVariablesName.push_back(tmpNcVariablesName);

    parallelIo.defineArray(PIO_INT, ncVariablesName[k], num);
    parallelIo.setAttribute(idVariablesName[j], "name", ncVariablesName[k]);
  }

  MString XString = "variables" + to_string(noDbVars + noIdVars + (MInt)isDetChem<SysEqn> + 1);
  MString YString = "variables" + to_string(noDbVars + noIdVars + (MInt)isDetChem<SysEqn> + 2);

  IF_CONSTEXPR(isDetChem<SysEqn>) {
    parallelIo.defineArray(PIO_FLOAT, XString, num);
    parallelIo.defineArray(PIO_FLOAT, YString, num);
    parallelIo.setAttribute("XCoord", "name", XString);
    parallelIo.setAttribute("YCoord", "name", YString);
  }

  for(MInt j = 0; j < noIdPars; j++) {
    // solution parameters
    parallelIo.setAttribute(idParameters.p[j], idParametersName[j]);
  }

  for(MInt j = 0; j < noDbPars; j++) {
    // solution parameters
    parallelIo.setAttribute(dbParameters.p[j], dbParametersName[j]);
  }
  parallelIo.setAttribute(m_currentGridFileName, "gridFile");

  if(m_initialCondition == 16) {
    parallelIo.setAttributes(&m_Re, "Re", 1);
    parallelIo.setAttributes(&sysEqn().m_Re0, "Re0", 1);
    parallelIo.setAttributes(&m_randomDeviceSeed, "randomDeviceSeed", 1);
  }

  ParallelIo::size_type start = 0;
  ParallelIo::size_type count = 1;

  // Update start and count for parallel writing
  MPI_Exscan(&noInternalCellIds, &start, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "noInternalCells", "start");
  count = noInternalCellIds;
  parallelIo.setOffset(count, start);

  for(MInt j = 0; j < noDbVars; j++) {
    tmpDbVariables = &(dbVariables.p[j * noTotalCells]);

    if(m_recalcIds != nullptr) {
      MFloatScratchSpace tmpDouble(count, AT_, "tmpDouble");
      for(MInt l = 0; l < count; ++l) {
        tmpDouble[l] = tmpDbVariables[recalcIds[l]];
      }
      parallelIo.writeArray(tmpDouble.begin(), ncVariablesName[j]);
    } else {
      parallelIo.writeArray(tmpDbVariables, ncVariablesName[j]);
    }
  }

  IF_CONSTEXPR(isDetChem<SysEqn>) {
    MFloatScratchSpace tmpX(a_noCells(), AT_, "tmpX");
    MFloatScratchSpace tmpY(a_noCells(), AT_, "tmpY");
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      tmpX[cellId] = a_coordinate(cellId, 0);
    }
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      tmpY[cellId] = a_coordinate(cellId, 1);
    }
    parallelIo.writeArray(&tmpX[0], XString);
    parallelIo.writeArray(&tmpY[0], YString);
  }

  for(MInt j = 0; j < noIdVars; j++) {
    tmpIdVariables = &(idVariables.p[j * noTotalCells]);
    if(m_recalcIds != nullptr) {
      MIntScratchSpace tmpInt(count, AT_, "tmpInt");
      for(MInt l = 0; l < count; ++l) {
        tmpInt[l] = tmpIdVariables[recalcIds[l]];
      }
      parallelIo.writeArray(tmpInt.begin(), ncVariablesName[j + noDbVars]);
    } else {
      parallelIo.writeArray(tmpIdVariables, ncVariablesName[j + noDbVars]);
    }
  }

  m_log << Scratch::printSelfReport();
}


/// \brief Load the restart time step from the restart file (useNonSpecifiedRestartFile enabled)
template <MInt nDim_, class SysEqn>
MInt FvCartesianSolverXD<nDim_, SysEqn>::determineRestartTimeStep() const {
  TRACE();
  using namespace maia::parallel_io;

  if(!m_useNonSpecifiedRestartFile) {
    mTerm(1, "determineRestartTimeStep should only be used with useNonSpecifiedRestartFile enabled!");
  }

  std::stringstream varFileName;
  if(!m_multipleFvSolver) {
    varFileName << restartDir() << "restartVariables" << ParallelIo::fileExt();
  } else {
    varFileName << restartDir() << "restartVariables" << m_solverId << "_" << ParallelIo::fileExt();
  }
  ParallelIo parallelIo(varFileName.str(), PIO_READ, MPI_COMM_SELF);
  MInt timeStep = -1;
  parallelIo.getAttribute(&timeStep, "globalTimeStep");
  return timeStep;
}

// -----------------------------------------------------------------------------------------------------------

/** \brief This function loads the flow information of the cells
 *        such as variables and attributes like u_velocity,density,etc.,
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::loadRestartTime(const MChar* fileName, MInt& globalTimeStepInput,
                                                         MFloat& timeInput, MFloat& physicalTimeInput) {
  TRACE();

  ParallelIo parallelIo(fileName, maia::parallel_io::PIO_READ, MPI_COMM_SELF);

  CartesianNetcdf CN;
  // ----------------------------------------------------------

  // --------------------------------------------------------------
  // Read solution parameters
  // number of samples used for averaging

  // global time step
  parallelIo.getAttribute(&globalTimeStepInput, CN.globalTimeStep);
  // solution time
  parallelIo.getAttribute(&timeInput, CN.time);
  // physical time
  parallelIo.getAttribute(&physicalTimeInput, CN.physicalTime);
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::writeCellData(MInt c) {
  TRACE();

  cerr << "**********************************************************" << endl;
  cerr << "Writing cell data for cell " << c << " at time step " << globalTimeStep << ", " << m_RKStep << "> at level "
       << a_level(c) << endl;
  cerr << "Primitive cell variables: " << endl;
  for(MInt v = 0; v < PV->noVariables; v++) {
    cerr << a_pvariable(c, v) << " ";
  }
  cerr << endl;
  cerr << "Conservative cell variables: " << endl;
  for(MInt v = 0; v < CV->noVariables; v++) {
    cerr << a_variable(c, v) << " ";
  }
  cerr << "Cell slopes: " << endl;
  for(MInt v = 0; v < PV->noVariables; v++) {
    for(MInt i = 0; i < 3; i++) {
      cerr << a_slope(c, v, i) << " ";
    }
    cerr << endl;
  }
  cerr << "**********************************************************" << endl;
}

/// Initializes the communication timers
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initializeTimers() {
  TRACE();

  std::fill(m_timers.begin(), m_timers.end(), -1);

  // Create timer group & timer for solver, and start the timer
  NEW_TIMER_GROUP_NOCREATE(m_timerGroup, "FvCartesianSolver (solverId = " + to_string(m_solverId) + ")");
  NEW_TIMER_NOCREATE(m_timers[Timers::SolverType], "total object lifetime", m_timerGroup);
  RECORD_TIMER_START(m_timers[Timers::SolverType]);

  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::TimeInt], "Time-integration", m_timers[Timers::SolverType]);

  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::Rhs], "rhs", m_timers[Timers::TimeInt]);
  // RHS subtimers
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::Muscl], "MUSCL", m_timers[Timers::Rhs]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::Ausm], "AUSM", m_timers[Timers::Rhs]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::ViscFlux], "Viscous flux", m_timers[Timers::Rhs]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::DistFlux], "Distribute flux", m_timers[Timers::Rhs]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::RhsMisc], "Misc", m_timers[Timers::Rhs]);
  if(m_useSandpaperTrip) {
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::SandpaperTrip], "SandpaperTrip", m_timers[Timers::Rhs]);
  }
  if(m_wmLES) {
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::WMExchange], "WMExchange", m_timers[Timers::Rhs]);
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::WMSurfaceLoop], "WMSurfaceLoop", m_timers[Timers::Rhs]);
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::WMFluxCorrection], "WMFluxCorrection", m_timers[Timers::Rhs]);
  }
  IF_CONSTEXPR(isDetChem<SysEqn>) {
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::SurfaceCoefficients], "Surface Coefficients", m_timers[Timers::Rhs]);
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::SurfaceMeanMolarWeight], "Surface Mean Molar Weight",
                           m_timers[Timers::SurfaceCoefficients]);
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::SurfaceTransportCoefficients], "Surface Transport Coefficients",
                           m_timers[Timers::SurfaceCoefficients]);
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::CellCenterCoefficients], "Cell Center Coefficients", m_timers[Timers::Rhs]);
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::SpeciesReactionRates], "Species Reaction Rates", m_timers[Timers::Rhs]);
  }
  // MUSCL subtimers
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::MusclReconst], "LSReconstructCellCenter", m_timers[Timers::Muscl]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::MusclCopy], "copySlopesToSmallCells", m_timers[Timers::Muscl]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::MusclGhostSlopes], "updateGhostCellSlopesInviscid", m_timers[Timers::Muscl]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::MusclCutSlopes], "updateCutOffSlopesInviscid", m_timers[Timers::Muscl]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::MusclReconstSrfc], "reconstructSurfaceData", m_timers[Timers::Muscl]);

  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::ReconstSrfcCompValues], "computeSurfaceValues",
                         m_timers[Timers::MusclReconstSrfc]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::ReconstSrfcCorrVars], "correctSurfaceVariables",
                         m_timers[Timers::MusclReconstSrfc]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::ReconstSrfcUpdateGhost], "updateGhost", m_timers[Timers::MusclReconstSrfc]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::ReconstSrfcUpdateCutOff], "updateCutOff", m_timers[Timers::MusclReconstSrfc]);

  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::RhsBnd], "rhsBnd", m_timers[Timers::TimeInt]);

  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::Lhs], "lhs", m_timers[Timers::TimeInt]);

  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::LhsBnd], "lhsBnd", m_timers[Timers::TimeInt]);

  // LHS-BND subtimers
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::SmallCellCorr], "small cell correction", m_timers[Timers::LhsBnd]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::ComputePV], "compute PV", m_timers[Timers::LhsBnd]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::Exchange], "exchange", m_timers[Timers::LhsBnd]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::CutOff], "cut off", m_timers[Timers::LhsBnd]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::BndryCnd], "boundary conditions", m_timers[Timers::LhsBnd]);

  // Small cell correction subtimers
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::SCCorrInit], "init", m_timers[Timers::SmallCellCorr]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::SCCorrExchange1], "first exchange", m_timers[Timers::SmallCellCorr]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::SCCorrExchange1Wait], "waiting/blocking MPI",
                         m_timers[Timers::SCCorrExchange1]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::SCCorrInterp], "interpolation", m_timers[Timers::SmallCellCorr]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::SCCorrRedist], "redistribution", m_timers[Timers::SmallCellCorr]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::SCCorrExchange2], "second exchange", m_timers[Timers::SmallCellCorr]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::SCCorrExchange2Wait], "waiting/blocking MPI",
                         m_timers[Timers::SCCorrExchange2]);

  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::Residual], "Residual", m_timers[Timers::TimeInt]);
  NEW_SUB_TIMER_NOCREATE(m_timers[Timers::ResidualMpi], "MPI", m_timers[Timers::Residual]);

  // prepare solver subtimers
  if(m_levelSetMb) {
    // preTimeStep
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::PreTime], "PreTimeStep", m_timers[Timers::SolverType]);
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::ReinitSolu], "ReinitSolutionStep", m_timers[Timers::PreTime]);
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::BndryMb], "generateBndryCells", m_timers[Timers::ReinitSolu]);
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::NearBndry], "initNearBndryExc", m_timers[Timers::ReinitSolu]);
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::InitSmallCorr], "initSmallCellCor", m_timers[Timers::ReinitSolu]);
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::GhostCells], "ghostCells", m_timers[Timers::ReinitSolu]);
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::PostTime], "PostTimeStep", m_timers[Timers::SolverType]);
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::PostSolu], "PostSolutionStep", m_timers[Timers::PostTime]);
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::ResidualMb], "Residual-MB", m_timers[Timers::PostSolu]);
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::SurfaceForces], "SurfaceForces", m_timers[Timers::PostSolu]);
    NEW_SUB_TIMER_NOCREATE(m_timers[Timers::LevelSetCorr], "LevelSetCorr", m_timers[Timers::PostSolu]);
  }

  // TODO labels:FV,TIMERS Create accumulated timers that monitor selected subsystems
  /* NEW_SUB_TIMER_NOCREATE( */
  /*     m_timers[Timers::Accumulated], "selected accumulated timers", m_timers[Timers::SolverType]); */
  /* NEW_SUB_TIMER_NOCREATE(m_timers[Timers::IO], "IO", */
  /*                        m_timers[Timers::Accumulated]); */
  /* NEW_SUB_TIMER_NOCREATE(m_timers[Timers::MPI], "MPI", */
  /*                        m_timers[Timers::Accumulated]); */


  // Communication
  NEW_TIMER_GROUP_NOCREATE(m_tgfv, "FV Exchange");
  NEW_TIMER_NOCREATE(m_tcomm, "Communication", m_tgfv);

  NEW_SUB_TIMER_NOCREATE(m_texchange, "exchange", m_tcomm);

  NEW_SUB_TIMER_NOCREATE(m_tgatherAndSend, "gather and send", m_texchange);
  NEW_SUB_TIMER_NOCREATE(m_tgather, "gather", m_tgatherAndSend);
  NEW_SUB_TIMER_NOCREATE(m_tsend, "send", m_tgatherAndSend);
  NEW_SUB_TIMER_NOCREATE(m_tgatherAndSendWait, "wait", m_tgatherAndSend);
  NEW_SUB_TIMER_NOCREATE(m_treceive, "receive", m_texchange);
  NEW_SUB_TIMER_NOCREATE(m_tscatter, "scatter", m_texchange);
  NEW_SUB_TIMER_NOCREATE(m_tscatterWaitSome, "wait some", m_tscatter);
  NEW_SUB_TIMER_NOCREATE(m_treceiving, "receiving", m_treceive);
  NEW_SUB_TIMER_NOCREATE(m_treceiveWait, "waiting", m_treceive);

  NEW_SUB_TIMER_NOCREATE(m_texchangeDt, "exchange time-step", m_tcomm);
}

/// \brief Reads the Runge-Kutta properties and initializes the variables
/// required for Runge Kutta time stepping.
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initializeRungeKutta() {
  TRACE();

  setRungeKuttaProperties();
  m_RKStep = 0;
}


/*! \brief load variables for the specified timeStep
 *
 * \author A. Niemoeller
 * \date 11.12.2013
 *
 * loads the variables from a restartFile for a given timeStep
 *
 * \param[in] timeStep timestep of restartfile
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::loadSampleVariables(MInt timeStep) {
  m_loadSampleVariables = true;
  m_restartTimeStep = timeStep;
  loadRestartFile();
  m_loadSampleVariables = false;
}

/*! \brief read only access to primitive variables of a single cell
 *
 * \author A. Niemoeller
 * \date 11.12.2013
 *
 * get cell variables of a single cell
 *
 * \param[in] cellId cell that is accessed
 * \param[in,out] vars pointer to the variables
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getSampleVariables(MInt cellId, const MFloat*& vars) {
  vars = &a_pvariable(cellId, 0);
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getSampleVariables(const MInt cellId, std::vector<MFloat>& vars) {
  const MInt noVars = vars.size();
  ASSERT(noVars <= noVariables(), "noVars > noVariables()");
  for(MInt varId = 0; varId < noVars; varId++) {
    vars[varId] = a_pvariable(cellId, varId);
  }
}

/// \brief Return the sample variable names (primitive variables)
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getSampleVariableNames(std::vector<MString>& varNames) {
  varNames.clear();
  for(MInt i = 0; i < PV->noVariables; i++) {
    varNames.push_back(PV->varNames[i]);
  }
}

/// \brief Access derivatives of primitive variables of a given cell.
///
/// \author Ansgar Niemoeller (ansgar) <a.niemoeller@aia.rwth-aachen.de>
/// \date 2016-07-13
///
/// \param[in] cellId Requested cell.
/// \parma[out] vars Pointer to the derivatives of the primitive variables.
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getSampleVarsDerivatives(const MInt cellId, const MFloat*& vars) {
  vars = &a_slope(cellId, 0, 0);
}

template <MInt nDim_, class SysEqn>
MBool FvCartesianSolverXD<nDim_, SysEqn>::getSampleVarsDerivatives(const MInt cellId, std::vector<MFloat>& vars) {
  std::memcpy(&vars[0], &a_slope(cellId, 0, 0), sizeof(MFloat) * (nDim * PV->noVariables));
  return true; // = implemented for this solver
}

/*! \brief calculates heatRelease, currently used for postprocessing (average_in)
 *
 * \author D.Zilles
 * \date 29.5.2017
 *
 * param[out] heatRelease
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::calculateHeatRelease() {
  IF_CONSTEXPR(isDetChem<SysEqn>) {
    for(MInt cellId = 0; cellId < a_noCells(); ++cellId) {
      const MFloat dampeningFactor = m_heatReleaseDamp ? m_dampFactor[cellId] : F1;
      m_heatRelease[cellId] = F0;
      for(MInt s = 0; s < m_noSpecies; ++s) {
        m_heatRelease[cellId] -= dampeningFactor * a_speciesReactionRate(cellId, s) * m_standardHeatFormation[s];
      }
    }
  }
  else {
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      m_heatRelease[cellId] = a_reactionRate(cellId, 0) * a_cellVolume(cellId) * (m_burntUnburntTemperatureRatio - F1)
                              * (F1 / (m_gamma - F1));
    }
  }
}

/*! \brief returns
 *
 * \author D.Zilles
 * \date 29.5.2017
 *
 * \param[out] heatRelease
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getHeatRelease(MFloat*& heatRelease) {
  heatRelease = m_heatRelease;
}

/*! \brief calculates heat flux of boundary cells
 *
 * \author Thomas Schilden
 * \date 3.10.2015
 *
 * \param[in] cellId
 * \param[out] heat flux
 *
 */
template <MInt nDim_, class SysEqn>
MFloat FvCartesianSolverXD<nDim_, SysEqn>::getBoundaryHeatFlux(const MInt cellId) const {
  MInt bndryId = a_bndryId(cellId);
  if(bndryId > -1) {
    if(m_bndryCells->a[bndryId].m_noSrfcs > 1) {
      mTerm(1, AT_, "lineOutput not implemented for split cells or such");
    }
    // temperature gradient
    MFloat drhodn = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_normalDeriv[PV->RHO];
    MFloat rhoW = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_primVars[PV->RHO];
    MFloat pW = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_primVars[PV->P];
    return (-m_gamma * pW * drhodn / pow(rhoW, F2));
  }
  return std::numeric_limits<MFloat>::max();
}

/*! \brief returns the time
 *
 * \author Thomas Schilden
 * \date 3.10.2015
 *
 * \param[out] time
 *
 */
template <MInt nDim_, class SysEqn>
MFloat FvCartesianSolverXD<nDim_, SysEqn>::time() const {
  return m_time;
}

/*! \brief wrapper for vorticity computation
 *
 * \author Ansgar Niemoeller
 * \date 09.07.2014
 *
 * \param[out] vorticity collector for computed vorticity
 *
 * Vorticity w for cells 0, 1, 2 is stored as follows:
 * wx_0, wx_1, wx_2, wy_0, wy_1, wy_2, wz_0, wz_1, wz_2
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getVorticity(MFloat* const vorticity) {
  TRACE();

  IF_CONSTEXPR(nDim == 3) { computeVorticity3D(vorticity); }
  else IF_CONSTEXPR(nDim == 2) {
    computeVorticity2D(vorticity);
  }
}


/*! \brief This function computes the pressure from the oldVariables
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::oldPressure(MFloat* const p) {
  TRACE();

  IF_CONSTEXPR(!hasE<SysEqn>)
  mTerm(1, AT_, "Not compatible with SysEqn without RHO_E!");


  for(MInt c = 0; c < noInternalCells(); c++) {
    const MFloat rho = a_oldVariable(c, CV->RHO);
    const MFloat rhoE = a_oldVariable(c, CV->RHO_E);
    IF_CONSTEXPR(nDim == 2) {
      p[c] =
          sysEqn().pressure(rho, POW2(a_oldVariable(c, CV->RHO_VV[0])) + POW2(a_oldVariable(c, CV->RHO_VV[1])), rhoE);
    }
    IF_CONSTEXPR(nDim == 3) {
      p[c] = sysEqn().pressure(rho,
                               POW2(a_oldVariable(c, CV->RHO_VV[0])) + POW2(a_oldVariable(c, CV->RHO_VV[1]))
                                   + POW2(a_oldVariable(c, CV->RHO_VV[2])),
                               rhoE);
    }
  }
}


/*! \brief wrapper for vorticity computation (transposed version)
 *
 * \author Michael Schlottke-Lakemper
 * \date 24.11.2015
 *
 * \param[out] vorticity collector for computed vorticity
 *
 * Vorticity w for cells 0, 1, 2 is stored as follows:
 * wx_0, wy_0, wz_0, wx_1, wy_1, wz_1, wx_2, wy_2, wz_2
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getVorticityT(MFloat* const vorticity) {
  TRACE();

  IF_CONSTEXPR(nDim == 3) { computeVorticity3DT(vorticity); }
  else IF_CONSTEXPR(nDim == 2) {
    computeVorticity2D(vorticity);
  }
}


template <MInt nDim_, class SysEqn>
MFloat& FvCartesianSolverXD<nDim_, SysEqn>::vorticityAtCell(const MInt cellId, const MInt dir) {
  ASSERT(m_vorticity != nullptr, "Vorticity not initialized");
  return m_vorticity[cellId][dir];
}

/*! \brief get dimensionalization parameters
 *
 * \author Ansgar Niemoeller
 * \date 09.07.2014
 *
 * \param[out] dimParams dimensionalization parameters (values and names)
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getDimensionalizationParams(vector<pair<MFloat, MString>>& dimParams) const {
  TRACE();

  dimParams.clear();
  dimParams.push_back(make_pair(m_Re, "Re"));
  dimParams.push_back(make_pair(m_Ma, "Ma"));
  dimParams.push_back(make_pair(sysEqn().gamma_Ref(), "gamma"));
  dimParams.push_back(make_pair(m_gasConstant, "R"));
  dimParams.push_back(make_pair(m_referenceTemperature, "T_ref"));
}


// --------------------------------------------------------------------------------------

/**
 * \brief compute the reconstruction constants of the given cell by a weighted least-squares
 *        approach via singular value decomposition
 *
 * weightMode 0 : only use distance weights
 * weightMode 1 : only use distance weights and set weight = 0 for diagonal neighbors
 * weightMode 2 : use distance and cellFraction weights for all neighbors
 * weightMode 3 : special treatment at rfn-interface
 * weightMode 4 : special treatment at rfn-interface,
 *                away from bndries weights are such that stencil is 2nd order accurate;
 *                m_relocateCenter==true: slopes of bndry cells are determined by a
 *                simultanous least-square in all directions; if stencil of non-bndry
 *                cell has a bndry cell in its stencil, the cell center of that cell is
 *                relocated by means of the temporarily determined least-square slopes
 *
 *
 * fallBackMode -1 : no fall-back, print error message if the computation fails
 * fallBackMode  1 : stencilCheck, based on direct neighbor distance and stencil extension if
 *                   the computation fails
 *
 * \author Lennart Schneiders, Update Tim Wegmann
 */
template <MInt nDim_, class SysEqn>
MFloat FvCartesianSolverXD<nDim_, SysEqn>::computeRecConstSVD(const MInt cellId, const MInt offset,
                                                              MFloatScratchSpace& tmpA, MFloatScratchSpace& tmpC,
                                                              MFloatScratchSpace& weights, const MInt recDim,
                                                              const MInt weightMode, const MInt fallBackMode,
                                                              const std::array<MBool, nDim> dirs,
                                                              const MBool relocateCenter) {
  const MBool allDirs = std::all_of(dirs.begin(), dirs.end(), [](const MBool _) { return _ == false; });
  const MInt noDirs = std::accumulate(dirs.begin(), dirs.end(), 0);
  MInt currentSlopeDir = -1;
  if(noDirs == 1) {
    for(MInt d = 0; d < nDim; ++d) {
      if(dirs[d]) {
        currentSlopeDir = d;
        break;
      }
    }
  }
  ASSERT(a_hasProperty(cellId, SolverCell::IsSplitChild) || a_hasProperty(cellId, SolverCell::IsSplitClone)
             || c_isLeafCell(cellId),
         "");
  ASSERT(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel), "");
  ASSERT(a_hasProperty(cellId, SolverCell::IsFlux), "");
  ASSERT(!a_hasProperty(cellId, SolverCell::IsNotGradient), "");
  ASSERT(!a_isBndryGhostCell(cellId), "");
  const MInt noNghbrIds = a_noReconstructionNeighbors(cellId);
  if(noNghbrIds == 0) {
    return F0;
  }
  ASSERT(tmpA.size0() >= noNghbrIds && tmpA.size1() >= recDim, "");
  ASSERT(tmpC.size0() >= recDim && tmpC.size1() >= noNghbrIds, "");
  ASSERT(weights.size0() >= noNghbrIds, "");
  ASSERT(noNghbrIds <= m_cells.noRecNghbrs(), "");

  const MInt rootCell = (a_hasProperty(cellId, SolverCell::IsSplitChild)) ? getAssociatedInternalCell(cellId) : cellId;
  const MFloat cellLength = c_cellLengthAtCell(cellId);

  ASSERT(rootCell > -1 && rootCell < a_noCells(), "");

  //
  if((weightMode == 3 || weightMode == 4) && allDirs) {
    std::array<MBool, nDim> dirsJmp = {};
    for(MInt d = 0; d < nDim; ++d) {
      const MBool coarseNghbr =
          m_cells.nghbrInterface(cellId, 2 * d) == 3 || m_cells.nghbrInterface(cellId, 2 * d + 1) == 3;
      const MBool fineNghbr =
          m_cells.nghbrInterface(cellId, 2 * d) == 2 || m_cells.nghbrInterface(cellId, 2 * d + 1) == 2;
      if(coarseNghbr || fineNghbr) {
        dirsJmp[d] = true;
      } else {
        dirsJmp[d] = false;
      }
    }

    //
    MBool hasBndryInStencil = false;
    for(MInt n = 0; n < noNghbrIds; n++) {
      if(a_isBndryCell(a_reconstructionNeighborId(cellId, n))) {
        hasBndryInStencil = true;
        break;
      }
    }

    // Bndry cells are by now treated as before, so one LS-system is solved for slopes in all directions
    if(a_isBndryCell(cellId) || a_isBndryGhostCell(cellId) || hasBndryInStencil) {
      std::fill_n(&dirsJmp[0], nDim, false);
    }

    // Determine provisional slopes to correct cell center of bndry cells
    if(weightMode == 4 && m_relocateCenter) {
      if(hasBndryInStencil && !a_isBndryCell(cellId)) {
        std::array<MBool, nDim> dir;
        std::fill_n(&dir[0], nDim, true);
        computeRecConstSVD(cellId, offset, tmpA, tmpC, weights, recDim, weightMode, fallBackMode, dir);
      }
    }

    MFloat condNumMax = std::numeric_limits<MFloat>::lowest();
    std::array<MBool, nDim> dir = dirsJmp;
    for(auto& d : dir) {
      d = !d;
    }
    if(std::any_of(dir.begin(), dir.end(), [](MBool _) { return _ == true; })) {
      auto condNum = computeRecConstSVD(cellId, offset, tmpA, tmpC, weights, recDim, weightMode, fallBackMode, dir,
                                        !a_isBndryCell(cellId) && m_relocateCenter);
      condNumMax = mMax(condNum, condNumMax);
    }

    if(weightMode == 3) {
      if(std::any_of(dirsJmp.begin(), dirsJmp.end(), [](MBool _) { return _ == true; })) {
        auto condNum =
            computeRecConstSVD(cellId, offset, tmpA, tmpC, weights, recDim, weightMode, fallBackMode, dirsJmp);
        condNumMax = mMax(condNum, condNumMax);
      }
    }
    if(weightMode == 4) { // all jmp-directions are treated seperately according to method-of-lines principle
      for(MInt d = 0; d < nDim; ++d) {
        if(dirsJmp[d]) {
          std::array<MBool, nDim> dirsJmp_ = {};
          dirsJmp_[d] = true;
          auto condNum = computeRecConstSVD(cellId, offset, tmpA, tmpC, weights, recDim, weightMode, fallBackMode,
                                            dirsJmp_, !a_isBndryCell(cellId) && m_relocateCenter);
          condNumMax = mMax(condNum, condNumMax);
        }
      }
    }

    return condNumMax;
  }

  // Lambda fnct for weightMode == 3 & 4
  constexpr MFloat EPS = 1e-10;
  // Returns the direction of the nghbr, if nghbrId is a direct nghbr; returns -1 if nghbrId is the
  // ghost cell of cellId; return -2 if nghbrId does not share a common surface.
  auto isDirectNghbr = [=](const MInt nghbrId) {
    if(a_isBndryCell(cellId) && a_isBndryGhostCell(nghbrId)) {
      return -1;
    }
    for(MInt d = 0; d < nDim; ++d) {
      if(!dirs[d]) {
        continue;
      }
      for(MInt side = 0; side < 2; ++side) {
        const MInt orientation = 2 * d + side;
        if(a_level(nghbrId) == a_level(cellId)) {
          if(checkNeighborActive(cellId, orientation) && a_hasNeighbor(cellId, orientation)
             && c_neighborId(cellId, orientation) == nghbrId) {
            return orientation;
          }
        } else if(a_level(nghbrId) < a_level(cellId)) {
          if(c_neighborId(c_parentId(cellId), orientation) == nghbrId) {
            return orientation;
          }
        } else if(a_level(nghbrId) > a_level(cellId)) {
          if(checkNeighborActive(cellId, orientation) && a_hasNeighbor(cellId, orientation)) {
            const MInt nghbrParentId = c_neighborId(cellId, orientation);
            for(MInt child = 0; child < IPOW2(nDim); child++) {
              if(c_childId(nghbrParentId, child) == nghbrId) {
                if(childCodePro[orientation] & 1 << child) {
                  return orientation;
                }
              }
            }
          }
        }
      }
    }
    return -2;
  };

  // initialise weights
  weights.fill(F0);

  // a) set direct neighbors for weightMode 1
  set<MInt> nextNghbrs;
  nextNghbrs.clear();
  if(weightMode == 1) {
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      if(checkNeighborActive(rootCell, dir) && a_hasNeighbor(rootCell, dir) > 0) {
        const MInt nghbrId = c_neighborId(rootCell, dir);
        if(a_hasProperty(nghbrId, SolverCell::IsOnCurrentMGLevel)) {
          nextNghbrs.insert(nghbrId);
        }
      }
    }
  }

  // b) set weights based on weightMode
  array<MInt, 2 * nDim> noFineNghbrs{};
  MBool hasBndryInStencil = false;
  for(MInt n = 0; n < noNghbrIds; n++) {
    const MInt nghbrId = a_reconstructionNeighborId(cellId, n);
    const MInt nghbrRootId =
        (a_hasProperty(nghbrId, SolverCell::IsSplitChild)) ? getAssociatedInternalCell(nghbrId) : nghbrId;

    hasBndryInStencil = hasBndryInStencil || a_isBndryCell(nghbrId);

    // compute distance weight
    MFloat dxdx = F0;
    for(MInt i = 0; i < nDim; i++) {
      dxdx += POW2(a_coordinate(nghbrId, i) - a_coordinate(cellId, i));
    }

    MFloat fac = F1;
    // compute volume weight factor for weightMode 2
    // based on cell distances and volume ratios
    // to account for small cells falling out of the stencil!
    if(weightMode == 2 && !a_isBndryGhostCell(nghbrId) && a_isBndryCell(nghbrId)) {
      const MFloat vf = a_cellVolume(nghbrId) / c_cellVolumeAtLevel(a_level(nghbrId));
      fac = maia::math::deltaFun(vf, 1e-6, 0.1);
      // don't kompletly fade out small cells, but reduce them to the same value as uncut neighbors
      // which have a larger distance!
      if(m_engineSetup) {
        fac = fac * 0.5 + 0.5;
      }
      // if (a_bndryId( nghbrId )== -2 ) {
      //  fac = F1 - maia::math::deltaFun( m_fvBndryCnd->m_bndryCells->a[a_bndryId( cellId )].m_volume/m_gridCellVolume[
      //  a_level(cellId) ], 0.9, F1 );
      //}
    }

    // set weight to zero for all non-direct neighbors for weightMode 1
    if(weightMode == 1 && !a_isBndryGhostCell(nghbrId)) {
      fac = (nextNghbrs.count(nghbrRootId) == 0) ? F0 : fac;
      // TODO labels:FV possibly change: do not to compute the diagonal neighbors as
      //      their weight is currently set to zero and their reconstruction Constant
      //      is thus very low!
    }

    if(weightMode == 3 || weightMode == 4) {
      // By now bndry cells are excluded
      const MInt orientation = isDirectNghbr(nghbrId);
      if(((!a_isBndryCell(cellId) && !a_isBndryGhostCell(nghbrId)) || m_reExcludeBndryDiagonals) && orientation == -2) {
        fac = 0.0;
      } else if(m_2ndOrderWeights && (!a_isBndryCell(cellId) || m_reExcludeBndryDiagonals)
                && a_level(nghbrId) > a_level(cellId)) {
        TERMM_IF_NOT_COND(orientation >= 0 && orientation < 2 * nDim, "");
        ++noFineNghbrs[orientation];
      }
    }

    weights[n] = fac * maia::math::RBF(dxdx, POW2(cellLength));
    // weights[n] = POW2(c_cellLengthAtCell(cellId) )/dxdx;
  }

  // Update weights such that slope computation is 2nd order over rfn-jmp for 3-point stencil for locally 1D flow.
  // Since currently the stencils of bndry cells include diagonal cells, a weighting is needed
  // for the solutoin to be smooth, and weighting is kept as before.
  if((weightMode == 3 || weightMode == 4) && m_2ndOrderWeights
     && (!a_isBndryCell(cellId) || m_reExcludeBndryDiagonals)) {
    for(MInt n = 0; n < noNghbrIds; n++) {
      const MInt nghbrId = a_reconstructionNeighborId(cellId, n);
      if(approx(weights[n], 0.0, EPS)) {
        continue; // if weight was set to zero previously continue
      }

      MFloat dxdx = F0;
      if(relocateCenter) {
        const MInt d = (MInt)isDirectNghbr(nghbrId) / 2;
        TERMM_IF_NOT_COND(d >= 0 && d < nDim, "Try setting reExcludeBndryDiagonals==true and retry!");
        dxdx = POW2(a_coordinate(nghbrId, d) - a_coordinate(cellId, d));
      } else {
        for(MInt i = 0; i < nDim; i++) {
          if(dirs[i]) {
            dxdx += POW2(a_coordinate(nghbrId, i) - a_coordinate(cellId, i));
          }
        }
      }

      // If a bndry cell is contained in stencil, reduce power of weighting from w^2~1/dx^3 (2nd order)
      const MFloat exp = hasBndryInStencil ? 0.0 : 0.75;
      weights[n] = 1.0 / pow(fabs(dxdx), exp);
      if(a_level(nghbrId) > a_level(cellId)) {
        const MInt orientation = isDirectNghbr(nghbrId);
        TERMM_IF_NOT_COND(orientation >= 0 && orientation < 2 * nDim, "");
        weights[n] *= 1.0 / sqrt(noFineNghbrs[orientation]);
      }
    }
  }

  // compute Stencil check
  if(fallBackMode == 1) {
    // compute stencil check and dirTest
    MFloat dirTest[3] = {F0, F0, F0};
    for(MInt n = 0; n < a_noReconstructionNeighbors(cellId); n++) {
      const MInt nghbrId = a_reconstructionNeighborId(cellId, n);
      ASSERT(!a_hasProperty(nghbrId, SolverCell::IsSplitCell), "");
      for(MInt i = 0; i < nDim; i++) {
        dirTest[i] =
            mMax(dirTest[i], weights(n) * fabs(a_coordinate(nghbrId, i) - a_coordinate(cellId, i)) / cellLength);
      }
    }
    MFloat stencilCheck = F1;
    for(MInt i = 0; i < nDim; i++) {
      stencilCheck = mMin(stencilCheck, dirTest[i]);
    }
    // if the cells are to close to each other, the stencil is extended
    if(stencilCheck < 0.1) {
      extendStencil(cellId);
    }
    // compute reconstruction constants and return
    return computeRecConstSVD(cellId, offset, tmpA, tmpC, weights, recDim, weightMode, 2);
  }


  const MFloat normalizationFactor = FPOW2(a_level(cellId)) / c_cellLengthAtLevel(0);
  // reduces the condition number of the eq system

  std::vector<MBool> zeroColumns(recDim, true);
  std::array<MInt, nDim> recNghbrsRfn;
  std::fill_n(&recNghbrsRfn[0], nDim, -1);
  std::array<MFloat, nDim - 1> recConstantsRfn = {};
  MBool foundCoarseNghbr = false;
  for(MInt n = 0; n < noNghbrIds; n++) {
    const MInt nghbrId = a_reconstructionNeighborId(cellId, n);
    std::array<MFloat, nDim> dx;
    dx.fill(0.0);
    if(weightMode == 4) {
      if(!a_isBndryCell(cellId) && weights[n] > EPS && a_level(nghbrId) < a_level(cellId)
         && currentSlopeDir != -1) { //(relocateCenter == m_relocateCenter)) {
        TERMM_IF_NOT_COND(currentSlopeDir != -1, "Only one direction at a time should be considered");
        TERMM_IF_NOT_COND(!foundCoarseNghbr, "Only one coarse nghbr per direction is allowed!");
        recNghbrsRfn[0] = n;
        MInt dimN = currentSlopeDir;                            // direction of coarse nghbr
        array<MInt, nDim - 1> dimT{};                           // tangential directions
        MFloatScratchSpace dxT(nDim - 1, nDim - 1, AT_, "dxT"); // dx in tangential directions
        MInt noTDims = 0;
        for(MInt i = 0; i < nDim; ++i) {
          if(i != dimN) {
            const MInt dir = a_coordinate(cellId, i) > a_coordinate(nghbrId, i) ? 0 : 1;
            if(checkNeighborActive(cellId, 2 * i + dir) && a_hasNeighbor(cellId, 2 * i + dir), "") {
              const MInt nghbrId_ = c_neighborId(cellId, 2 * i + dir);
              for(MInt nn = 0; nn < noNghbrIds; nn++) {
                if(a_reconstructionNeighborId(cellId, nn) == nghbrId_) {
                  recNghbrsRfn[noTDims + 1] = nn;
                }
              }
              TERMM_IF_NOT_COND(recNghbrsRfn[noTDims + 1] != -1, "This nghbr must exist in rec-stencil!");
              TERMM_IF_NOT_COND(a_hasProperty(nghbrId_, SolverCell::IsOnCurrentMGLevel), "");
              dimT[noTDims] = i;
              for(MInt d = 0, dd = 0; d < nDim; ++d) {
                if(d != dimN) {
                  dxT(dd++, noTDims) = a_coordinate(nghbrId_, d) - a_coordinate(cellId, d);
                }
              }
              ++noTDims;
            }
          }
        }

        dx[dimN] = a_coordinate(nghbrId, dimN) - a_coordinate(cellId, dimN);
        if(noTDims == nDim - 1) {
          MFloatScratchSpace dxT_inv(nDim - 1, nDim - 1, AT_, "dxT_inv");
          maia::math::invert(dxT, dxT_inv, nDim - 1, nDim - 1);
          for(MInt i = 0; i < nDim - 1; ++i) {
            recConstantsRfn[i] = 0;
            for(MInt d = 0; d < nDim - 1; ++d) {
              recConstantsRfn[i] += dxT_inv(i, d) * (a_coordinate(nghbrId, dimT[d]) - a_coordinate(cellId, dimT[d]));
            }
            if(!a_isBndryCell(nghbrId) && !a_isBndryCell(a_reconstructionNeighborId(cellId, recNghbrsRfn[1]))
               && !a_isBndryCell(a_reconstructionNeighborId(cellId, recNghbrsRfn[nDim - 1]))) {
              TERMM_IF_NOT_COND(approx(recConstantsRfn[i], 0.5, EPS), "");
            }
          }
          for(MInt i = 0; i < nDim - 1; ++i) {
            const MInt nghbrId_ = a_reconstructionNeighborId(cellId, recNghbrsRfn[i + 1]);
            dx[dimN] += (a_coordinate(cellId, dimN) - a_coordinate(nghbrId_, dimN)) * recConstantsRfn[i];
          }
        }
        if(nDim == 3 && noTDims == 1) {
          for(MInt d = 0, dd = 0; d < nDim; ++d) {
            if(d != dimN) {
              dxT(dd, noTDims) = dxT(1 - dd, 0);
              ++dd;
            }
          }
          dxT(0, noTDims) *= -1;
          MFloatScratchSpace dxT_inv(nDim - 1, nDim - 1, AT_, "dxT_inv");
          maia::math::invert(dxT, dxT_inv, nDim - 1, nDim - 1);
          recConstantsRfn[0] = 0;
          for(MInt d = 0; d < nDim - 1; ++d) {
            recConstantsRfn[0] += dxT_inv(0, d) * (a_coordinate(nghbrId, dimT[d]) - a_coordinate(cellId, dimT[d]));
          }
          dx[dimN] +=
              (a_coordinate(cellId, dimN) - a_coordinate(a_reconstructionNeighborId(cellId, recNghbrsRfn[1]), dimN))
              * recConstantsRfn[0];
        }
        dx[dimN] *= normalizationFactor;
        foundCoarseNghbr = true;
        //} //else if(!a_isBndryCell(cellId) && weights[n] > EPS && a_level(nghbrId) > a_level(cellId)) {
        // for(MInt i = 0; i < nDim; i++) {
        //  dx[i] = (a_coordinate(nghbrId, i) - a_coordinate(cellId, i)) * normalizationFactor;
        //}
      } else {
        if(relocateCenter) {
          const MInt d = (MInt)isDirectNghbr(nghbrId) / 2;
          if(d > -1) {
            dx[d] = (a_coordinate(nghbrId, d) - a_coordinate(cellId, d)) * normalizationFactor;
          }
        } else {
          for(MInt i = 0; i < nDim; i++) {
            if(dirs[i]) {
              dx[i] = (a_coordinate(nghbrId, i) - a_coordinate(cellId, i)) * normalizationFactor;
            }
          }
        }
      }
    } else if(weightMode == 3) {
      for(MInt i = 0; i < nDim; i++) {
        if(dirs[i]) {
          dx[i] = (a_coordinate(nghbrId, i) - a_coordinate(cellId, i)) * normalizationFactor;
        }
      }
    } else {
      for(MInt i = 0; i < nDim; i++) {
        dx[i] = (a_coordinate(nghbrId, i) - a_coordinate(cellId, i)) * normalizationFactor;
      }
    }
    MInt cnt = 0;
    for(MInt i = 0; i < nDim; i++) {
      tmpA(n, i) = dx[i];
      if(fabs(tmpA(n, i)) > EPS && fabs(weights[n]) > EPS) {
        zeroColumns[i] = false;
      }
      cnt++;
    }
    for(MInt i = 0; i < nDim; i++) {
      if(cnt < recDim) {
        tmpA(n, cnt) = F1B2 * POW2(dx[i]);
        if(fabs(tmpA(n, cnt)) > EPS && fabs(weights[n]) > EPS) {
          zeroColumns[cnt] = false;
        }
        cnt++;
      }
    }
    for(MInt i = 0; i < nDim; i++) {
      for(MInt j = i + 1; j < nDim; j++) {
        if(cnt < recDim) {
          tmpA(n, cnt) = dx[i] * dx[j];
          if(fabs(tmpA(n, cnt)) > EPS && fabs(weights[n]) > EPS) {
            zeroColumns[cnt] = false;
          }
          cnt++;
        }
      }
    }
  }

  // Remove zero columns
  for(MInt n = 0; n < noNghbrIds; n++) {
    for(MInt i = 0, ii = 0; i < recDim; ++i) {
      if(!allDirs && !dirs[i]) { // TODO check if this would improve solution quality
        zeroColumns[i] = true;
      }
      if(!zeroColumns[i]) {
        tmpA(n, ii) = tmpA(n, i);
        ++ii;
      }
    }
  }

  const MInt recDimSignificant = std::count(zeroColumns.begin(), zeroColumns.end(), false);
  TERMM_IF_COND(recDimSignificant == 0,
                std::to_string(dirs[0]) + " " + std::to_string(dirs[1]) + " " + std::to_string(allDirs));

  const MInt rank = maia::math::invertR(tmpA, weights, tmpC, noNghbrIds, recDimSignificant);
  if(rank < min(noNghbrIds, recDimSignificant)) {
#ifndef NDEBUG
    cerr << domainId() << ": QRD failed for cell " << cellId << " " << c_globalId(cellId) << " " << a_level(cellId)
         << " " << a_isHalo(cellId) << " " << a_hasProperty(cellId, SolverCell::IsNotGradient) << " /split "
         << a_hasProperty(cellId, SolverCell::IsSplitCell) << " " << a_hasProperty(cellId, SolverCell::IsSplitChild)
         << " " << a_hasProperty(cellId, SolverCell::HasSplitFace) << endl;
    for(MInt n = 0; n < noNghbrIds; n++) {
      cerr << weights[n] << " ";
    }
    cerr << endl;
    for(MInt dir = 0; dir < 2 * nDim; dir++) {
      if(checkNeighborActive(cellId, dir)) {
        cerr << a_hasNeighbor(cellId, dir) << "/" << c_neighborId(cellId, dir) << " ";
      }
    }
    cerr << endl;
#endif
    // todo labels:FV this is not correct tmpA and tmpC needs to be reset
    maia::math::invert(tmpA, weights, tmpC, noNghbrIds, recDimSignificant - 1);
  }

  a_reconstructionData(cellId) = offset;
  if((signed)m_reconstructionConstants.size() < nDim * (offset + noNghbrIds)) {
    m_reconstructionConstants.resize(nDim * (offset + noNghbrIds));
    m_reconstructionCellIds.resize(offset + noNghbrIds);
    m_reconstructionNghbrIds.resize(offset + noNghbrIds);
  }
  std::vector<MFloat> reConstants;
  if(weightMode == 4 && relocateCenter && hasBndryInStencil) {
    reConstants.resize(nDim * noNghbrIds);
    std::copy_n(&m_reconstructionConstants[nDim * offset], nDim * noNghbrIds, &reConstants[0]);
  }
  for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
    const MInt nghbrId = a_reconstructionNeighborId(cellId, nghbr);
    m_reconstructionCellIds[offset + nghbr] = cellId;
    m_reconstructionNghbrIds[offset + nghbr] = nghbrId;
    for(MInt i = 0, ii = -1; i < nDim; i++) {
      if(zeroColumns[i]) {
        continue;
      }
      ++ii;
      if(!allDirs && !dirs[i]) {
        continue;
      }
      m_reconstructionConstants[nDim * (offset + nghbr) + i] = tmpC(ii, nghbr) * normalizationFactor;
    }
  }

  if(weightMode == 4 && relocateCenter && hasBndryInStencil) {
    for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
      const MInt nghbrId = a_reconstructionNeighborId(cellId, nghbr);

      const MInt d = (MInt)isDirectNghbr(nghbrId) / 2;
      if(a_isBndryCell(nghbrId) && a_level(nghbrId) >= a_level(cellId) && d > -1) {
        array<MFloat, nDim> dx{};
        for(MInt dd = 0; dd < nDim; ++dd) {
          if(dd != d) {
            dx[dd] = a_coordinate(nghbrId, dd) - a_coordinate(cellId, dd);
          }
        }
        for(MInt nghbr2 = 0; nghbr2 < noNghbrIds; nghbr2++) {
          for(MInt i = 0; i < nDim; ++i) {
            if(zeroColumns[i]) {
              continue;
            }
            if(!allDirs && !dirs[i]) {
              continue;
            }
            for(MInt dd = 0; dd < nDim; ++dd) {
              m_reconstructionConstants[nDim * (offset + nghbr2) + i] -=
                  m_reconstructionConstants[nDim * (offset + nghbr) + i] * (reConstants[nDim * nghbr2 + dd] * dx[dd]);
            }
          }
        }
      }
    }
  }

  if(foundCoarseNghbr) { // weightMode == 4
    const MInt nghbr = recNghbrsRfn[0];
    for(MInt i = 0; i < nDim; i++) {
      if(zeroColumns[i]) {
        continue;
      }
      if(!allDirs && !dirs[i]) {
        continue;
      }
      for(MInt n = 0; n < nDim - 1; ++n) {
        if(recNghbrsRfn[n + 1] != -1) {
          const MInt nghbr_ = recNghbrsRfn[n + 1];
          TERMM_IF_NOT_COND(approx(m_reconstructionConstants[nDim * (offset + nghbr_) + i], 0.0, MFloatEps), "");
          m_reconstructionConstants[nDim * (offset + nghbr_) + i] =
              -recConstantsRfn[n] * m_reconstructionConstants[nDim * (offset + nghbr) + i];
        }
      }
    }
  }

  const MInt condNum = maia::math::frobeniusMatrixNormSquared(tmpA, noNghbrIds, recDimSignificant);
  if(condNum < F0 || condNum > 1e6 || std::isnan(condNum)) {
    // fall-back solution:
    if(fallBackMode > 0) {
      extendStencil(cellId);
      return computeRecConstSVD(cellId, offset, tmpA, tmpC, weights, recDim, weightMode, -1);
    }

    // debug output
    cerr << domainId() << " " << globalTimeStep << " SVD decomposition for cell " << cellId << "/" << c_globalId(cellId)
         << " level " << a_level(cellId) << " with large condition number: " << condNum << " " << noNghbrIds << "x"
         << recDim << " " << a_cellVolume(cellId) / pow(cellLength, (MFloat)nDim) << " coords "
         << a_coordinate(cellId, 0) << ", " << a_coordinate(cellId, 1) << ", " << a_coordinate(cellId, 2) << " bndryId "
         << a_bndryId(cellId) << endl;
    for(MInt n = 0; n < noNghbrIds; n++) {
      cerr << c_globalId(a_reconstructionNeighborId(cellId, n)) << "(" << weights[n] << ") ";
    }
    ASSERT(false, "");
  }

  return condNum;
}

//-------------------------------------------------------------------------------------------

/**
 * \brief extend the reconstruction sencil towards all diagonal cells on the first layer
 * \author Tim Wegmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::extendStencil(const MInt cellId) {
  TRACE();

  MIntScratchSpace nghbrList(100, AT_, "nghbrList");
  MIntScratchSpace layerId(100, AT_, "layerList");

  const MInt rootCell = (a_hasProperty(cellId, SolverCell::IsSplitChild)) ? getAssociatedInternalCell(cellId) : cellId;

  // reset reconstruction neighbors and only keep ghostCells
  a_noReconstructionNeighbors(cellId) = (a_isBndryCell(cellId)) ? m_bndryCells->a[a_bndryId(cellId)].m_noSrfcs : 0;

  const MInt counter2 = getAdjacentLeafCells_d2_c(rootCell, 1, nghbrList, layerId);

  for(MInt n = 0; n < counter2; n++) {
    if(nghbrList[n] < 0) continue;
    if(a_hasProperty(nghbrList[n], SolverCell::IsInactive)) continue;
    if(a_noReconstructionNeighbors(cellId) < m_cells.noRecNghbrs()) {
      a_reconstructionNeighborId(cellId, a_noReconstructionNeighbors(cellId)) = nghbrList[n];
      a_noReconstructionNeighbors(cellId)++;
    } else {
      cerr << "Warning: too many reconstruction neighbors for cell " << cellId << endl;
    }
  }
}


//-------------------------------------------------------------------------------------------
/**
 * \brief converts the primitive restart variables to a new Mach Number
 * \author Thomas Schilden
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::convertPrimitiveRestartVariables() {
  TRACE();

  // compute the infinity values for the restart file Mach number (m_previousMa)
  const MFloat tInfRestart = sysEqn().temperature_IR(m_previousMa);
  const MFloat pInfRestart = sysEqn().pressure_IR(tInfRestart);
  const MFloat uInfRestart = m_previousMa * sqrt(tInfRestart);
  const MFloat rhoInfRestart = sysEqn().density_IR(tInfRestart);

  // compute the infinity values for the Mach number
  const MFloat tInf = sysEqn().temperature_IR(m_Ma);
  const MFloat pInf = sysEqn().pressure_IR(tInf);
  const MFloat uInf = m_Ma * sqrt(tInf);
  const MFloat rhoInf = sysEqn().density_IR(tInf);

  // set the ratio
  const MFloat velRatio = uInf / uInfRestart;
  const MFloat densityRatio = rhoInf / rhoInfRestart;
  const MFloat pressureRatio = pInf / pInfRestart;

  // conversion
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    // compute the velocities
    for(MInt i = 0; i < nDim; i++) {
      a_pvariable(cellId, PV->VV[i]) *= velRatio;
    }

    // compute the density
    a_pvariable(cellId, PV->RHO) *= densityRatio;

    // compute the pressure
    a_pvariable(cellId, PV->P) *= pressureRatio;
  }
}

/// \brief Exchange external sources.
///
/// \author Sven Berger
/// \date   April 2018
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::exchangeExternalSources() {
  TRACE();

  ASSERT(m_hasExternalSource, "");

  // exchange all external sources
  if(noDomains() > 1) {
    maia::mpi::reverseExchangeAddData(grid().neighborDomains(), grid().haloCells(), grid().windowCells(), mpiComm(),
                                      m_externalSource, CV->noVariables);
  }


  MBool filter = false;
  // TODO labels:FV,totest check filter function!
  if(filter) {
    grid().smoothFilter(maxRefinementLevel() - 1, m_externalSource);
  }
}

/// \brief Add external sources to the RHS.
/// \author Tim Wegmann
/// \date   January 2021
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::applyExternalSource() {
  TRACE();

  for(MInt ac = 0; ac < m_noActiveCells; ac++) {
    const MInt cellId = m_activeCellIds[ac];
    for(MInt var = 0; var < CV->noVariables; var++) {
      a_rightHandSide(cellId, var) += a_externalSource(cellId, var);
    }
  }
}

/// \brief Reset external sources.
/// \author Sven Berger
/// \date   April 2018
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::resetExternalSources() {
  TRACE();

  ASSERT(m_hasExternalSource, "");

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    for(MInt var = 0; var < CV->noVariables; var++) {
      a_externalSource(cellId, var) = 0;
    }
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getPrimitiveVariables(MInt cellId, MFloat* Xp, MFloat* vars, MInt order) {
  const MInt noPVars = PV->noVariables;

  for(MInt vari = 0; vari < noPVars; vari++)
    vars[vari] = a_pvariable(cellId, vari);

  if(order == 0) return;

  for(MInt vari = 0; vari < noPVars; vari++)
    for(MInt dimi = 0; dimi < nDim; dimi++)
      vars[vari] += a_slope(cellId, vari, dimi) * (Xp[dimi] - a_coordinate(cellId, dimi));
}

/// Should the time step from the restart file be used?
template <MInt nDim_, class SysEqn>
MBool FvCartesianSolverXD<nDim_, SysEqn>::useTimeStepFromRestartFile() const {
  if(m_timeStepComputationInterval == -1 && m_restart) {
    return true;
  } else if(m_restart && Context::propertyExists("consistentRestart", m_solverId)
            && Context::getSolverProperty<MBool>("consistentRestart", m_solverId, AT_)) {
    return true;
  }

  return false;
}

/// Does the time-step need to be recomputed on this step?
template <MInt nDim_, class SysEqn>
MBool FvCartesianSolverXD<nDim_, SysEqn>::requiresTimeStepUpdate() const {
  switch(m_timeStepComputationInterval) {
    case -1:
    case 0: {
      return false;
    } // only once at the beginning
    default: {
      if(m_timeStepComputationInterval < 0) {
        mTerm(1, AT_,
              "timeStepComputationInterval is " + to_string(m_timeStepComputationInterval)
                  + " and out-of-range [-1, infinity)");
      }
      return globalTimeStep % m_timeStepComputationInterval == 0;
    }
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setRestartFileOutputTimeStep() {
  TRACE();
  if((m_timeStepMethod == 17511 && nDim == 2) || m_timeStepMethod == 6) {
    return;
  }
  m_restartFileOutputTimeStep = timeStep();
}

/// Compute right-hand side.
/// \author Sven Berger
/// \tparam nDim
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::rhs() {
  TRACE();
  RECORD_TIMER_START(m_timers[Timers::TimeInt]);
  RECORD_TIMER_START(m_timers[Timers::Rhs]);

  resetRHS();

  IF_CONSTEXPR(isDetChem<SysEqn>) {
    RECORD_TIMER_START(m_timers[Timers::CellCenterCoefficients]);
    computeMeanMolarWeights_CV();
    RECORD_TIMER_STOP(m_timers[Timers::CellCenterCoefficients]);
  }

  RECORD_TIMER_START(m_timers[Timers::Muscl]);
  Muscl();
  RECORD_TIMER_STOP(m_timers[Timers::Muscl]);

#if defined(WITH_CANTERA)
  if(m_detChem.hasChemicalReaction && (m_RKStep == 0)) {
    IF_CONSTEXPR(isDetChem<SysEqn>) {
      RECORD_TIMER_START(m_timers[Timers::SpeciesReactionRates]);
      computeSpeciesReactionRates();
      RECORD_TIMER_STOP(m_timers[Timers::SpeciesReactionRates]);
    }
  }
  IF_CONSTEXPR(isDetChem<SysEqn>) {
    RECORD_TIMER_START(m_timers[Timers::SurfaceCoefficients]);
    computeDetailedChemistryVariables();
    RECORD_TIMER_STOP(m_timers[Timers::SurfaceCoefficients]);
  }
#endif

  RECORD_TIMER_START(m_timers[Timers::Ausm]);
  Ausm();
  RECORD_TIMER_STOP(m_timers[Timers::Ausm]);

  RECORD_TIMER_START(m_timers[Timers::ViscFlux]);
  if(!m_euler) {
    viscousFlux();
    // TODO labels:FV Decide if those two variants are still needed. If yes, move to appropriate SysEqn!
    IF_CONSTEXPR(nDim == 2) {
      if(m_combustion) {
        if(m_plenum) {
          mTerm(1, "Move to sysEqn!");
          viscousFlux_Gequ_Pv_Plenum();
        } else if(m_divergenceTreatment) {
          mTerm(1, "Move to sysEqn!");
          viscousFlux_Gequ_Pv();
        }
      }
    }
  }
  RECORD_TIMER_STOP(m_timers[Timers::ViscFlux]);

  RECORD_TIMER_START(m_timers[Timers::DistFlux]);
  distributeFluxToCells();
  RECORD_TIMER_STOP(m_timers[Timers::DistFlux]);

  RECORD_TIMER_START(m_timers[Timers::RhsMisc]);
  if(m_combustion) {
    computeSourceTerms();
  }

  IF_CONSTEXPR(isDetChem<SysEqn>) {
    if(m_detChem.hasChemicalReaction) {
      addSpeciesReactionRatesAndHeatRelease();
    }
  }

  if(m_considerVolumeForces) {
    computeVolumeForces();
  }

  if(m_rans) {
    computeVolumeForcesRANS();
  }

  if(m_considerRotForces) {
    computeRotForces();
  }

  if(m_dualTimeStepping) {
    dqdtau();
  }

  IF_CONSTEXPR(isEEGas<SysEqn>) rhsEEGas();

  if(m_hasExternalSource) {
    applyExternalSource();
  }
  RECORD_TIMER_STOP(m_timers[Timers::RhsMisc]);

  RECORD_TIMER_STOP(m_timers[Timers::Rhs]);
  RECORD_TIMER_STOP(m_timers[Timers::TimeInt]);
}


/// Apply boundary condition
/// \author Sven Berger
/// \tparam nDim
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::rhsBnd() {
  TRACE();
  RECORD_TIMER_START(m_timers[Timers::TimeInt]);
  RECORD_TIMER_START(m_timers[Timers::RhsBnd]);

  updateSpongeLayer();

  updateJet();

  resetRHSNonInternalCells();

  resetRHSCutOffCells();

  correctMasterCells();

  nonReflectingBCCutOff();

  if(m_fvBndryCnd->m_smallCellRHSCorrection) {
    smallCellRHSCorrection();
    updateSplitParentVariables();
  }

  RECORD_TIMER_STOP(m_timers[Timers::RhsBnd]);
  RECORD_TIMER_STOP(m_timers[Timers::TimeInt]);
}

/// Perform solution step
/// \author Sven Berger
/// \tparam nDim
template <MInt nDim_, class SysEqn>
MBool FvCartesianSolverXD<nDim_, SysEqn>::solverStep() {
  RECORD_TIMER_START(m_timers[Timers::TimeInt]);
  RECORD_TIMER_START(m_timers[Timers::Lhs]);

  //-->debug
  /*  MInt nosplitclones = 0;
    for( MInt cellId = 0; cellId < a_noCells(); cellId++ ){
      if(a_hasProperty(cellId, SolverCell::IsSplitClone)) nosplitclones++;
    }
    ASSERT(nosplitclones==0, "ERROR: clone cells in use!");
  */

  if(m_levelSet && !m_levelSetMb && !m_combustion && !m_levelSetRans) {
    RECORD_TIMER_STOP(m_timers[Timers::Lhs]);
    RECORD_TIMER_STOP(m_timers[Timers::TimeInt]);
    return true;
  }

  // If multilevel is activated and this is *not* the finest solver, apply multilevel correction
  if(isMultilevel() && !isMultilevelPrimary()) {
    applyCoarseLevelCorrection();
  }

  // Perform one Runge-Kutta substep, returns if time step is completed
  const MBool step = rungeKuttaStep();

  IF_CONSTEXPR(isDetChem<SysEqn>) { correctMajorSpeciesMassFraction(); }

  nonReflectingBCAfterTreatmentCutOff();

  // update the timeStep after the last rungeKuttaStep (=> new timeStep for next iteration!)
  if(step && requiresTimeStepUpdate()) {
#if defined(WITH_CANTERA)
    IF_CONSTEXPR(isDetChem<SysEqn>) { computeGamma(); }
#endif
    setTimeStep();
  }

  RECORD_TIMER_STOP(m_timers[Timers::Lhs]);
  RECORD_TIMER_STOP(m_timers[Timers::TimeInt]);
  return step;
}


/**
 * \brief Initializes the fv-solver
 * \author Sven Berger, Tim Wegmann
 * \tparam nDim
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initSolver() {
  TRACE();

  // relevant for Post-Processing and set from pp-init
  m_statisticCombustionAnalysis = false;

  m_statisticCombustionAnalysis =
      Context::getBasicProperty<MBool>("statisticCombustionAnalysis", AT_, &m_statisticCombustionAnalysis);
  if(m_statisticCombustionAnalysis || isDetChem<SysEqn>) {
    mAlloc(m_heatRelease, maxNoGridCells(), "m_heatRelease", F0, AT_);
  }

  // Nothing to be done if solver is not active
  if(!isActive()) return;

  const MFloat time0 = MPI_Wtime();

  IF_CONSTEXPR(isEEGas<SysEqn>)
  if(m_EEGas.depthCorrection) initDepthCorrection();

  applyInitialCondition();
  computePV();

  if(m_zonal) {
    resetZonalSolverData();
    if(m_restart || (m_resetInitialCondition && m_solverId == m_zonalRestartInterpolationSolverId)) {
      loadRestartFile();
    }
  }

  if(m_STGSponge) initSTGSponge();

  if(noNeighborDomains() > 0) {
    exchangeDataFV(&a_variable(0, 0), CV->noVariables, false, m_rotIndVarsCV);
    exchangeDataFV(&a_oldVariable(0, 0), CV->noVariables, false, m_rotIndVarsCV);
    exchangeDataFV(&a_pvariable(0, 0), PV->noVariables, false, m_rotIndVarsPV);
  }

  const MFloat time1 = MPI_Wtime();
  if(domainId() == 0) m_log << "Init solution time " << time1 - time0 << endl;
}


/// \brief Initializes the solver afer the initialRefinement!
/// \author unknown
/// \date
/// \tparam nDim
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::finalizeInitSolver() {
  TRACE();

  // Nothing to be done if solver is not active
  if(!isActive()) return;

  // Load restart
  if(m_restart && !(m_zonal || grid().azimuthalPeriodicity())) {
    loadRestartFile();
  }

  // Reallocate memory to small and master cell id arrays
  reInitSmallCellIdsMemory();

  // initialize the solver
  initSolutionStep(-1);

  // Reallocate solver memory to arrays depending on a_noCells()
  reInitActiveCellIdsMemory();
  writeListOfActiveFlowCells();

  initializeMaxLevelExchange();

  {
    MLong maxNoCells = noInternalCells();
    MPI_Allreduce(MPI_IN_PLACE, &maxNoCells, 1, type_traits<MLong>::mpiType(), MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                  "maxNoCells");
    MLong maxNoTotalCells = a_noCells();
    MPI_Allreduce(MPI_IN_PLACE, &maxNoTotalCells, 1, type_traits<MLong>::mpiType(), MPI_MAX, mpiComm(), AT_,
                  "MPI_IN_PLACE", "maxNoTotalCells");
    stringstream message;
    message << "Solver #" << solverId() << " - maximum number of internal cells among ranks: " << maxNoCells
            << std::endl;
    message << "Solver #" << solverId() << " - maximum number of cells among ranks: " << maxNoTotalCells << std::endl;
    m_log << message.str();
    cerr0 << message.str();
  }

  IF_CONSTEXPR(isEEGas<SysEqn>)
  if(m_EEGas.depthCorrection) initDepthCorrection();

  // initialize the flow field (again)
  applyInitialCondition();

  // IF_CONSTEXPR(isDetChem<SysEqn>) { computeMeanMolarWeights_CV(); }

  // Calculate primitive variables
  computePV();

#if defined(WITH_CANTERA)
  IF_CONSTEXPR(isDetChem<SysEqn>) { computeGamma(); }
#endif

  // initialize the runge kutta integration scheme
  initializeRungeKutta();

  setTimeStep();

  // periodic exchange (azimuthal periodicity concept)
  if(m_periodicCells == 3) {
    exchange();
    exchangePeriodic();
  }

  // Exchange halo/window cell information if multiSolver is enabled
  exchange();

  if(m_calcLESAverage) {
    determineLESAverageCells();
    // resetZonalLESAverage();
    finalizeLESAverage();
  }

  if(m_STGSponge) {
    initSTGSpongeExchange();
    if(m_preliminarySponge) {
      readPreliminarySTGSpongeData();
    }
  }

  if(m_STGSponge && globalTimeStep > m_stgSpongeTimeStep) {
    loadSpongeData();
  }

  // Set cut-off boundary conditions
  cutOffBoundaryCondition();

  // Apply boundary conditions
  applyBoundaryCondition();

  computeConservativeVariables();

  // Calls the scalar limiter if species are calculated
  scalarLimiter();

  // Compute the cell center slopes here if changed slope calculation activated
  if(calcSlopesAfterStep()) {
    LSReconstructCellCenter();
    m_fvBndryCnd->copySlopesToSmallCells();
    m_fvBndryCnd->updateGhostCellSlopesInviscid();
    m_fvBndryCnd->updateCutOffSlopesInviscid();
  }

  if(m_combustion && !m_LSSolver) {
    setCellProperties();
    computePrimitiveVariablesCoarseGrid();
    computeConservativeVariables();
  }

  if((m_levelSet || m_levelSetRans) && !m_combustion && !m_LSSolver) {
    setCellProperties();
  }

  IF_CONSTEXPR(isEEGas<SysEqn>) {
    if(m_EEGas.gasSource != 0) initSourceCells();
    grid().findEqualLevelNeighborsParDiagonal(false);
  }
}

/// \brief Initialization of mass source cells for EEGas
///
/// \author Daniel Lauwers
/// \date 2020-11-18
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<isEEGas<SysEqn>, _*>>
inline void FvCartesianSolverXD<nDim, SysEqn>::initSourceCells() {
  MFloat sourceCellVolume = 0.0;
  switch(m_EEGas.gasSource) {
    case 0:
      return;
      break;

    case 9: // gas Source defined by property gasSourceBox
      for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
        if(a_level(cellId) != maxLevel() || a_isBndryGhostCell(cellId)) continue;
        MBool isInAnyBox = false;
        for(MInt box = 0; box < m_EEGas.noGasSourceBoxes; box++) {
          MBool isInThisBox = true;
          for(MInt i = 0; i < nDim; i++) {
            if(a_coordinate(cellId, i) < m_EEGas.gasSourceBox[i + box * nDim * 2]
               || a_coordinate(cellId, i) > m_EEGas.gasSourceBox[i + nDim + box * nDim * 2]) {
              isInThisBox = false;
              break;
            }
          }
          if(isInThisBox) {
            isInAnyBox = true;
            break;
          }
        }
        if(isInAnyBox) {
          m_EEGas.gasSourceCells.push_back(cellId);
          if(!a_isHalo(cellId)) sourceCellVolume += a_cellVolume(cellId);
        }
      }
      break;

    default:
      break;
  }
  MPI_Allreduce(MPI_IN_PLACE, &sourceCellVolume, 1, type_traits<MFloat>::mpiType(), MPI_SUM, mpiComm(), AT_,
                "MPI_IN_PLACE", "totalSourceCellVolume");

  MFloat massFlow = m_EEGas.gasSourceMassFlow;
  m_EEGas.massSource = massFlow / sourceCellVolume;

  if(domainId() == 0)
    std::cerr << "Volume of gas mass source cells: " << sourceCellVolume
              << " \tmass source (rho): " << m_EEGas.massSource << std::endl;
}

/// \brief Finish the split MPI communication and perform the left out part from
///        lhsBnd().
///
/// \author Ansgar Niemoeller (ansgar) <a.niemoeller@aia.rwth-aachen.de>
/// \date 2016-11-05
template <MInt nDim_, class SysEqn>
inline void FvCartesianSolverXD<nDim_, SysEqn>::lhsBndFinish() {
  TRACE();

  RECORD_TIMER_START(m_timers[Timers::TimeInt]);
  RECORD_TIMER_START(m_timers[Timers::LhsBnd]);

  if(!g_splitMpiComm) {
    mTerm(1, "lhsBndFinish() should only be used with split MPI communication "
             "(splitMpiComm) activated.");
  }

  RECORD_TIMER_START(m_timers[Timers::Exchange]);

  RECORD_TIMER_START(m_tcomm);
  RECORD_TIMER_START(m_texchange);
  finishMpiExchange();
  RECORD_TIMER_STOP(m_texchange);
  RECORD_TIMER_STOP(m_tcomm);

  RECORD_TIMER_STOP(m_timers[Timers::Exchange]);

  // These are the remaining calls in lhsBnd() that need to be executed after
  // the data exchange finished
  // Note: if anything here is changed, make sure to apply the same changes in
  //       lhsBnd()
  computePrimitiveVariablesCoarseGrid();

  RECORD_TIMER_START(m_timers[Timers::CutOff]);
  cutOffBoundaryCondition();
  RECORD_TIMER_STOP(m_timers[Timers::CutOff]);

  RECORD_TIMER_START(m_timers[Timers::BndryCnd]);
  applyBoundaryCondition();
  RECORD_TIMER_STOP(m_timers[Timers::BndryCnd]);

  computePrimitiveVariablesCoarseGrid();

  // Compute the cell center slopes here if changed slope calculation activated
  if(calcSlopesAfterStep()) {
    RECORD_TIMER_STOP(m_timers[Timers::LhsBnd]);

    RECORD_TIMER_START(m_timers[Timers::Rhs]);
    RECORD_TIMER_START(m_timers[Timers::Muscl]);

    RECORD_TIMER_START(m_timers[Timers::MusclReconst]);
    LSReconstructCellCenter();
    RECORD_TIMER_STOP(m_timers[Timers::MusclReconst]);

    // copy the slopes from the master to the slave cells
    RECORD_TIMER_START(m_timers[Timers::MusclCopy]);
    m_fvBndryCnd->copySlopesToSmallCells();
    RECORD_TIMER_STOP(m_timers[Timers::MusclCopy]);

    // update the ghost cell slopes for reconstruction of the primitive variables
    // on the surfaces for the AUSM scheme
    RECORD_TIMER_START(m_timers[Timers::MusclGhostSlopes]);
    m_fvBndryCnd->updateGhostCellSlopesInviscid();
    RECORD_TIMER_STOP(m_timers[Timers::MusclGhostSlopes]);

    RECORD_TIMER_START(m_timers[Timers::MusclCutSlopes]);
    m_fvBndryCnd->updateCutOffSlopesInviscid();
    RECORD_TIMER_STOP(m_timers[Timers::MusclCutSlopes]);
    // m_fvBndryCnd->updateGhostCellSlopesViscous();

    RECORD_TIMER_STOP(m_timers[Timers::Muscl]);
    RECORD_TIMER_STOP(m_timers[Timers::Rhs]);

    RECORD_TIMER_START(m_timers[Timers::LhsBnd]);
  }

  RECORD_TIMER_STOP(m_timers[Timers::LhsBnd]);
  RECORD_TIMER_STOP(m_timers[Timers::TimeInt]);
}

/// \brief Apply lhsBnd.
/// \author Sven Berger
/// \tparam nDim
/// \param lhsBndTimerId
template <MInt nDim_, class SysEqn>
inline void FvCartesianSolverXD<nDim_, SysEqn>::lhsBnd() {
  TRACE();

  RECORD_TIMER_START(m_timers[Timers::TimeInt]);
  RECORD_TIMER_START(m_timers[Timers::LhsBnd]);

#if defined _MB_DEBUG_ || !defined NDEBUG
  checkDiv();
#endif

  if(m_noSpecies > 0) {
    scalarLimiter();
  }

  RECORD_TIMER_START(m_timers[Timers::SmallCellCorr]);
  smallCellCorrection();
  RECORD_TIMER_STOP(m_timers[Timers::SmallCellCorr]);
  updateSplitParentVariables();

#if defined _MB_DEBUG_
  checkDiv();
#endif

  RECORD_TIMER_START(m_timers[Timers::ComputePV]);
  computePV();
  RECORD_TIMER_STOP(m_timers[Timers::ComputePV]);

  RECORD_TIMER_START(m_timers[Timers::Exchange]);
  // periodic exchange (azimuthal periodicity concept)
  if(m_periodicCells == 3) {
    exchange();
    exchangePeriodic();
  }

  // Cut-off cells are used for azimuthal reconstruction and for non cbc boundaries not part of smallcellcorrection
  if(grid().azimuthalPeriodicity()) {
    cutOffBoundaryCondition();
    if(!m_fvBndryCnd->m_cbcSmallCellCorrection) {
      for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
        if(a_hasProperty(cellId, SolverCell::IsCutOff)) {
          sysEqn().computeConservativeVariables(&a_pvariable(cellId, 0), &a_variable(cellId, 0), 0);
        }
      }
    }
  }

  if(g_splitMpiComm) {
    RECORD_TIMER_START(m_tcomm);
    RECORD_TIMER_START(m_texchange);
    startMpiExchange();
    RECORD_TIMER_STOP(m_texchange);
    RECORD_TIMER_STOP(m_tcomm);
  } else {
    exchange();
  }
  RECORD_TIMER_STOP(m_timers[Timers::Exchange]);

  // periodic exchange (azimuthal periodicity concept)
  if(m_periodicCells == 1 || m_periodicCells == 2) {
    RECORD_TIMER_START(m_timers[Timers::CutOff]);
    cutOffBoundaryCondition();
    RECORD_TIMER_STOP(m_timers[Timers::CutOff]);

    RECORD_TIMER_START(m_timers[Timers::Exchange]);
    exchangePeriodic();
    RECORD_TIMER_STOP(m_timers[Timers::Exchange]);
  }

  if(!g_splitMpiComm) {
    // Note: if anything here is changed, make sure to apply the same changes in
    //       lhsBndFinish()
    computePrimitiveVariablesCoarseGrid();
    // return command for non-combustion computations

    RECORD_TIMER_START(m_timers[Timers::CutOff]);
    cutOffBoundaryCondition();
    RECORD_TIMER_STOP(m_timers[Timers::CutOff]);

    RECORD_TIMER_START(m_timers[Timers::BndryCnd]);
    applyBoundaryCondition();
    RECORD_TIMER_STOP(m_timers[Timers::BndryCnd]);

    computePrimitiveVariablesCoarseGrid();
    // return command for non-combustion computations
    // solver->computeConservativeVariables();

    // Compute the cell center slopes here if changed slope calculation
    // activated
    if(calcSlopesAfterStep()) {
      RECORD_TIMER_STOP(m_timers[Timers::LhsBnd]);

      RECORD_TIMER_START(m_timers[Timers::Rhs]);
      RECORD_TIMER_START(m_timers[Timers::Muscl]);

      RECORD_TIMER_START(m_timers[Timers::MusclReconst]);
      LSReconstructCellCenter();
      RECORD_TIMER_STOP(m_timers[Timers::MusclReconst]);

      // copy the slopes from the master to the slave cells
      RECORD_TIMER_START(m_timers[Timers::MusclCopy]);
      m_fvBndryCnd->copySlopesToSmallCells();
      RECORD_TIMER_STOP(m_timers[Timers::MusclCopy]);

      // update the ghost cell slopes for reconstruction of the primitive variables
      // on the surfaces for the AUSM scheme
      RECORD_TIMER_START(m_timers[Timers::MusclGhostSlopes]);
      m_fvBndryCnd->updateGhostCellSlopesInviscid();
      RECORD_TIMER_STOP(m_timers[Timers::MusclGhostSlopes]);

      RECORD_TIMER_START(m_timers[Timers::MusclCutSlopes]);
      m_fvBndryCnd->updateCutOffSlopesInviscid();
      RECORD_TIMER_STOP(m_timers[Timers::MusclCutSlopes]);
      // m_fvBndryCnd->updateGhostCellSlopesViscous();

      RECORD_TIMER_STOP(m_timers[Timers::Muscl]);
      RECORD_TIMER_STOP(m_timers[Timers::Rhs]);

      RECORD_TIMER_START(m_timers[Timers::LhsBnd]);
    }
  }

  RECORD_TIMER_STOP(m_timers[Timers::LhsBnd]);
  RECORD_TIMER_STOP(m_timers[Timers::TimeInt]);
}


/// \brief Return global solver variables that should be equal on all domains
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getGlobalSolverVars(std::vector<MFloat>& globalFloatVars,
                                                             std::vector<MInt>& NotUsed(globalIdVars)) {
  TRACE();

  // Store global variables that need to be communicated during load balancing with inactive ranks
  globalFloatVars.push_back(m_time);
  globalFloatVars.push_back(m_timeStep);
  globalFloatVars.push_back(m_physicalTime);
  // TODO labels:FV,DLB any other variables to be communicated during DLB?
}


/// \brief Set global solver variables (see getGlobalSolverVars())
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setGlobalSolverVars(std::vector<MFloat>& globalFloatVars,
                                                             std::vector<MInt>& NotUsed(globalIdVars)) {
  TRACE();

  // Set variables in the same order as in getGlobalSolverVars()
  m_time = globalFloatVars[0];
  m_timeStep = globalFloatVars[1];
  m_physicalTime = globalFloatVars[2];
}


/**
 * \brief  Get solver timings
 * \author Tim Wegmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getSolverTimings(std::vector<std::pair<MString, MFloat>>& solverTimings,
                                                          const MBool allTimings) {
  TRACE();

  const MString namePrefix = "b" + std::to_string(solverId()) + "_";

  const MFloat load = returnLoadRecord();
  const MFloat idle = returnIdleRecord();

  solverTimings.emplace_back(namePrefix + "loadFvCartesianSolver", load);
  solverTimings.emplace_back(namePrefix + "idleFvCartesianSolver", idle);

#ifdef MAIA_TIMER_FUNCTION
  solverTimings.emplace_back(namePrefix + "timeIntegration", RETURN_TIMER_TIME(m_timers[Timers::TimeInt]));

  if(allTimings) {
    // Full set of timings
    solverTimings.emplace_back(namePrefix + "rhs", RETURN_TIMER_TIME(m_timers[Timers::Rhs]));
    solverTimings.emplace_back(namePrefix + "MUSCL", RETURN_TIMER_TIME(m_timers[Timers::Muscl]));
    solverTimings.emplace_back(namePrefix + "reconstructCellCenter", RETURN_TIMER_TIME(m_timers[Timers::MusclReconst]));
    solverTimings.emplace_back(namePrefix + "reconstructSrfcData",
                               RETURN_TIMER_TIME(m_timers[Timers::MusclReconstSrfc]));
    if(m_useSandpaperTrip) {
      solverTimings.emplace_back(namePrefix + "SandpaperTrip", RETURN_TIMER_TIME(m_timers[Timers::SandpaperTrip]));
    }
    if(m_wmLES) {
      solverTimings.emplace_back(namePrefix + "WMFluxCorrection",
                                 RETURN_TIMER_TIME(m_timers[Timers::WMFluxCorrection]));
      solverTimings.emplace_back(namePrefix + "WMSurfaceLoop", RETURN_TIMER_TIME(m_timers[Timers::WMSurfaceLoop]));
      solverTimings.emplace_back(namePrefix + "WMExchange", RETURN_TIMER_TIME(m_timers[Timers::WMExchange]));
    }

    IF_CONSTEXPR(isDetChem<SysEqn>) {
      solverTimings.emplace_back(namePrefix + "SurfaceCoefficients",
                                 RETURN_TIMER_TIME(m_timers[Timers::SurfaceCoefficients]));
      solverTimings.emplace_back(namePrefix + "SurfaceMeanMolarWeight",
                                 RETURN_TIMER_TIME(m_timers[Timers::SurfaceMeanMolarWeight]));
      solverTimings.emplace_back(namePrefix + "SurfaceTransportCoefficients",
                                 RETURN_TIMER_TIME(m_timers[Timers::SurfaceTransportCoefficients]));
      solverTimings.emplace_back(namePrefix + "CellCenterCoefficients",
                                 RETURN_TIMER_TIME(m_timers[Timers::CellCenterCoefficients]));
      solverTimings.emplace_back(namePrefix + "SpeciesReactionRates",
                                 RETURN_TIMER_TIME(m_timers[Timers::SpeciesReactionRates]));
    }

    solverTimings.emplace_back(namePrefix + "AUSM", RETURN_TIMER_TIME(m_timers[Timers::Ausm]));
    solverTimings.emplace_back(namePrefix + "viscFlux", RETURN_TIMER_TIME(m_timers[Timers::ViscFlux]));
    solverTimings.emplace_back(namePrefix + "distrFlux", RETURN_TIMER_TIME(m_timers[Timers::DistFlux]));

    solverTimings.emplace_back(namePrefix + "rhsBnd", RETURN_TIMER_TIME(m_timers[Timers::RhsBnd]));
    solverTimings.emplace_back(namePrefix + "lhs", RETURN_TIMER_TIME(m_timers[Timers::Lhs]));

    solverTimings.emplace_back(namePrefix + "lhsBnd", RETURN_TIMER_TIME(m_timers[Timers::LhsBnd]));
    solverTimings.emplace_back(namePrefix + "smallCellCorr", RETURN_TIMER_TIME(m_timers[Timers::SmallCellCorr]));
    solverTimings.emplace_back(namePrefix + "computePV", RETURN_TIMER_TIME(m_timers[Timers::ComputePV]));
    solverTimings.emplace_back(namePrefix + "exchange", RETURN_TIMER_TIME(m_timers[Timers::Exchange]));
    solverTimings.emplace_back(namePrefix + "cutOff", RETURN_TIMER_TIME(m_timers[Timers::CutOff]));
    solverTimings.emplace_back(namePrefix + "bndryCnd", RETURN_TIMER_TIME(m_timers[Timers::BndryCnd]));
    solverTimings.emplace_back(namePrefix + "SCC-init", RETURN_TIMER_TIME(m_timers[Timers::SCCorrInit]));

    if(m_levelSetMb) {
      solverTimings.emplace_back(namePrefix + "SCC-Ex1", RETURN_TIMER_TIME(m_timers[Timers::SCCorrExchange1]));
      solverTimings.emplace_back(namePrefix + "SCC-Wait1", RETURN_TIMER_TIME(m_timers[Timers::SCCorrExchange1Wait]));
      solverTimings.emplace_back(namePrefix + "SCC-int", RETURN_TIMER_TIME(m_timers[Timers::SCCorrInterp]));
      solverTimings.emplace_back(namePrefix + "SCC-redist", RETURN_TIMER_TIME(m_timers[Timers::SCCorrRedist]));
      solverTimings.emplace_back(namePrefix + "SCC-Ex2", RETURN_TIMER_TIME(m_timers[Timers::SCCorrExchange2]));
      solverTimings.emplace_back(namePrefix + "SCC-wait2", RETURN_TIMER_TIME(m_timers[Timers::SCCorrExchange2Wait]));
    }
  } else {
    // TODO labels:FV,TIMERS Reduced/essential set of timings
    solverTimings.emplace_back(namePrefix + "smallCellCorr", RETURN_TIMER_TIME(m_timers[Timers::SmallCellCorr]));
    solverTimings.emplace_back(namePrefix + "exchange", RETURN_TIMER_TIME(m_timers[Timers::Exchange]));
    // solverTimings.emplace_back(namePrefix + "bndryCnd", RETURN_TIMER_TIME(m_timers[Timers::BndryCnd]));
  }
#endif
}


/// \brief Return data size to be communicated during DLB for a grid cell and given data id
template <MInt nDim_, class SysEqn>
MInt FvCartesianSolverXD<nDim_, SysEqn>::cellDataSizeDlb(const MInt dataId, const MInt gridCellId) {
  // Inactive ranks do not have any data to communicate
  if(!isActive()) {
    return 0;
  }

  // Convert to solver cell id and check
  const MInt cellId = grid().tree().grid2solver(gridCellId);
  if(cellId < 0 || cellId >= noInternalCells()) {
    return 0;
  }

  MInt dataSize = 0;

  switch(dataId) {
    case 0: // variables
      dataSize = CV->noVariables;
      break;
    /* case 1: // cell properties */
    /*   dataSize = 1; */
    /*   break; */
    default:
      mTerm(1, "Unknown data id.");
      break;
  }

  return dataSize;
}


// \brief Apply the multilevel correction tau on a coarse level, i.e., add tau as a forcing to the
//        right hand side
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::applyCoarseLevelCorrection() {
  TRACE();

  const MInt _noInternalCells = grid().noInternalCells();
  const MInt noCVars = CV->noVariables;
  for(MInt cellId = 0; cellId < _noInternalCells; cellId++) {
    for(MInt varId = 0; varId < noCVars; varId++) {
      a_rightHandSide(cellId, varId) -= a_tau(cellId, varId);
    }
  }
}


/// \brief Return sampling properties for the FV solver
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getSolverSamplingProperties(
    std::vector<MInt>& samplingVarIds, std::vector<MInt>& noSamplingVars,
    std::vector<std::vector<MString>>& samplingVarNames, const MString featureName) {
  TRACE();

  // Read sampling variable names
  std::vector<MString> varNamesList;
  MInt noVars = readSolverSamplingVarNames(varNamesList, featureName);

  // Set default sampling variables if none specified
  if(noVars == 0) {
    varNamesList.emplace_back("FV_PV");
    noVars = 1;
  }

  for(MInt i = 0; i < noVars; i++) {
    const MInt samplingVar = string2enum(varNamesList[i]);
    std::vector<MString> varNames;

    auto samplingVarIt = std::find(samplingVarIds.begin(), samplingVarIds.end(), samplingVar);
    if(samplingVarIt != samplingVarIds.end()) {
      mTerm(1, "Sampling variable '" + varNamesList[i] + "' already specified.");
    }

    switch(samplingVar) {
      case FV_PV: {
        samplingVarIds.push_back(FV_PV);
        noSamplingVars.push_back(PV->noVariables);

        varNames.resize(PV->noVariables);
        varNames[PV->U] = "u";
        varNames[PV->V] = "v";
        IF_CONSTEXPR(nDim == 3) { varNames[PV->W] = "w"; }
        varNames[PV->P] = "p";
        varNames[PV->RHO] = "rho";
        MInt varCount = nDim + 2;

        IF_CONSTEXPR(isDetChem<SysEqn>) {
          if(PV->m_noSpecies > 0) {
            for(MUint s = 0; s < PV->m_noSpecies; s++) {
              MString str = ("Y" + m_speciesName[s]);
              MChar* c = new MChar[10];
              strcpy(c, str.c_str());
              varNames[PV->Y[s]] = c;
              varCount++;
            }
          }
        }
        else {
          IF_CONSTEXPR(hasPV_C<SysEqn>::value)
          if(PV->m_noSpecies > 0) {
            varNames[PV->C] = "c";
            varCount++;
          }
        }

        TERMM_IF_NOT_COND(PV->noVariables == varCount, "Error: variable count mismatch");

        samplingVarNames.push_back(varNames);
        break;
      }
      // TODO labels:FV,PP add sampling of gradients?
      case FV_VORT: {
        // mTerm(1, "Sampling of vorticity not tested.");
        samplingVarIds.push_back(FV_VORT);

        const MInt noVorticities = (nDim == 2) ? 1 : 3;
        noSamplingVars.push_back(noVorticities);

        varNames.resize(noVorticities);
        IF_CONSTEXPR(nDim == 2) { varNames[0] = "vort_z"; }
        else {
          varNames[0] = "vort_x";
          varNames[1] = "vort_y";
          varNames[2] = "vort_z";
        }
        samplingVarNames.push_back(varNames);

        break;
      }
      case FV_HEAT_RELEASE: {
        samplingVarIds.push_back(FV_HEAT_RELEASE);
        noSamplingVars.push_back(1);
        varNames.resize(1);
        varNames[0] = "h";
        samplingVarNames.push_back(varNames);
        break;
      }
      default: {
        mTerm(1, "Unknown sampling variable: " + varNamesList[i]);
        break;
      }
    }
  }
}


/// Initialize sampling variables, i.e., allocate additional memory for sampling quantities
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initSolverSamplingVariables(const std::vector<MInt>& varIds,
                                                                     const std::vector<MInt>& noSamplingVars) {
  TRACE();

  m_samplingVariablesStatus.fill(-1);

  // TODO labels:FV enable use with balancing
  for(MUint i = 0; i < varIds.size(); i++) {
    // No additional storage for primitive variables
    if(varIds[i] == FV_PV) {
      continue;
    }
    // Storage for sampling variable already allocated
    if(m_samplingVariables[varIds[i]] != nullptr) {
      continue;
    }

    MFloat** varPointer = nullptr;
    const MInt dataBlockSize = noSamplingVars[i];
    mAlloc(varPointer, a_noCells(), dataBlockSize, "m_samplingVariables_" + std::to_string(varIds[i]), 0.0, AT_);
    m_samplingVariables[varIds[i]] = varPointer;
  }
}


/// \brief Calculate all additional sampling variables that can be evaluated by the sampling data
///        features via calcSamplingVarAtPoint().
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::calcSamplingVariables(const std::vector<MInt>& varIds, const MBool exchange) {
  for(MUint i = 0; i < varIds.size(); i++) {
    const MInt varId = varIds[i];
    // Note: calcSamplingVariables() can be called from multiple features, check if sampling variable is already
    // computed and exchanged for this time step
    const MInt statusCurr = globalTimeStep;
    const MInt statusCalc = m_samplingVariablesStatus[2 * varId];
    const MInt statusExchange = m_samplingVariablesStatus[2 * varId + 1];
    TERMM_IF_COND(statusExchange == statusCurr && statusCalc != statusCurr,
                  "Error: invalid compute/exchange order " + std::to_string(statusCurr) + " "
                      + std::to_string(statusCalc) + " " + std::to_string(statusExchange));

    switch(varId) {
      case FV_PV: {
        // Nothing to do
        break;
      }
      case FV_VORT: {
        MFloat* vortPointer = m_samplingVariables[varId][0];
        if(statusCurr != statusCalc) { // Check if already computed for the current time step
          m_log << "DEBUG calcSamplingVariables calc FV_VORT " << statusCurr << " " << statusCalc << std::endl;
          IF_CONSTEXPR(nDim == 3) { computeVorticity3DT(vortPointer); }
          else {
            computeVorticity2D(vortPointer);
          }
          m_samplingVariablesStatus[2 * varId] = statusCurr; // update computed status
        }
        // Exchange data on window/halo cells if requested (e.g. for least squares interpolation)
        if(exchange && statusCurr != statusExchange) { // check if already exchanged for the current time step
          constexpr MInt noVort = (nDim == 2) ? 1 : 3;
          exchangeDataFV(vortPointer, noVort);
          m_samplingVariablesStatus[2 * varId + 1] = statusCurr; // update exchanged status
        }
        break;
      }
      case FV_HEAT_RELEASE: {
        // heat release should already be computed
        break;
      }
      default: {
        mTerm(1, "Invalid variable id");
        break;
      }
    }
  }
}


/** \page sensorsFV
 *
 *  \section entrGrad Entropy gradient
 *
 *  Property: <code>ENTROPY_GRADIENT</code>
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::sensorEntropyGrad(std::vector<std::vector<MFloat>>& sensors,
                                                           std::vector<std::bitset<64>>& sensorCellFlag,
                                                           std::vector<MFloat>& sensorWeight, MInt sensorOffset,
                                                           MInt sen) {
  m_log << "   - Sensor preparation for the entropy sensor" << endl;

  // weightings depending on the refinement
  ScratchSpace<MFloat> lengthFactor(maxRefinementLevel() + 1, AT_, "lengthFactor");
  for(MInt l = 0; l <= maxRefinementLevel(); l++)
    lengthFactor.p[l] = pow(c_cellLengthAtLevel(l), F3B2);

  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    ASSERT(!c_isToDelete(cellId), "");
    // skip all unnecessary cells
    if(a_bndryId(cellId) != -1) continue;
    if(a_isBndryGhostCell(cellId)) continue;
    if(c_noChildren(cellId) > 0) continue;
    if(a_isHalo(cellId)) continue;

    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    // if ( a_hasProperty( cellId , SolverCell::WasInactive ) ) continue;

    // shortcuts
    const MInt level = a_level(cellId);
    const MInt gridId = grid().tree().solver2grid(cellId);

    // compute the magnitude of the temperature gradient (stored in PV->P)
    MFloat a2 = sysEqn().temperature_ES(a_pvariable(cellId, PV->RHO), a_pvariable(cellId, PV->P));
    MFloat tau = F0;
    for(MInt i = 0; i < nDim; i++) {
      tau += POW2(a_slope(cellId, PV->P, i) - a_slope(cellId, PV->RHO, i) * a2);
    }
    tau = sqrt(tau);
    tau *= lengthFactor.p[level];
    sensors[sensorOffset + sen][gridId] = tau;
    sensorCellFlag[gridId][sensorOffset + sen] = 1;
  }

  sensorWeight[sensorOffset + sen] = this->m_sensorWeight[sen];
}

/** \page sensorsFV
 *
 *  \section entrQuot Entropy quotient
 *
 *  Property: <code>ENTROPY_QUOTIENT</code>
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::sensorEntropyQuot(std::vector<std::vector<MFloat>>& sensors,
                                                           std::vector<std::bitset<64>>& sensorCellFlag,
                                                           std::vector<MFloat>& sensorWeight, MInt sensorOffset,
                                                           MInt sen) {
  m_log << "   - Sensor preparation for the entropy sensor" << endl;

  // weightings depending on the refinement
  ScratchSpace<MFloat> lengthFactor(maxRefinementLevel() + 1, AT_, "lengthFactor");
  for(MInt l = 0; l <= maxRefinementLevel(); l++)
    lengthFactor.p[l] = pow(c_cellLengthAtLevel(l), F3B2);

  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    ASSERT(!c_isToDelete(cellId), "");
    // skip all unnecessary cells
    if(a_bndryId(cellId) != -1) continue;
    if(a_isBndryGhostCell(cellId)) continue;
    if(c_noChildren(cellId) > 0) continue;
    if(a_isHalo(cellId)) continue;

    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    // if ( a_hasProperty( cellId , SolverCell::WasInactive ) ) continue;

    // shortcuts
    const MInt level = a_level(cellId);
    const MInt gridId = grid().tree().solver2grid(cellId);

    MFloat tau = F0;
    tau = pow(mMax(F0, ((entropy(cellId) - m_SInfinity) / m_SInfinity)), 1.2);
    tau *= lengthFactor.p[level];
    sensors[sensorOffset + sen][gridId] = tau;
    sensorCellFlag[gridId][sensorOffset + sen] = 1;
  }

  sensorWeight[sensorOffset + sen] = this->m_sensorWeight[sen];
}

/** \page sensorsFV
 *
 *  \section vort Vorticity
 *
 *  Property: <code>VORTICITY</code>
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::sensorVorticity(std::vector<std::vector<MFloat>>& sensors,
                                                         std::vector<std::bitset<64>>& sensorCellFlag,
                                                         std::vector<MFloat>& sensorWeight, MInt sensorOffset,
                                                         MInt sen) {
  m_log << "   - Sensor preparation for the vorticity sensor" << endl;

  // weightings depending on the refinement
  ScratchSpace<MFloat> lengthFactor(maxRefinementLevel() + 1, AT_, "lengthFactor");
  for(MInt l = 0; l <= maxRefinementLevel(); l++)
    lengthFactor.p[l] = pow(c_cellLengthAtLevel(l), F3B2);

  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    ASSERT(!c_isToDelete(cellId), "");

    // skip all unnecessary cells
    if(a_bndryId(cellId) != -1) continue;
    if(a_isBndryGhostCell(cellId)) continue;
    if(c_noChildren(cellId) > 0) continue;
    if(a_isHalo(cellId)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    // if ( a_hasProperty( cellId , SolverCell::WasInactive ) ) continue;

    // shortcuts
    const MInt level = a_level(cellId);
    const MInt gridId = this->grid().tree().solver2grid(cellId);

    MFloat tau = F0;
    if(m_euler) {
      tau = sqrt(mMax(F1, (entropy(cellId) / m_SInfinity))) - F1;
    } else {
      IF_CONSTEXPR(nDim == 2) { tau = fabs(a_slope(cellId, PV->V, 0) - a_slope(cellId, PV->U, 1)); }
      else {
        tau = sqrt(POW2(a_slope(cellId, PV->W, 1) - a_slope(cellId, PV->V, 2))
                   + POW2(a_slope(cellId, PV->U, 2) - a_slope(cellId, PV->W, 0))
                   + POW2(a_slope(cellId, PV->V, 0) - a_slope(cellId, PV->U, 1)));
      }
    }

    tau *= lengthFactor.p[level];
    sensors[sensorOffset + sen][gridId] = tau;
    sensorCellFlag[gridId][sensorOffset + sen] = true;
  }

  sensorWeight[sensorOffset + sen] = this->m_sensorWeight[sen];
}

/** \page sensorsFV
 *
 *  \section der Derivative
 *
 *  Property: <code>DERIVATIVE</code>
 */
/** \brief computes the sensor values for a derivative sensor
 *
 * \author Andreas Lintermann
 * \date 25.04.2019
 *
 * Function is called by a function pointer in the array of function pointer (m_sensorFnPtr).
 * The function runs over all cells and computes the derivatives by a simple finite difference stencil.
 *
 * \param[in] sensors vector of vector of sensor values
 * \param[in] sensonWeight weighting of each sensor
 * \param[in] sensorCellFlag indicates if a cell is suited for adaptation
 * \param[in] sensorOffset the present sensor offset
 *
 **/
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::sensorDerivative(std::vector<std::vector<MFloat>>& sensors,
                                                          std::vector<std::bitset<64>>& sensorCellFlag,
                                                          std::vector<MFloat>& sensorWeight, MInt sensorOffset,
                                                          MInt sen) {
  m_log << "   - Sensor preparation for the derivative sensor" << endl;

  // weightings depending on the refinement
  ScratchSpace<MFloat> lengthFactor(maxRefinementLevel() + 1, AT_, "lengthFactor");
  for(MInt l = 0; l <= maxRefinementLevel(); l++) {
    lengthFactor[l] = pow(c_cellLengthAtLevel(l), F3B2);
  }

  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    ASSERT(!c_isToDelete(cellId), "");

    // skip all unnecessary cells
    if(a_bndryId(cellId) != -1) continue;
    if(a_isBndryGhostCell(cellId)) continue;
    if(c_noChildren(cellId) > 0) continue;
    if(a_isHalo(cellId)) continue;

    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    // if ( a_hasProperty( cellId , SolverCell::WasInactive ) ) continue;

    if(a_level(cellId) > this->m_maxSensorRefinementLevel[sen]) {
      continue;
    }

    const MInt gridId = this->grid().tree().solver2grid(cellId);

    // skip cells outside the bore
    if(m_engineSetup) {
      if(a_coordinate(cellId, 0) < -0.5 || a_coordinate(cellId, 0) > 0.5) continue;
    }

    MFloat tau = F0;

    // option to trigger velocity magnitude gradient!
    if((MInt)this->m_sensorDerivativeVariables[sen] == 10) {
      MFloat gradMax = F0;
      for(MInt d = 0; d < nDim; d++) {
        MFloat grad = 0;
        for(MInt i = 0; i < nDim; i++) {
          grad += POW2(a_slope(cellId, PV->VV[d], i));
        }
        if(grad > gradMax) gradMax = grad;
      }
      tau = sqrt(gradMax);
    } else if((MInt)this->m_sensorDerivativeVariables[sen] == 9) {
      // largest species gradient if species above 0.001
      if(a_pvariable(cellId, PV->Y[0]) > 0.001) {
        MFloat gradMax = F0;
        for(MInt d = 0; d < nDim; d++) {
          MFloat grad = 0;
          for(MInt i = 0; i < nDim; i++) {
            grad += POW2(a_slope(cellId, PV->Y[0], i));
          }
          if(grad > gradMax) gradMax = grad;
        }
        tau = sqrt(gradMax);
      }

    } else {
      // compute the magnitude of the gradient
      for(MInt d = 0; d < nDim; d++) {
        MFloat grad = a_slope(cellId, this->m_sensorDerivativeVariables[sen], d);
        tau += POW2(grad);
      }
      tau = sqrt(tau);
    }

    tau *= lengthFactor[a_level(cellId)];

    sensors[sensorOffset + sen][gridId] = tau;
    sensorCellFlag[gridId][sensorOffset + sen] = true;
  }

  sensorWeight[sensorOffset + sen] = this->m_sensorWeight[sen];
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::sensorSpecies(std::vector<std::vector<MFloat>>& sensors,
                                                       std::vector<std::bitset<64>>& sensorCellFlag,
                                                       std::vector<MFloat>& sensorWeight, MInt sensorOffset, MInt sen) {
  TRACE();

  /*! \page propertiesFV
  \section speciesConLimit
  <code>MFloat range</code>\n
  default = 0.0001 \n \n
  Species concentration limit for adaptation.\n
  Keywords: <i>PARTICLE</i>
  */
  MFloat speciesLimit = 0.0001;
  speciesLimit = Context::getSolverProperty<MFloat>("speciesConLimit", m_solverId, AT_, &speciesLimit);

  std::function<MFloat(const MInt)> species = [&](const MInt cellId) { return a_pvariable(cellId, PV->Y[0]); };

  static_cast<maia::CartesianSolver<nDim, FvCartesianSolverXD<nDim_, SysEqn>>*>(this)->sensorLimit(
      sensors, sensorCellFlag, sensorWeight, sensorOffset, sen, species, speciesLimit, &m_bandWidth[0],
      m_refineDiagonals);

  // reset sensor for inactive cells and outside engine
  if(m_levelSetMb) {
    for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
      if(m_linerLvlJump && (a_coordinate(cellId, 0) < -0.515 || a_coordinate(cellId, 0) > 0.515)) {
        const MInt gridCellId = grid().tree().solver2grid(cellId);
        if(sensors[sensorOffset + sen][gridCellId] > 0) {
          sensors[sensorOffset + sen][gridCellId] = 0;
          sensorCellFlag[gridCellId][sensorOffset + sen] = false;
        }
      }
      if(!a_isInactive(cellId)) continue;
      if(a_levelSetValuesMb(cellId, 0) > -(m_maxLsValue - m_eps)) continue;
      const MInt gridCellId = grid().tree().solver2grid(cellId);
      if(sensors[sensorOffset + sen][gridCellId] > 0) {
        sensors[sensorOffset + sen][gridCellId] = 0;
        sensorCellFlag[gridCellId][sensorOffset + sen] = false;
      }
    }
  }
}

/** \page sensorsFV
 *
 *  \section part Particles
 *
 *  This sensor represents the number of particles.<br>
 *  Property: <code>PARTICLES</code>
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::sensorParticle(std::vector<std::vector<MFloat>>& sensors,
                                                        std::vector<std::bitset<64>>& sensorCellFlag,
                                                        std::vector<MFloat>& sensorWeight, MInt sensorOffset,
                                                        MInt sen) {
  static constexpr MInt particleLimit = 1;

  std::function<MFloat(const MInt)> noPart = [&](const MInt cellId) { return static_cast<MFloat>(a_noPart(cellId)); };

  static_cast<maia::CartesianSolver<nDim, FvCartesianSolverXD<nDim_, SysEqn>>*>(this)->sensorLimit(
      sensors, sensorCellFlag, sensorWeight, sensorOffset, sen, noPart, particleLimit, &m_particleWidth[0],
      m_refineDiagonals);

  // reset sensor for inactive cells and outside engine
  if(m_levelSetMb) {
    for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
      if(m_engineSetup && (a_coordinate(cellId, 0) < -0.515 || a_coordinate(cellId, 0) > 0.515)) {
        const MInt gridCellId = grid().tree().solver2grid(cellId);
        if(sensors[sensorOffset + sen][gridCellId] > 0) {
          sensors[sensorOffset + sen][gridCellId] = 0;
          sensorCellFlag[gridCellId][sensorOffset + sen] = false;
        }
      }
      if(!a_isInactive(cellId)) continue;
      if(a_levelSetValuesMb(cellId, 0) > -(m_maxLsValue - m_eps)) continue;
      const MInt gridCellId = grid().tree().solver2grid(cellId);
      if(sensors[sensorOffset + sen][gridCellId] > 0) {
        sensors[sensorOffset + sen][gridCellId] = 0;
        sensorCellFlag[gridCellId][sensorOffset + sen] = false;
      }
    }
  }
}

/**
 * \brief Get distance to boundary, currently bc 3003. Should be replaced by more precise distance using STL
 * information. \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getBoundaryDistance(MFloatScratchSpace& distance) {
  MBoolScratchSpace interfaceCell(a_noCells(), AT_, "interfaceCell");
  interfaceCell.fill(0);
  vector<MInt> bndCndIds;
  bndCndIds.push_back(3003);

  this->identifyBoundaryCells(&interfaceCell[0], bndCndIds);

  this->setBoundaryDistance(&interfaceCell[0], &m_outerBandWidth[0], distance);

  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    // Fix for partition level shift, start reduce operation at internal cell with a halo parent
    const MInt parentId = c_parentId(cellId);
    const MBool isPartLvlShift = (parentId > -1 && a_isHalo(parentId));

    if(a_level(cellId) != minLevel() && !isPartLvlShift) {
      continue;
    }
    // @ansgar PLA TODO labels:FV
    // this does not properly reduces the distance for internal pla cells with halo childs!
    // reduce starting from partition cells and ignore partition level ancestors?
    reduceData(cellId, &distance(0));
  }
  exchangeDataFV(distance.data());
}


/**
 * \brief determines the value of 'data' in the given cell by recusively volumetric averaging among all its offsprings
 * \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
MFloat FvCartesianSolverXD<nDim_, SysEqn>::reduceData(const MInt cellId, MFloat* data, const MInt dataBlockSize,
                                                      const MBool average) {
  MFloat vol = a_cellVolume(cellId);
  if(c_noChildren(cellId) > 0) {
    vol = F0;
    for(MInt d = 0; d < dataBlockSize; d++) {
      data[dataBlockSize * cellId + d] = F0;
    }
    for(MInt child = 0; child < IPOW2(nDim); child++) {
      MInt childId = c_childId(cellId, child);
      if(childId < 0) continue;
      if(c_noChildren(childId) == 0 && !a_hasProperty(childId, SolverCell::IsOnCurrentMGLevel)) continue;
      MFloat volc = reduceData(childId, data, dataBlockSize);
      for(MInt d = 0; d < dataBlockSize; d++) {
        data[dataBlockSize * cellId + d] += volc * data[dataBlockSize * childId + d];
      }
      vol += volc;
    }
    if(average) {
      for(MInt d = 0; d < dataBlockSize; d++) {
        data[dataBlockSize * cellId + d] /= mMax(1e-14, vol);
      }
    }
  }
  return vol;
}

// --------------------------------------------------------------------------------------

/**
 * \brief Performs one Runge-Kutta step of the FV solver, returns true if the time step is completed
 * \author Thomas Hoesgen
 */
template <MInt nDim_, class SysEqn>
MBool FvCartesianSolverXD<nDim_, SysEqn>::solutionStep() {
  TRACE();

  NEW_TIMER_GROUP_STATIC(tg_solutionStep, "solution step");
  NEW_TIMER_STATIC(t_solutionStep, "solution step", tg_solutionStep);
  NEW_SUB_TIMER_STATIC(t_timeIntegration, "time integration", t_solutionStep);
  NEW_SUB_TIMER_STATIC(t_lhs, "lhs", t_timeIntegration);
  NEW_SUB_TIMER_STATIC(t_lhsBnd, "lhsBnd", t_timeIntegration);
  NEW_SUB_TIMER_STATIC(t_rhs, "rhs", t_timeIntegration);
  NEW_SUB_TIMER_STATIC(t_rhsBnd, "rhsBnd", t_timeIntegration);

  /// Time-integration (perform one Runge-Kutta step)
  RECORD_TIMER_START(t_solutionStep);
  RECORD_TIMER_START(t_timeIntegration);

  // Split MPI communication: finish MPI exchange if needed and perform
  // the left out part from lhsBnd()
  if(g_splitMpiComm && m_splitMpiCommRecv) {
    RECORD_TIMER_START(t_lhsBnd);
    lhsBndFinish();
    RECORD_TIMER_STOP(t_lhsBnd);
  }
  // Receive data in the next substep
  m_splitMpiCommRecv = true;

  /// RHS computation:
  RECORD_TIMER_START(t_rhs);
  rhs();
  RECORD_TIMER_STOP(t_rhs);

  /// RHS Boundary Condition:
  RECORD_TIMER_START(t_rhsBnd);
  rhsBnd();
  RECORD_TIMER_STOP(t_rhsBnd);

  /// LHS computation:
  RECORD_TIMER_START(t_lhs);
  const MBool timeStepCompleted = solverStep();
  RECORD_TIMER_STOP(t_lhs);

  /// LHS Boundary Condition:
  RECORD_TIMER_START(t_lhsBnd);
  lhsBnd();
  RECORD_TIMER_STOP(t_lhsBnd);

  RECORD_TIMER_STOP(t_timeIntegration);
  RECORD_TIMER_STOP(t_solutionStep);

  return timeStepCompleted;
}


/**
 * \brief: Performs the post time step
 * \author Thomas Hoesgen
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::postTimeStep() {
  TRACE();

  if(m_calcLESAverage) {
    calcLESAverage();
    if(globalTimeStep % m_restartInterval == 0) {
      saveLESAverage();
    }
  }
  if(m_STGSponge || m_preliminarySponge) {
    calcPeriodicSpongeAverage();
  }
  if(globalTimeStep >= m_stgSpongeTimeStep && m_STGSponge && globalTimeStep % m_restartInterval == 0) {
    saveSpongeData();
  }
  m_timeStepConverged = maxResidual();

  if(g_splitMpiComm && m_splitMpiCommRecv) {
    // Finish MPI communication in split MPI mode after completed timestep
    lhsBndFinish();
    // At the beginning of the next timestep there is nothing to receive
    m_splitMpiCommRecv = false;
  }

  m_forceAdaptation = adaptationTrigger();
}

//----------------------------------------------------------------------------


/** brief: limits scalar variables to [0,1]
 *
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::scalarLimiter() {
  TRACE();
  if(m_isEEGas) return;

  if(m_hasExternalSource) return;

  const MInt noCVars = CV->noVariables;
  MInt cellId;
  auto* var = (MFloat*)(&(a_variable(0, 0)));
  // auto* pvar = (MFloat*)(&(a_pvariable(0, 0)));

  for(MInt id = 0; id < m_noActiveCells; id++) {
    cellId = m_activeCellIds[id];
    for(MInt i = 0; i < m_noSpecies; i++)
      var[cellId * noCVars + CV->RHO_Y[i]] =
          mMin(var[cellId * noCVars + CV->RHO], mMax(var[cellId * noCVars + CV->RHO_Y[i]], F0));
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::revertTimestep() {
  const MFloat dt = timeStep(true);
  m_time -= dt;
  m_physicalTime -= dt * m_timeRef;
  m_RKStep = 0;
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::resetImplicitCoefficients() {
  TRACE();

#ifdef _OPENMP
#pragma omp parallel for collapse(2)
#endif
  // Set implicit coefficient to zero
  for(MInt i = 0; i < a_noCells(); i++) {
    for(MInt j = 0; j < 2 * nDim; j++) {
      a_implicitCoefficient(i, j) = F0;
    }
  }
}

template <MInt nDim_, class SysEqn>
template <class _, std::enable_if_t<isEEGas<SysEqn>, _*>>
void FvCartesianSolverXD<nDim_, SysEqn>::rhsEEGas() {
  TRACE();
  if(nDim != 3) mTerm(1, AT_, "nDim has to be 3 for EEGas simulations");

  // gas mass source
  if(m_EEGas.gasSource != 0) {
    for(auto& sourceCell : m_EEGas.gasSourceCells) {
      a_rightHandSide(sourceCell, CV->A_RHO) -= m_EEGas.massSource * a_cellVolume(sourceCell);
    }
  }

// adapted from computeVolumeForces()
// Gravity
#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt ac = 0; ac < m_noActiveCells; ac++) {
    for(MInt i = 0; i < nDim; i++) {
      a_rightHandSide(m_activeCellIds[ac], CV->A_RHO_VV[i]) -=
          a_pvariable(m_activeCellIds[ac], PV->RHO) * m_volumeAcceleration[i] * a_cellVolume(m_activeCellIds[ac])
          * a_pvariable(m_activeCellIds[ac], PV->A);
      IF_CONSTEXPR(hasE<SysEqn>)
      a_rightHandSide(m_activeCellIds[ac], CV->A_RHO_E) -=
          a_pvariable(m_activeCellIds[ac], PV->VV[i]) * a_pvariable(m_activeCellIds[ac], PV->RHO)
          * m_volumeAcceleration[i] * a_cellVolume(m_activeCellIds[ac]) * a_pvariable(m_activeCellIds[ac], PV->A);
    }
  }


  // Interface forces between bubbles and liquid
  static const MFloat Eo_factor = m_EEGas.Eo0 / (m_EEGas.liquidDensity - m_rhoInfinity);
  const MFloat F_D_factor = F3B4 * m_EEGas.liquidDensity / m_EEGas.bubbleDiameter; // = 3/4 * rho_l / d_B
  const MFloat F1Bdt = F1 / timeStep(true);
  const MFloat F1BdtLiquid =
      F1
      / (timeStep(true)
         * (m_EEGas.interpolationFactor > 0.0 ? m_EEGas.interpolationFactor * m_RKalpha[m_RKStep] : 1.0));
  const MFloat* const RESTRICT cellVol = &a_cellVolume(0);
#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt ac = 0; ac < m_noActiveCells; ac++) {
    const MInt cellId = m_activeCellIds[ac];
    if(a_isBndryGhostCell(cellId)) continue;
    MFloat F_D_factorCell = 0.0;
    MFloat C_D = 0.0;
    if(m_EEGas.dragModel == 0) {
      const MFloat Eo = Eo_factor * (m_EEGas.liquidDensity - a_pvariable(cellId, PV->RHO)); // Eotvos number
      C_D = F2B3 * sqrt(Eo); // only valid in regime of distorted bubbles (see Mohammadi et al. 2019)
      F_D_factorCell = F_D_factor * C_D;
    } else if(m_EEGas.dragModel == 1) {
      MFloat uSlip = 0.0;
      for(MInt i = 0; i < nDim; i++) {
        uSlip = mMax(uSlip, abs(a_uOtherPhase(cellId, i) - a_pvariable(cellId, PV->VV[i])));
      }
      const MFloat nu_l = a_nuEffOtherPhase(cellId) - a_nuTOtherPhase(cellId);
      const MFloat l_bubbleDiameter = m_EEGas.bubbleDiameter;
      C_D = 24.0 * nu_l / (sysEqn().m_Re0 * uSlip * l_bubbleDiameter);
      F_D_factorCell = F_D_factor * C_D;
    } else if(m_EEGas.dragModel == 2) {
      C_D = m_EEGas.CD;
      F_D_factorCell = F_D_factor * C_D;
    } else if(m_EEGas.dragModel == 3) {
      F_D_factorCell = a_alphaGas(cellId) * 18.0 / sysEqn().m_Re0
                       * (a_nuEffOtherPhase(cellId) - a_nuTOtherPhase(cellId)) * m_EEGas.liquidDensity
                       / mMin(10.0, 1 - a_alphaGas(cellId)) / m_EEGas.bubbleDiameter / m_EEGas.bubbleDiameter;
    }

    MFloat u_d[3];
    MFloat liftV[3];
    for(MInt i = 0; i < 3; i++) {
      u_d[i] = a_pvariable(cellId, PV->VV[i]) - a_uOtherPhase(cellId, i);
    }
    maia::math::cross(&u_d[0], &a_vortOtherPhase(cellId, 0), &liftV[0]);

    const MFloat F_L_factorCell = m_EEGas.CL * a_alphaGas(cellId) * m_EEGas.liquidDensity;

    MFloat F1BOldrhoAlpha = F0;
    if(a_oldVariable(cellId, CV->A_RHO) > -m_EEGas.eps) {
      F1BOldrhoAlpha = F1 / max(m_EEGas.eps, a_oldVariable(cellId, CV->A_RHO));
    } else {
      F1BOldrhoAlpha = F1 / a_oldVariable(cellId, CV->A_RHO);
    }
    const MFloat F_VM_factorCell = 0.5 * a_alphaGas(cellId) * m_EEGas.liquidDensity;

    const MFloat Sc = m_EEGas.schmidtNumber; // Schmidt number
    MFloat F_TD_factorCell = 0.0;
    if(m_EEGas.dragModel == 3) {
      F_TD_factorCell = -18.0 / sysEqn().m_Re0 / sysEqn().m_Re0 / Sc * m_EEGas.liquidDensity / m_EEGas.bubbleDiameter
                        / m_EEGas.bubbleDiameter * a_nuEffOtherPhase(cellId)
                        * (a_nuEffOtherPhase(cellId) - a_nuTOtherPhase(cellId)) / mMin(10.0, 1 - a_alphaGas(cellId));
    } else {
      F_TD_factorCell = -F1 / sysEqn().m_Re0 * F_D_factorCell / Sc * a_nuEffOtherPhase(cellId);
    }

    const MInt dragModel = m_EEGas.dragModel;

    const MFloat C_D0 = F_D_factorCell * m_EEGas.RKSemiImplicitFactor;
    const MFloat dt = timeStep(true) * m_RKalpha[m_RKStep];
    const MFloat C_VM0 = F_VM_factorCell / dt * m_EEGas.RKSemiImplicitFactor;

    for(MInt i = 0; i < nDim; i++) {
      // Calculation of the implicit coefficients
      MFloat C_D1, C_D2;
      const MInt sign = (0.0 < (-u_d[i])) - ((-u_d[i]) < 0.0);
      if(dragModel == 3) {
        C_D1 = C_D0 * a_uOtherPhase(cellId, i);
        C_D2 = -C_D0;
      } else {
        C_D1 =
            C_D0 * a_alphaGas(cellId) * sign * (POW2(a_uOtherPhase(cellId, i)) - POW2(a_pvariable(cellId, PV->VV[i])));
        C_D2 = 2.0 * C_D0 * a_alphaGas(cellId) * sign * u_d[i];
      }
      const MFloat gradAlpha = a_slope(cellId, PV->A, i);
      const MFloat C_TD0 = -F1 / sysEqn().m_Re0 * C_D0 / Sc * a_nuEffOtherPhase(cellId) * gradAlpha;
      MFloat C_TD1, C_TD2;
      if(dragModel == 3) {
        C_TD1 = 0.0;
        C_TD2 = 0.0;
      } else {
        C_TD1 = C_TD0 * a_uOtherPhase(cellId, i) * sign;
        C_TD2 = -C_TD0 * sign;
      }
      const MFloat C_VM1 = C_VM0 * a_pvariable(cellId, PV->VV[i]);
      const MFloat C_VM2 = -C_VM0;
      a_implicitCoefficient(cellId, i * 2) = (C_D1 + C_TD1 + C_VM1) * cellVol[cellId];
      a_implicitCoefficient(cellId, i * 2 + 1) = (C_D2 + C_TD2 + C_VM2) * cellVol[cellId];
      // Drag force
      MFloat F_D = 0.0;
      if(m_EEGas.dragModel == 3) {
        F_D = F_D_factorCell * -u_d[i];
      } else {
        F_D = F_D_factorCell * a_alphaGas(cellId) * -u_d[i] * abs(u_d[i]);
      }

      // Lift force
      // Mohammadi et al. 2019
      const MFloat F_L = F_L_factorCell * liftV[i];

      // buoyancy force
      // F_B = - alpha_g * rho_l * g_vec
      const MFloat F_B =
          m_EEGas.depthCorrection ? -a_alphaGas(cellId) * m_EEGas.liquidDensity * m_EEGas.gravity[i] : 0.0;

      // Virtual mass force
      // Mohammadi et al. 2019
      MFloat duOtherPhaseDt = (a_uOtherPhase(cellId, i) - a_uOtherPhaseOld(cellId, i)) * F1BdtLiquid;
      MFloat duDt = 0.0;
      if(m_RKStep == 0) {
        duDt = (a_pvariable(cellId, PV->VV[i]) - a_oldVariable(cellId, CV->A_RHO_VV[i]) * F1BOldrhoAlpha) * F1Bdt;
      } else {
        duDt = (a_pvariable(cellId, PV->VV[i]) - a_oldVariable(cellId, CV->A_RHO_VV[i]) * F1BOldrhoAlpha) * F1Bdt
               / m_RKalpha[m_RKStep - 1];
      }
      const MFloat F_VM_I = (F1BOldrhoAlpha > F1 / m_EEGas.eps * 0.999 || F1BOldrhoAlpha < -F1 / m_EEGas.eps * 0.999)
                                ? 0.0
                                : -F_VM_factorCell * duDt;
      const MFloat F_VM_E = F_VM_factorCell
                            * ((duOtherPhaseDt + a_uOtherPhase(cellId, 0) * a_gradUOtherPhase(cellId, i, 0)
                                + a_uOtherPhase(cellId, 1) * a_gradUOtherPhase(cellId, i, 1)
                                + a_uOtherPhase(cellId, 2) * a_gradUOtherPhase(cellId, i, 2))
                               - (a_pvariable(cellId, PV->VV[0]) * a_slope(cellId, PV->VV[i], 0)
                                  + a_pvariable(cellId, PV->VV[1]) * a_slope(cellId, PV->VV[i], 1)
                                  + a_pvariable(cellId, PV->VV[2]) * a_slope(cellId, PV->VV[i], 2)));

      // Turbulent dispersion force
      // Mohammadi et al. 2019
      MFloat F_TD = 0.0;
      if(m_EEGas.dragModel == 3) {
        F_TD = F_TD_factorCell * a_slope(cellId, PV->A, i);
      } else {
        F_TD = F_TD_factorCell * abs(u_d[i]) * a_slope(cellId, PV->A, i);
      }
      const MFloat explicitFF = 1.0 - m_EEGas.RKSemiImplicitFactor;

      a_rightHandSide(cellId, CV->A_RHO_VV[i]) -= // (-) because rhs is substracted from cell value in RK-step
          (F_D * explicitFF + F_L + F_VM_I * explicitFF + F_VM_E + F_TD * (m_EEGas.dragModel == 3 ? 1.0 : explicitFF)
           + F_B)
          * a_cellVolume(cellId);
    }
  }
}


// works only with zeroth level-set function!
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeSourceTerms() {
  TRACE();
  //  #define debugOutput
  const MInt noCells = a_noCells();
  MInt gc;
  MFloat factor, Psi, xi = F0, cbar, a = F0, a1 = F0, a2 = F0, b = F0, b2 = F0, b1 = F0, c1 = F0, FD, Rr,
                      sigma; //,d,omega
  MFloat reactionEnthalpy;
  const MFloat gammaMinusOne = m_gamma - F1;
  const MFloat FgammaMinusOne = F1 / gammaMinusOne;
  // MFloat denominator;
  MFloat FlaminarFlameThickness = F1 / m_laminarFlameThickness;
  // MFloat rhoU, Dth;
  MFloat rhoUFrhoB = m_burntUnburntTemperatureRatio;
  // MFloat rhoBurnt = m_rhoInfinity / m_burntUnburntTemperatureRatio;
  MFloat rhoJump = F1 / m_burntUnburntTemperatureRatio - F1;
  // MFloat FrhoBurnt = m_burntUnburntTemperatureRatio;
  MFloat factor1 = m_c0 / (F1 - m_c0);
  MFloat echekkiFerzigerPrefactor = F1 / (F1 - m_c0) * (F1 / (F1 - m_c0) - F1);
  const MFloat sq1F2 = sqrt(F1B2);
  const MFloat eps = c_cellLengthAtLevel(maxRefinementLevel()) * 0.00000000001;
  // MFloat levelSetNegative = F0, levelSetPlus = F0;

  //---
  // reset
  m_maxReactionRate = F0;
  m_totalHeatReleaseRate = F0;
  // compute the heat release
  reactionEnthalpy = (m_burntUnburntTemperatureRatio - F1) * FgammaMinusOne;
  // save old reaction rate
  if(m_RKStep == 0) {
    // if(hasReactionRates() && hasReactionRatesBackup())
    memcpy(&a_reactionRateBackup(0, 0), &a_reactionRate(0, 0), sizeof(MFloat) * noInternalCells());
  }
  // reset
  for(MInt c = 0; c < noCells; c++) {
    a_reactionRate(c, 0) = F0;
  }
  // compute the subfilter variance
  sigma = m_subfilterVariance * c_cellLengthAtLevel(maxLevel());
  factor = F1 / (sqrt(F2) * sigma);
  // return for no-heat release combustion
  if(reactionEnthalpy < m_rhoEInfinity * 0.00001) {
    return;
  }
  switch(m_initialCondition) {
    case 17516: {
      /** brief important correction of jump condition (implemented like presented in Dissertation D. Hartmann)
       *
       * \author Stephan Schlimpert
       * \date November 2011
       */
      MInt diverged = 0;
      MFloat diffTimeStep = 50000;
      if(m_temperatureChange && (globalTimeStep - m_restartTimeStep) <= diffTimeStep) {
        MFloat diffTemp = (m_burntUnburntTemperatureRatioEnd - m_burntUnburntTemperatureRatioStart);
        m_burntUnburntTemperatureRatio =
            (diffTemp / diffTimeStep) * (globalTimeStep - m_restartTimeStep) + m_burntUnburntTemperatureRatioStart;
      }
      // rhoBurnt = m_rhoFlameTube / m_burntUnburntTemperatureRatio;
      // FrhoBurnt = m_burntUnburntTemperatureRatio * F1 / m_rhoFlameTube;
      rhoJump = F1 - m_burntUnburntTemperatureRatio;
      for(MInt c = 0; c < m_bndryGhostCellsOffset; c++) {
        if(grid().tree().hasProperty(c, Cell::IsHalo)) {
          continue;
        }
        if(!a_hasProperty(c, SolverCell::IsOnCurrentMGLevel)) {
          continue;
        }
        MInt cLs = c;
        if(cLs < 0) {
          continue;
        }
        gc = cLs;
        // continue if the g cell is out of the band
        // the source term is in this case zero
        if(a_levelSetFunction(c, 0) < -999998) { // TODO labels:FV,toenhance!
          continue;
        }
        // compute the Echekki-Ferziger constant
        // - compute the inverse eddy viscosity (s/m^2)
        // - - density of the unburnt gas rho^u = m_rhoInfinity
        // - - assuming m_TInfinity is the temperature of the unburnt gas -> muInf=SUTHERLANDLAW(m_TInfinity)
        // - - DthInf = muInf^u / ( rho^u *Pr )
        FD = F1 / m_DthInfinity;
        // - compute Rr
        // levelSetNegative = a_levelSetFunction(gc, 0) - m_noReactionCells;
        // levelSetPlus = a_levelSetFunction(gc, 0) + m_noReactionCells;


        Rr = echekkiFerzigerPrefactor * POW2(a_flameSpeed(gc, 0) * (F1 - a_curvatureG(gc, 0) * m_marksteinLength)) * FD;

        // damp out the reaction rate to the wall w(y=0.0341) = 0 by damping the model constant Rr(y=0.0341)=0
        if(m_heatReleaseDamp) {
          if(c_coordinate(gc, 1) < (0.0234 + m_dampingDistanceFlameBase)) {
            if(c_coordinate(gc, 1) > 0.0234) {
              Rr *= 1. / m_dampingDistanceFlameBase * (c_coordinate(gc, 1) - 0.0234);
            }
          }
          if(c_coordinate(gc, 1) < 0.0234) {
            Rr = F0;
          }
        }
        // compute Psi
        // - compute xi
        xi = a_levelSetFunction(gc, 0) * factor; //< xi = G(x,t)/(sigma*sqrt(2))

        // - compute c bar
        a = xi - sq1F2 * factor1 * sigma * FlaminarFlameThickness;
        a1 = F1B2 * (POW2(sigma * factor1 * FlaminarFlameThickness))
             - SQRT2 * xi * sigma * factor1 * FlaminarFlameThickness;
        if(a > F3) {
          a2 = (F1 - m_c0) * exp(a1) * F1B2 * (-erfc(a) + F2); // erfc computes 1-erf and is more accurate for large a
        } else {
          a2 = (F1 - m_c0) * exp(a1) * F1B2 * (erf(a) + F1);
        }
        b = xi + sq1F2 * sigma * FlaminarFlameThickness;
        b1 = F1B2 * POW2(sigma * FlaminarFlameThickness) + SQRT2 * xi * sigma * FlaminarFlameThickness;
        if(b > F3) {
          b2 = m_c0 * exp(b1) * F1B2 * (-erfc(b)); // erfc computes 1-erf and is more accurate for large b
        } else {
          b2 = m_c0 * exp(b1) * F1B2 * (erf(b) - F1);
        }
        c1 = F1B2 * (erf(xi) - F1);
        cbar = F1 - (a2 + b2 - c1);

        // - compute Psi
        if(ABS(F1 - cbar) < eps) {
          Psi = F1;
        } else {
          Psi = a2 / ((F1 - cbar) * POW2((rhoUFrhoB + cbar * rhoJump)));
        }

        a_psi(c) = Psi;

        IF_CONSTEXPR(hasPV_C<SysEqn>::value) {
          // compute rhoBar
          const MFloat rhoBar = m_rhoUnburnt / (1 - a_pvariable(c, PV->C) * rhoJump);

          // compute the source term
          a_reactionRate(c, 0) = sysEqn().m_Re0 * rhoBar * rhoUFrhoB * Rr * (F1 - a_pvariable(c, PV->C)) * Psi;
        }

        // catch nan reaction rate
        if(!(a_reactionRate(c, 0) >= F0) && !(a_reactionRate(c, 0) <= F0)) {
          diverged = 1;
          cerr << "reaction rate is nan!!!" << endl;
        }

        // compute the source terms
        IF_CONSTEXPR(hasPV_C<SysEqn>::value)
        a_rightHandSide(c, CV->RHO_C) -= a_reactionRate(c, 0) * a_cellVolume(c);
        a_rightHandSide(c, CV->RHO_E) -= a_reactionRate(c, 0) * a_cellVolume(c) * reactionEnthalpy;

        // compute the maximum reaction rate and the total heat release
        if(!a_hasProperty(c, Cell::IsHalo)) {
          m_maxReactionRate = mMax(a_reactionRate(c, 0), m_maxReactionRate);
          m_totalHeatReleaseRate += a_reactionRate(c, 0) * a_cellVolume(c) * reactionEnthalpy;
        }
      }
      MPI_Allreduce(MPI_IN_PLACE, &diverged, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "diverged");
      if(diverged == 1) {
        cerr << "Solution diverged (computeSourceTerms)" << endl;
        MString errorMessage = "reaction rate is nan";
        mTerm(1, AT_, errorMessage);
      }

      break;
    }
    case 1751600: {
      MInt diverged = 0;
      MFloat diffTimeStep = 50000;
      if(m_temperatureChange && (globalTimeStep - m_restartTimeStep) <= diffTimeStep) {
        MFloat diffTemp = (m_burntUnburntTemperatureRatioEnd - m_burntUnburntTemperatureRatioStart);
        m_burntUnburntTemperatureRatio =
            (diffTemp / diffTimeStep) * (globalTimeStep - m_restartTimeStep) + m_burntUnburntTemperatureRatioStart;
      }
      // rhoBurnt = m_rhoFlameTube / m_burntUnburntTemperatureRatio;
      // FrhoBurnt = m_burntUnburntTemperatureRatio * F1 / m_rhoFlameTube;
      rhoJump = F1 - m_burntUnburntTemperatureRatio;
      for(MInt c = 0; c < m_bndryGhostCellsOffset; c++) {
        if(grid().tree().hasProperty(c, Cell::IsHalo)) {
          continue;
        }
        if(!a_hasProperty(c, SolverCell::IsOnCurrentMGLevel)) {
          continue;
        }
        MInt cLs = c;
        if(cLs < 0) {
          continue;
        }
        gc = cLs;
        if(gc == -1) {
          continue;
        }
        // continue if the g cell is out of the band
        // the source term is in this case zero
        if(a_levelSetFunction(gc, 0) < -99998) {
          continue;
        }
        // compute the Echekki-Ferziger constant
        // - compute the inverse eddy viscosity (s/m^2)
        // - - density of the unburnt gas rho^u = m_rhoInfinity
        // - - assuming m_TInfinity is the temperature of the unburnt gas -> muInf=SUTHERLANDLAW(m_TInfinity)
        // - - DthInf = muInf^u / ( rho^u *Pr )
        FD = F1 / m_DthInfinity;
        // - compute Rr
        // levelSetNegative = lsSolver().a_levelSetFunctionG(gc, 0) - m_noReactionCells;
        // levelSetPlus = lsSolver().a_levelSetFunctionG(gc, 0) + m_noReactionCells;

        Rr = echekkiFerzigerPrefactor * POW2(a_flameSpeed(gc, 0) * (F1 - a_curvatureG(gc, 0) * m_marksteinLength)) * FD;

        // damp out the reaction rate to the wall w(y=0.0341) = 0 by damping the model constant Rr(y=0.0341)=0
        if(m_heatReleaseDamp) {
          if(c_coordinate(gc, 1) < (m_yOffsetFlameTube + m_dampingDistanceFlameBase)) {
            if(c_coordinate(gc, 1) > m_yOffsetFlameTube) {
              Rr *= 1. / m_dampingDistanceFlameBase * (c_coordinate(gc, 1) - m_yOffsetFlameTube);
            }
          }
          if(c_coordinate(gc, 1) < m_yOffsetFlameTube) {
            Rr = F0;
          }
        }

        xi = a_levelSetFunction(gc, 0) * factor; //< xi = G(x,t)/(sigma*sqrt(2))

        // - compute c bar
        a = xi - sq1F2 * factor1 * sigma * FlaminarFlameThickness;
        a1 = F1B2 * (POW2(sigma * factor1 * FlaminarFlameThickness))
             - SQRT2 * xi * sigma * factor1 * FlaminarFlameThickness;
        if(a > F3) {
          a2 = (F1 - m_c0) * exp(a1) * F1B2 * (-erfc(a) + F2); // erfc computes 1-erf and is more accurate for large a
        } else {
          a2 = (F1 - m_c0) * exp(a1) * F1B2 * (erf(a) + F1);
        }
        b = xi + sq1F2 * sigma * FlaminarFlameThickness;
        b1 = F1B2 * POW2(sigma * FlaminarFlameThickness) + SQRT2 * xi * sigma * FlaminarFlameThickness;
        if(b > F3) {
          b2 = m_c0 * exp(b1) * F1B2 * (-erfc(b)); // erfc computes 1-erf and is more accurate for large b
        } else {
          b2 = m_c0 * exp(b1) * F1B2 * (erf(b) - F1);
        }
        c1 = F1B2 * (erf(xi) - F1);
        cbar = F1 - (a2 + b2 - c1);

        // - compute Psi
        if(ABS(F1 - cbar) < eps) {
          Psi = F1;
        } else {
          Psi = a2 / ((F1 - cbar) * POW2((rhoUFrhoB + cbar * rhoJump)));
        }

        a_psi(c) = Psi;

        IF_CONSTEXPR(hasPV_C<SysEqn>::value) {
          // compute rhoBar
          const MFloat rhoBar = m_rhoUnburnt / (1 - a_pvariable(c, PV->C) * rhoJump);

          // compute the source term
          a_reactionRate(c, 0) = sysEqn().m_Re0 * rhoBar * rhoUFrhoB * Rr * (F1 - a_pvariable(c, PV->C)) * Psi;
        }

        // catch nan reaction rate
        if(!(a_reactionRate(c, 0) >= F0) && !(a_reactionRate(c, 0) <= F0)) {
          diverged = 1;
        }

        // compute the source terms
        IF_CONSTEXPR(hasPV_C<SysEqn>::value)
        a_rightHandSide(c, CV->RHO_C) -= a_reactionRate(c, 0) * a_cellVolume(c);
        a_rightHandSide(c, CV->RHO_E) -= a_reactionRate(c, 0) * a_cellVolume(c) * reactionEnthalpy;

        // compute the maximum reaction rate and the total heat release
        if(!a_hasProperty(c, Cell::IsHalo)) {
          m_maxReactionRate = mMax(a_reactionRate(c, 0), m_maxReactionRate);
          m_totalHeatReleaseRate += a_reactionRate(c, 0) * a_cellVolume(c) * reactionEnthalpy;
        }
      }
      MPI_Allreduce(MPI_IN_PLACE, &diverged, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "diverged");
      if(diverged == 1) {
        // m_log << "Solution diverged, writing NETCDF file for debugging" << endl;
        MString errorMessage = "reaction rate is nan";
        mTerm(1, AT_, errorMessage);
      }

      break;
    }


    default: {
      cerr << "dont use the default in computeSourceTerms (FV) !!!" << endl;
      break;
    }
  }
  if(noDomains() > 1) {
    MPI_Allreduce(MPI_IN_PLACE, &m_totalHeatReleaseRate, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "m_totalHeatReleaseRate");
    MPI_Allreduce(MPI_IN_PLACE, &m_maxReactionRate, 1, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                  "m_maxReactionRate");
  }
}

template <MInt nDim_, class SysEqn>
MFloat FvCartesianSolverXD<nDim_, SysEqn>::computeWMViscositySpalding(MInt wmSrfcId) {
  TRACE();

  const MFloat kappa = 0.4;
  const MFloat B = 5.5;

  const MInt bndryCellId = m_wmSurfaces[wmSrfcId].m_bndryCellId;
  const MInt bndrySrfcId = m_wmSurfaces[wmSrfcId].m_bndrySrfcId;
  const MInt cellId = m_bndryCells->a[bndryCellId].m_cellId;

  if(!m_wmSurfaces[wmSrfcId].m_wmHasImgCell) {
    return F0;
  }

  MFloat tau_wm = F0;
  MFloat mue_wm = F0;

  MFloat nx = m_bndryCells->a[bndryCellId].m_srfcs[bndrySrfcId]->m_normalVector[0];
  MFloat ny = m_bndryCells->a[bndryCellId].m_srfcs[bndrySrfcId]->m_normalVector[1];
  MFloat u_img = 0.0;
  MFloat v_img = 0.0;
  MFloat u_II = 0.0;
  MFloat u_II_bndry = 0.0;
  MFloat dn_img = m_wmDistance;

  u_img = m_wmSurfaces[wmSrfcId].m_wmImgVars[PV->VV[0]];
  v_img = m_wmSurfaces[wmSrfcId].m_wmImgVars[PV->VV[1]];

  // compute wall parallel velocities, depending on surface orientation
  if(abs(ny) < m_eps) return F0; // close to vertical wall, can't decide proper flow direction here

  u_II = maia::math::sgn(ny) * (u_img * ny - v_img * nx);
  u_II_bndry = maia::math::sgn(ny) * (a_pvariable(cellId, PV->U) * ny - a_pvariable(cellId, PV->V) * nx);

  if(u_II > 0.0 && u_II_bndry > 0.0) {
    const MInt ghostCellId = m_bndryCells->a[bndryCellId].m_srfcVariables[bndrySrfcId]->m_ghostCellId;
    const MFloat rho_surf = F1B2 * (a_pvariable(cellId, PV->RHO) + a_pvariable(ghostCellId, PV->RHO));
    const MFloat p_surf = F1B2 * (a_pvariable(cellId, PV->P) + a_pvariable(ghostCellId, PV->P));
    const MFloat T_surf = sysEqn().temperature_ES(rho_surf, p_surf);
    const MFloat mue = SUTHERLANDLAW(T_surf);

    const MFloat Re0 = sysEqn().m_Re0;

    // Time filter to reduce fluctuations in the wall shear stress which are normally dampened by the viscous sublayer
    MFloat u_tau = m_wmSurfaces[wmSrfcId].m_wmUTAU;

    if(m_wmTimeFilter) {
      // see "Integral wall model for large large eddy simulations of wall-bounded turbulent flows" (Yang et al. 2015)
      const MFloat theta = 1.0;
      const MFloat twall = theta * m_wmDistance / (kappa * u_tau);
      const MFloat E = m_timeStep / twall; // constant for exponential moving average
      const MFloat u_II_last = m_wmSurfaces[wmSrfcId].m_wmUII;

      // floating average with time constant based on shear velocity
      u_II = E * u_II + (F1 - E) * u_II_last;
    }

    // save u_II for restart purposes (before van Driest Transformation!)
    m_wmSurfaces[wmSrfcId].m_wmUII = u_II;

    if(m_Ma > 1.3) {
      // van Driest transform for compressible flows
      const MFloat b = sysEqn().vanDriest(m_Ma);
      u_II = m_UInfinity / b * asin(b * u_II / m_UInfinity);
    }

    // iteration of spalding wall function
    MFloat res = 9999.0;
    while(res > 1e-6) {
      MFloat eKB = exp(-kappa * B);
      MFloat spalding = u_II / u_tau
                        + eKB
                              * (exp(kappa * u_II / u_tau) - 1 - (kappa * u_II / u_tau)
                                 - 1.0 / 2.0 * pow(kappa * u_II / u_tau, 2) - 1.0 / 6.0 * pow(kappa * u_II / u_tau, 3))
                        - abs(dn_img) * u_tau * (rho_surf / mue) * Re0;
      MFloat d_spalding =
          -u_II / pow(u_tau, 2)
          + eKB
                * ((-kappa * u_II / pow(u_tau, 2)) * exp(kappa * u_II / u_tau) + (kappa * u_II / u_tau) / u_tau
                   + pow(kappa * u_II / u_tau, 2) / u_tau + 1.0 / 2.0 * pow(kappa * u_II / u_tau, 3) / u_tau)
          - abs(dn_img) * (rho_surf / mue) * Re0;

      MFloat delta = -spalding / d_spalding;

      u_tau += delta;
      res = abs(delta / u_tau);
      m_wmIterator++;
    }

    // save u_tau for restart purposes
    m_wmSurfaces[wmSrfcId].m_wmUTAU = u_tau;

    if(std::isnan(u_tau)) {
      cout << "WARNING: Wall model u_tau is NaN!" << endl;
      return F0;
    }

    tau_wm = rho_surf * pow(u_tau, 2);

    MFloat dudn = m_bndryCells->a[bndryCellId].m_srfcVariables[bndrySrfcId]->m_normalDeriv[PV->VV[0]];
    MFloat dvdn = m_bndryCells->a[bndryCellId].m_srfcVariables[bndrySrfcId]->m_normalDeriv[PV->VV[1]];
    MFloat grad = maia::math::sgn(ny) * (dudn * ny - dvdn * nx);
    MFloat tau_w = mue * grad / Re0;

    if(tau_w / tau_wm > m_eps) mue_wm = ((tau_wm / tau_w) - 1.0) * mue;
    if(mue_wm > 50.0 * mue) mue_wm = 50.0 * mue;
  }

  m_wmSurfaces[wmSrfcId].m_wmTauW = tau_wm;
  m_wmSurfaces[wmSrfcId].m_wmMUEWM = mue_wm;

  return mue_wm;
}


template <MInt nDim_, class SysEqn>
MFloat FvCartesianSolverXD<nDim_, SysEqn>::computeWMViscositySpalding3D(MInt cellId) {
  TRACE();

  const MFloat kappa = 0.4;
  const MFloat B = 5.5;

  MInt bndryCellId = a_bndryId(cellId);
  if(!m_bndryCells->a[bndryCellId].m_wmBCVars->m_wmHasImgCell) return F0;

  MFloat tau_wm = F0;
  MFloat mue_wm = F0;

  MFloat* normalVec = m_bndryCells->a[bndryCellId].m_srfcs[0]->m_normalVector;
  MFloat* imgVar = m_bndryCells->a[bndryCellId].m_wmBCVars->m_wmImgVars;
  MFloat* normalDeriv = m_bndryCells->a[bndryCellId].m_srfcVariables[0]->m_normalDeriv;

  MFloat vvII[3] = {0.0, 0.0, 0.0};
  MFloat vvn[3] = {0.0, 0.0, 0.0};
  MFloat dvvII_dn[3] = {0.0, 0.0, 0.0};
  MFloat dvvn_dn[3] = {0.0, 0.0, 0.0};

  MFloat Vn = 0.0;
  MFloat VII = 0.0;
  MFloat dVn_dn = 0.0;
  MFloat dVII_dn = 0.0;

  MFloat dn_img = m_wmDistance;

  // decompose 3D velocity and gradients into wall-parallel and orthogonal components
  for(MInt d = 0; d < nDim; d++) {
    Vn += imgVar[PV->VV[d]] * normalVec[d];
    dVn_dn += normalDeriv[PV->VV[d]] * normalVec[d];
  }

  for(MInt d = 0; d < nDim; d++) {
    vvn[d] = Vn * normalVec[d];
    vvII[d] = imgVar[PV->VV[d]] - vvn[d];

    dvvn_dn[d] = dVn_dn * normalVec[d];
    dvvII_dn[d] = normalDeriv[PV->VV[d]] - dvvn_dn[d];
  }

  for(MInt d = 0; d < nDim; d++) {
    VII += POW2(vvII[d]);
    dVII_dn += POW2(dvvII_dn[d]);
  }

  VII = sqrt(VII);
  dVII_dn = sqrt(dVII_dn);

  // close to vertical wall, can't decide proper flow direction here, probably stagnation point
  if(F1 - abs(normalVec[0]) < m_eps) return F0;

  // check for attached flow with respect to mean flow in x direction)
  if(vvII[0] > 0.0 && dvvII_dn[0] > 0.0) {
    const MInt ghostCellId = m_bndryCells->a[bndryCellId].m_srfcVariables[0]->m_ghostCellId;
    const MFloat rho_surf = F1B2 * (a_pvariable(cellId, PV->RHO) + a_pvariable(ghostCellId, PV->RHO));
    const MFloat p_surf = F1B2 * (a_pvariable(cellId, PV->P) + a_pvariable(ghostCellId, PV->P));
    const MFloat T_surf = sysEqn().temperature_ES(rho_surf, p_surf);
    const MFloat mue = SUTHERLANDLAW(T_surf);

    const MFloat Re0 = sysEqn().m_Re0;

    if(m_Ma > 1.3) {
      // van Driest transform for compressible flows
      const MFloat b = sysEqn().vanDriest(m_Ma);
      VII = m_UInfinity / b * asin(b * VII / m_UInfinity);
    }

    // iteration of spalding wall function
    MFloat u_tau = m_bndryCells->a[bndryCellId].m_wmBCVars->m_wmUTAU;
    MFloat res = 9999.0;

    while(res > 1e-6) {
      MFloat eKB = exp(-kappa * B);
      MFloat spalding = VII / u_tau
                        + eKB
                              * (exp(kappa * VII / u_tau) - 1 - (kappa * VII / u_tau)
                                 - 1.0 / 2.0 * pow(kappa * VII / u_tau, 2) - 1.0 / 6.0 * pow(kappa * VII / u_tau, 3))
                        - abs(dn_img) * u_tau * (rho_surf / mue) * Re0;
      MFloat d_spalding =
          -VII / pow(u_tau, 2)
          + eKB
                * ((-kappa * VII / pow(u_tau, 2)) * exp(kappa * VII / u_tau) + (kappa * VII / u_tau) / u_tau
                   + pow(kappa * VII / u_tau, 2) / u_tau + 1.0 / 2.0 * pow(kappa * VII / u_tau, 3) / u_tau)
          - abs(dn_img) * (rho_surf / mue) * Re0;
      MFloat delta = -spalding / d_spalding;
      u_tau += delta;
      res = abs(delta / u_tau);
      m_wmIterator++;
    }

    tau_wm = rho_surf * pow(u_tau, 2);

    m_bndryCells->a[bndryCellId].m_wmBCVars->m_wmUTAU = u_tau;

    MFloat tau_w = mue * dVII_dn / Re0;

    if(tau_w / tau_wm > m_eps) mue_wm = ((tau_wm / tau_w) - 1.0) * mue;
    if(mue_wm > 50.0 * mue) mue_wm = 50.0 * mue; // USE MAX FUNCTION MAYBE?
  }

  if(m_wmOutput) {
    m_bndryCells->a[bndryCellId].m_wmBCVars->m_wmUII = VII;
    m_bndryCells->a[bndryCellId].m_wmBCVars->m_wmTauW = tau_wm;
    m_bndryCells->a[bndryCellId].m_wmBCVars->m_wmMUEWM = mue_wm;
  }

  return mue_wm;
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::readWallModelProperties() {
  TRACE();

  m_wmLES = Context::getSolverProperty<MBool>("wmLES", m_solverId, AT_, &m_wmLES);

  if(m_wmLES) {
    m_log << endl << "Reading WM properties ... " << endl;

    if(Context::propertyExists("wmUseInterpolation", m_solverId)) {
      m_wmUseInterpolation =
          Context::getSolverProperty<MBool>("wmUseInterpolation", m_solverId, AT_, &m_wmUseInterpolation);
    } else {
      m_wmUseInterpolation = true;
    }

    if(Context::propertyExists("wmDistance", m_solverId)) {
      m_wmDistance = Context::getSolverProperty<MFloat>("wmDistance", m_solverId, AT_, &m_wmDistance);
    } else {
      m_wmDistance = 2.0 * c_cellLengthAtLevel(maxLevel());
    }

    if(Context::propertyExists("wmOutput", m_solverId)) {
      m_wmOutput = Context::getSolverProperty<MBool>("wmOutput", m_solverId, AT_, &m_wmOutput);
    } else {
      m_wmOutput = false;
    }

    if(Context::propertyExists("wmSurfaceProbeInterval", m_solverId)) {
      m_wmSurfaceProbeInterval =
          Context::getSolverProperty<MInt>("wmSurfaceProbeInterval", m_solverId, AT_, &m_wmSurfaceProbeInterval);
    } else {
      m_wmSurfaceProbeInterval = 0;
    }

    if(Context::propertyExists("wmTimeFilter", m_solverId)) {
      m_wmTimeFilter = Context::getSolverProperty<MBool>("wmTimeFilter", m_solverId, AT_, &m_wmTimeFilter);
    } else {
      m_wmTimeFilter = false;
    }

    m_log << "wmDistance = " << m_wmDistance << endl;
    m_log << "wmUseInterpolation = " << m_wmUseInterpolation << endl;
    m_log << "wmOutput = " << m_wmOutput << endl;
    m_log << "wmSurfaceProbeInterval = " << m_wmSurfaceProbeInterval << endl;
    m_log << "done.";
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::exchangeWMVars() {
  TRACE();

  const MInt noPVars = PV->noVariables;

  // gather
  gatherWMVars();

  // send
  MInt sendBufSize = 0;
  MInt sendOffset = 0;

  for(MInt dom = 0; dom < m_wmNoDomains; dom++) {
    sendBufSize = m_noWMImgPointsSend[dom] * noPVars;
    MPI_Issend(&m_wmImgSendBuffer[sendOffset], sendBufSize, MPI_DOUBLE, dom, 0, m_comm_wm, &m_mpi_wmSendReq[dom], AT_,
               "m_wmImgSendBuffer[sendOffset]");
    sendOffset += sendBufSize;
  }

  // receive
  MInt recvOffset = 0;
  MInt recvBufSize = 0;

  for(MInt dom = 0; dom < m_wmNoDomains; dom++) {
    recvBufSize = m_noWMImgPointsRecv[dom] * noPVars;
    MPI_Irecv(&m_wmImgRecvBuffer[recvOffset], recvBufSize, MPI_DOUBLE, dom, 0, m_comm_wm, &m_mpi_wmRecvReq[dom], AT_,
              "m_wmImgRecvBuffer[recvOffset]");
    recvOffset += recvBufSize;
  }
  MPI_Waitall(m_wmNoDomains, &m_mpi_wmSendReq[0], MPI_STATUSES_IGNORE, AT_);
  MPI_Waitall(m_wmNoDomains, &m_mpi_wmRecvReq[0], MPI_STATUSES_IGNORE, AT_);

  scatterWMVars();
}


// interpolation must occur beforehand, a data structure to save the interplolated variables is necessary
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::gatherWMVars() {
  TRACE();
  const MInt noPVars = PV->noVariables;
  MInt sendBufferCounter = 0;

  if(m_wmUseInterpolation) {
    MFloatScratchSpace interpolatedVars(noPVars, AT_, "interpolatedVars");
    for(MInt dom = 0; dom < m_wmNoDomains; dom++) {
#ifdef _OPENMP
#pragma omp parallel for
#endif
      for(MInt ip = 0; ip < m_noWMImgPointsSend[dom]; ip++) {
        const MInt imgCellId = m_wmImgCellIds[dom][ip];
        const MFloat* imgCoords = &m_wmImgCoords[dom][nDim * ip];
        getInterpolatedVariablesInCell(imgCellId, &imgCoords[0], &interpolatedVars[0]);
        for(MInt v = 0; v < noPVars; v++) {
          m_wmImgSendBuffer[sendBufferCounter + (ip * noPVars) + v] = interpolatedVars[v];
        }
      }
      // moving the counter out of the loop allows openmp parallelization
      sendBufferCounter += m_noWMImgPointsSend[dom] * noPVars;
    }
  } else {
    for(MInt dom = 0; dom < m_wmNoDomains; dom++) {
      for(MInt ip = 0; ip < m_noWMImgPointsSend[dom]; ip++) {
        const MInt imgCellId = m_wmImgCellIds[dom][ip];
        for(MInt v = 0; v < noPVars; v++) {
          m_wmImgSendBuffer[sendBufferCounter + (ip * noPVars) + v] = a_pvariable(imgCellId, v);
        }
      }
      // moving the counter out of the loop allows openmp parallelization
      sendBufferCounter += m_noWMImgPointsSend[dom] * noPVars;
    }
  }
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::sendWMVars() {
  TRACE();
  const MInt noPVars = PV->noVariables;
  MInt bufSize = 0;
  MInt offset = 0;

  for(MInt dom = 0; dom < noDomains(); dom++) {
    bufSize = m_noWMImgPointsSend[dom] * noPVars;
    MPI_Issend(&m_wmImgSendBuffer[offset], bufSize, MPI_DOUBLE, dom, 0, mpiComm(), &m_mpi_wmRequest[dom], AT_,
               "m_wmImgSendBuffer[offset]");
    offset += bufSize;
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::receiveWMVars() {
  TRACE();
  const MInt noPVars = PV->noVariables;
  MInt offset = 0;
  MInt bufSize = 0;
  MPI_Status status;

  // TODO labels:FV,COMM switch to Irecv + Waitall
  for(MInt dom = 0; dom < noDomains(); dom++) {
    bufSize = m_noWMImgPointsRecv[dom] * noPVars;
    MPI_Recv(&m_wmImgRecvBuffer[offset], bufSize, MPI_DOUBLE, dom, 0, mpiComm(), &status, AT_,
             "m_wmImgRecvBuffer[offset]");
    offset += bufSize;
  }
  for(MInt dom = 0; dom < noDomains(); dom++) {
    MPI_Wait(&m_mpi_wmRequest[dom], &status, AT_);
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::scatterWMVars() {
  TRACE();

  if(PV->noVariables > 5) mTerm(1, AT_, "WMLES not implemented for noPVars > 5");

  const MInt noPVars = mMin(PV->noVariables, 5);
  MInt ipCounter = 0;

  for(MInt dom = 0; dom < m_wmNoDomains; dom++) {
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for(MInt ip = 0; ip < m_noWMImgPointsRecv[dom]; ip++) {
      const MInt wmSrfcId = m_wmImgRecvIdMap[ipCounter + ip];
      for(MInt v = 0; v < noPVars; v++) {
        m_wmSurfaces[wmSrfcId].m_wmImgVars[v] = m_wmImgRecvBuffer[noPVars * (ipCounter + ip) + v];
      }
      // ipCounter++;
    }
    // moving the counter out of the loop allows openmp parallelization
    ipCounter += m_noWMImgPointsRecv[dom];
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initWMExchange() {
  TRACE();

  mDeallocate(m_noWMImgPointsSend);
  mDeallocate(m_noWMImgPointsRecv);
  mDeallocate(m_wmImgSendBuffer);
  mDeallocate(m_wmImgRecvBuffer);
  mDeallocate(m_wmImgRecvIdMap);
  mDeallocate(m_mpi_wmRequest);
  mDeallocate(m_mpi_wmSendReq);
  mDeallocate(m_mpi_wmRecvReq);

  m_wmImgCellIds.clear();
  m_wmImgWMSrfcIds.clear();
  m_wmImgCoords.clear();

  const MInt noPVars = PV->noVariables;
  const MInt noWMSurfaces = m_wmSurfaces.size();

  std::vector<MFloat> localWMImgCoords;
  std::vector<MInt> localWMImgPointRootIds;
  std::vector<MInt> localWMSrfcIds;

  for(MInt wmSrfcId = 0; wmSrfcId < noWMSurfaces; wmSrfcId++) {
    MInt bndryCellId = m_wmSurfaces[wmSrfcId].m_bndryCellId;
    MInt bndrySrfcId = m_wmSurfaces[wmSrfcId].m_bndrySrfcId;

    for(MInt dim = 0; dim < nDim; dim++) {
      MFloat imgCoord = 0.0;
      imgCoord += m_bndryCells->a[bndryCellId].m_srfcs[bndrySrfcId]->m_coordinates[dim];
      imgCoord += m_wmDistance * m_bndryCells->a[bndryCellId].m_srfcs[bndrySrfcId]->m_normalVector[dim];
      localWMImgCoords.push_back(imgCoord);
    }
    localWMImgPointRootIds.push_back(domainId());
    localWMSrfcIds.push_back(wmSrfcId);
  }

  ScratchSpace<MInt> localNoWMImgPoints(noDomains(), AT_, "localNoWMImgPoints");
  localNoWMImgPoints.fill(0);
  ScratchSpace<MInt> localNoWMImgCoords(noDomains(), AT_, "localNoWMImgCoords");
  localNoWMImgCoords.fill(0);

  localNoWMImgPoints[domainId()] = localWMImgPointRootIds.size();

  MPI_Allgather(&localNoWMImgPoints[domainId()], 1, MPI_INT, &localNoWMImgPoints[0], 1, MPI_INT, mpiComm(), AT_,
                "localNoWMImgPoints", "localNoWMImgPoints");

  for(MInt dom = 0; dom < noDomains(); dom++) {
    localNoWMImgCoords[dom] = localNoWMImgPoints[dom] * nDim;
  }

  // sum up all imagePoints to check if there is any imgPoint to be found, otherwise there is probably something wrong
  MInt globalNoWMImgPoints = 0;
  for(MInt dom = 0; dom < noDomains(); dom++) {
    globalNoWMImgPoints += localNoWMImgPoints[dom];
  }

  if(!(globalNoWMImgPoints > 0)) {
    mTerm(-1, "No WM Image Points were found within the entire geometry! Please check if you have assigned any WM-BC "
              "in the geometry file");
  }

  std::vector<std::vector<MInt>> wmImgCellIds;
  std::vector<std::vector<MInt>> wmImgWMSrfcIds;
  std::vector<std::vector<MFloat>> wmImgCoords;

  wmImgCellIds.resize(noDomains());
  wmImgWMSrfcIds.resize(noDomains());
  wmImgCoords.resize(noDomains());

  ScratchSpace<MInt> noWMImgPointsSend(noDomains(), AT_, "noWMImgPointsSend");
  noWMImgPointsSend.fill(0);
  ScratchSpace<MInt> noWMImgPointsRecv(noDomains(), AT_, "noWMImgPointsRecv");
  noWMImgPointsRecv.fill(0);

  // now treat all domains sequentially to avoid massive allocation of memory
  MInt totalNoWMImgPointsSend = 0;
  MInt outsideImagePoints = 0;
  for(MInt dom = 0; dom < noDomains(); dom++) {
    if(localNoWMImgPoints[dom] == 0) continue; // this domain has no wmBndryCells

    // allocate temp memory to communicate the image points to every other domain
    ScratchSpace<MFloat> domWMImgCoords(nDim * localNoWMImgPoints[dom], AT_, "domWMImgCoords");
    ScratchSpace<MInt> domWMImgPointRootIds(localNoWMImgPoints[dom], AT_, "domWMImgPointRootIds");
    ScratchSpace<MInt> domWMSrfcIds(localNoWMImgPoints[dom], AT_, "domWMSrfcIds");

    if(domainId() == dom) {
      // sending domain, fill array with actual values
      for(MInt ip = 0; ip < localNoWMImgPoints[dom]; ip++) {
        for(MInt dim = 0; dim < nDim; dim++) {
          domWMImgCoords[nDim * ip + dim] = localWMImgCoords[nDim * ip + dim];
        }
        domWMImgPointRootIds[ip] = localWMImgPointRootIds[ip];
        domWMSrfcIds[ip] = localWMSrfcIds[ip];
      }
    } else {
      // receiving domain, fill with dummy values
      domWMImgCoords.fill(-9999.9999);
      domWMImgPointRootIds.fill(-1);
      domWMSrfcIds.fill(-1);
    }

    // Broadcast coordinates, rootIds and wmSrfcIds to everyone to allow searching
    MPI_Bcast(&domWMImgCoords[0], localNoWMImgCoords[dom], MPI_DOUBLE, dom, mpiComm(), AT_, "domWMImgCoords[0]");
    MPI_Bcast(&domWMImgPointRootIds[0], localNoWMImgPoints[dom], MPI_INT, dom, mpiComm(), AT_,
              "domWMImgPointRootIds[0]");
    MPI_Bcast(&domWMSrfcIds[0], localNoWMImgPoints[dom], MPI_INT, dom, mpiComm(), AT_, "domWMSrfcIds[0]");

    // now search for image points of dom in the local domain
    for(MInt ip = 0; ip < localNoWMImgPoints[dom]; ip++) {
      MFloat imgCoords[nDim];
      MInt dummyId = -1;
      for(MInt dim = 0; dim < nDim; dim++) {
        imgCoords[dim] = domWMImgCoords[nDim * ip + dim];
      }
      dummyId = grid().findContainingLeafCell(imgCoords);
      if(dummyId > -1) {
        wmImgCellIds[dom].push_back(dummyId);
        wmImgWMSrfcIds[dom].push_back(domWMSrfcIds[ip]);
        for(MInt dim = 0; dim < nDim; dim++) {
          wmImgCoords[dom].push_back(imgCoords[dim]);
        }
        if(m_wmUseInterpolation) initInterpolationForCell(dummyId);
        a_isWMImgCell(dummyId) = true;
        noWMImgPointsSend[dom]++;
        totalNoWMImgPointsSend++;
        if(dom != domainId()) outsideImagePoints++;
      }
    }

    // communicate found points to receiving domain (dom)
    MPI_Gather(&noWMImgPointsSend[dom], 1, MPI_INT, &noWMImgPointsRecv[0], 1, MPI_INT, dom, mpiComm(), AT_,
               "&noWMImgPointsSend[dom]", "noWMImgPointsRecv[0]");
  }

  MPI_Allreduce(MPI_IN_PLACE, &outsideImagePoints, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "outsideImagePoints");

  m_log << "initWMExchange() found " << outsideImagePoints << " non-local image points!";

  MInt totalNoWMImgPointsRecv = 0;
  for(MInt dom = 0; dom < noDomains(); dom++) {
    totalNoWMImgPointsRecv += noWMImgPointsRecv[dom];
  }

  // every domain now knows if it has to send or receive imgPointVars
  // we can now create a sub-communicator only containing the relevant ranks
  if(totalNoWMImgPointsRecv > 0 || totalNoWMImgPointsSend > 0) {
    MPI_Comm_split(mpiComm(), 0, 0, &m_comm_wm, AT_, "m_comm_wm");
    MPI_Comm_rank(m_comm_wm, &m_wmDomainId);
    MPI_Comm_size(m_comm_wm, &m_wmNoDomains);
  } else {
    MPI_Comm_split(mpiComm(), MPI_UNDEFINED, 0, &m_comm_wm, AT_, "m_comm_wm");
    m_wmDomainId = -1;
    m_wmNoDomains = 0;
  }

  // ranks uninvolved in the wmExchange can now return
  if(m_wmDomainId < 0) return;

  // =========================================================================
  // ===================== ONLY INVOLVED RANKS FROM HERE =====================
  // =========================================================================

  // to reduce the data structures of the imgPoints we need to map the ranks from m_comm_wm to mpiComm()
  ScratchSpace<MInt> wmIdToWorldId(m_wmNoDomains, AT_, "wmIdToWorldId");
  MInt domId = domainId();
  MPI_Allgather(&domId, 1, MPI_INT, &wmIdToWorldId[0], 1, MPI_INT, m_comm_wm, AT_, "domId", "wmIdToWorldId");

  if(totalNoWMImgPointsSend > 0) {
    mAlloc(m_wmImgSendBuffer, noPVars * totalNoWMImgPointsSend, "m_wmImgSendBuffer", 0.0, AT_);
  }

  if(totalNoWMImgPointsRecv > 0) {
    mAlloc(m_wmImgRecvBuffer, noPVars * totalNoWMImgPointsRecv, "m_wmImgPointsRecvBuffer", 0.0, AT_);
    mAlloc(m_wmImgRecvIdMap, totalNoWMImgPointsRecv, "m_wmImgRecvIdMap", -1, AT_);
  }

  m_wmImgCellIds.resize(m_wmNoDomains);
  m_wmImgWMSrfcIds.resize(m_wmNoDomains);
  m_wmImgCoords.resize(m_wmNoDomains);

  mAlloc(m_noWMImgPointsSend, m_wmNoDomains, "m_noWMImgPointsSend", 0, AT_);
  mAlloc(m_noWMImgPointsRecv, m_wmNoDomains, "m_noWMImgPointsRecv", 0, AT_);
  mAlloc(m_mpi_wmRequest, m_wmNoDomains, "m_mpi_wmRequest", AT_);
  mAlloc(m_mpi_wmSendReq, m_wmNoDomains, "m_mpi_wmSendReq", AT_);
  mAlloc(m_mpi_wmRecvReq, m_wmNoDomains, "m_mpi_wmRecvReq", AT_);

  // create reduced data structures in the order of the dedicated wm communicator
  for(MInt wmDom = 0; wmDom < m_wmNoDomains; wmDom++) {
    const MInt dom = wmIdToWorldId[wmDom];
    m_noWMImgPointsSend[wmDom] = noWMImgPointsSend[dom];
    m_noWMImgPointsRecv[wmDom] = noWMImgPointsRecv[dom];
    for(MInt ip = 0; ip < noWMImgPointsSend[dom]; ip++) {
      m_wmImgCellIds[wmDom].push_back(wmImgCellIds[dom][ip]);
      m_wmImgWMSrfcIds[wmDom].push_back(wmImgWMSrfcIds[dom][ip]);
      for(MInt dim = 0; dim < nDim; dim++) {
        m_wmImgCoords[wmDom].push_back(wmImgCoords[dom][nDim * ip + dim]);
      }
    }
  }

  // now communicate the receive map by means of the WM communicator
  for(MInt wmDom = 0; wmDom < m_wmNoDomains; wmDom++) {
    MPI_Issend(&m_wmImgWMSrfcIds[wmDom][0], m_noWMImgPointsSend[wmDom], MPI_INT, wmDom, 0, m_comm_wm,
               &m_mpi_wmRequest[wmDom], AT_, "&m_wmImgSrfcIds[wmDom][0]");
  }

  MPI_Status status;
  MInt offset = 0;
  for(MInt wmDom = 0; wmDom < m_wmNoDomains; wmDom++) {
    MPI_Recv(&m_wmImgRecvIdMap[offset], m_noWMImgPointsRecv[wmDom], MPI_INT, wmDom, 0, m_comm_wm, &status, AT_,
             "&m_wmImgRecvIdMap[offset]");
    offset += m_noWMImgPointsRecv[wmDom];
  }

  for(MInt wmDom = 0; wmDom < m_wmNoDomains; wmDom++) {
    MPI_Wait(&m_mpi_wmRequest[wmDom], &status, AT_);
  }

  // set flag in wmBndryCells that an imgCell has been found and a communication mapping has been setup correctly
  // cells without an img cell will need special treatment (return 0.0) in the wmViscosity computation.
  MInt ipCounter = 0;
  for(MInt dom = 0; dom < m_wmNoDomains; dom++) {
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for(MInt ip = 0; ip < m_noWMImgPointsRecv[dom]; ip++) {
      const MInt wmSrfcId = m_wmImgRecvIdMap[ipCounter + ip];
      m_wmSurfaces[wmSrfcId].m_wmHasImgCell = true;
    }
    ipCounter += m_noWMImgPointsRecv[dom];
  }
  m_log << "ok." << endl;
}


// only for y-normal surface
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initWMSurfaceProbes() {
  TRACE();

  // read cell coordinates from property file and find cells
  MInt noVars = 13;

  MInt noSurfaceProbes = Context::propertyLength("wmSurfaceProbesX", m_solverId);

  if(noSurfaceProbes != Context::propertyLength("wmSurfaceProbesZ", m_solverId))
    mTerm(1, "no of coordinates for WM Surface probes must be equal for X and Z");

  for(MInt p = 0; p < noSurfaceProbes; p++) {
    MFloat probeCoord[3] = {0.0, 0.0, 0.0};
    probeCoord[0] = Context::getSolverProperty<MFloat>("wmSurfaceProbesX", m_solverId, AT_, &probeCoord[0], p);
    probeCoord[2] = Context::getSolverProperty<MFloat>("wmSurfaceProbesZ", m_solverId, AT_, &probeCoord[2], p);

    for(MInt bCellId = 0; bCellId < m_bndryCells->size(); bCellId++) {
      MInt cellId = m_bndryCells->a[bCellId].m_cellId;
      MFloat cellCoord[3] = {0.0, 0.0, 0.0};
      for(MInt dim = 0; dim < nDim; dim++) {
        cellCoord[dim] = a_coordinate(cellId, dim);
      }
      if(abs(cellCoord[0] - probeCoord[0]) < F1B2 * c_cellLengthAtLevel(maxRefinementLevel()) + m_eps
         && abs(cellCoord[2] - probeCoord[2]) < F1B2 * c_cellLengthAtLevel(maxRefinementLevel()) + m_eps) {
        if(!a_isHalo(cellId)) {
          for(MInt srfc = 0; srfc < m_bndryCells->a[bCellId].m_noSrfcs; srfc++) {
            if(m_bndryCells->a[bCellId].m_srfcs[srfc]->m_bndryCndId == 3399) {
              m_wmSurfaceProbeIds.push_back(cellId);
              m_wmSurfaceProbeSrfcs.push_back(srfc);
              break;
            }
          }
        }
      }
    }
  }

  mAlloc(m_wmLocalNoSrfcProbeIds, noDomains(), "m_wmLocalNoSrfcProbeIds", 0, AT_);
  m_wmLocalNoSrfcProbeIds[domainId()] = m_wmSurfaceProbeIds.size();
  MPI_Allgather(&m_wmLocalNoSrfcProbeIds[domainId()], 1, MPI_INT, &m_wmLocalNoSrfcProbeIds[0], 1, MPI_INT, mpiComm(),
                AT_, "m_wmLocalNoSrfcProbeIds", "m_wmLocalNoSrfcProbeIds");

  m_wmGlobalNoSrfcProbeIds = 0;
  for(MInt dom = 0; dom < noDomains(); dom++) {
    m_wmGlobalNoSrfcProbeIds += m_wmLocalNoSrfcProbeIds[dom];
  }

  if(m_wmLocalNoSrfcProbeIds[domainId()] > 0) {
    mAlloc(m_wmSrfcProbeSendBuffer, noVars * m_wmLocalNoSrfcProbeIds[domainId()], "m_wmSrfcProbeSendBuffer", 0.0, AT_);
  }
  if(domainId() == 0) {
    mAlloc(m_wmSrfcProbeRecvBuffer, noVars * m_wmGlobalNoSrfcProbeIds, "m_wmSrfcProbeRecvBuffer", 0.0, AT_);
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::writeWMSurfaceProbes() {
  TRACE();

  MInt noVars = 13;

  // Computing and Gathering variables:
  for(MInt p = 0; p < m_wmLocalNoSrfcProbeIds[domainId()]; p++) {
    MInt cellId = m_wmSurfaceProbeIds[p];
    MInt srfc = m_wmSurfaceProbeSrfcs[p];
    MInt bCellId = a_bndryId(cellId);
    MInt ghostCellId = m_bndryCells->a[bCellId].m_srfcVariables[srfc]->m_ghostCellId;

    MFloat pSurface = F1B2 * (a_pvariable(cellId, PV->P) + a_pvariable(ghostCellId, PV->P));
    MFloat rhoSurface = F1B2 * (a_pvariable(cellId, PV->RHO) + a_pvariable(ghostCellId, PV->RHO));
    MFloat TSurface = sysEqn().temperature_ES(rhoSurface, pSurface);
    MFloat mue = SUTHERLANDLAW(TSurface);

    m_wmSrfcProbeSendBuffer[noVars * p + 0] = cellId;
    m_wmSrfcProbeSendBuffer[noVars * p + 1] = m_bndryCells->a[bCellId].m_srfcs[srfc]->m_coordinates[0];
    m_wmSrfcProbeSendBuffer[noVars * p + 2] = m_bndryCells->a[bCellId].m_srfcs[srfc]->m_coordinates[1];
    m_wmSrfcProbeSendBuffer[noVars * p + 3] = m_bndryCells->a[bCellId].m_srfcs[srfc]->m_coordinates[2];
    m_wmSrfcProbeSendBuffer[noVars * p + 4] = m_bndryCells->a[bCellId].m_srfcs[srfc]->m_normalVector[0];
    m_wmSrfcProbeSendBuffer[noVars * p + 5] = m_bndryCells->a[bCellId].m_srfcs[srfc]->m_normalVector[1];
    m_wmSrfcProbeSendBuffer[noVars * p + 6] = m_bndryCells->a[bCellId].m_srfcs[srfc]->m_normalVector[2];
    m_wmSrfcProbeSendBuffer[noVars * p + 7] = m_bndryCells->a[bCellId].m_srfcVariables[srfc]->m_normalDeriv[PV->VV[0]];
    m_wmSrfcProbeSendBuffer[noVars * p + 8] = m_bndryCells->a[bCellId].m_srfcVariables[srfc]->m_normalDeriv[PV->VV[1]];
    m_wmSrfcProbeSendBuffer[noVars * p + 9] = m_bndryCells->a[bCellId].m_srfcVariables[srfc]->m_normalDeriv[PV->VV[2]];
    m_wmSrfcProbeSendBuffer[noVars * p + 10] = mue;
    m_wmSrfcProbeSendBuffer[noVars * p + 11] = m_bndryCells->a[bCellId].m_wmBCVars->m_wmMUEWM;
    m_wmSrfcProbeSendBuffer[noVars * p + 12] = m_bndryCells->a[bCellId].m_wmBCVars->m_wmTauW;
  }

  // Sending variables
  MPI_Issend(&m_wmSrfcProbeSendBuffer[0], m_wmLocalNoSrfcProbeIds[domainId()] * noVars, MPI_DOUBLE, 0, 0, mpiComm(),
             &m_mpi_wmRequest[0], AT_, "&m_wmSrfcProbeSendBuffer[0]");

  // Receiving variables
  MPI_Status status;
  MInt offset = 0;
  if(domainId() == 0) {
    for(MInt dom = 0; dom < noDomains(); dom++) {
      MPI_Recv(&m_wmSrfcProbeRecvBuffer[offset], m_wmLocalNoSrfcProbeIds[dom] * noVars, MPI_DOUBLE, dom, 0, mpiComm(),
               &status, AT_, "&m_wmSrfcProbeRecvBuffer[offset]");
      offset += m_wmLocalNoSrfcProbeIds[dom] * noVars;
    }

    FILE* datei;
    stringstream filename;
    filename << outputDir() << "wmSurfaceProbes_" << globalTimeStep;
    datei = fopen(filename.str().c_str(), "w+");

    // print header
    fprintf(datei, "cellId");
    fprintf(datei, "  x");
    fprintf(datei, "  y");
    fprintf(datei, "  z");
    fprintf(datei, "  nx");
    fprintf(datei, "  ny");
    fprintf(datei, "  nz");
    fprintf(datei, "  dudn");
    fprintf(datei, "  dvdn");
    fprintf(datei, "  dwdn");
    fprintf(datei, "  mue");
    fprintf(datei, "  mue_wm");
    fprintf(datei, "  tau_wm");
    fprintf(datei, "\n");

    for(MInt p = 0; p < m_wmGlobalNoSrfcProbeIds; p++) {
      for(MInt v = 0; v < noVars; v++) {
        fprintf(datei, "%f  ", m_wmSrfcProbeRecvBuffer[p * noVars + v]);
      }
      fprintf(datei, "\n");
    }
    fclose(datei);
  }
}


//-----------------------------------------------------------------------------

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::resetRHSCutOffCells() {
  TRACE();
  const MInt noFVars = FV->noVariables;
  //---


  // reset rhs rot periodic cells (azimuthal periodicity concept)
  if(m_periodicCells == 1 || m_periodicCells == 2 || m_periodicCells == 3) {
#ifdef _OPENMP
#pragma omp parallel for collapse(2)
#endif
    for(MInt c = 0; c < m_sortedPeriodicCells->size(); c++) {
      for(MInt v = 0; v < noFVars; v++) {
        a_rightHandSide(m_sortedPeriodicCells->a[c], v) = F0;
      }
    }
  }

// reset rhs of cutoff boundary cells
#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt bcId = 0; bcId < m_fvBndryCnd->m_noCutOffBndryCndIds; bcId++) {
    const MInt noCutOffCells = m_fvBndryCnd->m_sortedCutOffCells[bcId]->size();
    for(MInt scc = 0; scc < noCutOffCells; scc++) {
      for(MInt v = 0; v < noFVars; v++) {
        a_rightHandSide(m_fvBndryCnd->m_sortedCutOffCells[bcId]->a[scc], v) = F0;
      }
    }
  }
}


// --------------------------------------------------------------------------------------


/** \brief checks if the surfaces for a cell are correct and balanced
 * The accumulated cell surfaces in +x direction must be balanced by the
 * accumulated cell surfaces in -x direction and so on. If the surfaces are
 * not balanced, the cell is loggd to the debug output
 * method is not yet extended to moving boundary computations
 *
 * \author Claudia Guenther, December 2008
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::checkCellSurfaces() {
  const MInt noCells = a_noCells();
  const MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();
  const MInt noSrfcs = a_noSurfaces();
  MFloat* area = &a_surfaceArea(0);
  MFloatScratchSpace cellSurfaceAreas(noCells, nDim, AT_, "cellSurfaceAreas");
  MInt cellId0, cellId1;
  MFloat eps = 1e-20; // allow for a small difference which can be due to roundoff errors
  stringstream filename;

  //---

  // reset
  for(MInt cellId = 0; cellId < noCells; cellId++) {
    for(MInt i = 0; i < nDim; i++) {
      cellSurfaceAreas(cellId, i) = F0;
    }
  }

  // compute the total area
  for(MInt s = 0; s < noSrfcs; s++) {
    cellId0 = a_surfaceNghbrCellId(s, 0);
    cellId1 = a_surfaceNghbrCellId(s, 1);
    if(cellId0 > noCells) continue;
    if(cellId1 > noCells) continue;
    cellSurfaceAreas(cellId0, a_surfaceOrientation(s)) += area[s];
    cellSurfaceAreas(cellId1, a_surfaceOrientation(s)) -= area[s];
  }

  //   correct surfaces which are connected to small cells
  for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
    if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId == -1) continue;
    if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId > noCells) continue;
    for(MInt dir = 0; dir < nDim; dir++) {
      cellSurfaceAreas(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId, dir) +=
          cellSurfaceAreas(m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId, dir);
      cellSurfaceAreas(m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId, dir) = F0;
    }
  }

  for(MInt cellId = 0; cellId < noCells; cellId++) {
    for(MInt dir = 0; dir < nDim; dir++) {
      // only check cells which are regular computing cells (no ghost cells, multisolver halo cells etc...) -> can be
      // extended to moving boundary active cells
      if(abs(cellSurfaceAreas(cellId, dir)) > eps && a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)
         && !a_hasProperty(cellId, SolverCell::IsPeriodicWithRot) && (!a_isBndryGhostCell(cellId))
         && (!a_hasProperty(cellId, SolverCell::IsNotGradient)) && (!a_isHalo(cellId))) {
        //                                m_log << "[" << domainId() << "]: Cell Surfaces are not balanced! " <<
        //                                endl; m_log << "[" << domainId() << "]: CellId: " << cellId << ", Area: "
        //                                << cellSurfaceAreas(cellId, dir) << ", direction:" << dir << endl; m_log <<
        //                                "["
        //                                << domainId() << "]: ... is a boundary cell:" << (a_bndryId(cellId) >
        //                                -1) << endl;
      }
    }
  }
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::copyVarsToSmallCells() {
  TRACE();

  m_fvBndryCnd->copyVarsToSmallCells();
}


// ---------------------------------------------------------------------------


/**
 * \brief computes conservative from primitive variables for given cell id
 * \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
inline void FvCartesianSolverXD<nDim_, SysEqn>::setConservativeVariables(MInt cellId) {
  const MFloat* const RESTRICT pvars = &a_pvariable(cellId, 0);
  MFloat* const RESTRICT cvars = &a_variable(cellId, 0);
  const MFloat* const RESTRICT avars = hasAV ? &a_avariable(cellId, 0) : nullptr;

  IF_CONSTEXPR(isDetChem<SysEqn>) setMeanMolarWeight_PV(cellId);

  sysEqn().computeConservativeVariables(pvars, cvars, avars);
}

template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<isEEGas<SysEqn>, _*>>
void FvCartesianSolverXD<nDim, SysEqn>::initDepthCorrection() {
  if(m_EEGas.depthCorrectionCoefficients.size() != nDim)
    mTerm(1, AT_, "depthCorrectionCoefficients initialized incorrectly!");
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    MFloat depthCorrectionValue = 0.0;
    for(MInt i = 0; i < nDim; i++) {
      const MFloat deltaH = a_coordinate(cellId, i) - m_EEGas.gravityRefCoords[i];
      depthCorrectionValue += m_EEGas.liquidDensity * m_EEGas.depthCorrectionCoefficients[i] * deltaH;
    }
    a_avariable(cellId, AV->DC) = depthCorrectionValue;
  }
}


// ---------------------------------------------------------------------------


/**
 * \fn void FvCartesianSolverXD::initNearBoundaryExchange()
 * \brief Setup the near-boundary communicator needed for the flux-redistribution method
 * \author Lennart Schneiders
 * \note Send and receive buffers are switched on purpose
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initNearBoundaryExchange(const MInt mode, const MInt offset) {
  TRACE();

  if(m_fvBndryCnd->m_cellMerging) return;

  if(noNeighborDomains() == 0 && grid().noAzimuthalNeighborDomains() == 0
     && m_azimuthalRemappedNeighborDomains.size() == 0)
    return;

#ifndef NDEBUG
  MInt test0 = 0;
  MInt test1 = 0;
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    test0 += m_noMaxLevelHaloCells[i];
    test1 += m_noMaxLevelWindowCells[i];
  }
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    test0 += m_azimuthalMaxLevelHaloCells[i].size();
    test1 += m_azimuthalMaxLevelWindowCells[i].size();
  }
  if(test0 == 0 && test1 == 0) {
    mTerm(1, AT_, "Max level exchange has not yet been initialized.");
  }
#endif

  MIntScratchSpace activeFlag(a_noCells(), AT_, "activeFlag");
  MIntScratchSpace sendBufferCnts(noNeighborDomains(), AT_, "sendBufferCnts");
  MIntScratchSpace recvBufferCnts(noNeighborDomains(), AT_, "recvBufferCnts");
  ScratchSpace<MPI_Request> sendReq(noNeighborDomains(), AT_, "sendReq");
  ScratchSpace<MPI_Request> recvReq(noNeighborDomains(), AT_, "recvReq");

  sendBufferCnts.fill(0);
  recvBufferCnts.fill(0);
  sendReq.fill(MPI_REQUEST_NULL);
  recvReq.fill(MPI_REQUEST_NULL);
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    m_fvBndryCnd->m_nearBoundaryWindowCells[i].clear();
    m_fvBndryCnd->m_nearBoundaryHaloCells[i].clear();
  }

  activeFlag.fill(0);

  setActiveFlag(activeFlag, mode, offset);

  setAdditionalActiveFlag(activeFlag);

  if(grid().azimuthalPeriodicity()) {
    initAzimuthalNearBoundaryExchange(activeFlag);
  }

  for(MInt i = 0; i < noNeighborDomains(); i++) {
    MInt sendBufferCounter = 0;
    for(MInt j = 0; j < m_noMaxLevelHaloCells[i]; j++) {
      MInt cellId = m_maxLevelHaloCells[i][j];
      m_receiveBuffers[i][sendBufferCounter] = F0;
      if(activeFlag(cellId)) {
        m_receiveBuffers[i][sendBufferCounter] = F1;
        m_fvBndryCnd->m_nearBoundaryHaloCells[i].push_back(cellId);
        if(a_hasProperty(cellId, SolverCell::IsSplitCell)) {
          for(MUint sc = 0; sc < m_splitCells.size(); sc++) {
            if(cellId != m_splitCells[sc]) continue;
            for(MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) {
              m_fvBndryCnd->m_nearBoundaryHaloCells[i].push_back(m_splitChilds[sc][ssc]);
            }
          }
        }
      }
      sendBufferCounter++;
    }
    ASSERT(sendBufferCounter == m_noMaxLevelHaloCells[i], "");
    sendBufferCnts(i) = sendBufferCounter;
    recvBufferCnts(i) = m_noMaxLevelWindowCells[i];
  }

  if(noNeighborDomains() > 0) {
    if(m_nonBlockingComm) {
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        ASSERT(recvBufferCnts(i) <= m_noMaxLevelWindowCells[i] * m_dataBlockSize, "");
        MPI_Irecv(m_sendBuffers[i], recvBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 2, mpiComm(), &recvReq[i], AT_,
                  "m_sendBuffers[i]");
      }
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        ASSERT(sendBufferCnts(i) <= m_noMaxLevelHaloCells[i] * m_dataBlockSize, "");
        MPI_Isend(m_receiveBuffers[i], sendBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 2, mpiComm(), &sendReq[i], AT_,
                  "m_receiveBuffers[i]");
      }
      MPI_Waitall(noNeighborDomains(), &recvReq[0], MPI_STATUSES_IGNORE, AT_);
      MPI_Waitall(noNeighborDomains(), &sendReq[0], MPI_STATUSES_IGNORE, AT_);
    } else {
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        ASSERT(sendBufferCnts(i) <= m_noMaxLevelHaloCells[i] * m_dataBlockSize, "");
        MPI_Issend(m_receiveBuffers[i], sendBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 2, mpiComm(), &sendReq[i],
                   AT_, "m_receiveBuffers[i]");
      }
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        ASSERT(recvBufferCnts(i) <= m_noMaxLevelWindowCells[i] * m_dataBlockSize, "");
        MPI_Recv(m_sendBuffers[i], recvBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 2, mpiComm(), MPI_STATUS_IGNORE,
                 AT_, "m_sendBuffers[i]");
      }
      MPI_Waitall(noNeighborDomains(), &sendReq[0], MPI_STATUSES_IGNORE, AT_);
    }

    for(MInt i = 0; i < noNeighborDomains(); i++) {
      MInt recvBufferCounter = 0;
      for(MInt j = 0; j < m_noMaxLevelWindowCells[i]; j++) {
        MInt cellId = m_maxLevelWindowCells[i][j];
        if((MInt)m_sendBuffers[i][recvBufferCounter]) {
          m_fvBndryCnd->m_nearBoundaryWindowCells[i].push_back(cellId);
          ASSERT(c_noChildren(cellId) == 0, "");
          if(a_hasProperty(cellId, SolverCell::IsSplitCell)) {
            for(MUint sc = 0; sc < m_splitCells.size(); sc++) {
              if(cellId != m_splitCells[sc]) continue;
              for(MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) {
                m_fvBndryCnd->m_nearBoundaryWindowCells[i].push_back(m_splitChilds[sc][ssc]);
              }
            }
          }
        }
        recvBufferCounter++;
      }
    }
  }


#ifdef _MB_DEBUG_
  if(globalTimeStep % 100 == 0) {
    MLong totalMaxLevelHaloCells = 0;
    MLong totalMaxLevelWindowCells = 0;
    MLong totalNearBoundaryHaloCells = 0;
    MLong totalNearBoundaryWindowCells = 0;
    m_log << "Near-boundary exchange size:" << endl;
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      m_log << "D" << neighborDomain(i) << ":"
            << " " << m_fvBndryCnd->m_nearBoundaryWindowCells[i].size() << "/" << m_noMaxLevelWindowCells[i] << " "
            << m_fvBndryCnd->m_nearBoundaryHaloCells[i].size() << "/" << m_noMaxLevelHaloCells[i] << endl;
      totalMaxLevelHaloCells += m_noMaxLevelHaloCells[i];
      totalMaxLevelWindowCells += m_noMaxLevelWindowCells[i];
      totalNearBoundaryHaloCells += (signed)m_fvBndryCnd->m_nearBoundaryHaloCells[i].size();
      totalNearBoundaryWindowCells += (signed)m_fvBndryCnd->m_nearBoundaryWindowCells[i].size();
    }
    MPI_Allreduce(MPI_IN_PLACE, &totalMaxLevelHaloCells, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "totalMaxLevelHaloCells");
    MPI_Allreduce(MPI_IN_PLACE, &totalMaxLevelWindowCells, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "totalMaxLevelWindowCells");
    MPI_Allreduce(MPI_IN_PLACE, &totalNearBoundaryHaloCells, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "totalNearBoundaryHaloCells");
    MPI_Allreduce(MPI_IN_PLACE, &totalNearBoundaryWindowCells, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "totalNearBoundaryWindowCells");
    m_log << "Global near-boundary exchange size: " << totalNearBoundaryWindowCells << "/" << totalMaxLevelWindowCells
          << " (" << 100.0 * ((MFloat)totalNearBoundaryWindowCells / (MFloat)totalMaxLevelWindowCells) << "%)"
          << " - " << totalNearBoundaryHaloCells << "/" << totalMaxLevelHaloCells << " ("
          << 100.0 * ((MFloat)totalNearBoundaryHaloCells / (MFloat)totalMaxLevelHaloCells) << "%)" << endl;
  }
#endif
}


/** \brief Set the flag for the cells needed for near bndry exchange
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setActiveFlag(MIntScratchSpace& activeFlag, const MInt mode,
                                                       const MInt offset) {
  TRACE();

  for(MInt bndryId = 0; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    // maxLevelChange!
    const MFloat vfrac = a_cellVolume(cellId) / grid().cellVolumeAtLevel(maxLevel());
    MBool atWall = false;
    for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      if(m_fvBndryCnd->m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId / 1000 == 3) atWall = true;
    }
    const MFloat volumeLimit = atWall ? m_fvBndryCnd->m_volumeLimitWall : m_fvBndryCnd->m_volumeLimitOther;
    if(mode == 0 && vfrac > volumeLimit) continue;
    if(mode == 1 && bndryId < offset && vfrac > volumeLimit) continue;
    activeFlag(cellId) = 1;
    const MInt noSrfcs = m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs;
    const MUint noRecNghbrs = m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.size();
    for(MUint n = noSrfcs; n < noRecNghbrs; n++) {
      MInt nghbrId = m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n];
      if(nghbrId < 0) continue;
      activeFlag(nghbrId) = 1;
      if(a_hasProperty(nghbrId, SolverCell::IsSplitChild)) {
        activeFlag(getAssociatedInternalCell(nghbrId)) = 1;
      }
    }
    if(!a_hasProperty(cellId, SolverCell::IsSplitChild) && !a_hasProperty(cellId, SolverCell::IsSplitClone)) {
      for(MInt dir = 0; dir < m_noDirs; dir++) {
        if(checkNeighborActive(cellId, dir) && a_hasNeighbor(cellId, dir)) {
          activeFlag(c_neighborId(cellId, dir)) = 1;
        }
      }
    }
  }
}


// ---------------------------------------------------------------------------


#ifndef NDEBUG
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::divCheck(MInt x) {
  MBool solutionDiverged = false;
  const MInt noCVars = CV->noVariables;

  for(MInt i = 0; i < noNeighborDomains(); i++) {
    if(m_fvBndryCnd->m_nearBoundaryHaloCells[i].empty()) {
      continue;
    }
    for(MUint j = 0; j < m_fvBndryCnd->m_nearBoundaryHaloCells[i].size(); j++) {
      MInt cellId = m_fvBndryCnd->m_nearBoundaryHaloCells[i][j];
      const MInt rootId =
          (a_hasProperty(cellId, SolverCell::IsSplitChild)) ? getAssociatedInternalCell(cellId) : cellId;
      IF_CONSTEXPR(!isEEGas<SysEqn>) {
        for(MInt v = 0; v < noCVars; v++) {
          if(!(a_variable(cellId, v) >= F0 || a_variable(cellId, v) < F0) || std::isnan(a_variable(cellId, v))) {
            cerr << domainId() << ": EXC1 " << i << " " << j << " " << c_globalId(cellId) << " " << a_bndryId(cellId)
                 << " " << a_level(cellId) << " /v " << a_cellVolume(cellId) / grid().gridCellVolume(a_level(rootId))
                 << " "
                 << (a_bndryId(cellId) > -1 ? m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_volume
                                                  / grid().gridCellVolume(a_level(rootId))
                                            : 99999)
                 << " " << v << " " << a_variable(cellId, v) << " " << a_coordinate(cellId, 0) << " "
                 << a_coordinate(cellId, 1) << " " << a_coordinate(cellId, nDim - 1) << " "
                 << a_hasProperty(cellId, SolverCell::IsSplitChild) << " "
                 << a_hasProperty(cellId, SolverCell::IsSplitCell) << endl;
            solutionDiverged = true;
          }
        }
      }
      if(a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId)) > m_fvBndryCnd->m_volumeLimitWall) {
        setPrimitiveVariables(cellId);
        if(a_pvariable(cellId, PV->RHO) < F0 || a_pvariable(cellId, PV->P) < F0) {
          cerr << domainId() << ": EXC1 " << i << " " << j << " " << c_globalId(cellId) << " " << a_bndryId(cellId)
               << " " << a_level(cellId) << " /r " << a_pvariable(cellId, PV->RHO) << " /p "
               << a_pvariable(cellId, PV->P) << " /v " << a_cellVolume(cellId) / grid().gridCellVolume(a_level(rootId))
               << " "
               << (a_bndryId(cellId) > -1 ? m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_volume
                                                / grid().gridCellVolume(a_level(rootId))
                                          : 99999)
               << " " << a_coordinate(cellId, 0) << " " << a_coordinate(cellId, 1) << " "
               << a_coordinate(cellId, nDim - 1) << " " << a_hasProperty(cellId, SolverCell::IsSplitChild) << " "
               << a_hasProperty(cellId, SolverCell::IsSplitCell) << endl;
          cerr << " vel " << a_pvariable(cellId, PV->VV[0]) << " " << a_pvariable(cellId, PV->VV[1]) << " "
               << a_pvariable(cellId, PV->VV[nDim - 1]) << endl;
          solutionDiverged = true;
        }
      }
    }
  }

  if(grid().azimuthalPeriodicity()) {
    for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
      if(m_fvBndryCnd->m_azimuthalNearBoundaryHaloCells[i].empty()) {
        continue;
      }
      for(MUint j = 0; j < m_fvBndryCnd->m_azimuthalNearBoundaryHaloCells[i].size(); j++) {
        MInt cellId = m_fvBndryCnd->m_azimuthalNearBoundaryHaloCells[i][j];
        const MInt rootId =
            (a_hasProperty(cellId, SolverCell::IsSplitChild)) ? getAssociatedInternalCell(cellId) : cellId;
        for(MInt v = 0; v < noCVars; v++) {
          if(!(a_variable(cellId, v) >= F0 || a_variable(cellId, v) < F0) || std::isnan(a_variable(cellId, v))) {
            cerr << domainId() << ": EXC1 Azi " << i << " " << j << " " << c_globalId(cellId) << " "
                 << a_bndryId(cellId) << " " << a_level(cellId) << " /v "
                 << a_cellVolume(cellId) / grid().gridCellVolume(a_level(rootId)) << " "
                 << (a_bndryId(cellId) > -1 ? m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_volume
                                                  / grid().gridCellVolume(a_level(rootId))
                                            : 99999)
                 << " " << v << " " << a_variable(cellId, v) << " " << a_coordinate(cellId, 0) << " "
                 << a_coordinate(cellId, 1) << " " << a_coordinate(cellId, nDim - 1) << " "
                 << a_hasProperty(cellId, SolverCell::IsSplitChild) << " "
                 << a_hasProperty(cellId, SolverCell::IsSplitCell) << endl;
            solutionDiverged = true;
          }
        }
        if(a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId)) > m_fvBndryCnd->m_volumeLimitWall) {
          setPrimitiveVariables(cellId);
          if(a_pvariable(cellId, m_sysEqn.PV->RHO) < F0 || a_pvariable(cellId, m_sysEqn.PV->P) < F0) {
            cerr << domainId() << ": EXC1 Azi " << i << " " << j << " " << c_globalId(cellId) << " "
                 << a_bndryId(cellId) << " " << a_level(cellId) << " /r " << a_pvariable(cellId, m_sysEqn.PV->RHO)
                 << " /p " << a_pvariable(cellId, m_sysEqn.PV->P) << " /v "
                 << a_cellVolume(cellId) / grid().gridCellVolume(a_level(rootId)) << " "
                 << (a_bndryId(cellId) > -1 ? m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_volume
                                                  / grid().gridCellVolume(a_level(rootId))
                                            : 99999)
                 << " " << a_coordinate(cellId, 0) << " " << a_coordinate(cellId, 1) << " "
                 << a_coordinate(cellId, nDim - 1) << " " << a_hasProperty(cellId, SolverCell::IsSplitChild) << " "
                 << a_hasProperty(cellId, SolverCell::IsSplitCell) << endl;
            cerr << " vel " << a_pvariable(cellId, m_sysEqn.PV->VV[0]) << " " << a_pvariable(cellId, m_sysEqn.PV->VV[1])
                 << " " << a_pvariable(cellId, m_sysEqn.PV->VV[nDim - 1]) << endl;
            solutionDiverged = true;
          }
        }
      }
    }
  }
  if(solutionDiverged) {
    cerr << "Solution diverged (BEXC" << x << ") at solver " << domainId() << " " << globalTimeStep << " " << m_RKStep
         << endl;
  }
  if(noDomains() > 1) {
    // Convert data to MInt before MPI call and copy back afterwards
    MInt tmp = solutionDiverged;
    MPI_Allreduce(MPI_IN_PLACE, &tmp, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "tmp");
    solutionDiverged = tmp;
  }
  if(solutionDiverged) {
    saveSolverSolution(1);
    MPI_Barrier(mpiComm(), AT_);
    mTerm(1, AT_, "Solution diverged after near boundary exchange.");
  }
}
#endif

/**
 * \fn void FvCartesianSolverXD::smallCellCorrection()
 * \brief Flux-redistribution method
 *         Apply a stable correction to small-cells and redistribute the defective
 *         flux to neighboring cells to re-establish conservation
 *         For details see Schneiders,Hartmann,Meinke,Schrder, J.Comput.Phys. 235 (2013)
 *         For more details see the dissertation of Lennart Schneiders, "Particle-Resolved
 *         Analysis of Turbulent Multiphase Flow by a Cut-Cell Method" Chapter 3.4
 * \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::smallCellCorrection(const MInt /*timerId*/) {
  TRACE();

  if(m_fvBndryCnd->m_cellMerging || m_fvBndryCnd->m_smallCellRHSCorrection) {
    return;
  }

  RECORD_TIMER_START(m_timers[Timers::SCCorrInit]);

  // Claudia Note: Hier pruefen! -> TINA transient braucht ab und zu conservation = false um weiterzulaufen (kleine
  // Ventilspalte)
  const MBool conservation = (m_RKStep == 0);
  // the final Runge-Kutta step is sufficient to maintain conservation, however, steady-state
  // solutions are then dependent on the time step size! (Lennart)
  const MInt noSmallCells = (signed)m_fvBndryCnd->m_smallCutCells.size();
  const MInt noCVars = CV->noVariables;
  const MInt noPVars = PV->noVariables;
  const MInt noAVars = AV->noVariables;
  const MInt volFactor = nDim == 3 ? 4 : 2;

  MFloatScratchSpace redistFac(noSmallCells, AT_, "redistFac");
  MFloatScratchSpace delta(noSmallCells, noCVars, AT_, "delta");
  MIntScratchSpace sendBufferCnts(mMax(1, noNeighborDomains()), AT_, "sendBufferCnts");
  MIntScratchSpace recvBufferCnts(mMax(1, noNeighborDomains()), AT_, "recvBufferCnts");
  ScratchSpace<MPI_Request> sendReq(mMax(1, noNeighborDomains()), AT_, "sendReq");
  ScratchSpace<MPI_Request> recvReq(mMax(1, noNeighborDomains()), AT_, "recvReq");

  //-------------

  // 0. Init
  redistFac.fill(F0);
  delta.fill(F0);

  RECORD_TIMER_STOP(m_timers[Timers::SCCorrInit]);
  RECORD_TIMER_START(m_timers[Timers::SCCorrExchange1]);

  // azimuthal periodicity concept
  if(m_periodicCells == 2 || m_periodicCells == 3) {
    computePV();
    exchangePeriodic();
  }

  // 2. Request conservative variables of involved halo cells
  {
    sendReq.fill(MPI_REQUEST_NULL);
    recvReq.fill(MPI_REQUEST_NULL);
    sendBufferCnts.fill(0);
    recvBufferCnts.fill(0);
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      sendBufferCnts(i) = noCVars * (signed)m_fvBndryCnd->m_nearBoundaryWindowCells[i].size();
      recvBufferCnts(i) = noCVars * (signed)m_fvBndryCnd->m_nearBoundaryHaloCells[i].size();
      if(m_fvBndryCnd->m_nearBoundaryWindowCells[i].empty()) continue;
      MInt sendBufferCounter = 0;
      for(MUint j = 0; j < m_fvBndryCnd->m_nearBoundaryWindowCells[i].size(); j++) {
        MInt cellId = m_fvBndryCnd->m_nearBoundaryWindowCells[i][j];
        for(MInt v = 0; v < noCVars; v++) {
          m_sendBuffers[i][sendBufferCounter] = a_variable(cellId, v);
          sendBufferCounter++;
        }
      }
    }

    MInt sendCnt = 0;
    MInt recvCnt = 0;
    if(m_nonBlockingComm) {
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(sendBufferCnts(i) == 0) continue;
        ASSERT(sendBufferCnts(i) <= m_noMaxLevelWindowCells[i] * m_dataBlockSize, "");
        MPI_Isend(m_sendBuffers[i], sendBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 12, mpiComm(), &sendReq[sendCnt],
                  AT_, "m_sendBuffers[i]");
        sendCnt++;
      }
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(recvBufferCnts(i) == 0) continue;
        ASSERT(recvBufferCnts(i) <= m_noMaxLevelHaloCells[i] * m_dataBlockSize, "");
        MPI_Irecv(m_receiveBuffers[i], recvBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 12, mpiComm(),
                  &recvReq[recvCnt], AT_, "m_receiveBuffers[i]");
        recvCnt++;
      }
      RECORD_TIMER_START(m_timers[Timers::SCCorrExchange1Wait]);
      if(recvCnt > 0) MPI_Waitall(recvCnt, &recvReq[0], MPI_STATUSES_IGNORE, AT_);
      RECORD_TIMER_STOP(m_timers[Timers::SCCorrExchange1Wait]);
    } else {
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(sendBufferCnts(i) == 0) continue;
        ASSERT(sendBufferCnts(i) <= m_noMaxLevelWindowCells[i] * m_dataBlockSize, "");
        MPI_Issend(m_sendBuffers[i], sendBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 12, mpiComm(), &sendReq[sendCnt],
                   AT_, "m_sendBuffers[i]");
        sendCnt++;
      }
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(recvBufferCnts(i) == 0) continue;
        ASSERT(recvBufferCnts(i) <= m_noMaxLevelHaloCells[i] * m_dataBlockSize, "");
        RECORD_TIMER_START(m_timers[Timers::SCCorrExchange1Wait]);
        MPI_Recv(m_receiveBuffers[i], recvBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 12, mpiComm(),
                 MPI_STATUS_IGNORE, AT_, "m_receiveBuffers[i]");
        RECORD_TIMER_STOP(m_timers[Timers::SCCorrExchange1Wait]);
        recvCnt++;
      }
    }
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_fvBndryCnd->m_nearBoundaryHaloCells[i].empty()) continue;
      MInt recvBufferCounter = 0;
      for(MUint j = 0; j < m_fvBndryCnd->m_nearBoundaryHaloCells[i].size(); j++) {
        MInt cellId = m_fvBndryCnd->m_nearBoundaryHaloCells[i][j];
        for(MInt v = 0; v < noCVars; v++) {
          a_variable(cellId, v) = m_receiveBuffers[i][recvBufferCounter];
          recvBufferCounter++;
        }
      }
    }
    RECORD_TIMER_START(m_timers[Timers::SCCorrExchange1Wait]);
    if(sendCnt > 0) MPI_Waitall(sendCnt, &sendReq[0], MPI_STATUSES_IGNORE, AT_);
    RECORD_TIMER_STOP(m_timers[Timers::SCCorrExchange1Wait]);

    if(grid().azimuthalPeriodicity()) {
      azimuthalNearBoundaryExchange();
    }


#ifndef NDEBUG
    divCheck(1);
#endif
  }

  RECORD_TIMER_STOP(m_timers[Timers::SCCorrExchange1]);
  RECORD_TIMER_START(m_timers[Timers::SCCorrInterp]);

  // 3. Compute stable update for internal small cells
#if !defined NDEBUG || defined _MB_DEBUG_
  MInt nanCnt = 0;
#endif

  //  doesnot work correctly with openmp
  // 0) Compute the volume-sum for all reconstruction-neighbors of the small-cell
  for(MInt smallc = 0; smallc < noSmallCells; smallc++) {
    const MInt bndryId = m_fvBndryCnd->m_smallCutCells[(unsigned)smallc];
    ASSERT(std::count(m_fvBndryCnd->m_smallCutCells.begin(), m_fvBndryCnd->m_smallCutCells.end(), bndryId) == 1, "");
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_isPeriodic(cellId)) {
      continue;
    }
    if(a_isHalo(cellId)) {
      continue;
    }
    if(a_hasProperty(cellId, SolverCell::IsPeriodicWithRot)) {
      continue;
    }
    // correct for cbc cutOff cells!
    if(a_hasProperty(cellId, SolverCell::IsCutOff) && !m_fvBndryCnd->m_cbcSmallCellCorrection) continue;

    const MInt noSrfcs = m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs;
    const MUint noRecNghbrs = m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.size();
    if(noRecNghbrs == 0) {
      cerr << domainId() << ": Warning: no reconstruction posible in small cell " << cellId << endl;
      continue;
    }
    MFloat sum = F0;
    // MFloat sum0 = F0;
    for(MUint n = (unsigned)noSrfcs + 1; n < noRecNghbrs; n++) {
      const MInt nghbrId = m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n];
      if(nghbrId < 0) {
        continue;
      }
      // consider volume of cbc cutOff cells
      if(a_hasProperty(nghbrId, SolverCell::IsCutOff) && !m_fvBndryCnd->m_cbcSmallCellCorrection) continue;
      // for a smallcell cbc cutOff cell, all corresponding noncutOff cells
      // should be skipped for interpolation!

      // MFloat dx = F0;
      // for ( MInt i = 0; i < nDim; i++ ) {
      //  dx += POW2( a_coordinate( nghbrId ,  i ) - a_coordinate( cellId ,  i ) );
      //}
      // sum0 += a_cellVolume( nghbrId );
      sum += a_cellVolume(nghbrId); // * RBF( dx, POW2( cellLength[ a_level(cellId) ] ) ) ;
    }
    //     if ( sum0 < F1B2* grid().gridCellVolume( a_level(cellId) ) ) cerr << "Warning: redistribution small vol. " <<
    //     cellId
    //     << " " << sum0/ grid().gridCellVolume( a_level(cellId) ) << endl;
    for(auto n = (unsigned)noSrfcs; n < noRecNghbrs; n++) {
      setPrimitiveVariables(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n]);
    }

    MFloatScratchSpace pvars(noPVars, AT_, "pvars");
    for(MInt v = 0; v < noPVars; v++) {
      pvars[v] = F0;
      MInt stencil = 0;
      for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
        const MInt bc = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[v];

        if(bc != BC_DIRICHLET) {
          stencil += IPOW2(srfc);
        }

        switch(bc) {
          case BC_DIRICHLET:
            a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[srfc],
                        v) =
                m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[v]; // set the dummy vars
            break;
          case BC_NEUMANN:
            a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[srfc],
                        v) =
                m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[v]; // set the dummy vars
            break;
          case BC_ROBIN:
          case BC_ISOTHERMAL:
            a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[srfc],
                        v) = F0; // m_fvBndryCnd->m_bndryCell[ bndryId ].m_srfcVariables[srfc]->m_normalDeriv[v]; //set
                                 // the dummy vars
            break;
          case BC_UNSET:
          default:
            mTerm(1, AT_,
                  "Invalid BC type in FvCartesianSolverXD::smallCellCorrection(). "
                      + to_string(m_fvBndryCnd->m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId) + " "
                      + to_string(cellId) + " " + to_string(noSrfcs));
        }
      }
      pvars[v] = F0;
      for(MUint n = 0; n < noRecNghbrs; n++) {
        if(fabs(m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * n + stencil]) > m_eps) {
          pvars[v] += m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * n + stencil]
                      * a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n], v);


#if !defined NDEBUG || defined _MB_DEBUG_
          if(nanCnt < 100
             && (std::isnan(m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * n + stencil])
                 || std::isnan(a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n], v)))) {
            cerr << domainId() << ": "
                 << " nan detected in smallCellCorrection " << globalTimeStep << "/" << m_RKStep << " "
                 << " " << cellId << "(" << c_globalId(cellId) << ")"
                 << " " << n << "/" << noRecNghbrs << " " << v << " " << stencil << " "
                 << m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n] << "("
                 << c_globalId(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n]) << ")"
                 << " " << m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * n + stencil] << " "
                 << a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n], v) << " "
                 << a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId)) << " "
                 << a_cellVolume(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n])
                        / grid().gridCellVolume(a_level(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n]))
                 << endl;
            nanCnt++;
            if(nanCnt == 100) cerr << domainId() << ": More than 100 nan's, not reporting any more." << endl;
          }
#endif
        }
      }
    }


    //====================
    // labels:FV EULER hack
    if(m_fvBndryCnd->m_bndryCell[bndryId].m_srfcs[0]->m_bndryCndId == 3007) {
      MFloat pvars2[5];
      for(MInt i = 0; i < nDim; i++) {
        MInt stencil = 1;
        for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
          a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[srfc], PV->VV[i]) = F0;
        }
        pvars2[PV->VV[i]] = F0;
        for(MUint n = 0; n < noRecNghbrs; n++) {
          pvars2[PV->VV[i]] += m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * n + stencil]
                               * a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n], PV->VV[i]);
        }
      }
      MFloat vel[3];
      for(MInt i = 0; i < nDim; i++) {
        vel[i] = pvars2[PV->VV[i]];
        for(MInt j = 0; j < nDim; j++) {
          vel[i] += m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i] * (pvars[PV->VV[j]] - pvars2[PV->VV[j]])
                    * m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[j];
        }
      }
      for(MInt i = 0; i < nDim; i++) {
        pvars[PV->VV[i]] = vel[i];
      }
    }
    if(m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_variablesType[PV->RHO] == BC_ISOTHERMAL) {
      MInt stencil = 0;
      for(MInt v = 0; v < noPVars; v++) {
        for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
          a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[srfc], v) =
              m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[v];
        }
      }
      MFloat Tc = F0;
      for(MUint n = 0; n < noRecNghbrs; n++) {
        if(fabs(m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * n + stencil]) > m_eps) {
          MFloat Tn = F0;
          IF_CONSTEXPR(isDetChem<SysEqn>) {
            Tn = a_avariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n], AV->W_MEAN)
                 * a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n], PV->P)
                 / (a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n], PV->RHO) * m_gasConstant);
          }
          else {
            Tn = sysEqn().temperature_ES(a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n], PV->RHO),
                                         a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n], PV->P));
          }
          // if ( (signed)n < noSrfcs ) Tn = m_bodyTemperature[
          // m_internalBodyId[m_bndryCells->a[bndryId].m_srfcs[n]->m_bodyId[0]] ];
          Tc += m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * n + stencil] * Tn;
        }
      }

      IF_CONSTEXPR(isDetChem<SysEqn>) {
        MFloatScratchSpace avars(noAVars, AT_, "avars");
        avars[AV->W_MEAN] = [&] {
          MFloat fRecMeanMolarWeight = F0;
          for(MUint s = 0; s < PV->m_noSpecies; ++s) {
            fRecMeanMolarWeight += pvars[PV->Y[s]] * sysEqn().m_species->fMolarMass[s];
          }
          const MFloat recMeanMolarWeight = F1 / fRecMeanMolarWeight;
          return recMeanMolarWeight;
        }();
        pvars[PV->RHO] = avars[AV->W_MEAN] * pvars[PV->P] / (Tc * m_gasConstant);
      }
      else {
        pvars[PV->RHO] = sysEqn().density_ES(pvars[PV->P], Tc);
      }


    } else if(m_fvBndryCnd->m_bndryCell[bndryId].m_srfcs[0]->m_bndryCndId == 3067) {
      MBool& first = m_static_smallCellCorrection_first;
      MInt& slipDirection = m_static_smallCellCorrection_slipDirection;
      MFloat& slipCoordinate = m_static_smallCellCorrection_slipCoordinate;

      // TODO labels:FV,DOC cleanup this mess!
      /*! \page propertiesFV
         \section slipDirection
         <code>MFloat FvBndryCnd::slipDirection</code>\n
         default: <code>none</code>  \n \n
         Changes the direction of your underwear \n
         Possible values are:
         <ul>
         <li> inside, outside, upside down, on your head </li>
         </ul>
         Keywords: <i>FINITE_VOLUME, BOUNDARY CONDITION, Dolce and Gabana, Gucci, Victoria Secret </i>
       */
      if(first) {
        first = false;
        slipDirection = Context::getSolverProperty<MInt>("slipDirection", m_solverId, AT_);
        slipCoordinate = Context::getSolverProperty<MFloat>("slipCoordinate", m_solverId, AT_);
      }
      MInt slipDim = slipDirection / 2;
      MFloat slipSign = F1;
      if(slipDirection % 2 == 1) {
        slipSign = -F1;
      }

      if((a_coordinate(cellId, slipDim) - slipCoordinate) * slipSign < F0) {
        MFloat pvars2[5];
        for(MInt i = 0; i < nDim; i++) {
          MInt stencil = 1;
          for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
            a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[srfc], PV->VV[i]) = F0;
          }
          pvars2[PV->VV[i]] = F0;
          for(MUint n = 0; n < noRecNghbrs; n++) {
            pvars2[PV->VV[i]] += m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * n + stencil]
                                 * a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n], PV->VV[i]);
          }
        }
        MFloat vel[3];
        for(MInt i = 0; i < nDim; i++) {
          vel[i] = pvars2[PV->VV[i]];
          for(MInt j = 0; j < nDim; j++) {
            vel[i] += m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i] * (pvars[PV->VV[j]] - pvars2[PV->VV[j]])
                      * m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[j];
          }
        }
        for(MInt i = 0; i < nDim; i++) {
          pvars[PV->VV[i]] = vel[i];
        }
      }
    }
    //====================
    MFloatScratchSpace cvars(noCVars, AT_, "cvars");
    MFloatScratchSpace avars(noAVars, AT_, "avars");
    IF_CONSTEXPR(isDetChem<SysEqn>) {
      // Only meanMolarMass is needed
      avars[AV->W_MEAN] = [&] {
        MFloat fRecMeanMolarWeight = F0;
        for(MUint s = 0; s < PV->m_noSpecies; ++s) {
          fRecMeanMolarWeight += pvars[PV->Y[s]] * sysEqn().m_species->fMolarMass[s];
        }
        const MFloat recMeanMolarWeight = F1 / fRecMeanMolarWeight;
        return recMeanMolarWeight;
      }();
    }

    // Avoid passing zero-sized vector
    sysEqn().computeConservativeVariables(&pvars[0], &cvars[0], isDetChem<SysEqn> ? &avars[0] : nullptr);

    ASSERT(maxLevel() >= maxUniformRefinementLevel() && maxLevel() <= maxRefinementLevel(), "");

    // commented version also applies smallCellCorrection for cutCells on lower levels, however
    // they only need to be stabilised if their volume falls below the threshold of the fines cells!
    // maxLevelChange
    MFloat vfrac = a_cellVolume(cellId) / grid().gridCellVolume(maxLevel());
    MFloat volumeLimit = m_fvBndryCnd->m_volumeLimitWall;

    if(a_level(cellId) < maxLevel() && m_bndryLevelJumps) {
      volumeLimit = volumeLimit * volFactor * (maxLevel() - a_level(cellId));
    }
    if(m_localTS) {
      vfrac = a_cellVolume(cellId) / c_cellVolumeAtLevel(a_level(cellId));
    }

    const MFloat fac = maia::math::deltaFun(vfrac, 1e-8, volumeLimit);

    for(MInt v = 0; v < noCVars; v++) {
      // if ( fabs(a_variable( cellId ,  v )) < 1e-12 ) continue;
      delta(smallc, v) = (F1 - fac) * (cvars[v] - a_variable(cellId, v));
    }
    redistFac(smallc) = a_cellVolume(cellId) / sum;
  }

  RECORD_TIMER_STOP(m_timers[Timers::SCCorrInterp]);
  RECORD_TIMER_START(m_timers[Timers::SCCorrRedist]);

  // 4. Reset buffer for flux redistribution over domain boundaries
  if(conservation) {
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_fvBndryCnd->m_nearBoundaryHaloCells[i].empty()) continue;
      for(MUint j = 0; j < m_fvBndryCnd->m_nearBoundaryHaloCells[i].size(); j++) {
        MInt cellId = m_fvBndryCnd->m_nearBoundaryHaloCells[i][j];
        for(MInt v = 0; v < noCVars; v++) {
          a_variable(cellId, v) = F0;
        }
      }
    }

    if(grid().azimuthalPeriodicity()) {
      for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
        for(MUint j = 0; j < m_fvBndryCnd->m_azimuthalNearBoundaryHaloCells[i].size(); j++) {
          MInt cellId = m_fvBndryCnd->m_azimuthalNearBoundaryHaloCells[i][j];
          for(MInt v = 0; v < noCVars; v++) {
            a_variable(cellId, v) = F0;
          }
        }
      }
      for(MUint i = 0; i < m_azimuthalRemappedNeighborDomains.size(); i++) {
        for(MUint j = 0; j < m_azimuthalRemappedHaloCells[i].size(); j++) {
          MInt cellId = m_azimuthalRemappedHaloCells[i][j];
          for(MInt v = 0; v < noCVars; v++) {
            a_variable(cellId, v) = F0;
          }
        }
      }
    }
  }

  // azimuthal periodicity concept
  if(conservation && (m_periodicCells == 2 || m_periodicCells == 3)) {
    // reset periodic cells
    for(MInt c = 0; c < m_sortedPeriodicCells->size(); c++) {
      a_variable(m_sortedPeriodicCells->a[c], CV->RHO) = F0;
      IF_CONSTEXPR(hasE<SysEqn>)
      a_variable(m_sortedPeriodicCells->a[c], CV->RHO_E) = F0;
      a_variable(m_sortedPeriodicCells->a[c], CV->RHO_U) = F0;
      a_variable(m_sortedPeriodicCells->a[c], CV->RHO_V) = F0;
      a_variable(m_sortedPeriodicCells->a[c], CV->RHO_W) = F0;

      IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
        for(MInt r = 0; r < m_noRansEquations; r++) {
          a_variable(m_sortedPeriodicCells->a[c], CV->RHO_NN[r]) = F0;
        }
      }
    }
  }

  // 5. Apply stable update to internal small cells
  for(MInt smallc = 0; smallc < noSmallCells; smallc++) {
    const MInt bndryId = m_fvBndryCnd->m_smallCutCells[(unsigned)smallc];
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_isPeriodic(cellId)) continue;
    if(a_isHalo(cellId)) continue;
    if(a_hasProperty(cellId, SolverCell::IsPeriodicWithRot)) continue;
    // stabilize small cbc cutOff cells!
    if(a_hasProperty(cellId, SolverCell::IsCutOff) && !m_fvBndryCnd->m_cbcSmallCellCorrection) continue;

    for(MInt v = 0; v < noCVars; v++) {
      a_variable(cellId, v) += delta(smallc, v);
      // a_rightHandSide( cellId ,  v ) = a_cellVolume( cellId ) * ( a_variable( cellId ,  v ) - a_oldVariable( cellId
      // ,  v ) ) / ( m_RKalpha[m_RKStep] * timeStep() );
#if !defined NDEBUG || defined _MB_DEBUG_

      IF_CONSTEXPR(hasE<SysEqn>)
      if(std::isnan(a_variable(cellId, v))
         || (((v == CV->RHO && a_variable(cellId, CV->RHO) < F0)
              || (v == CV->RHO_E && a_variable(cellId, CV->RHO_E) < F0))
             && !isDetChem<SysEqn> && !m_isEEGas)) {
        cerr << domainId() << ": small cell correction failed " << globalTimeStep << " " << cellId << " "
             << c_globalId(cellId) << " " << v << " " << a_level(cellId) << " " << a_variable(cellId, v) << " "
             << delta(smallc, v) << " " << setprecision(12)
             << a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId)) << " "
             << a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId)) << endl;
      }
#endif
    }
  }

  // 6. Redistribute flux defect to adjacent cells to re-establish conservation
  if(conservation) {
    for(MInt smallc = 0; smallc < noSmallCells; smallc++) {
      const MInt bndryId = m_fvBndryCnd->m_smallCutCells[(unsigned)smallc];
      const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
      if(a_isPeriodic(cellId)) continue;
      // no-mass conservation at the cut-off - no redistribution from cutoff cells
      if(a_hasProperty(cellId, SolverCell::IsCutOff)) continue;
      if(a_isHalo(cellId)) continue;
      if(a_hasProperty(cellId, SolverCell::IsPeriodicWithRot)) continue;
      if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;
      if(redistFac(smallc) < 1e-14) continue;
      const MInt noSrfcs = m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs;
      const MUint noRecNghbrs = m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.size();
      if(noRecNghbrs == 0) continue;
      // loop over all reconstruction neighbors and apply update to those cells!
      for(MUint n = (unsigned)noSrfcs + 1; n < noRecNghbrs; n++) {
        MInt nghbrId = m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n];
        if(nghbrId < 0) continue;
        ASSERT(a_hasProperty(nghbrId, SolverCell::IsSplitChild) || c_noChildren(nghbrId) == 0, "");
        // non-conservation at the cutOff - no redistribution into cutOff cells
        if(a_hasProperty(nghbrId, SolverCell::IsCutOff)) continue;
        for(MInt v = 0; v < noCVars; v++) {
          a_variable(nghbrId, v) -= redistFac(smallc) * delta(smallc, v);
        }
#if !defined NDEBUG || defined _MB_DEBUG_
        IF_CONSTEXPR(hasE<SysEqn>)
        if(!a_isHalo(nghbrId) && !m_isEEGas
           && (a_variable(nghbrId, CV->RHO) < F0 || ((a_variable(nghbrId, CV->RHO_E) < F0) && (!isDetChem<SysEqn>)))) {
          cerr << domainId() << ": flux redist failed " << globalTimeStep << " " << cellId << " " << c_globalId(cellId)
               << " " << a_level(cellId) << " " << nghbrId << " " << c_globalId(nghbrId) << " "
               << a_variable(nghbrId, CV->RHO) << " " << a_variable(nghbrId, CV->RHO_E) << " " << noRecNghbrs << " "
               << redistFac(smallc) << " " << delta(smallc, CV->RHO) << " " << delta(smallc, CV->RHO_E) << " "
               << setprecision(12) << a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId)) << endl;
        }
#endif
      }
    }
  }

  RECORD_TIMER_STOP(m_timers[Timers::SCCorrRedist]);
  RECORD_TIMER_START(m_timers[Timers::SCCorrExchange2]);

  // 7. Send back flux redistributed over domain boundaries, i.e., from halos -> windows, send and receive buffers are
  // switched on purpose
  if(conservation) {
    if(grid().azimuthalPeriodicity()) azimuthalNearBoundaryReverseExchange();

    sendReq.fill(MPI_REQUEST_NULL);
    recvReq.fill(MPI_REQUEST_NULL);
    sendBufferCnts.fill(0);
    recvBufferCnts.fill(0);
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      sendBufferCnts(i) = noCVars * (signed)m_fvBndryCnd->m_nearBoundaryHaloCells[i].size();
      recvBufferCnts(i) = noCVars * (signed)m_fvBndryCnd->m_nearBoundaryWindowCells[i].size();
      if(m_fvBndryCnd->m_nearBoundaryHaloCells[i].empty()) continue;
      MInt sendBufferCounter = 0;
      for(MUint j = 0; j < m_fvBndryCnd->m_nearBoundaryHaloCells[i].size(); j++) {
        MInt cellId = m_fvBndryCnd->m_nearBoundaryHaloCells[i][j];
        for(MInt v = 0; v < noCVars; v++) {
          m_receiveBuffers[i][sendBufferCounter] = a_variable(cellId, v);
          sendBufferCounter++;
        }
      }
    }
    MInt sendCnt = 0;
    MInt recvCnt = 0;
    if(m_nonBlockingComm) {
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(sendBufferCnts(i) == 0) continue;
        ASSERT(sendBufferCnts(i) <= m_noMaxLevelHaloCells[i] * m_dataBlockSize, "");
        MPI_Isend(m_receiveBuffers[i], sendBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 13, mpiComm(),
                  &sendReq[sendCnt], AT_, "m_receiveBuffers[i]");
        sendCnt++;
      }
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(recvBufferCnts(i) == 0) continue;
        ASSERT(recvBufferCnts(i) <= m_noMaxLevelWindowCells[i] * m_dataBlockSize, "");
        MPI_Irecv(m_sendBuffers[i], recvBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 13, mpiComm(), &recvReq[recvCnt],
                  AT_, "m_sendBuffers[i]");
        recvCnt++;
      }
      RECORD_TIMER_START(m_timers[Timers::SCCorrExchange2Wait]);
      if(recvCnt > 0) MPI_Waitall(recvCnt, &recvReq[0], MPI_STATUSES_IGNORE, AT_);
      RECORD_TIMER_STOP(m_timers[Timers::SCCorrExchange2Wait]);
    } else {
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(sendBufferCnts(i) == 0) continue;
        ASSERT(sendBufferCnts(i) <= m_noMaxLevelHaloCells[i] * m_dataBlockSize, "");
        MPI_Issend(m_receiveBuffers[i], sendBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 13, mpiComm(),
                   &sendReq[sendCnt], AT_, "m_receiveBuffers[i]");
        sendCnt++;
      }
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(recvBufferCnts(i) == 0) continue;
        ASSERT(recvBufferCnts(i) <= m_noMaxLevelWindowCells[i] * m_dataBlockSize, "");
        RECORD_TIMER_START(m_timers[Timers::SCCorrExchange2Wait]);
        MPI_Recv(m_sendBuffers[i], recvBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 13, mpiComm(), MPI_STATUS_IGNORE,
                 AT_, "m_sendBuffers[i]");
        RECORD_TIMER_STOP(m_timers[Timers::SCCorrExchange2Wait]);
        recvCnt++;
      }
    }
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_fvBndryCnd->m_nearBoundaryWindowCells[i].empty()) continue;
      MInt recvBufferCounter = 0;
      for(MUint j = 0; j < m_fvBndryCnd->m_nearBoundaryWindowCells[i].size(); j++) {
        MInt cellId = m_fvBndryCnd->m_nearBoundaryWindowCells[i][j];
        for(MInt v = 0; v < noCVars; v++) {
          // if( (!a_isPeriodic(cellId)) && (!a_hasProperty( cellId , SolverCell::IsCutOff)) ){   // ?
          a_variable(cellId, v) += m_sendBuffers[i][recvBufferCounter];
          //}
          // a_rightHandSide( cellId ,  v ) = a_cellVolume( cellId ) * ( a_variable( cellId ,  v ) - a_oldVariable(
          // cellId ,  v ) ) / ( m_RKalpha[m_RKStep] * timeStep() );
          recvBufferCounter++;
        }
      }
    }
    RECORD_TIMER_START(m_timers[Timers::SCCorrExchange2Wait]);
    if(sendCnt > 0) MPI_Waitall(sendCnt, &sendReq[0], MPI_STATUSES_IGNORE, AT_);

    RECORD_TIMER_STOP(m_timers[Timers::SCCorrExchange2Wait]);
  }

  // azimuthal periodicity concept
  if(conservation && (m_periodicCells == 2 || m_periodicCells == 3)) {
    // reset halo cells
    for(MInt c = 0; c < m_sortedPeriodicCells->size(); c++) {
      if(a_isHalo(m_sortedPeriodicCells->a[c])) {
        a_variable(m_sortedPeriodicCells->a[c], CV->RHO) = F0;
        IF_CONSTEXPR(hasE<SysEqn>)
        a_variable(m_sortedPeriodicCells->a[c], CV->RHO_E) = F0;
        a_variable(m_sortedPeriodicCells->a[c], CV->RHO_U) = F0;
        a_variable(m_sortedPeriodicCells->a[c], CV->RHO_V) = F0;
        a_variable(m_sortedPeriodicCells->a[c], CV->RHO_W) = F0;

        IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
          for(MInt r = 0; r < m_noRansEquations; ++r) {
            a_variable(m_sortedPeriodicCells->a[c], CV->RHO_NN[r]) = F0;
          }
        }
      }
    }

    for(MInt d = 0; d < noDomains(); d++) {
      for(MInt c = 0; c < m_noPerCellsToReceive[d]; c++) {
        const auto sortedId = static_cast<MInt>(m_periodicDataToReceive[d][5 + c * m_noPeriodicData]);
        const MInt cell_Id = m_sortedPeriodicCells->a[sortedId];

        m_periodicDataToReceive[d][0 + c * m_noPeriodicData] = a_variable(cell_Id, CV->RHO);
        m_periodicDataToReceive[d][1 + c * m_noPeriodicData] = a_variable(cell_Id, CV->RHO_U);
        m_periodicDataToReceive[d][2 + c * m_noPeriodicData] = a_variable(cell_Id, CV->RHO_V);
        m_periodicDataToReceive[d][3 + c * m_noPeriodicData] = a_variable(cell_Id, CV->RHO_W);
        IF_CONSTEXPR(hasE<SysEqn>)
        m_periodicDataToReceive[d][4 + c * m_noPeriodicData] = a_variable(cell_Id, CV->RHO_E);
      }
    }

    // set Data for current domain
    for(MInt c = 0; c < m_noPerCellsToReceive[domainId()]; c++) {
      for(MInt v = 0; v < m_noPeriodicData; v++) {
        m_periodicDataToSend[domainId()][v + c * m_noPeriodicData] =
            m_periodicDataToReceive[domainId()][v + c * m_noPeriodicData];
      }
    }

    {
      // exchange interpolated PV Variables
      ScratchSpace<MPI_Request> send_Req(noDomains(), AT_, "sendReq");
      ScratchSpace<MPI_Request> recv_Req(noDomains(), AT_, "recvReq");
      send_Req.fill(MPI_REQUEST_NULL);
      recv_Req.fill(MPI_REQUEST_NULL);

      for(MInt snd = 0; snd < domainId(); snd++) {
        if(m_noPerCellsToSend[snd] > 0) {
          MInt bufSize = m_noPerCellsToSend[snd] * m_noPeriodicData;
          MPI_Irecv(m_periodicDataToSend[snd], bufSize, MPI_DOUBLE, snd, 0, mpiComm(), &recv_Req[snd], AT_,
                    "m_periodicDataToSend[snd]");
        }
      }
      for(MInt rcv = 0; rcv < noDomains(); rcv++) {
        if(m_noPerCellsToReceive[rcv] > 0 && rcv != domainId()) {
          MInt bufSize = m_noPerCellsToReceive[rcv] * m_noPeriodicData;
          MPI_Isend(m_periodicDataToReceive[rcv], bufSize, MPI_DOUBLE, rcv, 0, mpiComm(), &send_Req[rcv], AT_,
                    "m_periodicDataToReceive[rcv]");
        }
      }

      if(domainId() < noDomains() - 1) {
        for(MInt snd = domainId() + 1; snd < noDomains(); snd++) {
          if(m_noPerCellsToSend[snd] > 0) {
            MInt bufSize = m_noPerCellsToSend[snd] * m_noPeriodicData;
            MPI_Irecv(m_periodicDataToSend[snd], bufSize, MPI_DOUBLE, snd, 0, mpiComm(), &recv_Req[snd], AT_,
                      "m_periodicDataToSend[snd]");
          }
        }
      }

      RECORD_TIMER_START(m_timers[Timers::SCCorrExchange2Wait]);
      MPI_Waitall(noDomains(), &recv_Req[0], MPI_STATUSES_IGNORE, AT_);
      MPI_Waitall(noDomains(), &send_Req[0], MPI_STATUSES_IGNORE, AT_);
      RECORD_TIMER_STOP(m_timers[Timers::SCCorrExchange2Wait]);
    }


    for(MInt d = 0; d < noDomains(); d++) {
      for(MInt c = 0; c < m_noPerCellsToSend[d]; c++) {
        const auto cell_Id = static_cast<MInt>(m_periodicDataToSend[d][6 + c * m_noPeriodicData]);

        a_variable(cell_Id, CV->RHO) += m_periodicDataToSend[d][0 + c * m_noPeriodicData];
        a_variable(cell_Id, CV->RHO_U) += m_periodicDataToSend[d][1 + c * m_noPeriodicData];
        a_variable(cell_Id, CV->RHO_V) += m_periodicDataToSend[d][2 + c * m_noPeriodicData];
        a_variable(cell_Id, CV->RHO_W) += m_periodicDataToSend[d][3 + c * m_noPeriodicData];
        IF_CONSTEXPR(hasE<SysEqn>)
        a_variable(cell_Id, CV->RHO_E) += m_periodicDataToSend[d][4 + c * m_noPeriodicData];
      }
    }
  }

  RECORD_TIMER_STOP(m_timers[Timers::SCCorrExchange2]);
}

//-------------------------------------------------------------------------------------


/** \brief retrieves the first 'noLayers' layers of direct and(or diagonal neighbors to the given cell
 *
 * \author Lennart Schneiders
 *
 * Templeate parameters:
 *   - diag=0 only direct neighbors are returned
 *   - diag=1 also determines 2D-diagonal neighbors
 *   - diag=2 returns all diagonal neighbors
 *   - recorrectBndryCellCoords: how to treat boundary cells (with a volumetric center other than the cell center)
 *
 * \param[in] cellId the cell id to consider
 * \param[in] noLayers the distance of cell units to consider
 * \param[in] adjacentCells will contain the ids of the neighboring cells
 * \param[in] layerId the distance in cell units of a given neighbor
 * \return the number of neighbors found
 *
 **/
template <MInt nDim_, class SysEqn>
template <MInt diag, MBool recorrectBndryCellCoords>
MInt FvCartesianSolverXD<nDim_, SysEqn>::getAdjacentLeafCells(const MInt cellId, const MInt noLayers,
                                                              MIntScratchSpace& adjacentCells,
                                                              MIntScratchSpace& layerId) {
  if(recorrectBndryCellCoords != m_fvBndryCnd->m_cellCoordinatesCorrected) {
    return getAdjacentLeafCells<diag, !recorrectBndryCellCoords>(cellId, noLayers, adjacentCells, layerId);
  }
#ifndef NDEBUG
  if(recorrectBndryCellCoords && !m_fvBndryCnd->m_cellCoordinatesCorrected)
    mTerm(1, AT_, "Corrected cell coordinates are expected.");
  if(!recorrectBndryCellCoords && m_fvBndryCnd->m_cellCoordinatesCorrected)
    mTerm(1, AT_, "Uncorrected cell coordinates are expected.");
#endif
  std::array<std::array<MInt, 4>, nDim> tmpNghbrs;

  MInt gridcell = cellId;
  if(a_hasProperty(cellId, SolverCell::IsSplitClone)) {
    gridcell = m_splitChildToSplitCell.find(cellId)->second;
  }
  if(!a_hasProperty(cellId, SolverCell::IsSplitChild) && c_noChildren(gridcell) > 0) return 0;
  map<MInt, MInt> nghbrs;
  nghbrs.insert(pair<MInt, MInt>(cellId, 0));
  for(MInt layer = 1; layer <= noLayers; layer++) {
    set<MInt> nextLayer;
    for(auto& nghbr : nghbrs) {
      MInt nghbrId = nghbr.first;
      for(MInt dir0 = 0; dir0 < 2 * nDim; dir0++) {
        const MInt cnt0 = getNghbrLeafCells<recorrectBndryCellCoords>(nghbrId, cellId, layer, &tmpNghbrs[0][0], dir0);
        for(MInt c0 = 0; c0 < cnt0; c0++) {
          nextLayer.insert(tmpNghbrs[0][c0]);
          if(diag > 0) {
            for(MInt dir1 = 0; dir1 < 2 * nDim; dir1++) {
              if((dir1 / 2) == (dir0 / 2)) {
                continue;
              }
              const MInt cnt1 = getNghbrLeafCells<recorrectBndryCellCoords>(tmpNghbrs[0][c0], cellId, layer,
                                                                            &tmpNghbrs[1][0], dir1, dir0);
              for(MInt c1 = 0; c1 < cnt1; c1++) {
                nextLayer.insert(tmpNghbrs[1][c1]);
                IF_CONSTEXPR(nDim == 3 && diag == 2) {
                  for(MInt dir2 = 0; dir2 < 2 * nDim; dir2++) {
                    if(((dir2 / 2) == (dir0 / 2)) || ((dir2 / 2) == (dir1 / 2))) continue;
                    const MInt cnt2 = getNghbrLeafCells<recorrectBndryCellCoords>(tmpNghbrs[1][c1], cellId, layer,
                                                                                  &tmpNghbrs[2][0], dir2, dir1, dir0);
                    for(MInt c2 = 0; c2 < cnt2; c2++) {
                      nextLayer.insert(tmpNghbrs[2][c2]);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    for(MInt it : nextLayer) {
      nghbrs.insert(pair<MInt, MInt>(it, layer));
    }
  }
  nghbrs.erase(cellId);
  MInt cnt = 0;
  for(auto it = nghbrs.begin(); it != nghbrs.end(); it++) {
    ASSERT(cnt < (signed)adjacentCells.size(),
           to_string(cellId) + " " + to_string(nghbrs.size()) + " " + to_string(a_isHalo(cellId)) + " "
               + to_string(a_isWindow(cellId)) + " " + to_string(adjacentCells.size()));
    if(a_hasProperty(it->first, SolverCell::IsSplitCell)) {
      auto it2 = find(m_splitCells.begin(), m_splitCells.end(), it->first);
      if(it2 == m_splitCells.end()) mTerm(1, AT_, "split cells inconsistency.");
      const MInt pos = distance(m_splitCells.begin(), it2);
      ASSERT(m_splitCells[pos] == it->first, "");
      for(MUlong c = 0; c < m_splitChilds[pos].size(); c++) {
        adjacentCells[cnt] = m_splitChilds[pos][c];
        layerId[cnt] = it->second;
        ASSERT(adjacentCells[cnt] > -1, "");
        ASSERT(a_hasProperty(adjacentCells[cnt], SolverCell::IsSplitChild) || c_noChildren(adjacentCells[cnt]) == 0,
               "");
        cnt++;
      }
    } else {
      adjacentCells[cnt] = it->first;
      layerId[cnt] = it->second;
      ASSERT(adjacentCells[cnt] > -1, "");
      ASSERT(c_noChildren(adjacentCells[cnt]) == 0, "");
      cnt++;
    }
  }
  return cnt;
}

// ---------------------------------------------------------------------------


/**
 * \brief returns the neighbor leaf cells in the specified direction 'dir'
 * (dir1 and dir2 are used to identify only neighboring children beeing adjacent to the root cell)
 * \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
template <MBool recorrectBndryCellCoords>
MInt FvCartesianSolverXD<nDim_, SysEqn>::getNghbrLeafCells(const MInt cellId, MInt refCell, MInt layer, MInt* nghbrs,
                                                           MInt dir, MInt dir1, MInt dir2) const {
  MInt count = 0;
  // set cellId of split child
  const MInt gridcellId =
      a_hasProperty(cellId, SolverCell::IsSplitClone) ? m_splitChildToSplitCell.find(cellId)->second : cellId;

  if(a_hasProperty(cellId, SolverCell::IsSplitChild)) {
    return 0;
  }

  if(checkNeighborActive(gridcellId, dir) && a_hasNeighbor(gridcellId, dir) > 0) {
    const MInt nextId = c_neighborId(gridcellId, dir);
    if(nextId < 0) return 0;

    if(c_noChildren(nextId) > 0) {
      for(MInt child = 0; child < IPOW2(nDim); child++) {
        if(!childCode[dir][child]) continue;
        if(dir1 > -1 && !childCode[dir1][child]) continue;
        if(dir2 > -1 && !childCode[dir2][child]) continue;
        const MInt childId = c_childId(nextId, child);
        if(childId < 0) continue;
        if(c_noChildren(childId) > 0) continue;
        if(a_hasProperty(childId, SolverCell::IsOnCurrentMGLevel)) {
          nghbrs[count] = childId;
          count++;
        }
      }
    } else if(a_hasProperty(nextId, SolverCell::IsOnCurrentMGLevel)) {
      nghbrs[0] = nextId;
      count = 1;
    }
  } else if(c_parentId(gridcellId) > -1) {
    if(a_hasNeighbor(c_parentId(gridcellId), dir) > 0) {
      const MInt nextId = c_neighborId(c_parentId(gridcellId), dir);
      if(nextId < 0 || c_noChildren(nextId) > 0) {
        return 0;
      }
      if(a_hasProperty(nextId, SolverCell::IsOnCurrentMGLevel)) {
        nghbrs[0] = nextId;
        count = 1;
      }
    }
  }

  std::array<MFloat, nDim> coord0{};
  for(MInt i = 0; i < nDim; i++) {
    coord0[i] = a_coordinate(refCell, i)
                - ((recorrectBndryCellCoords && a_bndryId(refCell) > -1)
                       ? m_fvBndryCnd->m_bndryCells->a[a_bndryId(refCell)].m_coordinates[i]
                       : F0);
  }

  for(MInt c = 0; c < count; c++) {
    const MFloat delta = ((MFloat)layer) * 0.5005 * (c_cellLengthAtCell(nghbrs[c]) + c_cellLengthAtCell(refCell));

    for(MInt i = 0; i < nDim; i++) {
      const MFloat correctedCoord = a_coordinate(nghbrs[c], i)
                                    - ((recorrectBndryCellCoords && a_bndryId(nghbrs[c]) > -1)
                                           ? m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrs[c])].m_coordinates[i]
                                           : F0);
      if(std::abs(correctedCoord - coord0[i]) > delta) {
        nghbrs[c] = nghbrs[count - 1];
        count--;
        c--;
        break;
      }
    }
  }

  return count;
}

// ---------------------------------------------------------------------------

template <MInt nDim_, class SysEqn>
MInt FvCartesianSolverXD<nDim_, SysEqn>::getAdjacentLeafCells_d0(const MInt cellId, const MInt noLayers,
                                                                 MIntScratchSpace& nghbrList,
                                                                 MIntScratchSpace& layerId) {
  return getAdjacentLeafCells<0>(cellId, noLayers, nghbrList, layerId);
}
template <MInt nDim_, class SysEqn>
MInt FvCartesianSolverXD<nDim_, SysEqn>::getAdjacentLeafCells_d1(const MInt cellId, const MInt noLayers,
                                                                 MIntScratchSpace& nghbrList,
                                                                 MIntScratchSpace& layerId) {
  return getAdjacentLeafCells<1>(cellId, noLayers, nghbrList, layerId);
}
template <MInt nDim_, class SysEqn>
MInt FvCartesianSolverXD<nDim_, SysEqn>::getAdjacentLeafCells_d2(const MInt cellId, const MInt noLayers,
                                                                 MIntScratchSpace& nghbrList,
                                                                 MIntScratchSpace& layerId) {
  return getAdjacentLeafCells<2>(cellId, noLayers, nghbrList, layerId);
}
template <MInt nDim_, class SysEqn>
MInt FvCartesianSolverXD<nDim_, SysEqn>::getAdjacentLeafCells_d0_c(const MInt cellId, const MInt noLayers,
                                                                   MIntScratchSpace& nghbrList,
                                                                   MIntScratchSpace& layerId) {
  return getAdjacentLeafCells<0, true>(cellId, noLayers, nghbrList, layerId);
}
template <MInt nDim_, class SysEqn>
MInt FvCartesianSolverXD<nDim_, SysEqn>::getAdjacentLeafCells_d1_c(const MInt cellId, const MInt noLayers,
                                                                   MIntScratchSpace& nghbrList,
                                                                   MIntScratchSpace& layerId) {
  return getAdjacentLeafCells<1, true>(cellId, noLayers, nghbrList, layerId);
}
template <MInt nDim_, class SysEqn>
MInt FvCartesianSolverXD<nDim_, SysEqn>::getAdjacentLeafCells_d2_c(const MInt cellId, const MInt noLayers,
                                                                   MIntScratchSpace& nghbrList,
                                                                   MIntScratchSpace& layerId) {
  return getAdjacentLeafCells<2, true>(cellId, noLayers, nghbrList, layerId);
}

//-------------------------------------------------------------------------------------


/** \brief handles the application of boundary conditions to the ghost cells
 *
 * If multiple ghost cells are used with ghost cells located normal to the boundary
 * surfaces from the surface centroids, image point variables are set.
 * If the image point variables should be set coupled to the flow field, they are
 * updated iteratively.
 *
 * \author changed by Claudia Guenther, Mai 2010
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::applyBoundaryCondition() {
  TRACE();

  // Note: flamespeed is abused here to detect if Stephans flame stuff is running
  if(m_levelSet && m_combustion && abs(m_flameSpeed) <= 0) {
    m_log << "WARNING: applyBoundaryCondition() " << endl;
    return;
  }

  // MFloat ipChange = 10000000.0;
  // MFloat eps = 1e-5;   // just a guess for a suitable value - should be changed to some sophisticated value
  MInt iter = 0;

  if(m_fvBndryCnd->m_multipleGhostCells) {
    // compute Interpolated Variables - initial guess
    m_fvBndryCnd->updateImagePointVariables(0);
  }

  if(m_fvBndryCnd->m_multipleGhostCells && m_fvBndryCnd->m_ipVariableIterative) {
    //     while(ipChange > eps && iter < m_fvBndryCnd->m_noImagePointIterations){
    while(iter < m_fvBndryCnd->m_noImagePointIterations) {
      // apply Dirichlet boundary conditions
      m_fvBndryCnd->updateGhostCellVariables();
      // apply von Neumann boundary conditions
      m_fvBndryCnd->applyNeumannBoundaryCondition();
      // compute cell center gradients
      LSReconstructCellCenter_Boundary();
      // compute Interpolated Variables
      /* ipChange = */ m_fvBndryCnd->updateImagePointVariables(1);
      //       cerr << "[ " << domainId() << " ]: " << " iteration: " << iter << " max. rel. change in image point
      //       variables: " << ipChange << endl;
      iter++;
    }
  }
  // apply Dirichlet boundary conditions
  m_fvBndryCnd->updateGhostCellVariables();

  // apply von Neumann boundary conditions
  m_fvBndryCnd->applyNeumannBoundaryCondition();
}


// --------------------------------------------------------------------------------------


/** \brief Determine the least squares stencil
 * \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::buildLeastSquaresStencilSimple() {
  TRACE();

  const MBool diagonalCellAddition = m_fvBndryCnd->m_cellMerging && (nDim == 3);
  const MInt maxNoNghbrs = 100;
  MIntScratchSpace nghbrList(maxNoNghbrs, AT_, "nghbrList");
  MIntScratchSpace layerId(maxNoNghbrs, AT_, "layerId");

  m_fvBndryCnd->recorrectCellCoordinates();

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    const MInt bndryId = a_bndryId(cellId);
    MInt gridcell = cellId;
    if(a_hasProperty(cellId, SolverCell::IsSplitClone)) {
      gridcell = m_splitChildToSplitCell.find(cellId)->second;
    }

    a_noReconstructionNeighbors(cellId) = 0;

    if(a_isBndryGhostCell(cellId)) continue;
    if(c_noChildren(gridcell) > 0) continue;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    // if( a_hasProperty( cellId , SolverCell::IsCutOff) ) continue;
    if(a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInvalid)) continue;

    // const MInt counter = ( bndryId > -1 || m_orderOfReconstruction == 2 ) ? getAdjacentLeafCells<1>( cellId, 1,
    // nghbrList, layerId ) : getAdjacentLeafCells<0>( cellId, 1, nghbrList, layerId ); MBool ext = false; if ( bndryId
    // > -1 ) if ( m_fvBndryCnd->m_bndryCells->a[ bndryId ].m_volume / pow(c_cellLengthAtCell(cellId),(MFloat)nDim) <
    // F1B2 ) ext = true; const MInt counter = ( ext || m_orderOfReconstruction == 2 ) ? getAdjacentLeafCells<1>(
    // cellId, 1, nghbrList, layerId ) : getAdjacentLeafCells<0>( cellId, 1, nghbrList, layerId );
    const MInt counter = getAdjacentLeafCells<0>(cellId, 1, nghbrList, layerId);
    if(counter > maxNoNghbrs) mTerm(1, AT_, "too many nghbrs " + to_string(counter));
    if(bndryId > -1) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        a_reconstructionNeighborId(cellId, a_noReconstructionNeighbors(cellId)) =
            m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
        a_noReconstructionNeighbors(cellId)++;
      }
    }
    MBool atInterface = false;
    for(MInt k = 0; k < counter; k++) {
      MInt nghbrId = nghbrList[k];
      if(nghbrId < 0) continue;
      if(a_hasProperty(nghbrId, SolverCell::IsInvalid)) continue;
      // if ( a_noReconstructionNeighbors( cellId )  >= m_cells.noRecNghbrs()) continue;
      a_reconstructionNeighborId(cellId, a_noReconstructionNeighbors(cellId)) = nghbrId;
      a_noReconstructionNeighbors(cellId)++;
      if(a_noReconstructionNeighbors(cellId) > m_cells.noRecNghbrs()) {
        mTerm(1, AT_, "too many rec nghbrs " + to_string(cellId) + " " + to_string(counter));
      }
      if(a_level(nghbrId) < a_level(cellId)) atInterface = true;
    }
    if(diagonalCellAddition && atInterface) {
      const MInt counter2 = getAdjacentLeafCells<2>(cellId, 1, nghbrList, layerId);
      for(MInt k = 0; k < counter2; k++) {
        MInt nghbrId = nghbrList[k];
        if(nghbrId < 0) continue;
        if(a_hasProperty(nghbrId, SolverCell::IsInvalid)) continue;
        if(a_level(nghbrId) >= a_level(cellId)) continue;
        MBool exist = false;
        for(MInt i = 0; i < a_noReconstructionNeighbors(cellId); i++) {
          if(a_reconstructionNeighborId(cellId, i) == nghbrId) {
            exist = true;
            break;
          }
        }
        if(!exist) {
          a_reconstructionNeighborId(cellId, a_noReconstructionNeighbors(cellId)) = nghbrId;
          a_noReconstructionNeighbors(cellId)++;
        }
        if(a_noReconstructionNeighbors(cellId) > m_cells.noRecNghbrs()) {
          mTerm(1, AT_, "too many rec nghbrs " + to_string(cellId) + " " + to_string(counter));
        }
      }
    }
  }

  if(m_fvBndryCnd->m_cellMerging) {
    // internal master cells
    // add the slave ghost cells and neighbor boundary cells
    MInt noSmallCells = m_fvBndryCnd->m_smallBndryCells->size();
    for(MInt smallId = 0; smallId < noSmallCells; smallId++) {
      MInt smallCell = m_fvBndryCnd->m_smallBndryCells->a[smallId];
      MInt smallCellId = m_fvBndryCnd->m_bndryCells->a[smallCell].m_cellId;
      MInt masterCellId = m_fvBndryCnd->m_bndryCells->a[smallCell].m_linkedCellId;
      if(a_bndryId(masterCellId) == -1) {
        for(MInt i = 0; i < a_noReconstructionNeighbors(smallCellId); i++) {
          MInt nghbrId = a_reconstructionNeighborId(smallCellId, i);
          if(a_bndryId(nghbrId) > -1)
            if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId > -1)
              nghbrId = m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId;
          MBool found = false;
          for(MInt j = 0; j < a_noReconstructionNeighbors(masterCellId); j++) {
            if(nghbrId == a_reconstructionNeighborId(masterCellId, j)) {
              found = true;
              break;
            }
          }
          if(!found && nghbrId != masterCellId) {
            a_reconstructionNeighborId(masterCellId, a_noReconstructionNeighbors(masterCellId)) = nghbrId;
            a_noReconstructionNeighbors(masterCellId)++;
          }
        }
      }
    }
  }

  m_fvBndryCnd->rerecorrectCellCoordinates();
}


// --------------------------------------------------------------------------------------


/** \brief Compute the reconstruction constants using a weighted least squares approached solved via singular value
 * decomposition \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeReconstructionConstantsSVD() {
  TRACE();

  if(m_orderOfReconstruction > 1) mTerm(1, AT_, "Check code here.");

  const MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();
  const MInt recDim = (m_orderOfReconstruction == 2) ? (IPOW2(nDim) + 1) : nDim;
  MFloatScratchSpace tmpA(m_cells.noRecNghbrs(), recDim, AT_, "tmpA");
  MFloatScratchSpace tmpC(recDim, m_cells.noRecNghbrs(), AT_, "tmpC");
  MFloatScratchSpace weights(m_cells.noRecNghbrs(), AT_, "weights");

#ifndef NDEBUG
  MFloat counter = F0;
  MFloat avg = F0;
  MFloat maxc = F0;
#endif

  m_reconstructionConstants.clear();
  m_reconstructionCellIds.clear();
  m_reconstructionNghbrIds.clear();

  // clear cell-center reconstruction
  m_reconstructionDataSize = 0;

  // reset isFlux
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    a_hasProperty(cellId, SolverCell::IsFlux) = false;
  }

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    a_reconstructionData(cellId) = m_reconstructionDataSize;

    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    // if( !a_hasProperty( cellId , SolverCell::IsFlux) ) continue;
    if(a_isBndryGhostCell(cellId)) continue;
    if(a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    /*IF_CONSTEXPR(nDim == 3) {
      if(a_hasProperty(cellId , SolverCell::IsInvalid)) continue;
    }*/
    if(a_bndryId(cellId) > -1) {
      if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_linkedCellId > -1) {
        continue;
      }
    }

    a_hasProperty(cellId, SolverCell::IsFlux) = true;

    // loop over least-squares cell cluster
    const MInt noNghbrIds = a_noReconstructionNeighbors(cellId);
    if(noNghbrIds == 0) continue;

    for(MInt n = 0; n < noNghbrIds; n++) {
      const MInt nghbrId = a_reconstructionNeighborId(cellId, n);
      a_hasProperty(nghbrId, SolverCell::IsFlux) = true;
    }

    MFloat condNum =
        computeRecConstSVD(cellId, m_reconstructionDataSize, tmpA, tmpC, weights, recDim, m_reConstSVDWeightMode, -1);

    m_reconstructionDataSize += noNghbrIds;

#ifndef NDEBUG
    avg += condNum;
    maxc = mMax(maxc, condNum);
    counter += F1;
#else
    std::ignore = condNum;

#endif
  }

  a_reconstructionData(a_noCells()) = m_reconstructionDataSize;

  // copy reconstruction Constants into bndry reconstruction Constants for all bndryCells
  for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    for(MInt nghbr = 0; nghbr < a_noReconstructionNeighbors(cellId); nghbr++) {
      for(MInt i = 0; i < nDim; i++) {
        m_fvBndryCnd->m_reconstructionConstants[bndryId][nghbr * nDim + i] =
            m_reconstructionConstants[nDim * (a_reconstructionData(cellId) + nghbr) + i];
      }
    }
    const MUint noRecNghbrs = m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.size();
    const MInt noSrfcs = m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs;
    // Note: skip the first noSrfcs neighbor ids since they contain dummyIds
    for(MUint n = noSrfcs; n < noRecNghbrs; n++) {
      a_hasProperty(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n], SolverCell::IsFlux) = true;
    }
  }

  m_log << "ok" << endl;

#ifndef NDEBUG

  MPI_Allreduce(MPI_IN_PLACE, &maxc, 1, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "maxc");
  MPI_Allreduce(MPI_IN_PLACE, &avg, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "avg");
  MPI_Allreduce(MPI_IN_PLACE, &counter, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "counter");

  m_log << " -> Singular value decomposition: maximum/average condition number: " << maxc << "/" << avg / counter
        << endl;

#endif
}


// ---------------------------------------------------------------------------


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::cutOffBoundaryCondition() {
  TRACE();

  m_fvBndryCnd->updateCutOffCellVariables();
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initCutOffBoundaryCondition() {
  TRACE();

  m_fvBndryCnd->initCutOffBndryCnds();
}

// --------------------------------------------------------------------------------------

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::nonReflectingBCCutOff() {
  TRACE();

  m_fvBndryCnd->applyNonReflectingBCCutOff();
}


// --------------------------------------------------------------------------------------


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::nonReflectingBCAfterTreatmentCutOff() {
  TRACE();

  m_fvBndryCnd->applyNonReflectingBCAfterTreatmentCutOff();
}


// --------------------------------------------------------------------------------------


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeCellSurfaceDistanceVectors() {
  TRACE();

  const MInt noSrfcs = a_noSurfaces();
  //---

  for(MInt s = 0; s < noSrfcs; s++) {
    for(MInt i = 0; i < nDim; i++) {
      a_surfaceDeltaX(s, i) = a_surfaceCoordinate(s, i) - a_coordinate(a_surfaceNghbrCellId(s, 0), i);
      a_surfaceDeltaX(s, nDim + i) = a_surfaceCoordinate(s, i) - a_coordinate(a_surfaceNghbrCellId(s, 1), i);
    }
  }
}


//-----------------------------------------------------------------------------


// template <MInt nDim_, class SysEqn>
// void FvCartesianSolverXD<nDim,SysEqn>::updateBndryCollector()
//{
//  TRACE();
//
//  MInt noCells = a_noCells();
//  //---
//
//  for( MInt cellId = 0; cellId < noCells; cellId++)
//    if( a_bndryId( cellId )  > -1 )
//      m_fvBndryCnd->m_bndryCells->a[ a_bndryId( cellId )  ].m_cellId = cellId;
//}


// ----------------------------------------------------------------------------


/** \brief computes the coordinates of the grid cell centers and stores them into a one-dimensional array
 *
 * \author Daniel Hartmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeGridCellCoordinates(MFloat* gccCoordinates) {
  TRACE();

  MInt noCellIds = a_noCells();
  MInt bndryId;
  MInt smallCell;

  // ---------- end of initialization ----------------

  // copy fluid cell cogs and correct those of boundary cells
  for(MInt cellId = 0; cellId < noCellIds; cellId++) {
    if(!a_isBndryGhostCell(cellId)) {
      for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
        // copy coordinates of cog
        gccCoordinates[cellId * nDim + spaceId] = a_coordinate(cellId, spaceId);

        // correct cog of boundary cells
        if(a_bndryId(cellId) > -1) {
          bndryId = a_bndryId(cellId);

          gccCoordinates[cellId * nDim + spaceId] -= m_fvBndryCnd->m_bndryCells->a[bndryId].m_coordinates[spaceId];
        }
      }
    }
  }

  // correct coordinates of fluid cells which are masters of a small cell
  for(MInt smallId = 0; smallId < m_fvBndryCnd->m_smallBndryCells->size(); smallId++) {
    smallCell = m_fvBndryCnd->m_smallBndryCells->a[smallId];
    if(m_fvBndryCnd->m_bndryCells->a[smallCell].m_linkedCellId > -1) {
      if(a_bndryId(m_fvBndryCnd->m_bndryCells->a[smallCell].m_linkedCellId) == -1) {
        for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
          gccCoordinates[(m_fvBndryCnd->m_bndryCells->a[smallCell].m_linkedCellId) * nDim + spaceId] =
              m_fvBndryCnd->m_bndryCells->a[smallCell].m_masterCoordinates[spaceId];
        }
      }
    }
  }
}


// ----------------------------------------------------------------------------


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeCellVolumes() {
  TRACE();

  MInt smallCell;
  MInt masterId;
  const MInt noCells = a_noCells();
  const MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();
  //---

  for(MInt cellId = 0; cellId < noCells; cellId++) {
    a_cellVolume(cellId) = c_cellLengthAtCell(cellId);
    for(MInt spaceId = 1; spaceId < nDim; spaceId++) {
      a_cellVolume(cellId) *= c_cellLengthAtCell(cellId);
    }
  }
  // correct the volume of boundary cells
  for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    a_cellVolume(cellId) = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume;
  }

  // correct the volume of fluid master cells
  for(MInt smallId = 0; smallId < m_fvBndryCnd->m_smallBndryCells->size(); smallId++) {
    smallCell = m_fvBndryCnd->m_smallBndryCells->a[smallId];
    masterId = m_fvBndryCnd->m_bndryCells->a[smallCell].m_linkedCellId;
    if(a_bndryId(masterId) == -1) {
      a_cellVolume(masterId) += m_fvBndryCnd->m_bndryCells->a[smallCell].m_volume;
    }
  }

  // check the volume of all cells that are
  // taken into account
  for(MInt cellId = 0; cellId < noCells; cellId++) {
    if(a_cellVolume(cellId) < 0.0
       // || a_cellVolume( cellId ) < pow( 10.0, -12.0 )
    ) {
      cerr << "!!!Volume is " << a_cellVolume(cellId) << endl;
      cerr << "cell Id " << c_globalId(cellId) << " level " << a_level(cellId) << endl;
      if(a_bndryId(cellId) > -1) {
        cerr << "... is a boundary cell" << endl << endl;
      }
      cerr << "Coordinates: " << a_coordinate(cellId, 0) << " " << a_coordinate(cellId, 1);
      IF_CONSTEXPR(nDim == 3) cerr << " " << a_coordinate(cellId, 2);
      cerr << endl;
    }
  }

  // compute the inverse volume
  for(MInt cellId = 0; cellId < noCells; cellId++) {
    a_FcellVolume(cellId) = F1 / a_cellVolume(cellId);
  }
}


// --------------------------------------------------------------------------------------
/** \cartesiansolver Sponge
 */
// --------------------------------------------------------------------------------------

/** \brief computes the additional rhs of all cells lying inside the
 *        sponge layer to dissipate outgoing waves.
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::updateSpongeLayer() {
  TRACE();
  // TODO labels:FV compute sponge factor (linear, tanh)
  if(m_spongeLayerThickness > F0) {
    std::array<MFloat, 6> values{}; // order is: rho1, p1, rho2, p2, rho3, p3; default are rhoInf and pInf
    values = computeTargetValues();

    for(MInt c = 0; c < m_noCellsInsideSpongeLayer; c++) {
      const MInt cellId = m_cellsInsideSpongeLayer[c];
      // update rhs RHO_E, RHO, RHO_V, RHO_U, RHO_W, RHO_Y (NOTE: RHO_Y is not computed by computeSpongeDeltas):
      updateSpongeLayerRhs(cellId, computeSpongeDeltas(cellId, values));
    }
  }
}

template <MInt nDim_, class SysEqn>
std::array<MFloat, 6> FvCartesianSolverXD<nDim_, SysEqn>::computeTargetValues() {
  using valueA = std::array<MFloat, 6>;
  valueA values;
  values[0] = m_rhoInfinity;
  values[1] = m_PInfinity;
  values[2] = m_rhoInfinity;
  values[3] = m_PInfinity;
  values[4] = m_rhoInfinity;
  values[5] = m_PInfinity;

  switch(m_spongeLayerType) {
    case 5: {
      values[0] = m_rhoHg;
      values[1] = m_PHg;
      values[2] = m_UHg;
      values[3] = m_rhoCg;
      values[4] = m_PCg;
      values[5] = m_UCg;
      break;
    }
    case 6: {
      values[0] = m_rhoInfinity;
      values[1] = m_PInfinity;
      values[2] = m_UInfinity;
      values[3] = m_VInfinity;
      values[4] = m_WInfinity;
      values[5] = m_UInfinity;
      break;
    }
    case 66: {
      values[0] = m_rhoInfinity;
      values[1] = m_PInfinity;
      values[2] = m_UInfinity;
      values[3] = m_VInfinity;
      values[4] = m_WInfinity;
      values[5] = m_UInfinity;
      break;
    }
    case 77: {
      values[0] = m_rhoInfinity;
      values[1] = m_PInfinity;
      values[2] = m_UInfinity;
      values[3] = m_VInfinity;
      values[4] = m_WInfinity;
      values[5] = m_UInfinity;
      break;
    }

    // FAN --> Alexej Pogorelov
    case 41: {
      IF_CONSTEXPR(nDim == 2) mTerm(-1, "Info: untested in 2D.");

      m_deltaP = 1.002083018;
      values[1] = m_PInfinity * m_deltaP;
      return values;
    }

    // this sponge was originally located in fvsolver3d.cpp; so if anything is not working as
    // it is supposed to work, look in there
    case 51: { // ALLGEMEINER SPONGE MIT MITTELUNG
      IF_CONSTEXPR(nDim == 2) mTerm(-1, "Info: This sponge layer type only works in 3D.");

      static constexpr MInt noRSteps = 20;

      if(m_firstUseUpdateSpongeLayerCase51) {
        m_hasCellsInSpongeLayer = m_noCellsInsideSpongeLayer;

        m_noSpongeZonesIn = 0;

        /*! \page propertiesFV
              \section noSpongeZonesOut
              <code>MInt FvCartesianSolverXD::m_noSpongeZonesOut</code>\n
              default = <code>0</code>\n \n
              Used in sponge 51. Number of outflow sponge zones.\n \n
              Possible values are:
              <ul>
                <li>Any positive integer value</li>
              </ul>
              Keywords: <i>FINITE_VOLUME, SPONGE</i>
            */
        m_noSpongeZonesOut = 0;
        m_noSpongeZonesIn = Context::getSolverProperty<MInt>("noSpongeZonesIn", m_solverId, AT_, &m_noSpongeZonesIn);
        m_noSpongeZonesOut = Context::getSolverProperty<MInt>("noSpongeZonesOut", m_solverId, AT_, &m_noSpongeZonesOut);
        if(m_noSpongeZonesIn > 0) {
          for(MInt i = 0; i < m_noSpongeZonesIn; i++) {
            m_spongeDirectionsIn[i] = Context::getSolverProperty<MInt>("spongeDirectionsIn", m_solverId, AT_, i);

            /*! \page propertiesFV
              \section secondSpongeDirectionsIn
              <code>MInt FvCartesianSolverXD::m_secondSpongeDirectionsIn</code>\n
              default = <code>none </code>\n \n
              Used in sponge 51 (general averaging in time). Defines the Direction of the sponge for the second inflow.
              Keywords: <i>FINITE_VOLUME, SPONGE, AVERAGING</i>
            */
            m_secondSpongeDirectionsIn[i] =
                Context::getSolverProperty<MInt>("secondSpongeDirectionsIn", m_solverId, AT_, i);
            m_spongeAveragingIn[i] = Context::getSolverProperty<MInt>("spongeAveragingIn", m_solverId, AT_, i);
          }
        }
        if(m_noSpongeZonesOut > 0) {
          for(MInt i = 0; i < m_noSpongeZonesOut; i++) {
            /*! \page propertiesFV
              \section spongeDirectionsOut
              <code>MInt FvCartesianSolverXD::m_spongeDirectionsOut</code>\n
              default = <code>none</code>\n \n
              Outward direction of the sponge layer.\n
              Possible values:\n
              <li>0,1,2</li>
              Keywords: <i>FINITE_VOLUME, SPONGE</i>
            */
            m_spongeDirectionsOut[i] = Context::getSolverProperty<MInt>("spongeDirectionsOut", m_solverId, AT_, i);

            /*! \page propertiesFV
            \section secondSpongeDirectionsOut
            <code>MInt FvCartesianSolverXD::m_secondSpongeDirectionsOut</code>\n
            default = <code>none </code>\n \n
            Used in sponge 51 (general averaging in time). Defines the Direction of the sponge for the second outflow.
            Keywords: <i>FINITE_VOLUME, SPONGE, AVERAGING</i>
          */
            m_secondSpongeDirectionsOut[i] =
                Context::getSolverProperty<MInt>("secondSpongeDirectionsOut", m_solverId, AT_, i);

            /*! \page propertiesFV
              \section spongeAveragingOut
              <code>MInt FvCartesianSolverXD::m_spongeAveragingOut</code>\n
              default = <code>none</code>\n \n
              Used in sponge 51 (general averaging in time). Enables/disables averaging a particular "out" sponge
              region. Keywords: <i>FINITE_VOLUME, SPONGE, AVERAGING</i>
            */
            m_spongeAveragingOut[i] = Context::getSolverProperty<MInt>("spongeAveragingOut", m_solverId, AT_, i);
          }
        }
        MIntScratchSpace comm_buff_scratch_processes(1, AT_, "comm_buff_scratch_processes");
        MIntScratchSpace comm_buff_result_scratch_processes(noDomains(), AT_, "comm_buff_result_scratch_processes");
        MInt* comm_buff_processes = comm_buff_scratch_processes.getPointer();
        MInt* comm_buff_result_processes = comm_buff_result_scratch_processes.getPointer();
        comm_buff_processes[0] = m_hasCellsInSpongeLayer;

        MPI_Allgather(comm_buff_processes, 1, MPI_INT, comm_buff_result_processes, 1, MPI_INT, mpiComm(), AT_,
                      "comm_buff_processes", "comm_buff_result_processes");

        MPI_Group world_group;
        MPI_Group group_sponge;
        MInt noProcs_sponge = 0;
        for(MInt i = 0; i < noDomains(); i++) {
          if(comm_buff_result_processes[i] > 0) {
            noProcs_sponge++;
          }
        }
        MIntScratchSpace procs_sponge(noProcs_sponge, AT_, "procs_sponge");
        MInt count = 0;
        for(MInt i = 0; i < noDomains(); i++) {
          if(comm_buff_result_processes[i] > 0) {
            procs_sponge[count++] = i;
          }
        }

        MPI_Comm_group(mpiComm(), &world_group, AT_, "world_group");
        MPI_Group_incl(world_group, noProcs_sponge, procs_sponge.getPointer(), &group_sponge, AT_);

        MPI_Comm_create(mpiComm(), group_sponge, &comm_sponge, AT_, "comm_sponge");

        /*! \page propertiesFV
          \section timeOfMaxPdiff
          <code>MInt FvCartesianSolverXD::m_timeOfMaxPdiff</code>\n
          default = <code>0.0</code>\n \n
          Used in sponge 51. Time in which the pressure is changed to final value.\n \n
          Possible values are:
          <ul>
            <li>Any positive floating point value</li>
          </ul>
          Keywords: <i>FINITE_VOLUME, SPONGE</i>
        */
        m_timeOfMaxPdiff = 0.0;
        m_timeOfMaxPdiff = Context::getSolverProperty<MFloat>("timeOfMaxPdiff", m_solverId, AT_, &m_timeOfMaxPdiff);
        // Convert from freestream-based to stagnation-based non-dimensionalization
        m_timeOfMaxPdiff = m_timeOfMaxPdiff / m_timeRef;

        m_firstUseUpdateSpongeLayerCase51 = false;

        // allocate sponge specific variables, which need to persist through the whole run
        mAlloc(m_coordSpongeIn, m_noSpongeZonesIn, "m_coordSpongeIn", AT_);
        mAlloc(m_secondCoordSpongeIn, m_noSpongeZonesIn, "m_secondCoordSpongeIn", AT_);
        mAlloc(m_coordSpongeOut, m_noSpongeZonesOut, "m_coordSpongeOut", AT_);
        mAlloc(m_secondCoordSpongeOut, m_noSpongeZonesOut, "m_secondCoordSpongeOut", AT_);
        mAlloc(m_uNormal_r, noRSteps, "m_uNormal_r", AT_);
      }
      if(!m_hasCellsInSpongeLayer) {
        break; // return;
      }
      MFloatScratchSpace spongeVolumeIn(m_noSpongeZonesIn, AT_, "spongeVolumeIn");
      MFloatScratchSpace spongeVolumeOut(m_noSpongeZonesOut, AT_, "spongeVolumeOut");
      MFloatScratchSpace pressureIn(m_noSpongeZonesIn, AT_, "pressureIn");
      MFloatScratchSpace pressureOut(m_noSpongeZonesOut, AT_, "pressureOut");
      MFloatScratchSpace densityIn(m_noSpongeZonesIn, AT_, "densityIn");
      MFloatScratchSpace densityOut(m_noSpongeZonesOut, AT_, "densityOut");
      MFloatScratchSpace coordAverageIn(m_noSpongeZonesIn, AT_, "coordAverageIn");
      MFloatScratchSpace coordAverageOut(m_noSpongeZonesOut, AT_, "coordAverageOut");
      MFloatScratchSpace comm_buff_scratch(2 * m_noSpongeZonesIn + 2 * m_noSpongeZonesOut + 40, AT_,
                                           "comm_buff_scratch");
      MFloatScratchSpace comm_buff_result_scratch(2 * m_noSpongeZonesIn + 2 * m_noSpongeZonesOut + 40, AT_,
                                                  "comm_buff_result_scratch");
      MFloat* comm_buff = comm_buff_scratch.getPointer();
      MFloat* comm_buff_result = comm_buff_result_scratch.getPointer();
      MFloat bBox[6];
      auto* tmp = new MFloat[6];
      m_geometry->getBoundingBox(tmp);
      bBox[0] = tmp[0];
      bBox[1] = tmp[3];
      bBox[2] = tmp[1];
      bBox[3] = tmp[4];
      bBox[4] = tmp[2];
      bBox[5] = tmp[5];
      constexpr MFloat directionSign[6] = {1.0, -1.0, 1.0, -1.0, 1.0, -1.0};
      constexpr MInt directionDim[6] = {0, 0, 1, 1, 2, 2};
      constexpr MInt otherDirection[6] = {1, 0, 3, 2, 5, 4};
      const MFloat cellLength = c_cellLengthAtLevel(maxRefinementLevel());
      const MFloat R = 2.0;
      MInt counter_r[noRSteps];
      for(MInt i = 0; i < noRSteps; i++) {
        m_uNormal_r[i] = F0;
        counter_r[i] = 0;
      }
      const MFloat rDiff = R / noRSteps;

      //      ---------------------

      for(MInt i = 0; i < m_noSpongeZonesIn; i++) {
        densityIn[i] = F0;
        pressureIn[i] = F0;
        spongeVolumeIn[i] = F0;
        coordAverageIn[i] = bBox[m_spongeDirectionsIn[i]]
                            + directionSign[m_spongeDirectionsIn[i]] * m_spongeAveragingIn[i] * cellLength;
        m_coordSpongeIn[i] = m_spongeCoord[m_spongeDirectionsIn[i]];
        if(m_secondSpongeDirectionsIn[i] > -1) {
          m_secondCoordSpongeIn[i] =
              F1B2 * (bBox[m_secondSpongeDirectionsIn[i]] + bBox[otherDirection[m_secondSpongeDirectionsIn[i]]]);
        } else {
          m_secondSpongeDirectionsIn[i] = m_spongeDirectionsIn[i];
          m_secondCoordSpongeIn[i] = bBox[otherDirection[m_secondSpongeDirectionsIn[i]]];
        }
      }
      for(MInt i = 0; i < m_noSpongeZonesOut; i++) {
        densityOut[i] = F0;
        pressureOut[i] = F0;
        spongeVolumeOut[i] = F0;
        coordAverageOut[i] = bBox[m_spongeDirectionsOut[i]]
                             + directionSign[m_spongeDirectionsOut[i]] * m_spongeAveragingOut[i] * cellLength;
        m_coordSpongeOut[i] = m_spongeCoord[m_spongeDirectionsOut[i]];
        if(m_secondSpongeDirectionsOut[i] > -1) {
          m_secondCoordSpongeOut[i] =
              F1B2 * (bBox[m_secondSpongeDirectionsOut[i]] + bBox[otherDirection[m_secondSpongeDirectionsOut[i]]]);
        } else {
          m_secondSpongeDirectionsOut[i] = m_spongeDirectionsOut[i];
          m_secondCoordSpongeOut[i] = bBox[otherDirection[m_secondSpongeDirectionsOut[i]]];
        }
      }

      for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
        if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
          continue;
        }
        if(a_hasProperty(cellId, SolverCell::IsInvalid)) {
          continue;
        }
        if(!a_hasProperty(cellId, SolverCell::IsActive)) {
          continue;
        }

        for(MInt i = 0; i < m_noSpongeZonesIn; i++) {
          if(!a_isBndryGhostCell(cellId)
             && (a_coordinate(cellId, directionDim[m_spongeDirectionsIn[i]]) - coordAverageIn[i])
                        * directionSign[m_spongeDirectionsIn[i]]
                    < F0
             && (a_coordinate(cellId, directionDim[m_secondSpongeDirectionsIn[i]]) - m_secondCoordSpongeIn[i])
                        * directionSign[m_secondSpongeDirectionsIn[i]]
                    < F0) {
            pressureIn[i] += a_pvariable(cellId, PV->P) * a_cellVolume(cellId);
            spongeVolumeIn[i] += a_cellVolume(cellId);
            if(a_bndryId(cellId) > -1) {
              for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_noSrfcs; srfc++) {
                const MInt ghostCellId =
                    m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_srfcVariables[srfc]->m_ghostCellId;
                pressureIn[i] += a_pvariable(ghostCellId, PV->P) * a_cellVolume(ghostCellId);
                spongeVolumeIn[i] += a_cellVolume(ghostCellId);
              }
            }
          }
        }
        for(MInt i = 0; i < m_noSpongeZonesOut; i++) {
          if(!a_isBndryGhostCell(cellId)
             && (a_coordinate(cellId, directionDim[m_spongeDirectionsOut[i]]) - coordAverageOut[i])
                        * directionSign[m_spongeDirectionsOut[i]]
                    < F0
             && (a_coordinate(cellId, directionDim[m_secondSpongeDirectionsOut[i]]) - m_secondCoordSpongeOut[i])
                        * directionSign[m_secondSpongeDirectionsOut[i]]
                    < F0) {
            densityOut[i] += a_pvariable(cellId, PV->RHO) * a_cellVolume(cellId);
            spongeVolumeOut[i] += a_cellVolume(cellId);

            const MFloat r = sqrt(POW2(a_coordinate(cellId, 1)) + POW2(a_coordinate(cellId, 2)));
            const auto rIndex = (MInt)((R - r) / rDiff);
            m_uNormal_r[rIndex] += a_pvariable(cellId, PV->U);
            counter_r[rIndex]++;
          }
        }
      }


      for(MInt i = 0; i < m_noSpongeZonesIn; i++) {
        comm_buff[2 * i] = pressureIn[i];
        comm_buff[2 * i + 1] = spongeVolumeIn[i];
      }
      // FIXME labels:FV The following buffer is not used later, so what is the purpose of densityOut & spongeVolumeOut
      for(MInt i = 0; i < m_noSpongeZonesOut; i++) {
        comm_buff[2 * m_noSpongeZonesIn + 2 * i] = densityOut[i];
        comm_buff[2 * m_noSpongeZonesIn + 2 * i + 1] = spongeVolumeOut[i];
      }
      for(MInt i = 0; i < 20; i++) {
        comm_buff[2 * m_noSpongeZonesIn + 2 * m_noSpongeZonesOut + i] = m_uNormal_r[i];
        comm_buff[2 * m_noSpongeZonesIn + 2 * m_noSpongeZonesOut + 20 + i] = counter_r[i];
      }

      MPI_Allreduce(comm_buff, comm_buff_result, 2 * (m_noSpongeZonesIn + m_noSpongeZonesOut) + 40, MPI_DOUBLE, MPI_SUM,
                    comm_sponge, AT_, "comm_buff", "comm_buff_result");

      for(MInt i = 0; i < m_noSpongeZonesIn; i++) {
        pressureIn[i] = comm_buff_result[2 * i] / comm_buff_result[2 * i + 1];
        densityIn[i] = sysEqn().density_IR_P(pressureIn[i]);
      }
      for(MInt i = 0; i < noRSteps; i++) {
        m_uNormal_r[i] = comm_buff_result[i + 2 * (m_noSpongeZonesIn + m_noSpongeZonesOut)]
                         / comm_buff_result[i + 2 * (m_noSpongeZonesIn + m_noSpongeZonesOut) + 20];
        if(m_uNormal_r[i] < F0) {
          m_uNormal_r[i] = F0;
        }
      }

      // only pressureIn is saved in values, since the other values can be deduced later
      if(m_noSpongeZonesIn > 6)
        mTerm(1, AT_,
              "FvCartesianSolverXD::computeTargetValues(): For noSpongeZonesIn>6 the code needs to be "
              "modified.");

      for(MInt i = 0; i < m_noSpongeZonesIn; i++)
        values[i] = pressureIn[i];

      return values;
    }

    // Sponge for jets from (chevron) nozzle
    case 1174: {
      const MFloat pressureAmbient = m_PInfinity;
      const MFloat densityAmbient = m_rhoInfinity;

      const MFloat pressure_i = m_nozzleInletP;
      const MFloat density_i = m_nozzleInletRho;

      values[0] = density_i;
      values[1] = pressure_i;

      values[2] = densityAmbient;
      values[3] = pressureAmbient;

      break;
    }

    case 47: {
      MInt ghostCellId;
      MFloatScratchSpace comm_buff_scratch(6, AT_, "comm_buff_scratch");
      MFloatScratchSpace comm_buff_result_scratch(6, AT_, "comm_buff_result_scratch");
      MFloat* comm_buff = comm_buff_scratch.getPointer();
      MFloat* comm_buff_result = comm_buff_result_scratch.getPointer();
      MFloat density = F0;
      MFloat spongeVolume = F0;
      MFloat pressureIn1 = F0;
      MFloat spongeVolumeIn1 = F0;
      MFloat pressureIn2 = F0;
      MFloat spongeVolumeIn2 = F0;
      MFloat u_in1 = F0;
      MFloat v_in1 = F0;
      MFloat w_in1 = F0;
      MFloat u_in2 = F0;
      MFloat v_in2 = F0;
      MFloat w_in2 = F0;
      for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
        if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
          continue;
        }
        if(a_hasProperty(cellId, SolverCell::IsInvalid)) {
          continue;
        }
        if(!a_hasProperty(cellId, SolverCell::IsActive)) {
          continue;
        }
        if(a_hasProperty(cellId, SolverCell::IsHalo)) continue;
        if(!a_isBndryGhostCell(cellId) && a_coordinate(cellId, 2) < -67.0) {
          density += a_pvariable(cellId, PV->RHO) * a_cellVolume(cellId);
          spongeVolume += a_cellVolume(cellId);
        }
        if(!a_isBndryGhostCell(cellId) && a_coordinate(cellId, 0) > 82.0 && a_coordinate(cellId, 1) > 0.0) {
          pressureIn1 += a_pvariable(cellId, PV->P) * a_cellVolume(cellId);
          u_in1 += a_pvariable(cellId, PV->U) * a_cellVolume(cellId);
          v_in1 += a_pvariable(cellId, PV->V) * a_cellVolume(cellId);
          w_in1 += a_pvariable(cellId, PV->W) * a_cellVolume(cellId);
          spongeVolumeIn1 += a_cellVolume(cellId);
          if(a_bndryId(cellId) > -1) {
            for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_noSrfcs; srfc++) {
              ghostCellId = m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_srfcVariables[srfc]->m_ghostCellId;
              pressureIn1 += a_pvariable(ghostCellId, PV->P) * a_cellVolume(ghostCellId);
              spongeVolumeIn1 += a_cellVolume(ghostCellId);
            }
          }
        }
        if(!a_isBndryGhostCell(cellId) && a_coordinate(cellId, 0) > 82.0 && a_coordinate(cellId, 1) < 0.0) {
          pressureIn2 += a_pvariable(cellId, PV->P) * a_cellVolume(cellId);
          u_in2 += a_pvariable(cellId, PV->U) * a_cellVolume(cellId);
          v_in2 += a_pvariable(cellId, PV->V) * a_cellVolume(cellId);
          w_in2 += a_pvariable(cellId, PV->W) * a_cellVolume(cellId);
          spongeVolumeIn2 += a_cellVolume(cellId);
          if(a_bndryId(cellId) > -1) {
            for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_noSrfcs; srfc++) {
              ghostCellId = m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_srfcVariables[srfc]->m_ghostCellId;
              pressureIn2 += a_pvariable(ghostCellId, PV->P) * a_cellVolume(ghostCellId);
              u_in2 += a_pvariable(ghostCellId, PV->U) * a_cellVolume(ghostCellId);
              v_in2 += a_pvariable(ghostCellId, PV->V) * a_cellVolume(ghostCellId);
              w_in2 += a_pvariable(ghostCellId, PV->W) * a_cellVolume(ghostCellId);
              spongeVolumeIn2 += a_cellVolume(ghostCellId);
            }
          }
        }
      }
      comm_buff[0] = density;
      comm_buff[1] = pressureIn1;
      comm_buff[2] = pressureIn2;
      comm_buff[3] = spongeVolume;
      comm_buff[4] = spongeVolumeIn1;
      comm_buff[5] = spongeVolumeIn2;
      MPI_Allreduce(comm_buff, comm_buff_result, 6, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "comm_buff",
                    "comm_buff_result");
      density = comm_buff_result[0] / comm_buff_result[3];
      MFloat pressure = m_PInfinity - m_deltaPL;
      pressureIn1 = comm_buff_result[1] / comm_buff_result[4];
      MFloat densityIn1 = sysEqn().density_IR_P(pressureIn1);
      pressureIn2 = comm_buff_result[2] / comm_buff_result[5];
      MFloat densityIn2 = sysEqn().density_IR_P(pressureIn2);
      if(globalTimeStep < 550) {
        pressureIn1 = sysEqn().p_Ref();
        densityIn1 = 1.0;
        pressureIn2 = pressureIn1;
        densityIn2 = densityIn1;
      }
      values[0] = density;
      values[1] = pressure;
      values[2] = densityIn1;
      values[3] = pressureIn1;
      values[4] = densityIn2;
      values[5] = pressureIn2;
      return values;
    }


    default: {
      values[0] = m_rhoInfinity;
      values[1] = m_PInfinity;
      values[2] = m_rhoInfinity;
      values[3] = m_PInfinity;
      values[4] = m_rhoInfinity;
      values[5] = m_PInfinity;
      return values;
    }

    // forced response velocity profile, forcing via sponge layer
    // This sponge has been moved from fvsolver2d.cpp, so evtl. you can have a look there
    case 17515: {
      IF_CONSTEXPR(nDim == 3) mTerm(-1, "Info: This sponge layer type only works in 2D.");

      MFloat pressure;
      MFloat maxSpongeFactor1 = -999999, minSpongeFactor1 = 999999;
      MFloat maxSpongeFactor2 = -999999, minSpongeFactor2 = 999999;
      MFloat maxSpongeFactor3 = -999999, minSpongeFactor3 = 999999;
      MFloat spongeEndFactor = -99999;
      //---
      // save previous mean pressure for weighting
      const MFloat backupMeanPressure = m_meanPressure;

      m_meanPressure = F0;
      // compute the mean pressure for all cells in the sponge zone below the reaction zone
      MInt counter = 0;
      for(MInt c = 0; c < m_noCellsInsideSpongeLayer; c++) {
        const MInt cellId = m_cellsInsideSpongeLayer[c];
        if(a_spongeBndryId(cellId, 0) == 176191 || a_spongeBndryId(cellId, 1) == 176191
           || a_spongeBndryId(cellId, 0) == 209104 || a_spongeBndryId(cellId, 1) == 209104
           || a_spongeBndryId(cellId, 0) == 209101 || a_spongeBndryId(cellId, 1) == 209101
           || a_spongeBndryId(cellId, 0) == 17616 || a_spongeBndryId(cellId, 1) == 17616
           || a_spongeBndryId(cellId, 0) == 3906 || a_spongeBndryId(cellId, 1) == 3906
           || a_spongeBndryId(cellId, 0) == 39060 || a_spongeBndryId(cellId, 1) == 39060
           || a_spongeBndryId(cellId, 0) == 209102 || a_spongeBndryId(cellId, 1) == 209102) {
          counter++;
          m_meanPressure += a_pvariable(cellId, PV->P);
        }
      }

      MPI_Allreduce(MPI_IN_PLACE, &m_meanPressure, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                    "m_meanPressure");
      MPI_Allreduce(MPI_IN_PLACE, &counter, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "counter");

      m_meanPressure /= (MFloat)counter;

      if(!m_forcing) {
        for(MInt c = 0; c < m_noCellsInsideSpongeLayer; c++) {
          const MInt cellId = m_cellsInsideSpongeLayer[c];
          // search for time dependent sponge id and set new sigma sponge
          if(m_spongeTimeDep) {
            for(MInt bcId = 0; bcId < m_noSpongeBndryCndIds; bcId++) {
              const MInt bcSpId = m_spongeBndryCndIds[bcId];

              if(a_spongeBndryId(cellId, 0) != bcSpId && a_spongeBndryId(cellId, 1) != bcSpId) continue;

              // Jerry - Changed double sponge for looking after time dependence before skipping it.
              MInt bcId2 = -2;
              MInt bcSpId2 = -2;
              if(a_spongeBndryId(cellId, 1) != -1) {
                if(a_spongeBndryId(cellId, 1) == bcSpId) {
                  bcSpId2 = a_spongeBndryId(cellId, 0);
                } else {
                  bcSpId2 = a_spongeBndryId(cellId, 1);
                }

                for(MInt k = 0; k < m_noSpongeBndryCndIds; ++k) {
                  if(m_spongeBndryCndIds[k] == bcSpId2) {
                    bcId2 = k;
                    break;
                  }
                }

                //                  if (m_spongeTimeDependent[bcId2]<1) {
                //                    continue;
                //                  }
              }
              if(bcId2 != -2) {
                if(m_spongeTimeDependent[bcId] < 1 && m_spongeTimeDependent[bcId2] < 1) continue;

              } else {
                if(m_spongeTimeDependent[bcId] < 1) continue;
              }

              //                if(a_spongeBndryId(cellId, 0) != bcSpId && a_spongeBndryId(cellId, 1) != bcSpId) {
              //                  continue;
              //                }

              // sponge decreasing function from spongeFactorStart down to zero via tanh function / sponge edges treated
              // separately
              if(m_spongeTimeDependent[bcId] == 1 || m_spongeTimeDependent[bcId2] == 1) {
                if(a_spongeBndryId(cellId, 0) == bcSpId && a_spongeBndryId(cellId, 1) == -1) {
                  if(globalTimeStep >= (MInt)m_spongeStartIteration[bcId]
                     && globalTimeStep <= (MInt)m_spongeEndIteration[bcId]) {
                    const MFloat spongeDiff = m_spongeEndIteration[bcId] - m_spongeStartIteration[bcId];
                    a_spongeFactor(cellId) =
                        F1B2 * tanh(5.0)
                        - F1B2
                              * tanh((F2 * ((MFloat)globalTimeStep - m_spongeStartIteration[bcId]) - spongeDiff) * 5.0
                                     / spongeDiff);
                    a_spongeFactor(cellId) *= a_spongeFactorStart(cellId);

                    maxSpongeFactor1 = mMax(a_spongeFactor(cellId), maxSpongeFactor1);
                    minSpongeFactor1 = mMin(a_spongeFactor(cellId), minSpongeFactor1);

                    if(approx(a_spongeFactorStart(cellId), -1.0, MFloatEps)) {
                      cerr << "sponge time dependent error, see code in fvbndrycnd2d.cpp or fvsolver2d.cpp" << endl;
                    }

                  } else if(globalTimeStep < (MInt)m_spongeStartIteration[bcId]) {
                    a_spongeFactor(cellId) = a_spongeFactorStart(cellId);

                    maxSpongeFactor1 = mMax(a_spongeFactor(cellId), maxSpongeFactor1);
                    minSpongeFactor1 = mMin(a_spongeFactor(cellId), minSpongeFactor1);

                  } else if(globalTimeStep > (MInt)m_spongeEndIteration[bcId]) {
                    a_spongeFactor(cellId) = F0;
                    maxSpongeFactor1 = F0;
                    minSpongeFactor1 = F0;
                  }
                } else {
                  // take dir
                  MInt s2;
                  MInt bcIdS;
                  MInt bcIdT;
                  if(m_spongeTimeDependent[bcId] == 1) {
                    bcIdS = bcId2;
                    bcIdT = bcId;
                  } else if(m_spongeTimeDependent[bcId2] == 1) {
                    bcIdS = bcId;
                    bcIdT = bcId2;

                  } else {
                    stringstream errorMessage;
                    errorMessage << "ERROR: sponge time dependent";
                    mTerm(1, AT_, errorMessage.str());
                  }
                  switch(m_spongeDirections[bcIdS]) {
                    case 1:
                      s2 = 0;
                      break;
                    case 0:
                      s2 = 0;
                      break;
                    case 3:
                      s2 = 1;
                      break;
                    case 2:
                      s2 = 1;
                      break;
                    case 5:
                      s2 = 2;
                      break;
                    case 4:
                      s2 = 2;
                      break;
                    default: {
                      mTerm(1, AT_, "wrong sponge direction selected during solver run, how can this happen?!");
                    }
                  }
                  // calculate sponge end factor which depends on distance to the according wall
                  MFloat spongeEpsilon = c_cellLengthAtLevel(maxLevel()) / 1000.0;
                  MFloat spongeFactorBcId = m_spongeLayerThickness * abs(m_spongeFactor[bcIdS]);
                  MFloat spongeDistanceFactor = F1 / (mMax(spongeEpsilon, spongeFactorBcId));
                  MFloat spongeDistance = abs(a_coordinate(cellId, s2) - m_spongeCoord[bcIdS]) * spongeDistanceFactor;
                  spongeEndFactor = pow(spongeDistance, m_spongeBeta);
                  spongeEndFactor *= m_sigmaSpongeBndryId[bcIdS];
                  if(globalTimeStep <= 1 && bcId2 != -2) {
                    m_log << "spongeEnd " << spongeEndFactor << endl;
                  }
                  if(globalTimeStep >= (MInt)m_spongeStartIteration[bcIdT]
                     && globalTimeStep <= (MInt)m_spongeEndIteration[bcIdT]) {
                    const MFloat spongeDiff = m_spongeEndIteration[bcIdT] - m_spongeStartIteration[bcIdT];
                    // calculate the sponge end factor via sigma sponge ratio in order to keep the factor distance
                    // dependent
                    //			spongeEndFactor = a_spongeFactorStart( cellId ) /m_sigmaSpongeBndryId[bcIdTT];
                    // spongeEndFactor *=m_sigmaEndSpongeBndryId[bcIdTT];

                    //			spongeFactorDiff = a_spongeFactorStart( cellId )  - spongeEndFactor;
                    const MFloat spongeFactorDiff = spongeEndFactor - a_spongeFactorStart(cellId);
                    a_spongeFactor(cellId) =
                        a_spongeFactorStart(cellId) + (spongeFactorDiff / spongeDiff) * globalTimeStep;
                    //			a_spongeFactor( cellId )  = spongeFactorDiff * (F1 + F1B2 * tanh(5.0) - F1B2 * tanh((F2 *
                    //((MFloat)globalTimeStep - m_spongeStartIteration[bcIdT]) - spongeDiff) * 5.0 / spongeDiff));

                    maxSpongeFactor1 = mMax(a_spongeFactor(cellId), maxSpongeFactor1);
                    minSpongeFactor1 = mMin(a_spongeFactor(cellId), minSpongeFactor1);

                    if(approx(a_spongeFactorStart(cellId), -1.0, MFloatEps)) {
                      cerr << "sponge time dependent error, see code in fvbndrycnd2d.cpp or fvsolver2d.cpp" << endl;
                    }


                  } else if(globalTimeStep < (MInt)m_spongeStartIteration[bcIdT]) {
                    a_spongeFactor(cellId) = a_spongeFactorStart(cellId);

                    maxSpongeFactor1 = mMax(a_spongeFactor(cellId), maxSpongeFactor1);
                    minSpongeFactor1 = mMin(a_spongeFactor(cellId), minSpongeFactor1);

                  } else if(globalTimeStep > (MInt)m_spongeEndIteration[bcIdT]) {
                    a_spongeFactor(cellId) = spongeEndFactor;
                    maxSpongeFactor1 = F0;
                    minSpongeFactor1 = F0;
                  }
                }
                break;
                // sponge rising function from zero up to spongeFactorStart (calculated dependent on distance to the
                // wall, see spongeLayerLayout)
              } else if(m_spongeTimeDependent[bcId] == 2) {
                if(globalTimeStep >= (MInt)m_spongeStartIteration[bcId]
                   && globalTimeStep <= (MInt)m_spongeEndIteration[bcId]) {
                  const MFloat spongeDiff = m_spongeEndIteration[bcId] - m_spongeStartIteration[bcId];
                  a_spongeFactor(cellId) =
                      F1 - F1B2 * tanh(5.0)
                      + F1B2
                            * tanh((F2 * ((MFloat)globalTimeStep - m_spongeStartIteration[bcId]) - spongeDiff) * 5.0
                                   / spongeDiff);
                  a_spongeFactor(cellId) *= a_spongeFactorStart(cellId);

                  maxSpongeFactor2 = mMax(a_spongeFactor(cellId), maxSpongeFactor2);
                  minSpongeFactor2 = mMin(a_spongeFactor(cellId), minSpongeFactor2);

                  if(approx(a_spongeFactorStart(cellId), -1.0, MFloatEps)) {
                    cerr << "sponge time dependent error, see code in fvbndrycnd2d.cpp or fvsolver2d.cpp" << endl;
                  }

                } else if(globalTimeStep < m_spongeStartIteration[bcId]) {
                  a_spongeFactor(cellId) = F0;
                  maxSpongeFactor2 = F0;
                  minSpongeFactor2 = F0;

                } else if(globalTimeStep > m_spongeEndIteration[bcId]) {
                  a_spongeFactor(cellId) = a_spongeFactorStart(cellId);
                  maxSpongeFactor2 = mMax(a_spongeFactor(cellId), maxSpongeFactor2);
                  minSpongeFactor2 = mMin(a_spongeFactor(cellId), minSpongeFactor2);
                }
                break;
                // sponge decreasing function from spongeFactor down to spongeEndFactor (calculated dependent on
                // distance to the wall, see spongeLayerLayout)
              } else if(m_spongeTimeDependent[bcId] == 3) {
                if(globalTimeStep >= (MInt)m_spongeStartIteration[bcId]
                   && globalTimeStep <= (MInt)m_spongeEndIteration[bcId]) {
                  const MFloat spongeDiff = m_spongeEndIteration[bcId] - m_spongeStartIteration[bcId];
                  // calculate the sponge end factor via sigma sponge ratio in order to keep the factor distance
                  // dependent
                  spongeEndFactor = a_spongeFactorStart(cellId) / m_sigmaSpongeBndryId[bcId];
                  spongeEndFactor *= m_sigmaEndSpongeBndryId[bcId];

                  const MFloat spongeFactorDiff = a_spongeFactorStart(cellId) - spongeEndFactor;

                  a_spongeFactor(cellId) =
                      spongeFactorDiff
                      * (F1 + F1B2 * tanh(5.0)
                         - F1B2
                               * tanh((F2 * ((MFloat)globalTimeStep - m_spongeStartIteration[bcId]) - spongeDiff) * 5.0
                                      / spongeDiff));

                  maxSpongeFactor3 = mMax(a_spongeFactor(cellId), maxSpongeFactor3);
                  minSpongeFactor3 = mMin(a_spongeFactor(cellId), minSpongeFactor3);

                  if(approx(a_spongeFactorStart(cellId), -1.0, MFloatEps)) {
                    cerr << "sponge time dependent error, see code in fvbndrycnd2d.cpp or fvsolver2d.cpp" << endl;
                  }

                  // before increasing function, set the sponge factor to the initial spongeFactor
                } else if(globalTimeStep < m_spongeStartIteration[bcId]) {
                  a_spongeFactor(cellId) = a_spongeFactorStart(cellId);
                  maxSpongeFactor3 = mMax(a_spongeFactor(cellId), maxSpongeFactor3);
                  minSpongeFactor3 = mMin(a_spongeFactor(cellId), minSpongeFactor3);

                  // calculate the sponge end factor via sigma sponge ratio in order to keep the factor distance
                  // dependent
                } else if(globalTimeStep > m_spongeEndIteration[bcId]) {
                  spongeEndFactor = a_spongeFactorStart(cellId) / m_sigmaSpongeBndryId[bcId];
                  spongeEndFactor *= m_sigmaEndSpongeBndryId[bcId];
                  a_spongeFactor(cellId) = spongeEndFactor;
                  maxSpongeFactor3 = mMax(spongeEndFactor, maxSpongeFactor3);
                  minSpongeFactor3 = mMin(spongeEndFactor, minSpongeFactor3);
                }
                break;
                // sponge rising function from desired start factor up to spongeEndFactor (calculated dependent on
                // distance to the wall, see spongeLayerLayout)
              } else if(m_spongeTimeDependent[bcId] == 4) {
                if(globalTimeStep >= (MInt)m_spongeStartIteration[bcId]
                   && globalTimeStep <= (MInt)m_spongeEndIteration[bcId]) {
                  const MFloat spongeDiff = m_spongeEndIteration[bcId] - m_spongeStartIteration[bcId];
                  // calculate the sponge end factor via sigma sponge ratio in order to keep the factor distance
                  // dependent
                  spongeEndFactor = a_spongeFactorStart(cellId) / m_sigmaSpongeBndryId[bcId];
                  spongeEndFactor *= m_sigmaEndSpongeBndryId[bcId];

                  const MFloat spongeFactorDiff = spongeEndFactor - a_spongeFactorStart(cellId);

                  a_spongeFactor(cellId) =
                      a_spongeFactorStart(cellId)
                      + spongeFactorDiff
                            * (F1 - F1B2 * tanh(5.0)
                               + F1B2
                                     * tanh((F2 * ((MFloat)globalTimeStep - m_spongeStartIteration[bcId]) - spongeDiff)
                                            * 5.0 / spongeDiff));

                  maxSpongeFactor2 = mMax(a_spongeFactor(cellId), maxSpongeFactor2);
                  minSpongeFactor2 = mMin(a_spongeFactor(cellId), minSpongeFactor2);

                  if(approx(a_spongeFactorStart(cellId), -1.0, MFloatEps)) {
                    cerr << "sponge time dependent error, see code in fvbndrycnd2d.cpp or fvsolver2d.cpp" << endl;
                  }

                } else if(globalTimeStep < m_spongeStartIteration[bcId]) {
                  a_spongeFactor(cellId) = F0;
                  maxSpongeFactor2 = F0;
                  minSpongeFactor2 = F0;

                } else if(globalTimeStep > m_spongeEndIteration[bcId]) {
                  a_spongeFactor(cellId) = a_spongeFactorStart(cellId);
                  maxSpongeFactor2 = mMax(a_spongeFactor(cellId), maxSpongeFactor2);
                  minSpongeFactor2 = mMin(a_spongeFactor(cellId), minSpongeFactor2);
                }
                break;
              }
            } // for(MInt bcId = 0; bcId < m_noSpongeBndryCndIds; bcId++) ends here
          }   // if(m_spongeTimeDep) ends here
        }     // for(MInt c = 0; c < m_noCellsInsideSpongeLayer; c++) ends here

        if(m_spongeTimeDep) {
          if(m_RKStep == m_noRKSteps - 1 && globalTimeStep % 1000) {
            if(noDomains() > 1) {
              MPI_Allreduce(MPI_IN_PLACE, &maxSpongeFactor1, 1, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                            "maxSpongeFactor1");
              MPI_Allreduce(MPI_IN_PLACE, &maxSpongeFactor2, 1, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                            "maxSpongeFactor2");
              MPI_Allreduce(MPI_IN_PLACE, &maxSpongeFactor3, 1, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                            "maxSpongeFactor3");
              MPI_Allreduce(MPI_IN_PLACE, &minSpongeFactor1, 1, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE",
                            "minSpongeFactor1");
              MPI_Allreduce(MPI_IN_PLACE, &minSpongeFactor2, 1, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE",
                            "minSpongeFactor2");
              MPI_Allreduce(MPI_IN_PLACE, &minSpongeFactor3, 1, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE",
                            "minSpongeFactor3");
            }
            if(domainId() == 0) {
              FILE* datei;
              datei = fopen("spongeFactor", "a+");
              fprintf(datei, " %d", globalTimeStep);
              fprintf(datei, " %f", m_time);
              fprintf(datei, " %-10.8f", maxSpongeFactor1);
              fprintf(datei, " %-10.8f", minSpongeFactor1);
              fprintf(datei, " %-10.8f", maxSpongeFactor2);
              fprintf(datei, " %-10.8f", minSpongeFactor2);
              fprintf(datei, " %-10.8f", maxSpongeFactor3);
              fprintf(datei, " %-10.8f", minSpongeFactor3);
              fprintf(datei, "\n");
              fclose(datei);
            }
          }
        }

        // compute target pressure & density
        // later in computeSpongeDeltas the appropriate one is chosen depending on cellId
        // --- Case 1 ---
        MFloat pressureLoss = F0;
        if(m_plenum) {
          pressureLoss = m_rhoInfinity * POW2(m_VInfinity) * (m_inletTubeAreaRatio - F1);
        }
        // pressure loss = pressure Loss (Inlet -> flame tube) + pressure Loss (Flame surface -> Outlet)
        if(m_plenumWall) {
          pressureLoss += m_rhoFlameTube * m_targetDensityFactor
                          * (POW2(m_velocityOutlet) - POW2(m_flameSpeed) * m_flameOutletAreaRatio);
        }

        if(m_plenum) {
          pressure =
              m_PInfinity + m_rhoInfinity * POW2(m_VInfinity) * (m_burntUnburntTemperatureRatio - F1) + pressureLoss;
        } else {
          pressure =
              m_PInfinity + m_rhoInfinity * POW2(m_flameSpeed) * (m_burntUnburntTemperatureRatio - F1) + pressureLoss;
        }

        if(m_confinedFlame) {
          pressure = backupMeanPressure * (m_spongeWeight - 1) / m_spongeWeight; // m_PInfinity + m_deltaPL;
          pressure += m_meanPressure / m_spongeWeight;
          /*
MFloat tubeLength = 4.01;
MFloat outletLength = 15.0;
MFloat outletDiameter = 1.006*2;
pressure+= F3B2*m_muInfinity*(tubeLength/POW3(2*m_radiusVelFlameTube))*m_VInfinity;
pressure+=
F3B2*SUTHERLANDLAW(m_burntUnburntTemperatureRatio)*(outletLength/(POW3(outletDiameter)))*m_velocityOutlet;*/
        }
        // --- Case 1 ends ---

        // --- Case 2 ---
        MFloat outflowPressure = m_pressureFlameTube;
        MFloat outflowDensity = m_rhoFlameTube * m_targetDensityFactor;
        if(m_confinedFlame) {
          outflowPressure = m_jetPressure;
          //		outflowDensity = m_jetDensity;
        }
        // --- Case 2 ends ---

        values[0] = m_rhoInfinity;
        values[1] = pressure;
        values[2] = outflowDensity;
        values[3] = outflowPressure;

      } else { // if(!forcing) ends here

        // compute target pressure & density
        // later in computeSpongeDeltas the appropriate one is chosen depending on cellId
        // --- Case 1 ---
        MFloat pressureLoss = F0;
        if(m_plenum) {
          pressureLoss = m_rhoInfinity * POW2(m_VInfinity) * (m_inletTubeAreaRatio - F1);
        }
        // pressure loss = pressure Loss (Inlet -> flame tube) + pressure Loss (Flame surface -> Outlet)
        if(m_plenumWall) {
          pressureLoss += m_rhoFlameTube * m_targetDensityFactor
                          * (POW2(m_velocityOutlet) - POW2(m_flameSpeed) * m_flameOutletAreaRatio);
        }

        if(m_plenum) {
          pressure =
              m_PInfinity + m_rhoInfinity * POW2(m_VInfinity) * (m_burntUnburntTemperatureRatio - F1) + pressureLoss;
        } else {
          pressure =
              m_PInfinity + m_rhoInfinity * POW2(m_flameSpeed) * (m_burntUnburntTemperatureRatio - F1) + pressureLoss;
        }

        if(m_confinedFlame) {
          pressure = m_PInfinity + m_deltaPL;
          /*
MFloat tubeLength = 4.01;
MFloat outletLength = 15.0;
MFloat outletDiameter = 1.006*2;
pressure+= F3B2*m_muInfinity*(tubeLength/POW3(2*m_radiusVelFlameTube))*m_VInfinity;
pressure+=
F3B2*SUTHERLANDLAW(m_burntUnburntTemperatureRatio)*(outletLength/(POW3(outletDiameter)))*m_velocityOutlet;
*/
        }
        // --- Case 1 ends ---
        values[0] = m_rhoInfinity;
        values[1] = pressure;

        // --- Case 2 ---
        // rhoFlameTubem, pressureFlameTube is set to infinity values if a plenum isn't used.
        values[2] = m_rhoFlameTube * m_targetDensityFactor;
        values[3] = m_pressureFlameTube;
        // --- Case 2 ends ---
      }
      break;
    }
      // maybe keep these comments:
      // they might be useful if somebody needs the above kind of sponge for a testcase but encounters some problems...
      // the below case numbers were very similar to the above one and weren't used in any testcases but they might
      // include solutions to some problems therefore keep this information here so that somebody who encounters a
      // problem with the above sponge can have a look at the SVN for the below case numbers
      // ---
      // case 17513
      // case 17516
      // case 17517
      // forced response velocity profile, forcing via sponge layer, without forcing u velocity to zero, otherwise
      // divergence generates pressure jump at the end of the sponge layer
      // case 1751500: {
      // using mean pressure at the outflow boundary
      // case 17515000: {
      // forced response velocity profile, forcing via sponge layer
      // case 175150: {
      // DL time dependent
      // case 19900: {

      // end of "2D cases"
  } // end of switch
  return values;
}

template <MInt nDim_, class SysEqn>
std::array<MFloat, nDim_ + 2>
FvCartesianSolverXD<nDim_, SysEqn>::computeSpongeDeltas(const MInt cellId, array<MFloat, 6> value) {
  TRACE();
  using PVars = std::array<MFloat, nDim + 2>;
  using VelA = std::array<MFloat, nDim>;

  VelA VVInfinity;
  VelA noVelocitySponge;
  MFloat noDensitySponge = a_pvariable(cellId, PV->RHO);
  MFloat noPressureSponge = a_pvariable(cellId, PV->P);
  // MFloat noViscositySponge=a_pvariable(cellId, PV->N);

  for(MInt d = 0; d < nDim; ++d) {
    VVInfinity[d] = m_VVInfinity[d];
  }
  for(MInt d = 0; d < nDim; ++d) {
    noVelocitySponge[d] = a_pvariable(cellId, PV->VV[d]);
  }
  auto pJet = [&] { return m_jet ? m_jetPressure : m_PInfinity; };
  auto rhoJet = [&] { return m_jet ? m_jetDensity : m_rhoInfinity; };
  auto from_target = [&](MFloat targetRho, VelA targetU, MFloat targetP) {
    PVars dPV;
    dPV[PV->RHO] = a_pvariable(cellId, PV->RHO) - targetRho;
    for(MInt d = 0; d < nDim; ++d) {
      dPV[PV->VV[d]] = (a_pvariable(cellId, PV->VV[d]) - targetU[d]) * targetRho;
    }
    IF_CONSTEXPR(isDetChem<SysEqn>) {
      const MFloat* const pvarsCell = &a_pvariable(cellId, 0);
      std::vector<MFloat> targetPV;
      targetPV.resize(nDim + 2 + PV->m_noSpecies);
      targetPV[PV->RHO] = targetRho;
      targetPV[PV->P] = targetP;
      for(MInt d = 0; d < nDim; ++d) {
        targetPV[PV->VV[d]] = targetU[d];
      }
      for(MInt s = 0; s < m_noSpecies; ++s) {
        targetPV[PV->Y[s]] = pvarsCell[PV->Y[s]];
      }
      MFloat sensibleEnergy = F0;
      sysEqn().evaluateSensibleEnergy(sensibleEnergy, pvarsCell, a_avariable(cellId, AV->W_MEAN));

      MFloat targetSensibleEnergy = F0;
      sysEqn().evaluateSensibleEnergy(targetSensibleEnergy, &targetPV[0], a_avariable(cellId, AV->W_MEAN));

      dPV[PV->P] = (sensibleEnergy - targetSensibleEnergy) * targetRho;
    }
    else {
      dPV[PV->P] = sysEqn().pressureEnergy(a_pvariable(cellId, PV->P) - targetP);
    }
    return dPV;
  };
  auto targetVelocityU = [&]() {
    MFloat velocityU = a_oldVariable(cellId, CV->RHO_VV[0]) * (m_spongeWeight - 1) / m_spongeWeight;
    velocityU /= a_oldVariable(cellId, CV->RHO);
    velocityU += a_variable(cellId, CV->RHO_VV[0]) / (a_variable(cellId, CV->RHO) * m_spongeWeight);
    return velocityU;
  };
  auto targetVelocityV = [&]() {
    MFloat velocityV = a_oldVariable(cellId, CV->RHO_VV[1]) * (m_spongeWeight - 1) / m_spongeWeight;
    velocityV /= a_oldVariable(cellId, CV->RHO);
    // why is this not in here as well?
    // velocityV += a_variable(cellId, CV->RHO_VV[0]) / (a_variable(cellId, CV->RHO) *
    // m_spongeWeight);
    return velocityV;
  };
  auto targetVelocityW = [&]() {
    MFloat velocityW = a_oldVariable(cellId, CV->RHO_VV[2]) * (m_spongeWeight - 1) / m_spongeWeight;
    velocityW /= a_oldVariable(cellId, CV->RHO);
    velocityW += a_variable(cellId, CV->RHO_VV[2]) / (a_variable(cellId, CV->RHO) * m_spongeWeight);
    return velocityW;
  };

  /// \property
  /// \page fvSponge List of Sponge layer types for solvertype `MAIA_FINITE_VOLUME`
  /// The change in Primitive variables are calculated as follows: <br>
  /// \f$ \Delta \rho = \rho - \rho_{t} \f$ ;
  /// \f$ \Delta \bar{V} = (\bar{V} - \bar{V}_{t})*\rho_{t} \f$ ;
  /// \f$ \Delta P = \dfrac{P - P_{t}}{\gamma - 1} \f$ <br>
  /// Thus, only one of \f$ \Delta PV \f$ or \f$ PV_t \f$ needs to be prescribed.

  switch(m_spongeLayerType) {
    case 0: {
      /// \fvspongeSwitchCase{fvSponge, 0, Pressure and Density sponge to infinity values}
      /// \f$ \rho_t = \rho_{\infty} \f$ <br>
      /// \f$ \Delta \bar{V} = 0 \f$ <br>
      /// \f$	P_t = P_{\infty} \f$ <br>
      return from_target(m_rhoInfinity, noVelocitySponge, m_PInfinity);
    }
    case 1: {
      /// \fvspongeSwitchCase{fvSponge, 1, Pressure and Density sponge}
      /// \f$ \Delta \rho = \rho \dfrac{\Delta P}{P} \f$ <br>
      /// \f$ \Delta \bar{V} = 0 \f$ <br>
      /// \f$	P_t = P_{\infty} \f$ <br>
      PVars dPVtmp;
      dPVtmp = from_target(noDensitySponge, noVelocitySponge, m_PInfinity);
      dPVtmp[PV->RHO] = a_pvariable(cellId, PV->RHO)
                        * ((a_pvariable(cellId, PV->P) + dPVtmp[PV->P]) / a_pvariable(cellId, PV->P) - 1);
      return dPVtmp;
    }
    case 3: {
      /// \fvspongeSwitchCase{fvSponge, 3, Pressure Velocity and Density sponge}
      /// \f$ \rho_t = \rho_{\infty} * f_{\rho} \f$, where \f$ f_{\rho} \f$
      /// is the targetDensityFactor <br>
      /// \f$	P_t = P_{\infty} \f$ <br>
      PVars dPVtmp;
      dPVtmp = from_target(m_rhoInfinity * m_targetDensityFactor, noVelocitySponge, m_PInfinity);
      for(MInt d = 0; d < nDim; ++d) {
        dPVtmp[PV->VV[d]] = a_pvariable(cellId, PV->VV[d]);
      }
      return dPVtmp;
    }

    case 5: {
      /// \fvspongeSwitchCase{fvSponge, 5, Channel Flow}

      PVars dPVtmp;
      dPVtmp = from_target(noDensitySponge, noVelocitySponge, value[1]);
      return dPVtmp;
    }
    case 6: {
      /// \fvspongeSwitchCase{fvSponge, 6, Pressure and Density sponge to infinity values}
      /// \f$ \rho_t = \rho_{\infty} \f$ <br>
      /// \f$ \Delta \bar{V} = 0 \f$ <br>
      /// \f$	P_t = P_{\infty} \f$ <br>
      PVars dPVtmp;
      // if ( a_coordinate(cellId, 0) > 1.0 ) {
      //   dPVtmp=from_target( value[0],
      //                       noVelocitySponge,
      //                       value[1]);
      // } else {
      dPVtmp = from_target(value[0], noVelocitySponge, value[1]);
      // }
      return dPVtmp;
    }

    case 66: {
      PVars dPVtmp;
      dPVtmp = from_target(noDensitySponge, noVelocitySponge, value[1]);
      return dPVtmp;
    }

    // Sponge layer for STG forcing
    case 77: {
      /// \fvspongeSwitchCase{fvSponge, 77, Sponge layer for STG forcing}
      PVars dPVtmp;
      dPVtmp = from_target(noDensitySponge, noVelocitySponge, noPressureSponge);

      if(m_STGSponge) {
        MFloat halfCellLength = grid().halfCellLength(cellId);
        MBool apply = false;
        if(globalTimeStep >= m_stgSpongeTimeStep) {
          for(MInt b = 0; b < m_noStgSpongePositions; b++) {
            if(abs(a_coordinate(cellId, 0) - m_stgSpongePositions[b]) < 4 * halfCellLength) {
              apply = true;
            }
          }
        }

        if(apply) {
          // Streamwise velocity cannot be negative
          if(a_pvariable(cellId, sysEqn().PV->U) > F0) {
            MFloat u_delta = m_STGSpongeFactor[0][cellId];
            MFloat rho = a_pvariable(cellId, sysEqn().PV->RHO);
            MFloat r = m_STGSpongeFactor[nDim + 1][cellId];
            dPVtmp[sysEqn().PV->U] = r * u_delta * rho;
          }
        }
      }

      // dPVtmp = from_target(noDensitySponge, velocitySponge, noPressureSponge);
      return dPVtmp;
    }

    // FAN --> Alexej Pogorelov
    case 41: {
      /// \fvspongeSwitchCase{fvSponge, 41, FAN -> Alexej Pogorelov}
      const MFloat phi_mid = 74.9355804414;
      //    const MFloat targetU = cos(phi_mid / 180.0 * PI) * m_UInfinity * 1.2539184953;
      PVars dPVtmp = from_target(m_rhoInfinity, noVelocitySponge,
                                 a_coordinate(cellId, 0) > c_cellLengthAtLevel(2) ? value[1] : m_PInfinity);
      if(a_coordinate(cellId, 0) > c_cellLengthAtLevel(2))
        dPVtmp[PV->U] = a_pvariable(cellId, PV->RHO) * a_pvariable(cellId, PV->U)
                        - cos(phi_mid / 180.0 * PI) * m_UInfinity * m_rhoInfinity * 1.2539184953;
      return dPVtmp;
    }

    // TODO labels:FV The sponge implementation in case 47 is hardcoded, but this cannot be removed from the code
    // since the testcase FV/3D_engine_SUZI_parallel uses this value. Either the test case needs to be modified
    // or the sponge implementation for case 47 needs to be generalized.
    case 47: {
      /// \fvspongeSwitchCase{fvSponge, 47, Hardcoded}
      /// \warning  The coordinate values are hardcoded in the implementation. Please
      /// see the code for detailed implementation.
      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        break;
      }
      if(a_hasProperty(cellId, SolverCell::IsInvalid)) {
        break;
      }
      if(!a_hasProperty(cellId, SolverCell::IsActive)) {
        break;
      }
      updateSpongeLayerRhs(
          cellId,
          from_target((!a_isBndryGhostCell(cellId) && a_coordinate(cellId, 2) < -50.0) ? value[0] : noDensitySponge,
                      noVelocitySponge,
                      (!a_isBndryGhostCell(cellId) && a_coordinate(cellId, 2) < -50.0) ? value[1] : noPressureSponge));
      updateSpongeLayerRhs(
          cellId,
          from_target((!a_isBndryGhostCell(cellId) && a_coordinate(cellId, 0) > 60.0 && a_coordinate(cellId, 1) > 0.0)
                          ? value[2]
                          : noDensitySponge,
                      noVelocitySponge,
                      (!a_isBndryGhostCell(cellId) && a_coordinate(cellId, 0) > 60.0 && a_coordinate(cellId, 1) > 0.0)
                          ? value[3]
                          : noPressureSponge));
      return from_target(
          (!a_isBndryGhostCell(cellId) && a_coordinate(cellId, 0) > 60.0 && a_coordinate(cellId, 1) < 0.0)
              ? value[4]
              : noDensitySponge,
          noVelocitySponge,
          (!a_isBndryGhostCell(cellId) && a_coordinate(cellId, 0) > 60.0 && a_coordinate(cellId, 1) < 0.0)
              ? value[5]
              : noPressureSponge);
    }

    case 446: {
      /// \fvspongeSwitchCase{fvSponge, 446, Pressure sponge}
      /// \f$ \Delta \rho = 0 \f$ <br>
      /// \f$ \Delta \bar{V} = 0 \f$ <br>
      /// \f$	\Delta P = \rho E - \dfrac{P_\infty}{\gamma-1}+\dfrac{1}{2} \rho {||\bar{V}||}^2 \f$ <br>
      IF_CONSTEXPR(!hasE<SysEqn>)
      mTerm(1, AT_, "Not compatible with SysEqn without RHO_E!");
      MFloat U2 = 0.0;
      PVars dPVtmp;

      for(MInt d = 0; d < nDim; ++d) {
        U2 += POW2(a_pvariable(cellId, PV->VV[d]));
      }
      dPVtmp = from_target(noDensitySponge, noVelocitySponge, noPressureSponge);
      dPVtmp[PV->P] =
          a_variable(cellId, CV->RHO_E) - sysEqn().internalEnergy(m_PInfinity, a_variable(cellId, CV->RHO), U2);
      return dPVtmp;
    }

    // (dimensional)
    case 11212: {
      /// \fvspongeSwitchCase{fvSponge, 11212, Pressure sponge to infinity}
      /// \f$ \Delta \rho = 0 \f$ <br>
      /// \f$ \Delta \bar{V} = 0 \f$ <br>
      /// \f$	P_t = P_{\infty} \f$ <br>
      return from_target(noDensitySponge, noVelocitySponge, m_PInfinity);
    }

    // (dimensional)
    case 11213: {
      /// \fvspongeSwitchCase{fvSponge, 11213, Flame}
      const MInt oneDGridSize = m_oneDimFlame->m_grid.size();
      VelA forcedVelocity;
      MInt mainAxis = 0;
      for(MInt dim = 0; dim < nDim; dim++)
        forcedVelocity[dim] = (dim == mainAxis) ? m_oneDimFlame->m_profile.velocity[oneDGridSize - 1] : F0;

      return from_target(noDensitySponge, forcedVelocity, m_PInfinity);
    }

    // (dimensional)
    case 11214: {
      /// \fvspongeSwitchCase{fvSponge, 11214, Flame}
      const MInt oneDGridSize = m_oneDimFlame->m_grid.size();

      MFloat FmeanMolarMassBurnt = F0;
      for(MUint s = 0; s < PV->m_noSpecies; ++s) {
        FmeanMolarMassBurnt +=
            m_oneDimFlame->m_profile.massFractions[m_noSpecies * (oneDGridSize - 1) + s] * m_fMolarMass[s];
      }

      const MFloat temperatureInfinityBurnt = m_oneDimFlame->m_profile.temperature[oneDGridSize - 1];
      const MFloat meanMolarMassBurnt = F1 / FmeanMolarMassBurnt;

      const MFloat rhoInfinityBurnt = m_PInfinity * meanMolarMassBurnt / (temperatureInfinityBurnt * m_gasConstant);

      const MFloat spongeRho = a_coordinate(cellId, 1) < 0 ? m_rhoInfinity : rhoInfinityBurnt;

      VelA targetV;
      targetV[0] = F0;
      targetV[1] = m_VInfinity;
      IF_CONSTEXPR(nDim == 3) targetV[1] = F0;
      if(a_coordinate(cellId, 1) < 0) {
        return from_target(spongeRho, targetV, noPressureSponge);
      } else {
        return from_target(noDensitySponge, noVelocitySponge, m_PInfinity);
      }
    }

    case 51: {
      /// \fvspongeSwitchCase{fvSponge, 51, General Sponge with Average}

      // ALLGEMEINER SPONGE MIT MITTELUNG
      IF_CONSTEXPR(nDim == 2) mTerm(-1, "Info: This sponge layer type only works in 3D.");

      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) break;
      if(a_hasProperty(cellId, SolverCell::IsInvalid)) break;
      if(!a_hasProperty(cellId, SolverCell::IsActive)) break;
      if(a_isBndryGhostCell(cellId)) break;

      constexpr MFloat directionSign[6] = {1.0, -1.0, 1.0, -1.0, 1.0, -1.0};
      constexpr MInt directionDim[6] = {0, 0, 1, 1, 2, 2};
      const MFloat Pdiff = m_deltaPL;
      MFloat fac = 1.0;
      if(m_time < m_timeOfMaxPdiff) fac = (m_time / m_timeOfMaxPdiff);
      const MFloat finalPressure = m_PInfinity - Pdiff;
      const MFloat initialPressure = sysEqn().p_Ref() - Pdiff;
      const MFloat deltaPressure = finalPressure - initialPressure;
      static constexpr MInt noRSteps = 20;
      const MFloat R = 2.0;
      const MFloat rDiff = R / noRSteps;
      PVars dPVtmp;
      dPVtmp[PV->P] = noPressureSponge;
      dPVtmp[PV->RHO] = noDensitySponge;
      std::copy_n(&dPVtmp[0], nDim, &noVelocitySponge[0]);

      for(MInt i = 0; i < m_noSpongeZonesIn; i++) {
        if((a_coordinate(cellId, directionDim[m_spongeDirectionsIn[i]]) - m_coordSpongeIn[i])
                   * directionSign[m_spongeDirectionsIn[i]]
               < F0
           && (a_coordinate(cellId, directionDim[m_secondSpongeDirectionsIn[i]]) - m_secondCoordSpongeIn[i])
                      * directionSign[m_secondSpongeDirectionsIn[i]]
                  < F0) {
          // suboptimal to recompute for each cell again, but that is how it is now
          const MFloat pressureIn = value[i];
          const MFloat densityIn = sysEqn().density_IR_P(pressureIn);
          dPVtmp[PV->P] += sysEqn().pressureEnergy(a_pvariable(cellId, PV->P) - pressureIn);
          dPVtmp[PV->RHO] += a_pvariable(cellId, PV->RHO) - densityIn;
        }
      }
      for(MInt i = 0; i < m_noSpongeZonesOut; i++) {
        if((a_coordinate(cellId, directionDim[m_spongeDirectionsOut[i]]) - m_coordSpongeOut[i])
                   * directionSign[m_spongeDirectionsOut[i]]
               < F0
           && (a_coordinate(cellId, directionDim[m_secondSpongeDirectionsOut[i]]) - m_secondCoordSpongeOut[i])
                      * directionSign[m_secondSpongeDirectionsOut[i]]
                  < F0) {
          // suboptimal to recompute for each cell again, but that is how it is now
          const MFloat pressureOut = (initialPressure + fac * deltaPressure);
          const MFloat densityOut = sysEqn().density_IR_P(pressureOut);

          dPVtmp[PV->P] += sysEqn().pressureEnergy(a_pvariable(cellId, PV->P) - pressureOut);
          dPVtmp[PV->RHO] += a_pvariable(cellId, PV->RHO) - densityOut;

          for(MInt dimId = 0; dimId < nDim; dimId++)
            dPVtmp[PV->VV[dimId]] += a_pvariable(cellId, PV->VV[dimId]);

          const MFloat r = sqrt(POW2(a_coordinate(cellId, 1)) + POW2(a_coordinate(cellId, 2)));
          const MInt rIndex = (MInt)((R - r) / rDiff);
          dPVtmp[PV->VV[0]] -= m_uNormal_r[rIndex];
        }
      }
      return dPVtmp;
    }

    case 100: {
      /// \fvspongeSwitchCase{fvSponge, 100, Jet}
      VelA VV;
      MFloat spongeDistanceFactor = F1;
      PVars tmpVars;
      if(m_velocitySponge) {
        VV[0] = targetVelocityU();
        VV[1] = targetVelocityV();
        VV[2] = targetVelocityW();
        if(a_variable(cellId, CV->RHO_VV[1]) < 0) {
          spongeDistanceFactor = F2;
          VV[1] += m_VInfinity / m_spongeWeight;
        } else {
          VV[1] += a_variable(cellId, CV->RHO_VV[1]) / (a_variable(cellId, CV->RHO) * m_spongeWeight);
        }
      } else {
        VV = noVelocitySponge;
      }
      tmpVars = from_target(rhoJet(),
                            VV,
                            (a_coordinate(cellId, 1) < m_yOffsetFlameTube - 0.5) ? rhoJet()
                                                                                 : rhoJet() * m_targetDensityFactor);
      tmpVars[PV->VV[0]] *= spongeDistanceFactor;
      return tmpVars;
    }

    case 333: {
      /// \fvspongeSwitchCase{fvSponge, 333, Velocity sponge to infinity}
      /// \f$ \Delta \rho = 0 \f$ <br>
      /// \f$ \bar{V}_t = \bar{V}_{\infty} \f$ <br>
      /// \f$	\Delta P = 0 \f$ <br>
      return from_target(noDensitySponge, VVInfinity, noPressureSponge);
    }
    case 2014: {
      /// \fvspongeSwitchCase{fvSponge, 2014, Pressure Velocity and Density sponge to infinity}
      /// \f$ \rho_t = \rho_{\infty} \f$ <br>
      /// \f$ \bar{V}_t = \bar{V}_{\infty} \f$ <br>
      /// \f$	P_t = P_{\infty} \f$ <br>
      return from_target(m_rhoInfinity, VVInfinity, m_PInfinity);
    }
    case 91900: {
      /// \fvspongeSwitchCase{fvSponge, 91900, Flame}
      VelA VV;
      if(m_velocitySponge) {
        VV[0] = targetVelocityU();
        VV[1] = targetVelocityV();
        VV[2] = targetVelocityW();
      } else {
        VV = noVelocitySponge;
      }
      return from_target(
          (a_coordinate(cellId, 1) < m_yOffsetFlameTube - 0.5 && abs(a_coordinate(cellId, 2)) < m_jetHalfLength + 0.1)
              ? rhoJet()
              : rhoJet() * m_targetDensityFactor,
          VV,
          pJet());
    }
    case 919001: {
      /// \fvspongeSwitchCase{fvSponge, 919001, Flame Hardcoded}
      /// \warning  The coordinate values are hardcoded in the implementation. Please
      /// see the code for detailed implementation.
      VelA VV;
      if(m_velocitySponge) {
        VV[0] = targetVelocityU();
        VV[1] = targetVelocityV();
        VV[2] = targetVelocityW();
      } else {
        VV = noVelocitySponge;
      }
      return from_target(
          (a_coordinate(cellId, 1) < m_yOffsetFlameTube - 0.5 && abs(a_coordinate(cellId, 2)) < m_jetHalfLength + 0.1)
              ? F0
              : rhoJet() * m_targetDensityFactor,
          VV,
          pJet());
    }
    case 919002: {
      /// \fvspongeSwitchCase{fvSponge, 919002, Flame Hardcoded}
      /// \warning  The coordinate values are hardcoded in the implementation. Please
      /// see the code for detailed implementation.
      VelA VV;
      PVars tmpVars;
      if(m_velocitySponge) {
        VV[0] = targetVelocityU();
        VV[1] = targetVelocityV();
        VV[2] = targetVelocityW();
      } else {
        VV = noVelocitySponge;
      }
      tmpVars = from_target(
          (a_coordinate(cellId, 1) < m_yOffsetFlameTube - 0.5 && abs(a_coordinate(cellId, 2)) < m_jetHalfLength + 0.1)
              ? rhoJet()
              : rhoJet() * m_targetDensityFactor,
          VV,
          pJet());
      if(a_coordinate(cellId, 1) < m_yOffsetFlameTube - 0.5 && abs(a_coordinate(cellId, 2)) < m_jetHalfLength + 0.1) {
        tmpVars[PV->RHO] *= m_sigmaSpongeInflow / m_sigmaSponge;
        tmpVars[PV->P] *= m_sigmaSpongeInflow / m_sigmaSponge;
      }
      return tmpVars;
    }
    case 40: {
      /// \fvspongeSwitchCase{fvSponge, 40, Pressure and Density sponge}
      /// \f$ \rho_t = \rho_{\infty} * f_{\rho} \f$, where \f$ f_{\rho} \f$
      /// is the targetDensityFactor <br>
      /// \f$ \Delta \bar{V} = 0 \f$ <br>
      /// \f$	\Delta P = P_\infty + \Delta P_\tau (\text{DomainBndry[3]} - y_{cell}) \f$ <br>
      return from_target(m_rhoInfinity * m_targetDensityFactor,
                         noVelocitySponge,
                         m_PInfinity + m_deltaP * (m_domainBoundaries[3] - a_coordinate(cellId, 1)));
    }

    // Sponge for jet exiting (chevron) nozzle
    case 1174: {
      /// \fvspongeSwitchCase{fvSponge, 1174, Sponge for jet exiting (chevron) nozzle}
      ASSERT(!a_hasProperty(cellId, SolverCell::IsInvalid), "sponge cell invalid");
      ASSERT(!a_isBndryGhostCell(cellId), "sponge cell is bndry ghost cell");
      // ASSERT(a_hasProperty(cellId, SolverCell::IsActive), "sponge cell inactive");
      // ASSERT(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel), "sponge cell not on current mg level");
      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) break;
      if(!a_hasProperty(cellId, SolverCell::IsActive)) break;

      VelA velSponge(noVelocitySponge);
      MFloat targetRho, targetP;

      // TODO labels:FV variable nozzle position needs to be specified in other places as well (eg for IC, BC)
      const MFloat centerY = 0.0;
      const MFloat centerZ = 0.0;
      const MFloat radius = sqrt(POW2(a_coordinate(cellId, 1) - centerY) + POW2(a_coordinate(cellId, 2) - centerZ));
      const MFloat xpos = a_coordinate(cellId, 0);
      const MFloat maxInletPosX = 3.0;   // TODO labels:FVMB @ansgar FIXME hard-coded position
      const MFloat minOutletPosX = 50.0; // TODO labels:FVMB  @ansgar FIXME hard-coded position

      if(xpos <= maxInletPosX && radius <= m_inletRadius) {
        const MFloat deltaMomentum = m_momentumThickness * m_inletRadius;
        const MFloat jet = tanh((m_inletRadius - radius) / (2.0 * deltaMomentum));

        const MFloat density_i = value[0];
        targetRho = density_i / sysEqn().CroccoBusemann(m_maNozzleInlet, jet);
        targetP = value[1];
      } else {
        // Ambient values
        targetRho = value[2];
        targetP = value[3];

        // Add velocity sponge for outlet bc to prevent backflow
        if(xpos >= minOutletPosX && a_pvariable(cellId, PV->U) < 0) {
          velSponge[0] = 0.0;
        }
      }

      return from_target(targetRho, velSponge, targetP);
    }

    // sponges originally from 2D solver:

    // vortex-pair cylinder (quiescent flow prescribed)
    case 2: {
      /// \fvspongeSwitchCase{fvSponge, 2, vortex-pair cylinder (quiescent flow prescribed)}
      /// \f$ \rho_t = \rho \dfrac{\Delta P}{P} \f$ <br>
      /// \f$ \Delta \bar{V} = \bar{V}*\rho_t \f$ <br>
      /// \f$	P_t = P_{\infty} \f$ <br>
      PVars dPVtmp;
      dPVtmp = from_target(noDensitySponge, noVelocitySponge, m_PInfinity);
      dPVtmp[PV->RHO] = a_pvariable(cellId, PV->RHO)
                        * ((a_pvariable(cellId, PV->P) + dPVtmp[PV->P]) / a_pvariable(cellId, PV->P) - 1);
      for(MInt d = 0; d < nDim; ++d) {
        dPVtmp[PV->VV[d]] = dPVtmp[PV->RHO] * a_pvariable(cellId, PV->VV[d]);
      }
      return dPVtmp;
    }
      // quiescent flow
    case 4: {
      /// \fvspongeSwitchCase{fvSponge, 4, quiescent flow- Pressure and Density Sponged}
      /// \f$ \rho_t = 1.0 \f$ <br>
      /// \f$ \Delta \bar{V} = 0 \f$ <br>
      /// \f$	P_t = P_{\infty} \f$ <br>
      PVars dPVtmp;
      dPVtmp = from_target(noDensitySponge, noVelocitySponge, noPressureSponge);
      dPVtmp[PV->P] = sysEqn().pressureEnergy(a_pvariable(cellId, PV->P) - sysEqn().p_Ref());
      dPVtmp[PV->RHO] = a_pvariable(cellId, PV->RHO) - 1.0;
      return dPVtmp;
    }

    case 7: {
      /// \fvspongeSwitchCase{fvSponge, 7, shock}
      PVars dPVtmp;
      const MFloat T2 = sysEqn().temperature_ES(m_postShockPV[PV->RHO], m_postShockPV[PV->P]);
      MFloat velSq = 0.0;
      for(MInt d = 0; d < nDim; ++d) {
        velSq += POW2(m_postShockPV[PV->VV[d]]);
      }
      velSq *= F1B2;

      dPVtmp = from_target(noDensitySponge, noVelocitySponge, m_postShockPV[PV->P]);
      dPVtmp[PV->RHO] = (a_pvariable(cellId, PV->P) - m_postShockPV[PV->P]) / T2;
      dPVtmp[PV->P] = (dPVtmp[PV->P] + dPVtmp[PV->RHO] * velSq);
      return dPVtmp;
    }
      // backward-facing step combustor
    case 1930: {
      /// \fvspongeSwitchCase{fvSponge, 1930, backward-facing step combustor}
      return from_target((a_coordinate(cellId, 0) < 0) ? m_rhoInfinity : m_rhoInfinity * m_targetDensityFactor,
                         noVelocitySponge,
                         m_PInfinity);
    }
      // case 1940 already exists from 3D.. but it is different from the 2D one

      // forced response
    case 17511:
      /// \fvspongeSwitchCase{fvSponge, 17511, forced response}

      // DL instability
    case 1990: {
      /// \fvspongeSwitchCase{fvSponge, 1990, DL instability}
      MFloat pressure;
      pressure = m_PInfinity + m_rhoInfinity * POW2(m_flameSpeed) * (m_burntUnburntTemperatureRatio - F1);
      return from_target((a_coordinate(cellId, 1) < 0.0) ? m_rhoInfinity : m_rhoInfinity * m_targetDensityFactor,
                         noVelocitySponge,
                         (a_coordinate(cellId, 1) < 0.0) ? pressure : m_PInfinity);
    }
    case 17512:
      /// \fvspongeSwitchCase{fvSponge, 17512, ...}

    case 17514: {
      /// \fvspongeSwitchCase{fvSponge, 17514, DL instability}
      return from_target((a_coordinate(cellId, 1) < 0.0) ? m_rhoInfinity : m_rhoInfinity * m_targetDensityFactor,
                         noVelocitySponge,
                         (a_coordinate(cellId, 1) < 0.0) ? value[1] : m_PInfinity);
    }

    // forced response velocity profile, forcing via sponge layer
    case 17515: {
      /// \fvspongeSwitchCase{fvSponge, 17515, forced response velocity profile- forcing via sponge layer}
      MFloat velocity;
      MFloat ampl = m_forcingAmplitude;
      MFloat xPlus, xNegative;
      MFloat St = m_flameStrouhal;
      // MFloat neg2=-F2;
      //	MFloat integrateFactor = m_velocityMagnitudeFactor;
      //---

      PVars dPVtmp;
      if(!m_forcing) {
        // compute the forcing terms
        MFloat deltaV = F0;
        MFloat deltaU = F0;
        MFloat velocityU = F0;

        if(a_spongeBndryId(cellId, 0) == 176191 || a_spongeBndryId(cellId, 1) == 176191
           || a_spongeBndryId(cellId, 0) == 209104 || a_spongeBndryId(cellId, 1) == 209104
           || a_spongeBndryId(cellId, 0) == 209101 || a_spongeBndryId(cellId, 1) == 209101
           || a_spongeBndryId(cellId, 0) == 17616 || a_spongeBndryId(cellId, 1) == 17616
           || a_spongeBndryId(cellId, 0) == 3906 || a_spongeBndryId(cellId, 1) == 3906
           || a_spongeBndryId(cellId, 0) == 39060 || a_spongeBndryId(cellId, 1) == 39060
           || a_spongeBndryId(cellId, 0) == 209102
           || a_spongeBndryId(cellId, 1) == 209102) { // a_coordinate( cellId ,  1 ) < m_yOffsetFlameTube ) {

          const MFloat density = value[0];
          const MFloat pressure = value[1];

          dPVtmp[PV->RHO] = a_pvariable(cellId, PV->RHO) - density;
          dPVtmp[PV->P] = sysEqn().pressureEnergy(a_pvariable(cellId, PV->P) - pressure);

          xPlus = a_coordinate(cellId, 0) + m_radiusVelFlameTube;
          xNegative = a_coordinate(cellId, 0) - m_radiusVelFlameTube;

          velocity =
              m_VInfinity
              * (F1B2 * (F1 + tanh(xPlus * m_shearLayerStrength)) * (F1 - tanh(xNegative * m_shearLayerStrength)) - F1);

          //	      velocity = m_VInfinity*(tanh(5.0)-F1B2*tanh(5.0) +  F1B2*tanh((neg2*xNegative -
          // 0.05)*5.0/0.05))*(tanh(5.0)-F1B2*tanh(5.0) +  F1B2*tanh((F2*xPlus - 0.05)*5.0/0.05)); 	      velocity =
          // F1B4*(1+tanh(xPlus*100.0))*(1-tanh(xNegative*100.0))*m_VInfinity;//*integrateFactor;

          if(!m_specialSpongeTreatment) {
            deltaV = (a_pvariable(cellId, PV->VV[1]) - velocity) * m_rhoInfinity;
            deltaU = (a_pvariable(cellId, PV->VV[0]) - velocityU) * m_rhoInfinity;
          } else {
            a_variable(cellId, CV->RHO_V) = velocity * m_rhoInfinity;
            a_variable(cellId, CV->RHO_U) = F0;
          }

          // outflow sponge layer
        } else {
          const MFloat outflowDensity = value[2];
          const MFloat outflowPressure = value[3];

          dPVtmp[PV->RHO] = a_pvariable(cellId, PV->RHO) - outflowDensity;
          dPVtmp[PV->P] = sysEqn().pressureEnergy(a_pvariable(cellId, PV->P) - outflowPressure);
          deltaU = 0;
          deltaV = 0;

          if(m_velocitySponge && (a_spongeBndryId(cellId, 0) == 1763 || a_spongeBndryId(cellId, 1) == 1763)) {
            velocity = a_oldVariable(cellId, CV->RHO_VV[1]) * (m_spongeWeight - 1) / m_spongeWeight;
            velocity /= a_oldVariable(cellId, CV->RHO);
            velocity += a_variable(cellId, CV->RHO_VV[1]) / (a_variable(cellId, CV->RHO) * m_spongeWeight);

            velocityU = a_oldVariable(cellId, CV->RHO_VV[0]) * (m_spongeWeight - 1) / m_spongeWeight;
            velocityU /= a_oldVariable(cellId, CV->RHO);
            velocityU += a_variable(cellId, CV->RHO_VV[0]) / (a_variable(cellId, CV->RHO) * m_spongeWeight);

            deltaV = (a_pvariable(cellId, PV->VV[1]) - velocity) * m_rhoInfinity;
            deltaU = (a_pvariable(cellId, PV->VV[0]) - velocityU) * m_rhoInfinity;
          }
        }

        dPVtmp[PV->U] = deltaU * (m_velocitySponge + (!m_specialSpongeTreatment) * m_spongeReductionFactor);
        dPVtmp[PV->V] = deltaV * (m_velocitySponge + (!m_specialSpongeTreatment) * m_spongeReductionFactor);

      } else { // if(!forcing) ends here

        // compute the forcing terms
        // ...for the pressure
        // ...for the density
        MFloat deltaV = F0;
        MFloat deltaU = F0;
        MFloat velocityU = F0;

        if((a_spongeBndryId(cellId, 0) == 17616 || a_spongeBndryId(cellId, 1) == 17616)
           || (a_spongeBndryId(cellId, 0) == 176191 || a_spongeBndryId(cellId, 1) == 176191)
           || (a_spongeBndryId(cellId, 0) == 209102 || a_spongeBndryId(cellId, 1) == 209102)
           || (a_spongeBndryId(cellId, 0) == 209101 || a_spongeBndryId(cellId, 1) == 209101)
           || (a_spongeBndryId(cellId, 0) == 209104
               || a_spongeBndryId(cellId, 1) == 209104)) { // a_coordinate( cellId ,  1 ) < m_yOffsetFlameTube ) {

          const MFloat density = value[0];
          const MFloat pressure = value[1];

          dPVtmp[PV->RHO] = a_pvariable(cellId, PV->RHO) - density;
          dPVtmp[PV->P] = sysEqn().pressureEnergy(a_pvariable(cellId, PV->P) - pressure);

          xPlus = a_coordinate(cellId, 0) + m_radiusVelFlameTube;
          xNegative = a_coordinate(cellId, 0) - m_radiusVelFlameTube;

          velocity =
              m_VInfinity
              * (F1B2 * (F1 + tanh(xPlus * m_shearLayerStrength)) * (F1 - tanh(xNegative * m_shearLayerStrength)) - F1);

          velocity *= (F1 + ampl * sin(St * m_time));

          // velocity = m_VInfinity*(tanh(5.0)-F1B2*tanh(5.0) +  F1B2*tanh((neg2*xNegative -
          // 0.05)*5.0/0.05))*(tanh(5.0)-F1B2*tanh(5.0) +  F1B2*tanh((F2*xPlus - 0.05)*5.0/0.05));

          // velocity = F1B4*(1+tanh(xPlus*100.0))*(1-tanh(xNegative*100.0))*m_VInfinity*( F1 + ampl * sin( St * m_time
          // ));//*integrateFactor;

          if(!m_specialSpongeTreatment) {
            deltaV = (a_pvariable(cellId, PV->VV[1]) - velocity) * m_rhoInfinity;
            deltaU = (a_pvariable(cellId, PV->VV[0]) - velocityU) * m_rhoInfinity;
          } else {
            a_variable(cellId, CV->RHO_V) = velocity * m_rhoInfinity;
            a_variable(cellId, CV->RHO_U) = F0;
          }

          // outflow sponge layer
        } else {
          const MFloat outflowDensity = value[2];
          const MFloat outflowPressure = value[3];

          dPVtmp[PV->RHO] = a_pvariable(cellId, PV->RHO) - outflowDensity;
          dPVtmp[PV->P] = sysEqn().pressureEnergy(a_pvariable(cellId, PV->P) - outflowPressure);
          deltaV = F0;
          deltaU = F0;
          if(m_velocitySponge && (a_spongeBndryId(cellId, 0) == 1763 || a_spongeBndryId(cellId, 1) == 1763)) {
            velocity = a_oldVariable(cellId, CV->RHO_VV[1]) * (m_spongeWeight - 1) / m_spongeWeight;
            velocity /= a_oldVariable(cellId, CV->RHO);
            velocity += a_variable(cellId, CV->RHO_VV[1]) / (a_variable(cellId, CV->RHO) * m_spongeWeight);

            velocityU = a_oldVariable(cellId, CV->RHO_VV[0]) * (m_spongeWeight - 1) / m_spongeWeight;
            velocityU /= a_oldVariable(cellId, CV->RHO);
            velocityU += a_variable(cellId, CV->RHO_VV[0]) / (a_variable(cellId, CV->RHO) * m_spongeWeight);

            deltaV = (a_pvariable(cellId, PV->VV[1]) - velocity) * m_rhoInfinity;
            deltaU = (a_pvariable(cellId, PV->VV[0]) - velocityU) * m_rhoInfinity;
          }
        }

        dPVtmp[PV->U] = deltaU * (m_velocitySponge + (!m_specialSpongeTreatment) * m_spongeReductionFactor);
        dPVtmp[PV->V] = deltaV * (m_velocitySponge + (!m_specialSpongeTreatment) * m_spongeReductionFactor);
      }
      return dPVtmp;
    }
      // end of "2D sponges"


    default: {
      mTerm(1, AT_,
            "FvCartesianSolverXD::computeSpongeDeltas() switch variable 'm_spongeLayerType' not matching any "
            "case");
    }
  } // end of switch
  return from_target(noDensitySponge, noVelocitySponge, noPressureSponge);
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::updateSpongeLayerRhs(const MInt cellId, array<MFloat, nDim_ + 2> dPV) {
  TRACE();

  // update rhs RHO_E, RHO, RHO_V, RHO_U, RHO_W, RHO_Y
  IF_CONSTEXPR(hasE<SysEqn>)
  a_rightHandSide(cellId, CV->RHO_E) += a_spongeFactor(cellId) * dPV[PV->P] * a_cellVolume(cellId);
  a_rightHandSide(cellId, CV->RHO) += a_spongeFactor(cellId) * dPV[PV->RHO] * a_cellVolume(cellId);
  for(MInt d = 0; d < nDim; ++d) {
    a_rightHandSide(cellId, CV->RHO_VV[d]) += a_spongeFactor(cellId) * dPV[PV->VV[d]] * a_cellVolume(cellId);
  }

  // IF_CONSTEXPR(SysEqn::m_noRansEquations > 0){
  //   for(MInt r = 0; r < m_noRansEquations; ++r) {
  //     a_rightHandSide(cellId, CV->RHO_NN[r]) +=
  //     a_spongeFactor(cellId)*dPV[PV->RHO]*a_cellVolume(cellId);
  //   }
  // }

  // species
  for(MInt s = 0; s < m_noSpecies; s++) {
    a_rightHandSide(cellId, CV->RHO_Y[s]) +=
        a_spongeFactor(cellId) * dPV[PV->RHO] * a_cellVolume(cellId) * a_pvariable(cellId, PV->Y[s]);
  }
}


// --------------------------------------------------------------------------------------


/** \brief Extracts the minimum and maximum coordinates of all cells in the grid.
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeDomainAndSpongeDimensions() {
  TRACE();

  MInt noDirs = 2 * nDim;
  MFloat halfCellWidth;
  MFloat epsilon = c_cellLengthAtLevel(maxRefinementLevel()) / 1000.0;
  MFloatScratchSpace tmp(nDim, AT_, "tmp");
  MFloatScratchSpace tmp2(nDim, AT_, "tmp2");
  //---

  // compute domain dimensions
  halfCellWidth = F1B2 * c_cellLengthAtCell(0);
  for(MInt i = 0; i < nDim; i++) {
    m_domainBoundaries[2 * i] = a_coordinate(0, i) - halfCellWidth;
    m_domainBoundaries[2 * i + 1] = a_coordinate(0, i) + halfCellWidth;
  }
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    if(c_noChildren(cellId) > 0) continue;
    halfCellWidth = F1B2 * c_cellLengthAtCell(cellId);
    for(MInt i = 0; i < nDim; i++) {
      m_domainBoundaries[2 * i] = mMin(m_domainBoundaries[2 * i], a_coordinate(cellId, i) - halfCellWidth);
      m_domainBoundaries[2 * i + 1] = mMax(m_domainBoundaries[2 * i + 1], a_coordinate(cellId, i) + halfCellWidth);
    }
  }
  // exchange domain boundaries
  // maximum dimensions
  for(MInt i = 0; i < nDim; i++)
    tmp.p[i] = m_domainBoundaries[2 * i + 1];
  MPI_Reduce(tmp.getPointer(), tmp2.getPointer(), nDim, MPI_DOUBLE, MPI_MAX, 0, mpiComm(), AT_, "tmp.getPointer()",
             "tmp2.getPointer()");
  MPI_Bcast(tmp2.getPointer(), nDim, MPI_DOUBLE, 0, mpiComm(), AT_, "tmp2.getPointer()");
  for(MInt i = 0; i < nDim; i++)
    m_domainBoundaries[2 * i + 1] = tmp2.p[i];
  // minimum dimensions
  for(MInt i = 0; i < nDim; i++)
    tmp.p[i] = m_domainBoundaries[2 * i];
  MPI_Reduce(tmp.getPointer(), tmp2.getPointer(), nDim, MPI_DOUBLE, MPI_MIN, 0, mpiComm(), AT_, "tmp.getPointer()",
             "tmp2.getPointer()");
  MPI_Bcast(tmp2.getPointer(), nDim, MPI_DOUBLE, 0, mpiComm(), AT_, "tmp2.getPointer()");
  for(MInt i = 0; i < nDim; i++)
    m_domainBoundaries[2 * i] = tmp2.p[i];

  // compute the mean coordinate ([2] is set for the 2D-version)
  m_meanCoord[2] = F0;
  m_fvBndryCnd->m_meanCoord[2] = m_meanCoord[2];
  for(MInt i = 0; i < nDim; i++) {
    m_meanCoord[i] = F1B2 * (m_domainBoundaries[2 * i] + m_domainBoundaries[2 * i + 1]);
    m_fvBndryCnd->m_meanCoord[i] = m_meanCoord[i];
  }

  if(m_spongeLayerThickness > F0) {
    if(!m_createSpongeBoundary) {
      // compute sponge zone dimensions
      for(MInt i = 0; i < nDim; i++) {
        m_spongeCoord[2 * i] = m_domainBoundaries[2 * i] + m_spongeLayerThickness * m_spongeFactor[2 * i];
        m_spongeCoord[noDirs + 2 * i] = F1 / mMax(epsilon, m_spongeLayerThickness * m_spongeFactor[2 * i]);
        m_spongeCoord[2 * i + 1] = m_domainBoundaries[2 * i + 1] - m_spongeLayerThickness * m_spongeFactor[2 * i + 1];
        m_spongeCoord[noDirs + 2 * i + 1] = F1 / (mMax(epsilon, m_spongeLayerThickness * m_spongeFactor[2 * i + 1]));
      }
    }
  }

  m_log << "*** boundaries of the computational domain " << endl;
  m_log << "     direction  " << endl;
  for(MInt i = 0; i < nDim; i++) {
    m_log << "min     " << i << "       " << m_domainBoundaries[2 * i] << endl;
    m_log << "max     " << i << "       " << m_domainBoundaries[2 * i + 1] << endl;
    m_log << "mean    " << i << "       " << m_meanCoord[i] << endl;
  }
}


// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// ****************** Small cells *********************************************
// ----------------------------------------------------------------------------


/** \brief adds the right hand side of small cells to their corresponding master cells and sets the small cell RHS to
 * zero
 *
 * \author Daniel Hartmann
 * \date  April 12, 2006
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::correctMasterCells() {
  TRACE();

  const MInt noSmallCells = m_fvBndryCnd->m_smallBndryCells->size();
  const MInt noVarIds = FV->noVariables;
  //---

#ifdef _OPENMP
#pragma omp parallel for collapse(2)
#endif
  for(MInt s = 0; s < noSmallCells; s++) {
    for(MInt varId = 0; varId < noVarIds; varId++) {
      a_rightHandSide(m_masterCellIds[s], varId) += a_rightHandSide(m_smallCellIds[s], varId);
      a_rightHandSide(m_smallCellIds[s], varId) = F0;
    }
  }
}


// ----------------------------------------------------------------------------
// ****************** Output / restart ****************************************
// ----------------------------------------------------------------------------


/**
 * \fn void FvCartesianSolverXD::saveSolverSolution()
 * \brief Manages solver-specific output
 *
 * \author Daniel Hartmann, Stephan Schlimpert
 * \date unknown, June 2011, January 2013
 *
 * last changes: VTU format included (cut cell output in 2D)
 *
 * outputs are only given for the zeroth level-set function (set = 0)
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::saveSolverSolution(const MBool forceOutput, const MBool finalTimeStep) {
  TRACE();
  std::ignore = finalTimeStep;
  // the following preprocessor statement triggers a more detailed output
  // might lead to memory issues as a new array is allocated.
  // better only use for debug reasons (\author: Claudia)
  //#define _DET_OUT
  // Return if this is not the primary solver in a multilevel computation
  if(isMultilevel() && !isMultilevelPrimary()) {
    return;
  }

  MInt offset = m_solutionOffset;
  MInt rank = domainId();
  stringstream gridFileName;
#ifdef _DET_OUT
  MIntScratchSpace MS_Ids(m_fvBndryCnd->m_bndryCells->size(), AT_, "MS_Ids");
  cerr << "detailed Output!" << endl;
#endif

  //---


  ////////////////////////////////////////
  /* minimum and maximum wall vorticity */
  ////////////////////////////////////////
  if(m_recordWallVorticity) {
    FILE* datei;
    MInt cellId, bndryId, ghostCellId;
    MFloat vorticity;
    MFloat minimumWallVorticity = 10000.;
    MFloat maximumWallVorticity = -10000.;

    datei = fopen("wallVorticity", "a+");
    fprintf(datei, "%d", globalTimeStep);
    fprintf(datei, "  %f", m_physicalTime);
    fprintf(datei, "  %f", m_time);

    for(MInt bcId = 0; bcId < m_fvBndryCnd->m_noBndryCndIds; bcId++) {
      if(m_fvBndryCnd->m_bndryCndIds[bcId] != 3006) continue;
      for(MInt id = m_fvBndryCnd->m_bndryCndCells[bcId]; id < m_fvBndryCnd->m_bndryCndCells[bcId + 1]; id++) {
        bndryId = m_fvBndryCnd->m_sortedBndryCells->a[id];
        cellId = m_bndryCells->a[bndryId].m_cellId;
        if(m_bndryCells->a[bndryId].m_linkedCellId > -1)
          if(a_bndryId(m_bndryCells->a[bndryId].m_linkedCellId) == -1) cellId = m_bndryCells->a[bndryId].m_linkedCellId;
        if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
        ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[0]->m_ghostCellId;

        vorticity = F1B4
                    * (a_slope(cellId, PV->V, 0) + a_slope(ghostCellId, PV->V, 0) - a_slope(cellId, PV->U, 1)
                       - a_slope(ghostCellId, PV->U, 1));
        vorticity /= m_UInfinity; // normalize
        minimumWallVorticity = mMin(minimumWallVorticity, vorticity);
        maximumWallVorticity = mMax(maximumWallVorticity, vorticity);
      }
    }
    fprintf(datei, "  %f", minimumWallVorticity);
    fprintf(datei, "  %f", maximumWallVorticity);

    fprintf(datei, "\n");
    fclose(datei);
  }

  //////////////////////////////////
  /* conserved quantities L and A */
  //////////////////////////////////
  if(m_recordLandA) {
    TERMM_IF_COND(m_reConstSVDWeightMode == 3 || m_reConstSVDWeightMode == 4, "Not yet implemented!");
    // this is 2D code!!!
    // compute the total vorticity
    FILE* datei;
    MInt noSrfcs = a_noSurfaces();
    MFloat vorticity = F0;
    MFloat totalVorticity = F0;
    MFloat totalVorticityPrimary = F0;
    MFloat totalVorticitySecondary = F0;
    MFloat totalSecondaryVorticity = F0;
    MFloat kineticEnergy = F0;
    MFloat enstrophy = F0;
    MFloat L1X = F0;
    MFloat L1Y = F0;
    MFloat L2X = F0;
    MFloat L2Y = F0;
    MFloat AZ1 = F0;
    MFloat AZ2 = F0;
    MFloat AZ3 = F0;
    MFloat LtopX = F0;
    MFloat LtopY = F0;
    MFloat AZtop = F0;
    MFloat tvtop = F0;
    MFloat tvtoprect = F0;
    MFloat LtopXrect = F0;
    MFloat LtopYrect = F0;
    MFloat LXprimary = F0;
    MFloat LXsecondary = F0;
    MFloat xmax = F0;
    MFloat xmin = F0;
    MFloat ymax = F0;

    // changed by claudia in order to make this code applicable when m_movingGrid is false
    MFloat gridVelocity[3] = {F0, F0, F0};
    MFloat gridVelocityDt1[3] = {F0, F0, F0};
    MFloat gridCenter[3] = {F0, F0, F0};

    // define rectangular computing area
    /*! \page propertiesFV
      \section refinementPatches
      <code>MInt FvCartesianSolverXD::refinementPatches</code>\n
      default = <code>0</code>\n\n
      Defines rectangular area for the computation of L and A, integral int l x nabla^2 omega dV and the body force
      components\n Possible values are: <ul>\n <li>1211</li> ( xmax=10.0 xmin=-6.0 ymax=10.0)\n <li>1212</li> (
      xmax=10.0 xmin=-20.0 ymax=10.0)\n
      </ul>\n
      Keywords: <i>FINITE_VOLUME, I/O</i>\n
    */
    MInt refinementPatches = 0;
    refinementPatches = Context::getSolverProperty<MInt>("refinementPatches", m_solverId, AT_, &refinementPatches);
    switch(refinementPatches) {
      case 1211: {
        xmax = 10.0;
        xmin = -6.0;
        ymax = 10.0;
        break;
      }
      case 1212: {
        xmax = 10.0;
        xmin = -20.0;
        ymax = 10.0;
        break;
      }
      default: {
        // do nothing, create new case for matching refinement patch if needed
      }
    }

    // compute L and A
    for(MInt cell = m_noActiveCells - 1; cell >= 0; --cell) {
      MInt cellId = m_activeCellIds[cell];
      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
      if(a_isBndryGhostCell(cellId)) continue;
      if(a_coordinate(cellId, 0) > xmax) continue;
      if(a_coordinate(cellId, 0) < xmin) continue;
      if(ABS(a_coordinate(cellId, 1)) > ymax) continue;
      vorticity = F1B2 * (a_slope(cellId, PV->V, 0) - a_slope(cellId, PV->U, 1));
      kineticEnergy +=
          F1B2 * a_cellVolume(cellId) * (POW2(a_pvariable(cellId, PV->U)) + POW2(a_pvariable(cellId, PV->V)));
      enstrophy += F1B2 * a_cellVolume(cellId) * POW2(vorticity);
      totalVorticity += ABS(vorticity) * a_cellVolume(cellId);
      if(vorticity * a_coordinate(cellId, 1) > F0) totalSecondaryVorticity += ABS(vorticity) * a_cellVolume(cellId);
      L2X += a_cellVolume(cellId) * vorticity * (a_coordinate(cellId, 1)); //- gridCenter[ 1 ] );
      L2Y -= a_cellVolume(cellId) * vorticity * (a_coordinate(cellId, 0)); //- gridCenter[ 0 ] );
      AZ1 -= a_cellVolume(cellId) * vorticity * F1B2
             * (POW2(a_coordinate(cellId, 0)) + //- gridCenter[ 0 ] ) +
                POW2(a_coordinate(cellId, 1))); //- gridCenter[ 1 ] ) );
      AZ3 -= a_cellVolume(cellId) * vorticity
             * ((a_coordinate(cellId, 0)) * gridCenter[0] + (a_coordinate(cellId, 1)) * gridCenter[1]);
      // top domain half
      if(a_coordinate(cellId, 1) > F0) {
        tvtop += vorticity * a_cellVolume(cellId);
        LtopX += a_cellVolume(cellId) * vorticity * (a_coordinate(cellId, 1));
        LtopY -= a_cellVolume(cellId) * vorticity * (a_coordinate(cellId, 0));
        AZtop -= a_cellVolume(cellId) * vorticity
                 * ((a_coordinate(cellId, 0)) * gridCenter[0] + (a_coordinate(cellId, 1)) * gridCenter[1]);
        LtopXrect += a_cellVolume(cellId) * vorticity * (a_coordinate(cellId, 1));
        LtopYrect -= a_cellVolume(cellId) * vorticity * (a_coordinate(cellId, 0));
        tvtoprect += vorticity * a_cellVolume(cellId);
      }
      // only the primary vorticity contribution
      if(vorticity * (a_coordinate(cellId, 1)) > F0) {
        LXprimary += a_cellVolume(cellId) * vorticity * (a_coordinate(cellId, 1));
        totalVorticityPrimary += ABS(vorticity) * a_cellVolume(cellId);
      } else {
        LXsecondary += a_cellVolume(cellId) * vorticity * (a_coordinate(cellId, 1));
        totalVorticitySecondary += ABS(vorticity) * a_cellVolume(cellId);
      }
    }
    L1X = totalVorticity * gridCenter[1];
    L1Y = -totalVorticity * gridCenter[0];
    AZ2 = -m_angularBodyVelocity;
    LtopX += tvtop * gridCenter[1];
    LtopY -= tvtop * gridCenter[0];
    AZtop -= F1B2 * tvtop * (POW2(gridCenter[0]) + POW2(gridCenter[1]));
    LtopXrect += tvtoprect * gridCenter[1];
    LtopYrect -= tvtoprect * gridCenter[0];
    // LXprimary += totalVorticityPrimary * gridCenter[ 1 ];
    // LXsecondary += totalVorticitySecondary * gridCenter[ 1 ];

    // normalize
    L1X /= m_UInfinity;
    L1Y /= m_UInfinity;
    L2X /= m_UInfinity;
    L2Y /= m_UInfinity;
    AZ1 /= m_UInfinity;
    AZ2 /= m_UInfinity;
    AZ3 /= m_UInfinity;
    LtopX /= m_UInfinity;
    LtopY /= m_UInfinity;
    AZtop /= m_UInfinity;
    LtopXrect /= m_UInfinity;
    LtopYrect /= m_UInfinity;
    LXprimary /= m_UInfinity;
    LXsecondary /= m_UInfinity;

    // compute the integral int l x nabla^2 omega dV
    // /////////////////////////////////////////////

    // compute the vorticity gradient
    for(MInt i = 0; i < a_noCells(); i++)
      for(MInt d = 0; d < nDim; d++)
        a_rightHandSide(i, d) = F0;

    for(MUint k = 0; k < m_reconstructionDataSize; k++) {
      MFloat vorticityDifference =
          (F1B2
           * ((a_slope(m_reconstructionNghbrIds[k], 1, 0) - a_slope(m_reconstructionNghbrIds[k], 0, 1))
              - (a_slope(m_reconstructionCellIds[k], 1, 0) - a_slope(m_reconstructionCellIds[k], 0, 1))));
      a_rightHandSide(m_reconstructionCellIds[k], 0) += m_reconstructionConstants[nDim * k] * vorticityDifference;
      a_rightHandSide(m_reconstructionCellIds[k], 1) += m_reconstructionConstants[nDim * k + 1] * vorticityDifference;
    }

    copyRHSIntoGhostCells();

    // compute the integral int l x nabla^2 omega dV
    MFloat laplaceVorticityIntegral = F0;
    MFloat* area = &a_surfaceArea(0);
    for(MInt srfcId = 0; srfcId < noSrfcs; srfcId++) {
      // compute the surface vorticity * area
      a_surfaceFlux(srfcId, 0) =
          area[srfcId]
          * (a_surfaceFactor(srfcId, 0) * a_rightHandSide(a_surfaceNghbrCellId(srfcId, 0), a_surfaceOrientation(srfcId))
             + (a_surfaceFactor(srfcId, 1)
                * a_rightHandSide(a_surfaceNghbrCellId(srfcId, 1), a_surfaceOrientation(srfcId))));
    }
    for(MInt cell = m_noActiveCells - 1; cell >= 0; --cell) {
      MInt cellId = m_activeCellIds[cell];
      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
      a_rightHandSide(cellId, 0) = F0;
    }
    for(MInt srfcId = 0; srfcId < noSrfcs; srfcId++) {
      a_rightHandSide(a_surfaceNghbrCellId(srfcId, 0), 0) += a_surfaceFlux(srfcId, 0);
      a_rightHandSide(a_surfaceNghbrCellId(srfcId, 1), 0) -= a_surfaceFlux(srfcId, 0);
    }
    for(MInt cell = m_noActiveCells - 1; cell >= 0; --cell) {
      MInt cellId = m_activeCellIds[cell];
      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
      if(a_isBndryGhostCell(cellId)) continue;
      if(a_coordinate(cellId, 0) > xmax) continue;
      if(a_coordinate(cellId, 0) < xmin) continue;
      if(ABS(a_coordinate(cellId, 1)) > ymax) continue;
      laplaceVorticityIntegral += a_rightHandSide(cellId, 0) * (a_coordinate(cellId, 1) - gridCenter[1]);
    }

    datei = fopen("conservedQuantities", "a+");
    fprintf(datei, "%d", globalTimeStep);
    fprintf(datei, "  %f", m_physicalTime);
    fprintf(datei, "  %f", m_time);
    fprintf(datei, "  %f", L1X);
    fprintf(datei, "  %f", L1Y);
    fprintf(datei, "  %f", L2X);
    fprintf(datei, "  %f", L2Y);
    fprintf(datei, "  %f", AZ1);
    fprintf(datei, "  %f", AZ2);
    fprintf(datei, "  %f", AZ3);
    fprintf(datei, "  %f", LtopX);
    fprintf(datei, "  %f", LtopY);
    fprintf(datei, "  %f", AZtop);
    fprintf(datei, "  %f", LtopXrect);
    fprintf(datei, "  %f", LtopYrect);
    fprintf(datei, "  %f", LXprimary);
    fprintf(datei, "  %f", LXsecondary);
    fprintf(datei, "\n");
    fclose(datei);

    datei = fopen("flowFieldQuantities", "a+");
    fprintf(datei, "%d", globalTimeStep);
    fprintf(datei, "  %f", m_physicalTime);
    fprintf(datei, "  %f", m_time);
    fprintf(datei, "  %f", totalVorticity);
    fprintf(datei, "  %f", kineticEnergy);
    fprintf(datei, "  %f", enstrophy);
    fprintf(datei, "  %f", totalSecondaryVorticity);
    fprintf(datei, "  %f", laplaceVorticityIntegral);
    fprintf(datei, "\n");
    fclose(datei);

    // compute body force components
    //-------------------------------
    MFloat momentOfVorticity = F0;
    MFloat positiveMomentOfVorticity = F0;
    MFloat negativeMomentOfVorticity = F0;
    for(MInt cell = m_noActiveCells - 1; cell >= 0; --cell) {
      MInt cellId = m_activeCellIds[cell];
      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
      if(a_isBndryGhostCell(cellId)) continue;
      if(a_coordinate(cellId, 0) > xmax) continue;
      if(a_coordinate(cellId, 0) < xmin) continue;
      if(ABS(a_coordinate(cellId, 1)) > ymax) continue;
      vorticity = F1B2 * (a_slope(cellId, PV->V, 0) - a_slope(cellId, PV->U, 1));
      momentOfVorticity += a_cellVolume(cellId) * vorticity * a_coordinate(cellId, 1);
      if(vorticity * a_coordinate(cellId, 1) > F0)
        positiveMomentOfVorticity += a_cellVolume(cellId) * vorticity * a_coordinate(cellId, 1);
      else
        negativeMomentOfVorticity += a_cellVolume(cellId) * vorticity * a_coordinate(cellId, 1);
    }
    // time derivatives
    MFloat timeDerivativeMOV = (momentOfVorticity - m_oldMomentOfVorticity) / timeStep();
    MFloat timeDerivativeNMOV = (negativeMomentOfVorticity - m_oldNegativeMomentOfVorticity) / timeStep();
    MFloat timeDerivativePMOV = (positiveMomentOfVorticity - m_oldPositiveMomentOfVorticity) / timeStep();
    if(globalTimeStep < 2) {
      timeDerivativeMOV = F0;
      timeDerivativeNMOV = F0;
      timeDerivativePMOV = F0;
    }
    MFloat dUxdt = (gridVelocityDt1[0] - gridVelocity[0]) / timeStep();
    MFloat Ustar = m_Re / m_UInfinity * gridVelocity[0];
    // set old values
    m_oldMomentOfVorticity = momentOfVorticity;
    m_oldNegativeMomentOfVorticity = negativeMomentOfVorticity;
    m_oldPositiveMomentOfVorticity = positiveMomentOfVorticity;

    datei = fopen("bodyForceBalance", "a+");
    fprintf(datei, "%d", globalTimeStep);
    fprintf(datei, "  %f", m_physicalTime);
    fprintf(datei, "  %f", m_time);
    fprintf(datei, "  %f", momentOfVorticity);
    fprintf(datei, "  %f", timeDerivativeMOV);
    fprintf(datei, "  %f", negativeMomentOfVorticity);
    fprintf(datei, "  %f", timeDerivativeNMOV);
    fprintf(datei, "  %f", positiveMomentOfVorticity);
    fprintf(datei, "  %f", timeDerivativePMOV);
    fprintf(datei, "  %f", Ustar);
    fprintf(datei, "  %f", dUxdt);
    fprintf(datei, "\n");
    fclose(datei);
  }

  if(m_integratedHeatReleaseOutput) {
    if(m_integratedHeatReleaseOutputInterval != 0
       && (((globalTimeStep - offset) % m_integratedHeatReleaseOutputInterval) == 0)) {
      calculateHeatRelease();

      MFloat accumulatedHeatRelease = F0;
      for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
        accumulatedHeatRelease += m_heatRelease[cellId] * a_cellVolume(cellId);
      }

      MPI_Allreduce(MPI_IN_PLACE, &accumulatedHeatRelease, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                    "accumulatedHeatRelease");

      if(rank == 0) {
        FILE* datei;
        datei = fopen("integratedHeatRelease", "a+");
        fprintf(datei, "%d", globalTimeStep);
        fprintf(datei, " %-10.10f", m_physicalTime);
        fprintf(datei, " %-10.10f", m_time);
        fprintf(datei, " %-10.10f", accumulatedHeatRelease);
        fprintf(datei, "\n");
        fclose(datei);
      }
    }
  }

  if(!m_combustion) {
    // force coefficients
    if(m_dragOutputInterval != 0
       && (((globalTimeStep - offset) % m_dragOutputInterval) == 0 && globalTimeStep >= offset)) {
      MFloatScratchSpace forceCoefficientVector(nDim, AT_, "forceCoefficientVector");
      computeForceCoefficients(&forceCoefficientVector.p[0]);

      MFloat m_ub_utau = 1.0 / sqrt(forceCoefficientVector.p[0] / 2.0);
      MFloat Re_tau = m_Re / m_ub_utau;

      if(rank == 0) {
        FILE* datei;
        datei = fopen("forceCoef", "a+");
        fprintf(datei, "%d", globalTimeStep);
        fprintf(datei, "  %f", m_physicalTime);
        fprintf(datei, "  %f", m_time);
        for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
          fprintf(datei, "  %f", forceCoefficientVector.p[spaceId]);
        }
        IF_CONSTEXPR(nDim == 2) {
          fprintf(datei, "  %f",
                  forceCoefficientVector.p[0] * cos(m_angle[0]) + forceCoefficientVector.p[1] * sin(m_angle[0]));
          fprintf(datei, "  %f",
                  -forceCoefficientVector.p[0] * sin(m_angle[0]) + forceCoefficientVector.p[1] * cos(m_angle[0]));
        }
        if(m_periodicCells == 3) { // azimuthal periodicity concept
          fprintf(datei, "  %f", m_ub_utau);
          fprintf(datei, "  %f", Re_tau);
        }
        fprintf(datei, "\n");
        fclose(datei);
      }
    }
  }

  if(m_wmSurfaceProbeInterval > 0) {
    if(((globalTimeStep - offset) % m_wmSurfaceProbeInterval) == 0 && globalTimeStep >= offset) {
      writeWMSurfaceProbes();
    }
  }

  if(m_wallNormalOutput && m_normalOutputInterval > 0) {
    if(((globalTimeStep - offset) % m_normalOutputInterval) == 0 && globalTimeStep >= offset) {
      getWallNormalPointVars();
    }
  }

  if(m_saSrfcProbeInterval > 0) {
    if(globalTimeStep >= m_saSrfcProbeStart) {
      if(((globalTimeStep - offset) % m_saSrfcProbeInterval) == 0 && globalTimeStep >= offset) {
        writeSpanAvgSrfcProbes();
      }
    }
  }

  {
    // solution output
    // ---------------
    if((((globalTimeStep - offset) % m_solutionInterval) == 0 && globalTimeStep >= offset) || forceOutput
       || (m_solutionTimeSteps.count(globalTimeStep) > 0)) {
      if(m_outputPhysicalTime) {
        if(domainId() == 0)
          cerr << "solverId: " << m_solverId << ", Writing " << m_outputFormat << " output at time step "
               << globalTimeStep << ", physical time " << m_physicalTime << " ... ";
        m_log << "Writing " << m_outputFormat << " output at time step " << globalTimeStep << ", physical time "
              << m_physicalTime << " ... ";
      } else {
        if(domainId() == 0)
          cerr << "solverId: " << m_solverId << ", Writing " << m_outputFormat << " output at time step "
               << globalTimeStep << ", time " << m_time << " ... ";
        m_log << "Writing " << m_outputFormat << " output at time step " << globalTimeStep << ", time " << m_time
              << " ... ";
      }


      MInt noLevelSetFieldData = 0;

      if(m_levelSet) {
        if(m_combustion) {
          noLevelSetFieldData = 0; // a_noLevelSetFieldData();
          // noLevelSetFieldData = combustion().noLevelSetFieldData();
        } else if(m_levelSetMb) {
          noLevelSetFieldData = 0;
        } else {
          noLevelSetFieldData = a_noLevelSetFieldData();
        }
      }

      MBool writeSpongeInfo = false;
      writeSpongeInfo = Context::getSolverProperty<MBool>("writeSpongeInfo", solverId(), AT_, &writeSpongeInfo);

      if(m_spongeTimeDep) writeSpongeInfo = true;

      MBool writeLimInfo = false;
      if(string2enum(m_surfaceValueReconstruction) == HOCD_LIMITED_SLOPES_MAN) writeLimInfo = true;

      MFloatScratchSpace dbVariables(a_noCells()
                                             * (PV->noVariables + (MInt)m_levelSet * noLevelSetFieldData
                                                + m_vorticitySize + (MInt)m_qCriterionOutput + (MInt)writeSpongeInfo
                                                + (MInt)writeLimInfo + (5 + PV->noVariables) * (MInt)m_wmOutput
                                                + (MInt)m_useSandpaperTrip)
                                         + (MInt)isDetChem<SysEqn>,
                                     AT_, "dbVariables");
      MIntScratchSpace idVariables(a_noCells() * 2, AT_,
                                   "idVariables"); // MIntScratchSpace idVariables(a_noCells()*2, AT_, "idVariables");
      MFloatScratchSpace dbParameters(4, AT_, "dbParameters");
      MIntScratchSpace idParameters(2, AT_, "idParameters");
      vector<MString> dbVariablesName;
      vector<MString> idVariablesName;
      vector<MString> dbParametersName;
      vector<MString> idParametersName;
      vector<MString> name;

      stringstream fileName;
      if(m_multipleFvSolver) {
        fileName << m_solutionOutput << "QOUT" << getIdentifier(true, "_") << globalTimeStep;
      } else {
        fileName << m_solutionOutput << "QOUT_" << globalTimeStep;
      }

      for(MInt v = 0; v < PV->noVariables; v++) {
        name.push_back(m_variablesName[v]);
      }

      this->collectVariables(&a_pvariable(0, 0), dbVariables, name, dbVariablesName, PV->noVariables, a_noCells());
      if(writeLimInfo) {
        name.clear();
        name.push_back("limPhi");
        this->collectVariables(m_limPhi, dbVariables, name, dbVariablesName, 1, a_noCells());
      }

      if(m_vorticityOutput) {
        MFloatScratchSpace vorticity(a_noCells() * m_vorticitySize, AT_, "vorticity");
        getVorticity(&vorticity[0]);
        name.clear();
        for(MInt i = 0; i < m_vorticitySize; i++) {
          name.push_back(m_vorticityName[i]);
        }
        this->collectVariables(vorticity.begin(), dbVariables, name, dbVariablesName, m_vorticitySize, a_noCells(),
                               true);
      }

      if(m_qCriterionOutput) {
        MFloatScratchSpace qCriterion(a_noCells(), AT_, "qCriterion");
        computeQCriterion(qCriterion);
        name.clear();
        name.push_back("qCriterion");
        this->collectVariables(qCriterion.begin(), dbVariables, name, dbVariablesName, 1, a_noCells());
      }


      if(m_wmOutput) {
        MFloatScratchSpace tmp(a_noCells(), AT_, "tmp");

        for(MInt cell = 0; cell < a_noCells(); cell++) {
          tmp[cell] = 0.0;
        }
        for(MUint wmSrfcId = 0; wmSrfcId < m_wmSurfaces.size(); wmSrfcId++) {
          const MInt bndryCellId = m_wmSurfaces[wmSrfcId].m_bndryCellId;
          const MInt cell = m_bndryCells->a[bndryCellId].m_cellId;
          tmp[cell] = (MFloat)m_wmSurfaces[wmSrfcId].m_wmHasImgCell;
        }
        name.clear();
        name.push_back("hasImgCell");
        this->collectVariables(tmp.begin(), dbVariables, name, dbVariablesName, 1, a_noCells());

        for(MInt cell = 0; cell < a_noCells(); cell++) {
          tmp[cell] = 0.0;
        }
        for(MUint wmSrfcId = 0; wmSrfcId < m_wmSurfaces.size(); wmSrfcId++) {
          const MInt bndryCellId = m_wmSurfaces[wmSrfcId].m_bndryCellId;
          const MInt cell = m_bndryCells->a[bndryCellId].m_cellId;
          tmp[cell] = (MFloat)m_wmSurfaces[wmSrfcId].m_wmUII;
        }
        name.clear();
        name.push_back("u_II");
        this->collectVariables(tmp.begin(), dbVariables, name, dbVariablesName, 1, a_noCells());

        for(MInt cell = 0; cell < a_noCells(); cell++) {
          tmp[cell] = 0.0;
        }
        for(MUint wmSrfcId = 0; wmSrfcId < m_wmSurfaces.size(); wmSrfcId++) {
          const MInt bndryCellId = m_wmSurfaces[wmSrfcId].m_bndryCellId;
          const MInt cell = m_bndryCells->a[bndryCellId].m_cellId;
          tmp[cell] = (MFloat)m_wmSurfaces[wmSrfcId].m_wmTauW;
        }
        name.clear();
        name.push_back("tau_w_spalding");
        this->collectVariables(tmp.begin(), dbVariables, name, dbVariablesName, 1, a_noCells());

        for(MInt cell = 0; cell < a_noCells(); cell++) {
          tmp[cell] = 0.0;
        }
        for(MUint wmSrfcId = 0; wmSrfcId < m_wmSurfaces.size(); wmSrfcId++) {
          const MInt bndryCellId = m_wmSurfaces[wmSrfcId].m_bndryCellId;
          const MInt cell = m_bndryCells->a[bndryCellId].m_cellId;
          tmp[cell] = (MFloat)m_wmSurfaces[wmSrfcId].m_wmMUEWM;
        }
        name.clear();
        name.push_back("mue_wm");
        this->collectVariables(tmp.begin(), dbVariables, name, dbVariablesName, 1, a_noCells());

        for(MInt cell = 0; cell < a_noCells(); cell++) {
          tmp[cell] = (MFloat)a_isWMImgCell(cell);
        }
        name.clear();
        name.push_back("isWMImgCell");
        this->collectVariables(tmp.begin(), dbVariables, name, dbVariablesName, 1, a_noCells());

        const MChar* imgVarNames[5] = {"UImg", "VImg", "WImg", "RHOImg", "PImg"};
        for(MInt v = 0; v < PV->noVariables; v++) {
          for(MInt cell = 0; cell < a_noCells(); cell++) {
            tmp[cell] = 0.0;
          }
          for(MUint wmSrfcId = 0; wmSrfcId < m_wmSurfaces.size(); wmSrfcId++) {
            const MInt bndryCellId = m_wmSurfaces[wmSrfcId].m_bndryCellId;
            const MInt cell = m_bndryCells->a[bndryCellId].m_cellId;
            tmp[cell] = (MFloat)m_wmSurfaces[wmSrfcId].m_wmImgVars[v];
          }
          name.clear();
          name.push_back(v <= 4 ? imgVarNames[v] : "YImg" + std::to_string(v));
          this->collectVariables(tmp.begin(), dbVariables, name, dbVariablesName, 1, a_noCells());
        }
      }

      if(m_useSandpaperTrip) {
        MFloatScratchSpace tmp(a_noCells(), AT_, "tmp");
        for(MInt cell = 0; cell < a_noCells(); cell++) {
          tmp[cell] = (MFloat)a_isSandpaperTripCell(cell);
        }
        name.clear();
        name.push_back("isSandpaperTripCell");
        this->collectVariables(tmp.begin(), dbVariables, name, dbVariablesName, 1, a_noCells());
      }

      if(m_levelSet) {
        MInt noSets = 0;
        if(m_combustion) {
          noSets = a_noSets();
        } else if(!m_levelSetMb) {
          noSets = a_noSets();
        }
        for(MInt set = 0; set < noSets; set++) {
          MFloatScratchSpace levelSetFunction(a_noCells(), AT_, "levelSetFunction");
          MFloatScratchSpace curvature(a_noCells(), AT_, "curvature");

          for(MInt cell = 0; cell < c_noCells(); cell++) {
            if(m_combustion) {
              levelSetFunction[cell] = a_levelSetFunction(cell, 0);
              curvature[cell] = a_curvatureG(cell, 0);
            } else if(m_levelSetMb) {
              continue;
            } else {
              levelSetFunction[cell] = a_levelSetFunction(cell, 0);
              curvature[cell] = a_curvatureG(cell, 0);
            }
          }
          stringstream gName;
          stringstream gCurv;
          gName << "G_" << set << endl;
          gCurv << "curvature_" << set << endl;
          name.clear();
          name.push_back(gName.str());
          this->collectVariables(levelSetFunction.begin(), dbVariables, name, dbVariablesName, 1, a_noCells());
          name.clear();
          name.push_back(gCurv.str());
          this->collectVariables(curvature.begin(), dbVariables, name, dbVariablesName, 1, a_noCells());
        }
      }

      this->collectParameters(m_noSamples, idParameters, "noSamples", idParametersName);
      this->collectParameters(globalTimeStep, idParameters, "globalTimeStep", idParametersName);
      if(m_outputPhysicalTime) {
        this->collectParameters(m_physicalTime, dbParameters, "time", dbParametersName);
        this->collectParameters(m_time, dbParameters, "internalTime", dbParametersName);
      } else {
        this->collectParameters(m_time, dbParameters, "time", dbParametersName);
        this->collectParameters(m_physicalTime, dbParameters, "physicalTime", dbParametersName);
      }

      MIntScratchSpace domainIdCheck(a_noCells(), AT_, "domainIdCheck");
      MIntScratchSpace windowCheck(a_noCells(), AT_, "windowCheck");
      for(MInt cell = 0; cell < a_noCells(); cell++) {
        domainIdCheck.p[cell] = domainId();
        if(a_isBndryGhostCell(cell)) continue;
        if(a_isWindow(cell)) {
          windowCheck.p[cell] = domainId();
        } else
          windowCheck.p[cell] = -1;
      }

      // writing out sponge info
      if(writeSpongeInfo) {
        MFloatScratchSpace spongeFactor(a_noCells(), AT_, "spongeFactor");
        for(MInt cell = 0; cell < a_noCells(); cell++) {
          spongeFactor[cell] = a_spongeFactor(cell);
        }
        name.clear();
        name.push_back("sigmaSponge");
        this->collectVariables(spongeFactor.begin(), dbVariables, name, dbVariablesName, 1, a_noCells());
      }

      // --------------------------------------------

      switch(string2enum(m_outputFormat)) {
        case NETCDF: {
          fileName << ParallelIo::fileExt();
          // TODO labels:FV,IO currently not working for adaptation, check save restartFile
          //      and get solver recalcIds!
          //
          saveGridFlowVarsPar((fileName.str()).c_str(), a_noCells(), noInternalCells(), dbVariables, dbVariablesName, 0,
                              idVariables, idVariablesName, 0, dbParameters, dbParametersName, idParameters,
                              idParametersName, m_recalcIds);
          break;
        }
        case VTK:
        case VTU:
        case VTP: {
          m_fvBndryCnd->recorrectCellCoordinates();
          // grid().extractPointIdsFromGrid(false);
          extractPointIdsFromGrid(m_extractedCells, m_gridPoints, false, m_splitChildToSplitCell, m_vtuLevelThreshold,
                                  m_vtuCoordinatesThreshold);
          reduceVariables();
          fileName << "_D" << domainId() << ".vtu";

          VtkIo<nDim, SysEqn> VtkIo(this);

          VtkIo.writeVtkXmlOutput((fileName.str()).c_str());
          if(m_extractedCells) {
            delete m_extractedCells;
            m_extractedCells = nullptr;
          }
          if(m_gridPoints) {
            delete m_gridPoints;
            m_gridPoints = nullptr;
          }
          m_fvBndryCnd->rerecorrectCellCoordinates();
          break;
        }
        default: {
          stringstream errorMessage;
          errorMessage << "FvCartesianSolverXD::saveOutputFv(): switch variable 'm_outputFormat' with value "
                       << m_outputFormat << " not matching any case." << endl;
          mTerm(1, AT_, errorMessage.str());
        }
      }

      if(domainId() == 0) cerr << "ok" << endl;
    }
  }
}


//------------------------------------------------------------------------------------------------------

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::writeRestartFile(const MBool writeRestart, const MBool writeBackup,
                                                          const MString gridFileName, MInt* recalcIdTree) {
  TRACE();

  m_currentGridFileName = gridFileName;

  if(m_recalcIds != nullptr) {
    for(MInt cellId = 0; cellId < maxNoGridCells(); cellId++) {
      m_recalcIds[cellId] = recalcIdTree[cellId];
    }
  }

  if(writeRestart) {
    saveRestartFile(writeBackup);
  }

  if(m_useSandpaperTrip) {
    saveSandpaperTripVars();
  }

  if(m_wmLES) {
    writeWMTimersASCII();
  }

  saveSampleFiles();
}

//------------------------------------------------------------------------------------------------------

template <MInt nDim_, class SysEqn>
MBool FvCartesianSolverXD<nDim_, SysEqn>::prepareRestart(MBool writeRestart, MBool& writeGridRestart) {
  TRACE();

  writeGridRestart = false;

  // write intermediate restart file
  if(m_restartInterval == -1 && !writeRestart) {
    writeRestart = false;
  }

  MInt relativeTimeStep = globalTimeStep - m_restartOffset;
  MInt relativeRestartTimeStep = m_restartTimeStep - m_restartOffset;

  if(((relativeTimeStep % m_restartInterval) == 0 && relativeTimeStep > relativeRestartTimeStep) || writeRestart) {
    writeRestart = true;

    if(m_forceRestartGrid) {
      m_adaptationSinceLastRestart = true;
      writeGridRestart = true;
      if(m_recalcIds == nullptr && isActive()) mAlloc(m_recalcIds, maxNoGridCells(), "m_recalcIds", -1, AT_);
    }

    if(m_adaptationSinceLastRestartBackup || m_adaptationSinceLastRestart) {
      writeGridRestart = true;
    }
  }

  if(isActive() && m_levelSetMb && writeRestart) {
    if(maxLevel() > minLevel()) {
      for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
        if(a_isBndryGhostCell(cellId)) continue;
        if(a_isHalo(cellId)) continue;
        if(a_level(cellId) != minLevel()) continue;
        reduceData(cellId, &a_pvariable(0, 0), PV->noVariables);
      }
    }
  }

  return writeRestart;
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::reIntAfterRestart(MBool doneRestart) {
  TRACE();

  if(doneRestart) {
    m_adaptationSinceLastRestart = false;
    m_adaptationSinceLastRestartBackup = false;
  }
}


//------------------------------------------------------------------------------------------------------

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::saveSampleFiles() {
  TRACE();

  if(m_time < m_samplingTimeBegin) {
    return;
  }
  if(m_time > m_samplingTimeEnd) {
    return;
  }
  if(globalTimeStep % samplingInterval() != 0) {
    return;
  }

  const MInt oldSize = a_noCells();
  m_cells.size(m_bndryGhostCellsOffset);

  MInt ghostcellbackup = m_totalnoghostcells;
  MInt splitchildbackup = m_totalnosplitchilds;
  m_totalnoghostcells = 0;
  m_totalnosplitchilds = 0;

  stringstream varFileName;

  {
    varFileName << outputDir() << "Q_" << m_noSamples << ParallelIo::fileExt();

    MFloatScratchSpace dbVariables(
        a_noCells() * (PV->noVariables + (MInt)m_levelSet + m_vorticitySize + (MInt)m_qCriterionOutput), AT_,
        "dbVariables");
    MIntScratchSpace idVariables(0, AT_, "idVariables");
    MFloatScratchSpace dbParameters(6, AT_, "dbParameters");
    MIntScratchSpace idParameters(4, AT_, "idParameters");
    vector<MString> dbVariablesName;
    vector<MString> idVariablesName;
    vector<MString> dbParametersName;
    vector<MString> idParametersName;
    vector<MString> name;

    for(MInt v = 0; v < PV->noVariables; v++) {
      name.push_back(m_variablesName[v]);
    }

    this->collectVariables(&a_pvariable(0, 0), dbVariables, name, dbVariablesName, PV->noVariables, a_noCells());

    if(m_vorticityOutput) {
      MFloatScratchSpace vorticity(a_noCells() * m_vorticitySize, AT_, "vorticity");
      getVorticity(&vorticity[0]);
      name.clear();
      for(MInt i = 0; i < m_vorticitySize; i++) {
        name.push_back(m_vorticityName[i]);
      }
      this->collectVariables(vorticity.begin(), dbVariables, name, dbVariablesName, m_vorticitySize, a_noCells(), true);
    }

    if(m_qCriterionOutput) {
      MFloatScratchSpace qCriterion(a_noCells(), AT_, "qCriterion");
      computeQCriterion(qCriterion);
      name.clear();
      name.push_back("qCriterion");
      this->collectVariables(qCriterion.begin(), dbVariables, name, dbVariablesName, 1, a_noCells());
    }
    setRestartFileOutputTimeStep();
    this->collectParameters(m_noSamples, idParameters, "noSamples", idParametersName);
    this->collectParameters(globalTimeStep, idParameters, "globalTimeStep", idParametersName);
    if(m_outputPhysicalTime) {
      this->collectParameters(m_physicalTime, dbParameters, "time", dbParametersName);
    } else {
      this->collectParameters(m_time, dbParameters, "time", dbParametersName);
    }
    this->collectParameters(m_restartFileOutputTimeStep, dbParameters, "timeStep", dbParametersName);
    this->collectParameters(m_noTimeStepsBetweenSamples, idParameters, "noTimeStepsBetweenSamples", idParametersName);
    this->collectParameters(m_physicalTime, dbParameters, "physicalTime", dbParametersName);
    this->collectParameters((MInt)m_forcing, idParameters, "forcing", idParametersName);
    this->collectParameters(m_meanPressure, dbParameters, "meanPressure", dbParametersName);

    // TODO labels:FV,IO currently not working for adaptation, check save restartFile
    //      and get solver recalcIds!
    //
    saveGridFlowVarsPar((varFileName.str()).c_str(), a_noCells(), noInternalCells(), dbVariables, dbVariablesName, 0,
                        idVariables, idVariablesName, 0, dbParameters, dbParametersName, idParameters, idParametersName,
                        m_recalcIds);
  }

  m_noSamples++;


  m_cells.size(oldSize);
  m_totalnoghostcells = ghostcellbackup;
  m_totalnosplitchilds = splitchildbackup;
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeForceCoefficients(MFloat* forceCoefficients) {
  TRACE();
  // const MInt maxNoEmbeddedBodies = 10;
  // ofstream ofl2[maxNoEmbeddedBodies];
  MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();
  MInt cellId, ghostCellId;
  MFloat rhoSurface, pSurface;
  MFloat T, mue, dAoverRe, rhoU2;
  MFloat dist;
  const MFloat eps = c_cellLengthAtLevel(maxRefinementLevel()) * 0.0001;
  MFloat angle, cp, ma;
  MFloat pressure[nDim];
  MFloat tau[nDim];
  MFloat shear[nDim];
  MFloat globalForceCoefficients[nDim];
  MInt localNoSurfacePoints = 0;
  MFloat ypmin = 999999.99;
  MFloat ypmax = F0;
  MFloat ypavg = F0;
  MFloat yprms = F0;
  MFloat ypcnt = F0;

  for(MInt i = 0; i < nDim; i++) {
    tau[i] = numeric_limits<MFloat>::max(); // gcc 4.8.2 maybe uninitialized
  }

  // prepare parallel writing
  if(m_surfDistParallel) {
    for(MInt bndryCellId = 0; bndryCellId < noBndryCells; bndryCellId++) {
      cellId = m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_cellId;
      //       if( cellId >= noInternalCells() )
      //         continue;
      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
      if(a_isHalo(cellId)) continue;
      if(a_isPeriodic(cellId)) continue;
      for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_noSrfcs; srfc++) {
        if(m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_srfcs[srfc]->m_bndryCndId < 3000
           || m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_srfcs[srfc]->m_bndryCndId >= 4000)
          continue;
        localNoSurfacePoints++;
      }
    }
  }
  const MInt surfaceValuesSize = 4 + nDim;
  MFloatScratchSpace surfaceValues(localNoSurfacePoints * surfaceValuesSize, AT_, "surfaceValues");
  //---


  // reset
  for(MInt i = 0; i < nDim; i++) {
    shear[i] = F0;
    pressure[i] = F0;
  }

  rhoU2 = F0;
  for(MInt i = 0; i < nDim; i++) {
    rhoU2 += POW2(m_VVInfinity[i]);
  }
  rhoU2 *= m_rhoInfinity;

  MBool found_ = false;
  MFloat localRetau[1];
  MFloat globalRetau[1];
  localRetau[0] = 0.0;
  globalRetau[0] = 0.0;
  MFloat Re_tau_ = 0.0;
  MFloat localArea1[1];
  MFloat globalArea1[1];
  localArea1[0] = 0.0;
  globalArea1[0] = 0.0;


  MInt counter = 0;
  for(MInt bndryCellId = 0; bndryCellId < noBndryCells; bndryCellId++) {
    // only take (non-ghost) non-slave cells with solid-wall bc into account
    cellId = m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_cellId;
    if(cellId >= noInternalCells() && (!m_surfDistParallel)) continue;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_isHalo(cellId)) continue;
    if(a_isPeriodic(cellId)) continue;

    MFloatScratchSpace dummyPvariables(m_bndryCells->a[bndryCellId].m_noSrfcs, PV->noVariables, AT_, "dummyPvariables");

    if(!m_surfDistParallel)
      if(m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_linkedCellId > -1)
        if(a_bndryId(m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_linkedCellId) > -1) continue;
    if(!m_fvBndryCnd->m_cellMerging) {
      for(MInt s = 0; s < mMin((signed)m_fvBndryCnd->m_bndryCell[bndryCellId].m_recNghbrIds.size(),
                               m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_noSrfcs);
          s++) {
        dummyPvariables(s, PV->P) = m_fvBndryCnd->m_bndryCell[bndryCellId].m_srfcVariables[s]->m_primVars[PV->P];
        dummyPvariables(s, PV->RHO) = m_fvBndryCnd->m_bndryCell[bndryCellId].m_srfcVariables[s]->m_primVars[PV->RHO];
      }
    }
    for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_noSrfcs; srfc++) {
      if(m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_srfcs[srfc]->m_bndryCndId < 3000
         || m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_srfcs[srfc]->m_bndryCndId >= 4000)
        continue;
      // find corresponding ghostId
      ghostCellId = m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_srfcVariables[srfc]->m_ghostCellId;

      // density and pressure on surface
      rhoSurface = F1B2 * (a_pvariable(cellId, PV->RHO) + a_pvariable(ghostCellId, PV->RHO));
      pSurface = F1B2 * (a_pvariable(cellId, PV->P) + a_pvariable(ghostCellId, PV->P));

      // temperature
      T = sysEqn().temperature_ES(rhoSurface, pSurface);

      // calculate the viscosity with the sutherland law mue = T^3/2 * (1+S/T_0)(T + S/T_0)
      mue = SUTHERLANDLAW(T);

      // A_s / Re
      dAoverRe =
          m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_srfcs[srfc]->m_area / (m_referenceLength * sysEqn().m_Re0);

      // distanceVector: connection vector of boundary surface center and cell center
      dist = F0;
      for(MInt i = 0; i < nDim; i++) {
        dist +=
            fabs((a_coordinate(cellId, i) - m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_srfcs[srfc]->m_coordinates[i])
                 * m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_srfcs[srfc]->m_normalVector[i]);
      }

      // determine tau (all dimensions)
      if(m_fvBndryCnd->m_cellMerging) {
        for(MInt orientation = 0; orientation < nDim; orientation++) {
          if(fabs(dist) > eps)
            tau[orientation] =
                mue * F1B2 * (a_pvariable(cellId, PV->VV[orientation]) - a_pvariable(ghostCellId, PV->VV[orientation]))
                / dist;
          else
            tau[orientation] = F0;
        }
      } else {
        rhoSurface = F0;
        pSurface = F0;
        for(MInt n = 0; n < (signed)m_fvBndryCnd->m_bndryCell[bndryCellId].m_recNghbrIds.size(); n++) {
          const MInt nghbrId = m_fvBndryCnd->m_bndryCell[bndryCellId].m_recNghbrIds[n];
          const MFloat nghbrPvariableP = (n < m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_noSrfcs)
                                             ? dummyPvariables(n, PV->P)
                                             : a_pvariable(nghbrId, PV->P);
          const MFloat nghbrPvariableRho = (n < m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_noSrfcs)
                                               ? dummyPvariables(n, PV->RHO)
                                               : a_pvariable(nghbrId, PV->RHO);
          rhoSurface +=
              m_fvBndryCnd->m_bndryCell[bndryCellId].m_srfcVariables[srfc]->m_imagePointRecConst[n] * nghbrPvariableRho;
          pSurface +=
              m_fvBndryCnd->m_bndryCell[bndryCellId].m_srfcVariables[srfc]->m_imagePointRecConst[n] * nghbrPvariableP;
        }
        T = sysEqn().temperature_ES(rhoSurface, pSurface);
        mue = SUTHERLANDLAW(T);
        for(MInt k = 0; k < nDim; k++) {
          tau[k] = mue * m_fvBndryCnd->m_bndryCell[bndryCellId].m_srfcVariables[srfc]->m_normalDeriv[PV->VV[k]];
        }
      }

      // shear-stress and pressure
      for(MInt orientation = 0; orientation < nDim; orientation++) {
        pressure[orientation] +=
            (-F1) * pSurface * m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_srfcs[srfc]->m_area
            * m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_srfcs[srfc]->m_normalVector[orientation];
        shear[orientation] += tau[orientation] * dAoverRe;
      }


      if(m_periodicCells == 3) { // azimuthal periodicity concept


        MFloat Length_2 = c_cellLengthAtCell(cellId);
        if(a_coordinate(cellId, 2) < 200.0 && a_coordinate(cellId, 1) > 200.0
           && a_coordinate(cellId, 1) < (200.0 + Length_2) && a_coordinate(cellId, 0) >= 2.5
           && a_coordinate(cellId, 0) < 2.5 + Length_2) {
          found_ = true;
          Re_tau_ = sqrt(tau[0] / sysEqn().m_Re0 / rhoSurface / (m_Ma * sqrt(m_TInfinity)) / (m_Ma * sqrt(m_TInfinity)))
                    * m_Re;
        }

        if(a_coordinate(cellId, 0) >= 2.5 && a_coordinate(cellId, 0) < 2.5 + Length_2) {
          //	MFloat re_test= sqrt(fabs(tau[ 0 ])/m_Re0/rhoSurface/(m_Ma * sqrt( m_TInfinity ))/(m_Ma * sqrt(
          // m_TInfinity )))*m_Re;
          localArea1[0] += m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_srfcs[0]->m_area;
          localRetau[0] +=
              sqrt(fabs(tau[0]) / sysEqn().m_Re0 / rhoSurface / (m_Ma * sqrt(m_TInfinity)) / (m_Ma * sqrt(m_TInfinity)))
              * m_Re * m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_srfcs[0]->m_area;
        }
      }


      MFloat yplus;
      MFloat magTau = F0;
      for(MInt dim = 0; dim < nDim; dim++) {
        magTau += POW2(tau[dim]);
      }
      yplus = sqrt(sysEqn().m_Re0 * sqrt(magTau) * rhoSurface) * c_cellLengthAtCell(cellId) / mue;

      ypmin = mMin(ypmin, yplus);
      ypmax = mMax(ypmax, yplus);
      ypavg += yplus;
      yprms += POW2(yplus);
      ypcnt += F1;

      // save surface values to scratch space:
      if(m_surfDistParallel) {
        MFloat radToDeg = 360.0 / (2.0 * PI);
        MFloat xOffset = 0.0;
        MFloat yOffset = 0.0;
        if(m_levelSetMb) {
          MInt body = m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_srfcs[srfc]->m_bodyId[0];
          ASSERT(body > -1, "wrong body Id for boundary surface...");
          xOffset = m_bodyCenter[body * nDim + 0];
          yOffset = m_bodyCenter[body * nDim + 1];
        }
        MFloat dx = m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_srfcs[srfc]->m_coordinates[0] - xOffset;
        MFloat dy = m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_srfcs[srfc]->m_coordinates[1] - yOffset;
        angle = 180.0 - (radToDeg * atan2(dy, dx));
        ma = F0;
        for(MInt i = 0; i < nDim; i++)
          ma += POW2(m_fvBndryCnd->m_bndryCell[bndryCellId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]]);
        ma = sqrt(ma);
        ma /= sysEqn().speedOfSound(rhoSurface, pSurface);
        cp = (pSurface - m_PInfinity) / (F1B2 * rhoU2);
        MFloat cf = (m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_srfcs[srfc]->m_normalVector[1] * tau[0]
                     - m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_srfcs[srfc]->m_normalVector[0] * tau[1])
                    / (F1B2 * rhoU2 * sysEqn().m_Re0);
        MInt idcnt = counter * surfaceValuesSize;
        surfaceValues(idcnt++) = angle;
        for(MInt i = 0; i < nDim; i++) {
          surfaceValues(idcnt++) = m_fvBndryCnd->m_bndryCells->a[bndryCellId].m_srfcs[srfc]->m_coordinates[i];
        }
        surfaceValues(idcnt++) = cp;
        surfaceValues(idcnt++) = cf;
        surfaceValues(idcnt) = ma;
        counter++;
      }
    }
  }


  // parallel surface-value output using MPI I/O
  if(m_surfDistParallel) {
    const MString fileName = "surfaceDistribution";
    const MInt dataSolver = surfaceValuesSize;
    const MInt floatWidth = 9;
    const MInt noChars = floatWidth + 2;
    MInt dataSize = dataSolver * noChars * counter;
    ScratchSpace<char> data(dataSize, AT_, "data");
    MInt cnt = 0;
    for(MInt c = 0; c < counter; c++) {
      for(MInt i = 0; i < dataSolver; i++) {
        stringstream s;
        s.clear();
        s << fixed << setprecision(floatWidth) << surfaceValues[c * dataSolver + i];
        s.str().copy(&data[cnt], floatWidth);
        cnt += floatWidth;
        if(i < (dataSolver - 1))
          sprintf(&data[cnt], ", ");
        else
          sprintf(&data[cnt], " \n");
        cnt += 2;
      }
    }
    ASSERT(dataSize == cnt, "");
    ScratchSpace<MInt> dataPerDomain(noDomains(), AT_, "dataPerDomain");
    MPI_Allgather(&dataSize, 1, MPI_INT, &dataPerDomain[0], 1, MPI_INT, mpiComm(), AT_, "dataSize", "dataPerDomain[0]");
    MInt globalDataOffset = 0;
    for(MInt d = 0; d < domainId(); d++)
      globalDataOffset += dataPerDomain[d];
    MPI_File file = nullptr;
    MInt rcode = MPI_File_open(mpiComm(), const_cast<MChar*>(fileName.c_str()), MPI_MODE_CREATE | MPI_MODE_WRONLY,
                               MPI_INFO_NULL, &file, AT_);
    if(rcode != MPI_SUCCESS) mTerm(1, AT_, "Error opening file " + fileName);
    MPI_Status status;
    // MPI_File_seek(file, globalDataOffset, MPI_SEEK_SET, AT_ );
    MPI_File_seek(file, globalDataOffset, MPI_SEEK_CUR, AT_);
    rcode = (counter > 0) ? MPI_File_write(file, &data[0], dataSize, MPI_CHAR, &status) : MPI_SUCCESS;
    if(rcode != MPI_SUCCESS) mTerm(1, AT_, "Error (1) writing to file " + fileName);
    MPI_File_close(&file, AT_);
  }

  if(m_euler) {
    for(MInt i = 0; i < nDim; i++)
      forceCoefficients[i] = (pressure[i]) / (F1B2 * rhoU2);
  } else {
    for(MInt i = 0; i < nDim; i++) {
      forceCoefficients[i] = (shear[i] + pressure[i]) / (F1B2 * rhoU2);
    }
    if(m_periodicCells == 3) { // azimuthal periodicity concept
      for(MInt i = 0; i < nDim; i++)
        forceCoefficients[i] = (shear[i]) / (F1B2 * rhoU2) / (5.0) / (2.0 * PI * 0.5);
    }
  }

  // exchange and sum up the local force coefficients
  if(m_periodicCells == 3) {
    MPI_Allreduce(localRetau, globalRetau, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "localRetau", "globalRetau");
    MPI_Allreduce(localArea1, globalArea1, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "localArea1", "globalArea1");

    globalRetau[0] =
        globalRetau[0] / globalArea1[0]; //( m_domainBoundaries[ 1 ]- m_domainBoundaries[ 0 ])/(2.0*PI*0.5);
  }

  MPI_Reduce(forceCoefficients, globalForceCoefficients, nDim, MPI_DOUBLE, MPI_SUM, 0, mpiComm(), AT_,
             "forceCoefficients", "globalForceCoefficients");
  MPI_Bcast(globalForceCoefficients, nDim, MPI_DOUBLE, 0, mpiComm(), AT_, "globalForceCoefficients");

  for(MInt i = 0; i < nDim; i++) {
    forceCoefficients[i] = globalForceCoefficients[i];
  }

  MPI_Allreduce(MPI_IN_PLACE, &ypmin, 1, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE", "ypmin");
  MPI_Allreduce(MPI_IN_PLACE, &ypmax, 1, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "ypmax");
  MPI_Allreduce(MPI_IN_PLACE, &ypavg, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "ypavg");
  MPI_Allreduce(MPI_IN_PLACE, &yprms, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "yprms");
  MPI_Allreduce(MPI_IN_PLACE, &ypcnt, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "ypcnt");


  if(found_ && m_periodicCells == 3) // azimuthal periodicity concept
  {
    FILE* datei;
    datei = fopen("reTau_loc", "a+");
    fprintf(datei, "%d", globalTimeStep);
    fprintf(datei, "  %f", Re_tau_);
    fprintf(datei, "\n");
    fclose(datei);
  }

  if(domainId() == 0 && m_periodicCells == 3) { // azimuthal periodicity concept
    FILE* datei;
    datei = fopen("reTau", "a+");
    fprintf(datei, "%d", globalTimeStep);
    fprintf(datei, "  %f", globalRetau[0]);
    fprintf(datei, "\n");
    fclose(datei);
  }
  // if ( domainId() == 0 && globalTimeStep%10 == 0 ) cerr << "yplus: min=" << ypmin << ", avg=" << ypavg/ypcnt << ",
  // rms=" << sqrt(yprms/ypcnt) << ", max=" << ypmax << "." << endl; if ( globalTimeStep % m_restartInterval == 0 )
  m_log << "yplus: min=" << ypmin << ", avg=" << ypavg / ypcnt << ", rms=" << sqrt(yprms / ypcnt) << ", max=" << ypmax
        << "." << endl;
}


//-----------------------------------------------------------------------------


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeSlopesByCentralDifferences() {
  const MInt noPVars = PV->noVariables;
  if(m_extractedCells == nullptr) {
    cerr << "Extracted cells not allocated." << endl;
    return;
  }
  for(MInt c = 0; c < m_extractedCells->size(); c++) {
    MInt cellId = m_extractedCells->a[c].m_cellId;
    for(MInt dir = 0; dir < nDim; dir++) {
      MInt n0 = (a_hasNeighbor(cellId, 2 * dir) > 0) ? c_neighborId(cellId, 2 * dir) : cellId;
      MInt n1 = (a_hasNeighbor(cellId, 2 * dir + 1) > 0) ? c_neighborId(cellId, 2 * dir + 1) : cellId;
      for(MInt var = 0; var < noPVars; var++) {
        a_slope(cellId, var, dir) =
            (a_pvariable(n1, var) - a_pvariable(n0, var)) / mMax(1e-10, a_coordinate(n1, dir) - a_coordinate(n0, dir));
      }
    }
  }
}


//-----------------------------------------------------------------------------


/**
 * \brief Check whether any of the extracted cells lie below the halo cell level and interpolate their variables in that
 * case \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::reduceVariables() {
  TRACE();

  const MInt noPVars = PV->noVariables;
  const MBool needSlopes =
      (m_vtuQCriterionOutput || m_vtuVorticityOutput || m_vtuVelocityGradientOutput || m_vtuLambda2Output);
  if(m_extractedCells == nullptr) {
    cerr << "Extracted cells not allocated." << endl;
    return;
  }

  if(m_vtuLevelThreshold < maxRefinementLevel()) {
    if(needSlopes && m_vtuLevelThreshold > maxUniformRefinementLevel()) {
      LSReconstructCellCenter();
    }
    for(MInt c = 0; c < m_extractedCells->size(); c++) {
      MInt cellId = m_extractedCells->a[c].m_cellId;
      if(c_noChildren(cellId) > 0 && a_level(cellId) == m_vtuLevelThreshold) {
        reduceData(cellId, &a_pvariable(0, 0), noPVars);
      }
    }
    if(needSlopes && m_vtuLevelThreshold <= maxUniformRefinementLevel()) {
      exchangeDataFV(&a_pvariable(0, 0), noPVars, false, m_rotIndVarsPV);
      computeSlopesByCentralDifferences();
    } else if(m_vtuWritePointData) {
      exchangeDataFV(&a_pvariable(0, 0), noPVars, false, m_rotIndVarsPV);
    }
    if(needSlopes) {
      for(MInt c = 0; c < m_extractedCells->size(); c++) {
        MInt cellId = m_extractedCells->a[c].m_cellId;
        if(c_noChildren(cellId) > 0 && a_level(cellId) == m_vtuLevelThreshold) {
          reduceData(cellId, &a_slope(0, 0, 0), noPVars * nDim);
        }
      }
    }
  }
  if(m_vtuWritePointData) {
    if(needSlopes) {
      // Rotation of slopes for azimuthal periodicity is not yet handled
      exchangeDataFV(&a_slope(0, 0, 0), noPVars * nDim, false);
    }
  }
}


//-----------------------------------------------------------------------------


/**
 * Saves the restart file as triggerd in the grid controller
 * (this includes a separate grid call to check if a restarGrid file needs to be written)
 *
 * @author D. Hartmann, Update Tim Wegmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::saveRestartFile(const MBool writeBackup) {
  TRACE();

  MBool debugOutput = m_domainIdOutput;
#ifdef _MB_DEBUG_
  debugOutput = true;
#endif

  MBool jet = false;
  if(m_jet || m_confinedFlame) jet = true;
  m_levelSetOutput = m_levelSetOutput || (m_levelSet && !m_combustion && !m_levelSetMb);

  MInt noCells;
  MInt noInternalCellIds;
  std::vector<MInt> recalcIdsSolver(0);
  std::vector<MInt> reOrderedCells(0);
  // << TODO labels:FVMB Without this IMHO memory-leaking but backward-compatible
  // move FVMB test case fails (LS/3D_minLevelIncrease)
  if(grid().newMinLevel() > 0) {
    m_recalcIds = nullptr;
  }
  // >>
  this->calcRecalcCellIdsSolver(m_recalcIds, noCells, noInternalCellIds, recalcIdsSolver, reOrderedCells);
  // a_noCells(), however pVariables need to be written in a different way then!
  noCells = (grid().newMinLevel() < 0) ? a_noCells() : reOrderedCells.size();

  stringstream varFileName;
  stringstream backupFileName;
  const MInt noDbVariables =
      noCells
      * (PV->noVariables                                         // primitive variables
         + (MInt)debugOutput * 2                                 // visualise window/halo-Cells and cellId
         + (MInt)m_levelSetRans + ((MInt)m_acousticAnalysis) * 3 // acoustics analysis variables
         + ((m_averageVorticity && m_movingAvgInterval == 0) || m_saveVorticityToRestart)
               * m_vorticitySize                         // vorticity variables
         + (MInt)m_restartOldVariables * CV->noVariables // dpdt
         + (MInt)m_localTS + (MInt)m_bodyIdOutput + (MInt)m_levelSetOutput
         + ((MInt)(isDetChem<SysEqn> && m_detChemExtendedOutput)) * 3
         + ((MInt)(isDetChem<SysEqn> && m_detChemExtendedOutput && m_acousticAnalysis)) * 4 + (MInt)m_wmLES * 2);

  MBool addVarOut = m_localTS || m_bodyIdOutput || m_levelSetOutput;
  MFloatScratchSpace dbVariables(noDbVariables, AT_, "dbVariables");
  MFloatScratchSpace tmp(noCells * ((MInt)addVarOut), AT_, "tmp");
  MFloatScratchSpace tmpW(noCells * ((MInt)debugOutput), AT_, "tmpW");
  MFloatScratchSpace tmpDetChem(noCells * ((MInt)isDetChem<SysEqn>), AT_, "tmpDetChem");

  const MInt noIdVariables = (MInt)m_isActiveOutput;
  MIntScratchSpace idVariables(noIdVariables, AT_, "idVariables");
  MIntScratchSpace tmpId(noCells * noIdVariables, AT_, "idVariables");

  MInt writeRestartTimeBc2800 = 0;
  if(Context::propertyExists("modeType", m_solverId)) writeRestartTimeBc2800 = 1;
  MFloatScratchSpace dbParameters(writeRestartTimeBc2800 + 5 + 3 * (MInt)jet, AT_, "dbParameters");
  MIntScratchSpace idParameters(4, AT_, "idParameters");
  vector<MString> dbVariablesName;
  vector<MString> idVariablesName;
  vector<MString> dbParametersName;
  vector<MString> idParametersName;
  vector<MString> name;

  for(MInt v = 0; v < PV->noVariables; v++) {
    name.push_back(m_variablesName[v]);
  }

  if(grid().newMinLevel() < 0) {
    this->collectVariables(&a_pvariable(0, 0), dbVariables, name, dbVariablesName, PV->noVariables, a_noCells());
  } else {
    MFloat** variables = nullptr;
    const MInt noPVars = PV->noVariables;
    mAlloc(variables, noCells, noPVars, "variables", 0.0, AT_);

    for(MInt cell = 0; cell < noCells; cell++) {
      for(MInt var = 0; var < noPVars; var++)
        variables[cell][var] = a_pvariable(reOrderedCells[cell], var);
    }

    this->collectVariables(variables, dbVariables, name, dbVariablesName, noPVars, noCells);
    variables = nullptr;
    mDeallocate(variables);
  }

  IF_CONSTEXPR(isDetChem<SysEqn>) {
    if(m_detChemExtendedOutput) {
      name.clear();
      name.push_back("RHO_E");
      if(grid().newMinLevel() < 0) {
        for(MInt cellId = 0; cellId < noCells; cellId++) {
          tmpDetChem[cellId] = a_variable(cellId, CV->RHO_E);
        }
      } else {
        for(MInt cellId = 0; cellId < noCells; cellId++) {
          tmpDetChem[cellId] = a_variable(reOrderedCells[cellId], CV->RHO_E);
        }
      }
      this->collectVariables(tmpDetChem.begin(), dbVariables, name, dbVariablesName, 1, noCells);

      name.clear();
      name.push_back("T");
      if(grid().newMinLevel() < 0) {
        for(MInt cellId = 0; cellId < noCells; cellId++) {
          tmpDetChem[cellId] = a_pvariable(cellId, PV->P) / m_gasConstant * a_avariable(cellId, AV->W_MEAN)
                               / a_pvariable(cellId, PV->RHO);
        }
      } else {
        for(MInt cellId = 0; cellId < noCells; cellId++) {
          tmpDetChem[cellId] = a_pvariable(reOrderedCells[cellId], PV->P) / m_gasConstant
                               * a_avariable(reOrderedCells[cellId], AV->W_MEAN)
                               / a_pvariable(reOrderedCells[cellId], PV->RHO);
        }
      }
      this->collectVariables(tmpDetChem.begin(), dbVariables, name, dbVariablesName, 1, noCells);

      name.clear();
      name.push_back("HeatRelease");
      if(grid().newMinLevel() < 0) {
        for(MInt cellId = 0; cellId < noCells; cellId++) {
          if(a_isBndryGhostCell(cellId)) continue;
          const MFloat dampeningFactor = m_heatReleaseDamp ? m_dampFactor[cellId] : F1;
          tmpDetChem[cellId] = 0;
          for(MUint s = 0; s < PV->m_noSpecies; ++s) {
            tmpDetChem[cellId] -= dampeningFactor * a_speciesReactionRate(cellId, s) * m_standardHeatFormation[s];
          }
        }
      } else {
        for(MInt cellId = 0; cellId < noCells; cellId++) {
          if(a_isBndryGhostCell(cellId)) continue;
          const MFloat dampeningFactor = m_heatReleaseDamp ? m_dampFactor[cellId] : F1;
          tmpDetChem[cellId] = 0;
          for(MUint s = 0; s < PV->m_noSpecies; ++s) {
            tmpDetChem[cellId] -=
                dampeningFactor * a_speciesReactionRate(reOrderedCells[cellId], s) * m_standardHeatFormation[s];
          }
        }
      }
      this->collectVariables(tmpDetChem.begin(), dbVariables, name, dbVariablesName, 1, noCells);

      if(m_acousticAnalysis) {
        MFloatScratchSpace QeI(a_noCells(), AT_, "QeI");
        MFloatScratchSpace QeIII(a_noCells(), AT_, "QeIII");
        MFloatScratchSpace cSquared(a_noCells(), AT_, "cSquared");
        MFloatScratchSpace drhodt(a_noCells(), AT_, "drhodt");

        computeAcousticSourceTermQe(QeI, QeIII, cSquared, drhodt);

        name.clear();
        name.push_back("QeI");
        this->collectVariables(QeI.begin(), dbVariables, name, dbVariablesName, 1, noCells);

        name.clear();
        name.push_back("QeIII");
        this->collectVariables(QeIII.begin(), dbVariables, name, dbVariablesName, 1, noCells);

        name.clear();
        name.push_back("cSquared");
        this->collectVariables(cSquared.begin(), dbVariables, name, dbVariablesName, 1, noCells);

        name.clear();
        name.push_back("drhodt");
        this->collectVariables(drhodt.begin(), dbVariables, name, dbVariablesName, 1, noCells);
      }
    }
  }

  if(m_wmLES) {
    MFloat** wmVariables = nullptr;
    const MInt noWMVars = 2;
    mAlloc(wmVariables, noCells, noWMVars, "wmVariables", 0.0, AT_);
    name.clear();
    name.emplace_back("utau");
    name.emplace_back("u_II");
    for(MUint wmSrfcId = 0; wmSrfcId < m_wmSurfaces.size(); wmSrfcId++) {
      const MInt bndryCellId = m_wmSurfaces[wmSrfcId].m_bndryCellId;
      const MInt cell = m_bndryCells->a[bndryCellId].m_cellId;
      wmVariables[cell][0] = m_wmSurfaces[wmSrfcId].m_wmUTAU;
      wmVariables[cell][1] = m_wmSurfaces[wmSrfcId].m_wmUII;
    }
    this->collectVariables(wmVariables, dbVariables, name, dbVariablesName, noWMVars, noCells);
    wmVariables = nullptr;
    mDeallocate(wmVariables);
  }

  if(debugOutput) {
    name.clear();
    name.push_back("domainId");
    for(MInt i = 0; i < c_noCells(); i++) {
      if(a_isWindow(i)) {
        tmpW[i] = -domainId();
      } else {
        tmpW[i] = domainId();
      }
    }
    this->collectVariables(tmpW.begin(), dbVariables, name, dbVariablesName, 1, noCells);

    name.clear();
    name.push_back("globalId");
    for(MInt i = 0; i < c_noCells(); i++) {
      assertValidGridCellId(i);
      tmpW[i] = c_globalId(i);
    }
    for(MInt i = c_noCells(); i < noCells; i++) {
      tmpW[i] = -1;
    }
    this->collectVariables(tmpW.begin(), dbVariables, name, dbVariablesName, 1, noCells);
  }

  if(m_levelSetOutput) {
    name.clear();
    name.push_back("G");
    if(m_levelSetMb) {
      if(grid().newMinLevel() < 0) {
        for(MInt cellId = 0; cellId < noCells; cellId++) {
          tmp[cellId] = a_levelSetValuesMb(cellId, 0);
        }
      } else {
        for(MInt cellId = 0; cellId < noCells; cellId++) {
          tmp[cellId] = a_levelSetValuesMb(reOrderedCells[cellId], 0);
        }
      }
    } else {
      for(MInt i = 0; i < noCells; i++) {
        tmp[i] = a_levelSetFunction(i, 0);
      }
    }
    this->collectVariables(tmp.begin(), dbVariables, name, dbVariablesName, 1, noCells);
  }

  if(m_localTS) {
    name.clear();
    name.push_back("localTS");
    for(MInt cellId = 0; cellId < noCells; cellId++) {
      tmp[cellId] = a_localTimeStep(cellId);
    }
    this->collectVariables(tmp.begin(), dbVariables, name, dbVariablesName, 1, noCells);
  }

  if(m_levelSetRans) {
    name.clear();
    name.push_back("d");
    for(MInt cellId = 0; cellId < noCells; cellId++) {
      tmp[cellId] = a_levelSetFunction(cellId, 0);
    }
    this->collectVariables(tmp.begin(), dbVariables, name, dbVariablesName, 1, noCells);
  }

  if(m_bodyIdOutput) {
    ASSERT(m_levelSetMb, "");
    if(grid().newMinLevel() < 0) {
      for(MInt cellId = 0; cellId < noCells; cellId++) {
        tmp[cellId] = a_associatedBodyIds(cellId, 0);
      }
    } else {
      for(MInt cellId = 0; cellId < noCells; cellId++) {
        tmp[cellId] = a_associatedBodyIds(reOrderedCells[cellId], 0);
      }
    }
    name.clear();
    name.push_back("BodyId");
    this->collectVariables(tmp.begin(), dbVariables, name, dbVariablesName, 1, noCells);
  }

  if(m_isActiveOutput) {
    if(grid().newMinLevel() < 0) {
      for(MInt cellId = 0; cellId < noCells; cellId++) {
        tmpId[cellId] = (MInt)(!a_hasProperty(cellId, SolverCell::IsInactive));
      }
    } else {
      for(MInt cellId = 0; cellId < noCells; cellId++) {
        tmpId[cellId] = (MInt)(!a_hasProperty(reOrderedCells[cellId], SolverCell::IsInactive));
      }
    }
    name.clear();
    name.push_back("IsActive");
    this->collectVariables(tmpId.begin(), idVariables, name, idVariablesName, 1, noCells);
  }

  if(m_combustion && m_acousticAnalysis) {
    IF_CONSTEXPR(!hasE<SysEqn>)
    mTerm(1, AT_, "Not compatible with SysEqn without RHO_E!");
    const MFloat gammaMinusOne = m_gamma - F1;
    const MFloat FgammaMinusOne = F1 / gammaMinusOne;
    MFloat reactionEnthalpy = (m_burntUnburntTemperatureRatio - F1) * FgammaMinusOne;
    MFloat FtimeStep = 1 / timeStep();

    MFloatScratchSpace dPdT(noCells, AT_, "dPdT");
    MFloatScratchSpace dHdT(noCells, AT_, "dHdT");
    MFloatScratchSpace h(noCells, AT_, "h");

    for(MInt cell = 0; cell < noCells; cell++) {
      dPdT[cell] = F0;
      dHdT[cell] = F0;
      h[cell] = F0;

      if(!a_hasProperty(cell, SolverCell::IsOnCurrentMGLevel)) continue;

      // compute the velocities
      MFloat velPOW2 = F0;
      for(MInt i = 0; i < nDim; i++) {
        velPOW2 += POW2(a_oldVariable(cell, CV->RHO_VV[i]));
      }

      dPdT[cell] = a_pvariable(cell, 3);
      // compute primitive old pressure from conservative variables
      const MFloat pold = sysEqn().pressure(a_oldVariable(cell, CV->RHO), velPOW2, a_oldVariable(cell, CV->RHO_E));

      dPdT[cell] -= pold;
      dPdT[cell] *= FtimeStep;

      h[cell] = a_reactionRate(cell, 0);
      h[cell] *= a_cellVolume(cell) * reactionEnthalpy;
      dHdT[cell] = a_reactionRate(cell, 0);
      dHdT[cell] -= a_reactionRateBackup(cell, 0);
      dHdT[cell] *= a_cellVolume(cell) * reactionEnthalpy;
      dHdT[cell] *= FtimeStep;
    }

    stringstream dPdTname;
    stringstream dHdTname;
    stringstream hName;
    dPdTname << "dPdT";
    dHdTname << "dHdT";
    hName << "h";
    name.clear();
    name.push_back(dPdTname.str());
    this->collectVariables(dPdT.begin(), dbVariables, name, dbVariablesName, 1, noCells);
    name.clear();
    name.push_back(dHdTname.str());
    this->collectVariables(dHdT.begin(), dbVariables, name, dbVariablesName, 1, noCells);
    name.clear();
    name.push_back(hName.str());
    this->collectVariables(h.begin(), dbVariables, name, dbVariablesName, 1, noCells);
  }

  setRestartFileOutputTimeStep();

  this->collectParameters(m_noSamples, idParameters, "noSamples", idParametersName);
  this->collectParameters(globalTimeStep, idParameters, "globalTimeStep", idParametersName);
  if(m_outputPhysicalTime) {
    this->collectParameters(m_physicalTime, dbParameters, "time", dbParametersName);
  } else {
    this->collectParameters(m_time, dbParameters, "time", dbParametersName);
  }
  this->collectParameters(m_restartFileOutputTimeStep, dbParameters, "timeStep", dbParametersName);
  this->collectParameters(m_noTimeStepsBetweenSamples, idParameters, "noTimeStepsBetweenSamples", idParametersName);
  this->collectParameters(m_physicalTime, dbParameters, "physicalTime", dbParametersName);
  this->collectParameters((MInt)m_forcing, idParameters, "forcing", idParametersName);
  if(writeRestartTimeBc2800 != 0) {
    this->collectParameters(m_restartTimeBc2800, dbParameters, "restartTimeBc2800", dbParametersName);
  }

  if(m_jet || m_confinedFlame) {
    this->collectParameters(m_jetDensity, dbParameters, "jetDensity", dbParametersName);
    this->collectParameters(m_jetPressure, dbParameters, "jetPressure", dbParametersName);
    this->collectParameters(m_jetTemperature, dbParameters, "jetTemperature", dbParametersName);
  }

  // Add vorticity to restart file
  if((m_averageVorticity && m_movingAvgInterval == 0) || m_saveVorticityToRestart) {
    MFloatScratchSpace vorticity(noCells * m_vorticitySize, AT_, "vorticity");
    getVorticity(&vorticity[0]);
    name.clear();
    for(MInt i = 0; i < m_vorticitySize; i++) {
      name.push_back(m_vorticityName[i]);
    }
    this->collectVariables(vorticity.begin(), dbVariables, name, dbVariablesName, m_vorticitySize, noCells, true);
  }

  // Store oldVariables in restart file if requested in property file
  if(m_restartOldVariables) {
    // Prepare buffers
    MFloatScratchSpace oldRhoE(noCells, AT_, "oldRhoE");
    MFloatScratchSpace oldRhoU(noCells, AT_, "oldRhoU");
    MFloatScratchSpace oldRhoV(noCells, AT_, "oldRhoV");
    MFloatScratchSpace oldRhoW(nDim == 3 ? noCells : 1, AT_, "oldRhoW");
    MFloatScratchSpace oldRho(noCells, AT_, "oldRho");

    // Copy data to buffers
    IF_CONSTEXPR(nDim == 3) {
      // 3D version
      for(MInt c = 0; c < noCells; c++) {
        IF_CONSTEXPR(hasE<SysEqn>)
        oldRhoE[c] = a_oldVariable(c, CV->RHO_E);
        oldRhoU[c] = a_oldVariable(c, CV->RHO_VV[0]);
        oldRhoV[c] = a_oldVariable(c, CV->RHO_VV[1]);
        oldRhoW[c] = a_oldVariable(c, CV->RHO_VV[2]);
        oldRho[c] = a_oldVariable(c, CV->RHO);
      }
    }
    else {
      // 2D version
      for(MInt c = 0; c < noCells; c++) {
        IF_CONSTEXPR(hasE<SysEqn>)
        oldRhoE[c] = a_oldVariable(c, CV->RHO_E);
        oldRhoU[c] = a_oldVariable(c, CV->RHO_VV[0]);
        oldRhoV[c] = a_oldVariable(c, CV->RHO_VV[1]);
        oldRho[c] = a_oldVariable(c, CV->RHO);
      }
    }

    // Collect data
    name.clear();
    name.push_back("oldRhoE");
    this->collectVariables(oldRhoE.begin(), dbVariables, name, dbVariablesName, 1, noCells);
    name.clear();
    name.push_back("oldRhoU");
    this->collectVariables(oldRhoU.begin(), dbVariables, name, dbVariablesName, 1, noCells);
    name.clear();
    name.push_back("oldRhoV");
    this->collectVariables(oldRhoV.begin(), dbVariables, name, dbVariablesName, 1, noCells);
    IF_CONSTEXPR(nDim == 3) {
      name.clear();
      name.push_back("oldRhoW");
      this->collectVariables(oldRhoW.begin(), dbVariables, name, dbVariablesName, 1, noCells);
    }
    name.clear();
    name.push_back("oldRho");
    this->collectVariables(oldRho.begin(), dbVariables, name, dbVariablesName, 1, noCells);
  }

  MInt* pointerRecalcIds = (m_recalcIds == nullptr) ? nullptr : recalcIdsSolver.data();

  if(m_useNonSpecifiedRestartFile) {
    if(writeBackup) {
      // write a backup restart file
      backupFileName << outputDir() << "restartVariablesBackup_" << globalTimeStep << ParallelIo::fileExt();

      cerr0 << "writing flow variables (backup) for the fv-solver... ";

      saveGridFlowVarsPar((backupFileName.str()).c_str(), noCells, noInternalCellIds, dbVariables, dbVariablesName, 0,
                          idVariables, idVariablesName, 0, dbParameters, dbParametersName, idParameters,
                          idParametersName, pointerRecalcIds);

      cerr0 << "ok" << endl;
    }
    varFileName << outputDir() << "restartVariables" << ParallelIo::fileExt();
    struct stat buffer {};
    if(stat((varFileName.str()).c_str(), &buffer) == 0) {
      // restart already exists rename to current timestep backup
      std::rename(varFileName.str().c_str(), (varFileName.str() + to_string(globalTimeStep) + "backup").c_str());
    }
  } else {
    if(!isMultilevel()) {
      varFileName << outputDir() << "restartVariables" << getIdentifier(m_multipleFvSolver, "", "") << "_"
                  << globalTimeStep << ParallelIo::fileExt();
    } else {
      // For multilevel, use solver-specific file name for restart files
      const MInt maxLength = 256;
      array<MChar, maxLength> buffer{};
      snprintf(buffer.data(), maxLength, "restart_b%02d_t%08d", solverId(), globalTimeStep);
      varFileName << outputDir() << MString(buffer.data()) << ParallelIo::fileExt();
    }
  }

  saveGridFlowVarsPar((varFileName.str()).c_str(), noCells, noInternalCellIds, dbVariables, dbVariablesName, 0,
                      idVariables, idVariablesName, 0, dbParameters, dbParametersName, idParameters, idParametersName,
                      pointerRecalcIds);

  if(domainId() == 0) cerr << "ok" << endl;
}

//-----------------------------------------------------------------------------

/**
 * \brief Saves the solver restart file and the grid restartFile
 * NOTE: for debugging purposes only! for regular output use the saveRestartFile above!
 * @author Tim Wegmann
 */

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::saveDebugRestartFile() {
  stringstream gridFile;
  stringstream gridFilePath;
  gridFile << "grid_" << globalTimeStep << ".Netcdf";
  gridFilePath << outputDir() << "grid_" << globalTimeStep << ".Netcdf";
  MIntScratchSpace recalcIds(grid().raw().treeb().size(), AT_, "recalcIds");

  grid().raw().saveGrid((gridFilePath.str()).c_str(), recalcIds.begin());

  writeRestartFile(true, false, (gridFile.str()).c_str(), recalcIds.begin());
}

/**
 * Loads the restart files
 *
 * @author: D. Hartmann, May 24, 2006
 */
///*
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::loadRestartFile() {
  TRACE();

  {
    stringstream varFileName; // gridFileName
    //---

    if(m_useNonSpecifiedRestartFile) {
      // gridFileName << restartDir() << "restartGrid_" << domainId() << ParallelIo::fileExt();
      if(m_multipleFvSolver) {
        varFileName << restartDir() << "restartVariables" << m_solverId << ParallelIo::fileExt();
      } else {
        varFileName << restartDir() << "restartVariables" << ParallelIo::fileExt();
      }
    } else {
      // TODO labels:FV,toremove remove this, globalTimeStep should not be changed by any solver!
      globalTimeStep = m_restartTimeStep;

      // gridFileName << restartDir() << "restartGrid_" << globalTimeStep << "_" << domainId() <<
      // ParallelIo::fileExt();
      if(!isMultilevel()) {
        if(m_multipleFvSolver) {
          varFileName << restartDir() << "restartVariables" << m_solverId << "_" << globalTimeStep
                      << ParallelIo::fileExt();
        } else {
          varFileName << restartDir() << "restartVariables_" << globalTimeStep << ParallelIo::fileExt();
        }
      } else {
        // For multilevel, use solver-specific file name for restart files
        const MInt maxLength = 256;
        array<MChar, maxLength> buffer{};
        snprintf(buffer.data(), maxLength, "restart_b%02d_t%08d", solverId(), globalTimeStep);
        varFileName << restartDir() << MString(buffer.data()) << ParallelIo::fileExt();
      }
    }

    m_log << "loading primitive variables ... ";
    loadGridFlowVarsPar((varFileName.str()).c_str());

    // Load oldVariable data
    if(m_restartOldVariables && !m_restartOldVariablesReset) {
      m_log << "loading old variables..." << endl;
      loadOldVariables(varFileName.str());
    }

    if(!m_resetInitialCondition) {
      if(!m_useNonSpecifiedRestartFile) {
        if(globalTimeStep != m_restartTimeStep) {
          stringstream errorMessage;
          m_log << "globalTimeStep unequal m_restartTimeStep!" << endl;
          m_log << "globalTimeStep = " << globalTimeStep << " and m_restartTimeStep = " << m_restartTimeStep << endl;
          m_log << "abort!" << endl;
          errorMessage << "globalTimeStep unequal m_restartTimeStep!" << endl;
          errorMessage << "globalTimeStep = " << globalTimeStep << " and m_restartTimeStep = " << m_restartTimeStep
                       << endl;
          errorMessage << "abort!" << endl;
          // mTerm(1,AT_,errorMessage.str());
        }
      } else {
        m_restartTimeStep = globalTimeStep;
        // stringstream backupFileName;
        // backupFileName << "cp " << varFileName.str() << " " << restartDir() << "restartVariables_" << globalTimeStep
        // << ParallelIo::fileExt(); system( (backupFileName.str()).c_str() );
      }
    }
    m_log << "ok" << endl;

    exchangeAll();

    if(m_changeMa) {
      m_log << "convert primitive restart variables ( " << m_previousMa << " ) to the Mach number " << m_Ma << "..."
            << endl;
      convertPrimitiveRestartVariables();
      m_log << "ok" << endl;
    }
    if(m_combustion) { // needed when level set grid is not matching the flow grid at the boundaries
      computePrimitiveVariablesCoarseGrid(noInternalCells());
      // needed if you use more than two layers
      exchangeAll();
      computePrimitiveVariablesCoarseGrid();
    }

    m_log << "computing conservative variables (only on internal cells)... "; // will be updated on all active cells
                                                                              // (halo cells included) in the
                                                                              // RungeKutta constructor
    computeConservativeVariables();
    m_log << "ok" << endl;

    if(m_restartOldVariables && m_restartOldVariablesReset) {
      m_log << "Resetting old variables..." << endl;
      if(domainId() == 0) std::cout << "FVSolver: Resetting old variables..." << endl;

      std::copy_n(&a_variable(0, 0), a_noCells() * CV->noVariables, &a_oldVariable(0, 0));
    }

    if(m_outputPhysicalTime) {
      m_log << "restart at time step: " << globalTimeStep << " - solution physical time: " << m_physicalTime << endl;
    } else {
      m_log << "restart at time step: " << globalTimeStep << " - solution time: " << m_time << endl;
    }
    m_log << m_noSamples << " samples read" << endl;

    m_log << Scratch::printSelf();
  }
}


/** \brief This function loads the flow information of the cells
 *        such as variables and attributes like u_velocity,density,etc.,
 *
 * \todo labels:FV,IO include the function in an IO class, but write it for general use, see saveGridFlowVars(Pars)Par()
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::loadGridFlowVarsPar(const MChar* fileName) {
  TRACE();

  IF_CONSTEXPR(nDim != 2 && nDim != 3) {
    cerr << " In global function loadGridFlowVarsPar: wrong number of "
            "dimensions !"
         << endl;
    mTerm(1, AT_);
    return;
  }

  // File loading.
  stringstream variables;

  using namespace maia;
  using namespace parallel_io;
  ParallelIo parallelIo(fileName, maia::parallel_io::PIO_READ, mpiComm());

  // This should be the same for all the variables
  ParallelIo::size_type dimLen = noInternalCells();
  ParallelIo::size_type start = domainOffset(domainId()) - grid().bitOffset();

  // set offset for all read operations
  parallelIo.setOffset(dimLen, start);

  // load variable names
  static constexpr MInt maxVariables = 128;
  array<MString, maxVariables> varNames;

  for(MInt vId = 0; vId < maxVariables; vId++) {
    MString varName = "variables" + to_string(vId);

    if(!parallelIo.hasDataset(varName)) {
      break;
    }

    MString tmp;
    parallelIo.getAttribute(&tmp, "name", varName);
    varNames[vId] = tmp;
  }

  auto varPosition = [&](const MString& _varName) {
    auto it = find(varNames.begin(), varNames.end(), _varName);
    if(it == varNames.end()) {
      mTerm(-1, "Couldn't find variable with name " + _varName + " for solver " + to_string(m_solverId));
    }
    return "variables" + to_string(distance(varNames.begin(), it));
  };

  auto hasVar = [&](const MString& _varName) {
    auto it = find(varNames.begin(), varNames.end(), _varName);
    return !(it == varNames.end());
  };

  // Load our variables
  MFloatScratchSpace tmpVar((MInt)dimLen, AT_, "tmpVar");

  // Velocity u
  parallelIo.readArray(tmpVar.getPointer(), varPosition("u"));
  for(MInt i = 0; i < (MInt)dimLen; ++i) {
    a_pvariable(i, PV->U) = tmpVar.p[i];
  }

  // Velocity v
  parallelIo.readArray(tmpVar.getPointer(), varPosition("v"));
  for(MInt i = 0; i < (MInt)dimLen; ++i) {
    a_pvariable(i, PV->V) = tmpVar.p[i];
  }

  // Density rho
  parallelIo.readArray(tmpVar.getPointer(), varPosition("rho"));
  for(MInt i = 0; i < (MInt)dimLen; ++i) {
    a_pvariable(i, PV->RHO) = tmpVar.p[i];
  }

  // pressure p
  parallelIo.readArray(tmpVar.getPointer(), varPosition("p"));
  for(MInt i = 0; i < (MInt)dimLen; ++i) {
    a_pvariable(i, PV->P) = tmpVar.p[i];
  }

  // RANS
  IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
    for(MInt r = 0; r < m_noRansEquations; r++) {
      parallelIo.readArray(tmpVar.getPointer(), varPosition(m_variablesName[nDim + 2 + r]));
      for(MInt i = 0; i < (MInt)dimLen; ++i) {
        a_pvariable(i, PV->NN[r]) = tmpVar.p[i];
      }
    }
  }

  if(m_combustion) {
    if(m_noSpecies > 1) {
      mTerm(-1, "code is incorrect!");
    }

    // species
    IF_CONSTEXPR(hasPV_C<SysEqn>::value)
    if(m_noSpecies == 1) {
      parallelIo.readArray(tmpVar.getPointer(), varPosition("c"));
      for(MInt i = 0; i < (MInt)dimLen; ++i) {
        a_pvariable(i, PV->C) = tmpVar.p[i];
      }
    }
    if(m_statisticCombustionAnalysis) {
      // heat release rate
      parallelIo.readArray(tmpVar.getPointer(), varPosition("h"));
      for(MInt i = 0; i < (MInt)dimLen; ++i) {
        m_heatRelease[i] = tmpVar.p[i];
      }
    }
  } else {
    if(m_localTS && hasVar("localTS")) {
      parallelIo.readArray(tmpVar.getPointer(), varPosition("localTS"));
      for(MInt i = 0; i < (MInt)dimLen; ++i) {
        a_localTimeStep(i) = tmpVar.p[i];
      }
    }
    if(m_noSpecies == 1 && hasVar("Y")) {
      parallelIo.readArray(tmpVar.getPointer(), varPosition("Y"));
      for(MInt i = 0; i < (MInt)dimLen; ++i) {
        a_pvariable(i, PV->Y[0]) = tmpVar.p[i];
      }
    } else {
      for(MInt s = 0; s < m_noSpecies; s++) {
        MString tmpString = "Y" + m_speciesName[s];
        if(hasVar(tmpString)) {
          parallelIo.readArray(tmpVar.getPointer(), varPosition(tmpString));
          for(MInt i = 0; i < (MInt)dimLen; ++i) {
            a_pvariable(i, PV->Y[s]) = tmpVar.p[i];
          }
        }
      }
    }
  }

  IF_CONSTEXPR(nDim == 3) {
    // Velocity w
    parallelIo.readArray(tmpVar.getPointer(), varPosition("w"));
    for(MInt i = 0; i < (MInt)dimLen; ++i) {
      a_pvariable(i, PV->W) = tmpVar.p[i];
    }

    // Load vorticity data if used for averaging (but not for moving average)
    if(m_loadSampleVariables && m_averageVorticity && m_movingAvgInterval == 0) {
      mTerm(-666, "fix calls see above");

      parallelIo.readArray(&m_vorticity[0][0], "variables5", 3);
      parallelIo.readArray(&m_vorticity[0][1], "variables6", 3);
      parallelIo.readArray(&m_vorticity[0][2], "variables7", 3);
    }
  }
  else {
    // Load vorticity data if used for averaging (but not for moving average)
    if(m_loadSampleVariables && m_averageVorticity && m_movingAvgInterval == 0) {
      mTerm(-666, "fix calls see above");
      parallelIo.readArray(&m_vorticity[0][0], "variables4");
    }
  }

  // Getting solution parameters.
  parallelIo.getAttribute(&m_noSamples, "noSamples");

  if(!m_resetInitialCondition) {
    parallelIo.getAttribute(&globalTimeStep, "globalTimeStep");
    if(m_outputPhysicalTime) {
      parallelIo.getAttribute(&m_physicalTime, "time");
    } else {
      parallelIo.getAttribute(&m_time, "time");
    }
    parallelIo.getAttribute(&m_timeStep, "timeStep");
    parallelIo.getAttribute(&m_physicalTime, "physicalTime");
  }

  if(useTimeStepFromRestartFile() && approx(timeStep(), -1., m_eps)) {
    mTerm(1, AT_,
          "the time-step from the restart file will be used but its equal to -1. That might not do what you think "
          "it "
          "does...");
  }

  if(m_restartBc2800) {
    parallelIo.getAttribute(&m_restartTimeBc2800, "restartTimeBc2800");
  }

  parallelIo.getAttribute(&m_noTimeStepsBetweenSamples, "noTimeStepsBetweenSamples");

  // ncmpi_inq_varid(ncId, "forcing", &varId);
  // ncmpi_get_vara_int_all(ncId, varId, &start, &cnt, &m_forcing);

  if(parallelIo.hasAttribute("meanPressure")) {
    parallelIo.getAttribute(&m_meanPressure, "meanPressure");
    m_log << "meanPressure is" << m_meanPressure << endl;
  }

  if(m_jet || m_confinedFlame) {
    parallelIo.getAttribute(&m_jetDensity, "jetDensity");
    m_log << "jetDensity is" << m_jetDensity << endl;

    parallelIo.getAttribute(&m_jetPressure, "jetPressure");
    m_log << "jetPressure is" << m_jetPressure << endl;

    parallelIo.getAttribute(&m_jetTemperature, "jetTemperature");
    m_log << "jetTemperature is" << m_jetTemperature << endl;
  }

  if(parallelIo.hasAttribute("Re", "")) {
    parallelIo.getAttribute(&m_Re, "Re");
    parallelIo.getAttribute(&sysEqn().m_Re0, "Re0");
    parallelIo.getAttribute(&m_randomDeviceSeed, "randomDeviceSeed");
    if(domainId() == 0) m_log << "Read Reynolds number: " << m_Re << " (" << sysEqn().m_Re0 << ")." << endl;
  }

  m_log << Scratch::printSelfReport();
}


/** \brief This function loads oldVariable data from a restartFile-type file
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::loadOldVariables(const MString& fileName) {
  TRACE();
  IF_CONSTEXPR(!hasE<SysEqn>)
  mTerm(1, AT_, "Not compatible with SysEqn without RHO_E!");

  ParallelIo parallelIo(fileName, maia::parallel_io::PIO_READ, mpiComm());
  parallelIo.setOffset(noInternalCells(), domainOffset(domainId()));

  MFloatScratchSpace buffer(noInternalCells(), AT_, "buffer");
  IF_CONSTEXPR(nDim == 2) {
    // rho*e
    parallelIo.readArray(&buffer[0], "variables7");
    for(MInt i = 0; i < noInternalCells(); i++) {
      a_oldVariable(i, CV->RHO_E) = buffer[i];
    }
    // rho*u
    parallelIo.readArray(&buffer[0], "variables8");
    for(MInt i = 0; i < noInternalCells(); i++) {
      a_oldVariable(i, CV->RHO_VV[0]) = buffer[i];
    }
    // rho*v
    parallelIo.readArray(&buffer[0], "variables9");
    for(MInt i = 0; i < noInternalCells(); i++) {
      a_oldVariable(i, CV->RHO_VV[1]) = buffer[i];
    }
    // rho
    parallelIo.readArray(&buffer[0], "variables10");
    for(MInt i = 0; i < noInternalCells(); i++) {
      a_oldVariable(i, CV->RHO) = buffer[i];
    }

    IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
      for(MInt rans = 1; rans < (m_noRansEquations + 1); rans++) {
        MString varname = "variables" + to_string(10 + rans);
        parallelIo.readArray(&buffer[0], varname);
        for(MInt i = 0; i < noInternalCells(); i++) {
          a_oldVariable(i, CV->RHO_NN[rans]) = buffer[i];
        }
      }
    }
  }
  else IF_CONSTEXPR(nDim == 3) {
    // rho*e
    parallelIo.readArray(&buffer[0], "variables8");
    for(MInt i = 0; i < noInternalCells(); i++) {
      a_oldVariable(i, CV->RHO_E) = buffer[i];
    }
    // rho*u
    parallelIo.readArray(&buffer[0], "variables9");
    for(MInt i = 0; i < noInternalCells(); i++) {
      a_oldVariable(i, CV->RHO_VV[0]) = buffer[i];
    }
    // rho*v
    parallelIo.readArray(&buffer[0], "variables10");
    for(MInt i = 0; i < noInternalCells(); i++) {
      a_oldVariable(i, CV->RHO_VV[1]) = buffer[i];
    }
    // rho*w
    parallelIo.readArray(&buffer[0], "variables11");
    for(MInt i = 0; i < noInternalCells(); i++) {
      a_oldVariable(i, CV->RHO_VV[2]) = buffer[i];
    }
    // rho
    parallelIo.readArray(&buffer[0], "variables12");
    for(MInt i = 0; i < noInternalCells(); i++) {
      a_oldVariable(i, CV->RHO) = buffer[i];
    }
    IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
      for(MInt rans = 1; rans < (m_noRansEquations + 1); rans++) {
        MString varname = "variables" + to_string(12 + rans);
        parallelIo.readArray(&buffer[0], varname);
        for(MInt i = 0; i < noInternalCells(); i++) {
          a_oldVariable(i, CV->RHO_NN[rans]) = buffer[i];
        }
      }
    }
  }
  else {
    mTerm(1, "bad number of dimensions");
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::restartWMSurfaces() {
  TRACE();

  m_log << "Reading WM Surface data from restart file ...";

  using namespace maia;
  using namespace parallel_io;

  // This should be the same of the function calling this and providing tmpVar
  ParallelIo::size_type dimLen = noInternalCells();
  ParallelIo::size_type start = domainOffset(domainId()) - grid().bitOffset();


  stringstream varFileName;

  if(m_useNonSpecifiedRestartFile) {
    // gridFileName << restartDir() << "restartGrid_" << domainId() << ParallelIo::fileExt();
    if(m_multipleFvSolver) {
      varFileName << restartDir() << "restartVariables" << m_solverId << ParallelIo::fileExt();
    } else {
      varFileName << restartDir() << "restartVariables" << ParallelIo::fileExt();
    }
  } else {
    if(!isMultilevel()) {
      if(m_multipleFvSolver) {
        varFileName << restartDir() << "restartVariables" << m_solverId << "_" << m_restartTimeStep
                    << ParallelIo::fileExt();
      } else {
        varFileName << restartDir() << "restartVariables_" << m_restartTimeStep << ParallelIo::fileExt();
      }
    } else {
      // For multilevel, use solver-specific file name for restart files
      const MInt maxLength = 256;
      array<MChar, maxLength> buffer{};
      snprintf(buffer.data(), maxLength, "restart_b%02d_t%08d", solverId(), m_restartTimeStep);
      varFileName << restartDir() << MString(buffer.data()) << ParallelIo::fileExt();
    }
  }

  ParallelIo parallelIo(varFileName.str().c_str(), maia::parallel_io::PIO_READ, mpiComm());

  // set offset for all read operations
  parallelIo.setOffset(dimLen, start);

  // load variable names :
  static constexpr MInt maxVariables(128);
  array<MString, maxVariables> varNames;

  for(MInt vId = 0; vId < maxVariables; vId++) {
    MString varName = "variables" + to_string(vId);

    if(!parallelIo.hasDataset(varName)) {
      break;
    }
    MString tmp;
    parallelIo.getAttribute(&tmp, "name", varName);
    varNames[vId] = tmp;
  }

  auto varPosition = [&](const MString& _varName) {
    auto it = find(varNames.begin(), varNames.end(), _varName);
    if(it == varNames.end()) {
      mTerm(-1, "Couldn't find variable with name " + _varName + " for solver " + to_string(m_solverId));
    }
    return "variables" + to_string(distance(varNames.begin(), it));
  };

  /*
  auto hasVar = [&](const MString& _varName) {
    auto it = find(varNames.begin(), varNames.end(), _varName);
    return !(it == varNames.end());
  };
  */

  // load out variables
  MFloatScratchSpace tmpVar((MInt)dimLen, AT_, "tmpVar");

  // shear velocity utau
  parallelIo.readArray(tmpVar.getPointer(), varPosition("utau"));
  for(MUint wmSrfcId = 0; wmSrfcId < m_wmSurfaces.size(); wmSrfcId++) {
    const MInt bndryCellId = m_wmSurfaces[wmSrfcId].m_bndryCellId;
    const MInt cellId = m_bndryCells->a[bndryCellId].m_cellId;
    m_wmSurfaces[wmSrfcId].m_wmUTAU = tmpVar.p[cellId];
  }

  // parallel velocity u_II
  parallelIo.readArray(tmpVar.getPointer(), varPosition("u_II"));
  for(MUint wmSrfcId = 0; wmSrfcId < m_wmSurfaces.size(); wmSrfcId++) {
    const MInt bndryCellId = m_wmSurfaces[wmSrfcId].m_bndryCellId;
    const MInt cellId = m_bndryCells->a[bndryCellId].m_cellId;
    m_wmSurfaces[wmSrfcId].m_wmUII = tmpVar.p[cellId];
  }

  m_log << " done." << endl;
}


////////////////////////////////////////////////////////////////////////////////
/// Inner Fv Loops: performance critical

/// \brief Reconstruction of the slopes of the primitive variables
/// at the center of the cells by use of the least squares approximation.
///
/// \note INNER MOST LOOP: about 30% MAIA_FV_Solvers run time is spent here.
/// Don't change/add anything here unless you __REALLY__ know what you are doing.
template <MInt nDim_, class SysEqn>
inline void FvCartesianSolverXD<nDim_, SysEqn>::LSReconstructCellCenter_(const MUint /* noSpecies */) {
  // TRACE();
  const MUint noPVars = PV->noVariables;
  const MUint totalNoSlopes = nDim * noPVars * a_noCells();
  MFloat* const RESTRICT slopes = ALIGNED_MF(&a_slope(0, 0, 0));
  const MInt* const RESTRICT recCellIds = ALIGNED_I(m_reconstructionCellIds.data());
  const MInt* const RESTRICT recNghbrIds = ALIGNED_I(m_reconstructionNghbrIds.data());
  const MFloat* const RESTRICT cellCoord = ALIGNED_F(&a_coordinate(0, 0));

  {
// Reset slopes to zero:
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for(MUint slopeId = 0; slopeId < totalNoSlopes; ++slopeId) {
      slopes[slopeId] = F0;
    }

    // Compute slopes:
    for(MUint k = 0; k < m_reconstructionDataSize; ++k) {
      const MFloat* const RESTRICT recNghbrVars = ALIGNED_F(&a_pvariable(recNghbrIds[k], 0));
      const MFloat* const RESTRICT recCellVars = ALIGNED_F(&a_pvariable(recCellIds[k], 0));
      const MUint slopeId = nDim * noPVars * recCellIds[k];
      for(MUint v = 0; v < noPVars; ++v) {
        const MFloat tmp = recNghbrVars[v] - recCellVars[v];
        slopes[slopeId + v * nDim] += m_reconstructionConstants[nDim * k] * tmp;
        slopes[slopeId + v * nDim + 1] += m_reconstructionConstants[nDim * k + 1] * tmp;
        IF_CONSTEXPR(nDim == 3) slopes[slopeId + v * nDim + 2] += m_reconstructionConstants[nDim * k + 2] * tmp;
      }
    }

    if(m_reConstSVDWeightMode == 3) {
      for(MInt cellId = 0; cellId < a_noCells(); ++cellId) {
        if(!a_hasProperty(cellId, SolverCell::HasCoarseNghbr)) {
          continue;
        }
        const MFloat* const RESTRICT recCellVars = ALIGNED_F(&a_pvariable(0, 0) + noPVars * cellId);
        const MUint slopeId = nDim * noPVars * cellId;
        std::array<MBool, nDim> dirsJmp = {};
        for(MInt d = 0; d < nDim; ++d) {
          if(m_cells.nghbrInterface(cellId, 2 * d) == 3 || m_cells.nghbrInterface(cellId, 2 * d + 1) == 3) {
            dirsJmp[d] = true;
          } else {
            dirsJmp[d] = false;
          }
        }

        const MUint cc1 = cellId * nDim;
        const MFloat* const RESTRICT cellIdCoord = ALIGNED_F(cellCoord + cc1);
        for(MUint v = 0; v < noPVars; ++v) {
          for(MInt d = 0; d < nDim; ++d) {
            if(dirsJmp[d]) {
              slopes[slopeId + v * nDim + d] = 0.0;
            }
          }
        }

        for(MInt k = a_reconstructionData(cellId); k < a_reconstructionData(cellId + 1); ++k) {
          const MFloat* const RESTRICT recNghbrVars = ALIGNED_F(&a_pvariable(0, 0) + noPVars * recNghbrIds[k]);
          const MUint cc = recNghbrIds[k] * nDim;
          const MUint slopeId2 = nDim * noPVars * cellId;
          const MFloat* const RESTRICT nghbrCoord = ALIGNED_F(cellCoord + cc);

          for(MUint v = 0; v < noPVars; ++v) {
            MFloat tmp = recNghbrVars[v] - recCellVars[v];
            for(MInt d = 0; d < nDim; ++d) {
              if(!dirsJmp[d]) {
                const MFloat dx = nghbrCoord[d] - cellIdCoord[d];
                tmp -= slopes[slopeId2 + v * nDim + d] * dx;
              }
            }
            for(MInt d = 0; d < nDim; ++d) {
              if(dirsJmp[d]) {
                slopes[slopeId + v * nDim + d] += m_reconstructionConstants[nDim * k + d] * tmp;
              }
            }
          }
        }
      }
    }
  }
}

/// \brief Dispatch the reconstruction computation to the appropiate loop.
///
/// NOTE: m_noSpecies is a run-time variable. The point of the if case is to
/// _encourage_ the compiler to produce optimized loops for the special cases.
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::LSReconstructCellCenter() {
  TRACE();
  const MInt noSpecies = m_noSpecies;
  if(noSpecies == 0) {
    LSReconstructCellCenter_(0);
  } else if(noSpecies == 1) {
    LSReconstructCellCenter_(1);
  } else {
    LSReconstructCellCenter_(noSpecies);
  }
}


/// Determine gradients of conservative variables at cell centers and store in a_storedSlope.
///
/// \author Michael Schlottke-Lakemper (mic) <mic@aia.rwth-aachen.de>
/// \date 2018-12-12
///
/// Copied from/based on src/fvsolverxd.h::FvCartesianSolverXD::LSReconstructCellCenter(...)
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::LSReconstructCellCenterCons(const MUint /* noSpecies */) {
  // TRACE();
  const MUint noCVars = CV->noVariables;
  const MUint noSlopes = nDim * noCVars;
  const MUint totalNoSlopes = noSlopes * a_noCells();
  const MUint recDataSize = m_reconstructionDataSize;
  MFloat* const RESTRICT slopes = ALIGNED_MF(&a_storedSlope(0, 0, 0));
  const MInt* const RESTRICT recCellIds = ALIGNED_I(m_reconstructionCellIds.data());
  const MInt* const RESTRICT recNghbrIds = ALIGNED_I(m_reconstructionNghbrIds.data());
  const MFloat* const RESTRICT vars = ALIGNED_F(&a_variable(0, 0));
  const MFloat* const RESTRICT cellCoord = ALIGNED_F(&a_coordinate(0, 0));

// Reset slopes to zero:
#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MUint slopeId = 0; slopeId < totalNoSlopes; ++slopeId) {
    slopes[slopeId] = F0;
  }

  // Compute slopes:
  for(MUint k = 0; k < recDataSize; ++k) {
    const MFloat* const RESTRICT recNghbrVars = ALIGNED_F(vars + noCVars * recNghbrIds[k]);
    const MFloat* const RESTRICT recCellVars = ALIGNED_F(vars + noCVars * recCellIds[k]);
    const MUint slopeId = noSlopes * recCellIds[k];
    for(MUint v = 0; v < noCVars; ++v) {
      const MFloat tmp = recNghbrVars[v] - recCellVars[v];
      slopes[slopeId + v * nDim] += m_reconstructionConstants[nDim * k] * tmp;
      slopes[slopeId + v * nDim + 1] += m_reconstructionConstants[nDim * k + 1] * tmp;
      IF_CONSTEXPR(nDim == 3) slopes[slopeId + v * nDim + 2] += m_reconstructionConstants[nDim * k + 2] * tmp;
    }
  }

  if(m_reConstSVDWeightMode == 3) {
    for(MInt cellId = 0; cellId < a_noCells(); ++cellId) {
      if(!a_hasProperty(cellId, SolverCell::HasCoarseNghbr)) {
        continue;
      }
      const MFloat* const RESTRICT recCellVars = ALIGNED_F(vars + noCVars * cellId);
      const MUint slopeId = nDim * noCVars * cellId;
      std::array<MBool, nDim> dirsJmp = {};
      for(MInt d = 0; d < nDim; ++d) {
        if(m_cells.nghbrInterface(cellId, 2 * d) == 3 || m_cells.nghbrInterface(cellId, 2 * d + 1) == 3) {
          dirsJmp[d] = true;
        } else {
          dirsJmp[d] = false;
        }
      }

      const MUint cc1 = cellId * nDim;
      const MFloat* const RESTRICT cellIdCoord = ALIGNED_F(cellCoord + cc1);
      for(MUint v = 0; v < noCVars; ++v) {
        for(MInt d = 0; d < nDim; ++d) {
          if(dirsJmp[d]) {
            slopes[slopeId + v * nDim + d] = 0.0;
          }
        }
      }

      for(MInt k = a_reconstructionData(cellId); k < a_reconstructionData(cellId + 1); ++k) {
        const MFloat* const RESTRICT recNghbrVars = ALIGNED_F(vars + noCVars * recNghbrIds[k]);
        const MUint cc = recNghbrIds[k] * nDim;
        const MUint slopeId2 = nDim * noCVars * cellId;
        const MFloat* const RESTRICT nghbrCoord = ALIGNED_F(cellCoord + cc);

        for(MUint v = 0; v < noCVars; ++v) {
          MFloat tmp = recNghbrVars[v] - recCellVars[v];
          for(MInt d = 0; d < nDim; ++d) {
            if(!dirsJmp[d]) {
              const MFloat dx = nghbrCoord[d] - cellIdCoord[d];
              tmp -= slopes[slopeId2 + v * nDim + d] * dx;
            }
          }
          for(MInt d = 0; d < nDim; ++d) {
            if(dirsJmp[d]) {
              slopes[slopeId + v * nDim + d] += m_reconstructionConstants[nDim * k + d] * tmp;
            }
          }
        }
      }
    }
  }
}

/// \brief Interpolates the cell-centered primitive variables into the surface
/// centroids linearly by using their cell-centered slopes.
///
/// NOTE: this is a very intensive inner-loop of MAIA
/// Don't change/add anything here unless you __REALLY__
/// know what you are doing.
template <MInt nDim_, class SysEqn>
inline void FvCartesianSolverXD<nDim_, SysEqn>::computeSurfaceValues_(const MUint /* noSpecies */) {
  // TRACE();
  const MUint noSrfcs = a_noSurfaces();
  const MUint noPVars = PV->noVariables;
  const MUint noSlopes = nDim * noPVars;
  const MUint surfaceVarMemory = 2 * noPVars;
  const MInt* const RESTRICT nghbrCellIds = ALIGNED_I(&a_surfaceNghbrCellId(0, 0));
  const MFloat* const RESTRICT cellCoord = ALIGNED_F(&a_coordinate(0, 0));
  const MFloat* const RESTRICT surfaceCoord = ALIGNED_F(&a_surfaceCoordinate(0, 0));
  MFloat* const RESTRICT surfaceVar = ALIGNED_MF(&a_surfaceVariable(0, 0, 0));
  const MFloat* const RESTRICT cellSlopes = ALIGNED_F(&a_slope(0, 0, 0));
  const MFloat* const RESTRICT vars = ALIGNED_F(&a_pvariable(0, 0));

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MUint srfcId = 0; srfcId < noSrfcs; ++srfcId) {
    const MUint sc = srfcId * nDim;
    const MInt* const RESTRICT nghbrIds = ALIGNED_I(nghbrCellIds + srfcId * 2);
    const MFloat* const RESTRICT srfcCoord = ALIGNED_F(surfaceCoord + sc);
    for(MUint side = 0; side < 2; ++side) { // for each surface side
      const MUint nghbr = nghbrIds[side];
      const MUint cc = nghbr * nDim;
      const MFloat* const RESTRICT nghbrCoord = ALIGNED_F(cellCoord + cc);
      MFloat dx[nDim];
      for(MInt d = 0; d < nDim; ++d) {
        dx[d] = srfcCoord[d] - nghbrCoord[d];
      }
      const MUint srfcVarOffset = srfcId * surfaceVarMemory + side * noPVars;
      MFloat* const RESTRICT currentSrfcVars = ALIGNED_MF(surfaceVar + srfcVarOffset);
      const MFloat* const RESTRICT nghbrVars = ALIGNED_F(vars + nghbr * noPVars);
      for(MUint v = 0; v < noPVars; ++v) {
        const MUint sl = nghbr * noSlopes + v * nDim;
        const MFloat* const RESTRICT nghbrSlopes = ALIGNED_F(cellSlopes + sl);
        currentSrfcVars[v] = nghbrVars[v];
        for(MInt d = 0; d < nDim; ++d) {
          currentSrfcVars[v] += nghbrSlopes[d] * dx[d];
        }
      }
    }
  }
}

/// \brief Dispatches the computation of the surface values for different number of species
///
/// The objective is to encourage the compiler to generate different optimized version
/// depending on the value of m_noSpecies.
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeSurfaceValues(const MInt /*timerId*/) {
  TRACE();


  RECORD_TIMER_START(m_timers[Timers::ReconstSrfcCompValues]);
  // compute the surface values:
  const MUint noSpecies = m_noSpecies;
  if(noSpecies == 0) {
    computeSurfaceValues_(0);
  } else if(noSpecies == 1) {
    computeSurfaceValues_(1);
  } else {
    computeSurfaceValues_(noSpecies);
  }
  RECORD_TIMER_STOP(m_timers[Timers::ReconstSrfcCompValues]);

  RECORD_TIMER_START(m_timers[Timers::ReconstSrfcCorrVars]);
  // correct the boundary surface values
  IF_CONSTEXPR(nDim == 2) m_fvBndryCnd->correctBoundarySurfaceVariables();
  IF_CONSTEXPR(nDim == 3) {
    if(m_fvBndryCnd->m_multipleGhostCells) { // Multiple-Ghost-Cell
      if(m_fvBndryCnd->m_surfaceGhostCell) {
        m_fvBndryCnd->correctBoundarySurfaceVariablesMGCSurface();
      } else {
        m_fvBndryCnd->correctBoundarySurfaceVariablesMGC();
      }
    } else {
      m_fvBndryCnd->correctBoundarySurfaceVariables();
    }
  }
  RECORD_TIMER_STOP(m_timers[Timers::ReconstSrfcCorrVars]);

  RECORD_TIMER_START(m_timers[Timers::ReconstSrfcUpdateGhost]);
  // update the ghost cell slopes for viscous flux balance
  m_fvBndryCnd->updateGhostCellSlopesViscous();
  RECORD_TIMER_STOP(m_timers[Timers::ReconstSrfcUpdateGhost]);

  RECORD_TIMER_START(m_timers[Timers::ReconstSrfcUpdateCutOff]);
  m_fvBndryCnd->updateCutOffSlopesViscous();
  RECORD_TIMER_STOP(m_timers[Timers::ReconstSrfcUpdateCutOff]);
}


/// limits the pressure slopes according to Venkatakrishnan, AIAA paper 93-0880 before calling
/// computeSurfaceValues_(noSpecies), modified for cartesian cells by
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeSurfaceValuesLimitedSlopes(MInt NotUsed(timerId)) {
#define VENKATAKRISHNAN
  // VENKATAKRISHNAN VENKATAKRISHNAN_MOD
  TRACE();
  const MInt noCells = a_noCells();
  MFloat* const RESTRICT cellSlopes = ALIGNED_MF(&a_slope(0, 0, 0));
  const MInt slopeMemory = m_slopeMemory;

  for(MInt cellId = 0; cellId < noCells; cellId++) {
    if(a_isBndryGhostCell(cellId)) continue;
    if(a_hasProperty(cellId, SolverCell::IsCutOff)) continue;
    for(MInt it = 0; it < m_noLimitedSlopesVar; it++) {
      MInt varId = m_limitedSlopesVar[it];

      MFloat minNghbrDelta = F0;
      MFloat maxNghbrDelta = F0;
      MFloat effNghbrDelta = F0;
      const MFloat cellValue = a_pvariable(cellId, varId);
      // 1. get the abs min value of the max and min value from the reconstruction neighbours
      for(MInt rcnstructnNghbr = 0; rcnstructnNghbr < a_noReconstructionNeighbors(cellId); rcnstructnNghbr++) {
        const MInt rcnstrctnNghbrId = a_reconstructionNeighborId(cellId, rcnstructnNghbr);
        const MFloat rcnstrctnNghbrValue = a_pvariable(rcnstrctnNghbrId, varId);
        const MFloat tmpDelta = rcnstrctnNghbrValue - cellValue;
        if(tmpDelta > maxNghbrDelta) {
          maxNghbrDelta = tmpDelta;
        } else if(tmpDelta < minNghbrDelta) {
          minNghbrDelta = tmpDelta;
        }
      }
      effNghbrDelta = mMin(maxNghbrDelta, abs(minNghbrDelta));
      // 2. get srfcDelta and compute the minimum phi
      const MFloat dx = F1B2 * c_cellLengthAtCell(cellId);
      MFloat srfcDelta = F0;
      for(MInt dim = 0; dim < nDim; dim++)
        srfcDelta += abs(cellSlopes[cellId * slopeMemory + varId * nDim + dim]) * dx;
#ifdef BART_AND_JESPERSON
      const MFloat eps = 1e-12;
      const MFloat phi_max = effNghbrDelta / (srfcDelta + eps);
      const MFloat minPhi = mMin(phi_max, F1);
#endif
#ifdef VENKATAKRISHNAN
      const MFloat eps = 1e-12;
      const MFloat y = effNghbrDelta / (srfcDelta + eps);
      const MFloat minPhi = mMin((y * y + F2 * y) / (y * y + y + F2), F1);
#endif
#ifdef VENKATAKRISHNAN_MOD
      const MFloat K = F2;
      const MFloat epsSqr = pow(K * dx, F3);
      const MFloat minPhi = (pow(effNghbrDelta, F2) + epsSqr + F2 * effNghbrDelta * srfcDelta)
                            / (pow(effNghbrDelta, F2) + F2 * pow(srfcDelta, F2) + effNghbrDelta * srfcDelta + epsSqr);
#endif
      // 3. limit slopes with the minimum phi
      for(MInt dim = 0; dim < nDim; dim++)
        cellSlopes[cellId * slopeMemory + varId * nDim + dim] *= minPhi;
    }
  }

  // compute the surface values:
  if(m_noSpecies == 0) {
    computeSurfaceValues_(0);
  } else if(m_noSpecies == 1) {
    computeSurfaceValues_(1);
  } else {
    computeSurfaceValues_(m_noSpecies);
  }

  // correct the boundary surface values
  IF_CONSTEXPR(nDim == 2) m_fvBndryCnd->correctBoundarySurfaceVariables();
  IF_CONSTEXPR(nDim == 3) {
    if(m_fvBndryCnd->m_multipleGhostCells) { // Multiple-Ghost-Cell
      if(m_fvBndryCnd->m_surfaceGhostCell) {
        m_fvBndryCnd->correctBoundarySurfaceVariablesMGCSurface();
      } else {
        m_fvBndryCnd->correctBoundarySurfaceVariablesMGC();
      }
    } else {
      m_fvBndryCnd->correctBoundarySurfaceVariables();
    }
  }

  // update the ghost cell slopes for viscous flux balance
  m_fvBndryCnd->updateGhostCellSlopesViscous();
  m_fvBndryCnd->updateCutOffSlopesViscous();
}

//----------------------------------------------------------------------------

/**
 * \fn void FvCartesianSolverXD::initComputeSurfaceValuesLimitedSlopesMan1()
 * \brief initializes the limiter at cells, that are in the vicinity of a given
 *        stl-geometry
 *
 * @author Thomas Schilden, December 2017
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initComputeSurfaceValuesLimitedSlopesMan1() {
  TRACE();

  m_log << " first step of initialization of computeSurfaceValuesLimitedSlopesMan" << endl;
  /*! \page propertiesFV
    \section slopeLimiterDistance1
    <code>MInt limDist (local variable)</code>\n
    Threshold of zone of reduced order surface reconstruction for shock capturing.
    The threshold is the distance to the stl file slopeLimiterFilename measured
    in cell length of the cells cut by the surface.
    The associated surface reconstruction method is HOCD_LIMITED_SLOPES_MAN \n
    default = none \n
    Possible values are integers >= 0 \n
    Keywords: <i>FINITE_VOLUME, SHOCK CAPTURING, SUPERSONIC FLOWS</i>
  */
  MInt limDist = Context::getSolverProperty<MInt>("slopeLimiterDistance1", m_solverId, AT_, &limDist);
  /*! \page propertiesFV
    \section slopeLimiterFilename
    <code>MString filename (local variable)</code>\n
    default = none \n
    Fileame of the file containing a surface, e.g. reprenting a discontinuity.
    The surface recontruction in the vicinity of the surface will be reduced in order.
    The associated surface reconstruction method is HOCD_LIMITED_SLOPES_MAN
    Possible value is some string \n
    Keywords: <i>FINITE_VOLUME, SHOCK CAPTURING, SUPERSONIC FLOWS</i>
  */
  MString filename = Context::getSolverProperty<MString>("slopeLimiterFilename", m_solverId, AT_, &filename);

  mAlloc(m_limPhi, a_noCells(), "m_limPhi", F1, AT_);

  vector<MInt> markedCells;
  MIntScratchSpace propDist(/*a_noCells()*/ grid().raw().treeb().size(), AT_, "propDist");
  propDist.fill(numeric_limits<MInt>::max());

  IF_CONSTEXPR(nDim == 2) {
    Geometry2D* auxGeom = new Geometry2D(0, filename, mpiComm());
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      const MFloat cellHalfLength = c_cellLengthAtLevel(a_level(cellId) + 1);
      if(!c_noChildren(cellId) && auxGeom->isOnGeometry(cellHalfLength, &a_coordinate(cellId, 0), "SAT")
         && a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel))
        if(grid().tree().solver2grid(cellId) > -1) markedCells.push_back(grid().tree().solver2grid(cellId));
    }
  }
  IF_CONSTEXPR(nDim == 3) {
    Geometry3D* auxGeom = new Geometry3D(0, filename, mpiComm());
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      const MFloat cellHalfLength = c_cellLengthAtLevel(a_level(cellId) + 1);
      if(!c_noChildren(cellId) && auxGeom->isOnGeometry(cellHalfLength, &a_coordinate(cellId, 0), "SAT")
         && a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel))
        if(grid().tree().solver2grid(cellId) > -1) markedCells.push_back(grid().tree().solver2grid(cellId));
    }
  }

  // TODO labels:FV,toenhance Is a cell that completely contains a closed surface cut by it? If Yes,
  //       we could loop down from the partition cells to the cut leaf cells and skip a lot
  //       calls of cellIsOnGeometry of definetily uncut cells.

  MLong tmp = markedCells.size();
  MPI_Allreduce(MPI_IN_PLACE, &tmp, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "tmp");
  m_log << "  overall cells on shock: " << tmp << endl;
  tmp = 0;

  grid().raw().propagateDistance(markedCells, propDist, limDist);

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    const MInt gridCellId = grid().tree().solver2grid(cellId);
    if(gridCellId < 0) continue;
    if(propDist[gridCellId] != numeric_limits<MInt>::max()) {
      m_limPhi[cellId] = F1B2 - F1B2 * cos(PI * ((MFloat)propDist[gridCellId]) / ((MFloat)limDist));
      tmp++;
    }
  }

  MPI_Allreduce(MPI_IN_PLACE, &tmp, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "tmp");
  m_log << "  overall limited cells: " << tmp << endl;
}

//----------------------------------------------------------------------------

/**
 * \fn void FvCartesianSolverXD::initComputeSurfaceValuesLimitedSlopesMan2()
 * \brief can be used to apply the slope limiter at certain positions such as
 *        refinement interfaces, cut off boundaries(sponge) etc. ...
 *
 * @author Thomas Schilden, December 2017
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initComputeSurfaceValuesLimitedSlopesMan2() {
  TRACE();

  m_log << " second step of initialization of computeSurfaceValuesLimitedSlopesMan" << endl;

  /*! \page propertiesFV
    \section slopeLimiterDistance2
    <code>MFloat limDistF (local variable)</code>\n
    Threshold of zone of reduced order surface reconstruction for shock capturing.
    The threshold is the distance to outflow boundaries 27[12]? measured using floats.
    The associated surface reconstruction method is HOCD_LIMITED_SLOPES_MAN \n
    default = 0 \n
    Possible values are floats >= 0.0 \n
    Keywords: <i>FINITE_VOLUME, SHOCK CAPTURING, SUPERSONIC FLOWS</i>
  */
  MFloat limDistF = F0;
  limDistF = Context::getSolverProperty<MFloat>("slopeLimiterDistance2", m_solverId, AT_, &limDistF);

  vector<MInt> markedCells;
  MIntScratchSpace propDist(/*a_noCells()*/ grid().raw().treeb().size(), AT_, "propDist");
  propDist.fill(numeric_limits<MInt>::max());

  MInt tmp = 0;
  if(limDistF > F0) {
    for(MInt bc = 0; bc < m_fvBndryCnd->m_noCutOffBndryCndIds; bc++) {
      if(m_fvBndryCnd->m_cutOffBndryCndIds[bc] / 10 == 272 || m_fvBndryCnd->m_cutOffBndryCndIds[bc] / 10 == 271) {
        for(MInt lvl = maxUniformRefinementLevel(); lvl <= maxRefinementLevel(); lvl++) {
          for(MInt i = 0; i < m_fvBndryCnd->m_sortedCutOffCells[bc]->size(); i++) {
            if(a_level(m_fvBndryCnd->m_sortedCutOffCells[bc]->a[i]) == lvl)
              if(grid().tree().solver2grid(m_fvBndryCnd->m_sortedCutOffCells[bc]->a[i]) > -1)
                markedCells.push_back(grid().tree().solver2grid(m_fvBndryCnd->m_sortedCutOffCells[bc]->a[i]));
          }
          auto limDist = (MInt)(limDistF / c_cellLengthAtLevel(lvl) + F1B2);
          grid().raw().propagateDistance(markedCells, propDist, limDist);
          markedCells.clear();
        }
      }
    }
    // set limiter value
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      const MInt gridCellId = grid().tree().solver2grid(cellId);
      if(gridCellId < 0) continue;
      if(propDist[gridCellId] != numeric_limits<MInt>::max()) {
        // compute distance from propDist depending on level
        MInt lvl = a_level(cellId);
        MFloat dist = (propDist[gridCellId] + F1B2) * c_cellLengthAtLevel(lvl);
        m_limPhi[cellId] = F1B2 - F1B2 * cos(PI * dist / limDistF);
        tmp++;
      }
    }
  }

  MPI_Allreduce(MPI_IN_PLACE, &tmp, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "tmp");
  m_log << "  added overall limited cells: " << tmp << endl;
}

//----------------------------------------------------------------------------

/**
 * \brief aaplies the slope limiter to the slopes before calling computeSurfaceValues_
 *
 * @author Thomas Schilden, December 2017
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeSurfaceValuesLimitedSlopesMan(MInt NotUsed(timerId)) {
  TRACE();

  const MInt noCells = a_noCells();
  MFloat* const RESTRICT cellSlopes = ALIGNED_MF(&a_slope(0, 0, 0));
  const MInt slopeMemory = m_slopeMemory;

  for(MInt cellId = 0; cellId < noCells; cellId++) {
    //    if(a_hasProperty(cellId, SolverCell::IsCutOff))
    //      continue;
    for(MInt it = 0; it < m_noLimitedSlopesVar; it++) {
      MInt varId = m_limitedSlopesVar[it];

      // limit slopes with the minimum phi
      for(MInt dim = 0; dim < nDim; dim++)
        cellSlopes[cellId * slopeMemory + varId * nDim + dim] *= m_limPhi[cellId];
    }
  }

  // compute the surface values:
  if(m_noSpecies == 0) {
    computeSurfaceValues_(0);
  } else if(m_noSpecies == 1) {
    computeSurfaceValues_(1);
  } else {
    computeSurfaceValues_(m_noSpecies);
  }

  // correct the boundary surface values
  if(m_fvBndryCnd->m_multipleGhostCells) { // Multiple-Ghost-Cell
    if(m_fvBndryCnd->m_surfaceGhostCell) {
      m_fvBndryCnd->correctBoundarySurfaceVariablesMGCSurface();
    } else {
      m_fvBndryCnd->correctBoundarySurfaceVariablesMGC();
    }
  } else {
    m_fvBndryCnd->correctBoundarySurfaceVariables();
  }

  // update the ghost cell slopes for viscous flux balance
  m_fvBndryCnd->updateGhostCellSlopesViscous();
  m_fvBndryCnd->updateCutOffSlopesViscous();
}


/// \brief Dispatches the AUSM flux computation for different number of species
///
/// The objective is to encourage the compiler to generate different optimized version
/// depending on the value of m_noSpecies.
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::Ausm() {
  TRACE();

  if(string2enum(m_advectiveFluxScheme) == AUSM) {
    Ausm_<AUSM>(sysEqn());
  } else if(string2enum(m_advectiveFluxScheme) == AUSMPLUS) {
    Ausm_<AUSMPLUS>(sysEqn());
  } else if(string2enum(m_advectiveFluxScheme) == SLAU) {
    Ausm_<SLAU>(sysEqn());
  }
}

template <MInt nDim_, class SysEqn>
template <MInt stencil, class F>
inline void FvCartesianSolverXD<nDim_, SysEqn>::Ausm_(F& fluxFct) {
  const MUint noPVars = PV->noVariables;
  const MUint noFluxVars = FV->noVariables;
  const MUint noSurfaceCoefficients = hasSC ? SC->m_noSurfaceCoefficients : 0;
  const MUint surfaceVarMemory = 2 * noPVars;
  const MUint noSurfaces = a_noSurfaces();
  const MUint noInternalSurfaces = m_bndrySurfacesOffset;

  MFloat* const RESTRICT fluxes = ALIGNED_MF(&a_surfaceFlux(0, 0));
  const MFloat* const RESTRICT surfaceVars = ALIGNED_F(&a_surfaceVariable(0, 0, 0));
  const MFloat* const RESTRICT surfaceCoefficients = hasSC ? ALIGNED_F(&a_surfaceCoefficient(0, 0)) : nullptr;
  const MFloat* const RESTRICT upwindCoefficients = ALIGNED_F(&a_surfaceUpwindCoefficient(0));
  const MFloat* const RESTRICT area = ALIGNED_F(&a_surfaceArea(0));
  const MInt* const RESTRICT orientations = ALIGNED_I(&a_surfaceOrientation(0));
  const MInt* const RESTRICT bndryCndIds = ALIGNED_I(&a_surfaceBndryCndId(0));

// loop over all surfaces
#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MUint srfcId = 0; srfcId < noSurfaces; ++srfcId) {
    const MUint orientation = orientations[srfcId];

    const MUint offset = srfcId * surfaceVarMemory;
    const MFloat* const RESTRICT leftVars = ALIGNED_F(surfaceVars + offset);
    const MFloat* const RESTRICT rightVars = ALIGNED_F(leftVars + noPVars);

    const MUint coefficientOffset = srfcId * noSurfaceCoefficients;
    const MFloat* const RESTRICT srfcCoeff = hasSC ? ALIGNED_F(surfaceCoefficients + coefficientOffset) : nullptr;

    const MFloat A = area[srfcId];

    const MUint fluxOffset = srfcId * noFluxVars;
    MFloat* const RESTRICT flux = ALIGNED_MF(fluxes + fluxOffset);

    const MFloat upwindCoefficient = upwindCoefficients[srfcId];

    fluxFct.template Ausm<stencil>(orientation, upwindCoefficient, A, leftVars, rightVars, srfcCoeff, flux);
  }

  // find if there is a boundary condition that needs flux correction
  // (assumes no moving boundaries between domains)
  MBool& checkedBndryCndIds = m_static_computeSurfaceValuesLimitedSlopesMan_checkedBndryCndIds;
  MBool& correctWallBndryFluxes = m_static_computeSurfaceValuesLimitedSlopesMan_correctWallBndryFluxes;
  if(!checkedBndryCndIds) {
    for(MUint srfcId = noInternalSurfaces; srfcId < noSurfaces; ++srfcId) {
      if((bndryCndIds[srfcId] > 1999 && bndryCndIds[srfcId] < 4000)) {
        correctWallBndryFluxes = true;
      }
    }
    checkedBndryCndIds = true;
  }

  if(correctWallBndryFluxes) {
    // correct all wall boundary surfaces
    for(MUint srfcId = noInternalSurfaces; srfcId < noSurfaces; ++srfcId) {
      if(!(bndryCndIds[srfcId] > 1999 && bndryCndIds[srfcId] < 4000)) {
        continue;
      }

      const MUint orientation = orientations[srfcId];

      const MUint offset = srfcId * surfaceVarMemory;
      const MFloat* leftVars = surfaceVars + offset;
      const MFloat* rightVars = leftVars + noPVars;

      const MFloat A = area[srfcId];
      const MUint fluxOffset = srfcId * noFluxVars;
      MFloat* const RESTRICT flux = fluxes + fluxOffset;

      fluxFct.AusmBndryCorrection(orientation, A, leftVars, rightVars, flux);
    }
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::viscousFlux() {
  TRACE();
  if(string2enum(m_viscousFluxScheme) == FIVE_POINT) {
    viscousFlux_<FIVE_POINT>(sysEqn());
  } else if(string2enum(m_viscousFluxScheme) == THREE_POINT) {
    viscousFluxCompact_<THREE_POINT>(sysEqn());
  } else if(string2enum(m_viscousFluxScheme) == FIVE_POINT_STABILIZED) {
    viscousFluxCompact_<FIVE_POINT_STABILIZED>(sysEqn());
  }
  IF_CONSTEXPR(isEEGas<SysEqn>) {
    if(m_EEGas.bubblePathDispersion) bubblePathDispersion();
  }
}

/// \brief Computes the viscous flux using a central difference scheme
/// to approximate the slopes at the surface centroids (5-point stencil).
///
/// TODO labels:FV,toenhance we should switch to a 3-point stencil in the future (the 5-point
/// stencil is unstable).
///
/// NOTE: this is an inner-most loop of MAIA (20% of the computation time is spent here)
/// Don't modify it unless you _REALLY_ know what you are doing.
///
/// Turned into template function for usage with function pointers, Lennart
///
/// @author: Daniel Hartmann, November 16, 2006
template <MInt nDim_, class SysEqn>
template <MInt stencil, class F>
void FvCartesianSolverXD<nDim_, SysEqn>::viscousFlux_(F& viscousFluxFct) {
  // TRACE();
  const MUint noPVars = PV->noVariables;
  const MUint noFluxVars = FV->noVariables;
  const MUint noSurfaceCoefficients = hasSC ? SC->m_noSurfaceCoefficients : 0;
  const MUint surfaceVarMemory = 2 * noPVars;
  const MUint noSlopes = nDim * noPVars;
  const MUint noSurfaces = a_noSurfaces();

#ifdef FV_FREE_SURFACE_BC // See TODO labels:FV below
  const MInt* const bndryCndIds RESTRICT = ALIGNED_I(&a_surfaceBndryCndId(0));
#endif
  const MInt* const RESTRICT orientations = ALIGNED_I(&a_surfaceOrientation(0));
  const MInt* const RESTRICT nghbrCellIds = ALIGNED_I(&a_surfaceNghbrCellId(0, 0));
  const MFloat* const RESTRICT surfaceVars = ALIGNED_F(&a_surfaceVariable(0, 0, 0));
  const MFloat* const RESTRICT surfaceCoefficients = hasSC ? ALIGNED_F(&a_surfaceCoefficient(0, 0)) : nullptr;
  const MFloat* const RESTRICT factor = ALIGNED_F(&a_surfaceFactor(0, 0));
  const MFloat* const RESTRICT slope = ALIGNED_F(&a_slope(0, 0, 0));
  const MFloat* const RESTRICT area = ALIGNED_F(&a_surfaceArea(0));
  MFloat* const RESTRICT fluxes = ALIGNED_MF(&a_surfaceFlux(0, 0));

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MUint srfcId = 0; srfcId < noSurfaces; srfcId++) {
    // TODO labels:FV,totest is this really necessary / is this the right place to do this??
#ifdef FV_FREE_SURFACE_BC
    // correct all free surface viscous boundaries flux to zero,  Christoph Siewert
    if((MInt)srfcId > m_bndrySurfacesOffset) {
      if(bndryCndId[srfcId] == 5000) {
        continue;
      }
    }
#endif

    const MUint offset = srfcId * surfaceVarMemory;
    const MFloat* const RESTRICT vars0 = ALIGNED_F(surfaceVars + offset);
    const MFloat* const RESTRICT vars1 = ALIGNED_F(vars0 + noPVars);

    const MUint orientation = orientations[srfcId];
    const MFloat A = area[srfcId];

    const MFloat f0 = factor[srfcId * 2];
    const MFloat f1 = factor[srfcId * 2 + 1];
    const MUint offset0 = nghbrCellIds[2 * srfcId] * noSlopes;
    const MUint offset1 = nghbrCellIds[2 * srfcId + 1] * noSlopes;
    const MFloat* const RESTRICT slope0 = ALIGNED_F(slope + offset0);
    const MFloat* const RESTRICT slope1 = ALIGNED_F(slope + offset1);

    const MUint coefficientOffset = srfcId * noSurfaceCoefficients;
    const MFloat* const RESTRICT srfcCoeff = hasSC ? ALIGNED_F(surfaceCoefficients + coefficientOffset) : nullptr;

    const MUint fluxOffset = srfcId * noFluxVars;
    MFloat* const RESTRICT flux = ALIGNED_MF(fluxes + fluxOffset);

    viscousFluxFct.template viscousFlux<stencil>(orientation, A, vars0, vars1, slope0, slope1, srfcCoeff, f0, f1, flux);
  }


  // correct viscous fluxes on WMLES bndry surfaces
  // \author Thomas Luerkens
  if(m_wmLES) {
    RECORD_TIMER_START(m_timers[Timers::WMSurfaceLoop]);
    const MInt noWMSurfaces = m_wmSurfaces.size();
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for(MInt wmSrfcId = 0; wmSrfcId < noWMSurfaces; wmSrfcId++) {
      const MFloat mue_wm = computeWMViscositySpalding(wmSrfcId);
      const MInt bndryCellId = m_wmSurfaces[wmSrfcId].m_bndryCellId;
      const MInt bndrySrfcId = m_wmSurfaces[wmSrfcId].m_bndrySrfcId;

      for(MInt dim = 0; dim < nDim; dim++) {
        const MInt srfcId = m_bndryCells->a[bndryCellId].m_srfcVariables[bndrySrfcId]->m_srfcId[dim];

        if(srfcId < 0) continue;

        const MUint offset = srfcId * surfaceVarMemory;
        const MFloat* const RESTRICT vars0 = ALIGNED_F(surfaceVars + offset);
        const MFloat* const RESTRICT vars1 = ALIGNED_F(vars0 + noPVars);

        const MUint orientation = orientations[srfcId];
        const MFloat A = area[srfcId];

        const MFloat f0 = factor[srfcId * 2];
        const MFloat f1 = factor[srfcId * 2 + 1];
        const MUint offset0 = nghbrCellIds[2 * srfcId] * noSlopes;
        const MUint offset1 = nghbrCellIds[2 * srfcId + 1] * noSlopes;
        const MFloat* const RESTRICT slope0 = ALIGNED_F(slope + offset0);
        const MFloat* const RESTRICT slope1 = ALIGNED_F(slope + offset1);

        const MUint fluxOffset = srfcId * noPVars;
        MFloat* const RESTRICT flux = ALIGNED_MF(fluxes + fluxOffset);

        RECORD_TIMER_START(m_timers[Timers::WMFluxCorrection]);
        viscousFluxFct.template wmViscousFluxCorrection<stencil>(orientation, A, vars0, vars1, slope0, slope1, f0, f1,
                                                                 flux, mue_wm);
        RECORD_TIMER_STOP(m_timers[Timers::WMFluxCorrection]);
      }
    }
    RECORD_TIMER_STOP(m_timers[Timers::WMSurfaceLoop]);
  }
}

/**
 * \brief Computes the viscous fluxes using a compact stencil with increased stability for flows with dominating viscous
 * effects. Uses a 3-point centered-differences stencil for the normal derivative and distance-weighted averaging of the
 * cell slopes for the tangential derivatives (i.e., a variant of the method described by Berger et al. in AIAA
 * 2012-1301)
 *
 * \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
template <MInt stencil, class F>
void FvCartesianSolverXD<nDim_, SysEqn>::viscousFluxCompact_(F& viscousFluxFct) {
  const MUint noPVars = PV->noVariables;
  const MUint noFluxVars = FV->noVariables;
  const MUint surfaceVarMemory = 2 * noPVars;
  const MUint noSlopes = nDim * noPVars;
  const MUint noSurfaces = a_noSurfaces();

  const MInt* const RESTRICT orientations = ALIGNED_I(&a_surfaceOrientation(0));
  const MInt* const RESTRICT nghbrCellIds = ALIGNED_I(&a_surfaceNghbrCellId(0, 0));
  const MFloat* const RESTRICT surfaceVars = ALIGNED_F(&a_surfaceVariable(0, 0, 0));
  const MFloat* const RESTRICT scoords = ALIGNED_F(&a_surfaceCoordinate(0, 0));
  const MFloat* const RESTRICT factor = ALIGNED_F(&a_surfaceFactor(0, 0));
  const MFloat* const RESTRICT slope = ALIGNED_F(&a_slope(0, 0, 0));
  const MFloat* const RESTRICT ccoords = ALIGNED_F(&a_coordinate(0, 0));
  const MFloat* const RESTRICT area = ALIGNED_F(&a_surfaceArea(0));
  const MFloat* const RESTRICT cellvars = ALIGNED_F(&a_pvariable(0, 0));
  MFloat* const RESTRICT fluxes = ALIGNED_MF(&a_surfaceFlux(0, 0));

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MUint srfcId = 0; srfcId < noSurfaces; srfcId++) {
    const MUint offset = srfcId * surfaceVarMemory;
    const MFloat* const RESTRICT vars0 = ALIGNED_F(surfaceVars + offset);
    const MFloat* const RESTRICT vars1 = ALIGNED_F(vars0 + noPVars);

    const MFloat f0 = factor[srfcId * 2];
    const MFloat f1 = factor[srfcId * 2 + 1];

    const MUint orientation = orientations[srfcId];
    const MFloat A = area[srfcId];

    const MBool isBndry = a_surfaceBndryCndId(srfcId) > -1;

    const MUint offsetSurfaceCoord = nDim * srfcId;
    const MFloat* const RESTRICT surfaceCoord = ALIGNED_F(scoords + offsetSurfaceCoord);

    const MUint off0 = nghbrCellIds[2 * srfcId] * nDim;
    const MUint off1 = nghbrCellIds[2 * srfcId + 1] * nDim;
    const MFloat* const RESTRICT coord0 = ALIGNED_F(ccoords + off0);
    const MFloat* const RESTRICT coord1 = ALIGNED_F(ccoords + off1);

    const MUint voff0 = nghbrCellIds[2 * srfcId] * noPVars;
    const MUint voff1 = nghbrCellIds[2 * srfcId + 1] * noPVars;
    const MFloat* const RESTRICT cellVars0 = ALIGNED_F(cellvars + voff0);
    const MFloat* const RESTRICT cellVars1 = ALIGNED_F(cellvars + voff1);

    const MUint offset0 = nghbrCellIds[2 * srfcId] * noSlopes;
    const MUint offset1 = nghbrCellIds[2 * srfcId + 1] * noSlopes;
    const MFloat* const RESTRICT slope0 = ALIGNED_F(slope + offset0);
    const MFloat* const RESTRICT slope1 = ALIGNED_F(slope + offset1);

    const MUint fluxOffset = srfcId * noFluxVars;
    MFloat* const RESTRICT flux = ALIGNED_MF(fluxes + fluxOffset);

    viscousFluxFct.template viscousFlux<stencil>(orientation, A, isBndry, surfaceCoord, coord0, coord1, cellVars0,
                                                 cellVars1, vars0, vars1, slope0, slope1, f0, f1, flux);
  }
}

template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<isEEGas<SysEqn>, _*>>
void FvCartesianSolverXD<nDim, SysEqn>::bubblePathDispersion() {
  TRACE();
  const MUint noPVars = PV->noVariables;
  const MUint noFluxVars = FV->noVariables;
  const MUint surfaceVarMemory = 2 * noPVars;
  // const MUint noSlopes = nDim * noPVars;
  const MUint noSurfaces = a_noSurfaces();

  const MInt* const RESTRICT orientations = ALIGNED_I(&a_surfaceOrientation(0));
  const MInt* const RESTRICT nghbrCellIds = ALIGNED_I(&a_surfaceNghbrCellId(0, 0));
  const MFloat* const RESTRICT surfaceVars = ALIGNED_F(&a_surfaceVariable(0, 0, 0));
  const MFloat* const RESTRICT factor = ALIGNED_F(&a_surfaceFactor(0, 0));
  // const MFloat* const RESTRICT slope = ALIGNED_F(&a_slope(0, 0, 0));
  const MFloat* const RESTRICT area = ALIGNED_F(&a_surfaceArea(0));
  MFloat* const RESTRICT fluxes = ALIGNED_MF(&a_surfaceFlux(0, 0));

  // bubble path dispersion (see Mohammadi 2019 eq. (23) / Sokolichin 2004)
  const MFloat fScRe0 = F1 / (m_EEGas.schmidtNumber * sysEqn().m_Re0);
#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MUint srfcId = 0; srfcId < noSurfaces; ++srfcId) {
    const MInt leftCellId = nghbrCellIds[2 * srfcId];
    const MInt rightCellId = nghbrCellIds[2 * srfcId + 1];

    const MUint orientation = orientations[srfcId];
    const MUint offset = srfcId * surfaceVarMemory;
    const MFloat* const RESTRICT leftVars = ALIGNED_F(surfaceVars + offset);
    const MFloat* const RESTRICT rightVars = ALIGNED_F(leftVars + noPVars);
    const MFloat A = area[srfcId];
    const MFloat f0 = factor[srfcId * 2];
    const MFloat f1 = factor[srfcId * 2 + 1];

    const MFloat alphaSlopeL = m_cells.slope(leftCellId, PV->A, orientation);
    const MFloat RHOL = leftVars[PV->RHO];
    const MFloat nutL = a_nuEffOtherPhase(leftCellId);

    const MFloat alphaSlopeR = m_cells.slope(rightCellId, PV->A, orientation);
    const MFloat RHOR = rightVars[PV->RHO];
    const MFloat nutR = a_nuEffOtherPhase(rightCellId);

    const MFloat alphaSlopeLR = f0 * alphaSlopeL + f1 * alphaSlopeR;
    const MFloat RHOLR = 0.5 * (RHOL + RHOR);
    const MFloat nutLR = f0 * nutL + f1 * nutR;

    if(fabs(alphaSlopeLR) < 1e-10) continue;

    const MUint fluxOffset = srfcId * noFluxVars;
    MFloat* const RESTRICT flux = ALIGNED_MF(fluxes + fluxOffset);
    flux[FV->A_RHO] -= fScRe0 * alphaSlopeLR * RHOLR * nutLR * A;
  }
}

//---------------------------------------------------------------------------------------
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeVolumeForcesRANS() {
  TRACE();

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt ac = 0; ac < m_noActiveCells; ac++) {
    const MInt cellId = m_activeCellIds[ac];

    if(a_isBndryGhostCell(cellId)) continue;
    if(a_isInactive(cellId)) continue;

    MFloat* vars = &a_pvariable(0, 0);
    MFloat* rhs = &a_rightHandSide(cellId, 0);
    const MFloat cellVol = a_cellVolume(cellId);
    const MFloat* const slopes = &a_slope(0, 0, 0);
    const MInt* const recNghbr = &a_reconstructionNeighborId(cellId, 0);
    const MInt noRecNghbr = a_noReconstructionNeighbors(cellId);
    const MInt recData = a_reconstructionData(cellId);
    const MFloat* const recConst = &m_reconstructionConstants[0];

    MFloat dist = F1;
    if(m_levelSetRans) {
      dist = a_levelSetFunction(cellId, 0);
    } else {
      // You can define an analytical wall distance here
      dist = a_coordinate(cellId, 1);
    }

    sysEqn().computeVolumeForces(cellId, vars, rhs, cellVol, slopes, recData, recNghbr, recConst, noRecNghbr, dist);
  }
}

/// \brief Performs a Runge-Kutta substep depending on m_RKStep
///
/// \returns True if the last Runge-Kutta substep was executed.
///
/// Two Runge-Kutta methods are available: 2nd and 3rd order
/// (See m_rungeKuttaOrder).
///
/// NOTE: This is an inner-most MAIA loop.
/// Don't modify unless you _REALLY_ know what you are doing.
///
/// Reason of the nDim == 2 at MG: The MultiGrid checks (b_properties[SolverCell::IsOnCurrentMGLevel])
/// were only being using in the FvCartesianSolver2D before moving this to XD.
///
/// Reason of ifs m_dualTimeStep: when dual time stepping is disabled we
/// should not even allocate m_localTimeStep_. That fails without the ifs.
/// Besides the most common case is that dualTimeStep is false. We should
/// clean this up eventually.
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<!isEEGas<SysEqn>, _*>>
inline MBool FvCartesianSolverXD<nDim, SysEqn>::rungeKuttaStep_(const MUint /* noSpecies_ */) {
  TRACE();

  const MUint noCVars = CV->noVariables;
  const MUint noFVars = FV->noVariables;

  // Include the timestep in the rkFactor if dual time stepping is disabled:
  const MFloat rkAlpha = m_RKalpha[m_RKStep];
  const MFloat dt = timeStep(true);
  const MFloat rkFactor = m_dualTimeStepping ? rkAlpha : rkAlpha * dt;

  const MUint last = m_noActiveHaloCellOffset > 0 ? m_activeCellIds[m_noActiveHaloCellOffset - 1] + 1
                                                  : std::numeric_limits<MUint>::min();
  MFloat* const RESTRICT oldVars = &a_oldVariable(0, 0);
  MFloat* const RESTRICT vars = &a_variable(0, 0);
  const MFloat* const RESTRICT fCellVol = &a_FcellVolume(0);
  const MFloat* const RESTRICT localTimeStep = m_dualTimeStepping ? &a_localTimeStep(0) : nullptr;
  const MFloat* const RESTRICT rhs = &a_rightHandSide(0, 0);

  if(m_RKStep == 0) {
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for(MUint cellId = m_activeCellIds[0]; cellId < last; ++cellId) {
#if !defined(DISABLE_FV_MG)
      IF_CONSTEXPR(nDim == 2) {
        if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
          continue;
        }
      }
#endif
      const MUint cellOffset = cellId * noCVars;
      MFloat* const RESTRICT oldCellVars = oldVars + cellOffset;
      const MFloat* const RESTRICT cellVars = vars + cellOffset;
      for(MUint varId = 0; varId < noCVars; ++varId) {
        oldCellVars[varId] = cellVars[varId];
      }
    }
  }

  // 2nd order and 3rd order Runge-Kutta Schemes
  switch(m_rungeKuttaOrder) {
    /// 2nd order Runge-Kutta scheme:
    case 2: {
      if(!m_dualTimeStepping) { // -> timestep is constant (see rkAlpha init)
#ifdef _OPENMP
#pragma omp parallel for
#endif
        for(MUint cellId = m_activeCellIds[0]; cellId < last; ++cellId) {
#if !defined(DISABLE_FV_MG)
          IF_CONSTEXPR(nDim == 2) {
            if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
              continue;
            }
          }
#endif
          const MFloat factor = rkFactor * fCellVol[cellId];
          const MUint cellOffset = cellId * noCVars;
          const MFloat* const RESTRICT oldCellVars = oldVars + cellOffset;
          const MFloat* const RESTRICT cellRhs = rhs + cellOffset;
          MFloat* const RESTRICT cellVars = vars + cellOffset;

          for(MUint varId = 0; varId < noCVars; ++varId) {
            cellVars[varId] = oldCellVars[varId] - factor * cellRhs[varId];
          }
        }
      } else {
#ifdef _OPENMP
#pragma omp parallel for
#endif
        for(MUint cellId = m_activeCellIds[0]; cellId < last; ++cellId) {
#if !defined(DISABLE_FV_MG)
          IF_CONSTEXPR(nDim == 2) {
            if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
              continue;
            }
          }
#endif
          const MFloat factor = rkFactor * fCellVol[cellId] * localTimeStep[cellId];
          const MUint cellOffset = cellId * noCVars;
          const MUint cellRhsOffset = cellId * noFVars;
          const MFloat* const RESTRICT oldCellVars = oldVars + cellOffset;
          const MFloat* const RESTRICT cellRhs = rhs + cellRhsOffset;
          MFloat* const RESTRICT cellVars = vars + cellOffset;
          for(MUint varId = 0; varId < noCVars; ++varId) {
            cellVars[varId] = oldCellVars[varId] - factor * cellRhs[varId];
          }
        }
      }
      break;
    }
    /// 3rd-order Runge-Kutta scheme:
    case 3: {
      if(!m_dualTimeStepping) { // -> timestep is constant (see rkAlpha init)
#ifdef _OPENMP
#pragma omp parallel for
#endif
        for(MUint cellId = m_activeCellIds[0]; cellId < last; ++cellId) {
#if !defined(DISABLE_FV_MG)
          IF_CONSTEXPR(nDim == 2) {
            if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
              continue;
            }
          }
#endif
          const MFloat factor = rkFactor * fCellVol[cellId];
          const MUint cellOffset = cellId * noCVars;
          const MUint cellRhsOffset = cellId * noFVars;
          const MFloat* const RESTRICT oldCellVars = oldVars + cellOffset;
          const MFloat* const RESTRICT cellRhs = rhs + cellRhsOffset;
          MFloat* const RESTRICT cellVars = vars + cellOffset;
          for(MUint varId = 0; varId < noCVars; ++varId) {
            cellVars[varId] = rkAlpha * cellVars[varId] + (F1 - rkAlpha) * oldCellVars[varId] - factor * cellRhs[varId];
          }
        }
      } else {
#ifdef _OPENMP
#pragma omp parallel for
#endif
        for(MUint cellId = m_activeCellIds[0]; cellId < last; ++cellId) {
#if !defined(DISABLE_FV_MG)
          IF_CONSTEXPR(nDim == 2) {
            if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
              continue;
            }
          }
#endif
          const MFloat factor = rkAlpha * fCellVol[cellId] * localTimeStep[cellId];
          const MUint cellOffset = cellId * noCVars;
          const MUint cellRhsOffset = cellId * noFVars;
          const MFloat* const RESTRICT oldCellVars = oldVars + cellOffset;
          const MFloat* const RESTRICT cellRhs = rhs + cellRhsOffset;
          MFloat* const RESTRICT cellVars = vars + cellOffset;
          for(MUint varId = 0; varId < noCVars; ++varId) {
            cellVars[varId] = rkAlpha * cellVars[varId] + (F1 - rkAlpha) * oldCellVars[varId] - factor * cellRhs[varId];
          }
        }
      }
      break;
    }
    default: {
      stringstream errorMessage;
      errorMessage << "Runge-Kutta Order (property 'rungeKuttaOrder) " << m_rungeKuttaOrder << " is not implemented.";
      mTerm(1, AT_, errorMessage.str());
    }
  }

  m_RKStep++;
  if(m_RKStep == m_noRKSteps) {
    if(!m_dualTimeStepping) {
      m_physicalTime += dt * m_timeRef; // timestep is dimensionless t/a_0 (right)
    }

    // Time is the "internal" time based on stagnation values
    m_time += dt; ///< time is dimensionless with a0 (right)
    m_RKStep = 0;

    return true;
  }
  return false;
}


/// \brief Dispatches the RungeKutta method for different number of species
///
/// The objective is to encourage the compiler to generate different optimized version
/// depending on the value of m_noSpecies.
template <MInt nDim_, class SysEqn>
MBool FvCartesianSolverXD<nDim_, SysEqn>::rungeKuttaStep() {
  const MUint noSpecies = m_noSpecies;

  IF_CONSTEXPR(isEEGas<SysEqn>) { return rungeKuttaStepEEGas(); }
  else {
    if(noSpecies == 0) {
      return rungeKuttaStep_(0);
    } else if(noSpecies == 1) {
      return rungeKuttaStep_(1);
    } else {
      return rungeKuttaStep_(noSpecies);
    }
  }
}

/// \brief Performs a Runge-Kutta substep for the semi implicit Euler-Euler EEGas model
///
/// \returns True if the last Runge-Kutta substep was executed.
///
/// only implemented for the 2nd order RK scheme without dual timestepping!
///
/// NOTE: This is an inner-most MAIA loop.
/// Don't modify unless you _REALLY_ know what you are doing.
///
/// Reason of ifs m_dualTimeStep: when dual time stepping is disabled we
/// should not even allocate m_localTimeStep_. That fails without the ifs.
/// Besides the most common case is that dualTimeStep is false. We should
/// clean this up eventually.
template <MInt nDim_, class SysEqn>
template <class _, std::enable_if_t<isEEGas<SysEqn>, _*>>
inline MBool FvCartesianSolverXD<nDim_, SysEqn>::rungeKuttaStepEEGas() {
  TRACE();

  const MUint noCVars = CV->noVariables;
  const MUint noFVars = FV->noVariables;

  // Include the timestep in the rkFactor if dual time stepping is disabled:
  const MFloat rkAlpha = m_RKalpha[m_RKStep];
  const MFloat dt = timeStep(true);
  const MFloat rkFactor = rkAlpha * dt;

  const MUint noActiveCells = m_noActiveCells;
  const MUint last = m_activeCellIds[noActiveCells - 1] + 1;
  MFloat* const RESTRICT oldVars = &a_oldVariable(0, 0);
  MFloat* const RESTRICT vars = &a_variable(0, 0);
  const MFloat* const RESTRICT fCellVol = &a_FcellVolume(0);
  const MFloat* const RESTRICT rhs = &a_rightHandSide(0, 0);


  if(m_RKStep == 0) {
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for(MUint cellId = m_activeCellIds[0]; cellId < last; ++cellId) {
      const MUint cellOffset = cellId * noCVars;
      MFloat* const RESTRICT oldCellVars = oldVars + cellOffset;
      const MFloat* const RESTRICT cellVars = vars + cellOffset;
      for(MUint varId = 0; varId < noCVars; ++varId) {
        oldCellVars[varId] = cellVars[varId];
      }
    }
  }

  // 2nd order and 3rd order Runge-Kutta Schemes
  switch(m_rungeKuttaOrder) {
    /// 2nd order Runge-Kutta scheme:
    case 2: {
      if(!m_dualTimeStepping) { // -> timestep is constant (see rkAlpha init)
#ifdef _OPENMP
#pragma omp parallel for
#endif
        for(MUint cellId = m_activeCellIds[0]; cellId < last; ++cellId) {
          const MFloat factor = rkFactor * fCellVol[cellId];
          const MUint cellOffset = cellId * noCVars;
          const MUint cellRhsOffset = cellId * noFVars;
          const MFloat* const RESTRICT oldCellVars = oldVars + cellOffset;
          const MFloat* const RESTRICT cellRhs = rhs + cellRhsOffset;
          MFloat* const RESTRICT cellVars = vars + cellOffset;

          cellVars[CV->RHO] = oldCellVars[CV->RHO] - factor * cellRhs[CV->RHO];
          for(MUint dir = 0; dir < nDim; dir++) {
            const MFloat C_1 = a_implicitCoefficient(cellId, dir * 2);
            const MFloat C_2 = a_implicitCoefficient(cellId, dir * 2 + 1);
            MFloat rhoAlpha = F1;
            if(cellVars[CV->RHO] > -m_EEGas.eps) {
              rhoAlpha = mMax(cellVars[CV->RHO], m_EEGas.eps);
            } else {
              rhoAlpha = cellVars[CV->RHO];
            }
            cellVars[CV->RHO_VV[dir]] = (-cellRhs[CV->RHO_VV[dir]] + C_1 + oldCellVars[CV->RHO_VV[dir]] / factor)
                                        / (F1 / factor - C_2 / rhoAlpha);
          }
        }
      } else {
        mTerm(1, AT_, "Dual timestepping not implemented for semi implicit EEGas!");
      }
      break;
    }
    default: {
      stringstream errorMessage;
      errorMessage << "Runge-Kutta Order (property 'rungeKuttaOrder) " << m_rungeKuttaOrder << " is not implemented.";
      mTerm(1, AT_, errorMessage.str());
    }
  }

  m_RKStep++;
  if(m_RKStep == m_noRKSteps) {
    if(!m_dualTimeStepping) {
      m_physicalTime += dt * m_timeRef; // timestep is dimensionless t/a_0 (right)
    }

    // Time is the "internal" time based on stagnation values
    m_time += dt; ///< time is dimensionless with a0 (right)
    m_RKStep = 0;

    return true;
  }
  return false;
}

/// \brief Distributes the surface fluxes to the cell RHS
///
/// NOTE: this is an inner-most loop of MAIA
/// Don't modify it unless you _REALLY_ know what you are doing.
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::distributeFluxToCells() {
  const MUint noFVars = FV->noVariables;
  const MInt* const RESTRICT nghbrCellIds = ALIGNED_I(&a_surfaceNghbrCellId(0, 0));
  const MFloat* const RESTRICT fluxes = ALIGNED_F(&a_surfaceFlux(0, 0));
  MFloat* const RESTRICT rhs = ALIGNED_MF(&a_rightHandSide(0, 0));

  //  Loop is not OpenMP parallelizable!
  for(MUint srfcId = 0; srfcId < static_cast<MUint>(a_noSurfaces()); ++srfcId) {
    const MUint offset0 = nghbrCellIds[srfcId * 2] * noFVars;
    const MUint offset1 = nghbrCellIds[srfcId * 2 + 1] * noFVars;
    const MUint fluxOffset = srfcId * noFVars;
    const MFloat* const RESTRICT flux = ALIGNED_F(fluxes + fluxOffset);
    for(MUint var = 0; var < noFVars; ++var) {
      rhs[offset0 + var] += flux[var];
      rhs[offset1 + var] -= flux[var];
    }
  }
  // for E-E multiphase, the pressure term was collected seperately and has to be applied now
  IF_CONSTEXPR(isEEGas<SysEqn>) {
    const MUint noCells = a_noCells();
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for(MUint cellId = 0; cellId < noCells; ++cellId) {
      const MFloat alpha = a_alphaGas(cellId);
      for(MUint i = 0; i < nDim; i++) {
        rhs[cellId * noFVars + CV->A_RHO_VV[i]] += rhs[cellId * noFVars + FV->P_RHO_VV[i]] * alpha;
      }
    }
  }
}

/// \brief Dispatches the computation of the primitive variables for
/// different number of species
///
/// The objective is to encourage the compiler to generate different optimized version
/// depending on the value of m_noSpecies.
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computePrimitiveVariables() {
  TRACE();

  IF_CONSTEXPR(isDetChem<SysEqn>) { computeMeanMolarWeights_CV(); }

  computePrimitiveVariables_();

  computePrimitiveVariablesCoarseGrid(noInternalCells()); // return command for non-combustion computations
}

/// \brief Computes the primitive variables: velocity, density, and pressure from the
/// conservative variables and stores the
/// primitive variables in a_pvariable( i ,  v )
///
/// NOTE: this is an inner-most loop of MAIA
/// Don't modify it unless you _REALLY_ know what you are doing.
template <MInt nDim, class SysEqn>
inline void FvCartesianSolverXD<nDim, SysEqn>::computePrimitiveVariables_() {
  const MUint noCells = a_noCells();
  const MUint noPVars = PV->noVariables;
  const MUint noCVars = CV->noVariables;
  const MUint noAVars = hasAV ? AV->noVariables : 0;

  MFloat* const RESTRICT cvars = &a_variable(0, 0);
  MFloat* const RESTRICT pvars = &a_pvariable(0, 0);
  MFloat* const RESTRICT avars = hasAV ? &a_avariable(0, 0) : nullptr;
  const MFloat* const RESTRICT uOtherPhase = isEEGas<SysEqn> ? &a_uOtherPhase(0, 0) : nullptr;

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MUint cellId = 0; cellId < noCells; ++cellId) {
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    const MUint cellPVarOffset = cellId * noPVars;
    const MUint cellCVarOffset = cellId * noCVars;
    const MUint cellAVarOffset = hasAV ? cellId * noAVars : 0;
    const MFloat* const RESTRICT cvarsCell = cvars + cellCVarOffset;
    MFloat* const RESTRICT pvarsCell = pvars + cellPVarOffset;
    const MFloat* const RESTRICT avarsCell = hasAV ? avars + cellAVarOffset : nullptr;
    sysEqn().computePrimitiveVariables(cvarsCell, pvarsCell, avarsCell);
  }
  IF_CONSTEXPR(isEEGas<SysEqn>)
  if(m_EEGas.uDLimiter) {
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for(MInt cellId = 0; cellId < m_bndryGhostCellsOffset; ++cellId) {
      const MInt cellPVarOffset = cellId * noPVars;
      const MInt cellCVarOffset = cellId * noCVars;
      const MUint cellAVarOffset = hasAV ? cellId * noAVars : 0;
      const MInt uOthOffset = cellId * nDim;
      MFloat* const RESTRICT pvarsCell = pvars + cellPVarOffset;
      MFloat* const RESTRICT cvarsCell = cvars + cellCVarOffset;
      const MFloat* const RESTRICT avarsCell = hasAV ? avars + cellAVarOffset : nullptr;
      const MFloat* const RESTRICT uOtherPhaseCell = uOtherPhase + uOthOffset;
      const MBool change = uDLimiter(uOtherPhaseCell, pvarsCell);
      if(change) sysEqn().computeConservativeVariables(pvarsCell, cvarsCell, avarsCell);
    }
  }
}

//-------------------------------------------------------------------------------------------
/**
 * \brief computes primitive from primitive variables for given cell id. This is the version for all SysEqn.
 * \author Lennart Schneiders, Borja Pedro
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setPrimitiveVariables(MInt cellId) {
  const MFloat* const cvarsCell = &a_variable(cellId, 0);
  MFloat* const pvarsCell = &a_pvariable(cellId, 0);
  const MFloat* const avarsCell = hasAV ? &a_avariable(cellId, 0) : nullptr;

  IF_CONSTEXPR(isDetChem<SysEqn>) setMeanMolarWeight_CV(cellId);

  sysEqn().computePrimitiveVariables(cvarsCell, pvarsCell, avarsCell);

  IF_CONSTEXPR(isEEGas<SysEqn>) {
    MBool change = false;
    if(m_EEGas.uDLimiter) {
      change = uDLimiter(&a_uOtherPhase(cellId, 0), &a_pvariable(cellId, 0));
    }
    if(change) setConservativeVariables(cellId);
  }
}

/// \brief Computes the primitive variables: velocity, density, and pressure from the
/// conservative variables and stores the
/// primitive variables in a_pvariable( i ,  v )
///
/// NOTE: this is an inner-most loop of MAIA
/// Don't modify it unless you _REALLY_ know what you are doing.
template <MInt nDim_, class SysEqn>
inline void FvCartesianSolverXD<nDim_, SysEqn>::computeConservativeVariables_() {
  const MUint noCells = a_noCells();
  const MUint noPVars = PV->noVariables;
  const MUint noCVars = CV->noVariables;
  const MUint noAVars = hasAV ? AV->noVariables : 0;

  const MFloat* const RESTRICT pvars = &a_pvariable(0, 0);
  MFloat* const RESTRICT cvars = &a_variable(0, 0);
  MFloat* const RESTRICT avars = hasAV ? &a_avariable(0, 0) : nullptr;

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MUint cellId = 0; cellId < noCells; ++cellId) {
    const MUint cellPVarOffset = cellId * noPVars;
    const MUint cellCVarOffset = cellId * noCVars;
    const MUint cellAVarOffset = hasAV ? (cellId * noAVars) : 0;
    const MFloat* const RESTRICT pvarsCell = pvars + cellPVarOffset;
    MFloat* const RESTRICT cvarsCell = cvars + cellCVarOffset;
    const MFloat* const RESTRICT avarsCell = hasAV ? avars + cellAVarOffset : nullptr;

    sysEqn().computeConservativeVariables(pvarsCell, cvarsCell, avarsCell);
  }
}

/// \brief Computes the primitive variables: velocity, density, and pressure from the
/// conservative variables and stores the
/// primitive variables in a_pvariable( i ,  v )
///
/// NOTE: this is an inner-most loop of MAIA
/// Don't modify it unless you _REALLY_ know what you are doing.
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computePrimitiveVariablesCoarseGrid(MInt noCells) {
  TRACE();

  if(!m_combustion) { // since the function is called in the methods there is a return at this position for the other
                      // maia users
    return;
  }

  for(MInt level_ = maxLevel() - 1; level_ >= minLevel(); --level_) {
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for(MInt cellId = 0; cellId < noCells; cellId++) {
      if(a_isBndryGhostCell(cellId)) continue;

      if(level_ != a_level(cellId)) {
        continue;
      }

      if(c_isLeafCell(cellId)) {
        continue;
      }

      MInt noChildren = 0;
      for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
        if(c_childId(cellId, childId) > -1) {
          noChildren++;
        }
      }
      if(noChildren == 0) {
        continue;
      }

      const MFloat FnoChildren = F1 / (MFloat)noChildren;

      for(MInt i = 0; i < PV->noVariables; i++) {
        a_pvariable(cellId, i) = F0;
      }

      for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
        if(c_childId(cellId, childId) < 0) {
          continue;
        }

        for(MInt i = 0; i < PV->noVariables; i++) {
          a_pvariable(cellId, i) += FnoChildren * a_pvariable(c_childId(cellId, childId), i);
          // a_FcellVolume( c_childId( cellId ,  childId ) ) *a_pvariable( c_childId( cellId ,  childId ) ,  i );
        }
      }
    }
  }
  ASSERT(m_combustion, "someone changed the code -> this code is only needed for combustion computations");
}


/// \brief Computes the primitive variables: velocity, density, and pressure from the
/// conservative variables and stores the
/// primitive variables in a_pvariable( i ,  v )
///
/// NOTE: this is an inner-most loop of MAIA
/// Don't modify it unless you _REALLY_ know what you are doing.
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computePrimitiveVariablesCoarseGrid() {
  TRACE();
  if(!m_combustion) // just to be sure
    return;

  MInt noCells = a_noCells();

  computePrimitiveVariablesCoarseGrid(noCells);
  ASSERT(m_combustion, "someone changed the code -> this code is only needed for combustion computations");
}

/// \brief Computes the primitive variables: velocity, density, and pressure from the
/// conservative variables and stores the
/// primitive variables in a_pvariable( i ,  v )
///
/// NOTE: this is an inner-most loop of MAIA
/// Don't modify it unless you _REALLY_ know what you are doing.
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeConservativeVariablesCoarseGrid() {
  TRACE();
  if(!m_combustion) // since the function is called in the methods there is a return at this position for the other maia
                    // users
    return;

  const MUint noCells = a_noCells();


  for(MInt level_ = maxLevel() - 1; level_ >= minLevel(); --level_) {
    for(MUint cellId = 0; cellId < noCells; cellId++) {
      if(a_isBndryGhostCell(cellId)) continue;
      if(level_ != a_level(cellId)) continue;

      if(c_isLeafCell(cellId)) continue;

      MInt noChildren = 0;
      for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
        if(c_childId(cellId, childId) > -1) {
          noChildren++;
        }
      }

      if(noChildren == 0) continue;

      MFloat FnoChildren = 1.0 / noChildren;

      for(MInt i = 0; i < CV->noVariables; i++) {
        a_variable(cellId, i) = F0;
      }

      for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
        if(c_childId(cellId, childId) < 0) continue;

        for(MInt i = 0; i < CV->noVariables; i++) {
          a_variable(cellId, i) +=
              FnoChildren
              * a_variable(c_childId(cellId, childId), i); // a_FcellVolume( c_childId( cellId ,  childId ) ) *
                                                           // a_variable(c_childId( cellId ,  childId ),  i );
        }
      }
    }
  }
  ASSERT(m_combustion, "someone changed the code -> this code is only needed for combustion computations");
}

/// \brief Dispatches the computation of the conservative variables for
/// different number of species
///
/// The objective is to encourage the compiler to generate different optimized version
/// depending on the value of m_noSpecies.
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeConservativeVariables() {
  TRACE();

  IF_CONSTEXPR(isDetChem<SysEqn>) { computeMeanMolarWeights_PV(); }

  computeConservativeVariables_();
  computeConservativeVariablesCoarseGrid(); // return command for non-combustion computations
}

/*! \brief calculates interpolated variables for a given position in a given cell
 *
 * \author Ansgar Niemoeller, Sven Berger
 * \date 07.06.2014
 *
 * \param[in]  cellId of the cell used for interpolation
 * \param[in]  position interpolation point
 * \param[out] vars array containing the interpolated variables
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getInterpolatedVariablesInCell(const MInt cellId, const MFloat* position,
                                                                        MFloat* vars) {
  TRACE();
  // Function pointer to a_pvariable
  std::function<MFloat(const MInt, const MInt)> varPtr = [&](const MInt cellId_, const MInt varId_) {
    return static_cast<MFloat>(a_pvariable(cellId_, varId_));
  };
  interpolateVariablesInCell<0, nDim + 2>(cellId, position, varPtr, vars);
  ASSERT(noVariables() == nDim + 2, "ERROR: Number of variables not correct.");
}


/*! \brief calculates interpolated variables for a given position in a given cell
 *
 * \author Ansgar Niemoeller, Sven Berger
 * \date 07.06.2014
 *
 * \param[in]  cellId of the cell used for interpolation
 * \param[in]  position interpolation point
 * \param[out] vars array containing the interpolated variables
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getInterpolatedVariables(const MInt cellId, const MFloat* position,
                                                                  MFloat* vars) {
  // TRACE();

  interpolateVariables<0, nDim + 2>(cellId, position, vars);

  ASSERT(noVariables() == nDim + 2, "ERROR: Number of variables not correct.");
}


/*! \brief calculates interpolated variables for a given position in a given cell while allowing for multiple species
 *
 * \author Ansgar Niemoeller, Sven Berger
 * \date 07.06.2014
 *
 * \param[in] cellId id of the cell used for interpolation
 * \param[in] position interpolation point
 * \param[out] vars array containing the interpolated variables
 *
 */
template <MInt nDim_, class SysEqn>
template <MInt noSpecies>
void FvCartesianSolverXD<nDim_, SysEqn>::getInterpolatedVariables(const MInt cellId, const MFloat* position,
                                                                  MFloat* vars) {
  // TRACE();

  interpolateVariables<0, nDim + 2 + noSpecies>(cellId, position, vars);

  ASSERT(noVariables() == nDim + 2 + noSpecies, "ERROR: Number of variables not correct.");
}


/*! \brief calculates interpolated variables (in the range a, b) for a given position in a given cell
 *
 * \author Sven Berger
 * \date January 2016
 *
 * \param[in] cellId id of the cell used for interpolation
 * \param[in] position interpolation point
 * \param[out] interpolatedVar array containing the interpolated variables
 *
 */
template <MInt nDim_, class SysEqn>
template <MInt a, MInt b, MBool old>
void FvCartesianSolverXD<nDim_, SysEqn>::interpolateVariables(const MInt cellId, const MFloat* position,
                                                              MFloat* interpolatedVar) {
  // TRACE();
  ASSERT((b - a) > 0, "ERROR: Difference between b and a needs to be positive!");
  ASSERT(cellId >= 0, "ERROR: Invalid cellId!");

  const MFloat originX = a_coordinate(cellId, 0);
  const MFloat originY = a_coordinate(cellId, 1);
  const MFloat originZ = a_coordinate(cellId, 2);

  ///
  /// 1. Find all direct neighboring cells
  ///
  vector<MInt> nghbrList;
#ifdef _OPENMP
#pragma omp critical
#endif
  {
    if(m_cellToNghbrHood.count(cellId) > 0) {
      nghbrList = m_cellToNghbrHood[cellId];
      // std::cout << "Old use existing hood with " << nghbrList.size() << " for " << cellId << std::endl;
    } else {
      findDirectNghbrs(cellId, nghbrList);
      // std::cout << "Old find hood with " << nghbrList.size() << std::endl;
      if(nghbrList.size() < 12) {
        findNeighborHood(cellId, 2, nghbrList);
        // std::cout << "Old find better hood with " << nghbrList.size() << std::endl;
#ifndef NDEBUG
        if(nghbrList.size() < 14) {
          cout << "WARNING: Only found " << nghbrList.size() << " neighbors during interpolation!" << endl;
        }
#endif
      }
      m_cellToNghbrHood.emplace(make_pair(cellId, nghbrList));
    }
  }

  // std::cout << "Old Interpolation with " << nghbrList.size() << " points" << std::endl;

  // check for boundary ghost cells belonging to cells in the neighbor list
  // for these cell a pseudoCell element is added, carrying position and velocity
  // on the boundary surface
  vector<array<MFloat, b - a>> pseudoCellVar(nghbrList.size());
  vector<array<MFloat, nDim>> pseudoCellPos(nghbrList.size());

  for(MUint nId = 0; nId < nghbrList.size(); nId++) {
    const MInt nghbrId = nghbrList[nId];
    if(nghbrId >= 0 && a_bndryId(nghbrId) > -1) {
      // mark as pseudo cell
      nghbrList[nId] = -1;
      for(MInt i = 0; i < nDim; i++) {
        pseudoCellPos[nId][i] = m_bndryCells->a[a_bndryId(nghbrId)].m_srfcs[0]->m_coordinates[i];
      }

      //      const MInt bndryCndId = m_fvBndryCnd->m_bndryCndIds[a_bndryId(nghbrId)];

      for(MInt i = a; i < b; i++) {
        // todo labels:FV bndCnd need to be implemented here (assumes bnd result equals cell result)
        if(old) {
          pseudoCellVar[nId][i - a] = a_oldVariable(cellId, i);
        } else {
          pseudoCellVar[nId][i - a] = a_variable(cellId, i);
        }
      }

      //      if(bndryCndId == 3003){ //no-slip wall
      //        for(MInt i = a; i < 3; i++){
      //          pseudoCellVar[nId][i - a] = 0;
      //        }
      //      }
    }
  }
  // std::cout << "Old interpolation with " << nghbrList.size() << " points at cell gid " << c_globalId(cellId) <<
  // std::endl;
  for(MUint nId = 0; nId < nghbrList.size(); nId++) {
    const MInt nghbrId = nghbrList[nId];
    // const MFloat a0 = 343.203775724;
    if(a_bndryId(nghbrId) > -1) {
      // std::cout << "Old outside " << pseudoCellVar[nId][0]*a0 << " " << pseudoCellVar[nId][1]*a0 << " " <<
      // pseudoCellVar[nId][2]*a0 << std::endl;
    } else {
      // std::cout << "Old inside " << a_variable(nghbrId,0)*a0 << " " << a_variable(nghbrId,1)*a0 << " " <<
      // a_variable(nghbrId,2)*a0 << std::endl;
    }
  }

  /// 2a. if only a low number of neighbors is found use distance weighted averaging
  ///
  if(nghbrList.size() < 10) {
    vector<MFloat> dist(nghbrList.size(), 0);
    for(MUint nId = 0; nId < nghbrList.size(); nId++) {
      const MInt nghbrId = nghbrList[nId];
      // calculate distance for each neighbor to the origin
      if(nghbrId < 0) {
        IF_CONSTEXPR(nDim == 2) {
          dist[nId] = POW2(pseudoCellPos[nId][0] - position[0]) + POW2(pseudoCellPos[nId][1] - position[1]);
        }
        else {
          dist[nId] = POW2(pseudoCellPos[nId][0] - position[0]) + POW2(pseudoCellPos[nId][1] - position[1])
                      + POW2(pseudoCellPos[nId][2] - position[2]);
        }
      } else {
        IF_CONSTEXPR(nDim == 2) {
          dist[nId] = POW2(a_coordinate(nghbrId, 0) - position[0]) + POW2(a_coordinate(nghbrId, 1) - position[1]);
        }
        else {
          dist[nId] = POW2(a_coordinate(nghbrId, 0) - position[0]) + POW2(a_coordinate(nghbrId, 1) - position[1])
                      + POW2(a_coordinate(nghbrId, 2) - position[2]);
        }
      }
    }

    MFloat sum = accumulate(dist.begin(), dist.end(), 0.0);

    for(MInt k = a; k < b; k++) {
      MFloat var = 0;
      interpolatedVar[k] = 0.0;

      for(MUint nId = 1; nId < nghbrList.size(); nId++) {
        const MInt nghbrId = nghbrList[nId];
        if(nghbrId < 0) {
          var = pseudoCellVar[nId][k - a];
        } else {
          if(old) {
            var = a_oldVariable(nghbrId, k);
          } else {
            var = a_variable(nghbrId, k);
          }
        }
        interpolatedVar[k] += dist[nId] / sum * var;
      }
    }

#ifndef NDEBUG
    //    cout << "WARNING: Not enough neighbors found to use LS using weighted averaging instead!" << endl;
    m_log << "WARNING: Not enough neighbors found to use LS using weighted averaging instead!" << endl;
#endif
  } else {
    ///
    /// 2b. build the least square matrix LSMatrix...
    ///
    MFloatTensor LSMatrix(2 * nDim + pow(2, nDim - 1), 2 * nDim + pow(2, nDim - 1));
    MFloatTensor rhs(2 * nDim + pow(2, nDim - 1));
    //    MFloatTensor weights(2 * nDim + pow(2, nDim - 1));
    MFloatTensor matInv(2 * nDim + pow(2, nDim - 1), 2 * nDim + pow(2, nDim - 1));

    LSMatrix.set(0.0);
    //    weights.set(1.0);
    matInv.set(0.0);

    MFloat sumX = 0;
    MFloat sumY = 0;
    MFloat sumZ = 0;
    MFloat sumXY = 0;
    MFloat sumXZ = 0;
    MFloat sumYZ = 0;
    MFloat sumX2 = 0;
    MFloat sumY2 = 0;
    MFloat sumZ2 = 0;
    MFloat sumXYZ = 0;
    MFloat sumX2Y = 0;
    MFloat sumX2Z = 0;
    MFloat sumXY2 = 0;
    MFloat sumY2Z = 0;
    MFloat sumXZ2 = 0;
    MFloat sumYZ2 = 0;
    MFloat sumX3 = 0;
    MFloat sumY3 = 0;
    MFloat sumZ3 = 0;
    MFloat sumX3Y = 0;
    MFloat sumX3Z = 0;
    MFloat sumXY3 = 0;
    MFloat sumY3Z = 0;
    MFloat sumXZ3 = 0;
    MFloat sumYZ3 = 0;
    MFloat sumX2Y2 = 0;
    MFloat sumX2Z2 = 0;
    MFloat sumX2YZ = 0;
    MFloat sumY2Z2 = 0;
    MFloat sumXY2Z = 0;
    MFloat sumXYZ2 = 0;
    MFloat sumX4 = 0;
    MFloat sumY4 = 0;
    MFloat sumZ4 = 0;


    // 2.1 Calculate intermediate variables
    for(MUint nId = 1; nId < nghbrList.size(); nId++) {
      MFloat x = 0;
      MFloat y = 0;
      MFloat z = 0;
      const MInt nghbrId = nghbrList[nId];
      if(nghbrId < 0) {
        x = pseudoCellPos[nId][0] - originX;
        y = pseudoCellPos[nId][1] - originY;
        IF_CONSTEXPR(nDim == 3) { z = pseudoCellPos[nId][2] - originZ; }
      } else {
        x = a_coordinate(nghbrId, 0) - originX;
        y = a_coordinate(nghbrId, 1) - originY;
        IF_CONSTEXPR(nDim == 3) { z = a_coordinate(nghbrId, 2) - originZ; }
      }

      sumX += x;
      sumY += y;
      sumZ += z;
      sumXY += x * y;
      sumXZ += x * z;
      sumYZ += y * z;
      sumX2 += x * x;
      sumY2 += y * y;
      sumZ2 += z * z;
      sumXYZ += x * y * z;
      sumX2Y += x * x * y;
      sumX2Z += x * x * z;
      sumXY2 += x * y * y;
      sumY2Z += y * y * z;
      sumXZ2 += z * z * x;
      sumYZ2 += z * z * y;
      sumX3 += x * x * x;
      sumY3 += y * y * y;
      sumZ3 += z * z * z;
      sumX3Y += x * x * x * y;
      sumX3Z += x * x * x * z;
      sumXY3 += y * y * y * x;
      sumY3Z += y * y * y * z;
      sumXZ3 += z * z * z * x;
      sumYZ3 += z * z * z * y;
      sumX2Y2 += x * x * y * y;
      sumX2Z2 += x * x * z * z;
      sumX2YZ += x * x * y * z;
      sumY2Z2 += y * y * z * z;
      sumXY2Z += x * y * y * z;
      sumXYZ2 += x * y * z * z;
      sumX4 += x * x * x * x;
      sumY4 += y * y * y * y;
      sumZ4 += z * z * z * z;
    }

    // 2.2 Use intermediate variables to build LSMatrix
    IF_CONSTEXPR(nDim == 2) {
      // diagonal
      LSMatrix(0, 0) = sumX4;
      LSMatrix(1, 1) = sumY4;
      LSMatrix(2, 2) = sumX2Y2;
      LSMatrix(3, 3) = sumX2;
      LSMatrix(4, 4) = sumY2;
      LSMatrix(5, 5) = nghbrList.size();

      // first column/row
      LSMatrix(0, 1) = LSMatrix(1, 0) = sumX2Y2;
      LSMatrix(0, 2) = LSMatrix(2, 0) = sumX3Y;
      LSMatrix(0, 3) = LSMatrix(3, 0) = sumX3;
      LSMatrix(0, 4) = LSMatrix(4, 0) = sumX2Y;
      LSMatrix(0, 5) = LSMatrix(5, 0) = sumX2;

      // second column/row
      LSMatrix(1, 2) = LSMatrix(2, 1) = sumXY3;
      LSMatrix(1, 3) = LSMatrix(3, 1) = sumXY2;
      LSMatrix(1, 4) = LSMatrix(4, 1) = sumY3;
      LSMatrix(1, 5) = LSMatrix(5, 1) = sumY2;

      // third column/row
      LSMatrix(2, 3) = LSMatrix(3, 2) = sumX2Y;
      LSMatrix(2, 4) = LSMatrix(4, 2) = sumXY2;
      LSMatrix(2, 5) = LSMatrix(5, 2) = sumXY;

      // fourth column/row
      LSMatrix(3, 4) = LSMatrix(4, 3) = sumXY;
      LSMatrix(3, 5) = LSMatrix(5, 3) = sumX;

      // fifth coulmn/row
      LSMatrix(4, 5) = LSMatrix(5, 4) = sumY;
    }
    else {
      // diagonal
      LSMatrix(0, 0) = sumX4;
      LSMatrix(1, 1) = sumY4;
      LSMatrix(2, 2) = sumZ4;
      LSMatrix(3, 3) = sumX2Y2;
      LSMatrix(4, 4) = sumX2Z2;
      LSMatrix(5, 5) = sumY2Z2;
      LSMatrix(6, 6) = sumX2;
      LSMatrix(7, 7) = sumY2;
      LSMatrix(8, 8) = sumZ2;
      LSMatrix(9, 9) = nghbrList.size();

      // first column/row
      LSMatrix(0, 1) = LSMatrix(1, 0) = sumX2Y2;
      LSMatrix(0, 2) = LSMatrix(2, 0) = sumX2Z2;
      LSMatrix(0, 3) = LSMatrix(3, 0) = sumX3Y;
      LSMatrix(0, 4) = LSMatrix(4, 0) = sumX3Z;
      LSMatrix(0, 5) = LSMatrix(5, 0) = sumX2YZ;
      LSMatrix(0, 6) = LSMatrix(6, 0) = sumX3;
      LSMatrix(0, 7) = LSMatrix(7, 0) = sumX2Y;
      LSMatrix(0, 8) = LSMatrix(8, 0) = sumX2Z;
      LSMatrix(0, 9) = LSMatrix(9, 0) = sumX2;

      // second column/row
      LSMatrix(1, 2) = LSMatrix(2, 1) = sumY2Z2;
      LSMatrix(1, 3) = LSMatrix(3, 1) = sumXY3;
      LSMatrix(1, 4) = LSMatrix(4, 1) = sumXY2Z;
      LSMatrix(1, 5) = LSMatrix(5, 1) = sumY3Z;
      LSMatrix(1, 6) = LSMatrix(6, 1) = sumXY2;
      LSMatrix(1, 7) = LSMatrix(7, 1) = sumY3;
      LSMatrix(1, 8) = LSMatrix(8, 1) = sumY2Z;
      LSMatrix(1, 9) = LSMatrix(9, 1) = sumY2;

      // third column/row
      LSMatrix(2, 3) = LSMatrix(3, 2) = sumXYZ2;
      LSMatrix(2, 4) = LSMatrix(4, 2) = sumXZ3;
      LSMatrix(2, 5) = LSMatrix(5, 2) = sumYZ3;
      LSMatrix(2, 6) = LSMatrix(6, 2) = sumXZ2;
      LSMatrix(2, 7) = LSMatrix(7, 2) = sumYZ2;
      LSMatrix(2, 8) = LSMatrix(8, 2) = sumZ3;
      LSMatrix(2, 9) = LSMatrix(9, 2) = sumZ2;

      // fourth column, fourth line
      LSMatrix(3, 4) = LSMatrix(4, 3) = sumX2YZ;
      LSMatrix(3, 5) = LSMatrix(5, 3) = sumXY2Z;
      LSMatrix(3, 6) = LSMatrix(6, 3) = sumX2Y;
      LSMatrix(3, 7) = LSMatrix(7, 3) = sumXY2;
      LSMatrix(3, 8) = LSMatrix(8, 3) = sumXYZ;
      LSMatrix(3, 9) = LSMatrix(9, 3) = sumXY;

      // fifth coulmn, fifth line
      LSMatrix(4, 5) = LSMatrix(5, 4) = sumXYZ2;
      LSMatrix(4, 6) = LSMatrix(6, 4) = sumX2Z;
      LSMatrix(4, 7) = LSMatrix(7, 4) = sumXYZ;
      LSMatrix(4, 8) = LSMatrix(8, 4) = sumXZ2;
      LSMatrix(4, 9) = LSMatrix(9, 4) = sumXZ;

      // sixth column, sixth line
      LSMatrix(5, 6) = LSMatrix(6, 5) = sumXYZ;
      LSMatrix(5, 7) = LSMatrix(7, 5) = sumY2Z;
      LSMatrix(5, 8) = LSMatrix(8, 5) = sumYZ2;
      LSMatrix(5, 9) = LSMatrix(9, 5) = sumYZ;

      // seventh column, seventh line
      LSMatrix(6, 7) = LSMatrix(7, 6) = sumXY;
      LSMatrix(6, 8) = LSMatrix(8, 6) = sumXZ;
      LSMatrix(6, 9) = LSMatrix(9, 6) = sumX;

      // eigth column, eigth line
      LSMatrix(7, 8) = LSMatrix(8, 7) = sumYZ;
      LSMatrix(7, 9) = LSMatrix(9, 7) = sumY;

      // nineth column, nineth line
      LSMatrix(8, 9) = LSMatrix(9, 8) = sumZ;
    }

    // 2.3 scale solution since the condition number gets really bad for large discrepancies in cell size
    const MFloat normalizationFactor = FPOW2(2 * a_level(cellId)) / c_cellLengthAtLevel(0);
    for(MInt i = 0; i < 2 * nDim + pow(2, nDim - 1); i++) {
      for(MInt j = 0; j < 2 * nDim + pow(2, nDim - 1); j++) {
        LSMatrix(i, j) *= normalizationFactor;
      }
    }

    // 2.4 determine the pseudoinverse using SVD
    maia::math::invert(LSMatrix, matInv, 2 * nDim + pow(2, nDim - 1), 2 * nDim + pow(2, nDim - 1));

    ///
    /// 3. Build rhs and solve the LS problem
    ///
    for(MInt k = a; k < b; k++) {
      MFloat sumVar = 0;
      if(old) {
        sumVar = a_oldVariable(cellId, k);
      } else {
        sumVar = a_variable(cellId, k);
      }
      MFloat sumVarX = 0;
      MFloat sumVarY = 0;
      MFloat sumVarZ = 0;
      MFloat sumVarXY = 0;
      MFloat sumVarXZ = 0;
      MFloat sumVarYZ = 0;
      MFloat sumVarX2 = 0;
      MFloat sumVarY2 = 0;
      MFloat sumVarZ2 = 0;

      rhs.set(0.0);

      // 3.1 Calculate intermediate variables
      for(MUint nId = 1; nId < nghbrList.size(); nId++) {
        MFloat x = 0;
        MFloat y = 0;
        MFloat z = 0;
        MFloat var = 0;
        const MInt nghbrId = nghbrList[nId];
        if(nghbrId < 0) {
          x = pseudoCellPos[nId][0] - originX;
          y = pseudoCellPos[nId][1] - originY;
          var = pseudoCellVar[nId][k - a];

          IF_CONSTEXPR(nDim == 3) { z = pseudoCellPos[nId][2] - originZ; }
        } else {
          x = a_coordinate(nghbrId, 0) - originX;
          y = a_coordinate(nghbrId, 1) - originY;
          if(old) {
            var = a_oldVariable(nghbrId, k);
          } else {
            var = a_variable(nghbrId, k);
          }
          IF_CONSTEXPR(nDim == 3) { z = a_coordinate(nghbrId, 2) - originZ; }
        }

        sumVar += var;
        sumVarX += var * x;
        sumVarY += var * y;
        sumVarZ += var * z;
        sumVarXY += var * x * y;
        sumVarXZ += var * x * z;
        sumVarYZ += var * y * z;
        sumVarX2 += var * x * x;
        sumVarY2 += var * y * y;
        sumVarZ2 += var * z * z;
      }

      // 3.2 assign intermediate variables to rhs
      IF_CONSTEXPR(nDim == 2) {
        rhs[0] = sumVarX2;
        rhs[1] = sumVarY2;
        rhs[2] = sumVarXY;
        rhs[3] = sumVarX;
        rhs[4] = sumVarY;
        rhs[5] = sumVar;
      }
      else {
        rhs(0) = sumVarX2;
        rhs(1) = sumVarY2;
        rhs(2) = sumVarZ2;
        rhs(3) = sumVarXY;
        rhs(4) = sumVarXZ;
        rhs(5) = sumVarYZ;
        rhs(6) = sumVarX;
        rhs(7) = sumVarY;
        rhs(8) = sumVarZ;
        rhs(9) = sumVar;
      }

      // 3.3 scale rhs
      for(MInt i = 0; i < 2 * nDim + pow(2, nDim - 1); i++) {
        rhs(i) *= normalizationFactor;
      }

      MFloatTensor coeff(2 * nDim + pow(2, nDim - 1));
      coeff.set(0.0);

      // 3.4 determine coefficients of the aim function polynomial
      for(MInt i = 0; i < 2 * nDim + pow(2, nDim - 1); i++) {
        for(MInt j = 0; j < 2 * nDim + pow(2, nDim - 1); j++) {
          coeff(i) += matInv(i, j) * rhs(j);
        }
      }

      ///
      /// 4. determine solution
      ///
      MFloat positionX = position[0] - originX;
      MFloat positionY = position[1] - originY;
      MFloat positionZ = 0;
      IF_CONSTEXPR(nDim == 3) { positionZ = position[2] - originZ; }
      MFloat result = coeff((MInt)(2 * nDim + pow(2, nDim - 1) - 1));
      IF_CONSTEXPR(nDim == 2) {
        result += coeff(0) * positionX * positionX;
        result += coeff(1) * positionY * positionY;
        result += coeff(2) * positionX * positionY;
        result += coeff(3) * positionX;
        result += coeff(4) * positionY;
      }
      else {
        result += coeff(0) * positionX * positionX;
        result += coeff(1) * positionY * positionY;
        result += coeff(2) * positionZ * positionZ;
        result += coeff(3) * positionX * positionY;
        result += coeff(4) * positionX * positionZ;
        result += coeff(5) * positionY * positionZ;
        result += coeff(6) * positionX;
        result += coeff(7) * positionY;
        result += coeff(8) * positionZ;
      }

      interpolatedVar[k - a] = result;
    }
  }

  // TRACE_OUT();
}


/// \brief Init the interpolation for points inside a given cell (based on interpolateVariables())
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initInterpolationForCell(const MInt cellId) {
  ASSERT(cellId >= 0, "ERROR: Invalid cellId!");

  if(m_cellInterpolationIndex[cellId] != -1) {
    /* std::cerr << "Interpolation for cell " << cellId << " already initialndized." << std::endl; */
    return;
  }

  const MFloat* const origin = &a_coordinate(cellId, 0);

  ///
  /// 1. Find all direct neighboring cells
  ///
  vector<MInt> nghbrList;
#ifdef _OPENMP
#pragma omp critical
#endif
  {
    findDirectNghbrs(cellId, nghbrList);
    if(nghbrList.size() < 12) {
      findNeighborHood(cellId, 2, nghbrList);
#ifndef NDEBUG
      if(nghbrList.size() < 14) {
        cout << "WARNING: Only found " << nghbrList.size() << " neighbors during interpolation!" << endl;
      }
#endif
    }
  }

  // check for boundary ghost cells belonging to cells in the neighbor list
  // for these cell a pseudoCell element is added, carrying position and velocity
  // on the boundary surface
  /* vector<vector<MFloat>> pseudoCellVar(nghbrList.size(), vector<MFloat>(b - a)); */
  /* vector<vector<MFloat>> pseudoCellPos(nghbrList.size(), {0, 0, 0}); */

  for(MUint nId = 0; nId < nghbrList.size(); nId++) {
    const MInt nghbrId = nghbrList[nId];
    if(nghbrId >= 0 && a_bndryId(nghbrId) > -1) {
      mTerm(1, "boundary cells not handled");
      // mark as pseudo cell
      /* nghbrList[nId] = -1; */
      /* for (MInt i = 0; i < nDim; i++) { */
      /*   pseudoCellPos[nId][i] = m_bndryCells->a[a_bndryId(nghbrId)].m_srfcs[0]->m_coordinates[i]; */
      /* } */
      /* for (MInt i = a; i < b; i++) { */
      /*   // todo labels:FV,toenhance bndCnd need to be implemented here (assumes bnd result equals cell result) */
      /*   if(old){ */
      /*     pseudoCellVar[nId][i - a] = a_oldVariable(cellId, i); */
      /*   } else { */
      /*     pseudoCellVar[nId][i - a] = a_variable(cellId, i); */
      /*   } */
      /* } */
    }
  }

  if(nghbrList.size() < 10) {
    mTerm(1, "too few neighbors");
  }

  ///
  /// 2b. build the least square matrix LSMatrix...
  ///
  MFloatTensor LSMatrix(2 * nDim + pow(2, nDim - 1), 2 * nDim + pow(2, nDim - 1));
  /* MFloatTensor rhs(2 * nDim + pow(2, nDim - 1)); */
  //  MFloatTensor weights(2 * nDim + pow(2, nDim - 1));
  MFloatTensor matInv(2 * nDim + pow(2, nDim - 1), 2 * nDim + pow(2, nDim - 1));

  LSMatrix.set(0.0);
  //  weights.set(1.0);
  matInv.set(0.0);

  MFloat sumX = 0;
  MFloat sumY = 0;
  MFloat sumZ = 0;
  MFloat sumXY = 0;
  MFloat sumXZ = 0;
  MFloat sumYZ = 0;
  MFloat sumX2 = 0;
  MFloat sumY2 = 0;
  MFloat sumZ2 = 0;
  MFloat sumXYZ = 0;
  MFloat sumX2Y = 0;
  MFloat sumX2Z = 0;
  MFloat sumXY2 = 0;
  MFloat sumY2Z = 0;
  MFloat sumXZ2 = 0;
  MFloat sumYZ2 = 0;
  MFloat sumX3 = 0;
  MFloat sumY3 = 0;
  MFloat sumZ3 = 0;
  MFloat sumX3Y = 0;
  MFloat sumX3Z = 0;
  MFloat sumXY3 = 0;
  MFloat sumY3Z = 0;
  MFloat sumXZ3 = 0;
  MFloat sumYZ3 = 0;
  MFloat sumX2Y2 = 0;
  MFloat sumX2Z2 = 0;
  MFloat sumX2YZ = 0;
  MFloat sumY2Z2 = 0;
  MFloat sumXY2Z = 0;
  MFloat sumXYZ2 = 0;
  MFloat sumX4 = 0;
  MFloat sumY4 = 0;
  MFloat sumZ4 = 0;


  // 2.1 Calculate intermediate variables
  for(MUint nId = 1; nId < nghbrList.size(); nId++) {
    MFloat x = 0;
    MFloat y = 0;
    MFloat z = 0;
    const MInt nghbrId = nghbrList[nId];
    if(nghbrId < 0) {
      mTerm(1, "not supported");
    }
    /*   x = pseudoCellPos[nId][0] - originX; */
    /*   y = pseudoCellPos[nId][1] - originY; */
    /*   IF_CONSTEXPR(nDim == 3) { */
    /*     z = pseudoCellPos[nId][2] - originZ; */
    /*   } */
    /* } else { */
    x = a_coordinate(nghbrId, 0) - origin[0];
    y = a_coordinate(nghbrId, 1) - origin[1];
    IF_CONSTEXPR(nDim == 3) { z = a_coordinate(nghbrId, 2) - origin[2]; }
    /* } */

    sumX += x;
    sumY += y;
    sumZ += z;
    sumXY += x * y;
    sumXZ += x * z;
    sumYZ += y * z;
    sumX2 += x * x;
    sumY2 += y * y;
    sumZ2 += z * z;
    sumXYZ += x * y * z;
    sumX2Y += x * x * y;
    sumX2Z += x * x * z;
    sumXY2 += x * y * y;
    sumY2Z += y * y * z;
    sumXZ2 += z * z * x;
    sumYZ2 += z * z * y;
    sumX3 += x * x * x;
    sumY3 += y * y * y;
    sumZ3 += z * z * z;
    sumX3Y += x * x * x * y;
    sumX3Z += x * x * x * z;
    sumXY3 += y * y * y * x;
    sumY3Z += y * y * y * z;
    sumXZ3 += z * z * z * x;
    sumYZ3 += z * z * z * y;
    sumX2Y2 += x * x * y * y;
    sumX2Z2 += x * x * z * z;
    sumX2YZ += x * x * y * z;
    sumY2Z2 += y * y * z * z;
    sumXY2Z += x * y * y * z;
    sumXYZ2 += x * y * z * z;
    sumX4 += x * x * x * x;
    sumY4 += y * y * y * y;
    sumZ4 += z * z * z * z;
  }

  // 2.2 Use intermediate variables to build LSMatrix
  IF_CONSTEXPR(nDim == 2) {
    // diagonal
    LSMatrix(0, 0) = sumX4;
    LSMatrix(1, 1) = sumY4;
    LSMatrix(2, 2) = sumX2Y2;
    LSMatrix(3, 3) = sumX2;
    LSMatrix(4, 4) = sumY2;
    LSMatrix(5, 5) = nghbrList.size();

    // first column/row
    LSMatrix(0, 1) = LSMatrix(1, 0) = sumX2Y2;
    LSMatrix(0, 2) = LSMatrix(2, 0) = sumX3Y;
    LSMatrix(0, 3) = LSMatrix(3, 0) = sumX3;
    LSMatrix(0, 4) = LSMatrix(4, 0) = sumX2Y;
    LSMatrix(0, 5) = LSMatrix(5, 0) = sumX2;

    // second column/row
    LSMatrix(1, 2) = LSMatrix(2, 1) = sumXY3;
    LSMatrix(1, 3) = LSMatrix(3, 1) = sumXY2;
    LSMatrix(1, 4) = LSMatrix(4, 1) = sumY3;
    LSMatrix(1, 5) = LSMatrix(5, 1) = sumY2;

    // third column/row
    LSMatrix(2, 3) = LSMatrix(3, 2) = sumX2Y;
    LSMatrix(2, 4) = LSMatrix(4, 2) = sumXY2;
    LSMatrix(2, 5) = LSMatrix(5, 2) = sumXY;

    // fourth column/row
    LSMatrix(3, 4) = LSMatrix(4, 3) = sumXY;
    LSMatrix(3, 5) = LSMatrix(5, 3) = sumX;

    // fifth coulmn/row
    LSMatrix(4, 5) = LSMatrix(5, 4) = sumY;
  }
  else {
    // diagonal
    LSMatrix(0, 0) = sumX4;
    LSMatrix(1, 1) = sumY4;
    LSMatrix(2, 2) = sumZ4;
    LSMatrix(3, 3) = sumX2Y2;
    LSMatrix(4, 4) = sumX2Z2;
    LSMatrix(5, 5) = sumY2Z2;
    LSMatrix(6, 6) = sumX2;
    LSMatrix(7, 7) = sumY2;
    LSMatrix(8, 8) = sumZ2;
    LSMatrix(9, 9) = nghbrList.size();

    // first column/row
    LSMatrix(0, 1) = LSMatrix(1, 0) = sumX2Y2;
    LSMatrix(0, 2) = LSMatrix(2, 0) = sumX2Z2;
    LSMatrix(0, 3) = LSMatrix(3, 0) = sumX3Y;
    LSMatrix(0, 4) = LSMatrix(4, 0) = sumX3Z;
    LSMatrix(0, 5) = LSMatrix(5, 0) = sumX2YZ;
    LSMatrix(0, 6) = LSMatrix(6, 0) = sumX3;
    LSMatrix(0, 7) = LSMatrix(7, 0) = sumX2Y;
    LSMatrix(0, 8) = LSMatrix(8, 0) = sumX2Z;
    LSMatrix(0, 9) = LSMatrix(9, 0) = sumX2;

    // second column/row
    LSMatrix(1, 2) = LSMatrix(2, 1) = sumY2Z2;
    LSMatrix(1, 3) = LSMatrix(3, 1) = sumXY3;
    LSMatrix(1, 4) = LSMatrix(4, 1) = sumXY2Z;
    LSMatrix(1, 5) = LSMatrix(5, 1) = sumY3Z;
    LSMatrix(1, 6) = LSMatrix(6, 1) = sumXY2;
    LSMatrix(1, 7) = LSMatrix(7, 1) = sumY3;
    LSMatrix(1, 8) = LSMatrix(8, 1) = sumY2Z;
    LSMatrix(1, 9) = LSMatrix(9, 1) = sumY2;

    // third column/row
    LSMatrix(2, 3) = LSMatrix(3, 2) = sumXYZ2;
    LSMatrix(2, 4) = LSMatrix(4, 2) = sumXZ3;
    LSMatrix(2, 5) = LSMatrix(5, 2) = sumYZ3;
    LSMatrix(2, 6) = LSMatrix(6, 2) = sumXZ2;
    LSMatrix(2, 7) = LSMatrix(7, 2) = sumYZ2;
    LSMatrix(2, 8) = LSMatrix(8, 2) = sumZ3;
    LSMatrix(2, 9) = LSMatrix(9, 2) = sumZ2;

    // fourth column, fourth line
    LSMatrix(3, 4) = LSMatrix(4, 3) = sumX2YZ;
    LSMatrix(3, 5) = LSMatrix(5, 3) = sumXY2Z;
    LSMatrix(3, 6) = LSMatrix(6, 3) = sumX2Y;
    LSMatrix(3, 7) = LSMatrix(7, 3) = sumXY2;
    LSMatrix(3, 8) = LSMatrix(8, 3) = sumXYZ;
    LSMatrix(3, 9) = LSMatrix(9, 3) = sumXY;

    // fifth coulmn, fifth line
    LSMatrix(4, 5) = LSMatrix(5, 4) = sumXYZ2;
    LSMatrix(4, 6) = LSMatrix(6, 4) = sumX2Z;
    LSMatrix(4, 7) = LSMatrix(7, 4) = sumXYZ;
    LSMatrix(4, 8) = LSMatrix(8, 4) = sumXZ2;
    LSMatrix(4, 9) = LSMatrix(9, 4) = sumXZ;

    // sixth column, sixth line
    LSMatrix(5, 6) = LSMatrix(6, 5) = sumXYZ;
    LSMatrix(5, 7) = LSMatrix(7, 5) = sumY2Z;
    LSMatrix(5, 8) = LSMatrix(8, 5) = sumYZ2;
    LSMatrix(5, 9) = LSMatrix(9, 5) = sumYZ;

    // seventh column, seventh line
    LSMatrix(6, 7) = LSMatrix(7, 6) = sumXY;
    LSMatrix(6, 8) = LSMatrix(8, 6) = sumXZ;
    LSMatrix(6, 9) = LSMatrix(9, 6) = sumX;

    // eigth column, eigth line
    LSMatrix(7, 8) = LSMatrix(8, 7) = sumYZ;
    LSMatrix(7, 9) = LSMatrix(9, 7) = sumY;

    // nineth column, nineth line
    LSMatrix(8, 9) = LSMatrix(9, 8) = sumZ;
  }

  // 2.3 scale solution since the condition number gets really bad for large discrepancies in cell
  // size
  const MFloat normalizationFactor = FPOW2(2 * a_level(cellId)) / grid().cellLengthAtLevel(0);
  for(MInt i = 0; i < 2 * nDim + pow(2, nDim - 1); i++) {
    for(MInt j = 0; j < 2 * nDim + pow(2, nDim - 1); j++) {
      LSMatrix(i, j) *= normalizationFactor;
    }
  }

  // 2.4 determine the pseudoinverse using SVD
  maia::math::invert(LSMatrix, matInv, 2 * nDim + pow(2, nDim - 1), 2 * nDim + pow(2, nDim - 1));

  const MInt matSize = 2 * nDim + pow(2, nDim - 1);
  std::vector<MFloat> matInvVector(matSize * matSize);

  MInt k = 0;
  for(MInt i = 0; i < 2 * nDim + pow(2, nDim - 1); i++) {
    for(MInt j = 0; j < 2 * nDim + pow(2, nDim - 1); j++) {
      matInvVector[k] = matInv(i, j);
      k++;
    }
  }

  const MInt interpIndex = m_cellInterpolationIds.size();
  // Store interpolation information for points in this cell
  m_cellInterpolationIndex[cellId] = interpIndex;
  m_cellInterpolationIds.push_back(nghbrList);
  m_cellInterpolationMatrix.push_back(matInvVector);
}


/// \brief Interpolate the given variable field inside a cell at a given position (based on
///        interpolateVariables() but uses the stored interpolation information for a cell).
template <MInt nDim_, class SysEqn>
template <MInt a, MInt b>
void FvCartesianSolverXD<nDim_, SysEqn>::interpolateVariablesInCell(const MInt cellId, const MFloat* position,
                                                                    std::function<MFloat(MInt, MInt)> variables,
                                                                    MFloat* interpolatedVar) {
  ASSERT((b - a) > 0, "ERROR: Difference between b and a needs to be positive!");
  ASSERT(cellId >= 0, "ERROR: Invalid cellId!");

  const MInt interpIndex = m_cellInterpolationIndex[cellId];
  if(interpIndex < 0) {
    mTerm(1, "Interpolation for cell not initialized");
    /* std::cerr << "Interpolation for cell " << cellId << " not initialized." << std::endl; */
    // interpolateVariables<a, b>(cellId, position, variables, interpolatedVar);
    /* return; */
  }

  const MFloat originX = a_coordinate(cellId, 0);
  const MFloat originY = a_coordinate(cellId, 1);
  MFloat originZ = 0.0;
  IF_CONSTEXPR(nDim == 3) { originZ = a_coordinate(cellId, 2); }

  const MFloat normalizationFactor = FPOW2(2 * a_level(cellId)) / grid().cellLengthAtLevel(0);

  const MInt noNghbrs = m_cellInterpolationIds[interpIndex].size();
  const MInt* const nghbrList = &m_cellInterpolationIds[interpIndex][0];

  const MInt matSize = 2 * nDim + pow(2, nDim - 1);
  MFloatTensor interpMatInv(&m_cellInterpolationMatrix[interpIndex][0], matSize, matSize);

  ///
  /// 3. Build rhs and solve the LS problem
  ///
  MFloat rhs[10];
  MFloat coeff[10];

  for(MInt k = a; k < b; k++) {
    MFloat sumVar = variables(cellId, k);
    MFloat sumVarX = 0;
    MFloat sumVarY = 0;
    MFloat sumVarZ = 0;
    MFloat sumVarXY = 0;
    MFloat sumVarXZ = 0;
    MFloat sumVarYZ = 0;
    MFloat sumVarX2 = 0;
    MFloat sumVarY2 = 0;
    MFloat sumVarZ2 = 0;

    std::fill_n(&rhs[0], matSize, 0.0);

    // 3.1 Calculate intermediate variables
    for(MInt nId = 1; nId < noNghbrs; nId++) {
      const MInt nghbrId = nghbrList[nId];
      const MFloat x = a_coordinate(nghbrId, 0) - originX;
      const MFloat y = a_coordinate(nghbrId, 1) - originY;
      const MFloat var = variables(nghbrId, k);
      MFloat z = 0.0;
      IF_CONSTEXPR(nDim == 3) { z = a_coordinate(nghbrId, 2) - originZ; }

      const MFloat varX = var * x;
      const MFloat varY = var * y;
      const MFloat varZ = var * z;

      sumVar += var;
      sumVarX += varX;
      sumVarY += varY;
      sumVarZ += varZ;

      sumVarXY += varX * y;
      sumVarXZ += varX * z;
      sumVarYZ += varY * z;

      sumVarX2 += varX * x;
      sumVarY2 += varY * y;
      sumVarZ2 += varZ * z;
    }

    // 3.2 assign intermediate variables to rhs
    IF_CONSTEXPR(nDim == 2) {
      rhs[0] = sumVarX2;
      rhs[1] = sumVarY2;
      rhs[2] = sumVarXY;
      rhs[3] = sumVarX;
      rhs[4] = sumVarY;
      rhs[5] = sumVar;
    }
    else {
      rhs[0] = sumVarX2;
      rhs[1] = sumVarY2;
      rhs[2] = sumVarZ2;

      rhs[3] = sumVarXY;
      rhs[4] = sumVarXZ;
      rhs[5] = sumVarYZ;

      rhs[6] = sumVarX;
      rhs[7] = sumVarY;
      rhs[8] = sumVarZ;
      rhs[9] = sumVar;
    }

    // 3.3 scale rhs
    for(MInt i = 0; i < matSize; i++) {
      rhs[i] *= normalizationFactor;
    }

    std::fill_n(&coeff[0], matSize, 0.0);

    // 3.4 determine coefficients of the aim function polynomial
    for(MInt i = 0; i < matSize; i++) {
      for(MInt j = 0; j < matSize; j++) {
        coeff[i] += interpMatInv(i, j) * rhs[j];
      }
    }

    ///
    /// 4. determine solution
    ///
    const MFloat positionX = position[0] - originX;
    const MFloat positionY = position[1] - originY;
    MFloat positionZ = 0.0;
    IF_CONSTEXPR(nDim == 3) { positionZ = position[2] - originZ; }

    MFloat result = coeff[matSize - 1];
    IF_CONSTEXPR(nDim == 2) {
      result += coeff[0] * positionX * positionX;
      result += coeff[1] * positionY * positionY;
      result += coeff[2] * positionX * positionY;
      result += coeff[3] * positionX;
      result += coeff[4] * positionY;
    }
    else {
      result += coeff[0] * positionX * positionX;
      result += coeff[1] * positionY * positionY;
      result += coeff[2] * positionZ * positionZ;
      result += coeff[3] * positionX * positionY;
      result += coeff[4] * positionX * positionZ;
      result += coeff[5] * positionY * positionZ;
      result += coeff[6] * positionX;
      result += coeff[7] * positionY;
      result += coeff[8] * positionZ;
    }

    interpolatedVar[k - a] = result;
  }
}


/// \brief Calculate the sampling variables at a given point in a cell.
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::calcSamplingVarAtPoint(const MFloat* point, const MInt id,
                                                                const MInt sampleVarId, MFloat* state,
                                                                const MBool interpolate) {
  // Note: interpolateVariablesInCell() requires variables for all cells
  switch(sampleVarId) {
    case FV_PV: {
      if(interpolate) {
        const MInt noSpecies = PV->m_noSpecies;
        constexpr MInt noVarsNoSpecies = (nDim == 2) ? 4 : 5;
        // Function pointer to a_pvariable
        std::function<MFloat(const MInt, const MInt)> varPtr = [&](const MInt cellId_, const MInt varId_) {
          return static_cast<MFloat>(a_pvariable(cellId_, varId_));
        };
        if(noSpecies == 0) {
          ASSERT(noVarsNoSpecies == PV->noVariables, "wrong number of variables");
          interpolateVariablesInCell<0, noVarsNoSpecies>(id, point, varPtr, state);
        } else if(noSpecies == 1) {
          interpolateVariablesInCell<0, noVarsNoSpecies + 1>(id, point, varPtr, state);
        } else {
          mTerm(1, "Fixme: noSpecies > 1");
        }
      } else {
        const MInt noVars = PV->noVariables;
        std::copy_n(&a_pvariable(id, 0), noVars, state);
      }
      break;
    }
    case FV_VORT: {
      const MInt noVort = (nDim == 2) ? 1 : 3;
      if(interpolate) {
        std::function<MFloat(const MInt, const MInt)> vortPointer = [&](const MInt cellId_, const MInt varId_) {
          return m_samplingVariables[sampleVarId][cellId_][varId_];
        };
        interpolateVariablesInCell<0, noVort>(id, point, vortPointer, state);
      } else {
        const MFloat** vortPointer = const_cast<const MFloat**>(m_samplingVariables[sampleVarId]);
        std::copy_n(vortPointer[id], noVort, state);
      }
      break;
    }
    case FV_HEAT_RELEASE: {
      if(interpolate) {
        mTerm(1, "Fixme: interpolation of heat release");
      }
      state[0] = m_heatRelease[id];
      break;
    }
    default: {
      mTerm(1, "Invalid variable id");
      break;
    }
  }
}

/** Updates old solutions for the physical time derivative
 * (dual time stepping)
 *
 * @author Daniel Hartmann, 23.08.2006
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::implicitTimeStep() {
  TRACE();

  m_physicalTime += m_physicalTimeStep;

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    for(MInt varId = 0; varId < CV->noVariables; varId++) {
      a_dt2Variable(cellId, varId) = a_dt1Variable(cellId, varId);
      a_dt1Variable(cellId, varId) = a_variable(cellId, varId);
    }
  }
}

/** Computes additional RHS from the physical time derivative
 * (dual time stepping)
 *
 * @author Daniel Hartmann, 23.08.2006
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::dqdtau() {
  TRACE();

  MBool cellOk;
  MFloat dt;
  const MFloat F4B2 = 2.0;


  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    // multilevel
    if(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      if(!a_isBndryGhostCell(cellId)) {
        cellOk = true;
        if(a_bndryId(cellId) > -1) {
          if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_linkedCellId != -1) {
            cellOk = false;
          }
        }
        if(cellOk) {
          dt = a_cellVolume(cellId) / m_physicalTimeStep;

          for(MInt varId = 0; varId < CV->noVariables; varId++) {
            a_rightHandSide(cellId, varId) += (F3B2 * a_variable(cellId, varId) - F4B2 * a_dt1Variable(cellId, varId)
                                               + F1B2 * a_dt2Variable(cellId, varId))
                                              * dt;
          }
        }
      }
    }
  }
}

/// Computes pressure in the cell \p cellId from the conservative variables.
template <MInt nDim_, class SysEqn>
MFloat FvCartesianSolverXD<nDim_, SysEqn>::cv_p(MInt cellId) const noexcept {
  IF_CONSTEXPR(!hasE<SysEqn>)
  mTerm(1, AT_, "Not compatible with SysEqn without RHO_E!");
  MFloat momentumDensitySquare = F0;
  for(MInt d = 0; d < nDim; ++d) {
    momentumDensitySquare += POW2((a_variable(cellId, CV->RHO_VV[d])));
  }
  return sysEqn().pressure(a_variable(cellId, CV->RHO), momentumDensitySquare, a_variable(cellId, CV->RHO_E));
}

/// Computes temperature in the cell \p cellId from the conservative variables.
template <MInt nDim_, class SysEqn>
MFloat FvCartesianSolverXD<nDim_, SysEqn>::cv_T(MInt cellId) const noexcept {
  return sysEqn().temperature_ES(a_variable(cellId, CV->RHO), cv_p(cellId));
}

/// Computes the speed of sound in the cell \p cellId from the conservative variables.
template <MInt nDim_, class SysEqn>
MFloat FvCartesianSolverXD<nDim_, SysEqn>::cv_a(MInt cellId) const noexcept {
  return sysEqn().speedOfSound(a_variable(cellId, CV->RHO), cv_p(cellId));
}


// debug
/// Computes the time-step from the CFL condition for the Euler-eqts as follows:
///
/// dt =   min      C * dx / (|u_i| + a)
///      i = 0..d
template <MInt nDim_, class SysEqn>
MFloat FvCartesianSolverXD<nDim_, SysEqn>::computeTimeStepEulerDirectional(MInt cellId) const noexcept {
  MFloat a;
  IF_CONSTEXPR(!hasE<SysEqn>)
  mTerm(1, AT_, "Not compatible with SysEqn without RHO_E!");

  IF_CONSTEXPR(isDetChem<SysEqn>) {
    MFloat gamma = a_avariable(cellId, AV->GAMMA);
    MFloat p = a_pvariable(cellId, PV->P);
    MFloat rho = a_pvariable(cellId, PV->RHO);
    a = sqrt(gamma * mMax(MFloatEps, p / mMax(MFloatEps, rho)));
  }
  else {
    a = cv_a(cellId);
  }

  MFloat dt = std::numeric_limits<MFloat>::max();
  const MFloat Frho = 1. / a_variable(cellId, CV->RHO);
  const MFloat dx = c_cellLengthAtCell(cellId);
  for(MInt d = 0; d < nDim; ++d) {
    MFloat abs_u_d = fabs(a_variable(cellId, CV->RHO_VV[d]) * Frho);
    MFloat dt_dir = m_cfl * dx / (abs_u_d + a);
    dt = mMin(dt, dt_dir);
  }

  return dt;
}
/// Computes the time-step from the CFL condition for the APEs and the LAE testcase
///
/// Taken from scheme no. 1 in "Report: maximum_CFLs" by Rodrigo/Michael
template <MInt nDim_, class SysEqn>
MFloat FvCartesianSolverXD<nDim_, SysEqn>::computeTimeStepApeDirectional(MInt cellId) const noexcept {
  ASSERT(((SolverType)string2enum(Context::getSolverProperty<MString>("solvertype", m_solverId, AT_))) == MAIA_FV_APE,
         "FV_APE solver not selected");

  const MFloat dx = c_cellLengthAtCell(cellId);

  MFloat lambdaMaxSum = (m_initialCondition == 1184) ? 0.0 : nDim; // 0 for LAE(IC1184), nDim for APE
  MFloat advectionVelocity[nDim];
  for(MInt d = 0; d < nDim; ++d) {
    advectionVelocity[d] =
        Context::getSolverProperty<MFloat>("advectionVelocity", m_solverId, AT_, &advectionVelocity[d], d);
    lambdaMaxSum += fabs(advectionVelocity[d]);
  }
  return m_cfl * dx / (lambdaMaxSum);
}

/// Computes the time-step from the stability condition for the Diffusion Eqt.
///
/// dt = C * dx^2 / diffusion_coefficient  where C = (0, 1/4]
template <MInt nDim_, class SysEqn>
MFloat FvCartesianSolverXD<nDim_, SysEqn>::computeTimeStepDiffusionNS(MFloat density, MFloat temperature, MFloat Re,
                                                                      MFloat C, MFloat dx) const noexcept {
  return sysEqn().computeTimeStepDiffusion(SUTHERLANDLAW(temperature) / (density * Re), C, dx);
}

/// Computes the time-step from the stability condition for the Diffusion Eqt.
///
/// dt = C * dx^2 / diffusion_coefficient  where C = (0, 1/4]
// template <MInt nDim_, class SysEqn>
// MFloat FvCartesianSolverXD<nDim_, SysEqn>::computeTimeStepDiffusionNS(MFloat density, MFloat temperature, MFloat Re,
//                                                                       MFloat C, MFloat dx) const noexcept {
//   return computeTimeStepDiffusion(SUTHERLANDLAW(temperature) / (density * Re), C, dx);
// }

/// Computes the time-step of the cell \p cellId.
template <MInt nDim_, class SysEqn>
MFloat FvCartesianSolverXD<nDim_, SysEqn>::computeTimeStepMethod(MInt cellId) const noexcept {
  switch(m_timeStepMethod) {
    default: {
      if(m_timeStepFixedValue > 0.) {
        return m_timeStepFixedValue;
      }
      mTerm(1, AT_, "unknown time-step method: " + to_string(m_timeStepMethod));
    }
    case 17511: // this uses a different time-step during the simulation but writes
                // the one that was read from a restart file to the next file
    case 1: {
      return computeTimeStepEulerDirectional(cellId);
    }
    case 2: {
      return computeTimeStepApeDirectional(cellId);
    }
    case 6: {
      return m_cfl * c_cellLengthAtLevel(maxRefinementLevel());
      // prior version used m_maxGCellLevel from the levelSet-Solver!
    }
    // Infinity values:
    case 100: {
      const MFloat dx = c_cellLengthAtLevel(maxRefinementLevel());
      std::array<MFloat, nDim> u = {};
      u[0] = m_UInfinity;
      u[1] = m_VInfinity;
      IF_CONSTEXPR(nDim == 3) u[2] = m_WInfinity;
      const MFloat dt_inv = sysEqn().computeTimeStepEulerMagnitude(m_rhoInfinity, u, m_PInfinity, m_cfl, dx);
      const MFloat dt_visc = computeTimeStepDiffusionNS(m_rhoInfinity, m_TInfinity, sysEqn().m_Re0, m_cflViscous, dx);
      return mMin(dt_inv, dt_visc);
    }
  }
}

template <MInt nDim_, class SysEqn>
MFloat FvCartesianSolverXD<nDim_, SysEqn>::computeTimeStep(MInt cellId) const noexcept {
  MFloat dtCell = computeTimeStepMethod(cellId);

  // Applies volume weighting to boundary cells
  if(m_timeStepVolumeWeighted && a_bndryId(cellId) != -1) {
    dtCell *= a_cellVolume(cellId) / grid().cellVolumeAtLevel(a_level(cellId));
  }
  return dtCell;
}

/// Does the cell \p cellId participate in the time-step computation?
template <MInt nDim_, class SysEqn>
MBool FvCartesianSolverXD<nDim_, SysEqn>::cellParticipatesInTimeStep(MInt cellId) const noexcept {
  // Skip cells in other MG levels:
  if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
    return false;
  }
  // Skip ghost-cells? (TODO labels:FV,totest is this the proper check for that?)
  if(a_bndryId(cellId) < -1) {
    return false;
  }
  // TODO labels:FV,totest check how many testcases this breaks:
  // if (a_hasProperty(cellId, Cell:IsGhost)) { return false; }

  // Skip small cells
  //
  // TODO labels:FV doesn't work with noMerging which has no master/slave cells, all
  // small cells have m_linkedCellId == -1, so right now they always participate
  // in the time-step computation. This will probably explode if one enables
  // volume weighting of boundary cells in combination with noMerging.
  if(a_bndryId(cellId) > -1 && m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_linkedCellId != -1) {
    return false;
  }

  // Skip halo cells
  if(a_isHalo(cellId)) {
    return false;
  }

  // skip cells which are inactive (negative ls-value)
  if(a_hasProperty(cellId, SolverCell::IsInactive)) {
    return false;
  }

  // Skip cells which are stabilized by other means (smallCellCorrection, linking)
  if(a_hasProperty(cellId, SolverCell::IsTempLinked)) {
    return false;
  }
  if(a_hasProperty(cellId, SolverCell::IsSplitChild)) {
    return false;
  }
  if(!m_fvBndryCnd->m_cellMerging && a_isBndryCell(cellId)
     && a_cellVolume(cellId) / grid().cellVolumeAtLevel(maxLevel()) <= m_fvBndryCnd->m_volumeLimitWall) {
    // maxLevelChange use maxLevel() instead of maxRefinementLevel!
    return false;
  }


  return true;
}

/// Computes and sets the time-step:
/// - computes the time-step in the local domains
/// - sets the localTimeStep when dualTimeStepping is enabled
/// - reduces the time-step across domains
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeAndSetTimeStep() {
  TRACE();

  const MFloat invalidTimeStep = std::numeric_limits<MFloat>::max();
  // Compute the global time step:
  MFloat newTimeStep = invalidTimeStep;
  const MInt noCells = a_noCells();

  // Initialize dualTimeStepping:
  if(m_dualTimeStepping || m_localTS) {
    for(MInt cellId = 0; cellId < noCells; cellId++) {
      a_localTimeStep(cellId) = invalidTimeStep;
    }
  }

  // Compute the time-step for every non-small-cell and non-ghost-cell
  MInt noCellsOnWhichTheTimeStepIsComputed = 0;
  for(MInt cellId = 0; cellId < noCells; ++cellId) {
    if(!cellParticipatesInTimeStep(cellId)) {
      if(m_dualTimeStepping) {
        a_localTimeStep(cellId) = F0;
      }
      continue;
    }

    MFloat dtCell = computeTimeStep(cellId);
    newTimeStep = mMin(newTimeStep, dtCell);
    if(m_dualTimeStepping) {
      a_localTimeStep(cellId) = dtCell;
    }

    ++noCellsOnWhichTheTimeStepIsComputed;
  }


  // some domains have only cells that do not participate in the time-step
  // computation
  if(noCellsOnWhichTheTimeStepIsComputed != 0 && approx(newTimeStep, invalidTimeStep, m_eps)) {
    mTerm(1, AT_, "failed to compute the time-step " + std::to_string(m_solverId));
  }

  // Use a fixed user-provided time-step:
  if(m_timeStepFixedValue > 0.) {
    MPI_Allreduce(MPI_IN_PLACE, &newTimeStep, 1, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE", "m_timeStep");
    if(m_timeStepFixedValue > newTimeStep && domainId() == 0) { // Still check the CFL condition
      std::cerr << endl
                << endl
                << "WARNING: timeStepFixedvalue = " << m_timeStepFixedValue
                << " > computedGlobalTimeStep = " << newTimeStep << endl
                << endl
                << endl;
    }
    const MString msg = "FV-Solver globalTimeStep " + std::to_string(globalTimeStep)
                        + ", using fixed time step: " + std::to_string(m_timeStepFixedValue)
                        + " (computeGlobalTimeStep = " + std::to_string(newTimeStep) + ")";
    m_log << msg << std::endl;
    if(domainId() == 0) {
      std::cerr << msg << std::endl;
    }

    newTimeStep = m_timeStepFixedValue;

    if(m_dualTimeStepping) { // also check the CFL condition for local time stepping
      for(MInt cellId = 0; cellId < noCells; ++cellId) {
        if(m_timeStepFixedValue < a_localTimeStep(cellId)) {
          m_log << "Warning: cell " << cellId << "timeStepFixedvalue = " << m_timeStepFixedValue
                << " < computedLocalTimeStep = " << a_localTimeStep(cellId) << endl;
        }
        a_localTimeStep(cellId) = m_timeStepFixedValue;
      }
    }
    forceTimeStep(newTimeStep);
  } else {
    // If the time-step is not fixed to a single constant value, exchange:
    RECORD_TIMER_START(m_tcomm);
    RECORD_TIMER_START(m_texchangeDt);

    forceTimeStep(newTimeStep);
    ASSERT(m_timeStepAvailable, "overlapping time-step computations?!");
#ifndef MAIA_MS_COMPILER
    MPI_Iallreduce(MPI_IN_PLACE, &m_timeStep, 1, MPI_DOUBLE, MPI_MIN, mpiComm(), &m_timeStepReq, AT_, "MPI_IN_PLACE",
                   "m_timeStep");
#else
    MPI_Allreduce(MPI_IN_PLACE, &m_timeStep, 1, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE", "m_timeStep");
#endif

    m_timeStepAvailable = false;
    if(!m_timeStepNonBlocking) {
      timeStep(true);
    }
    RECORD_TIMER_STOP(m_texchangeDt);
    RECORD_TIMER_STOP(m_tcomm);

  }
}

// This is the interface to the methods class
// author: Daniel Hartmann, July 2007
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setTimeStep() {
  TRACE();

  if(!useTimeStepFromRestartFile()) {
    computeAndSetTimeStep();
  }

  m_timeStepUpdated = true;


  IF_CONSTEXPR(nDim == 2) {
    // TODOs labels:FV
    // - since computeSamplingTimeStep overwrites m_timeStep it belongs to timeStepMethods
    // - however it expects the previous time-step (before the one being modified)
    //  to be written to a file. For this reason:
    //    - m_restartFileOutputTimeStep exists which writes out a different dt than the one used
    //    - some level set test cases have a timeStep of -1 in their restart files...
    // - this seems to be only somehow relevant for 2D level set which means
    //   3D flames are using a completely different time-step
    m_restartFileOutputTimeStep =
        (m_timeStepMethod == 17511 || m_timeStepMethod == 6) ? timeStep(true) : m_restartFileOutputTimeStep;
    if(m_timeStepMethod == 17511) {
      computeSamplingTimeStep(); // TODO labels:FV 2d_forced_flame_serial cruft
    }
  }
}


//---------------------------------------------------------------------------


/**
 * \author Lennart Schneiders
 * \brief Computes the global root-mean-square residual.
 * The residual is defined as time derivative of conservative variables, RHS/cellVolume.
 * This gives a residual independent of the time step.
 * Similarly, the volume-weighting/volume-integrated RMS value results in a residual
 * independent from the number of cells, thus smooth in time for dynamic mesh adaptation.
 * mode 0 (default) : also write residual file
 * mode 1           : pure debugging of the residual
 */
template <MInt nDim_, class SysEqn>
MBool FvCartesianSolverXD<nDim_, SysEqn>::maxResidual(MInt mode) {
  TRACE();

  if(globalTimeStep % m_residualInterval != 0) {
    return true;
  }

  // Return if this is not the primary solver in a multilevel computation
  if(isMultilevel() && !isMultilevelPrimary()) {
    return true;
  }

  RECORD_TIMER_START(m_timers[Timers::TimeInt]);
  RECORD_TIMER_START(m_timers[Timers::Residual]);

  const MInt noCells = a_noCells();
  const MInt noCVars = CV->noVariables;
  MFloatScratchSpace rmsResidual(noCVars + 1, AT_, "rmsResidual");
  MFloatScratchSpace maxResidual(noCVars, AT_, "maxResidual");
  MFloatScratchSpace avgResidual(noCVars + 1, AT_, "rmsResidual");
  rmsResidual.fill(F0);

  //---end of initialization

  // Compute residual
  // ----------------
  for(MInt cellId = 0; cellId < noCells; cellId++) {
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_isHalo(cellId)) continue;
    if(a_isBndryGhostCell(cellId)) continue;
    if(a_isPeriodic(cellId)) continue;
    if(a_hasProperty(cellId, SolverCell::IsPeriodicWithRot)) continue;
    if(a_hasProperty(cellId, SolverCell::IsCutOff)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInvalid)) continue;
    MInt gridcellId = cellId;
    if(a_hasProperty(cellId, SolverCell::IsSplitClone) || a_hasProperty(cellId, SolverCell::IsSplitChild)) {
      gridcellId = m_splitChildToSplitCell.find(cellId)->second;
    }
    if(c_noChildren(gridcellId) > 0) continue;
    if(a_bndryId(cellId) > -1 && m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_linkedCellId > -1) continue;
    if(a_isInactive(cellId)) continue;

    rmsResidual(0) += a_cellVolume(cellId);
    avgResidual(0)++;
    for(MInt var = 0; var < noCVars; var++) {
      if(!m_localTS) {
        MBool useOldResidual = true;
        if(useOldResidual) {
          rmsResidual(1 + var) += a_cellVolume(cellId) * POW2(a_FcellVolume(cellId) * a_rightHandSide(cellId, var));
        } else {
          rmsResidual(1 + var) += a_cellVolume(cellId) * POW2(a_variable(cellId, var) - a_oldVariable(cellId, var));
        }
        avgResidual(1 + var) += POW2(a_variable(cellId, var) - a_oldVariable(cellId, var));
        maxResidual(var) = mMax(maxResidual(var), POW2(a_variable(cellId, var) - a_oldVariable(cellId, var)));
      } else {
        rmsResidual(1 + var) +=
            a_cellVolume(cellId) * POW2(a_variable(cellId, var) - a_oldVariable(cellId, var)) / a_localTimeStep(cellId);
        avgResidual(1 + var) += POW2(a_variable(cellId, var) - a_oldVariable(cellId, var)) / a_localTimeStep(cellId);
        maxResidual(var) = mMax(maxResidual(var),
                                POW2(a_variable(cellId, var) - a_oldVariable(cellId, var)) / a_localTimeStep(cellId));
      }
    }
  }

  RECORD_TIMER_START(m_timers[Timers::ResidualMpi]);
  MPI_Allreduce(MPI_IN_PLACE, &rmsResidual(0), rmsResidual.size(), MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "rmsResidual(0)");
  MPI_Allreduce(MPI_IN_PLACE, &maxResidual(0), maxResidual.size(), MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                "maxResidual(0)");
  MPI_Allreduce(MPI_IN_PLACE, &avgResidual(0), avgResidual.size(), MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "avgResidual(0)");
  RECORD_TIMER_STOP(m_timers[Timers::ResidualMpi]);

  // compute RMS error (volume integral)
  for(MInt var = 0; var < noCVars; var++) {
    if(!m_localTS) {
      rmsResidual(1 + var) = sqrt(rmsResidual(1 + var) / rmsResidual(0));
      avgResidual(1 + var) = sqrt(avgResidual(1 + var) / avgResidual(0));
      maxResidual(var) = sqrt(maxResidual(var));
    } else {
      rmsResidual(1 + var) = sqrt(rmsResidual(1 + var) / rmsResidual(0)) / timeStep();
      avgResidual(1 + var) = sqrt(avgResidual(1 + var) / avgResidual(0)) / timeStep();
      maxResidual(var) = sqrt(maxResidual(var)) / timeStep();
    }
  }

  if(mode == 0 && this->m_adaptation && this->m_resTriggeredAdapt && maxResidual(1 + PV->RHO) < 0.00001) {
    MInt limit = m_localTS ? 10 : 350;
    if(globalTimeStep - m_lastAdapTS < limit) {
      if(domainId() == 0) {
        cerr << "Residual threshold reached within 100 TS after last adaptation at " << globalTimeStep << endl;
        cerr << " -> Deactivating residual triggered Adaptation" << endl;
      }
      this->m_resTriggeredAdapt = false;
    } else {
      if(domainId() == 0) {
        cerr << "Forcing residual-based adaptation at time-step " << globalTimeStep << " with rms-density Residual of "
             << rmsResidual(1 + PV->RHO) << endl;
      }
      m_forceAdaptation = true;
    }
  }

  MBool abort = false;
  MFloat maxRes = F0;
  for(MInt var = 0; var < noCVars; var++) {
    // Exit on NaN of average residual
    if(!(rmsResidual(1 + var) >= F0 || rmsResidual(1 + var) < F0)) {
      if(domainId() == 0) {
        cerr << "Solution diverged, average residual is nan " << endl;
      }
      m_log << "Solution diverged, average residual is nan " << endl;
      abort = true;
    }
    maxRes = mMax(maxRes, rmsResidual(1 + var));
  }

  if(abort) {
    // Save output and exit
    disableDlbTimers();
    m_vtuWritePointData = false;
    m_vtuLevelThreshold = maxRefinementLevel();
    saveSolverSolution(1);
    if(!m_levelSetMb) {
      mTerm(1, AT_, "Solution diverged, average residual is NaN!");
    }
  }

  if(mode == 1) return false;

  if(domainId() == 0) {
    MString surname;
    if(!m_multipleFvSolver || (isMultilevel() && isMultilevelPrimary())) {
      surname = "Residual";
    } else {
      surname = "Residual_s" + to_string(solverId());
    }
    MString surnameBAK = surname + "_BAK";

    // Output, residual
    // -----------------------
    FILE* datei;
    if(globalTimeStep == m_residualInterval) {
      struct stat buffer;
      if(stat(surname.c_str(), &buffer) == 0) {
        rename(surname.c_str(), "Residual_BAK");
      }
      datei = fopen(surname.c_str(), "w");
      IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
        IF_CONSTEXPR(nDim == 3) {
          fprintf(datei, "%s",
                  "# 1:time_step  2:hydrodynamic_time  3:acoustic_time  4:res_rhoU  5:res_rhoV  6:res_rhoW  7:res_rhoE "
                  " 8:res_rho  "
                  "9:res_rhon  10:maxRes_rhoU  11:maxRes_rhoV  12:maxRes_rhoW  13:maxRes_rhoE  14:maxRes_rho  "
                  "15:avgRes_rhoU  16:avgRes_rhoV  17:avgRes_rhoW  18:avgRes_rhoE  19:avgRes_rho\n");
        }
        else {
          fprintf(datei, "%s",
                  "# 1:time_step  2:hydrodynamic_time  3:acoustic_time  4:res_rhoU  5:res_rhoV  6:res_rhoE  7:res_rho  "
                  "8:res_rhon  9:maxRes_rhoU  10:maxRes_rhoV  11:maxRes_rhoE  12:maxRes_rho  "
                  "13:avgRes_rhoU  14:avgRes_rhoV  15:avgRes_rhoE  16:avgRes_rho\n");
        }
      }
      else {
        IF_CONSTEXPR(nDim == 3) {
          fprintf(datei, "%s",
                  "# 1:time_step  2:hydrodynamic_time  3:acoustic_time  4:res_rhoU  5:res_rhoV  6:res_rhoW  7:res_rhoE "
                  " 8:res_rho  "
                  "9:maxRes_rhoU  10:maxRes_rhoV  11:maxRes_rhoW  12:maxRes_rhoE  13:maxRes_rho  "
                  "14:avgRes_rhoU  15:avgRes_rhoV  16:avgRes_rhoW  17:avgRes_rhoE  18:avgRes_rho\n");
        }
        else {
          fprintf(datei, "%s",
                  "# 1:time_step  2:hydrodynamic_time  3:acoustic_time  4:res_rhoU  5:res_rhoV  6:res_rhoE  7:res_rho  "
                  "8:maxRes_rhoU  9:maxRes_rhoV  10:maxRes_rhoE  11:maxRes_rho  "
                  "12:avgRes_rhoU  13:avgRes_rhoV  14:avgRes_rhoE  15:avgRes_rho\n");
        }
      }
    } else {
      datei = fopen(surname.c_str(), "a");
    }
    fprintf(datei, "%d", globalTimeStep);
    fprintf(datei, "  %f", m_physicalTime);
    fprintf(datei, "  %f", m_time);
    for(MInt var = 0; var < noCVars; var++) {
      fprintf(datei, "  %.8g", rmsResidual(1 + var));
    }
    for(MInt var = 0; var < noCVars; var++) {
      fprintf(datei, "  %.8g", maxResidual(var));
    }
    for(MInt var = 0; var < noCVars; var++) {
      fprintf(datei, "  %.8g", avgResidual(1 + var));
    }
    fprintf(datei, "\n");
    fclose(datei);
  }

  RECORD_TIMER_STOP(m_timers[Timers::Residual]);
  RECORD_TIMER_STOP(m_timers[Timers::TimeInt]);

  if(maxRefinementLevel() == maxLevel() && maxRes < m_timeStepConvergenceCriterion) {
    return true;
  }

  return false;
}


/**
 * \brief Reconstructs the flux on the surfaces
 *
 * \author Daniel Hartmann
 * \date May 2008
 *
 * \details MUSCL stands for Monotone Upstream-centered Schemes for Conservation Laws and
 *          is a method for reconstructing the fluxes on the cell surfaces. For this, the
 *          fluxes from the left and right of the surface are obtained by extrapolating
 *          the conservative variables (and not the fluxes) from the cell centers to the
 *          surface.
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::Muscl(MInt /*timerId*/) {
  TRACE();

  if(!calcSlopesAfterStep()) {
    RECORD_TIMER_START(m_timers[Timers::MusclReconst]);
    LSReconstructCellCenter();
    RECORD_TIMER_STOP(m_timers[Timers::MusclReconst]);

    // copy the slopes from the master to the slave cells
    RECORD_TIMER_START(m_timers[Timers::MusclCopy]);
    m_fvBndryCnd->copySlopesToSmallCells();
    RECORD_TIMER_STOP(m_timers[Timers::MusclCopy]);

    // update the ghost cell slopes for reconstruction of the primitive variables
    // on the surfaces for the AUSM scheme
    RECORD_TIMER_START(m_timers[Timers::MusclGhostSlopes]);
    m_fvBndryCnd->updateGhostCellSlopesInviscid();
    RECORD_TIMER_STOP(m_timers[Timers::MusclGhostSlopes]);

    RECORD_TIMER_START(m_timers[Timers::MusclCutSlopes]);
    m_fvBndryCnd->updateCutOffSlopesInviscid();
    RECORD_TIMER_STOP(m_timers[Timers::MusclCutSlopes]);
    // m_fvBndryCnd->updateGhostCellSlopesViscous();
  }

  // reconstruction of the slopes and variables at the center of the surfaces
  RECORD_TIMER_START(m_timers[Timers::MusclReconstSrfc]);
  (this->*m_reconstructSurfaceData)(-1);
  RECORD_TIMER_STOP(m_timers[Timers::MusclReconstSrfc]);

  if(m_useSandpaperTrip) {
    RECORD_TIMER_START(m_timers[Timers::SandpaperTrip]);
    applySandpaperTrip();
    RECORD_TIMER_STOP(m_timers[Timers::SandpaperTrip]);
  }

  if(m_useChannelForce) {
    applyChannelForce();
  }
}


/**
 * interpolates all variables to child using the stencil support of
 * four cells: cellId, stencilCellIds[ 0 ], stencilCellIds[ 1 ], stencilCellIds[ 2 ]
 *
 * @author Daniel Hartmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::bilinearInterpolationAtBnd(MInt child, MInt cellId, MInt* stencilCellIds) {
  TRACE();

  MInt noCVars = CV->noVariables;
  MFloat delta;
  MFloat childDistance, cellDistance, nghbrDistance;
  MFloat factor, cellFactor, nghbrFactor;

  // compute distances

  // compute the distance of the child cell normal to the boundary
  childDistance = 0;
  for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
    childDistance += (a_coordinate(child, spaceId)
                      - m_fvBndryCnd->m_bndryCells->a[a_bndryId(child)].m_srfcs[0]->m_coordinates[spaceId])
                     * m_fvBndryCnd->m_bndryCells->a[a_bndryId(child)].m_srfcs[0]->m_normalVector[spaceId];
  }
  childDistance = fabs(childDistance);
  // compute the distance of cellId normal to the boundary
  cellDistance = 0;
  for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
    cellDistance += (a_coordinate(cellId, spaceId)
                     - m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_srfcs[0]->m_coordinates[spaceId])
                    * m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_srfcs[0]->m_normalVector[spaceId];
  }
  cellDistance = fabs(cellDistance);
  // compute the distance of stencilCellIds[ 1 ] normal to the boundary
  nghbrDistance = 0;
  for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
    nghbrDistance += (a_coordinate(stencilCellIds[1], spaceId)
                      - m_fvBndryCnd->m_bndryCells->a[a_bndryId(stencilCellIds[1])].m_srfcs[0]->m_coordinates[spaceId])
                     * m_fvBndryCnd->m_bndryCells->a[a_bndryId(stencilCellIds[1])].m_srfcs[0]->m_normalVector[spaceId];
  }
  nghbrDistance = fabs(nghbrDistance);

  // compute interpolation factors...
  // ...for cellId
  cellFactor = (cellDistance - childDistance) / (2.0 * cellDistance);
  // ...for nghbr
  nghbrFactor = (nghbrDistance - childDistance) / (2.0 * nghbrDistance);

  // compute the distance between child and ...
  // ...cellId
  cellDistance = 0;
  for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
    delta = a_coordinate(cellId, spaceId) - a_coordinate(child, spaceId);
    cellDistance += delta * delta;
  }
  // ...nghbrId
  nghbrDistance = 0;
  for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
    delta = a_coordinate(stencilCellIds[1], spaceId) - a_coordinate(child, spaceId);
    nghbrDistance += delta * delta;
  }

  // another interpolation factor
  factor = nghbrDistance / (nghbrDistance + cellDistance);

  // interpolation of the variables:
  // factor * interpolated cell value + ( 1 - factor ) * interpolated neighbor value
  for(MInt varId = 0; varId < noCVars; varId++) {
    a_variable(child, varId) =
        factor * (cellFactor * a_variable(stencilCellIds[0], varId) + (1.0 - cellFactor) * a_variable(cellId, varId))
        + (1.0 - factor)
              * (nghbrFactor * a_variable(stencilCellIds[2], varId)
                 + (1.0 - cellFactor) * a_variable(stencilCellIds[1], varId));
  }
}

template <MInt nDim_, class SysEqn>
MInt FvCartesianSolverXD<nDim_, SysEqn>::setUpBndryInterpolationStencil(const MInt cellId, MInt* interpolationCells,
                                                                        const MFloat* point) {
  TRACE();

  MInt count = 0;
  const MInt stencilSize = IPOW2(nDim);
  if(!a_hasProperty(cellId, SolverCell::IsSplitCell)) {
    // add cellId itself and possible bndry-ghost cell
    interpolationCells[count++] = cellId;
    if(a_isBndryCell(cellId)) {
      interpolationCells[count++] = a_bndryGhostCellId(a_bndryId(cellId), 0);
    }
  } else {
    // for split cell: add closest split-child and its bndry-ghost-cell
    MInt scId = -1;
    for(MInt sc = 0; sc < a_noSplitCells(); sc++) {
      const MInt splitCell = m_splitCells[sc];
      if(splitCell == cellId) {
        scId = sc;
        break;
      }
    }
    // fill distance array
    MFloatScratchSpace dist(a_noSplitChilds(scId), AT_, "neighborDistance");
    for(MInt ssc = 0; ssc < a_noSplitChilds(scId); ssc++) {
      const MInt splitChild = a_splitChildId(scId, ssc);
      IF_CONSTEXPR(nDim == 2) {
        dist(ssc) = sqrt(POW2(point[0] - a_coordinate(splitChild, 0)) + POW2(point[1] - a_coordinate(splitChild, 1)));
      }
      else {
        dist(ssc) = sqrt(POW2(point[0] - a_coordinate(splitChild, 0)) + POW2(point[1] - a_coordinate(splitChild, 1))
                         + POW2(point[2] - a_coordinate(splitChild, 2)));
      }
    }
    // find child with lowest distance
    MInt sscId = -1;
    MInt minDist = 99;
    for(MInt ssc = 0; ssc < a_noSplitChilds(scId); ssc++) {
      if(dist(ssc) < minDist) {
        minDist = dist(ssc);
        sscId = ssc;
      }
    }
    const MInt splitChildId = a_splitChildId(scId, sscId);
    interpolationCells[count++] = splitChildId;
    interpolationCells[count++] = a_bndryGhostCellId(a_bndryId(splitChildId), 0);
  }

#ifndef NDEBUG
  MInt debugId = -1;
  MInt debugDomainId = -1;

  if(cellId == debugId && domainId() == debugDomainId) {
    if(count == 1) {
      cerr << "Cell has only " << interpolationCells[0] << " s" << count << endl;
    } else {
      cerr << "Cell has " << interpolationCells[0] << " and bndry-ghost-cell " << interpolationCells[1] << " s" << count
           << endl;
    }
    cerr << "Cell is " << cellId << " " << c_noCells() << a_hasProperty(cellId, SolverCell::IsSplitCell) << endl;
  }
#endif

  // compute distance to all neighbor cells
  MFloatScratchSpace neighborDistance(m_noDirs, AT_, "neighborDistance");
  for(MInt dir = 0; dir < m_noDirs; dir++) {
    if(!checkNeighborActive(cellId, dir) || !a_hasNeighbor(cellId, dir)) {
      neighborDistance[dir] = 99.9;
    } else {
      IF_CONSTEXPR(nDim == 2) {
        neighborDistance[dir] = sqrt(POW2(point[0] - a_coordinate(c_neighborId(cellId, dir), 0))
                                     + POW2(point[1] - a_coordinate(c_neighborId(cellId, dir), 1)));
      }
      else {
        neighborDistance[dir] = sqrt(POW2(point[0] - a_coordinate(c_neighborId(cellId, dir), 0))
                                     + POW2(point[1] - a_coordinate(c_neighborId(cellId, dir), 1))
                                     + POW2(point[2] - a_coordinate(c_neighborId(cellId, dir), 2)));
      }
    }
  }

#ifndef NDEBUG
  if(cellId == debugId && domainId() == debugDomainId) {
    for(MInt i = 0; i < m_noDirs; i++) {
      const MInt nghbrId = c_neighborId(cellId, i);
      MInt ghostCell = -1;
      if(nghbrId > -1 && a_isBndryCell(nghbrId)) {
        ghostCell = a_bndryGhostCellId(a_bndryId(nghbrId), 0);
      }
      cerr << "distance " << i << " " << neighborDistance[i] << " neighbor " << nghbrId << " neighbor-ghost "
           << ghostCell << " " << a_hasProperty(nghbrId, SolverCell::IsSplitCell) << endl;
    }
  }
#endif

  // use first matching neighbors with lowest distance
  for(MInt i = 0; i < m_noDirs; i++) {
    MInt minId = -1;
    MFloat minDistance = 99;
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      if(neighborDistance[dir] < minDistance) {
        minDistance = neighborDistance[dir];
        minId = dir;
      }
    }
    if(minId > -1) {
      const MInt nghbrId = c_neighborId(cellId, minId);
      interpolationCells[count++] = nghbrId;

#ifndef NDEBUG
      if(cellId == debugId && domainId() == debugDomainId) {
        cerr << "Adding " << interpolationCells[count - 1] << " in dir " << minId << " s" << count << endl;
      }
#endif

      if(count < stencilSize && a_isBndryCell(nghbrId) && a_bndryGhostCellId(a_bndryId(nghbrId), 0) > -1) {
        // NOTE: bndry-ghost cell can be -1 for a bndry split-cell!
        interpolationCells[count++] = a_bndryGhostCellId(a_bndryId(nghbrId), 0);

#ifndef NDEBUG
        if(cellId == debugId && domainId() == debugDomainId) {
          cerr << "Adding ghost-cell" << interpolationCells[count - 1] << " from dir " << minId << " s" << count
               << endl;
        }
#endif
      }
      neighborDistance[minId] = 99;
    }
    if(count == stencilSize) {
      break;
    }
  }

  return count;
}

/**
 * interpolates all variables to child using the stencil support of
 * four cells: cellId, stencilCellIds[ 0 ], stencilCellIds[ 1 ], stencilCellIds[ 2 ]
 *
 * @author Daniel Hartmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::bilinearInterpolation(MInt child, MInt cellId, MInt* stencilCellIds) {
  TRACE();

  MBool a0Computed, a1Computed;
  MInt noCVars = CV->noVariables;
  MFloat rightHandSide1, rightHandSide2;
  MFloat xy, xy0, xy1, xy2, y2y1, xy1xy0, xy2xy0;
  MFloat r0, r1, r2;
  MFloat rhs1, rhs2, lhs2;
  MFloat x1term, x2term, y1term, y2term;
  MFloat ratio;
  MFloat coordinates[4 * nDim];
  MFloat epsilon = c_cellLengthAtLevel(maxRefinementLevel()) / 100.0;
  MFloat parameter[4] = {0, 0, 0, 0};
  //---


  // solve: phi(x,y) = a0*x + a1*y + a2*xy + a3
  a0Computed = false;
  a1Computed = false;

  // shift coordinates such that the coordinates of cellId are (0,0)
  for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
    coordinates[spaceId] = a_coordinate(child, spaceId) - a_coordinate(cellId, spaceId);
    coordinates[nDim + spaceId] = a_coordinate(stencilCellIds[0], spaceId) - a_coordinate(cellId, spaceId);
    coordinates[2 * nDim + spaceId] = a_coordinate(stencilCellIds[1], spaceId) - a_coordinate(cellId, spaceId);
    coordinates[3 * nDim + spaceId] = a_coordinate(stencilCellIds[2], spaceId) - a_coordinate(cellId, spaceId);
  }

  // compute constants
  xy = coordinates[0] * coordinates[1];
  xy0 = coordinates[nDim] * coordinates[nDim + 1];
  xy1 = coordinates[2 * nDim] * coordinates[2 * nDim + 1];
  xy2 = coordinates[3 * nDim] * coordinates[3 * nDim + 1];

  for(MInt varId = 0; varId < noCVars; varId++) {
    // 1.: check if a0 can be easily computed (check 1-coordinate)
    if(fabs(coordinates[nDim + 1]) < epsilon) {
      parameter[0] = (a_variable(stencilCellIds[0], varId) - a_variable(cellId, varId)) / coordinates[nDim];
      a0Computed = true;
    } else {
      if(fabs(coordinates[2 * nDim + 1] - coordinates[3 * nDim + 1]) < epsilon) {
        parameter[0] = (a_variable(stencilCellIds[2], varId) - a_variable(stencilCellIds[1], varId))
                       / (coordinates[3 * nDim] - coordinates[2 * nDim]);
        a0Computed = true;
      }
    }

    // 2.: check if a1 can be easily computed (check 0-coordinate)
    if(fabs(coordinates[2 * nDim]) < epsilon) {
      parameter[1] = (a_variable(stencilCellIds[1], varId) - a_variable(cellId, varId)) / coordinates[2 * nDim + 1];
      a1Computed = true;
    } else {
      if(fabs(coordinates[nDim] - coordinates[3 * nDim]) < epsilon) {
        parameter[1] = (a_variable(stencilCellIds[2], varId) - a_variable(stencilCellIds[0], varId))
                       / (coordinates[3 * nDim + 1] - coordinates[nDim + 1]);
        a1Computed = true;
      }
    }

    // 3. compute a3
    parameter[3] = a_variable(cellId, varId);

    // 4. compute remaining parameters
    if(a0Computed && a1Computed) {
      parameter[2] = (a_variable(stencilCellIds[2], varId) - parameter[3] - parameter[0] * coordinates[3 * nDim]
                      - parameter[1] * coordinates[3 * nDim + 1])
                     / xy2;

    } else {
      if(a0Computed) {
        rightHandSide1 = a_variable(stencilCellIds[1], varId) - parameter[3] - parameter[0] * coordinates[2 * nDim];
        rightHandSide2 = a_variable(stencilCellIds[2], varId) - parameter[3] - parameter[0] * coordinates[3 * nDim];
        ratio = coordinates[3 * nDim + 1] / coordinates[2 * nDim + 1];

        parameter[2] = (rightHandSide2 - ratio * rightHandSide1) / (xy2 - ratio * xy1);
        parameter[1] = (rightHandSide1 - xy1 * parameter[2]) / coordinates[2 * nDim + 1];

      } else {
        if(a1Computed) {
          rightHandSide1 = a_variable(stencilCellIds[0], varId) - parameter[3] - parameter[1] * coordinates[nDim + 1];
          rightHandSide2 =
              a_variable(stencilCellIds[2], varId) - parameter[3] - parameter[1] * coordinates[3 * nDim + 1];
          ratio = coordinates[3 * nDim] / coordinates[nDim];

          parameter[2] = (rightHandSide2 - ratio * rightHandSide1) / (xy2 - ratio * xy0);
          parameter[0] = (rightHandSide1 - xy0 * parameter[2]) / coordinates[nDim];

        } else {
          // Interpolation with skewed stencil
          // The system of equations is solved with parameters in reversed order!!!

          // compute constants
          xy1xy0 = xy1 / xy0;
          xy2xy0 = xy2 / xy0;
          x1term = coordinates[2 * nDim] - xy1xy0 * coordinates[nDim];
          x2term = coordinates[3 * nDim] - xy2xy0 * coordinates[nDim];
          y1term = coordinates[2 * nDim + 1] - xy1xy0 * coordinates[nDim + 1];
          y2term = coordinates[3 * nDim + 1] - xy2xy0 * coordinates[nDim + 1];
          y2y1 = y2term / y1term;

          parameter[3] = a_variable(cellId, varId);
          r0 = a_variable(stencilCellIds[0], varId) - parameter[3];
          r1 = a_variable(stencilCellIds[1], varId) - parameter[3];
          r2 = a_variable(stencilCellIds[2], varId) - parameter[3];

          // compute right and left hand sides
          rhs2 = r2 - xy2xy0 * r0 - y2y1 * (r1 - xy1xy0 * r0);
          rhs1 = r1 - xy1xy0 * r0;
          lhs2 = x2term - y2y1 * (x1term);

          // compute parameters
          parameter[0] = rhs2 / lhs2;
          parameter[1] = (rhs1 - x1term * parameter[0]) / y1term;
          parameter[2] = (r0 - coordinates[nDim] * parameter[0] - coordinates[nDim + 1] * parameter[1]) / xy0;
        }
      }
    }


    // 5. Interpolate
    a_variable(child, varId) =
        parameter[0] * coordinates[0] + parameter[1] * coordinates[1] + parameter[2] * xy + parameter[3];
  }
}


/**
 * interpolates all variables to child using the stencil support of
 * three cells: cellId, stencilCellIds[ 0 ], stencilCellIds[ 1 ]
 *
 * @author Daniel Hartmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::linearInterpolation(MInt child, MInt cellId, MInt* stencilCellIds) {
  TRACE();

  MInt noCVars = CV->noVariables;
  MFloat coordinates[3 * nDim];
  MFloat parameter[3];
  MFloat ratio;

  // shift coordinates such that the coordinates of cellId are (0,0)
  for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
    coordinates[spaceId] = a_coordinate(child, spaceId) - a_coordinate(cellId, spaceId);
    coordinates[nDim + spaceId] = a_coordinate(stencilCellIds[0], spaceId) - a_coordinate(cellId, spaceId);
    coordinates[2 * nDim + spaceId] = a_coordinate(stencilCellIds[1], spaceId) - a_coordinate(cellId, spaceId);
  }

  // interpolate
  for(MInt varId = 0; varId < noCVars; varId++) {
    parameter[2] = a_variable(cellId, varId);

    if(approx(coordinates[2 * nDim], 0.0, MFloatEps)) {
      parameter[1] = (a_variable(stencilCellIds[1], varId) - a_variable(cellId, varId)) / coordinates[2 * nDim + 1];
    } else {
      ratio = coordinates[2 * nDim] / coordinates[nDim];
      parameter[1] = (parameter[2] * (ratio - 1.) + a_variable(stencilCellIds[1], varId)
                      - a_variable(stencilCellIds[0], varId) * ratio)
                     / (coordinates[2 * nDim + 1] - coordinates[nDim + 1] * ratio);
    }

    if(approx(coordinates[nDim + 1], 0.0, MFloatEps)) {
      parameter[0] = (a_variable(stencilCellIds[0], varId) - a_variable(cellId, varId)) / coordinates[nDim];
    } else {
      parameter[0] = (a_variable(stencilCellIds[0], varId) - parameter[2] - parameter[1] * coordinates[nDim + 1])
                     / coordinates[nDim];
    }

    a_variable(child, varId) = parameter[0] * coordinates[0] + parameter[1] * coordinates[1] + parameter[2];
  }
}


/**
 * performs the correction of an existing solution on the fine grid
 *
 * computes the difference between the new coarse grid solution and the
 * stored restricted fine grid solution
 * interpolates this difference to children of the fine grid level
 * increase maximum level of refinement by 1
 *
 * @author Daniel Hartmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeCoarseGridCorrection(MInt NotUsed(level)) {
  TRACE();

  const MInt noCellIds = a_noCells();
  const MInt noCVars = CV->noVariables;
  mTerm(1, "code does not work, see comment below");

  for(MInt cellId = 0; cellId < noCellIds; cellId++) {
    for(MInt varId = 0; varId < noCVars; varId++) {
      if(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        a_variable(cellId, varId) -=
            a_restrictedVar(cellId, varId); // This code does not work since the level information is ignored!
      }
      a_tau(cellId, varId) = 0;
    }
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::copyRHSIntoGhostCells() {
  TRACE();

  m_fvBndryCnd->copyRHSIntoGhostCells();
}


/**
 * \brief identifies bndry cells (Sets a_isInterface for the solver!)
 *
 * hull method for cartesiangrid createBoundaryCells(),
 *
 * @author Claudia Guenther
 * @date 05/2012
 */
// TODO labels:FV use more meaningful name for this function?
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::createBoundaryCells() {
  TRACE();

  this->identifyBoundaryCells();

  ASSERT(c_noCells() == a_noCells() && a_noCells() == grid().tree().size(),
         to_string(c_noCells()) + " " + to_string(a_noCells()) + " " + to_string(grid().tree().size()) + " "
             + to_string(m_cells.size()));

  // reset a_isInterface if the cell IsInactive (negative Ls-value and no active Corners!)
  // and also for nonLeaf-Cells!
  // TODO labels:FV why not always reset isInterface for non-leaf cells
  if(m_levelSetMb && !m_constructGField) {
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      assertValidGridCellId(cellId);
      if(a_isInterface(cellId)) {
        if(c_isLeafCell(cellId) && a_hasProperty(cellId, SolverCell::IsInactive)) {
          a_isInterface(cellId) = false;
        } else if(!c_isLeafCell(cellId)) {
          a_isInterface(cellId) = false;
        }
      }
    }
  }
}

/**
 * computes the interpolation constants for the viscous flux computation
 *
 * @author Daniel Hartmann, November 17, 2006
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initViscousFluxComputation() {
  TRACE();

  const MInt noSrfcs = a_noSurfaces();
  MInt nghbrCells[2];
  MFloat eps = F1 / FPOW10[10];
  MFloat totalDistance, distance;
  MFloat factor0, factor1;
  //---


  // 1) compute the factors 0 and 1 for all surfaces
  for(MInt srfcId = 0; srfcId < noSrfcs; srfcId++) {
    nghbrCells[0] = a_surfaceNghbrCellId(srfcId, 0);
    nghbrCells[1] = a_surfaceNghbrCellId(srfcId, 1);
    distance = F0;
    totalDistance = F0;
    for(MInt i = 0; i < nDim; i++) {
      distance += POW2(a_surfaceCoordinate(srfcId, i) - a_coordinate(nghbrCells[0], i));
      totalDistance += POW2(a_surfaceCoordinate(srfcId, i) - a_coordinate(nghbrCells[1], i));
    }
    distance = sqrt(distance);
    totalDistance = sqrt(totalDistance) + distance;
    factor1 = distance / mMax(eps, totalDistance);
    factor0 = F1 - factor1;
    a_surfaceFactor(srfcId, 0) = factor0;
    a_surfaceFactor(srfcId, 1) = factor1;
  }

  if(!m_fvBndryCnd->m_cellMerging) {
#ifdef _OPENMP
#pragma omp parallel for
#endif
    for(MInt bs = 0; bs < m_fvBndryCnd->m_noBoundarySurfaces; bs++) {
      MInt srfcId = m_fvBndryCnd->m_boundarySurfaces[bs];
      a_surfaceFactor(srfcId, 0) = F1B2;
      a_surfaceFactor(srfcId, 1) = F1B2;
    }
  }
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::refineCell(const MInt gridCellId) {
  static constexpr MFloat signStencil[8][3] = {{-F1, -F1, -F1}, {F1, -F1, -F1}, {-F1, F1, -F1}, {F1, F1, -F1},
                                               {-F1, -F1, F1},  {F1, -F1, F1},  {-F1, F1, F1},  {F1, F1, F1}};

  if(!g_multiSolverGrid) ASSERT(grid().raw().a_hasProperty(gridCellId, Cell::WasRefined), "");

  const MInt noCVars = CV->noVariables;
  const MInt noFVars = FV->noVariables;
  const MInt noPVars = PV->noVariables;
  const MInt childLevel = grid().raw().a_level(gridCellId) + 1;
  const MFloat childCellLength = c_cellLengthAtLevel(childLevel);
  const MFloat childVolume = grid().cellVolumeAtLevel(childLevel);

  const MInt solverCellId = grid().tree().grid2solver(gridCellId);

  const MFloat* const pvarsCell = ALIGNED_F(&a_pvariable(solverCellId, 0));
  const MFloat* const cvarsCell = ALIGNED_F(&a_variable(solverCellId, 0));
  const MFloat* const avarsCell = ALIGNED_F(&a_avariable(solverCellId, 0));
  const MFloat* const slopesCell = ALIGNED_F(&a_slope(solverCellId, 0, 0));

  if(!g_multiSolverGrid) ASSERT(solverCellId == gridCellId, "");
  if(solverCellId < 0) return;

  MInt noAddedChilds = 0;

  for(MInt c = 0; c < grid().m_maxNoChilds; c++) {
    const MInt gridChildId = grid().raw().a_childId(gridCellId, c);

    if(gridChildId < 0) continue;
    // not necessarily all childs will be used, some have not been added to the grid-tree

    if(grid().azimuthalPeriodicity()) {
      // Solver flag will be set in proxy
      // The cartesianGrid does not know the geometry, therefore it needs to be checked
      // that the child actually is inside the geometry
      if(grid().checkOutsideGeometry(gridChildId) == 1) {
        grid().raw().setSolver(gridChildId, solverId(), false);
        continue;
      }
    }

    // solverFlag is set in CartesianGrid<nDim>::setChildSolverFlag
    // solverFlag is false if the specific child lies outside the solver geoemtry
    if(!grid().solverFlag(gridChildId, solverId())) continue;

    // Skip if cell is a partition level ancestor and its child was not newly created
    if(!grid().raw().a_hasProperty(gridChildId, Cell::WasNewlyCreated)
       && grid().raw().a_hasProperty(gridCellId, Cell::IsPartLvlAncestor)) {
      continue;
    }

    MInt solverChildId = this->createCellId(gridChildId);
    noAddedChilds++;

    ASSERT(grid().tree().solver2grid(solverChildId) == gridChildId, "  ");
    if(!g_multiSolverGrid) ASSERT(solverChildId == gridChildId, "");

    std::vector<std::vector<MFloat>> dQ(PV->noVariables, std::vector<MFloat>(nDim));
    MFloat U2 = F0;
    for(MInt i = 0; i < nDim; i++) {
      U2 += POW2(a_pvariable(solverCellId, PV->VV[i]));
    }

    dQ = sysEqn().conservativeSlopes(pvarsCell, cvarsCell, avarsCell, slopesCell);

    for(MInt v = 0; v < noCVars; v++) {
      for(MInt i = 0; i < nDim; i++) {
        dQ[v][i] *= F1B2 * childCellLength;
        if(std::isnan(dQ[v][i])) {
          dQ[v][i] = 0.0;
        }
      }
    }
    for(MInt v = 0; v < noCVars; v++) {
      a_variable(solverChildId, v) = a_variable(solverCellId, v);
      if(globalTimeStep > 0) {
        for(MInt i = 0; i < nDim; i++) {
          ASSERT(!std::isnan(dQ[v][i]), "");
          a_variable(solverChildId, v) += signStencil[c][i] * dQ[v][i];
        }
      }
    }

    IF_CONSTEXPR(isDetChem<SysEqn>) {
      for(MUint v = 0; v < PV->m_noSpecies; v++) {
        a_speciesReactionRate(solverChildId, v) = a_speciesReactionRate(solverCellId, v);
      }
    }
    else {
      // ensure mass-conservancy for species:
      for(MInt s = 0; s < m_noSpecies; s++) {
        a_variable(solverChildId, CV->RHO_Y[s]) = a_variable(solverCellId, CV->RHO_Y[s]);
      }
    }

    for(MInt v = 0; v < noCVars; v++) {
      a_oldVariable(solverChildId, v) = a_variable(solverChildId, v);
    }
    for(MInt v = 0; v < noFVars; v++) {
      a_rightHandSide(solverChildId, v) = FFPOW2(nDim) * a_rightHandSide(solverCellId, v);
    }
    for(MInt v = 0; v < noPVars; v++) {
      for(MInt i = 0; i < nDim; i++) {
        a_slope(solverChildId, v, i) = a_slope(solverCellId, v, i);
      }
    }

    // STG adaptation
    IF_CONSTEXPR(SysEqn::m_noRansEquations == 0) {
      if(m_zonal) {
        vector<MInt>::iterator findAverageId = find(m_LESAverageCells.begin(), m_LESAverageCells.end(), solverCellId);
        vector<MInt>::iterator findAverageChildId =
            find(m_LESAverageCells.begin(), m_LESAverageCells.end(), solverChildId);

        if(findAverageId != m_LESAverageCells.end() && !a_isHalo(solverChildId)) {
          if(findAverageChildId == m_LESAverageCells.end() && !a_isHalo(solverChildId)) {
            MInt LESAvgId = distance(m_LESAverageCells.begin(), findAverageId);
            for(MInt v = 0; v < m_LESNoVarAverage; v++) {
              m_LESVarAverage[v].push_back(m_LESVarAverage[v][LESAvgId]);
            }
            m_LESAverageCells.push_back(solverChildId);
          }
        }
      }
    }

    setPrimitiveVariables(solverChildId);

    a_bndryId(solverChildId) = -1;

    a_cellVolume(solverChildId) = childVolume;
    a_FcellVolume(solverChildId) = F1 / childVolume;

    a_noReconstructionNeighbors(solverChildId) = 0;
    for(MInt k = 0; k < m_cells.noRecNghbrs(); k++) {
      a_reconstructionNeighborId(solverChildId, k) = -1;
    }

    // check-child-values
#if defined _MB_DEBUG_ || !defined NDEBUG
    for(MInt v = 0; v < noPVars; v++) {
      if(std::isnan(a_pvariable(solverChildId, v)) && a_hasProperty(solverCellId, SolverCell::IsOnCurrentMGLevel)
         && !a_isHalo(solverCellId)) {
        cerr << "Invalid-value in refined-Cell! "
             << " " << solverChildId << " " << endl;
      }
    }
    if(a_hasProperty(solverCellId, SolverCell::IsOnCurrentMGLevel) && !a_isHalo(solverCellId)
       && a_variable(solverChildId, CV->RHO) < m_eps) {
      cerr << "rho is zero or negative-2!" << endl;
    }
#endif

    // necessary for diagonal bndryRefinement!
    // TODO labels:FV check why this changes the 2D_cylinder_adaptive-loadbalance_highPartitionLevelShift
    //      testcase!
    if(m_levelSetMb) {
      a_hasProperty(solverChildId, SolverCell::IsOnCurrentMGLevel) =
          a_hasProperty(solverCellId, SolverCell::IsOnCurrentMGLevel);
      a_hasProperty(solverChildId, SolverCell::IsInactive) = a_hasProperty(solverCellId, SolverCell::IsInactive);
    }
  }
  a_noReconstructionNeighbors(solverCellId) = 0;
  for(MInt k = 0; k < m_cells.noRecNghbrs(); k++) {
    a_reconstructionNeighborId(solverCellId, k) = -1;
  }

  if(m_sensorParticle && !a_isHalo(solverCellId) && noAddedChilds > 0) {
    const MInt noParticles = a_noPart(solverCellId);

    MInt noParticlesEach = noParticles / noAddedChilds;
    MInt lastChild = -1;
    for(MInt child = 0; child < grid().m_maxNoChilds; child++) {
      const MInt childId = c_childId(solverCellId, child);
      if(childId < 0) continue;
      a_noPart(childId) = noParticles > 0 ? noParticlesEach : 0;
      lastChild = child;
    }
    MInt remainingParticles = noParticles - ((c_noChildren(solverCellId) - 1) * noParticlesEach);
    if(lastChild > -1) {
      a_noPart(c_childId(solverCellId, lastChild)) = noParticles > 0 ? remainingParticles : 0;
    }

    if(noAddedChilds > 0) {
      a_noPart(solverCellId) = 0;
    }
  }

  if(noAddedChilds > 0) {
    a_hasProperty(solverCellId, SolverCell::IsOnCurrentMGLevel) = false;
  }
}


// --------------------------------------------------------------------------------------

/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::removeChilds(const MInt gridCellId) {
  const MInt solverCellId = grid().tree().grid2solver(gridCellId);

  ASSERT(solverCellId > -1 && solverCellId < m_cells.size(), "");
  ASSERT(c_noChildren(solverCellId) > 0, "");

  if(!g_multiSolverGrid) ASSERT(solverCellId == gridCellId, "");
  if(!g_multiSolverGrid) ASSERT(m_cells.size() == grid().raw().treeb().size(), "");

  // reset the solverCell-properties for the new leaf-cell:
  //- volume
  //- variables
  //- oldVariables only if not already updated in fvmb-version!
  //- slope
  //- rightHandSide
  const MInt noCVars = CV->noVariables;
  const MInt noFVars = FV->noVariables;
  const MInt noPVars = PV->noVariables;
  a_cellVolume(solverCellId) = F0;

  for(MInt v = 0; v < noCVars; v++) {
    a_variable(solverCellId, v) = F0;
    if(!m_levelSetMb) {
      a_oldVariable(solverCellId, v) = F0;
    }
    for(MInt i = 0; i < nDim; i++) {
      a_slope(solverCellId, v, i) = F0;
    }
  }
  for(MInt v = 0; v < noFVars; v++) {
    a_rightHandSide(solverCellId, v) = F0;
  }

  MInt isInactive = 0;
  MInt noRemovedChilds = 0;
  MInt noParticles = 0;

  for(MInt c = 0; c < grid().m_maxNoChilds; c++) {
    const MInt gridChildId = grid().raw().a_childId(gridCellId, c);
    const MInt childId = c_childId(solverCellId, c);

    if(childId < 0) continue;
    noRemovedChilds++;
    if(m_sensorParticle) noParticles += a_noPart(childId);

    ASSERT(grid().tree().solver2grid(childId) == gridChildId, "");

    // only use active childs for interpolation!
    if(!a_hasProperty(childId, SolverCell::IsInactive)) {
      const MFloat vol = a_cellVolume(childId);
      a_cellVolume(solverCellId) += vol;
      for(MInt v = 0; v < noCVars; v++) {
        a_variable(solverCellId, v) += vol * a_variable(childId, v);
        if(!m_levelSetMb) {
          a_oldVariable(solverCellId, v) += vol * a_oldVariable(childId, v);
        }
      }
      for(MInt v = 0; v < noFVars; v++) {
        a_rightHandSide(solverCellId, v) += a_rightHandSide(childId, v);
      }
      for(MInt v = 0; v < noPVars; v++) {
        for(MInt j = 0; j < nDim; j++) {
          a_slope(solverCellId, v, j) += vol * a_slope(childId, v, j);
        }
      }

      // STG adaptation
      IF_CONSTEXPR(SysEqn::m_noRansEquations == 0) {
        if(m_zonal) {
          vector<MInt>::iterator findAverageChildId =
              find(m_LESAverageCells.begin(), m_LESAverageCells.end(), solverCellId);
          if(findAverageChildId != m_LESAverageCells.end()) {
            MInt LESChildId = distance(m_LESAverageCells.begin(), findAverageChildId);
            for(MInt v = 0; v < m_LESNoVarAverage; v++) {
              m_LESVarAverage[v].erase(m_LESVarAverage[v].begin() + LESChildId);
            }
            m_LESAverageCells.erase(m_LESAverageCells.begin() + LESChildId);
            // m_noLESAverageCells--;
          }
        }
      }

    } else {
      isInactive++;
    }

    a_bndryId(childId) = -1;
    this->removeCellId(childId);
  }

  if(m_sensorParticle) a_noPart(solverCellId) = noParticles;

  // update variables and properties for the new leaf-cell:
  if(isInactive == noRemovedChilds) {
    // if of all childs are inactive, default variables are set!
    a_hasProperty(solverCellId, SolverCell::IsInactive) = true;
    a_hasProperty(solverCellId, SolverCell::IsOnCurrentMGLevel) = false;
    a_cellVolume(solverCellId) = c_cellVolumeAtLevel(a_level(solverCellId));

    a_variable(solverCellId, CV->RHO) = m_rhoInfinity;
    IF_CONSTEXPR(hasE<SysEqn>)
    a_variable(solverCellId, CV->RHO_E) = m_rhoEInfinity;
    for(MInt dir = 0; dir < nDim; dir++) {
      a_variable(solverCellId, CV->RHO_VV[dir]) = m_rhoVVInfinity[dir];
    }
  } else {
    if(!a_isHalo(solverCellId)) {
      ASSERT(a_variable(solverCellId, CV->RHO) > 0, "Zero density when removing childs!");
    }
    for(MInt v = 0; v < noCVars; v++) {
      a_variable(solverCellId, v) /= mMax(m_volumeThreshold, a_cellVolume(solverCellId));
      if(!m_levelSetMb) {
        a_oldVariable(solverCellId, v) /= mMax(m_volumeThreshold, a_cellVolume(solverCellId));
      }
    }
    for(MInt v = 0; v < noPVars; v++) {
      for(MInt i = 0; i < nDim; i++) {
        a_slope(solverCellId, v, i) /= mMax(m_volumeThreshold, a_cellVolume(solverCellId));
      }
    }
    a_hasProperty(solverCellId, SolverCell::IsOnCurrentMGLevel) = true;
    a_hasProperty(solverCellId, SolverCell::IsInactive) = false;
  }

  a_FcellVolume(solverCellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(solverCellId));
  setPrimitiveVariables(solverCellId);

  // only single-solver!
  if(!g_multiSolverGrid) ASSERT((m_cells.size() - grid().raw().treeb().size()) <= grid().m_maxNoChilds, "");
}


/**
 * \brief
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::removeCell(const MInt gridCellId) {
  const MInt solverCellId = grid().tree().grid2solver(gridCellId);

  ASSERT(gridCellId > -1 && gridCellId < grid().raw().treeb().size() && solverCellId > -1
             && solverCellId < m_cells.size() && grid().tree().solver2grid(solverCellId) == gridCellId,
         "");
  ASSERT(c_noChildren(solverCellId) == 0, "");

  this->removeCellId(solverCellId);
}

// --------------------------------------------------------------------------------------

/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::swapCells(const MInt cellId0, const MInt cellId1) {
  if(cellId1 == cellId0) return;

  const MInt noCVars = CV->noVariables;
  const MInt noFVars = FV->noVariables;
  const MInt noPVars = PV->noVariables;
  const MInt noAVars = AV->noVariables;
  for(MInt v = 0; v < noCVars; v++) {
    std::swap(a_variable(cellId1, v), a_variable(cellId0, v));
    std::swap(a_oldVariable(cellId1, v), a_oldVariable(cellId0, v));
    if(m_dualTimeStepping) {
      std::swap(a_dt1Variable(cellId1, v), a_dt1Variable(cellId0, v));
      std::swap(a_dt2Variable(cellId1, v), a_dt2Variable(cellId0, v));
    }
  }
  for(MInt v = 0; v < noFVars; v++) {
    std::swap(a_rightHandSide(cellId1, v), a_rightHandSide(cellId0, v));
  }
  for(MInt v = 0; v < noPVars; v++) {
    std::swap(a_pvariable(cellId1, v), a_pvariable(cellId0, v));
    for(MInt i = 0; i < nDim; i++) {
      std::swap(a_slope(cellId1, v, i), a_slope(cellId0, v, i));
    }
  }

  if(hasAV) {
    for(MInt v = 0; v < noAVars; v++) {
      std::swap(a_avariable(cellId1, v), a_avariable(cellId0, v));
    }
  }

  std::swap(a_cellVolume(cellId1), a_cellVolume(cellId0));
  std::swap(a_FcellVolume(cellId1), a_FcellVolume(cellId0));

  IF_CONSTEXPR(SysEqn::m_noRansEquations == 0) {
    if(m_zonal) {
      vector<MInt>::iterator findId0 = find(m_LESAverageCells.begin(), m_LESAverageCells.end(), cellId0);
      vector<MInt>::iterator findId1 = find(m_LESAverageCells.begin(), m_LESAverageCells.end(), cellId1);

      if(findId0 != m_LESAverageCells.end() && findId1 != m_LESAverageCells.end()) {
        MInt LESId0 = distance(m_LESAverageCells.begin(), findId0);
        MInt LESId1 = distance(m_LESAverageCells.begin(), findId1);
        for(MInt v = 0; v < m_LESNoVarAverage; v++) {
          std::swap(m_LESVarAverage[v][LESId0], m_LESVarAverage[v][LESId1]);
        }
        std::swap(m_LESAverageCells[LESId0], m_LESAverageCells[LESId1]);
      } else if(findId0 != m_LESAverageCells.end() && findId1 == m_LESAverageCells.end()) {
        MInt LESId0 = distance(m_LESAverageCells.begin(), findId0);
        m_LESAverageCells[LESId0] = cellId1;
      } else if(findId0 == m_LESAverageCells.end() && findId1 != m_LESAverageCells.end()) {
        MInt LESId1 = distance(m_LESAverageCells.begin(), findId1);
        m_LESAverageCells[LESId1] = cellId0;
      }
    }
  }

  std::swap(a_spongeFactor(cellId1), a_spongeFactor(cellId0));
  std::swap(a_spongeBndryId(cellId1, 0), a_spongeBndryId(cellId0, 0));
  std::swap(a_spongeBndryId(cellId1, 1), a_spongeBndryId(cellId0, 1));
  IF_CONSTEXPR(nDim == 3) { std::swap(a_spongeBndryId(cellId1, 2), a_spongeBndryId(cellId0, 2)); }

  const MInt bndryId0 = a_bndryId(cellId0);
  const MInt bndryId1 = a_bndryId(cellId1);
  if(bndryId0 > -1) {
    ASSERT(m_fvBndryCnd->m_bndryCells->a[bndryId0].m_cellId == cellId0, "bndryId not expected");
    m_fvBndryCnd->m_bndryCells->a[bndryId0].m_cellId = cellId1;
  }
  if(bndryId1 > -1) {
    ASSERT(m_fvBndryCnd->m_bndryCells->a[bndryId1].m_cellId == cellId1, "bndryId not expected");
    m_fvBndryCnd->m_bndryCells->a[bndryId1].m_cellId = cellId0;
  }
  std::swap(a_bndryId(cellId1), a_bndryId(cellId0));

  std::swap(m_cells.properties(cellId1), m_cells.properties(cellId0));

  if(m_sensorParticle) {
    std::swap(a_noPart(cellId1), a_noPart(cellId0));
  }
}


// --------------------------------------------------------------------------------------

/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::swapProxy(const MInt cellId0, const MInt cellId1) {
  grid().swapGridIds(cellId0, cellId1);
}


// --------------------------------------------------------------------------------------


// this function should be moved to Solver as soon as cartesiansolver.h has been removed!!!
// this function should be moved to Solver as soon as cartesiansolver.h has been removed!!
// this function should be moved to Solver as soon as cartesiansolver.h has been removed!!!
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::resizeGridMap() {
  grid().resizeGridMap(m_cells.size());
}


// --------------------------------------------------------------------------------------

/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
MBool FvCartesianSolverXD<nDim_, SysEqn>::cellOutside(const MInt cellId) {
  return m_fvBndryCnd->checkOutside(cellId);
}


// --------------------------------------------------------------------------------------

/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
MInt FvCartesianSolverXD<nDim_, SysEqn>::cellOutside(const MFloat* coords, const MInt level, const MInt gridCellId) {
  if(m_engineSetup) {
    return -1;
  }

  MInt solverCellId = grid().tree().grid2solver(gridCellId);
  if(!grid().raw().m_allowInterfaceRefinement) return 0;
  if(!a_isInterface(solverCellId)) return 0;
  return m_fvBndryCnd->checkOutside(coords, level);
}


// --------------------------------------------------------------------------------------

/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::resetSurfaces() {
  m_surfaces.clear(); // invalidate all elements and set size to 0
  m_fvBndryCnd->m_noBoundarySurfaces = 0;
  std::set<MInt>().swap(m_splitSurfaces);
}


// --------------------------------------------------------------------------------------
/**
 * \brief
 * \author Lennart Schneiders
 */
// FIXME labels:FV; optimization with gnu 7.2 -O3 causes bugs in this function
template <MInt nDim_, class SysEqn>
ATTRIBUTES1(ATTRIBUTE_NO_AUTOVEC)
void FvCartesianSolverXD<nDim_, SysEqn>::resetBoundaryCells(const MInt offset) {
  const MInt noPVars = PV->noVariables;

  if(m_fvBndryCnd->m_cellCoordinatesCorrected) {
    m_fvBndryCnd->recorrectCellCoordinates();
  }

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt bndryId = 0; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId = -1;
      for(MInt i = 0; i < nDim; i++) {
        m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_srfcId[i] = -1;
      }
    }
  }

  m_bndryGhostCellsOffset = c_noCells();

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt c = m_bndryGhostCellsOffset; c < a_noCells(); c++) {
    a_bndryId(c) = -1;
    a_isBndryGhostCell(c) = false;
    a_resetPropertiesSolver(c);
  }


#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt c = 0; c < a_noCells(); c++) {
    a_hasProperty(c, SolverCell::IsInvalid) = false;
    a_hasProperty(c, SolverCell::IsSplitCell) = false;
    a_hasProperty(c, SolverCell::IsSplitChild) = false;
    a_hasProperty(c, SolverCell::HasSplitFace) = false;
    a_hasProperty(c, SolverCell::IsTempLinked) = false;
    a_hasProperty(c, SolverCell::IsMovingBnd) = false;
  }

  // resize fvCellCollector to m_bndryGhostCellsOffset
  m_cells.size(m_bndryGhostCellsOffset);
  ASSERT(m_cells.size() == c_noCells(), "");


  // delete previous moving boundary cells
  for(MInt bndryId = m_fvBndryCnd->m_bndryCells->size() - 1; bndryId >= offset; bndryId--) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;

    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      MInt ghostCellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
      if(ghostCellId > -1) {
        ASSERT(a_bndryId(ghostCellId) == -2, "");
        a_bndryId(ghostCellId) = -1;
      }
      m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId = -1;
    }

    a_bndryId(cellId) = -1;

    MInt size = m_fvBndryCnd->m_bndryCells->size();
    m_fvBndryCnd->m_bndryCells->resetSize(size - 1);

    // since the resizing of the cell container above creates invalid cellId we need to make sure only valid cells are
    // reset in fvcellcollector
    if(cellId < m_bndryGhostCellsOffset) {
      a_noReconstructionNeighbors(cellId) = 0;
    }
    m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.resize(0);
    m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst.resize(0);
    std::vector<MFloat>().swap(m_fvBndryCnd->m_bndryCell[bndryId].m_faceVertices);
    for(MUint i = 0; i < m_fvBndryCnd->m_bndryCell[bndryId].m_faceStream.size(); i++) {
      m_fvBndryCnd->m_bndryCell[bndryId].m_faceStream[i].resize(0);
    }
    m_fvBndryCnd->m_bndryCell[bndryId].m_faceStream.resize(0);
    for(MInt srfc = 0; srfc < FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces; srfc++) {
      m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_noCutPoints = 0;
      m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst.resize(0);
      // FIXME labels:FV,totest
      // This is the loop that is optimized and causes a segmentation fault
      for(MInt v = 0; v < noPVars; v++) {
        m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[v] = BC_UNSET;
      }
    }
    m_bndryCells->a[bndryId].m_noSrfcs = 0;

    if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId > -1) {
      MInt pm = m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId;
      a_cellVolume(pm) = grid().cellVolumeAtLevel(a_level(pm));
      a_FcellVolume(pm) = F1 / mMax(m_volumeThreshold, a_cellVolume(pm));
      m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId = -1;
    }

    m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId = -1;
  }


  std::vector<MInt>().swap(m_splitCells);
  std::vector<std::vector<MInt>>().swap(m_splitChilds);
  std::map<MInt, MInt>().swap(m_splitChildToSplitCell);
  std::vector<MInt>().swap(m_associatedInternalCells);

  m_totalnosplitchilds = 0;
  m_totalnoghostcells = 0;
  // These are properly deleted in resetCutOff and allocateCutOffMemory in fvCartesianBndryCndxd.cpp
  // This clear results in memory leaks!
  // m_fvBndryCnd->m_sortedCutOffCells.clear();
}


// --------------------------------------------------------------------------------------

/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::updateMultiSolverInformation(MBool fullReset) {
  if(noNeighborDomains() == 0) {
    if(noDomains() > 1) {
      mTerm(1, "Unexpected situation in updateMultiSolverInformation!");
    }
    return;
  }


  if(fullReset) {
    if(!m_fvBndryCnd->m_cellMerging) {
      mDeallocate(m_fvBndryCnd->m_nearBoundaryWindowCells);
      mDeallocate(m_fvBndryCnd->m_nearBoundaryHaloCells);
      mAlloc(m_fvBndryCnd->m_nearBoundaryWindowCells, noNeighborDomains(), "m_nearBoundaryWindowCells", AT_);
      mAlloc(m_fvBndryCnd->m_nearBoundaryHaloCells, noNeighborDomains(), "m_nearBoundaryHaloCells", AT_);
    }
    mDeallocate(m_mpi_request);
    mAlloc(m_mpi_request, noNeighborDomains(), "m_mpi_request", AT_);
    if(m_nonBlockingComm) {
      mDeallocate(m_mpi_receiveRequest);
      mDeallocate(m_mpi_sendRequest);
      mAlloc(m_mpi_receiveRequest, noNeighborDomains(), "m_mpi_receiveRequest ", MPI_REQ_NULL, AT_);
      mAlloc(m_mpi_sendRequest, noNeighborDomains(), "m_mpi_sendRequest", MPI_REQ_NULL, AT_);
    }
  }


  ScratchSpace<MInt> haloCellsCnt(noNeighborDomains(), AT_, "noHaloCells");
  ScratchSpace<MInt> windowCellsCnt(noNeighborDomains(), AT_, "noWindowCells");
  for(MInt d = 0; d < noNeighborDomains(); d++) {
    haloCellsCnt[d] = noHaloCells(d);
    windowCellsCnt[d] = noWindowCells(d);
  }
  mDeallocate(m_maxLevelHaloCells);
  mDeallocate(m_maxLevelWindowCells);
  mDeallocate(m_noMaxLevelHaloCells);
  mDeallocate(m_noMaxLevelWindowCells);
  mAlloc(m_maxLevelHaloCells, noNeighborDomains(), &haloCellsCnt[0], "m_maxLevelHaloCells", AT_);
  mAlloc(m_maxLevelWindowCells, noNeighborDomains(), &windowCellsCnt[0], "m_maxLevelWindowCells", AT_);
  mAlloc(m_noMaxLevelHaloCells, noNeighborDomains(), "m_noMaxLevelHaloCells", 0, AT_);
  mAlloc(m_noMaxLevelWindowCells, noNeighborDomains(), "m_noMaxLevelWindowCells", 0, AT_);

  mDeallocate(m_sendBuffers);
  mDeallocate(m_receiveBuffers);
  mAlloc(m_sendBuffers, noNeighborDomains(), &windowCellsCnt[0], m_dataBlockSize, "m_sendBuffers", AT_);
  mAlloc(m_receiveBuffers, noNeighborDomains(), &haloCellsCnt[0], m_dataBlockSize, "m_receiveBuffers", AT_);

  if(m_nonBlockingComm) {
    mDeallocate(m_sendBuffersNoBlocking);
    mDeallocate(m_receiveBuffersNoBlocking);
    mAlloc(m_sendBuffersNoBlocking, noNeighborDomains(), &windowCellsCnt[0], m_dataBlockSize, "m_sendBuffersNoBlocking",
           AT_);
    mAlloc(m_receiveBuffersNoBlocking, noNeighborDomains(), &haloCellsCnt[0], m_dataBlockSize,
           "m_receiveBuffersNoBlocking", AT_);
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      m_mpi_receiveRequest[i] = MPI_REQUEST_NULL;
      m_mpi_sendRequest[i] = MPI_REQUEST_NULL;
    }
  }
}

/** \page sensorsFV
 *
 *  \section interface Interface
 *
 *  This sensors is calculated using the distance to moving or static boundaries.<br>
 *  Property: <code>INTERFACE</code>
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::sensorInterface(std::vector<std::vector<MFloat>>& sensors,
                                                         std::vector<std::bitset<64>>& sensorCellFlag,
                                                         std::vector<MFloat>& sensorWeight, MInt sensorOffset,
                                                         MInt sen) {
  // Setting function pointer for sensorInterface

  if(m_levelSet && !m_levelSetMb && !m_combustion) {
    sensorInterfaceLs(sensors, sensorCellFlag, sensorWeight, sensorOffset, sen);
  } else if(m_levelSetMb && !m_constructGField && m_levelSetAdaptationScheme == 2) {
    sensorInterfaceLsMb(sensors, sensorCellFlag, sensorWeight, sensorOffset, sen);
  } else {
    sensorInterfaceDelta(sensors, sensorCellFlag, sensorWeight, sensorOffset, sen);
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::sensorInterfaceLsMb(std::vector<std::vector<MFloat>>& sensors,
                                                             std::vector<std::bitset<64>>& sensorCellFlag,
                                                             std::vector<MFloat>& sensorWeight, MInt sensorOffset,
                                                             MInt sen) {
  m_log << "   - Sensor preparation for the interface sensor" << endl;
  ScratchSpace<MFloat> distance(a_noCells(), AT_, "distance");
  getBoundaryDistance(distance);

  MIntScratchSpace inList(a_noCells(), AT_, "inList");

  // cast floating array in MInt-array!
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    inList(cellId) = 0;
    if(a_level(cellId) < this->m_maxSensorRefinementLevel[sen]) {
      inList(cellId) = (MInt)distance(cellId);
    }
  }

  for(MInt level = minLevel(); level < this->m_maxSensorRefinementLevel[sen]; level++) {
    this->markSurrndCells(inList, m_bandWidth[level], level, m_refineDiagonals);
  }

  // unset sensor for cells ouside the liner geometry
  if(m_engineSetup) {
    const MInt linerSet = 1;
    for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
      if(inList(cellId) == 0) continue;
      if(a_level(cellId) == minLevel()) continue;
      if(c_noChildren(cellId) > 0) continue;
      if(a_levelSetValuesMb(cellId, linerSet) < -(m_maxLsValue - m_eps)) {
        inList(cellId) = 0;
        // MInt parentId = c_parentId( cellId );
        // while ( parentId > -1 && parentId < a_noCells()) {
        //  inList(cellId) = 0;
        //  parentId = c_parentId( parentId );
        //}
      }
    }
  }


#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    ASSERT(!a_isBndryGhostCell(cellId), "");
    ASSERT(!a_isHalo(cellId), "");
    ASSERT(!c_isToDelete(cellId), "");
    if(inList(cellId) == 0) {
      if(a_level(cellId) == minLevel()) continue;
      if(inList(c_parentId(cellId))) continue;
      if(!c_isLeafCell(cellId)) continue;
      const MInt gridCellId = grid().tree().solver2grid(cellId);
      sensors[sensorOffset + sen][gridCellId] = -1.0;
      sensorCellFlag[gridCellId][sensorOffset + sen] = true;
    } else {
      MInt lvl = this->m_maxSensorRefinementLevel[sen] - 1;
      if(m_linerLvlJump && a_coordinate(cellId, 0) > -0.515 && a_coordinate(cellId, 0) < 0.515) {
        lvl = this->m_maxSensorRefinementLevel[sen];
      }
      const MInt sensorLvl = m_linerLvlJump ? lvl : this->m_maxSensorRefinementLevel[sen];
      if(a_level(cellId) < sensorLvl) {
        // if(c_noChildren(cellId) > 0) continue;
        const MInt gridCellId = grid().tree().solver2grid(cellId);
        sensors[sensorOffset + sen][gridCellId] = 1.0;
        sensorCellFlag[gridCellId][sensorOffset + sen] = true;

        MInt parent = c_parentId(cellId);
        if(parent > -1 && parent < c_noCells()) {
          MInt parentGridCellId = grid().tree().solver2grid(parent);
          if(parentGridCellId > -1 && parentGridCellId < grid().raw().m_noInternalCells) {
            sensors[sensorOffset + sen][parentGridCellId] = 1.0;
            sensorCellFlag[parentGridCellId][sensorOffset + sen] = true;
          }
        }
      }
    }
  }

  sensorWeight[sensorOffset + sen] = this->m_sensorWeight[sen];
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::sensorInterfaceDelta(std::vector<std::vector<MFloat>>& sensors,
                                                              std::vector<std::bitset<64>>& sensorCellFlag,
                                                              std::vector<MFloat>& sensorWeight, MInt sensorOffset,
                                                              MInt sen) {
  m_log << "   - Sensor preparation for the interface sensor" << endl;

  ScratchSpace<MFloat> distance(a_noCells(), AT_, "distance");
  distance.fill(MFloatNaN); // fill with NaN to find errors

  getBoundaryDistance(distance);

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    ASSERT(!a_isBndryGhostCell(cellId), "");
    ASSERT(!a_isHalo(cellId), "");
    ASSERT(!c_isToDelete(cellId), "");
    const MInt gridId = this->grid().tree().solver2grid(cellId);
    const MInt level = a_level(cellId);
    MFloat delta = F0;
    if(level < maxRefinementLevel()) {
      delta = mMin(m_outerBandWidth[level] - distance[cellId], distance[cellId] - m_innerBandWidth[level]);
      sensors[sensorOffset + sen][gridId] = delta;
      sensorCellFlag[gridId][sensorOffset + sen] = true;
    }
  }

  sensorWeight[sensorOffset + sen] = this->m_sensorWeight[sen];
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::sensorInterfaceLs(std::vector<std::vector<MFloat>>& sensors,
                                                           std::vector<std::bitset<64>>& sensorCellFlag,
                                                           std::vector<MFloat>& sensorWeight, MInt sensorOffset,
                                                           MInt sen) {
  m_log << "   - Sensor preparation for the interface sensor" << endl;

  MIntScratchSpace inList(a_noCells(), AT_, "inList");

  ScratchSpace<MFloat> distance(a_noCells(), AT_, "distance");
  getBoundaryDistance(distance);

#ifdef _OPENMP
#pragma omp parallel for
#endif
  // cast floating array in int-array!
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    inList(cellId) = 0;
    if(a_level(cellId) < this->m_maxSensorRefinementLevel[sen]) {
      inList(cellId) = (MInt)distance(cellId);
    }
  }

  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    if(inList(cellId) == 0) {
      if(a_level(cellId) == minLevel()) continue;
      if(c_noChildren(cellId) == 0) {
        MInt gridCellId = grid().tree().solver2grid(cellId);
        sensors[sensorOffset + sen][gridCellId] = -1.0;
        sensorCellFlag[gridCellId][sensorOffset + sen] = 1;
      }
    } else {
      ASSERT(inList(cellId) > 0, "");
      MInt gridCellId = grid().tree().solver2grid(cellId);
      if(a_level(cellId) < maxRefinementLevel()) { // refine cell
        if(c_noChildren(cellId) > 0) continue;
        if(a_isHalo(cellId)) continue;
        sensors[sensorOffset + sen][gridCellId] = 1.0;
        sensorCellFlag[gridCellId][sensorOffset + sen] = 1;
      }
    }
  }

  sensorWeight[sensorOffset + sen] = this->m_sensorWeight[sen];
}

/** \page sensorsFV
 *
 *  \section cutoff Cut off
 *
 *  This sensor is used to refined the cut off boundaries.<br>
 *  Property: <code>CUTOFF</code>
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::sensorCutOff(std::vector<std::vector<MFloat>>& sensors,
                                                      std::vector<std::bitset<64>>& sensorCellFlag,
                                                      std::vector<MFloat>& sensorWeight, MInt sensorOffset, MInt sen) {
  MIntScratchSpace cutOffCells(a_noCells(), AT_, "cutOffCells");
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    cutOffCells(cellId) = 0;
  }

  m_fvBndryCnd->markCutOff(cutOffCells);

  MIntScratchSpace bandWidth(this->m_maxSensorRefinementLevel[sen], AT_, "bandWidth");
  constexpr MInt additionalLayers = 1;

  bandWidth[this->m_maxSensorRefinementLevel[sen] - 1] =
      m_bandWidth[this->m_maxSensorRefinementLevel[sen] - 1] + additionalLayers;


  for(MInt i = this->m_maxSensorRefinementLevel[sen] - 2; i >= 0; i--) {
    bandWidth[i] = (bandWidth[i + 1] / 2) + 1;
  }

  for(MInt level = minLevel(); level < this->m_maxSensorRefinementLevel[sen]; level++) {
    this->markSurrndCells(cutOffCells, bandWidth[level], level, m_refineDiagonals);
  }

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    ASSERT(!a_isBndryGhostCell(cellId), "");
    ASSERT(!a_isHalo(cellId), "");
    ASSERT(!c_isToDelete(cellId), "");
    const MInt gridCellId = grid().tree().solver2grid(cellId);
    if(cutOffCells(cellId) > 0) {
      if(a_level(cellId) < this->m_maxSensorRefinementLevel[sen]) {
        sensors[sensorOffset + sen][gridCellId] = 1.0;
        sensorCellFlag[gridCellId][sensorOffset + sen] = true;
        MInt parent = c_parentId(cellId);
        if(parent > -1 && parent < a_noCells()) {
          MInt parentGridCellId = grid().tree().solver2grid(parent);
          if(parentGridCellId > -1 && parentGridCellId < grid().raw().m_noInternalCells) {
            sensors[sensorOffset + sen][parentGridCellId] = 1.0;
            sensorCellFlag[parentGridCellId][sensorOffset + sen] = true;
          }
        }
      }
    } else {
      sensors[sensorOffset + sen][gridCellId] = 0.0;
      sensorCellFlag[gridCellId][sensorOffset + sen] = false;
    }
  }

  if(m_engineSetup) {
    MInt noCutOffBndryIds = Context::propertyLength("cutOffBndryIds", m_solverId);

    MFloat xmin = -2.95;
    MFloat xmax = 1.65;

    xmin = Context::getSolverProperty<MFloat>("cutOffCoordinates", m_solverId, AT_, 0);

    if(noCutOffBndryIds > 1) {
      xmax = Context::getSolverProperty<MFloat>("cutOffCoordinates", m_solverId, AT_, 6);
    }

    const MFloat dist1 = 0.15;
    const MFloat dist2 = 0.25;

    for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
      if(a_coordinate(cellId, 0) < (xmin + dist1) && a_levelSetValuesMb(cellId, 0) > -m_maxLsValue
         && a_level(cellId) < this->m_maxSensorRefinementLevel[sen]) {
        const MInt gridCellId = grid().tree().solver2grid(cellId);
        sensors[sensorOffset + sen][gridCellId] = 1.0;
        sensorCellFlag[gridCellId][sensorOffset + sen] = 1;
      }

      if(a_coordinate(cellId, 0) > (xmax - dist1) && a_levelSetValuesMb(cellId, 0) > -m_maxLsValue
         && a_level(cellId) < this->m_maxSensorRefinementLevel[sen]) {
        const MInt gridCellId = grid().tree().solver2grid(cellId);
        sensors[sensorOffset + sen][gridCellId] = 1.0;
        sensorCellFlag[gridCellId][sensorOffset + sen] = 1;
      }
    }
    for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
      if(a_coordinate(cellId, 0) < (xmin + dist2) && a_levelSetValuesMb(cellId, 0) > -m_maxLsValue
         && a_level(cellId) < this->m_maxSensorRefinementLevel[sen] - 1) {
        const MInt gridCellId = grid().tree().solver2grid(cellId);
        sensors[sensorOffset + sen][gridCellId] = 1.0;
        sensorCellFlag[gridCellId][sensorOffset + sen] = 1;
      }

      if(a_coordinate(cellId, 0) > (xmax - dist2) && a_levelSetValuesMb(cellId, 0) > -m_maxLsValue
         && a_level(cellId) < this->m_maxSensorRefinementLevel[sen] - 1) {
        const MInt gridCellId = grid().tree().solver2grid(cellId);
        sensors[sensorOffset + sen][gridCellId] = 1.0;
        sensorCellFlag[gridCellId][sensorOffset + sen] = 1;
      }
    }
  }


  sensorWeight[sensorOffset + sen] = this->m_sensorWeight[sen];
}

/** \page sensorsFV
 *
 *  \section patch Patch
 *
 *  This sensor triggers the refinement of predefined patches.<br>
 *  Property: <code>PATCH</code>
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::sensorPatch(std::vector<std::vector<MFloat>>& sensors,
                                                     std::vector<std::bitset<64>>& sensorCellFlag,
                                                     std::vector<MFloat>& sensorWeight, MInt sensorOffset, MInt sen) {
  this->patchRefinement(sensors, sensorCellFlag, sensorWeight, sensorOffset, sen);
}


/**
 * \brief Allocate memory to arrays according to the current number of cells
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::reInitActiveCellIdsMemory() {
  mDeallocate(m_activeCellIds);
  mAlloc(m_activeCellIds, a_noCells(), "m_activeCellIds", -1, AT_);
}

/**
 * \brief Reallocate memory to small and master cell id arrays according to the current number of cells
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::reInitSmallCellIdsMemory() {
  mDeallocate(m_smallCellIds);
  mAlloc(m_smallCellIds, a_noCells(), "m_smallCellIds", -1, AT_);
  mDeallocate(m_masterCellIds);
  mAlloc(m_masterCellIds, a_noCells(), "m_masterCellIds", -1, AT_);
}

/**
 * \brief
 * \author Tim Wegmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::prepareAdaptation() {
  TRACE();

  if(globalTimeStep > 0) {
    m_lastAdapTS = globalTimeStep;
  }
  m_wasAdapted = true;
  this->m_adaptationStep = 0;

  if(!isActive()) return;

  if(globalTimeStep > 0) {
    finalizeMpiExchange();
    m_fvBndryCnd->resetBndryCommunication();
    resetBoundaryCells();
    m_fvBndryCnd->resetCutOffFirst();
    resetCutOffCells();
    resetSurfaces();
    resetSponge();
  } else {
    computeCellVolumes();
  }

#ifndef NDEBUG
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    ASSERT(!a_isBndryGhostCell(cellId), "");
    ASSERT(a_bndryId(cellId) == -1,
           "Error: bndryCellId " + std::to_string(a_bndryId(cellId)) + " for cell " + std::to_string(cellId));
    ASSERT(!a_hasProperty(cellId, SolverCell::IsSplitChild), "");
    if(!a_isHalo(cellId) && a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      for(MInt v = 0; v < CV->noVariables; v++) {
        ASSERT(!std::isnan(a_variable(cellId, v)), "");
      }
    }
    if(!m_levelSetMb) {
      ASSERT(a_cellVolume(cellId) > 0, "");
      ASSERT(!a_hasProperty(cellId, SolverCell::IsInactive), "");
    }
  }
#endif

  m_adaptationLevel = maxUniformRefinementLevel();
  m_maxLevelBeforeAdaptation = maxLevel();

  // Azimuthal exchange needs to be reinitialized after adaptation
  if(grid().azimuthalPeriodicity()) {
    m_azimuthalRecConstSet = false;
    m_azimuthalNearBndryInit = false;
  }

  // STG adaptation
  IF_CONSTEXPR(SysEqn::m_noRansEquations == 0) {
    if(m_zonal) {
      for(MInt c = (MInt)m_LESAverageCells.size() - 1; c >= 0; c--) {
        MInt cellId = m_LESAverageCells[c];
        if(a_isHalo(cellId)) {
          m_LESAverageCells.erase(m_LESAverageCells.begin() + c);
          for(MInt var = 0; var < m_LESNoVarAverage; var++) {
            m_LESVarAverage[var].erase(m_LESVarAverage[var].begin() + c);
          }
        }
      }
    }
  }
}


/**
 * \brief set the sensors for the adaptation (i.e. which cell should be refined/removed?)
 * \author Tim Wegmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setSensors(std::vector<std::vector<MFloat>>& sensors,
                                                    std::vector<MFloat>& sensorWeight,
                                                    std::vector<std::bitset<64>>& sensorCellFlag,
                                                    std::vector<MInt>& sensorSolverId) {
  TRACE();

  MInt noSensors = this->m_noInitialSensors;
  if(globalTimeStep > 0) noSensors = this->m_noSensors;

  const auto sensorOffset = (signed)sensors.size();
  ASSERT(sensorOffset == 0 || grid().raw().treeb().noSolvers() > 1, "");
  sensorCellFlag.resize(grid().raw().m_noInternalCells, sensorOffset + noSensors);
  sensors.resize(sensorOffset + noSensors, vector<MFloat>(grid().raw().m_noInternalCells, F0));
  sensorWeight.resize(sensorOffset + noSensors, -1);
  sensorSolverId.resize(sensorOffset + noSensors, solverId());
  ASSERT(sensorOffset + noSensors < CartesianGrid<nDim>::m_maxNoSensors, "Increase bitset size!");


  // If solver is inactive the sensor arrays need to be set to obtain the correct offsets
  if(!isActive()) {
    for(MInt sen = 0; sen < noSensors; sen++) {
      sensorWeight[sensorOffset + sen] = this->m_sensorWeight[sen];
    }
    return;
  }

  // necessary for the outside check at the initial adaptation!
  if(grid().allowInterfaceRefinement() && globalTimeStep < 0) {
    this->identifyBoundaryCells();
  }

  if(!this->m_adapts) {
    ASSERT(!m_levelSetMb, "Currently not possible to leave the FV-Solver adaptation!");
    return;
  }

  // compute slopes at first adaptation loop
  if(globalTimeStep > 0 && m_adaptationLevel == maxUniformRefinementLevel()) {
    LSReconstructCellCenter();
  }

  if(domainId() == 0) {
    cerr << "Setting " << noSensors << " sensors for fv-Solver adaptation." << endl;
  }

  for(MInt sen = 0; sen < noSensors; sen++) {
    (this->*(this->m_sensorFnPtr[sen]))(sensors, sensorCellFlag, sensorWeight, sensorOffset, sen);

    // labels:FV jannik: testcase hack, necessary for 2D_forced_cyl_adaptive and 2D_tandem_cylinders_adaptive
    // @ansgar_pls_adapt is this always required for 2D?

    IF_CONSTEXPR(nDim == 2) {
      ScratchSpace<MFloat> distance(a_noCells(), AT_, "distance");
      getBoundaryDistance(distance);

      ScratchSpace<MFloat> bbox(m_noDirs, AT_, "bbox");
      MFloat* p_bbox = bbox.getPointer();
      m_geometry->getBoundingBox(p_bbox);

#ifdef _OPENMP
#pragma omp parallel for
#endif
      for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
        if(a_bndryId(cellId) != -1) {
          continue;
        }
        if(a_isBndryGhostCell(cellId)) {
          continue;
        }
        if(c_noChildren(cellId) > 0) {
          continue;
        }
        if(c_isToDelete(cellId)) {
          continue;
        }

        const MInt gridId = this->grid().tree().solver2grid(cellId);

        MFloat minDist = c_cellLengthAtLevel(0);
        for(MInt i = 0; i < nDim; i++) {
          minDist = mMin(minDist, fabs(a_coordinate(cellId, i) - bbox.p[i]));
          minDist = mMin(minDist, fabs(a_coordinate(cellId, i) - bbox.p[nDim + i]));
        }
        MFloat fac = mMin(F1, mMax(F0, (minDist - 5.0) / (10.0 - 5.0)));

        const MFloat R0 = 3.0 * m_adaptationDampingDistance;
        const MFloat R1 = F1B2 * c_cellLengthAtLevel(0);
        const MFloat r = mMax(F0, distance[cellId] - R0) / (R1 - R0);
        fac = F1 / (F1 + POW2(F4 * r));

        sensors[sensorOffset + sen][gridId] *= fac;
      }
    }
  }

  ASSERT(m_freeIndices.empty(), "");
  m_freeIndices.clear();

  if(!g_multiSolverGrid) {
    ASSERT(a_noCells() == c_noCells() && c_noCells() == grid().raw().treeb().size(), "");
  }

  this->m_adaptationStep++;
}


/**
 * \brief
 * \author Tim Wegmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::postAdaptation() {
  TRACE();

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt i = 0; i < grid().raw().noNeighborDomains(); i++) {
    for(MInt j = 0; j < grid().raw().noHaloCells(i); j++) {
      MInt gridId = grid().raw().m_haloCells[i][j];
      MInt l_solverId = this->grid().tree().grid2solver(gridId);
      if(l_solverId < 0) {
        continue;
      }

      if(!grid().raw().treeb().solver(gridId, m_solverId)) {
        // cerr << "removing a Halo-cell " << endl;
        this->removeCellId(l_solverId);
      }
    }
  }

  this->compactCells();

  if(!g_multiSolverGrid) {
    for(MInt gridCellId = 0; gridCellId < grid().raw().treeb().size(); gridCellId++) {
      ASSERT(grid().tree().solver2grid(gridCellId) == gridCellId, "");
      ASSERT(grid().tree().grid2solver(gridCellId) == gridCellId, "");
    }
  }

  grid().updateOther();
  updateDomainInfo(grid().domainId(), grid().noDomains(), grid().mpiComm(), AT_);
  this->checkNoHaloLayers();

  m_cells.size(c_noCells());
  m_totalnosplitchilds = 0;
  m_totalnoghostcells = 0;

  // updates Halo-Information!
  copyGridProperties();

  // Nothing further to be done if inactive
  if(!isActive()) return;

  if(!g_multiSolverGrid) {
    ASSERT(a_noCells() == c_noCells() && c_noCells() == grid().raw().treeb().size(), "");
  }

  m_bndryGhostCellsOffset = a_noCells();

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    ASSERT(!a_isBndryGhostCell(cellId), "");
    ASSERT(a_bndryId(cellId) >= -1, to_string(a_bndryId(cellId)));
  }

  // create exchange functions:
  if(globalTimeStep < 0) {
    setCellProperties();
    updateMultiSolverInformation(true);
    // initializeMaxLevelExchange();
    exchangeDataFV(&a_pvariable(0, 0), PV->noVariables, false, m_rotIndVarsPV);
    computeConservativeVariables();
  } else {
    // correct values on halo cells
    exchangeDataFV(&a_variable(0, 0), CV->noVariables, false, m_rotIndVarsCV);
    exchangeDataFV(&a_oldVariable(0, 0), CV->noVariables, false, m_rotIndVarsCV);
    exchangeProperties();
    IF_CONSTEXPR(isDetChem<SysEqn>) correctMajorSpeciesMassFraction();
    IF_CONSTEXPR(isDetChem<SysEqn>) computeMeanMolarWeights_CV();
    computePrimitiveVariables();
  }

  if(m_closeGaps) {
    exchangeGapInfo();
  }

  if(m_sensorParticle) {
    exchangeData(&a_noPart(
        0)); // Since azimuthal window/halos cells do not overlap an meaningful way to exchange this needs to be found!
  }

  if(m_zonal) {
    resetZonalSolverData();
  }

#if defined _MB_DEBUG_ || !defined NDEBUG
  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    for(MInt v = 0; v < PV->noVariables; v++) {
      if(std::isnan(a_pvariable(cellId, v)) && a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        cerr << "Cell with invalid value 1" << cellId << " " << a_isHalo(cellId) << " "
             << a_hasProperty(cellId, SolverCell::IsInactive) << endl;
      }
    }
  }
#endif

  m_freeIndices.clear();
  m_adaptationLevel++;
}

/**
 * \brief
 * \author Tim Wegmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::finalizeAdaptation() {
  TRACE();

  m_forceAdaptation = false;
  m_adaptationSinceLastRestart = true;
  m_adaptationSinceLastRestartBackup = true;

  // // Nothing further to be done if inactive
  if(!isActive()) return;

  // Reallocate memory to small and master cell id arrays
  reInitSmallCellIdsMemory();

  if(globalTimeStep > 0) {
    updateMultiSolverInformation(true);

    // set isInactive based on levelSet value!
    initSolutionStep(0);

    // Reallocate solver memory to arrays depending on a_noCells()
    reInitActiveCellIdsMemory();

    writeListOfActiveFlowCells();

    if(!m_levelSetMb) initializeMaxLevelExchange();

    updateMaterialNo();

    IF_CONSTEXPR(isDetChem<SysEqn>) {
      computeMeanMolarWeights_CV();
      cutOffBoundaryCondition();
      applyBoundaryCondition();
      computeConservativeVariables();
      scalarLimiter();
    }

    computePV();

    if(grid().azimuthalPeriodicity()) {
      cutOffBoundaryCondition(); // Cut-off cells are used for azimuthal reconstruction
      setConservativeVarsOnAzimuthalRecCells();
    }

    exchange();

    if(m_zonal) exchangeZonalAverageCells();

    cutOffBoundaryCondition();

    applyBoundaryCondition();

    IF_CONSTEXPR(isDetChem<SysEqn>) { computeConservativeVariables(); }

    scalarLimiter();

    exchange();

    if(m_hasExternalSource) {
      resetExternalSources();
    }

    IF_CONSTEXPR(isDetChem<SysEqn>) { computeMeanMolarWeights_PV(); }

#if defined(WITH_CANTERA)
    IF_CONSTEXPR(isDetChem<SysEqn>) {
      computeGamma();
      setTimeStep();
    }
#endif
  }

  m_wasAdapted = false;

#if defined _MB_DEBUG_ || !defined NDEBUG
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    for(MInt v = 0; v < PV->noVariables; v++) {
      if(std::isnan(a_pvariable(cellId, v)) && a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        cerr << "Cell with invalid value 2 " << cellId << " " << a_isHalo(cellId) << " "
             << a_hasProperty(cellId, SolverCell::IsInactive) << endl;
      }
    }
  }
#endif
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setCellWeights(MFloat* solverCellWeight) {
  TRACE();
  ASSERT(isActive(), "solver is not active");

  MBool weightOnlyLeafCells = false;
  weightOnlyLeafCells =
      Context::getSolverProperty<MBool>("weightOnlyLeafCellsFv", m_solverId, AT_, &weightOnlyLeafCells);

  const MInt noCellsGrid = grid().raw().treeb().size();
  const MInt offset = noCellsGrid * solverId();

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    assertValidGridCellId(cellId);
    const MInt gridCellId = grid().tree().solver2grid(cellId);
    const MInt id = gridCellId + offset;

    solverCellWeight[id] = (c_isLeafCell(cellId) || !weightOnlyLeafCells) ? 1.0 : 0.0;
  }
}

/**
 * \brief Limit Weight types to avoid large memory disbalance between ranks for DLB
 * \author Tim Wegmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::limitWeights(MFloat* weights) {
  TRACE();

  if(m_limitWeights) {
    ASSERT(m_weightInactiveCell, "");
    MInt count = 1 + m_weightBndryCells + m_weightCutOffCells + m_weightBc1601;
    weights[count] = mMax(weights[count], 0.01 * weights[0]);
  }
}


//-----------------------------------------------------------------------------------


template <MInt nDim_, class SysEqn>
MInt FvCartesianSolverXD<nDim_, SysEqn>::noLoadTypes() const {
  TRACE();

  MInt noFvLoadTypes = 1; // active leaf cells
  if(m_weightBndryCells) {
    noFvLoadTypes += 1; // boundary cells
  }
  if(m_weightCutOffCells) {
    noFvLoadTypes += 1; // cut-off cells
  }
  if(m_weightBc1601) {
    noFvLoadTypes += 1; // bc1601 cells
  }
  if(m_weightInactiveCell) {
    noFvLoadTypes += 1; // memory weight
  }
  if(m_weightNearBndryCells) {
    noFvLoadTypes += 1; // near boundary cells
  }
  if(m_weightLvlJumps) {
    noFvLoadTypes += 1; // cells at lvl-jump
  }
  if(m_weightSmallCells) {
    noFvLoadTypes += 1; // small cells
  }

  return noFvLoadTypes;
}


/// \brief Return the default weights for all load quantities
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getDefaultWeights(MFloat* weights, std::vector<MString>& names) const {
  TRACE();

  weights[0] = 1.0;
  names[0] = "fv_leaf_cell";
  MInt count = 1;

  if(m_weightBndryCells) {
    weights[count] = 5.0;
    names[count] = "fv_bndry_cell";
    count++;
  }

  if(m_weightCutOffCells) {
    weights[count] = 5.0;
    names[count] = "fv_cutoff_cell";
    count++;
  }

  if(m_weightBc1601) {
    weights[count] = 10.0;
    names[count] = "fv_bc1601";
    count++;
  }

  if(m_weightInactiveCell) {
    weights[count] = 0.1;
    names[count] = "fv_inactive_cell";
    count++;
  }

  if(m_weightNearBndryCells) {
    weights[count] = 2.0;
    names[count] = "fv_nearBndry_cell";
    count++;
  }
  if(m_weightLvlJumps) {
    weights[count] = 1.5;
    names[count] = "fv_lvlJump_cell";
    count++;
  }
  if(m_weightSmallCells) {
    weights[count] = 1.0;
    names[count] = "fv_smallCell";
    count++;
  }

  if(noLoadTypes() != count) {
    mTerm(1, "Count does not match noLoadTypes.");
  }
}


/// \brief Return the cumulative load quantities on this domain.
///
/// \author Ansgar Niemoeller (ansgar) <a.niemoeller@aia.rwth-aachen.de>
///
/// \param[out] loadQuantities Storage for load quantities.
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getLoadQuantities(MInt* const loadQuantities) const {
  TRACE();

  // reset
  std::fill_n(&loadQuantities[0], noLoadTypes(), 0);

  // Nothing to do if solver is not active
  if(!grid().isActive()) {
    return;
  }

  // Count the number of leaf cells/boundary cells and store as load quantities
  MInt noLeafCells = 0;
  MInt noBndryCells = 0;
  MInt noNearBndryCells = 0;
  MInt totalNoCutOffCells = 0;
  MInt noBc1601Cells = 0;
  MInt noLvlJumpCells = 0;

  for(MInt cellId = 0; cellId < grid().noInternalCells(); cellId++) {
    if(c_isLeafCell(cellId) && !a_hasProperty(cellId, SolverCell::IsInactive)) {
      noLeafCells++;
    }
    if(c_isLeafCell(cellId)) {
      MBool atLvlJump = false;
      for(MInt dir = 0; dir < m_noDirs; dir++) {
        if(c_neighborId(cellId, dir, false) < 0 && c_parentId(cellId) > -1
           && c_neighborId(c_parentId(cellId), dir, false) > -1) {
          atLvlJump = true;
          break;
        }
        if(c_neighborId(cellId, dir, false) > -1 && !c_isLeafCell(c_neighborId(cellId, dir, false))) {
          atLvlJump = true;
          break;
        }
      }
      if(atLvlJump) {
        noLvlJumpCells++;
      }
    }

    const MInt bndryId = a_bndryId(cellId);
    if(bndryId > -1 && c_isLeafCell(cellId)) {
      noBndryCells++;
    }
    if(a_hasProperty(cellId, SolverCell::NearWall)) {
      noNearBndryCells++;
    }
  }

  for(MInt bc = 0; bc < m_fvBndryCnd->m_noCutOffBndryCndIds; bc++) {
    MInt noCutOffCells = 0;

    const MInt bcSize = m_fvBndryCnd->m_sortedCutOffCells[bc]->size();
    for(MInt i = 0; i < bcSize; i++) {
      const MInt cellId = m_fvBndryCnd->m_sortedCutOffCells[bc]->a[i];
      if(!a_isHalo(cellId)) {
        noCutOffCells++;
      }
    }

    if(m_weightBc1601 && bc == m_fvBndryCnd->m_bc1601_bcId) {
      // If enabled, treat random eddy inflow bc cells separately
      noBc1601Cells = noCutOffCells;
    } else {
      // Sum up all other cut-off cells
      totalNoCutOffCells += noCutOffCells;
    }
  }

  loadQuantities[0] = noLeafCells;
  MInt count = 1;

  // Number of boundary cells if enabled
  if(m_weightBndryCells) {
    loadQuantities[count] = noBndryCells;
    count += 1;
  }
  if(m_weightCutOffCells) {
    loadQuantities[count] = totalNoCutOffCells;
    count += 1;
  }
  if(m_weightBc1601) {
    loadQuantities[count] = noBc1601Cells;
    count += 1;
  }
  if(m_weightInactiveCell) {
    loadQuantities[count] = grid().noInternalCells();
    count += 1;
  }
  if(m_weightNearBndryCells) {
    loadQuantities[count] = noNearBndryCells;
    count += 1;
  }
  if(m_weightLvlJumps) {
    loadQuantities[count] = noLvlJumpCells;
    count += 1;
  }
  if(m_weightSmallCells) {
    loadQuantities[count] = m_fvBndryCnd->m_smallCutCells.size();
    count += 1;
  }
}


/// \brief Return the load of a single cell (given computational weights).
///
/// \author Ansgar Niemoeller (ansgar) <a.niemoeller@aia.rwth-aachen.de>
///
/// \param[in] cellId Requested grid cell id.
/// \param[in] weights Computational weights for different simulation components.
/// \return Cell load.
template <MInt nDim_, class SysEqn>
MFloat FvCartesianSolverXD<nDim_, SysEqn>::getCellLoad(const MInt gridCellId, const MFloat* const weights) const {
  TRACE();
  ASSERT(isActive(), "solver is not active");

  // Convert to solver cell id and check
  const MInt cellId = grid().tree().grid2solver(gridCellId);
  if(cellId < 0) {
    return 0;
  }

  if(cellId < 0 || cellId >= grid().noInternalCells()) {
    mTerm(1, "The given cell id is invalid.");
  }

  // Default cell load
  MFloat cellLoad = 0.0;


  if(c_isLeafCell(cellId) && !a_hasProperty(cellId, SolverCell::IsInactive)) {
    cellLoad = weights[0];
  }
  MInt count = 1;

  // Add load for boundary/cut-off cells
  if(m_weightBndryCells) {
    const MInt bndryId = a_bndryId(cellId);
    if(bndryId > -1 && c_isLeafCell(cellId)) {
      cellLoad += weights[count];
    }
    count += 1;
  }

  if(m_weightCutOffCells) {
    for(MInt bc = 0; bc < m_fvBndryCnd->m_noCutOffBndryCndIds; bc++) {
      if(m_weightBc1601 && bc == m_fvBndryCnd->m_bc1601_bcId) continue; // skip bc1601 if cells are weighted separately

      const MInt bcSize = m_fvBndryCnd->m_sortedCutOffCells[bc]->size();
      for(MInt i = 0; i < bcSize; i++) {
        if(cellId == m_fvBndryCnd->m_sortedCutOffCells[bc]->a[i]) {
          cellLoad += weights[count + 1];
        }
      }
    }
    count += 1;
  }

  // Add load for bc1601 cells (random eddy inflow)
  if(m_weightBc1601) {
    const MInt bc = m_fvBndryCnd->m_bc1601_bcId; // -1 if non-existent
    const MInt bcSize = (bc < 0) ? 0 : m_fvBndryCnd->m_sortedCutOffCells[bc]->size();
    for(MInt i = 0; i < bcSize; i++) {
      if(cellId == m_fvBndryCnd->m_sortedCutOffCells[bc]->a[i]) {
        cellLoad += weights[count];
      }
    }
    count += 1;
  }
  if(m_weightInactiveCell) {
    if(cellLoad < MFloatEps) {
      cellLoad = weights[count];
    }
    count += 1;
  }

  if(m_weightNearBndryCells) {
    if(a_hasProperty(cellId, SolverCell::NearWall)) {
      cellLoad += weights[count];
    }
  }

  if(m_weightLvlJumps) {
    MBool atLvlJump = false;
    if(c_isLeafCell(cellId)) {
      for(MInt dir = 0; dir < m_noDirs; dir++) {
        if(c_neighborId(cellId, dir, false) < 0 && c_parentId(cellId) > -1
           && c_neighborId(c_parentId(cellId), dir, false) > -1) {
          atLvlJump = true;
          break;
        }
        if(c_neighborId(cellId, dir, false) > -1 && !c_isLeafCell(c_neighborId(cellId, dir, false))) {
          atLvlJump = true;
          break;
        }
      }
    }
    if(atLvlJump) {
      cellLoad += weights[count];
    }
  }

  if(m_weightSmallCells) {
    if(a_cellVolume(cellId) / grid().gridCellVolume(maxLevel()) < m_fvBndryCnd->m_volumeLimitWall) {
      cellLoad += weights[count];
    }
    count += 1;
  }

  return cellLoad;
}


/**
 * \brief Reset the solver prior to load balancing
 * \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::resetSolver() {
  finalizeMpiExchange();

  // apply and reset, as external sources are not exchanged during balance!
  /*
  if(m_hasExternalSource && m_levelSetMb) {
    for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
      if(!a_hasProperty(cellId, SolverCell::IsActive)) continue;
      for(MInt var = 0; var < CV->noVariables; var++) {
        a_rightHandSide(cellId, var) -= a_externalSource(cellId, var);
      }
    }
  }
  */
  if(m_hasExternalSource) {
    resetExternalSources();
    advanceExternalSource();
  }
}


/**
 * \brief reset sponge properties
 * \author Tim Wegmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::resetSponge() {
  TRACE();

  for(MInt c = 0; c < m_noCellsInsideSpongeLayer; c++) {
    // const MInt cellId = m_cellsInsideSpongeLayer[ c ];
    // a_hasProperty(cellId, SolverCell::IsInSpongeLayer) = false;
    // a_spongeFactor(cellId) = F0;
    m_cellsInsideSpongeLayer[c] = -1;
  }
  m_noCellsInsideSpongeLayer = 0;
}

//-----------------------------------------------------------------------------------


/**
 * \brief resets the solver
 * \author Lennart Schneiders
 */
template <MInt nDim_, class SysEqn>
ATTRIBUTES1(ATTRIBUTE_NO_AUTOVEC)
void FvCartesianSolverXD<nDim_, SysEqn>::resetSolverFull() {
  TRACE();

  if(m_fvBndryCnd->m_cellCoordinatesCorrected) {
    m_fvBndryCnd->recorrectCellCoordinates();
  }

  for(MInt cellId = 0; cellId < maxNoGridCells(); cellId++) {
    a_bndryId(cellId) = -1;
    for(MInt v = 0; v < FV->noVariables; v++) {
      a_rightHandSide(cellId, v) = F0;
    }
    for(MInt v = 0; v < PV->noVariables; v++) {
      a_pvariable(cellId, v) = sqrt(-F1);
    }
    a_cellVolume(cellId) = F0;
    a_FcellVolume(cellId) = sqrt(-F1);
  }

  if(grid().azimuthalPeriodicity()) {
    m_noAzimuthalReconstNghbrs.clear();
    m_azimuthalReconstNghbrIds.clear();
    m_azimuthalRecConsts.clear();
    // m_azimuthalCutRecCoord.clear();
    // m_azimuthalBndrySide.clear();
    // m_azimuthalWindowMap.clear();
    // m_azimuthalCartRecCoord.clear();
  }

  resetSurfaces();

  for(MInt bndryId = 0; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    a_bndryId(cellId) = -1;
    a_hasProperty(cellId, SolverCell::IsSplitCell) = false;
    a_hasProperty(cellId, SolverCell::IsSplitChild) = false;
    a_hasProperty(cellId, SolverCell::HasSplitFace) = false;
    a_hasProperty(cellId, SolverCell::IsTempLinked) = false;
    a_hasProperty(cellId, SolverCell::IsMovingBnd) = false;
  }
  for(MInt bndryId = 0; bndryId < m_fvBndryCnd->m_maxNoBndryCells; bndryId++) {
    std::vector<MInt>().swap(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds);
    std::vector<MFloat>().swap(m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst);
    std::vector<MFloat>().swap(m_fvBndryCnd->m_bndryCell[bndryId].m_cellDerivRecConst);
    std::vector<MFloat>().swap(m_fvBndryCnd->m_bndryCell[bndryId].m_faceVertices);
    for(MUint i = 0; i < m_fvBndryCnd->m_bndryCell[bndryId].m_faceStream.size(); i++) {
      m_fvBndryCnd->m_bndryCell[bndryId].m_faceStream[i].resize(0);
    }
    m_fvBndryCnd->m_bndryCell[bndryId].m_faceStream.resize(0);
    for(MInt srfc = 0; srfc < FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces; srfc++) {
      m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_noCutPoints = 0;
      std::vector<MFloat>().swap(m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst);
      for(MInt v = 0; v < PV->noVariables; v++) {
        m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[v] = BC_UNSET;
      }
      for(MInt i = 0; i < nDim; i++) {
        m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_srfcId[i] = -1;
      }
    }
    m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId = -1;
    // m_fvBndryCnd->deleteBndryCell( bndryId );
  }

  m_fvBndryCnd->m_bndryCells->resetSize(0);
  std::vector<MInt>().swap(m_fvBndryCnd->m_smallCutCells);

  resetCutOffCells();
  m_fvBndryCnd->resetCutOffFirst();

  m_fvBndryCnd->resetBndryCommunication();

  m_bndryGhostCellsOffset = 0;
  m_bndrySurfacesOffset = 0;
  m_totalnosplitchilds = 0;
  m_totalnoghostcells = 0;

  // Reset all cells (Note: this invalidates the collector internal data structures)
  m_cells.clear();
  ASSERT(m_cells.size() == 0, "");
  m_reconstructionDataSize = 0;

  IF_CONSTEXPR(isDetChem<SysEqn>) m_dampFactor.clear();

  // Note: dont use noNeighborDomains() since it might contain a different value after load balancing the grid.
  if(!m_fvBndryCnd->m_cellMerging && m_fvBndryCnd->m_nearBoundaryHaloCells != nullptr) {
    for(MUint i = 0; i < m_fvBndryCnd->m_nearBoundaryHaloCells->size(); i++) {
      std::vector<MInt>().swap(m_fvBndryCnd->m_nearBoundaryHaloCells[i]);
      std::vector<MInt>().swap(m_fvBndryCnd->m_nearBoundaryWindowCells[i]);
    }
  }
}


// --------------------------------------------------------------------------------------


/**
 * \brief Balance the solver
 * \author Jerry Grimmen, Lennart Schneiders, Ansgar Niemoeller, multi-solver-update: Tim Wegmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::balance(const MInt* const noCellsToReceiveByDomain,
                                                 const MInt* const noCellsToSendByDomain,
                                                 const MInt* const sortedCellId, const MInt oldNoCells) {
  // TODO labels:FV,DLB balance is still needed for FV-MB DLB!
  /* mTerm(1, "balance() is deprecated, use split balancing balancePre/Post instead!"); */
  TRACE();
  NEW_TIMER_GROUP(t_initTimer, "balance solver");
  NEW_TIMER(t_timertotal, "balance solver", t_initTimer);
  NEW_SUB_TIMER(t_variables, "variables", t_timertotal);
  NEW_SUB_TIMER(t_communicator, "communicator", t_timertotal);
  NEW_SUB_TIMER(t_reinit, "reinit", t_timertotal);

  RECORD_TIMER_START(t_timertotal);
  RECORD_TIMER_START(t_variables);

  // write solver-data into grid-structure arrays for the load-balancing
  MFloatScratchSpace variablesBalance(oldNoCells, CV->noVariables, FUN_, "variablesBalance");
  MFloatScratchSpace volumeBalance(oldNoCells, FUN_, "volumeBalance");

  variablesBalance.fill(-1);
  volumeBalance.fill(-1);


  for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
    MInt gridCellId = grid().tree().solver2grid(cellId);
    for(MInt variable = 0; variable < CV->noVariables; variable++) {
      if(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        ASSERT(!std::isnan(a_variable(cellId, variable)), "");
      }
      variablesBalance(gridCellId, variable) = a_variable(cellId, variable);
    }
    volumeBalance(gridCellId) = a_cellVolume(cellId);
  }


  // update of the proxy
  grid().update();

  // Just reset parallelization information if solver is not active
  // NOTE: inactive ranks not supported here since the data sizes etc are not determined for the
  // solver but for the whole grid -> use balancePre/Post instead!
  if(!grid().isActive()) {
    updateDomainInfo(-1, -1, MPI_COMM_NULL, AT_);
    mTerm(1, "fixme: inactive ranks not supported in balance(); use balancePre/Post instead!");
    return;
  }

  // Set new domain info for solver
  updateDomainInfo(grid().domainId(), grid().noDomains(), grid().mpiComm(), AT_);

  // This is only working of the same domains as in the grid are used!
  ASSERT(domainId() == grid().raw().domainId(), "");
  ASSERT(noDomains() == grid().raw().noDomains(), "");

  // data-to be saved during the balancing:
  //-a_variables
  // a_cellVolume

  MFloatScratchSpace variables(noCellsToReceiveByDomain[noDomains()], CV->noVariables, FUN_, "variables");
  MFloatScratchSpace cellVolumes(noCellsToReceiveByDomain[noDomains()], FUN_, "cellVolumes");

  variables.fill(-1.0);
  cellVolumes.fill(-1.0);

  maia::mpi::communicateData(&variablesBalance[0], oldNoCells, sortedCellId, noDomains(), domainId(), mpiComm(),
                             noCellsToSendByDomain, noCellsToReceiveByDomain, CV->noVariables, &variables[0]);
  maia::mpi::communicateData(&volumeBalance[0], oldNoCells, sortedCellId, noDomains(), domainId(), mpiComm(),
                             noCellsToSendByDomain, noCellsToReceiveByDomain, 1, &cellVolumes[0]);

  // Reset cell, surface, boundary cell data and deallocate halo/window cell arrays, and reset cell
  // collector
  resetSolverFull();

  // Reallocate communication data structures
  updateMultiSolverInformation(true);

  ASSERT(m_cells.size() == 0, "");

  // Iterate over all received grid cells
  for(MInt gridCellId = 0; gridCellId < noCellsToReceiveByDomain[noDomains()]; gridCellId++) {
    const MInt cellId = m_cells.size();

    if(!grid().raw().treeb().solver(gridCellId, m_solverId)) continue;

    // this needs to be appended before performing any checks
    m_cells.append();

    if(!grid().raw().bitOffset()) {
      ASSERT(grid().tree().solver2grid(cellId) == gridCellId, to_string(cellId) + " " + to_string(gridCellId));
    }

    if(grid().domainOffset(domainId()) + (MLong)cellId != c_globalId(cellId)) {
      mTerm(1, "Global id mismatch: o" + std::to_string(grid().domainOffset(domainId())) + " + c"
                   + std::to_string(cellId) + " != g" + std::to_string(c_globalId(cellId)));
    }

    a_resetPropertiesSolver(cellId);

    // Set solver data
    for(MInt v = 0; v < CV->noVariables; v++) {
      a_variable(cellId, v) = variables(gridCellId, v);
      a_oldVariable(cellId, v) = a_variable(cellId, v);
    }
    setPrimitiveVariables(cellId);
    a_cellVolume(cellId) = cellVolumes(gridCellId);
    a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
  }


  // append the halo-cells;
  m_cells.append(c_noCells() - m_cells.size());

  m_totalnoghostcells = 0;
  m_totalnosplitchilds = 0;

  ASSERT(m_cells.size() == c_noCells() && c_noCells() == a_noCells(), "");

  m_bndryGhostCellsOffset = a_noCells();
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    a_bndryId(cellId) = -1;
    a_isBndryGhostCell(cellId) = false;
    a_hasProperty(cellId, SolverCell::IsSplitChild) = false;
  }

  copyGridProperties();

  // this can only be done, after the halo-cells have been added above!
  this->checkNoHaloLayers();

  RECORD_TIMER_STOP(t_variables);
  RECORD_TIMER_START(t_communicator);

  mDeallocate(m_maxLevelHaloCells);
  mDeallocate(m_maxLevelWindowCells);
  mDeallocate(m_noMaxLevelHaloCells);
  mDeallocate(m_noMaxLevelWindowCells);
  mDeallocate(m_sendBuffers);
  mDeallocate(m_receiveBuffers);
  mDeallocate(m_mpi_request);
  if(m_nonBlockingComm) {
    mDeallocate(m_sendBuffersNoBlocking);
    mDeallocate(m_receiveBuffersNoBlocking);
    mDeallocate(m_mpi_receiveRequest);
    mDeallocate(m_mpi_sendRequest);
  }

  allocateCommunicationMemory();

  if(!m_fvBndryCnd->m_cellMerging) {
    mDeallocate(m_fvBndryCnd->m_nearBoundaryWindowCells);
    mDeallocate(m_fvBndryCnd->m_nearBoundaryHaloCells);
    mAlloc(m_fvBndryCnd->m_nearBoundaryWindowCells, noNeighborDomains(), "m_nearBoundaryWindowCells", AT_);
    mAlloc(m_fvBndryCnd->m_nearBoundaryHaloCells, noNeighborDomains(), "m_nearBoundaryHaloCells", AT_);
  }

  std::vector<MInt>().swap(m_splitCells);
  std::vector<std::vector<MInt>>().swap(m_splitChilds);
  std::map<MInt, MInt>().swap(m_splitChildToSplitCell);
  m_totalnosplitchilds = 0;

  if(this->m_adaptation) {
    for(MInt i = 0; i < maxNoGridCells(); i++)
      m_recalcIds[i] = i;
  }

  // set variables for halo cells:
  exchangeData(&a_variable(0, 0), CV->noVariables);
  exchangeData(&a_cellVolume(0), 1);
  if(grid().azimuthalPeriodicity()) {
    mTerm(1, AT_, "Add azimuthal periodicity, c.f. fvMb!");
  }

  for(MInt cellId = noInternalCells(); cellId < a_noCells(); cellId++) {
    setPrimitiveVariables(cellId);
    for(MInt v = 0; v < CV->noVariables; v++) {
      a_oldVariable(cellId, v) = a_variable(cellId, v);
    }
    a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
  }

  copyGridProperties();

  IF_CONSTEXPR(isDetChem<SysEqn>) if(m_heatReleaseDamp) initHeatReleaseDamp();

  RECORD_TIMER_STOP(t_communicator);
  RECORD_TIMER_START(t_reinit);

  // If grid adaptation is used make sure that a grid file is written with the next restart file
  // since the cells will be sorted during balacing, while the old grid after adaptation will
  // contain the unsorted grid cells
  if(this->m_adaptation) {
    m_adaptationSinceLastRestart = true;
    m_adaptationSinceLastRestartBackup = true;
  }

  RECORD_TIMER_STOP(t_reinit);
  RECORD_TIMER_STOP(t_timertotal);
  DISPLAY_TIMER(t_timertotal);
}

//-------------------------------------------------------------------------------------------


/// \brief Reinitialize solver for DLB prior to setting solution data.
///
/// \author Ansgar Niemoeller (ansgar) <a.niemoeller@aia.rwth-aachen.de>
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::balancePre() {
  TRACE();

  // Note: every function that allocates persistent memory should first deallocate that memory, for
  // this to work initialize all pointers with nullptr in the class definition

  // Set reinitialization stage
  m_loadBalancingReinitStage = 0;

  // Store currently used memory
  /* const MLong previouslyAllocated = allocatedBytes(); */

  // Update the grid proxy for this solver
  grid().update();

  if(!grid().isActive()) {
    // Reset parallelization information if solver is not active
    updateDomainInfo(-1, -1, MPI_COMM_NULL, AT_);
  } else {
    // Set new domain info for solver
    updateDomainInfo(grid().domainId(), grid().noDomains(), grid().mpiComm(), AT_);
  }

  if(m_zonal) {
    m_wasBalancedZonal = true;
  }

  // Reset cell, surface, boundary cell data and deallocate halo/window cell arrays
  resetSolverFull();

  // Reallocate communication data structures
  // only requires noNeighborDomains information, which is set in the proxy
  updateMultiSolverInformation(true);

  // Return if solver is not active
  if(!grid().isActive()) {
    return;
  }

  // check for empty cell collector
  ASSERT(m_cells.size() == 0, "");

  // Resize cell collector to internal cells
  m_cells.append(grid().noInternalCells());

  // Check that global ids are sorted
  for(MInt cellId = 0; cellId < grid().noInternalCells(); cellId++) {
    if(grid().domainOffset(domainId()) + (MLong)cellId != c_globalId(cellId)) {
      mTerm(1, "Global id mismatch.");
    }
    // TODO labels:FV,DLB communicate cell volumes necessary? (see balance())
    /* a_cellVolume(cellId) = cellVolumes(gridCellId); */
    /* a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(gridCellId)); */
  }

  // TODO labels:FV,DLB reinit postprocessing?

  // allocate general FvCartesianSolver memory
  // TODO labels:FV,DLB most memory sizes are constant, but some are dependent on m_noCells/m_noInternalCells
  // allocateAndInitSolverMemory();
}


/// \brief Reinitialize solver after setting solution data in DLB.
///
/// \author Ansgar Niemoeller (ansgar) <a.niemoeller@aia.rwth-aachen.de>
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::balancePost() {
  TRACE();

  if(grid().azimuthalPeriodicity()) {
    mTerm(1, AT_,
          "This type of balance is not supported for azimuthal periodicity. Add periodic exchange of conservative "
          "variables");
  }

  m_loadBalancingReinitStage = 1;

  // append the halo-cells
  m_cells.append(c_noCells() - m_cells.size());

  copyGridProperties();

  m_totalnoghostcells = 0;
  m_totalnosplitchilds = 0;
  ASSERT(m_cells.size() == c_noCells() && c_noCells() == a_noCells(), "");

  // Nothing to do if solver is not active
  if(!grid().isActive()) {
    return;
  }

  m_bndryGhostCellsOffset = a_noCells();
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    a_bndryId(cellId) = -1;
    a_isBndryGhostCell(cellId) = false;
    a_hasProperty(cellId, SolverCell::IsSplitChild) = false;
  }

  // this can only be done, after the halo property has been set above
  this->checkNoHaloLayers();

  // ### from c'tor ###
  // compute min and max coordinates in the grid
  computeDomainAndSpongeDimensions();
  // ###

  allocateCommunicationMemory();

  if(!m_fvBndryCnd->m_cellMerging) {
    mDeallocate(m_fvBndryCnd->m_nearBoundaryWindowCells);
    mDeallocate(m_fvBndryCnd->m_nearBoundaryHaloCells);
    mAlloc(m_fvBndryCnd->m_nearBoundaryWindowCells, noNeighborDomains(), "m_nearBoundaryWindowCells", AT_);
    mAlloc(m_fvBndryCnd->m_nearBoundaryHaloCells, noNeighborDomains(), "m_nearBoundaryHaloCells", AT_);
  }

  m_splitCells.clear();
  m_splitChilds.clear();
  m_splitChildToSplitCell.clear();
  m_totalnosplitchilds = 0;

  // during the balance cells are sorted again
  if(this->m_adaptation) {
    for(MInt i = 0; i < maxNoGridCells(); i++)
      m_recalcIds[i] = i;
  }

  exchangeData(&a_variable(0, 0), CV->noVariables);
  if constexpr(hasAV) exchangeData(&a_avariable(0, 0), AV->noVariables);
  exchangeData(&a_cellVolume(0), 1);
  if(grid().azimuthalPeriodicity()) {
    mTerm(1, AT_, "Add azimuthal periodicity, c.f. fvMb!");
  }

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    setPrimitiveVariables(cellId);
    for(MInt v = 0; v < CV->noVariables; v++) {
      a_oldVariable(cellId, v) = a_variable(cellId, v);
    }
    a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
  }

  copyGridProperties();

  if(m_zonal) {
    determineLESAverageCells();
    resetZonalLESAverage();
    resetZonalSolverData();
  }

  // If grid adaptation is used make sure that a grid file is written with the next restart file
  // since the cells will be sorted during balacing, while the old grid after adaptation will
  // contain the unsorted grid cells
  if(this->m_adaptation) {
    m_adaptationSinceLastRestart = true;
    m_adaptationSinceLastRestartBackup = true;
  }

  m_loadBalancingReinitStage = 2;

  // check finalizeBalance for any of this cases!
  if(m_combustion && !m_LSSolver) {
    mTerm(1, "balancePost untested case with combustion");
  }
  if constexpr(isEEGas<SysEqn>) {
    if(m_EEGas.gasSource != 0) {
      m_EEGas.gasSourceCells.clear();
      initSourceCells();
    }
  }
}


/// \brief Reinitialize solver after all data structures have been recreated
/// \author Tim Wegmann
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::finalizeBalance() {
  TRACE();

  ASSERT(m_cells.size() == c_noCells(), "");

  // Nothing to do if solver is not active
  if(!grid().isActive()) {
    return;
  }

  if(m_closeGaps) {
    exchangeGapInfo();
  }

  // nothing to be done in the initial adaptation
  if(globalTimeStep < 0) return;

  // Reallocate memory to small and master cell id arrays
  reInitSmallCellIdsMemory();

  // TODO labels:FV,DLB move the following into a separate function to be called at initialization and after DLB
  initSolutionStep(1);
  // Reallocate solver memory to arrays depending on a_noCells()
  reInitActiveCellIdsMemory();
  writeListOfActiveFlowCells();

  if(!m_levelSetMb) initializeMaxLevelExchange();

  // TODO labels:DLB already performed in initSolutionStep() TEST!
  updateMaterialNo();

  // To reset communicators in BndryCnd
  initCutOffBoundaryCondition();

  IF_CONSTEXPR(isDetChem<SysEqn>) {
    cutOffBoundaryCondition();
    applyBoundaryCondition();
    computeMeanMolarWeights_CV();
    computeConservativeVariables();
    computeMeanMolarWeights_CV();
  }

  computePV();

  // initialize the runge kutta integration scheme
  // TODO labels:FV,DLB fix this for levelSetMb, initializeRungeKutta is overloaded
  //      and some incorrect stuff is done there!
  if(!m_levelSetMb) {
    initializeRungeKutta();
  }

  // Note: time step is communicated to previously inactive ranks

  // periodic exchange (azimuthal periodicity concept)
  if(m_periodicCells == 3) {
    mTerm(1, "balancePost untested case with azimuthal periodicity");
    exchange();
    exchangePeriodic();
  }

  // exchange(); // Not required since already done via exchangeData() above?
  /*
  IF_CONSTEXPR(!isDetChem<SysEqn>) {
    cutOffBoundaryCondition();
    applyBoundaryCondition();
  }*/

  if(m_zonal) {
    m_wasBalancedZonal = false;
  }

  if(grid().azimuthalPeriodicity()) {
    exchange();
  }

  cutOffBoundaryCondition();
  applyBoundaryCondition();

  // After balance set conservative variables of the cells used for azimuthal (Relevant at cut-off)
  if(grid().azimuthalPeriodicity()) {
    setConservativeVarsOnAzimuthalRecCells();
  }

  // computeConservativeVariables();

  scalarLimiter();

  if(calcSlopesAfterStep()) {
    LSReconstructCellCenter();
    m_fvBndryCnd->copySlopesToSmallCells();
    m_fvBndryCnd->updateGhostCellSlopesInviscid();
    m_fvBndryCnd->updateCutOffSlopesInviscid();
  }

  // Note: from initSolver()
  if(m_combustion && !m_LSSolver) {
    setCellProperties();
    computePrimitiveVariablesCoarseGrid();
    computeConservativeVariables();
  }

  // Note: from initSolver()
  if(m_levelSet && !m_combustion && !m_LSSolver) {
    setCellProperties();
  }

  m_loadBalancingReinitStage = -1;
}


/**
 * \brief  Return decomposition information, i.e. number of local elements,...
 * \author Tim Wegmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getDomainDecompositionInformation(
    std::vector<std::pair<MString, MInt>>& domainInfo) {
  TRACE();

  const MString namePrefix = "b" + std::to_string(solverId()) + "_";

  const MInt noCells = (isActive()) ? grid().noInternalCells() : 0;
  MInt noLeafCells = 0;
  MInt noActiveLeafCells = 0;
  MInt noCutOffCells = 0;
  MInt noBc1601Cells = 0;
  MInt noNearBndryCells = 0;
  MInt noBndrycells = 0;
  MInt noLvlJumpCells = 0;

  if(isActive()) {
    for(MInt cellId = 0; cellId < grid().noInternalCells(); cellId++) {
      if(c_isLeafCell(cellId)) noLeafCells++;
      if(c_isLeafCell(cellId) && !a_hasProperty(cellId, SolverCell::IsInactive)) noActiveLeafCells++;
      if(a_hasProperty(cellId, SolverCell::NearWall)) {
        noNearBndryCells++;
      }
      if(a_bndryId(cellId) > -1 && c_isLeafCell(cellId)) {
        noBndrycells++;
      }
      if(c_isLeafCell(cellId)) {
        MBool atLvlJump = false;
        for(MInt dir = 0; dir < m_noDirs; dir++) {
          if(c_neighborId(cellId, dir, false) < 0 && c_parentId(cellId) > -1
             && c_neighborId(c_parentId(cellId), dir, false) > -1) {
            atLvlJump = true;
            break;
          }
          if(c_neighborId(cellId, dir, false) > -1 && !c_isLeafCell(c_neighborId(cellId, dir, false))) {
            atLvlJump = true;
            break;
          }
        }
        if(atLvlJump) {
          noLvlJumpCells++;
        }
      }
    }
  }

  for(MInt bc = 0; bc < m_fvBndryCnd->m_noCutOffBndryCndIds; bc++) {
    // Note: this also counts halo-cells
    const MInt cutOffSize = m_fvBndryCnd->m_sortedCutOffCells[bc]->size();
    if(bc == m_fvBndryCnd->m_bc1601_bcId) {
      noBc1601Cells = cutOffSize;
    } else {
      noCutOffCells += cutOffSize;
    }
  }


  domainInfo.emplace_back(namePrefix + "noFvCells", noCells);
  domainInfo.emplace_back(namePrefix + "noFvLeafCells", noLeafCells);
  domainInfo.emplace_back(namePrefix + "noFvActiveLeafCells", noActiveLeafCells);

  // Number of Bndry-Cells
  if(m_weightBndryCells) {
    domainInfo.emplace_back(namePrefix + "noFvBndryCells", noBndrycells);
  }

  // Number of cut-off cells
  if(m_weightCutOffCells) {
    domainInfo.emplace_back(namePrefix + "noCutOffCells", noCutOffCells);
  }
  // Number of bc1601 cells (random eddy inflow)
  if(m_weightBc1601) {
    domainInfo.emplace_back(namePrefix + "noBc1601Cells", noBc1601Cells);
  }

  // Number of near Bndry-Cells
  if(m_weightNearBndryCells) {
    domainInfo.emplace_back(namePrefix + "noNearBndryCells", noNearBndryCells);
  }

  // number of inactive cells
  if(m_weightInactiveCell) {
    domainInfo.emplace_back(namePrefix + "noFvInacticeCells", grid().noInternalCells());
  }

  // number of cells at lvl-jumps
  if(m_weightLvlJumps) {
    domainInfo.emplace_back(namePrefix + "noFvLvlJumpCells", noLvlJumpCells);
  }

  // number of small-cells
  if(m_weightSmallCells) {
    domainInfo.emplace_back(namePrefix + "noFvSmallCells", m_fvBndryCnd->m_smallCutCells.size());
  }
}

/**
 * \brief exchanges the Gap-Information with the solver-own communicators!
 * \author Tim Wegmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::exchangeGapInfo() {
  TRACE();

  MIntScratchSpace Gap(a_noCells(), 2, AT_, "Gap");

  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    Gap(cellId, 0) = (MInt)a_isGapCell(cellId);
    Gap(cellId, 1) = (MInt)a_wasGapCell(cellId);
  }

  exchangeDataFV(&Gap(0, 0), 2);

  for(MInt cellId = noInternalCells(); cellId < a_noCells(); cellId++) {
    a_isGapCell(cellId) = (MBool)Gap(cellId, 0);
    a_wasGapCell(cellId) = (MBool)Gap(cellId, 1);
  }
}

/**
 * \brief exchanges isInactive and isOnCurrentMGLevel
 * \author Tim Wegmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::exchangeProperties() {
  TRACE();

  if(noNeighborDomains() == 0) return;

  ScratchSpace<maia::fv::cell::BitsetType> propsBak(a_noCells(), FUN_, "propsBak");

  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    propsBak[0] = a_properties(cellId);
  }

  maia::mpi::exchangeBitset(grid().neighborDomains(), grid().haloCells(), grid().windowCells(), mpiComm(), &propsBak[0],
                            m_cells.size());

  for(MInt cellId = noInternalCells(); cellId < a_noCells(); cellId++) {
    a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) =
        propsBak[cellId][maia::fv::cell::p(SolverCell::IsOnCurrentMGLevel)];
    a_hasProperty(cellId, SolverCell::IsInactive) = propsBak[cellId][maia::fv::cell::p(SolverCell::IsInactive)];
  }
}


/**
 *  * \brief resets all Cut-Off Information
 *           should only be called before the adaptation and balance!
 *   * \author Tim Wegmann
 *    */

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::resetCutOffCells() {
  TRACE();

  // Note: reset only for existing cells and not for maxNoGridCell(), clearing the collector or
  // adding new cells will invalidate the properties anyways
  for(MInt c = 0; c < m_cells.size(); c++) {
    a_hasProperty(c, SolverCell::IsCutOff) = false;
  }

  m_fvBndryCnd->resetCutOff();
}

// ----------------------------------------------------------------------------

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeLimitedSurfaceValues(MInt NotUsed(timerId)) {
  TRACE();

  MInt nghbr0, nghbr1;
  const MInt noPVarIds = PV->noVariables;
  const MInt noSrfcs = a_noSurfaces();
  MInt va0, va1, sl0, sl1, i;
  const MInt surfaceVarMemory = m_surfaceVarMemory;
  const MInt slopeMemory = m_slopeMemory;
  MFloat* surfaceVar = (MFloat*)(&(a_surfaceVariable(0, 0, 0)));
  MFloat* cellSlopes = (MFloat*)(&(a_slope(0, 0, 0)));
  MFloat* dx = (MFloat*)(&(a_surfaceDeltaX(0, 0)));
  //---end of initialization

  va0 = 0;
  va1 = noPVarIds;
  i = 0;

  for(MInt srfcId = 0; srfcId < noSrfcs; srfcId++) {
    // interpolate the primitive variables onto the surface from both sides
    nghbr0 = a_surfaceNghbrCellId(srfcId, 0);
    nghbr1 = a_surfaceNghbrCellId(srfcId, 1);

    sl0 = nghbr0 * slopeMemory;
    sl1 = nghbr1 * slopeMemory;

    // limiting: bounds are MAX(v0,v1) and MIN(v0,v1)
    for(MInt varId = 0; varId < noPVarIds; varId++) {
      surfaceVar[va0 + varId] = a_pvariable(nghbr0, varId) + cellSlopes[sl0] * dx[i] + cellSlopes[sl0 + 1] * dx[i + 1];
      IF_CONSTEXPR(nDim == 3) surfaceVar[va0 + varId] += cellSlopes[sl0 + 2] * dx[i + 2];

      surfaceVar[va0 + varId] =
          mMin(surfaceVar[va0 + varId], mMax(a_pvariable(nghbr0, varId), a_pvariable(nghbr1, varId)));
      surfaceVar[va0 + varId] =
          mMax(surfaceVar[va0 + varId], mMin(a_pvariable(nghbr0, varId), a_pvariable(nghbr1, varId)));

      surfaceVar[va1 + varId] =
          a_pvariable(nghbr1, varId) + cellSlopes[sl1] * dx[i + nDim] + cellSlopes[sl1 + 1] * dx[i + nDim + 1];
      IF_CONSTEXPR(nDim == 3) surfaceVar[va1 + varId] += cellSlopes[sl1 + 2] * dx[i + nDim + 2];

      surfaceVar[va1 + varId] =
          mMin(surfaceVar[va1 + varId], mMax(a_pvariable(nghbr0, varId), a_pvariable(nghbr1, varId)));
      surfaceVar[va1 + varId] =
          mMax(surfaceVar[va1 + varId], mMin(a_pvariable(nghbr0, varId), a_pvariable(nghbr1, varId)));
      sl0 += nDim;
      sl1 += nDim;
    }
    va0 += surfaceVarMemory;
    va1 += surfaceVarMemory;
    i += 2 * nDim;
  }

  // correct the boundary surface values
  m_fvBndryCnd->correctBoundarySurfaceVariables();

  // update the ghost cell slopes for the viscous flux computation
  m_fvBndryCnd->updateGhostCellSlopesViscous();
  m_fvBndryCnd->updateCutOffSlopesViscous();
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeSurfaceValuesLimited(MInt NotUsed(timerId)) {
  TRACE();

  MInt nghbr0, nghbr1;
  const MInt noPVarIds = PV->noVariables;
  const MInt noSrfcs = a_noSurfaces();
  MInt /* cc0, cc1, sc, */ va0, va1, sl0, sl1, i;
  const MInt surfaceVarMemory = m_surfaceVarMemory;
  const MInt slopeMemory = m_slopeMemory;
  MFloat* surfaceVar = (MFloat*)(&(a_surfaceVariable(0, 0, 0)));
  MFloat* cellSlopes = (MFloat*)(&(a_slope(0, 0, 0)));
  MFloat* dx = (MFloat*)(&(a_surfaceDeltaX(0, 0)));
  //---end of initialization

  va0 = 0;
  va1 = noPVarIds;
  // sc = 0;
  i = 0;

  for(MInt srfcId = 0; srfcId < noSrfcs; srfcId++) {
    // interpolate the primitive variables onto the surface from both sides
    nghbr0 = a_surfaceNghbrCellId(srfcId, 0);
    nghbr1 = a_surfaceNghbrCellId(srfcId, 1);

    sl0 = nghbr0 * slopeMemory;
    sl1 = nghbr1 * slopeMemory;
    //    cc0 = nghbr0 * nDim;
    //    cc1 = nghbr1 * nDim;

    /*    MFloat dx0[nDim], dx1[nDim];
        dx0[0] = surfaceCoord[sc] - cellCoord[cc0];
        dx0[1] = surfaceCoord[sc + 1] - cellCoord[cc0 + 1];
    IF_CONSTEXPR(nDim == 3) {
        dx0[2] = surfaceCoord[sc + 2] - cellCoord[cc0 + 2];
    }
        dx1[0] = surfaceCoord[sc] - cellCoord[cc1];
        dx1[1] = surfaceCoord[sc + 1] - cellCoord[cc1 + 1];
    IF_CONSTEXPR(nDim == 3) {
        dx1[2] = surfaceCoord[sc + 2] - cellCoord[cc1 + 2];
    }
    */

    for(MInt varId = 0; varId < noPVarIds; varId++) {
      surfaceVar[va0 + varId] = a_pvariable(nghbr0, varId) + cellSlopes[sl0] * dx[i]      // dx0[0]
                                + cellSlopes[sl0 + 1] * dx[i + 1];                        // dx0[1]
      IF_CONSTEXPR(nDim == 3) surfaceVar[va0 + varId] += cellSlopes[sl0 + 2] * dx[i + 2]; // dx0[2];

      surfaceVar[va1 + varId] = a_pvariable(nghbr1, varId) + cellSlopes[sl1] * dx[i + nDim]      // dx1[0]
                                + cellSlopes[sl1 + 1] * dx[i + nDim + 1];                        // dx1[1]
      IF_CONSTEXPR(nDim == 3) surfaceVar[va1 + varId] += cellSlopes[sl1 + 2] * dx[i + nDim + 2]; // dx1[2];

      // limiter
      if(surfaceVar[va0 + varId] > mMax(a_pvariable(nghbr0, varId), a_pvariable(nghbr1, varId))
         || surfaceVar[va0 + varId] < mMin(a_pvariable(nghbr0, varId), a_pvariable(nghbr1, varId))) {
        surfaceVar[va0 + varId] = a_pvariable(nghbr0, varId);
      }
      if(surfaceVar[va1 + varId] > mMax(a_pvariable(nghbr0, varId), a_pvariable(nghbr1, varId))
         || surfaceVar[va1 + varId] < mMin(a_pvariable(nghbr0, varId), a_pvariable(nghbr1, varId))) {
        surfaceVar[va1 + varId] = a_pvariable(nghbr1, varId);
      }
      sl0 += nDim;
      sl1 += nDim;
      i += 2 * nDim; // TODO labels:FV @ansgar this seems not correct! compare computeLimitedSurfaceValues! -> unify?
    }

    va0 += surfaceVarMemory;
    va1 += surfaceVarMemory;
    // sc += nDim;
  }

  // correct the boundary surface values
  m_fvBndryCnd->correctBoundarySurfaceVariables();

  // update the ghost cell slopes for viscous flux balance
  m_fvBndryCnd->updateGhostCellSlopesViscous();
  m_fvBndryCnd->updateCutOffSlopesViscous();
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeSurfaceValuesLOCD(MInt NotUsed(timerId)) {
  TRACE();

  MInt nghbr0, nghbr1;
  const MInt noPVarIds = PV->noVariables;
  const MInt noSrfcs = a_noSurfaces();
  //  MInt va0, va1;//, sl0, sl1, i;
  const MInt surfaceVarMemory = m_surfaceVarMemory;
  MFloat* surfaceVar = (MFloat*)(&(a_surfaceVariable(0, 0, 0)));
  //---end of initialization

  MInt va0 = 0;
  MInt va1 = noPVarIds;
  //  i = 0;

  for(MInt srfcId = 0; srfcId < noSrfcs; srfcId++) {
    // interpolate the primitive variables onto the surface from both sides
    nghbr0 = a_surfaceNghbrCellId(srfcId, 0);
    nghbr1 = a_surfaceNghbrCellId(srfcId, 1);

    //    sl0 = nghbr0 * slopeMemory;
    //    sl1 = nghbr1 * slopeMemory;

    for(MInt varId = 0; varId < PV->P; varId++) {
      surfaceVar[va0 + varId] = a_pvariable(nghbr0, varId); //
      //                              + cellSlopes[sl0] * dx[i]
      //                              + cellSlopes[sl0 + 1] * dx[i + 1]
      // IF_CONSTEXPR(nDim == 2) {
      //                              ;
      //} else {
      //                              + cellSlopes[sl0 + 2] * dx[i + 2];
      //}
      surfaceVar[va1 + varId] = a_pvariable(nghbr1, varId); //
      //                              + cellSlopes[sl1] * dx[i + nDim]
      //                              + cellSlopes[sl1 + 1] * dx[i + nDim + 1]
      // IF_CONSTEXPR(nDim == 2) {
      //                              ;
      //} else {
      //                              + cellSlopes[sl1 + 2] * dx[i + nDim + 2];
      //}
      //      sl0 += nDim;
      //      sl1 += nDim;
    }
    surfaceVar[va0 + PV->P] = a_pvariable(nghbr0, PV->P);
    surfaceVar[va1 + PV->P] = a_pvariable(nghbr1, PV->P);
    //    sl0 += nDim;
    //    sl1 += nDim;
    for(MInt varId = PV->P + 1; varId < noPVarIds; varId++) {
      surfaceVar[va0 + varId] = a_pvariable(nghbr0, varId); //
      //                              + cellSlopes[sl0] * dx[i]
      //                              + cellSlopes[sl0 + 1] * dx[i + 1]
      // IF_CONSTEXPR(nDim == 2) {
      //                              ;
      //} else {
      //                              + cellSlopes[sl0 + 2] * dx[i + 2];
      //}
      surfaceVar[va1 + varId] = a_pvariable(nghbr1, varId); //
      //                              + cellSlopes[sl1] * dx[i + nDim]
      //                              + cellSlopes[sl1 + 1] * dx[i + nDim + 1]
      // IF_CONSTEXPR(nDim == 2) {
      //                              ;
      //} else {
      //                              + cellSlopes[sl1 + 2] * dx[i + nDim + 2]
      //}
      //      sl0 += nDim;
      //      sl1 += nDim;
    }

    va0 += surfaceVarMemory;
    va1 += surfaceVarMemory;
    //    i += 2 * nDim;
  }

  // correct the boundary surface values
  m_fvBndryCnd->correctBoundarySurfaceVariables();

  // update the ghost cell slopes for the viscous flux computation
  m_fvBndryCnd->updateGhostCellSlopesViscous();
  m_fvBndryCnd->updateCutOffSlopesViscous();
}

// ----------------------------------------------------------------------------

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeReconstructionConstants() {
  TRACE();

  MInt counter;
  const MInt noCells = a_noCells();
  MInt noNghbrIds, nghbrId;
  MInt noUnknowns = 0;
  if(m_orderOfReconstruction == 1) {
    noUnknowns = nDim;
  }
  if(m_orderOfReconstruction == 2) {
    noUnknowns = (nDim == 2) ? 5 : 9;
  }
  MFloat norm, tmp, normi, avg;
  //---

  // (p)reset the reconstruction constants
  for(MInt n = 0; n < nDim * (maxNoGridCells() * m_cells.noRecNghbrs()); n++) {
    // m_reconstructionConstants[n] = -999;
  }

  // cell-center reconstruction
  counter = 0;
  m_reconstructionDataSize = 0;
  avg = F0;
  for(MInt cellId = 0; cellId < noCells; cellId++) {
    a_reconstructionData(cellId) = m_reconstructionDataSize;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      continue;
    }
    if(!a_hasProperty(cellId, SolverCell::IsFlux)) {
      continue;
    }
    if(a_isBndryGhostCell(cellId)) {
      continue;
    }
    //     if( a_hasProperty( cellId , SolverCell::IsCutOff) )
    //       continue;
    if(a_hasProperty(cellId, SolverCell::IsNotGradient)) {
      continue;
    }
    if(a_hasProperty(cellId, SolverCell::IsInvalid)) {
      continue;
    }

    if(a_bndryId(cellId) > -1) {
      if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_linkedCellId > -1) {
        continue;
      }
    }

    // loop over least-squares cell cluster
    noNghbrIds = a_noReconstructionNeighbors(cellId);

    for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
      nghbrId = a_reconstructionNeighborId(cellId, nghbr);
      for(MInt i = 0; i < nDim; i++) {
        m_A[nghbr][i] = a_coordinate(nghbrId, i) - a_coordinate(cellId, i);
      }
      // additional terms for a higher-order reconstruction
      if(m_orderOfReconstruction == 2) {
        for(MInt i = 0; i < nDim; i++) {
          m_A[nghbr][nDim + i] = POW2(a_coordinate(nghbrId, i) - a_coordinate(cellId, i));
        }
        m_A[nghbr][2 * nDim] =
            (a_coordinate(nghbrId, 0) - a_coordinate(cellId, 0)) * (a_coordinate(nghbrId, 1) - a_coordinate(cellId, 1));
        IF_CONSTEXPR(nDim == 3) {
          m_A[nghbr][2 * nDim + 1] = (a_coordinate(nghbrId, 0) - a_coordinate(cellId, 0))
                                     * (a_coordinate(nghbrId, 2) - a_coordinate(cellId, 2));
          m_A[nghbr][2 * nDim + 2] = (a_coordinate(nghbrId, 1) - a_coordinate(cellId, 1))
                                     * (a_coordinate(nghbrId, 2) - a_coordinate(cellId, 2));
        }
      }
    }

    // compute ATA
    for(MInt i = 0; i < noUnknowns; i++) {
      for(MInt j = 0; j < noUnknowns; j++) {
        m_ATA[i][j] = F0;
        for(MInt k = 0; k < noNghbrIds; k++) {
          m_ATA[i][j] += m_A[k][i] * m_A[k][j];
        }
      }
    }

    // invert ATA
    const MFloat epsilon = POW3(c_cellLengthAtLevel(maxRefinementLevel()) / (1000.0));
    if(maia::math::inverse(m_ATA, m_ATAi, noUnknowns, epsilon) == 0) {
      //      cerr << domainId() << ": " << cellId << " " << noNghbrIds << endl;
      mTerm(1, AT_, "error recon");
    }

    // compute the 1-norms of ATA and ATAi
    norm = F0;
    normi = F0;
    for(MInt j = 0; j < noUnknowns; j++) {
      tmp = F0;
      for(MInt i = 0; i < noUnknowns; i++) {
        tmp += ABS(m_ATA[i][j]);
      }
      norm = mMax(norm, tmp);
      normi = mMax(normi, tmp);
    }

    // compute the condition number of ATA
    avg += norm * normi;
    counter++;

    // compute (m_ATA)^(-1) * AT
    for(MInt i = 0; i < noUnknowns; i++) {
      for(MInt j = 0; j < noNghbrIds; j++) {
        m_ATA[i][j] = F0;
        for(MInt k = 0; k < noUnknowns; k++) {
          m_ATA[i][j] += m_ATAi[i][k] * m_A[j][k];
        }
      }
    }

    m_reconstructionConstants.resize(nDim * (m_reconstructionDataSize + noNghbrIds));
    m_reconstructionCellIds.resize(m_reconstructionDataSize + noNghbrIds);
    m_reconstructionNghbrIds.resize(m_reconstructionDataSize + noNghbrIds);

    // loop over least-squares cell cluster
    for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
      nghbrId = a_reconstructionNeighborId(cellId, nghbr);

      // set cell Ids
      m_reconstructionCellIds[m_reconstructionDataSize] = cellId;
      m_reconstructionNghbrIds[m_reconstructionDataSize] = nghbrId;

      // compute the constants
      for(MInt d = 0; d < nDim; d++) {
        m_reconstructionConstants[nDim * m_reconstructionDataSize + d] = m_ATA[d][nghbr];
      }

      m_reconstructionDataSize++;
    }
  }
  a_reconstructionData(noCells) = m_reconstructionDataSize;
  m_log << " -> Least-squares: average condition number of A^T A: " << avg / (MFloat)counter << endl;
}


/**
 * \brief Computes the slopes at the cell centers of only the boundary cells
 *
 * needed if boundary condition has to be applied iteratively to reduce the
 * computational overhead
 *
 * @author Claudia Guenther, April 2010
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::LSReconstructCellCenter_Boundary() {
  TRACE();

  const MInt noCells = m_fvBndryCnd->m_bndryCells->size();
  const MInt noPVars = PV->noVariables;
  const MInt noSlopes = nDim * noPVars;
  const MInt slopeMemory = m_slopeMemory;
  MInt j, cellId, linkedCell;
  MFloat* slope = (MFloat*)(&(a_slope(0, 0, 0)));
  MInt reconstructionDataLocation, nghbrId;
  MInt recCellId;
  //---

  // reset the slopes on the boundary cells
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    j = slopeMemory * cellId;
    for(MInt i = 0; i < noSlopes; i++) {
      slope[j + i] = F0;
    }
  }

  // compute the slopes on all boundary cells on the respective computing level
  for(MInt bndryId = 0; bndryId < noCells; bndryId++) {
    cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      continue;
    }
    linkedCell = m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId;
    recCellId = cellId;
    if(linkedCell > -1) { // use master cell reconstruction neighbors and constants!
      recCellId = linkedCell;
    }
    reconstructionDataLocation = a_reconstructionData(recCellId);
    for(MInt nghbr = 0; nghbr < a_noReconstructionNeighbors(recCellId); nghbr++) {
      nghbrId = a_reconstructionNeighborId(recCellId, nghbr);
      for(MInt var = 0; var < noPVars; var++) {
        for(MInt i = 0; i < nDim; i++) {
          a_slope(cellId, var, i) += m_reconstructionConstants[nDim * reconstructionDataLocation + i]
                                     * (a_pvariable(nghbrId, var) - a_pvariable(recCellId, var));
        }
      }
      reconstructionDataLocation++;
    }
  }
}

// ----------------------------------------------------------------------------

/*
 * \brief generates finite-volume boundary cells and their member variables
 *
 * @author Daniel Hartmann, 22.12.2006, Merry Christmas!
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::generateBndryCells() {
  TRACE();

  m_log << "Generating FV boundary cells..." << endl;

  // TODO labels:FV,DLB skip setting isInterface flag or just perform for halo cells if properties are communicated
  // during DLB
  createBoundaryCells();

  // TODO labels:FV,DLB speed this up for DLB reinitialization!
  m_fvBndryCnd->generateBndryCells();

  m_log << m_fvBndryCnd->m_bndryCells->size() << " boundary cells created" << endl;
}


/**
 * identify and store all direct neighbors
 * function sweeps over all cells except for ghost cells and cells with
 * children and determines all of their direct neighbors
 * neighbor data is stored into two scratch arrays that are allocated by
 * the calling method and transferred
 *
 * @author Daniel Hartmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::findNghbrIds() {
  TRACE();

  // TODO labels:FV replace with cartesiangridproxy version!

  MBool nghbrsFound = false;
  MBool nghbrExist = false;
  const MInt noCellIds = a_noCells();
  const MInt maxNoCells = maxNoGridCells();
  MInt nghbrChildId;
  MInt currentCellId;
  MInt sideId, nghbrSideId;
  MInt bndryId = 0;
  MInt nghbrId = 0;
  MInt smallCell;
  MInt k = 0;
  MInt maxIndex = 0;
  MInt pos = 0;
  MInt tempNghbrs[16];
  MInt tempNghbrs1[16];
  ScratchSpace<MFloat> coordinates(noCellIds * nDim, AT_, "coordinates");
  //---

  if(!m_storeNghbrIds) {
    mAlloc(m_storeNghbrIds, m_noDirs * IPOW2(nDim) * maxNoCells, "m_storeNghbrIds", -1, AT_);
  }
  if(!m_identNghbrIds) {
    mAlloc(m_identNghbrIds, m_noDirs * maxNoCells + 1, "m_identNghbrIds", -1, AT_);
  }


  // ------------------------------------------------------------------------
  // ------------- determine coordinates of grid cell cogs ------------------
  // ------------------------------------------------------------------------

  // for the determination of neighbor relations, the coordinates of the cog
  // of the GRID CELLS must be known
  // the cog of boundary cells is moved to the cog of the fluid part of the
  // respective cells and therefore differs from the cog of the corresponding
  // grid cell

  // loop over all cartesian cells including ghost cells

  // check bndryCellIds...


  for(MInt cellId = 0; cellId < noCellIds; cellId++) {
    // proceed if cell is not a ghost cell
    if(!a_isBndryGhostCell(cellId)) {
      // loop over space dimensions
      for(MInt d = 0; d < nDim; d++) {
        // copy coordinates of cog
        coordinates[cellId * nDim + d] = a_coordinate(cellId, d);

        // correct cog of boundary cells
        if(a_bndryId(cellId) > -1) {
          bndryId = a_bndryId(cellId);

          // correct coordinates in the scratch array
          coordinates[cellId * nDim + d] -= m_fvBndryCnd->m_bndryCells->a[bndryId].m_coordinates[d];
        }
      }
    }
  }

  // correct coordinates of internal cells which are masters of a small cell
  for(MInt smallId = 0; smallId < m_fvBndryCnd->m_smallBndryCells->size(); smallId++) {
    smallCell = m_fvBndryCnd->m_smallBndryCells->a[smallId];
    if(m_fvBndryCnd->m_bndryCells->a[smallCell].m_linkedCellId != -1) {
      if(a_bndryId(m_fvBndryCnd->m_bndryCells->a[smallCell].m_linkedCellId) == -1) {
        for(MInt d = 0; d < nDim; d++) {
          coordinates[(m_fvBndryCnd->m_bndryCells->a[smallCell].m_linkedCellId) * nDim + d] =
              m_fvBndryCnd->m_bndryCells->a[smallCell].m_masterCoordinates[d];
        }
      }
    }
  }

  // ------------------------------------------------------------------------
  // ------------- coordinates of grid cell cogs determined -----------------
  // ------------------------------------------------------------------------

  // ------------------------------------------------------------------------
  // ------------- determine neighbor cell IDs of all cells -----------------
  // ------------------------------------------------------------------------

  // --------- loop over all cartesian cells including ghost cells ----------
  for(MInt cellId = 0; cellId < noCellIds; cellId++) {
    for(MInt dirId = 0; dirId < m_noDirs; dirId++) {
      m_identNghbrIds[cellId * m_noDirs + dirId] = pos;
    }

    // proceed if cell is not a ghost cell
    if(!a_isBndryGhostCell(cellId)) {
      // multilevel
      if(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        // --------------- loop over directions -----------------------------
        for(MInt dirId = 0; dirId < m_noDirs; dirId++) {
          MInt spaceId = dirId / 2;
          sideId = dirId % 2;
          nghbrSideId = (sideId + 1) % 2;

          nghbrExist = false;

          // set the location in m_storeNghbrIds, where neighbors of cellId are
          // stored
          m_identNghbrIds[cellId * m_noDirs + dirId] = pos;

          // ----------------------------------------------------------------
          // --- identify neighbor in considered direction ------------------
          // *-> this can be a neighbor of the cell itself or a neighbor of *
          // *   its parent, grandparent, and so forth                      *
          // ----------------------------------------------------------------

          // check if cell has a neighbor in the investigated
          // direction
          if(a_hasNeighbor(cellId, dirId) > 0) {
            if(a_level(c_neighborId(cellId, dirId)) <= maxRefinementLevel()) {
              // -> cell has a neighbor
              // this neighbor:
              nghbrId = c_neighborId(cellId, dirId);

              // --------------------------------------------------------------
              // --- investigate neighbor -------------------------------------
              // *-> check if neighbor has children, grandchildren, and so    *
              // *   forth, which are direct neighbors of the considered cell *
              // --------------------------------------------------------------
              // multilevel
              if(a_hasProperty(nghbrId, SolverCell::IsOnCurrentMGLevel)) {
                // neighbor is not a parent and can be stored as neighbor of
                // the cell cellId
                m_storeNghbrIds[pos] = nghbrId;
                pos++;

              } else {
                // neighbor is a parent
                // investigate all children and grandchildren

                // temporary array that holds all parent cells to be
                // investigated
                tempNghbrs[0] = nghbrId;
                nghbrsFound = false;

                // ----------------------------------------------------------
                // --- investigate all neighbors that are parents -----------
                // ----------------------------------------------------------

                maxIndex = 1;
                while(nghbrsFound == false) {
                  // initialize counter for the number of investigated
                  // neighboring children that are parents themselves and
                  // thus added to a temporary array
                  k = 0;

                  // ------ loop over all neighbor parents ------------------
                  for(MInt index = 0; index < maxIndex; index++) {
                    // investigated neighbor parent cell
                    ASSERT(index > -1 && index < 16, "");
                    nghbrId = tempNghbrs[index];

                    // check the location of the children within the parent cell
                    // by means of comparison of the grid cell cogs of the
                    // parent cell and the children in considered space direction

                    // in case none of the children is identified
                    // as a direct neighbor, do nothing, since then
                    // the considered cell side is a non-fluid side

                    // --------- loop over neighbor children ----------------
                    for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
                      if(c_childId(nghbrId, childId) == -1) {
                        continue;
                      }

                      if((coordinates[c_childId(nghbrId, childId) * nDim + spaceId]
                          - coordinates[nghbrId * nDim + spaceId])
                             * ((float)nghbrSideId - 0.5)
                         > 0) {
                        nghbrChildId = c_childId(nghbrId, childId);
                        // multilevel
                        if((c_noChildren(nghbrChildId) == 0 && a_level(nghbrChildId) <= maxRefinementLevel())
                           || (c_noChildren(nghbrChildId) > 0 && a_level(nghbrChildId) == maxRefinementLevel())) {
                          // child cell is not a parent and stored
                          // as a neighbor
                          m_storeNghbrIds[pos] = nghbrChildId;
                          pos++;

                        } else {
                          // add child cell to temporary array for
                          // further investigation
                          ASSERT(k > -1 && k < 16,
                                 "Too many local child neighbors. Something might be wrong with "
                                 "your mesh!");
                          tempNghbrs1[k] = nghbrChildId;
                          k++;
                        }
                      }
                    }
                  }

                  maxIndex = k;
                  if(k == 0) {
                    nghbrsFound = true;
                  } else {
                    // transfer the cells collected in tempNghbrs1 to
                    // tempNghbrs
                    for(MInt l = 0; l < k; l++) {
                      ASSERT(l > -1 && l < 16, "");
                      tempNghbrs[l] = tempNghbrs1[l];
                    }
                  }
                }
              }
            }
          } else {
            // -> cell does not have a neighbor of equivalent level
            currentCellId = cellId;

            // loop until a parent is found that has a neighbor in considered
            // direction
            // break when the parent ID becomes -1 (boundary in direction)
            while(nghbrExist == false) {
              // if parent does not exist, break
              if(c_parentId(currentCellId) == -1) {
                break;
              }

              // break if currentCell does not lie at the parent cell face
              // whose normal points to considered direction
              if((coordinates[currentCellId * nDim + spaceId] - coordinates[c_parentId(currentCellId) * nDim + spaceId])
                     * ((float)sideId - 0.5)
                 < 0) {
                break;
              }

              // identify parentId of current cell and store it
              // as current cell
              currentCellId = c_parentId(currentCellId);

              // check if current cell has a neighbor in regarded direction
              if(a_hasNeighbor(currentCellId, dirId) > 0) {
                nghbrExist = true;
                nghbrId = c_neighborId(currentCellId, dirId);
                // store this neighbor if it is regarded - multilevel
                if(a_hasProperty(nghbrId, SolverCell::IsOnCurrentMGLevel)) {
                  m_storeNghbrIds[pos] = nghbrId;
                  pos++;
                }
              }
            }
          }
        }
      }
    }
  }
  m_identNghbrIds[noCellIds * m_noDirs] = pos;
}

/*
template <MInt nDim_, class SysEqn>void FvCartesianSolverXD<nDim,SysEqn>::findNghbrIdsMGC() {
  mTerm(1, "Only available in 3D. MGC not yet implemented in 2D");
}
*/
/** identify and store all direct neighbors which are connected in the fluid
 * function sweeps over all cells except for ghost cells and cells with
 * children and determines all of their direct neighbors
 * neighbor data is stored into two scratch arrays that are allocated by
 * the calling method and transferred
 *
 * requires -1 children!
 * split faces and split cells can only be treated if the neighboring cells
 * are on the same refinement level!
 * @author Daniel Hartmann, modified by Claudia Guenther, Update by Tim Wegmann
 */

template <MInt nDim_, class SysEqn>
inline void FvCartesianSolverXD<nDim_, SysEqn>::findNghbrIdsMGC() {
  IF_CONSTEXPR(nDim == 2) mTerm(1, "Only available in 3D. MGC not yet implemented in 2D");
  TRACE();

  MBool nghbrsFound = false;
  MBool nghbrExist = false;
  const MInt noCellIds = a_noCells();
  const MInt maxNoCells = maxNoGridCells();
  MInt nghbrChildId;
  MInt currentCellId;
  MInt bndryId = 0;
  MInt nghbrBndryId;
  MInt nghbrId = 0;
  MInt k = 0;
  MInt maxIndex = 0;
  MInt pos = 0;
  MIntScratchSpace tempNghbrs_scratch(16, AT_, "tempNghbrs_scratch");
  MIntScratchSpace tempNghbrs1_scratch(16, AT_, "tempNghbrs1_scratch");
  MInt* tempNghbrs = tempNghbrs_scratch.getPointer();
  MInt* tempNghbrs1 = tempNghbrs1_scratch.getPointer();

  const MInt sideToChildren[6][4] = {{0, 2, 4, 6}, {1, 3, 5, 7}, {0, 1, 4, 5},
                                     {2, 3, 6, 7}, {0, 1, 2, 3}, {4, 5, 6, 7}};
  const MInt otherDir[6] = {1, 0, 3, 2, 5, 4};
  const MInt noChildrenPerSide = IPOW2(nDim - 1);
  MBool isNonFluidSide[m_noDirs];
  MBool nonFluidSide = false;

  if(!m_storeNghbrIds) {
    mAlloc(m_storeNghbrIds, m_noDirs * IPOW2(nDim) * maxNoCells, "m_storeNghbrIds", -1, AT_);
  }
  if(!m_identNghbrIds) {
    mAlloc(m_identNghbrIds, m_noDirs * maxNoCells + 1, "m_identNghbrIds", -1, AT_);
  }

  //---

  // ------------------------------------------------------------------------
  // ------------- determine coordinates of grid cell cogs ------------------
  // ------------------------------------------------------------------------

  // for the determination of neighbor relations, the coordinates of the cog
  // of the GRID CELLS is required -> new version has to be called before the
  // cell centroids are moved, or they have to be shifted back before this
  // function is called.

  // loop over all cartesian cells including ghost cells

  // ------------------------------------------------------------------------
  // ------------- determine neighbor cell IDs of all cells -----------------
  // ------------------------------------------------------------------------

  for(MInt cellId = 0; cellId < noCellIds; cellId++) {
    for(MInt dirId = 0; dirId < m_noDirs; dirId++) {
      m_identNghbrIds[cellId * m_noDirs + dirId] = pos;
      isNonFluidSide[dirId] = false;
    }

    bndryId = a_bndryId(cellId);

    if(a_hasProperty(cellId, SolverCell::IsInvalid)) {
      continue;
    }

    if(bndryId > -2) {
      if(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        // initialize nonFluidSide array to delete wrong connections
        if(bndryId > -1) {
          for(MInt face = 0; face < m_noDirs; face++) {
            isNonFluidSide[face] = m_fvBndryCnd->m_bndryCells->a[bndryId].m_externalFaces[face];
          }
        }


        // 1st step: identify potential neighbors -> OK
        // 2nd step: delete neighbor if non fluid side in between -> OK
        // 3rd step: correct split cells
        for(MInt dirId = 0; dirId < m_noDirs; dirId++) {
          nghbrExist = false;

          // set the location in storeNghbrIds, where neighbors of cellId are
          // stored
          m_identNghbrIds[cellId * m_noDirs + dirId] = pos;

          if(isNonFluidSide[dirId]) {
            continue;
          }

          // ----------------------------------------------------------------
          // --- identify neighbor in considered direction ------------------
          // *-> this can be a neighbor of the cell itself or a neighbor of *
          // *   its parent, grandparent, and so forth                      *
          // ----------------------------------------------------------------

          // Timw: use Spliparent for neighbor-search for SplitClones
          MInt gridcellId = cellId;
          if(a_hasProperty(cellId, SolverCell::IsSplitClone)) {
            gridcellId = m_splitChildToSplitCell.find(cellId)->second;
          }
          // check if cell has a neighbor in the investigated
          // direction -> nghbr on the same level (stored in m_nghbrIds)
          if(a_hasNeighbor(gridcellId, dirId) > 0
             && (a_level(c_neighborId(gridcellId, dirId)) <= maxRefinementLevel())) {
            // -> cell has a neighbor
            // this neighbor:
            nghbrId = c_neighborId(gridcellId, dirId);

            // --------------------------------------------------------------
            // --- investigate neighbor -------------------------------------
            // *-> check if neighbor has children, grandchildren, and so    *
            // *   forth, which are direct neighbors of the considered cell *
            // --------------------------------------------------------------
            // multilevel
            if(a_hasProperty(nghbrId, SolverCell::IsOnCurrentMGLevel)) {
              // neighbor is not a parent and can be stored as neighbor of
              // the cell cellId

              // here, special situations for bndry cells can occur! -> nghbr is on same level, so
              // no special treatment concerning levels needed
              if(bndryId > -1) {
                if(m_fvBndryCnd->m_bndryNghbrs[bndryId * 2 * m_noDirs + dirId * 2 + 1] > -1) {
                  // split surface with different neighbors. special treatment.
                  // check if first neighbor is also valid
                  if(m_fvBndryCnd->m_bndryNghbrs[bndryId * 2 * m_noDirs + dirId * 2] > -1) {
                    m_storeNghbrIds[pos] = m_fvBndryCnd->m_bndryNghbrs[bndryId * 2 * m_noDirs + dirId * 2];
                    pos++;
                    if(m_fvBndryCnd->m_bndryNghbrs[bndryId * 2 * m_noDirs + dirId * 2]
                       != m_fvBndryCnd->m_bndryNghbrs[bndryId * 2 * m_noDirs + dirId * 2 + 1]) {
                      m_storeNghbrIds[pos] = m_fvBndryCnd->m_bndryNghbrs[bndryId * 2 * m_noDirs + dirId * 2];
                      pos++;
                    } else {
                      cerr << " warning in findNghbrIdsMGC - assumed split face with two different "
                              "neighbors. But neighbors are identical... "
                           << endl;
                      cerr << " cell: " << cellId << " bndryId: " << bndryId << " dir: " << dirId
                           << " nghbrId: " << nghbrId << " nghbr1 in m_bndryNghbrs: "
                           << m_fvBndryCnd->m_bndryNghbrs[bndryId * 2 * m_noDirs + dirId * 2]
                           << " nghbr2 in m_bndryNghbrs: "
                           << m_fvBndryCnd->m_bndryNghbrs[bndryId * 2 * m_noDirs + dirId * 2 + 1] << endl;
                    }
                  } else {
                    cerr << " cell: " << cellId << " bndryId: " << bndryId << " dir: " << dirId
                         << " nghbrId: " << nghbrId << " nghbr1 in m_bndryNghbrs: "
                         << m_fvBndryCnd->m_bndryNghbrs[bndryId * 2 * m_noDirs + dirId * 2]
                         << " nghbr2 in m_bndryNghbrs: "
                         << m_fvBndryCnd->m_bndryNghbrs[bndryId * 2 * m_noDirs + dirId * 2 + 1] << endl;

                    stringstream errorMessage;
                    errorMessage << " error in findNghbrIdsMGC - assumed fluid side to split "
                                    "relative, but -1 neighbor stored in m_bndryNghbrs... ";
                    mTerm(1, AT_, errorMessage.str());
                  }
                } else if(nghbrId != m_fvBndryCnd->m_bndryNghbrs[bndryId * 2 * m_noDirs + dirId * 2]) {
                  // split neighbor. special treatment
                  // both on same level, not a non fuid side, so neighbor should be ok!
                  // double check nevertheless...
                  if(m_fvBndryCnd->m_bndryNghbrs[bndryId * 2 * m_noDirs + dirId * 2] > -1) {
                    m_storeNghbrIds[pos] = m_fvBndryCnd->m_bndryNghbrs[bndryId * 2 * m_noDirs + dirId * 2];
                    pos++;
                  } else {
                    stringstream errorMessage;
                    errorMessage << "  error in findNghbrIdsMGC - assumed fluid side to split "
                                    "relative, but -1 neighbor stored in m_bndryNghbrs... "
                                 << endl
                                 << " cell: " << cellId << " bndryId: " << bndryId << " dir: " << dirId
                                 << " nghbrId: " << nghbrId << " nghbr in m_bndryNghbrs: "
                                 << m_fvBndryCnd->m_bndryNghbrs[bndryId * 2 * m_noDirs + dirId * 2];
                    mTerm(1, AT_, errorMessage.str());
                  }
                } else {
                  // regular boundary cell
                  // both on the same level, not a non fluid side, so neighbor is ok!
                  m_storeNghbrIds[pos] = nghbrId;
                  pos++;
                }
              } else {
                m_storeNghbrIds[pos] = nghbrId;
                pos++;
              }

            } else { // here, bndry cell treatment not included, so be careful with level changes on
                     // bndry cells!

              // neighbor is a parent
              // investigate all children and grandchildren

              // temporary array that holds all parent cells to be
              // investigated
              tempNghbrs[0] = nghbrId;
              nghbrsFound = false;

              // ----------------------------------------------------------
              // --- investigate all neighbors that are parents -----------
              // ----------------------------------------------------------

              maxIndex = 1;
              while(nghbrsFound == false) {
                // initialize counter for the number of investigated
                // neighboring children that are parents themselves and
                // thus added to a temporary array
                k = 0;

                // ------ loop over all neighbor parents ------------------
                for(MInt index = 0; index < maxIndex; index++) {
                  // investigated neighbor parent cell
                  nghbrId = tempNghbrs[index];

                  if(c_noChildren(nghbrId)) {
                    // in case none of the children is identified
                    // as a direct neighbor, do nothing, since then
                    // the considered cell side is a non-fluid side

                    for(MInt c = 0; c < noChildrenPerSide; c++) {
                      nghbrChildId = c_childId(nghbrId, sideToChildren[otherDir[dirId]][c]);

                      if(nghbrChildId > -1) {
                        // multilevel
                        if((c_noChildren(nghbrChildId) == 0 && a_level(nghbrChildId) <= maxRefinementLevel())
                           || (c_noChildren(nghbrChildId) > 0 && a_level(nghbrChildId) == maxRefinementLevel())) {
                          // child cell is not a parent and stored
                          // as a neighbor

                          // check if a fluid connection exists
                          nghbrBndryId = a_bndryId(nghbrChildId);
                          nonFluidSide = false;
                          if(nghbrBndryId > -1) {
                            if(m_fvBndryCnd->m_bndryCells->a[nghbrBndryId].m_externalFaces[dirId]) {
                              nonFluidSide = true;
                              break;
                            }
                          }
                          if(!nonFluidSide) {
                            m_storeNghbrIds[pos] = nghbrChildId;
                            pos++;
                          }
                        } else {
                          // add child cell to temporary array for
                          // further investigation
                          tempNghbrs1[k] = nghbrChildId;
                          k++;
                        }
                      }
                    }
                  }
                }

                maxIndex = k;
                if(k == 0) {
                  nghbrsFound = true;
                } else {
                  // transfer the cells collected in tempNghbrs1 to
                  // tempNghbrs
                  for(MInt l = 0; l < k; l++) {
                    tempNghbrs[l] = tempNghbrs1[l];
                  }
                }
              }
            }

          } else { // no nghbr on equal level -> nghbr has lower level!

            // -> cell does not have a neighbor of equivalent level
            currentCellId = cellId;
            // Timw: use Spliparent for neighbor-search for SplitClones
            if(a_hasProperty(currentCellId, SolverCell::IsSplitClone)) {
              currentCellId = m_splitChildToSplitCell.find(currentCellId)->second;
            }

            // loop until a parent is found that has a neighbor in considered
            // direction
            // break when the parent ID becomes -1 (boundary in direction)
            while(nghbrExist == false) {
              // if parent does not exist, break
              if(c_parentId(currentCellId) == -1) {
                break;
              }

              // break if currentCell does not lie at the parent cell face
              // whose normal points to considered direction
              for(MInt c = 0; c < noChildrenPerSide; c++) {
                if(currentCellId == c_childId(c_parentId(currentCellId), sideToChildren[dirId][c])) {
                  // identify parentId of current cell and store it
                  // as current cell
                  currentCellId = c_parentId(currentCellId);

                  // check if current cell has a neighbor in regarded direction
                  if(a_hasNeighbor(currentCellId, dirId) > 0) {
                    nghbrExist = true;
                    nghbrId = c_neighborId(currentCellId, dirId);
                    // store this neighbor if it is regarded - multilevel
                    if(a_hasProperty(nghbrId, SolverCell::IsOnCurrentMGLevel)) {
                      // check if a fluid connection exists
                      nghbrBndryId = a_bndryId(nghbrId);
                      nonFluidSide = false;
                      if(nghbrBndryId > -1) {
                        if(m_fvBndryCnd->m_bndryCells->a[nghbrBndryId].m_externalFaces[dirId]) {
                          nonFluidSide = true;
                          break;
                        }
                      }
                      if(!nonFluidSide) {
                        m_storeNghbrIds[pos] = nghbrId;
                        pos++;
                      }
                    }
                  }
                  break;
                }
              }
              break;
            }
          }
        }
      }
    }
  }
  m_identNghbrIds[noCellIds * m_noDirs] = pos;
}

// ----------------------------------------------------------------------------

/*! \brief Obtain list of direct neighbors of given cell.
 *
 * \author Sven Berger
 * \date May 2016
 *
 * \param[in] cellId id of the cell for which all neighbors should be obtained
 * \param[out] nghbrList list of neighboring cells
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::findDirectNghbrs(const MInt cellId, vector<MInt>& nghbrList) {
  // TODO labels:FV replace with cartesiangridproxy version!

  ASSERT(cellId >= 0, "ERROR: Invalid cellId!");

  nghbrList.push_back(cellId);

  // this prevents neighbors to be identified multiple times
  auto uniqueAdd = [&](MInt newElement) {
    auto it = find(nghbrList.begin(), nghbrList.end(), newElement);
    if(it == nghbrList.end() && newElement >= 0) {
      nghbrList.push_back(newElement);
      return true;
    }
    return false;
  };

  ///
  /// Gather all neighbouring cells and Diagonal neighbor(s) in the xy-plane (in total 10 additional cells (3D)):
  ///
  static constexpr MInt diagDirs[4]{3, 2, 0, 1};
  for(MInt dir = 0; dir < 2 * nDim; dir++) {
    // iterate overall direct neighbors
    for(MInt j = m_identNghbrIds[2 * cellId * nDim + dir]; j < m_identNghbrIds[2 * cellId * nDim + dir + 1]; j++) {
      const MInt nghbrId = m_storeNghbrIds[j];
      uniqueAdd(nghbrId);
      if(dir < 4) {
        // add diagonal neighbors in x-y plane
        for(MInt t = m_identNghbrIds[2 * nghbrId * nDim + diagDirs[dir]];
            t < m_identNghbrIds[2 * nghbrId * nDim + diagDirs[dir] + 1];
            t++) {
          const MInt diagNghbr = m_storeNghbrIds[t];
          uniqueAdd(diagNghbr);
        }
      }
    }
  }

  ///
  /// In the 3D case look for additional diagonal and tridiagonal neighbors in the z-directions (in total 16 additional
  /// cells (3D)):
  ///
  IF_CONSTEXPR(nDim == 3) {
    for(MInt dirZ = 4; dirZ < 6; dirZ++) {
      for(MInt j = m_identNghbrIds[2 * cellId * nDim + dirZ]; j < m_identNghbrIds[2 * cellId * nDim + dirZ + 1]; j++) {
        const MInt nghbrIdZ = m_storeNghbrIds[j];
        for(MInt dir = 0; dir < 4; dir++) {
          for(MInt t = m_identNghbrIds[2 * nghbrIdZ * nDim + dir]; t < m_identNghbrIds[2 * nghbrIdZ * nDim + dir + 1];
              t++) {
            const MInt nghbrId = m_storeNghbrIds[t];
            uniqueAdd(nghbrId);
            // tridiagonal neighbors
            for(MInt v = m_identNghbrIds[2 * nghbrId * nDim + diagDirs[dir]];
                v < m_identNghbrIds[2 * nghbrId * nDim + diagDirs[dir] + 1];
                v++) {
              const MInt triDiagNghbrId = m_storeNghbrIds[v];
              uniqueAdd(triDiagNghbrId);
            }
          }
        }
      }
    }
  }
}

/*! \brief Obtain list of neighbors for the given extend.
 *
 * \author Sven Berger
 * \date May 2016
 *
 * \param[in] cellId id of the cell for which all neighbors should be obtained
 * \param[in] layer maximum extend of neighborhood in number of cells
 * \param[out] nghbrList list of neighboring cells
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::findNeighborHood(const MInt cellId, const MInt layer,
                                                          vector<MInt>& nghbrList) {
  ASSERT(layer > 0, "ERROR: Invalid layer!");
  ASSERT(cellId >= 0, "ERROR: Invalid cellId!");

  // TODO labels:FV replace with cartesiangridproxy version!

  // this prevents neighbors to be identified multiple times
  auto uniqueAdd = [&](MInt newElement) {
    auto it = find(nghbrList.begin(), nghbrList.end(), newElement);
    if(it == nghbrList.end() && newElement >= 0) {
      nghbrList.push_back(newElement);
      return true;
    }
    return false;
  };

  vector<MInt> tempNghbrCollection{};

  ///
  /// 1. direct neighbors of cell
  ///
  findDirectNghbrs(cellId, nghbrList);

  ///
  /// 2. increase neighborhood to given size
  ///
  for(MInt currEx = 1; currEx < layer; currEx++) {
    // for each newly found neighbor find all neighbors
    for(auto& nghbr : nghbrList) {
      findDirectNghbrs(nghbr, tempNghbrCollection);
    }
    nghbrList.clear();
    // add all new unique neighbor ids to vector
    for(auto& nghbr : tempNghbrCollection) {
      if(uniqueAdd(nghbr) && currEx + 1 < layer) {
        // optimisation
        nghbrList.push_back(nghbr);
      }
    }
  }
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::writeCenterLineVel() {
  TRACE();
  IF_CONSTEXPR(!hasE<SysEqn>)
  mTerm(1, AT_, "Not compatible with SysEqn without RHO_E!");

  switch(m_writeOutData) {
    case 1: {
      // dynamic pressure
      MFloat rhoU2 = 0;
      for(MInt dimId = 0; dimId < nDim; dimId++)
        rhoU2 += POW2(m_VVInfinity[dimId]);
      rhoU2 *= F1B2 * m_rhoInfinity;

      // write center line data
      ofstream ofl;
      ofl.open("CenterlineData");

      for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
        if(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
          if(fabs(a_coordinate(cellId, 1) - c_cellLengthAtLevel(a_level(cellId) + 1)) < 0.001
             && fabs(a_coordinate(cellId, nDim - 1) - c_cellLengthAtLevel(a_level(cellId) + 1)) < 0.001) {
            for(MInt dimId = 0; dimId < nDim; dimId++)
              ofl << a_coordinate(cellId, dimId) << "  ";
            for(MInt dimId = 0; dimId < nDim; dimId++)
              ofl << a_variable(cellId, CV->RHO_VV[dimId]) / a_variable(cellId, CV->RHO) << "  ";
            ofl << a_variable(cellId, CV->RHO) << "  ";
            ofl << endl;
          }
        }
      }

      // write boundary cell data
      ofstream ofl2;
      MFloat angle;
      const MFloat yOffset = 30.0;
      const MFloat xOffset = 15.028;
      const MFloat radToDeg = 360.0 / (2.0 * PI);
      ofl2.open("BoundaryData");

      for(MInt bndryId = 0; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
        const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
        if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId >= 3000
           && m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_bndryCndId <= 3003) {
          if(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
            // determine angle
            if(a_coordinate(cellId, 1) - yOffset > 0 && a_coordinate(cellId, 0) - xOffset > 0) {
              angle = 180 - radToDeg * atan((a_coordinate(cellId, 1) - yOffset) / (a_coordinate(cellId, 0) - xOffset));
            } else {
              if(a_coordinate(cellId, 1) - yOffset > 0 && a_coordinate(cellId, 0) - xOffset < 0) {
                angle = -radToDeg * atan((a_coordinate(cellId, 1) - yOffset) / (a_coordinate(cellId, 0) - xOffset));
              } else {
                if(a_coordinate(cellId, 1) - yOffset < 0 && a_coordinate(cellId, 0) - xOffset > 0) {
                  angle = 180.0
                          - radToDeg * atan((a_coordinate(cellId, 1) - yOffset) / (a_coordinate(cellId, 0) - xOffset));
                } else {
                  angle = 360.0
                          - radToDeg * atan((a_coordinate(cellId, 1) - yOffset) / (a_coordinate(cellId, 0) - xOffset));
                }
              }
            }

            // calculate velocities
            MFloat vv[nDim];
            MFloat vv2 = 0;
            for(MInt dimId = 0; dimId < nDim; dimId++) {
              vv[dimId] = a_variable(cellId, CV->RHO_VV[dimId]) / a_variable(cellId, CV->RHO);
              vv2 += POW2(vv[dimId]);
            }

            // pressure
            const MFloat p = sysEqn().pressure(a_variable(cellId, CV->RHO), vv2, a_variable(cellId, CV->RHO_E));
            const MFloat cp = (p - m_PInfinity) / rhoU2;

            // Mach number
            const MFloat ma = sqrt(vv2) / sysEqn().speedOfSound(a_variable(cellId, CV->RHO), p);

            ofl2 << angle << "  ";
            for(MInt dimId = 0; dimId < nDim; dimId++)
              ofl << vv[dimId] << "  ";
            ofl2 << cp << "  ";
            ofl2 << ma << "  ";
            for(MInt dimId = 0; dimId < nDim; dimId++)
              ofl << a_coordinate(cellId, dimId) << "  ";
            ofl2 << m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId << "  ";
            ofl2 << endl;
          }
        }
      }
      break;
    }
    case 2: {
      const MInt direction = 1;
      IF_CONSTEXPR(direction >= nDim) mTerm(1, AT_, "direction>=nDim");
      const MFloat coordinate = 100.0;

      fstream ofl;
      stringstream file;
      file << "PlaneData" << domainId();
      ofl.open((file.str()).c_str(), ios::out);

      for(MInt c = 0; c < noInternalCells(); c++) {
        if(c_noChildren(c) > 0) continue;

        if(a_level(c) < 0) continue;

        if(a_coordinate(c, direction) < coordinate) continue;

        if(a_hasNeighbor(c, 2 * direction) > 0) {
          if(a_coordinate(c_neighborId(c, 2 * direction), direction) > coordinate) continue;
        } else {
          continue;
        }

        // Write Ascii file
        for(MInt i = 0; i < nDim; i++)
          ofl << a_coordinate(c, i) << "  ";

        for(MInt v = 0; v < CV->noVariables; v++)
          ofl << a_variable(c, v) << "  ";

        ofl << endl;
      }
      ofl.close();

      break;
    }
    default: {
      stringstream errorMessage;
      errorMessage << "FvCartesianSolverXD::writeCenterLineVel() switch variable 'm_writeOutData' with value "
                   << m_writeOutData << " not matching any case." << endl;
      mTerm(1, AT_, errorMessage.str());
    }
  }
}


/**
 * \fn void FvCartesianSolverXD::setInfinityState()
 * \brief Computes/defines the infinity values/state once and for all
 *        Ideally the infinity variables should not be updated outside of this function!
 * \author Tim Wegmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::setInfinityState() {
  TRACE();

  const MInt noCVars = CV->noVariables;
  const MInt noPVars = PV->noVariables;

  const MFloat gammaMinusOne = m_gamma - 1.0;
  const MFloat gammaPlusOne = m_gamma + 1.0;

  /// 1. set infinity state primitive variables
  m_TInfinity = sysEqn().temperature_IR(m_Ma);
  MFloat UT = m_Ma * sqrt(m_TInfinity);
  m_timeRef = UT;
  // quiescent flow field as infinity state i.e. inifity state is not a function of Ma!
  // => change in infinity primitive variables necessary!
  if(m_initialCondition == 465 || m_initialCondition == 9465) {
    m_TInfinity = 1.0;
    UT = 0;
    m_timeRef = m_Ma;
  }

  m_UInfinity = UT * cos(m_angle[0]) * cos(m_angle[1]);
  m_VInfinity = UT * sin(m_angle[0]) * cos(m_angle[1]);
  IF_CONSTEXPR(nDim == 3) m_WInfinity = UT * sin(m_angle[1]);
  m_VVInfinity[0] = m_UInfinity;
  m_VVInfinity[1] = m_VInfinity;
  IF_CONSTEXPR(nDim == 3) m_VVInfinity[2] = m_WInfinity;
  m_PInfinity = sysEqn().pressure_IR(m_TInfinity);

  m_rhoInfinity = sysEqn().density_IR(m_TInfinity);
  m_rhoUInfinity = m_rhoInfinity * m_UInfinity;
  m_rhoVInfinity = m_rhoInfinity * m_VInfinity;
  IF_CONSTEXPR(nDim == 3) m_rhoWInfinity = m_rhoInfinity * m_WInfinity;
  m_rhoVVInfinity[0] = m_rhoUInfinity;
  m_rhoVVInfinity[1] = m_rhoVInfinity;
  IF_CONSTEXPR(nDim == 3) m_rhoVVInfinity[2] = m_rhoWInfinity;
  // timw: internal energy
  m_rhoEInfinity = m_PInfinity / gammaMinusOne + F1B2 * m_rhoInfinity * POW2(UT);

  // reference enthalpies (needed for combustion computations)
  // timw-enthalpy
  m_hInfinity = m_PInfinity / m_rhoInfinity * m_gamma / gammaMinusOne;

  sysEqn().m_muInfinity = SUTHERLANDLAW(m_TInfinity);
  // heat release model (progress variable) assumption of unity Lewis number Le=1 -> lambda(T)=D(T),
  // see Dissertation D.Hartmann page 13
  m_DInfinity = sysEqn().m_muInfinity; ///< Diffusion time (D) equals convection time (lambda) (mu=lambda)
  // - - assuming m_TInfinity is the temperature of the unburnt gas
  // - - Dth = mue^u / ( rho^u *Pr )
  m_DthInfinity = sysEqn().m_muInfinity / (m_rhoInfinity * m_Pr);
  m_SInfinity = F1 / m_gamma;

  m_deltaP = F0;

  sysEqn().m_Re0 = m_Re * sysEqn().m_muInfinity / (m_rhoInfinity * m_Ma * sqrt(m_TInfinity));
  m_rRe0 = 1. / sysEqn().m_Re0;

  // necessary for FvZonalRTV
  const MFloat lamVisc = SUTHERLANDLAW(m_TInfinity);
  const MFloat chi = 0.1;
  const MFloat nuTilde = chi * (lamVisc / m_rhoInfinity);
  m_nuTildeInfinity = nuTilde;
  //--------------------------------------------------------------------------
  m_kInfinity = F3B2 * POW2(m_turbulenceDegree * m_UInfinity);
  m_omegaInfinity = sqrt(m_kInfinity) / (pow(0.09, 0.25) * m_referenceLength);

  if(m_combustion) {
    setCombustionGequPvVariables();
  }

  MInt SA = nDim;
  // NOTE: set custom values for member variables here to allow enabling ranks during DLB which
  // did not initialize these variables at solver start
  // i.e. update infinity state to special initial-condition treatment!
  switch(m_initialCondition) {
    case 77: {
      // set special properties/setting for this oblique shock initialCondition!

      // TODO labels:FV IC=77 has been adopted from fvsolver2d and it currently works in 3D for the case
      // angle[1]=0
      if(abs(m_angle[1]) > 1e-10) {
        mTerm(1, AT_, "Flow component in z-diection currently not allowed for this IC!");
      }

      /*! \page propertiesFV
        \section shockAlignment
        <code>MInt SA (local variable)</code>\n
        default = none \n
        infinite oblique shock initial condition 77: how is the shock aligned in the grid?
        Possible values are:
        <ul>
        <li>0: shock normal to x axis</li>
        <li>1: shock normal to y axis</li>
        </ul>
        Keywords: <i>FINITE_VOLUME, INITIAL CONDITION, OBLIQUE SHOCK</i>
      */
      SA = Context::getSolverProperty<MInt>("shockAlignment", m_solverId, AT_, &SA);
      if(SA == 2) {
        mTerm(1, AT_, "shockAlignment with z-axis not implemented yet. Feel free to do this.");
      }

      if(m_VVInfinity[PV->VV[SA]] / sysEqn().speedOfSound(m_rhoInfinity, m_PInfinity) <= F1) {
        mTerm(1, AT_, "shock normal Mach number to small");
      }

      MFloat sigma = (MFloat)(2 * SA - 1) * m_angle[0] + (MFloat)(!SA) * PI / F2;
      MFloat strength = POW2(m_Ma * sin(sigma));
      // compute postshock values
      mAlloc(m_postShockPV, noPVars, "m_postShockPV", F0, AT_);
      mAlloc(m_postShockCV, noCVars, "m_postShockCV", F0, AT_);
      // shock density
      m_postShockPV[PV->RHO] = m_rhoInfinity * (gammaPlusOne * strength) / (gammaMinusOne * strength + F2);
      m_postShockCV[CV->RHO] = m_postShockPV[PV->RHO];
      // shock parallel velovity
      m_postShockPV[PV->VV[!SA]] = m_VVInfinity[PV->VV[!SA]];
      m_postShockCV[CV->RHO_VV[!SA]] = m_postShockPV[PV->VV[!SA]] * m_postShockPV[PV->RHO];
      // shock normal velocity
      m_postShockPV[PV->VV[SA]] = m_rhoVVInfinity[CV->RHO_VV[SA]] / m_postShockPV[PV->RHO];
      m_postShockCV[CV->RHO_VV[SA]] = m_rhoVVInfinity[CV->RHO_VV[SA]];
      // spanwise velocity
      IF_CONSTEXPR(nDim == 3) {
        m_postShockPV[PV->VV[2]] = 0.0;
        m_postShockCV[CV->RHO_VV[2]] = 0.0;
      }
      // pressure/energie
      m_postShockPV[PV->P] = m_PInfinity * (F1 - m_gamma + F2 * m_gamma * strength) / gammaPlusOne;
      IF_CONSTEXPR(hasE<SysEqn>)
      m_postShockCV[CV->RHO_E] =
          m_postShockPV[PV->P] / gammaMinusOne
          + F1B2 * m_postShockPV[PV->RHO] * (POW2(m_postShockPV[PV->U]) + POW2(m_postShockPV[PV->V]));

      // branch points
      MInt numBranchPoints = 4;
      MFloatScratchSpace BranchPoints(2, 2, numBranchPoints, AT_, "BranchPoints");
      MFloatScratchSpace kfp_2(nDim, AT_, "kfp_2");
      MFloatScratchSpace kfm_2(nDim, AT_, "kfm_2");
      MFloatScratchSpace ksp_2(nDim, AT_, "ksp_2");
      MFloatScratchSpace ksm_2(nDim, AT_, "ksm_2");
      MFloat beta =
          atan(F2 * (cos(sigma) / sin(sigma)) * (strength - F1) / (POW2(m_Ma) * (m_gamma + cos(F2 * sigma)) + F2));
      // Mach number downstream of the shock wave
      MFloat Ma1_n = m_Ma * sin(sigma);
      MFloat Ma1_t = m_Ma * cos(sigma);
      MFloat Ma2 = sqrt(POW2(m_postShockPV[PV->U]) + POW2(m_postShockPV[PV->V]))
                   / sysEqn().speedOfSound(m_postShockPV[PV->RHO], m_postShockPV[PV->P]);
      if(Ma2 <= F1) mTerm(1, AT_, "postshock Mach number to small");

      MFloat Ma2_n = Ma2 * sin(sigma - beta);
      MFloat Ma2_t = Ma2 * cos(sigma - beta);
      // extrema
      MFloat a = POW2(Ma2) - F1;
      MFloat b = -F2 * Ma2_t;
      MFloat c = F1;
      MFloat d = POW2((b / (F2 * a))) - c / a;

      MFloat ktfm_2 = -b / (F2 * a) - sqrt(d);
      MFloat ktsm_2 = -b / (F2 * a) + sqrt(d);

      kfp_2(0) = sin(sigma - beta) / (Ma2 + F1);
      kfp_2(1) = cos(sigma - beta) / (Ma2 + F1);
      kfm_2(0) = -(Ma2_n - ktfm_2 * Ma2_n * Ma2_t) / (F1 - POW2(Ma2_n));
      kfm_2(1) = ktfm_2;
      ksm_2(0) = -(Ma2_n - ktsm_2 * Ma2_n * Ma2_t) / (F1 - POW2(Ma2_n));
      ksm_2(1) = ktsm_2;
      ksp_2(0) = sin(sigma - beta) / (Ma2 - F1);
      ksp_2(1) = cos(sigma - beta) / (Ma2 - F1);

      MFloatScratchSpace kt_1(4 + 2, AT_, "kt_1");
      kt_1(0) = kfp_2(1) * sqrt(m_TInfinity / (sysEqn().temperature_ES(m_postShockPV[PV->RHO], m_postShockPV[PV->P])));
      kt_1(1) = kfm_2(1) * sqrt(m_TInfinity / (sysEqn().temperature_ES(m_postShockPV[PV->RHO], m_postShockPV[PV->P])));
      kt_1(2) = ksm_2(1) * sqrt(m_TInfinity / (sysEqn().temperature_ES(m_postShockPV[PV->RHO], m_postShockPV[PV->P])));
      kt_1(3) = ksp_2(1) * sqrt(m_TInfinity / (sysEqn().temperature_ES(m_postShockPV[PV->RHO], m_postShockPV[PV->P])));
      kt_1(4) =
          (F1 / Ma2_t) * sqrt(m_TInfinity / (sysEqn().temperature_ES(m_postShockPV[PV->RHO], m_postShockPV[PV->P])));
      kt_1(5) =
          (Ma2_t / (POW2(Ma2) - F1)) * sqrt(sysEqn().temperature_ES(m_postShockPV[PV->RHO], m_postShockPV[PV->P]));
      // BranchPoints
      MInt length_kt_1 = kt_1.size();
      MFloatScratchSpace kn(length_kt_1, 3, AT_, "kn");
      for(MInt i = 0; i < length_kt_1; i++) {
        MFloat kt = kt_1(i);
        MFloat p = F2 * Ma1_n * (F1 - Ma1_t * kt) / (F1 - POW2(Ma1_n));
        //        MFloat q = (2*Ma1_t*kt+POW2(kt*(1-POW2(Ma1_t))))/(1-POW2(Ma1_n));
        MFloat q = (POW2(kt) - POW2(kt * Ma1_t - F1)) / (F1 - POW2(Ma1_n));
        // slow
        kn(i, 0) = (-p / F2) + sqrt(POW2(p / F2) - q);
        // entropy
        kn(i, 1) = (F1 - Ma1_t * kt) / Ma1_n;
        // fast
        kn(i, 2) = (-p / F2) - sqrt(POW2(p / F2) - q);
      }

      m_log << "**************************" << endl;
      m_log << "Postshock Conditions summary" << endl;
      m_log << "**************************" << endl;
      m_log << "TInfinity = " << sysEqn().temperature_ES(m_postShockPV[PV->RHO], m_postShockPV[PV->P]) << endl;
      m_log << "UInfinity = " << m_postShockPV[PV->U] << endl;
      m_log << "VInfinity = " << m_postShockPV[PV->V] << endl;
      IF_CONSTEXPR(nDim == 3) m_log << "WInfinity = " << m_postShockPV[PV->W] << endl;
      m_log << "PInfinity = " << m_postShockPV[PV->P] << endl;
      m_log << "rhoInfinity(PV) = " << m_postShockPV[PV->RHO] << endl;
      m_log << "AInfinity = " << sysEqn().speedOfSound(m_postShockPV[PV->RHO], m_postShockPV[PV->P]) << endl;
      m_log << "Ma = " << Ma2 << endl;
      m_log << "Ma_x = " << m_postShockPV[PV->U] / sysEqn().speedOfSound(m_postShockPV[PV->RHO], m_postShockPV[PV->P])
            << endl;
      m_log << "Ma_y = " << m_postShockPV[PV->V] / sysEqn().speedOfSound(m_postShockPV[PV->RHO], m_postShockPV[PV->P])
            << endl;
      m_log << "rhoInfinity(CV) = " << m_postShockCV[CV->RHO] << endl;
      IF_CONSTEXPR(hasE<SysEqn>)
      m_log << "rhoEInfinity = " << m_postShockCV[CV->RHO_E] << endl;
      m_log << "rhoUInfinity = " << m_postShockCV[CV->RHO_U] << endl;
      m_log << "rhoVInfinity = " << m_postShockCV[CV->RHO_V] << endl;
      IF_CONSTEXPR(nDim == 3) m_log << "rhoWInfinity = " << m_postShockCV[CV->RHO_W] << endl;
      m_log << "******* shock wave *******" << endl;
      m_log << "Ma2 = " << Ma2 << endl;
      m_log << "Ma2_n = " << Ma2_n << endl;
      m_log << "Ma2_t = " << Ma2_t << endl;
      m_log << "sigma = " << 180.0 * sigma / PI << endl;
      m_log << "beta = " << 180.0 * beta / PI << endl;
      m_log << "***** branch points ******" << endl;
      m_log << "canonical form" << endl;
      m_log << "  fast: " << kfp_2(0) << ", " << kfp_2(1) << endl;
      for(MInt us = 0; us < 3; us++) {
        MFloat modeAngle = atan2(kt_1(0), kn(0, us)); // with respect to the shock normal
        m_log << "    upstream mode type " << us - 1
              << ": "
              //<< kn(0,us) << ", " << kt_1(0) << ", "
              << 180.0 * modeAngle / PI << ", " << 180.0 * (modeAngle - (PI / F2 - sigma)) / PI
              << ", " // with repect to flow
              << 180.0 * (SA * PI / F2 + (F1 - SA * F2) * modeAngle) / PI
              << endl; // with respect to x axis (property file)
      }
      m_log << "  slow: " << ksp_2(0) << ", " << ksp_2(1) << endl;
      for(MInt us = 0; us < 3; us++) {
        MFloat modeAngle = atan2(kt_1(3), kn(3, us)); // with respect to the shock normal
        m_log << "    upstream mode type " << us - 1
              << ": "
              //<< kn(3,us) << ", " << kt_1(3) << ", "
              << 180.0 * modeAngle / PI << ", " << 180.0 * (modeAngle - (PI / F2 - sigma)) / PI << ", "
              << 180.0 * (SA * PI / F2 + (F1 - SA * F2) * modeAngle) / PI << endl;
      }
      m_log << "shock aligned form" << endl;
      m_log << "  fast: " << kfm_2(0) << ", " << kfm_2(1) << endl;
      for(MInt us = 0; us < 3; us++) {
        MFloat modeAngle = atan2(kt_1(1), kn(1, us)); // with respect to the shock normal
        m_log << "    upstream mode type " << us - 1
              << ": "
              //<< kn(1,us) << ", " << kt_1(1) << ", "
              << 180.0 * modeAngle / PI << ", " << 180.0 * (modeAngle - (PI / F2 - sigma)) / PI << ", "
              << 180.0 * (SA * PI / F2 + (F1 - SA * F2) * modeAngle) / PI << endl;
      }
      m_log << "  slow: " << ksm_2(0) << ", " << ksm_2(1) << endl;
      for(MInt us = 0; us < 3; us++) {
        MFloat modeAngle = atan2(kt_1(2), kn(2, us)); // with respect to the shock normal
        m_log << "    upstream mode type " << us - 1
              << ": "
              //<< kn(2,us) << ", " << kt_1(2) << ", "
              << 180.0 * modeAngle / PI << ", " << 180.0 * (modeAngle - (PI / F2 - sigma)) / PI << ", "
              << 180.0 * (SA * PI / F2 + (F1 - SA * F2) * modeAngle) / PI << endl;
      }
      m_log << "evanescent cases" << endl;
      m_log << "  zero real number of kn and real(k_ac)==k_en:" << endl;
      for(MInt us = 0; us < 3; us++) {
        MFloat modeAngle = atan2(kt_1(4), kn(4, us)); // with respect to the shock normal
        m_log << "    upstream mode type " << us - 1
              << ": "
              //<< kn(2,us) << ", " << kt_1(2) << ", "
              << 180.0 * modeAngle / PI << ", " << 180.0 * (modeAngle - (PI / F2 - sigma)) / PI << ", "
              << 180.0 * (SA * PI / F2 + (F1 - SA * F2) * modeAngle) / PI << endl;
      }
      m_log << "  real(k_ac)||u and max(imag(kt))" << endl;
      for(MInt us = 0; us < 3; us++) {
        MFloat modeAngle = atan2(kt_1(5), kn(5, us)); // with respect to the shock normal
        m_log << "    upstream mode type " << us - 1
              << ": "
              //<< kn(2,us) << ", " << kt_1(2) << ", "
              << 180.0 * modeAngle / PI << ", " << 180.0 * (modeAngle - (PI / F2 - sigma)) / PI << ", "
              << 180.0 * (SA * PI / F2 + (F1 - SA * F2) * modeAngle) / PI << endl;
      }
      break;
    }

    case 11213:
    case 112123:
    case 112122:
    case 112121:
    case 11212: {
      ASSERT(isDetChem<SysEqn>, "IC not compatible with chosen sysEqn.");

      // set inifinity values
      m_TInfinity = m_detChem.infTemperature;

      // gives velocity as a factor of laminar flame speed
      UT = m_detChem.laminarFlameSpeedFactor * m_oneDimFlame->m_profile.velocity[0];

      MFloat recvVel = UT;
      MPI_Bcast(&recvVel, 1, MPI_DOUBLE, 0, mpiComm(), AT_, "recvVel"); // ensures same value across all ranks

      m_log << "Reconstructed infinity velocity:" << recvVel << endl;

      m_UInfinity = recvVel * cos(m_angle[0]) * cos(m_angle[1]);
      m_VInfinity = recvVel * sin(m_angle[0]) * cos(m_angle[1]);
      IF_CONSTEXPR(nDim == 3) m_WInfinity = recvVel * sin(m_angle[1]);

      m_VVInfinity[0] = m_UInfinity;
      m_VVInfinity[1] = m_VInfinity;
      IF_CONSTEXPR(nDim == 3) m_VVInfinity[2] = m_WInfinity;

      m_PInfinity = m_detChem.infPressure;

#if defined(WITH_CANTERA)
      m_canteraThermo->setState_TPY(m_TInfinity, m_PInfinity, &m_YInfinity[0]);
      sysEqn().m_muInfinity = m_canteraTransport->viscosity();
#endif

      MFloat FmeanMolarWeightInfinity = F0;
      for(MInt s = 0; s < m_noSpecies; s++) {
        FmeanMolarWeightInfinity += m_YInfinity[s] * m_fMolarMass[s];
      }

      MFloat meanMolarWeightInfinity = F1 / FmeanMolarWeightInfinity;

      m_rhoInfinity = m_PInfinity * meanMolarWeightInfinity / m_gasConstant / m_detChem.infTemperature;

      m_rhoUInfinity = m_rhoInfinity * m_UInfinity;
      m_rhoVInfinity = m_rhoInfinity * m_VInfinity;
      IF_CONSTEXPR(nDim == 3) m_rhoWInfinity = m_rhoInfinity * m_WInfinity;

      m_rhoVVInfinity[0] = m_rhoUInfinity;
      m_rhoVVInfinity[1] = m_rhoVInfinity;
      IF_CONSTEXPR(nDim == 3) m_rhoVVInfinity[2] = m_rhoWInfinity;

      const MInt maxLineLength = 256;
      MChar b[maxLineLength];
      snprintf(b, maxLineLength, "rhoInfinity: %.6e | muInfinity: %.6e | uInfinity: %.6e | vInfinity: %.6e |",
               m_rhoInfinity, sysEqn().m_muInfinity, m_UInfinity, m_VInfinity);

      m_log << b << std::endl;

      break;
    }

    case 15: {
      if(!m_levelSetMb) {
        m_rhoInfinity = F1;
        m_PInfinity = sysEqn().p_Ref();
        m_UInfinity = m_Ma;
        m_TInfinity = F1;
        m_rhoUInfinity = m_rhoInfinity * m_UInfinity;
        m_rhoVInfinity = m_rhoInfinity * m_VInfinity;
        m_rhoWInfinity = m_rhoInfinity * m_WInfinity;
        m_rhoEInfinity = m_PInfinity / gammaMinusOne + F1B2 * m_rhoInfinity * POW2(m_Ma);
        m_hInfinity = m_PInfinity / m_rhoInfinity * m_gamma / gammaMinusOne;
        sysEqn().m_Re0 = m_Re * SUTHERLANDLAW(m_TInfinity) / (m_rhoInfinity * m_UInfinity);
        m_timeRef = m_Ma;
      }
      break;
    }
    case 1164: {
      // Jet from (chevron) nozzle
      m_log << "Invalidating infinity variables to prevent/detect their usage for jet "
               "computations with a nozzle ..."
            << std::endl;

      // Case specific constants (see Xia et al 2009)
      // TODO labels:FV @ansgar_mb specify via properties?
      const MFloat T_0 = 286.4;
      const MFloat T_inf = 280.2;
      const MFloat p_0 = 1.78e5;
      const MFloat p_inf = 0.97e5;

      const MFloat temperature_j = m_normJetTemperature * T_inf / T_0;
      m_nozzleExitTemp = temperature_j;

      const MFloat pressure_j = p_inf / (m_gamma * p_0);
      /* m_nozzleExitP = pressure_j; */

      const MFloat rho_j = sysEqn().density_ES(pressure_j, temperature_j);
      m_nozzleExitRho = rho_j;

      const MFloat Ma_j = m_maNozzleExit * sqrt(1.0 / m_normJetTemperature);
      m_nozzleExitMaJet = Ma_j;

      const MFloat u_j = Ma_j * sqrt(temperature_j);
      m_nozzleExitU = u_j;

      const MFloat mu_j = SUTHERLANDLAW(temperature_j);

      m_log << "Ma_j = " << Ma_j << std::endl;
      m_log << "T_j = " << temperature_j << std::endl;
      m_log << "p_j = " << pressure_j << std::endl;
      m_log << "rho_j = " << rho_j << std::endl;
      m_log << "u_j = " << u_j << std::endl;
      m_log << "mu_j = " << mu_j << std::endl;

      sysEqn().m_Re0 = m_Re * mu_j / (rho_j * u_j);
      m_rRe0 = 1. / sysEqn().m_Re0;

      m_log << "Re_0 = " << sysEqn().m_Re0 << std::endl;
      m_log << "Re_j = " << m_Re << " " << (rho_j * u_j) / mu_j << std::endl;

      // Ambient conditions
      const MFloat pressureAmbient = pressure_j;
      const MFloat temperatureAmbient = temperature_j / m_normJetTemperature;
      const MFloat densityAmbient = sysEqn().density_ES(pressureAmbient, temperatureAmbient);

      m_PInfinity = pressureAmbient;
      m_rhoInfinity = densityAmbient;
      m_TInfinity = temperatureAmbient;

      m_log << "T_inf = " << m_TInfinity << std::endl;
      m_log << "p_inf = " << m_PInfinity << std::endl;
      m_log << "rho_inf = " << m_rhoInfinity << std::endl;

      // set m_timeRef = u_j/a0 instead of UT;
      m_timeRef = u_j;
      m_log << "timeRef = " << m_timeRef << std::endl;

      // Determine nozzle inlet Mach number
      MFloat Ma_i = 0.2; // initial guess
      for(MInt n = 0; n < 10; n++) {
        const MFloat tmp = (1.0 + 0.5 * (m_gamma - 1) * POW2(Ma_i));
        const MFloat exponent = -(m_gamma + 1) / (2 * (m_gamma - 1));
        const MFloat fkt_g = POW2(m_outletRadius / m_inletRadius) * m_gamma * pressure_j * Ma_j / sqrt(temperature_j)
                             - Ma_i * pow(tmp, exponent);

        const MFloat diff_g = pow(tmp, exponent) * (-1 + POW2(Ma_i) * 0.5 * (m_gamma + 1.0) / tmp);

        Ma_i = Ma_i - fkt_g / diff_g;
      }

      m_maNozzleInlet = Ma_i;

      const MFloat temperature_i = sysEqn().temperature_IR(Ma_i);
      const MFloat pressure_i = sysEqn().pressure_IR(temperature_i);
      const MFloat density_i = sysEqn().density_ES(pressure_i, temperature_i);
      const MFloat u_i = Ma_i * sqrt(temperature_i);

      m_nozzleInletTemp = temperature_i;
      m_nozzleInletP = pressure_i;
      m_nozzleInletRho = density_i; // = rho_i/rho_0
      m_nozzleInletU = u_i;         //  = u_i/a_0

      m_log << " Ma_i = " << Ma_i << std::endl;
      m_log << " T_i = " << temperature_i << std::endl;
      m_log << " p_i = " << pressure_i << std::endl;
      m_log << " rho_i = " << density_i << std::endl;
      m_log << " u_i = " << u_i << std::endl;

      // Reset all infinity variables (3D) that should not be used anywhere in the computation
      m_UInfinity = u_j;
      m_VInfinity = 0.0;
      m_WInfinity = 0.0;
      m_VVInfinity[0] = m_UInfinity;
      m_VVInfinity[1] = m_VInfinity;
      m_VVInfinity[2] = m_WInfinity;

      m_rhoUInfinity = NAN;
      m_rhoVInfinity = NAN;
      m_rhoWInfinity = NAN;
      m_rhoVVInfinity[0] = m_rhoUInfinity;
      m_rhoVVInfinity[1] = m_rhoVInfinity;
      m_rhoVVInfinity[2] = m_rhoWInfinity;

      m_rhoEInfinity = NAN;

      m_hInfinity = NAN;
      sysEqn().m_muInfinity = NAN;
      m_DInfinity = sysEqn().m_muInfinity;
      m_DthInfinity = NAN;
      m_SInfinity = NAN;
      break;
    }
    case 30: {
      // pressure loss per unit length dp = rho_00 u_tau^2 L / D ) here: D=1.0, L=1;
      // channel: dp = rho_00 u_tau^2 L / D )
      //  m_deltaP = POW2( m_Ma * ReTau * sqrt(m_TInfinity) / m_Re  ) * m_rhoInfinity /
      //  m_referenceLength;
      // pipe: dp = lambda * L/D * rho/2 * u^2, lambda = 0.3164 Re^(-1/4) (Blasius)
      // see test cases
      if(m_restart) {
        // careful, special setting for TINA testcase triggered with TINA_TC keyword!
        IF_CONSTEXPR(nDim == 2) mTerm(-1, "This is a 3D IC!");
        if((string2enum(m_testCaseName) == SUZI_TC) || (string2enum(m_testCaseName) == TINA_TC)) {
          m_deltaP = 64 / sysEqn().m_Re0 * F1 / m_referenceLength * F1B2 * m_rhoInfinity * POW2(UT) / 10.0;
        } else {
          m_deltaP = 64 / sysEqn().m_Re0 * F1 / m_referenceLength * F1B2 * m_rhoInfinity * POW2(UT) / 5.0;
        }
        m_fvBndryCnd->m_deltaP = m_deltaP;
      }
      break;
    }
    case 45300: {
      if(!m_restart) {
        m_rhoInfinity = F1;
        m_PInfinity = sysEqn().p_Ref();
        m_UInfinity = m_Ma;
        m_TInfinity = F1;
        m_rhoUInfinity = m_rhoInfinity * m_UInfinity;
        m_rhoVInfinity = m_rhoInfinity * m_VInfinity;
        m_rhoEInfinity = m_PInfinity / gammaMinusOne + F1B2 * m_rhoInfinity * POW2(UT);
        m_hInfinity = m_PInfinity / m_rhoInfinity * m_gamma / gammaMinusOne;
      }
      break;
    }
    default:
      break;
  }
}

/**
 * \fn void FvCartesianSolverXD<nDim_, SysEqn>::applyInitialCondition()
 * \brief Initializes the entire flow field
 *
 * @author Daniel Hartmann
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::applyInitialCondition() {
  TRACE();

  const MInt noPVars = PV->noVariables;
  const MInt noCVars = CV->noVariables;
  const MFloat gammaMinusOne = m_gamma - 1.0;
  const MFloat FgammaMinusOne = F1 / gammaMinusOne;

  /*! \page propertiesFV
    \section restartInterpolationFromStructured
    <code>MInt FvCartesianSolverXD::restartInterpolationFromStructured </code>\n
    default = <code> 0</code>\n \n
    Restart the computation with an interpolated field from structured solver\n
    from a given donorVars/Grid.\n
    Possible values are:\n
    <ul>
    <li>false: off</li>
    <li>true: on</li>
    </ul>
    Keywords: <i>INTERPOLATION, IO, FINITE_VOLUME</i>
  */
  MBool interpolateSolutionFromStructured = false;
  interpolateSolutionFromStructured = Context::getSolverProperty<MBool>("interpolateSolutionFromStructured", m_solverId,
                                                                        AT_, &interpolateSolutionFromStructured);
  if(interpolateSolutionFromStructured) {
    if(m_restart) mTerm(1, AT_, "'restart' and 'interpolateSolutionFromStructured' activated at the same time!");
    readRANSProfile(this);
    computeConservativeVariables();
    if(m_initialCondition != 999) {
      if(domainId() == 0)
        cout << "\033[0;31m#### WARNING:\033[0m 'interpolateSolutionFromStructured' is set and 'initialCondition!=999'!"
             << endl;
      m_log << "WARNING: 'interpolateSolutionFromStructured' is set and 'initialCondition!=999'!" << endl;
    }
  }

  // initialize the flow field i.e. the variables in all cells
  // at this point no properties should be set anymore!
  // TODO labels:FV,DOC cleanup the initialConditions and move properties-setting to the case statement above!
  if((!m_restart && !m_resetInitialCondition)) {
    // inflow condition
    // ----------------
    switch(m_initialCondition) {
      case 999: {
        break;
      }

      // zero velocity, temperature driven flow for detailed chemistry
      case 11213: {
        ASSERT(isDetChem<SysEqn>, "Only compatible with detailed chemistry equation system");
        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          std::vector<MFloat> PVars(nDim + 2 + m_noSpecies, F0);

          PVars[PV->P] = m_detChem.infPressure;

          for(MInt s = 0; s < m_noSpecies; s++) {
            PVars[PV->Y[s]] = m_oneDimFlame->m_profile.massFractions[s];
          }

          MFloat T = m_oneDimFlame->m_profile.temperature[0];

          for(MInt i = 0; i < nDim; i++) {
            PVars[PV->VV[i]] = F0;
          }

          MFloat FmeanMolarWeight = F0, meanMolarWeight = F0;

          for(MInt s = 0; s < m_noSpecies; s++) {
            FmeanMolarWeight += PVars[PV->Y[s]] * m_fMolarMass[s];
          }
          meanMolarWeight = F1 / FmeanMolarWeight;

          PVars[PV->RHO] = PVars[PV->P] / T * meanMolarWeight / m_gasConstant;

          a_variable(cellId, CV->RHO) = PVars[PV->RHO];

          for(MInt i = 0; i < nDim; i++) {
            a_variable(cellId, CV->RHO_VV[i]) = F0;
          }

          IF_CONSTEXPR(isDetChem<SysEqn> && hasE<SysEqn>) {
            MFloat sensibleEnergy = F0;
            sysEqn().evaluateSensibleEnergy(sensibleEnergy, &PVars[0], meanMolarWeight);
            a_variable(cellId, CV->RHO_E) = PVars[PV->RHO] * sensibleEnergy;
          }

          for(MInt s = 0; s < m_noSpecies; ++s) {
            a_variable(cellId, CV->RHO_Y[s]) = PVars[PV->RHO] * PVars[PV->Y[s]];
          }
        }

        break;
      }
      case 11212: {
        const MInt mainAxis = 0;
        const MFloat gasConstant = m_gasConstant;
        const MFloat fixedTemperatureLocation = m_oneDimFlame->m_fixedTemperatureLocation;
        const MInt oneDGridSize = m_oneDimFlame->m_grid.size();

        // Change such that fixedTemperatureLocation has the local coordinate 0
        // Then move to the local 2D/3D coordinate system (main axis conforming)
        std::vector<MFloat> transformedGrid(oneDGridSize, F0);

        MInt numberPerturbations = 0;
        MBool perturbedFlameFront = false;

        if(Context::propertyExists("perturbedFlameFront", m_solverId))
          perturbedFlameFront = Context::getSolverProperty<MBool>("perturbedFlameFront", m_solverId, AT_);

        // Allows perturbation of flame front
        if(perturbedFlameFront)
          numberPerturbations = Context::propertyLength("flameFrontPerturbationAmplitude", m_solverId);

        std::vector<MFloat> flameFrontPerturbationAmplitude(numberPerturbations, F0);
        std::vector<MFloat> flameFrontPerturbationWaveLength(numberPerturbations, F0);

        for(MInt i = 0; i < numberPerturbations; ++i) {
          flameFrontPerturbationAmplitude[i] =
              Context::getSolverProperty<MFloat>("flameFrontPerturbationAmplitude", m_solverId, AT_, i);
          flameFrontPerturbationWaveLength[i] =
              Context::getSolverProperty<MFloat>("flameFrontPerturbationWaveLength", m_solverId, AT_, i);
        }

        for(MInt i = 0; i < oneDGridSize; ++i) {
          transformedGrid[i] = m_oneDimFlame->m_grid[i] - fixedTemperatureLocation;
        }

        const MFloat oneDGridMin = m_oneDimFlame->m_grid[0] - fixedTemperatureLocation;
        const MFloat oneDGridMax = transformedGrid[oneDGridSize - 1];

        // set inifinity values
        m_TInfinity = m_detChem.infTemperature;

        MFloat UT = m_detChem.laminarFlameSpeedFactor * m_oneDimFlame->m_profile.velocity[0];
        m_UInfinity = UT * cos(m_angle[0]) * cos(m_angle[1]);
        m_VInfinity = UT * sin(m_angle[0]) * cos(m_angle[1]);
        IF_CONSTEXPR(nDim == 3) m_WInfinity = UT * sin(m_angle[1]);

        m_VVInfinity[0] = m_UInfinity;
        m_VVInfinity[1] = m_VInfinity;
        IF_CONSTEXPR(nDim == 3) m_VVInfinity[2] = m_WInfinity;

        m_PInfinity = m_detChem.infPressure;

        MFloat fMeanMolarWeightInfinity = F0;
        for(MInt s = 0; s < m_noSpecies; s++) {
          fMeanMolarWeightInfinity += m_YInfinity[s] * m_fMolarMass[s];
        }

        MFloat meanMolarWeightInfinity = F1 / fMeanMolarWeightInfinity;

        m_rhoInfinity = m_PInfinity * meanMolarWeightInfinity / gasConstant / m_detChem.infTemperature;

        m_rhoUInfinity = m_rhoInfinity * m_UInfinity;
        m_rhoVInfinity = m_rhoInfinity * m_VInfinity;
        IF_CONSTEXPR(nDim == 3) m_rhoWInfinity = m_rhoInfinity * m_WInfinity;

        m_rhoVVInfinity[0] = m_rhoUInfinity;
        m_rhoVVInfinity[1] = m_rhoVInfinity;
        IF_CONSTEXPR(nDim == 3) m_rhoVVInfinity[2] = m_rhoWInfinity;

        std::vector<MFloat> PVars(nDim + 2 + m_noSpecies, F0);
        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          // Coordinate in main axis direction
          MFloat coord = a_coordinate(cellId, mainAxis);
          MFloat tCoord = a_coordinate(cellId, 1);

          for(MInt i = 0; i < numberPerturbations; i++) {
            MFloat wavenumber = F2 * PI / (flameFrontPerturbationWaveLength[i]);
            coord +=
                flameFrontPerturbationAmplitude[i] * m_oneDimFlame->m_laminarFlameThickness * sin(wavenumber * tCoord);
          }

          MFloat FmeanMolarWeight = F0;
          MFloat meanMolarWeight = F0;
          MFloat T, VV;

          PVars[PV->P] = m_detChem.infPressure;

          // cell is in unburnt state (index 0)
          if(coord < oneDGridMin) {
            for(MInt s = 0; s < m_noSpecies; s++) {
              PVars[PV->Y[s]] = m_oneDimFlame->m_profile.massFractions[s];
            }
            T = m_oneDimFlame->m_profile.temperature[0];
            VV = m_detChem.laminarFlameSpeedFactor * m_oneDimFlame->m_profile.velocity[0];

            // cell is in completely burnt state (index oneDGridSize - 1)
          } else if(coord > oneDGridMax) {
            for(MInt s = 0; s < m_noSpecies; s++) {
              PVars[PV->Y[s]] = m_oneDimFlame->m_profile.massFractions[(oneDGridSize - 1) * m_noSpecies + s];
            }
            T = m_oneDimFlame->m_profile.temperature[oneDGridSize - 1];
            VV = m_detChem.laminarFlameSpeedFactor * m_oneDimFlame->m_profile.velocity[oneDGridSize - 1];

            // cell is inside flame front
          } else {
            // binary search
            auto lowerBound = std::lower_bound(transformedGrid.begin(), transformedGrid.end(), coord);
            auto upperBound = std::upper_bound(transformedGrid.begin(), transformedGrid.end(), coord);

            MInt n0 = lowerBound - transformedGrid.begin() - 1;
            MInt n1 = upperBound - transformedGrid.begin();

            MFloat x0 = transformedGrid[n0];
            MFloat x1 = transformedGrid[n1];

            MInt offset0 = m_noSpecies * n0;
            MInt offset1 = m_noSpecies * n1;

            for(MInt s = 0; s < m_noSpecies; s++) {
              MFloat Y_k_0 = m_oneDimFlame->m_profile.massFractions[offset0 + s];
              MFloat Y_k_1 = m_oneDimFlame->m_profile.massFractions[offset1 + s];
              PVars[PV->Y[s]] = Y_k_0 + (coord - x0) / (x1 - x0) * (Y_k_1 - Y_k_0);
            }

            // interpolate 1D Solution of variables on the 2D Grid based on the main axis
            MFloat T0 = m_oneDimFlame->m_profile.temperature[n0];
            MFloat T1 = m_oneDimFlame->m_profile.temperature[n1];

            T = T0 + (coord - x0) / (x1 - x0) * (T1 - T0);

            MFloat VV_0 = m_oneDimFlame->m_profile.velocity[n0];
            MFloat VV_1 = m_oneDimFlame->m_profile.velocity[n1];

            VV = VV_0 + (coord - x0) / (x1 - x0) * (VV_1 - VV_0);
            VV *= m_detChem.laminarFlameSpeedFactor;
          }

          for(MInt s = 0; s < m_noSpecies; s++) {
            FmeanMolarWeight += PVars[PV->Y[s]] * m_fMolarMass[s];
          }
          meanMolarWeight = F1 / FmeanMolarWeight;

          PVars[PV->RHO] = PVars[PV->P] / T * meanMolarWeight / gasConstant;

          a_variable(cellId, CV->RHO) = PVars[PV->RHO];

          for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
            if(spaceId == mainAxis) {
              PVars[CV->RHO_VV[spaceId]] = VV;
              a_variable(cellId, CV->RHO_VV[spaceId]) = PVars[PV->RHO] * VV;
            } else {
              PVars[CV->RHO_VV[spaceId]] = F0;
              a_variable(cellId, CV->RHO_VV[spaceId]) = F0;
            }
          }

          IF_CONSTEXPR(isDetChem<SysEqn> && hasE<SysEqn>) {
            MFloat sensibleEnergy = F0;
            sysEqn().evaluateSensibleEnergy(sensibleEnergy, &PVars[0], meanMolarWeight);
            a_variable(cellId, CV->RHO_E) = PVars[PV->RHO] * sensibleEnergy + 0.5 * PVars[PV->RHO] * POW2(VV);
          }

          for(MInt s = 0; s < m_noSpecies; ++s) {
            a_variable(cellId, CV->RHO_Y[s]) = PVars[PV->RHO] * PVars[PV->Y[s]];
          }
        }

        break;
      }

      /*
      Initial condition for real burner geometry, 2D. Gas sinside the tube is initialized from the 1D-solution of a
      precomputed flame, and outside it is initialized as burnt gas with 0 velocity in all space directions.
      */
      case 112121: {
        const MInt mainAxis = 1;
        const MFloat gasConstant = m_gasConstant;
        const MFloat fixedTemperatureLocation = m_oneDimFlame->m_fixedTemperatureLocation;
        const MInt oneDGridSize = m_oneDimFlame->m_grid.size();

        // Geometry of the burner, corner positions
        // MFloat corner_minus = {0.05, -0.05};
        // MFloat corner_plus = {0.05, 0.05};

        // MFloat cornerY = 0.00095214849;
        MFloat tubeDiameter = 0.0050048822 * 2.001; // slightly bigger
        MFloat flamePosition = 0.00115;

        // Change such that fixedTemperatureLocation has the local coordinate 0
        // Then move to the local 2D/3D coordinate system (main axis conforming)
        std::vector<MFloat> transformedGrid(oneDGridSize, F0);


        for(MInt i = 0; i < oneDGridSize; ++i) {
          transformedGrid[i] = m_oneDimFlame->m_grid[i] - fixedTemperatureLocation;
        }

        const MFloat oneDGridMin = m_oneDimFlame->m_grid[0] - fixedTemperatureLocation;
        const MFloat oneDGridMax = transformedGrid[oneDGridSize - 1];

        // set inifinity values
        m_TInfinity = m_detChem.infTemperature;

        MFloat UT = m_detChem.laminarFlameSpeedFactor * m_oneDimFlame->m_profile.velocity[0];

        MFloat recvVel = UT;
        MPI_Bcast(&recvVel, 1, MPI_DOUBLE, 0, mpiComm(), AT_, "recvVel"); // ensures same value across all ranks

        m_UInfinity = recvVel * cos(m_angle[0]) * cos(m_angle[1]);
        m_VInfinity = recvVel * sin(m_angle[0]) * cos(m_angle[1]);
        IF_CONSTEXPR(nDim == 3) m_WInfinity = recvVel * sin(m_angle[1]);

        m_VVInfinity[0] = m_UInfinity;
        m_VVInfinity[1] = m_VInfinity;
        IF_CONSTEXPR(nDim == 3) m_VVInfinity[2] = m_WInfinity;

        m_PInfinity = m_detChem.infPressure;

        MFloat fMeanMolarWeightInfinity = F0;
        for(MInt s = 0; s < m_noSpecies; s++) {
          fMeanMolarWeightInfinity += m_YInfinity[s] * m_fMolarMass[s];
        }

        MFloat meanMolarWeightInfinity = F1 / fMeanMolarWeightInfinity;

        m_rhoInfinity = m_PInfinity * meanMolarWeightInfinity / gasConstant / m_detChem.infTemperature;

        m_rhoUInfinity = m_rhoInfinity * m_UInfinity;
        m_rhoVInfinity = m_rhoInfinity * m_VInfinity;
        IF_CONSTEXPR(nDim == 3) m_rhoWInfinity = m_rhoInfinity * m_WInfinity;

        m_rhoVVInfinity[0] = m_rhoUInfinity;
        m_rhoVVInfinity[1] = m_rhoVInfinity;
        IF_CONSTEXPR(nDim == 3) m_rhoVVInfinity[2] = m_rhoWInfinity;

        std::vector<MFloat> PVars(nDim + 2 + m_noSpecies, F0);
        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          // Coordinate in main axis direction
          MFloat coord = a_coordinate(cellId, mainAxis);
          MFloat tCoord = a_coordinate(cellId, 0);

          MFloat FmeanMolarWeight = F0;
          MFloat meanMolarWeight = F0;
          MFloat T, VV;

          PVars[PV->P] = m_detChem.infPressure;

          // cell is in unburnt state (index 0)
          if(coord - flamePosition < oneDGridMin) {
            for(MInt s = 0; s < m_noSpecies; s++) {
              PVars[PV->Y[s]] = m_oneDimFlame->m_profile.massFractions[s];
            }
            T = m_oneDimFlame->m_profile.temperature[0];
            VV = m_detChem.laminarFlameSpeedFactor * m_oneDimFlame->m_profile.velocity[0];

            // cell is in completely burnt state (index oneDGridSize - 1)
          } else if(coord - flamePosition > oneDGridMax) {
            for(MInt s = 0; s < m_noSpecies; s++) {
              PVars[PV->Y[s]] = m_oneDimFlame->m_profile.massFractions[(oneDGridSize - 1) * m_noSpecies + s];
            }
            T = m_oneDimFlame->m_profile.temperature[oneDGridSize - 1];
            VV = m_detChem.laminarFlameSpeedFactor * m_oneDimFlame->m_profile.velocity[oneDGridSize - 1];

            // cell is inside flame front
          } else {
            const MFloat transformedCoord = coord - flamePosition;
            // binary search
            auto lowerBound = std::lower_bound(transformedGrid.begin(), transformedGrid.end(), transformedCoord);
            auto upperBound = std::upper_bound(transformedGrid.begin(), transformedGrid.end(), transformedCoord);

            MInt n0 = lowerBound - transformedGrid.begin() - 1;
            MInt n1 = upperBound - transformedGrid.begin();

            MFloat x0 = transformedGrid[n0];
            MFloat x1 = transformedGrid[n1];

            MInt offset0 = m_noSpecies * n0;
            MInt offset1 = m_noSpecies * n1;

            for(MInt s = 0; s < m_noSpecies; s++) {
              MFloat Y_k_0 = m_oneDimFlame->m_profile.massFractions[offset0 + s];
              MFloat Y_k_1 = m_oneDimFlame->m_profile.massFractions[offset1 + s];
              PVars[PV->Y[s]] = Y_k_0 + (transformedCoord - x0) / (x1 - x0) * (Y_k_1 - Y_k_0);
            }

            // interpolate 1D Solution of variables on the 2D Grid based on the main axis
            MFloat T0 = m_oneDimFlame->m_profile.temperature[n0];
            MFloat T1 = m_oneDimFlame->m_profile.temperature[n1];

            T = T0 + (transformedCoord - x0) / (x1 - x0) * (T1 - T0);

            MFloat VV_0 = m_oneDimFlame->m_profile.velocity[n0];
            MFloat VV_1 = m_oneDimFlame->m_profile.velocity[n1];

            VV = VV_0 + (transformedCoord - x0) / (x1 - x0) * (VV_1 - VV_0);
            VV *= m_detChem.laminarFlameSpeedFactor;
          }

          if(abs(tCoord) > tubeDiameter / F2) {
            for(MInt s = 0; s < m_noSpecies; s++) {
              PVars[PV->Y[s]] = m_oneDimFlame->m_profile.massFractions[(oneDGridSize - 1) * m_noSpecies + s];
            }
            T = m_oneDimFlame->m_profile.temperature[oneDGridSize - 1];
            // VV = m_detChem.laminarFlameSpeedFactor * m_oneDimFlame->m_profile.velocity[oneDGridSize - 1];
            VV = F0;
          }

          // override velocity component above given point
          if(coord > 0.001) {
            VV = F0;
          }

          for(MInt s = 0; s < m_noSpecies; s++) {
            FmeanMolarWeight += PVars[PV->Y[s]] * m_fMolarMass[s];
          }
          meanMolarWeight = F1 / FmeanMolarWeight;

          PVars[PV->RHO] = PVars[PV->P] / T * meanMolarWeight / gasConstant;

          a_variable(cellId, CV->RHO) = PVars[PV->RHO];

          for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
            if(spaceId == mainAxis) {
              PVars[CV->RHO_VV[spaceId]] = VV;
              a_variable(cellId, CV->RHO_VV[spaceId]) = PVars[PV->RHO] * VV;
            } else {
              PVars[CV->RHO_VV[spaceId]] = F0;
              a_variable(cellId, CV->RHO_VV[spaceId]) = F0;
            }
          }

          IF_CONSTEXPR(isDetChem<SysEqn> && hasE<SysEqn>) {
            MFloat sensibleEnergy = F0;
            sysEqn().evaluateSensibleEnergy(sensibleEnergy, &PVars[0], meanMolarWeight);
            a_variable(cellId, CV->RHO_E) = PVars[PV->RHO] * sensibleEnergy + 0.5 * PVars[PV->RHO] * POW2(VV);
          }

          for(MInt s = 0; s < m_noSpecies; ++s) {
            a_variable(cellId, CV->RHO_Y[s]) = PVars[PV->RHO] * PVars[PV->Y[s]];
          }
        }

        break;
      }

      // slit flame geometry, no combustion, cold gas
      case 112122: {
        const MInt mainAxis = 1;
        const MFloat gasConstant = m_gasConstant;

        MFloat tubeDiameter = 0.0050048822 * 2.001; // slightly bigger

        // set inifinity values
        m_TInfinity = m_detChem.infTemperature;

        MFloat UT = m_detChem.laminarFlameSpeedFactor * m_oneDimFlame->m_profile.velocity[0];
        m_UInfinity = UT * cos(m_angle[0]) * cos(m_angle[1]);
        m_VInfinity = UT * sin(m_angle[0]) * cos(m_angle[1]);
        IF_CONSTEXPR(nDim == 3) m_WInfinity = UT * sin(m_angle[1]);

        m_VVInfinity[0] = m_UInfinity;
        m_VVInfinity[1] = m_VInfinity;
        IF_CONSTEXPR(nDim == 3) m_VVInfinity[2] = m_WInfinity;

        m_PInfinity = m_detChem.infPressure;

        MFloat fMeanMolarWeightInfinity = F0;
        for(MInt s = 0; s < m_noSpecies; s++) {
          fMeanMolarWeightInfinity += m_YInfinity[s] * m_fMolarMass[s];
        }

        MFloat meanMolarWeightInfinity = F1 / fMeanMolarWeightInfinity;

        m_rhoInfinity = m_PInfinity * meanMolarWeightInfinity / gasConstant / m_detChem.infTemperature;

        m_rhoUInfinity = m_rhoInfinity * m_UInfinity;
        m_rhoVInfinity = m_rhoInfinity * m_VInfinity;
        IF_CONSTEXPR(nDim == 3) m_rhoWInfinity = m_rhoInfinity * m_WInfinity;

        m_rhoVVInfinity[0] = m_rhoUInfinity;
        m_rhoVVInfinity[1] = m_rhoVInfinity;
        IF_CONSTEXPR(nDim == 3) m_rhoVVInfinity[2] = m_rhoWInfinity;

        std::vector<MFloat> PVars(nDim + 2 + m_noSpecies, F0);
        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          // Coordinate in main axis direction
          // MFloat coord = a_coordinate(cellId, mainAxis);
          MFloat tCoord = a_coordinate(cellId, 0);


          MFloat FmeanMolarWeight = F0;
          MFloat meanMolarWeight = F0;
          MFloat T, VV;

          PVars[PV->P] = m_detChem.infPressure;

          // unburnt state (index 0)
          for(MInt s = 0; s < m_noSpecies; s++) {
            PVars[PV->Y[s]] = m_oneDimFlame->m_profile.massFractions[s];
          }
          T = m_oneDimFlame->m_profile.temperature[0];
          VV = m_detChem.laminarFlameSpeedFactor * m_oneDimFlame->m_profile.velocity[0];


          if(abs(tCoord) > tubeDiameter / F2) {
            VV = F0;
          }

          for(MInt s = 0; s < m_noSpecies; s++) {
            FmeanMolarWeight += PVars[PV->Y[s]] * m_fMolarMass[s];
          }
          meanMolarWeight = F1 / FmeanMolarWeight;

          PVars[PV->RHO] = PVars[PV->P] / T * meanMolarWeight / gasConstant;

          a_variable(cellId, CV->RHO) = PVars[PV->RHO];

          for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
            if(spaceId == mainAxis) {
              PVars[CV->RHO_VV[spaceId]] = VV;
              a_variable(cellId, CV->RHO_VV[spaceId]) = PVars[PV->RHO] * VV;
            } else {
              PVars[CV->RHO_VV[spaceId]] = F0;
              a_variable(cellId, CV->RHO_VV[spaceId]) = F0;
            }
          }

          IF_CONSTEXPR(isDetChem<SysEqn> && hasE<SysEqn>) {
            MFloat sensibleEnergy = F0;
            sysEqn().evaluateSensibleEnergy(sensibleEnergy, &PVars[0], meanMolarWeight);
            a_variable(cellId, CV->RHO_E) = PVars[PV->RHO] * sensibleEnergy + 0.5 * PVars[PV->RHO] * POW2(VV);
          }

          for(MInt s = 0; s < m_noSpecies; ++s) {
            a_variable(cellId, CV->RHO_Y[s]) = PVars[PV->RHO] * PVars[PV->Y[s]];
          }
        }

        saveDebugRestartFile();

        break;
      }

      case 0:
      case 465: {
        MFloat rho = m_rhoInfinity;
        if(Context::propertyExists("initialDensity", m_solverId)) {
          rho = Context::getSolverProperty<MFloat>("initialDensity", m_solverId, AT_);
        }
        IF_CONSTEXPR(hasE<SysEqn>) {
          MFloat rhoE = m_rhoEInfinity;
          if(Context::propertyExists("initialPressure", m_solverId)) {
            const MFloat p = Context::getSolverProperty<MFloat>("initialPressure", m_solverId, AT_);
            rhoE = sysEqn().internalEnergy(p, rho, 0);
          }
          for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
            a_variable(cellId, CV->RHO_E) = rhoE;
          }
        }

        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          a_variable(cellId, CV->RHO) = rho;

          for(MInt dir = 0; dir < nDim; dir++) {
            a_variable(cellId, CV->RHO_VV[dir]) = m_rhoVVInfinity[dir];
          }

          IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
            IF_CONSTEXPR(SysEqn::m_ransModel == RANS_SA_DV || SysEqn::m_ransModel == RANS_FS) {
              a_variable(cellId, CV->RHO_N) = m_rhoInfinity * m_nuTildeInfinity;
            }
            IF_CONSTEXPR(SysEqn::m_ransModel == RANS_KOMEGA || SysEqn::m_ransModel == RANS_SST) {
              a_variable(cellId, CV->RHO_K) = m_rhoInfinity * m_kInfinity;
              a_variable(cellId, CV->RHO_OMEGA) = m_rhoInfinity * m_omegaInfinity;
            }
          }

          for(MInt s = 0; s < m_noSpecies; s++) {
            a_variable(cellId, CV->RHO_Y[s]) = 0.0;
          }
        }
        break;
      }

      case 9465: // initial condition 465 adapted for LB-FV-EEGas
      case 90: { // initial condition 0 adapted for LB-FV-EEGas
        IF_CONSTEXPR(!isEEGas<SysEqn>) { mTerm(1, AT_, "Initial condition for Euler-Euler Simulations!"); }
        else {
          for(MInt bndryId = 0; bndryId < m_bndryCells->size(); bndryId++) {
            const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
            for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
              const MInt ghostCellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
              a_alphaGas(ghostCellId) = a_alphaGas(cellId);
            }
          }
          for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
            MFloat alpha = 1.0;
            MFloat p = m_PInfinity;
            MFloat rho = m_rhoInfinity;

            alpha = a_alphaGas(cellId);
            p = a_pvariable(cellId, PV->P);
            if(p < 1e-8 || isnan(p)) {
              p = m_PInfinity;
            }
            rho *= p / m_PInfinity;

            if(hasAV) {
              for(MInt i = 0; i < 3; i++) {
                rho += a_avariable(cellId, AV->DC);
              }
            }

            a_variable(cellId, CV->A_RHO) = rho * alpha;

            for(MInt dir = 0; dir < nDim; dir++) {
              MFloat rhoV = m_rhoVVInfinity[dir] / m_rhoInfinity * rho;
              rhoV *= p / m_PInfinity;
              a_variable(cellId, CV->A_RHO_VV[dir]) = rhoV * alpha;
            }
            a_pvariable(cellId, PV->RHO) = rho;
            a_pvariable(cellId, PV->P) = p;
          }
        }
        break;
      }
      case 33: {
        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          a_variable(cellId, CV->RHO) = F1;
          IF_CONSTEXPR(hasE<SysEqn>)
          a_variable(cellId, CV->RHO_E) = sysEqn().pressureEnergy(sysEqn().p_Ref());
          for(MInt dir = 0; dir < nDim; dir++) {
            a_variable(cellId, CV->RHO_VV[dir]) = F0;
          }
          for(MInt s = 0; s < m_noSpecies; s++) {
            a_variable(cellId, CV->RHO_Y[s]) = 0.5;
          }
          IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
            IF_CONSTEXPR(SysEqn::m_ransModel == RANS_SA_DV || SysEqn::m_ransModel == RANS_FS) {
              a_variable(cellId, CV->RHO_N) = m_rhoInfinity * m_nuTildeInfinity;
            }
            IF_CONSTEXPR(SysEqn::m_ransModel == RANS_KOMEGA || SysEqn::m_ransModel == RANS_SST) {
              a_variable(cellId, CV->RHO_K) = m_rhoInfinity * m_kInfinity;
              a_variable(cellId, CV->RHO_OMEGA) = m_rhoInfinity * m_omegaInfinity;
            }
          }
        }
        break;
      }
      case 123: {
        m_MaHg = Context::getSolverProperty<MFloat>("Ma_Hg", m_solverId, AT_);
        m_THg = sysEqn().temperature_IR(m_MaHg);
        m_UHg = m_MaHg * sqrt(m_THg);
        m_VHg = F0;
        m_WHg = F0;
        m_PHg = sysEqn().pressure_IR(m_THg);
        m_rhoHg = sysEqn().density_IR(m_THg);

        // Cavity
        m_MaCg = Context::getSolverProperty<MFloat>("Ma_Cg", m_solverId, AT_);
        m_TCg = sysEqn().temperature_IR(m_MaCg);
        m_UCg = m_MaCg * sqrt(m_TCg);
        m_VCg = F0;
        m_WCg = F0;
        m_PCg = sysEqn().pressure_IR(m_TCg);
        m_rhoCg = sysEqn().density_IR(m_TCg);

        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          a_variable(cellId, CV->RHO) = m_rhoInfinity;
          IF_CONSTEXPR(hasE<SysEqn>)
          a_variable(cellId, CV->RHO_E) = m_rhoEInfinity;

          for(MInt dir = 0; dir < nDim; dir++) {
            a_variable(cellId, CV->RHO_VV[dir]) = m_rhoVVInfinity[dir];
          }

          IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
            IF_CONSTEXPR(SysEqn::m_ransModel == RANS_SA_DV || SysEqn::m_ransModel == RANS_FS) {
              a_variable(cellId, CV->RHO_N) = m_rhoInfinity * m_nuTildeInfinity;
            }
            IF_CONSTEXPR(SysEqn::m_ransModel == RANS_KOMEGA || SysEqn::m_ransModel == RANS_SST) {
              a_variable(cellId, PV->K) = m_kInfinity;
              a_variable(cellId, PV->OMEGA) = m_omegaInfinity;
            }
          }

          for(MInt s = 0; s < m_noSpecies; s++) {
            a_variable(cellId, CV->RHO_Y[s]) = 0.0;
          }
        }
        break;
      }

      case 124: {
        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          a_pvariable(cellId, PV->RHO) = m_rhoInfinity;
          a_pvariable(cellId, PV->P) = m_PInfinity;
          for(MInt dir = 0; dir < nDim; dir++) {
            a_pvariable(cellId, PV->VV[dir]) = m_VVInfinity[dir];
          }

          IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
            IF_CONSTEXPR(SysEqn::m_ransModel == RANS_SA_DV || SysEqn::m_ransModel == RANS_FS) {
              // a_variable(cellId, PV->N) = m_nuTildeInfinity;
              MFloat r = sqrt(POW2(a_coordinate(cellId, 1)) + POW2(a_coordinate(cellId, 2)));
              a_pvariable(cellId, PV->N) = m_nuTildeInfinity + 10.0 * ((r - 114.2) * exp(-0.06 * pow(r - 114.2, F2)));
              a_pvariable(cellId, PV->VV[0]) = m_UInfinity * (1 - pow((r - 145.1) / 31.2, 10.0));
            }
          }

          for(MInt s = 0; s < m_noSpecies; s++) {
            a_pvariable(cellId, PV->Y[s]) = 0.0;
          }
        }
        computeConservativeVariables();
        break;
      }

      case 45300: {
        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          // quiescent flow field
          a_variable(cellId, CV->RHO) = m_rhoInfinity;

          for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
            a_variable(cellId, CV->RHO_VV[spaceId]) = F0;
          }

          IF_CONSTEXPR(hasE<SysEqn>)
          a_variable(cellId, CV->RHO_E) = m_PInfinity / gammaMinusOne;
        }
        break;
      }

      // strong shock aligned with y axis
      case 77: {
        MInt SA = nDim;
        SA = Context::getSolverProperty<MInt>("shockAlignment", m_solverId, AT_, &SA);

        if(SA == nDim) mTerm(1, AT_, "shockAlignment not set");
        /*! \page propertiesFV
          \section shockCoord
          <code>MFloat shockCoord (local variable)</code>\n
          default = none \n
          infinite oblique shock initial condition 77: position of the shock wave
          Possible value  is a coordinate within the boundaries of the computational domain \n
          Keywords: <i>FINITE_VOLUME, INITIAL CONDITION, OBLIQUE SHOCK</i>
        */
        MFloat shockCoord = Context::getSolverProperty<MFloat>("shockCoord", m_solverId, AT_, &shockCoord);

        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          if(a_coordinate(cellId, SA) < shockCoord) {
            // preshock
            a_variable(cellId, CV->RHO) = m_rhoInfinity;
            for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
              a_variable(cellId, CV->RHO_VV[spaceId]) = m_rhoVVInfinity[spaceId];
            }
            IF_CONSTEXPR(hasE<SysEqn>)
            a_variable(cellId, CV->RHO_E) = m_rhoEInfinity;
          } else {
            // postshock
            for(MInt var = 0; var < noCVars; var++) {
              a_variable(cellId, var) = m_postShockCV[var];
            }
          }
        }
        break;
      }

      // linear shear flow
      case 466: {
        // infinity state is updated here, since particles are initialised
        // on different infinity variables then the flow field!
        m_rhoInfinity = F1;
        m_TInfinity = F1;
        m_PInfinity = sysEqn().pressure_ES(m_TInfinity, m_rhoInfinity);
        m_UInfinity = m_Ma;
        m_rhoUInfinity = m_rhoInfinity * m_UInfinity;
        m_rhoVInfinity = m_rhoInfinity * m_VInfinity;
        m_rhoWInfinity = m_rhoInfinity * m_WInfinity;
        m_rhoEInfinity = sysEqn().internalEnergy(m_PInfinity, m_rhoInfinity, POW2(m_UInfinity));
        m_hInfinity = sysEqn().enthalpy(m_PInfinity, m_rhoInfinity);
        sysEqn().m_Re0 = m_Re * SUTHERLANDLAW(m_TInfinity) / (m_rhoInfinity * m_UInfinity);
        m_timeRef = m_Ma;

        MFloat bbox[2 * nDim];
        m_geometry->getBoundingBox(&bbox[0]);

        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          const MFloat vel = F2 * m_UInfinity * a_coordinate(cellId, 1) / (bbox[1 + nDim] - bbox[1]);
          a_variable(cellId, CV->RHO) = m_rhoInfinity;
          for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
            a_variable(cellId, CV->RHO_VV[spaceId]) = F0;
          }
          a_variable(cellId, CV->RHO_U) = m_rhoInfinity * vel;
          IF_CONSTEXPR(hasE<SysEqn>)
          a_variable(cellId, CV->RHO_E) = m_PInfinity / gammaMinusOne + F1B2 * m_rhoInfinity * POW2(vel);
        }
        break;
      }

      // Note: never used in 2D; this IC is from fvsolver3d
      case 8111: {
        IF_CONSTEXPR(nDim == 2) {
          mTerm(-1, "This IC has been never used in 2D! If you are sure that it works uncomment "
                    "this warning.");
        }
        m_log << "Initial condition 81 maps a solution off a source grid (incl. partition level "
                 "shift) on a target grid";
        m_log << "using nearest neighbor data" << endl;

        if(ParallelIo::fileExists("out/restartVariables_0.Netcdf", mpiComm())) {
          m_log << "get data from own grid" << endl;
          // File loading.
          stringstream variables;

          ParallelIo parallelIo("out/restartVariables_0.Netcdf", maia::parallel_io::PIO_READ, mpiComm());

          // This should be the same for all the variables
          ParallelIo::size_type dimLen = noInternalCells();
          ParallelIo::size_type start = domainOffset(domainId());

          // set offset for all read operations
          parallelIo.setOffset(dimLen, start);

          // Load our variables

          { // Velocity u
            MFloatScratchSpace tmp_velocityU((MInt)dimLen, AT_, "tmp_velocityU");
            parallelIo.readArray(tmp_velocityU.getPointer(), "variables0");
            for(MInt i = 0; i < (MInt)dimLen; ++i) {
              a_pvariable(i, PV->U) = tmp_velocityU.p[i];
            }
          }

          { // Velocity v
            MFloatScratchSpace tmp_velocityV((MInt)dimLen, AT_, "tmp_velocityV");
            parallelIo.readArray(tmp_velocityV.getPointer(), "variables1");
            for(MInt i = 0; i < (MInt)dimLen; ++i) {
              a_pvariable(i, PV->V) = tmp_velocityV.p[i];
            }
          }

          IF_CONSTEXPR(nDim == 3) {
            // Velocity w
            MFloatScratchSpace tmp_velocityW((MInt)dimLen, AT_, "tmp_velocityW");
            parallelIo.readArray(tmp_velocityW.getPointer(), "variables2");
            for(MInt i = 0; i < (MInt)dimLen; ++i) {
              a_pvariable(i, PV->W) = tmp_velocityW.p[i];
            }
          }

          { // Density rho
            MFloatScratchSpace tmp_rho((MInt)dimLen, AT_, "tmp_rho");
            parallelIo.readArray(tmp_rho.getPointer(), "variables3");
            for(MInt i = 0; i < (MInt)dimLen; ++i) {
              a_pvariable(i, PV->RHO) = tmp_rho.p[i];
            }
          }

          { // pressure p
            MFloatScratchSpace tmp_p((MInt)dimLen, AT_, "tmp_p");
            parallelIo.readArray(tmp_p.getPointer(), "variables4");
            for(MInt i = 0; i < (MInt)dimLen; ++i) {
              a_pvariable(i, PV->P) = tmp_p.p[i];
            }
          }

          MPI_Barrier(mpiComm(), AT_);
          m_log << " reading done" << endl;

          exchangeAll();

          MPI_Barrier(mpiComm(), AT_);
          m_log << "exchange done" << endl;

          computeConservativeVariables();

          MPI_Barrier(mpiComm(), AT_);
          m_log << "computeConservativeVariables done" << endl;

          LSReconstructCellCenter();

          break;
        }
        m_log << "get data from other grid" << endl;

        // initialize
        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          // parallel inflow field
          a_pvariable(cellId, PV->RHO) = m_rhoInfinity;
          for(MInt i = 0; i < nDim; i++)
            a_pvariable(cellId, PV->VV[i]) = m_VVInfinity[i];
          a_pvariable(cellId, PV->P) = m_PInfinity;
        }

        // if nearest == 1, the nearest leaf is found, otherwise an inside check is performed,
        // which may result in an endless loop
        // MInt nearestLeaf = 1;
        MInt maxNoCellsToRead = 5 * maxNoGridCells();

        // create src grid
        ParallelIo srcGrid("src/grid.Netcdf", maia::parallel_io::PIO_READ, mpiComm());


        /*! \page propertiesFV
                \section srcFileType
                <code>MInt FvCartesianSolverXD::srcFileType</code>\n
                default = <code>0</code>\n \n
                Defines the srcFileType. \n \n
                Possible values are:
                <ul>
                  <li>0,1,2,3</li>
                </ul>
                Keywords: <i>FINITE_VOLUME, INITIAL_CONDITION, ISOTROPIC, TURBULENCE</i>
              */
        // what src file are we dealing with
        MInt srcFileType = 0;
        srcFileType = Context::getSolverProperty<MInt>("srcFileType", m_solverId, AT_, &srcFileType);

        // src noCells
        MInt srcNoCells;
        srcGrid.readScalar(&srcNoCells, "noCells");

        // - stuff that might needs to be hardcoded for some src grids
        MFloat srcLengthLevel0;
        MFloat srcCenterOfGravity[nDim];
        MInt srcMinLevel;
        MInt srcMaxLevel;
        MFloat fileTypeFac;
        if(srcFileType == 1) { // Thomas
          IF_CONSTEXPR(nDim == 2) mTerm(1, AT_, "Not for 2D!");
          srcLengthLevel0 = 3.5000000032596290112;
          srcCenterOfGravity[0] = 0.021997896999999988488;
          srcCenterOfGravity[1] = 0.0;
          srcCenterOfGravity[2] = 0.0;
          fileTypeFac = 100.0;
          srcMinLevel = 9;
          srcMaxLevel = 11;
        } else if(srcFileType == 2) { // Thomas
          IF_CONSTEXPR(nDim == 2) mTerm(1, AT_, "Not for 2D!");
          srcLengthLevel0 = 3.0000000027939677238;
          srcCenterOfGravity[0] = 0.021997896999999988488;
          srcCenterOfGravity[1] = 0.0;
          srcCenterOfGravity[2] = 0.0;
          fileTypeFac = 100.0;
          srcMinLevel = 9;
          srcMaxLevel = 14;
        } else if(srcFileType == 3) { // Thomas
          IF_CONSTEXPR(nDim == 2) mTerm(1, AT_, "Not for 2D!");
          srcGrid.readScalar(&srcLengthLevel0, "lengthLevel0");
          srcGrid.readScalar(&(srcCenterOfGravity[0]), "CX");
          srcGrid.readScalar(&(srcCenterOfGravity[1]), "CY");
          srcGrid.readScalar(&(srcCenterOfGravity[2]), "CZ");
          fileTypeFac = 100.0;
          srcMinLevel = -1;
          srcMaxLevel = -1;
        } else { // all
          srcGrid.setOffset(nDim, 0);
          srcGrid.readArray(&(srcCenterOfGravity[0]), "centerOfGravity");
          srcGrid.readScalar(&srcLengthLevel0, "lengthLevel0");
          srcGrid.readScalar(&srcMinLevel, "minLevel");
          srcGrid.readScalar(&srcMaxLevel, "maxLevel");
          fileTypeFac = F1;
        }

        srcLengthLevel0 *= fileTypeFac;
        for(MInt dim = 0; dim < nDim; dim++)
          srcCenterOfGravity[dim] *= fileTypeFac;

        m_log << "srcLengthLevel0 = " << srcLengthLevel0 << endl;
        for(MInt dim = 0; dim < nDim; dim++)
          m_log << "srcCenterOfGravity[" << dim << "] =  " << srcCenterOfGravity[dim] << endl;

        MInt srcNmbrPartitionCells = (MInt)srcGrid.getArraySize("partitionCellsId");
        MIntScratchSpace srcPartitionCellsGlobalId(srcNmbrPartitionCells + 1, AT_, "srcPartitionCellsGlobalId");
        srcGrid.setOffset(srcNmbrPartitionCells, 0);
        srcGrid.readArray(srcPartitionCellsGlobalId.begin(), "partitionCellsId");
        srcPartitionCellsGlobalId(srcNmbrPartitionCells) = srcNoCells;

        // src structure, generated once and then saved to an auxiliary file
        // "src/srcPartitionCellsHilbertId"
        //// holds the hilbertIds on the lowest level
        multiset<MInt> srcPartitionCellHilbertIds;
        //// maps hilberIds on higher levels to the srcPartitionCellsId
        vector<multimap<MLong, MInt>> higherLvlPartitionCellHilbertIds;
        // maps local cells to srcPartitionCellIds
        multimap<MInt, MInt> partitionCellsToLoad;
        // misc
        vector<MString> varNames;
        vector<MInt> uncollatedBndryCells;
        vector<MInt> uncollatedCells;

        // this should be a clustered read operation, later ... or never :)
        { // scope start
          MIntScratchSpace srcPartitionCellsHilbertId(srcNmbrPartitionCells, AT_, "srcPartitionCellsHilbertId");
          if(ParallelIo::fileExists("src/srcPartitionCellsHilbertId", mpiComm())) {
            m_log << "read srcPartitionCellHilbertIds ..." << endl;
            ParallelIo srcHilbertId("src/srcPartitionCellsHilbertId", maia::parallel_io::PIO_READ, mpiComm());
            srcHilbertId.setOffset(srcNmbrPartitionCells, 0);
            srcHilbertId.readArray(srcPartitionCellsHilbertId.begin(), "srcPartitionCellsHilbertId");
            // fill the multiset and multimaps
            for(MInt mcCnt = 0; mcCnt < srcNmbrPartitionCells; mcCnt++) {
              multiset<MInt>::iterator it = srcPartitionCellHilbertIds.end();
              srcPartitionCellHilbertIds.insert(it, srcPartitionCellsHilbertId(mcCnt));
            }
            if(srcHilbertId.hasDataset("noHighLevels")) {
              MInt maxLvlDiff = 0;
              srcHilbertId.readScalar(&maxLvlDiff, "noHighLevels");
              for(MInt lDiff = 0; lDiff < maxLvlDiff; lDiff++) {
                higherLvlPartitionCellHilbertIds.push_back(multimap<MLong, MInt>());
                stringstream hilbertStr;
                hilbertStr << "higherLvlHilbertId_" << lDiff;
                stringstream idStr;
                idStr << "partitionCellId_" << lDiff;
                MInt noHighLvl = srcHilbertId.getArraySize(idStr.str());
                srcHilbertId.setOffset(noHighLvl, 0);
                MLongScratchSpace tmpHilbert(noHighLvl, AT_, "tmpHilbert");
                MIntScratchSpace tmpId(noHighLvl, AT_, "tmpId");
                srcHilbertId.readArray(tmpHilbert.begin(), hilbertStr.str());
                srcHilbertId.readArray(tmpId.begin(), idStr.str());
                for(MInt cCnt = 0; cCnt < noHighLvl; cCnt++)
                  higherLvlPartitionCellHilbertIds[lDiff].insert(make_pair(tmpHilbert(cCnt), tmpId(cCnt)));
              }
            }
          } else {
            m_log << "calc srcPartitionCellHilbertIds ..." << endl;
            // distribute partitionCells among processors
            MIntScratchSpace locNoPartitionCells(noDomains(), AT_, "locNoPartitionCells");
            MIntScratchSpace locPartitionCellStart(noDomains(), AT_, "locPartitionCellStart");
            locNoPartitionCells.fill(srcNmbrPartitionCells / noDomains());
            MInt rem = srcNmbrPartitionCells % noDomains();
            for(MInt dId = 0; dId < noDomains(); dId++) {
              locPartitionCellStart(dId) = dId * locNoPartitionCells(dId);
              if(dId < rem) locNoPartitionCells(dId)++;
              if(dId < rem)
                locPartitionCellStart(dId) += dId;
              else
                locPartitionCellStart(dId) += rem;
            }
            m_log << "  " << locNoPartitionCells(domainId()) << " read operations ..." << endl;
            // read partitionCellsLvlDiff info for higher min level information
            MIntScratchSpace srcPartitionCellsLvlDiff(locNoPartitionCells(domainId()), AT_, "srcPartitionCellsLvlDiff");
            srcGrid.setOffset(locNoPartitionCells(domainId()), locPartitionCellStart(domainId()));
            srcGrid.readArray(srcPartitionCellsLvlDiff.begin(), "partitionCellsLvlDiff");
            // get the highest levelDiff
            MInt maxLvlDiff = 0;
            for(MInt cId = 0; cId < locNoPartitionCells(domainId()); cId++) {
              maxLvlDiff = mMax(maxLvlDiff, srcPartitionCellsLvlDiff(cId));
            }
            MPI_Allreduce(MPI_IN_PLACE, &maxLvlDiff, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "maxLvlDiff");
            m_log << "highest partition cell difference is " << maxLvlDiff << endl;
            // compute offsets, local and total required memory
            MIntScratchSpace noHighLvl(maxLvlDiff, AT_, "noHighLvl");
            MIntScratchSpace highLvlOffset(maxLvlDiff, AT_, "highLvlOffset");
            MIntScratchSpace highLvlSum(maxLvlDiff, AT_, "highLvlSum");
            noHighLvl.fill(0);
            highLvlOffset.fill(0);
            highLvlSum.fill(0);
            for(MInt cId = 0; cId < locNoPartitionCells(domainId()); cId++) {
              for(MInt lvlId = 0; lvlId < srcPartitionCellsLvlDiff(cId); lvlId++)
                noHighLvl(lvlId)++;
            }
            for(MInt lvlId = 0; lvlId < maxLvlDiff; lvlId++) {
              MIntScratchSpace highLvlTmp(noDomains(), AT_, "highLvlTmp");
              highLvlTmp.fill(0);
              highLvlTmp(domainId()) = noHighLvl(lvlId);
              MPI_Allgather(MPI_IN_PLACE, 0, MPI_DATATYPE_NULL, highLvlTmp.begin(), 1, MPI_INT, mpiComm(), AT_,
                            "MPI_IN_PLACE", "highLvlTmp.begin()");
              for(MInt dom = 0; dom < domainId(); dom++) {
                highLvlOffset(lvlId) += highLvlTmp(dom);
                highLvlSum(lvlId) += highLvlTmp(dom);
              }
              for(MInt dom = domainId(); dom < noDomains(); dom++)
                highLvlSum(lvlId) += highLvlTmp(dom);
              m_log << "number of higher level hilbert ids to store for lvlDiff " << lvlId + 1 << " is "
                    << highLvlSum(lvlId) << endl;
            }
            // tmp memory for the higher level hilbetIds and corresponding partitionCellIds
            MIntScratchSpace offTotalHigherLvl(maxLvlDiff + 1, AT_, "offTotalHigherLvl");
            offTotalHigherLvl.fill(0);
            for(MInt lDiff = 1; lDiff <= maxLvlDiff; lDiff++)
              for(MInt lDiffi = lDiff; lDiffi <= maxLvlDiff; lDiffi++)
                offTotalHigherLvl(lDiffi) += highLvlSum(lDiff - 1);
            m_log << "higher level offsets in common memory" << endl;
            for(MInt lDiff = 0; lDiff <= maxLvlDiff; lDiff++)
              m_log << offTotalHigherLvl(lDiff) << endl;
            MIntScratchSpace highLvlId(offTotalHigherLvl(maxLvlDiff), AT_, "highLvlId");
            MLongScratchSpace highLvlHilbert(offTotalHigherLvl(maxLvlDiff), AT_,
                                             "highLvlHilbert"); // Long stuff
            highLvlId.fill(0);
            highLvlHilbert.fill(0);
            // ParallelIo variablename stuff
            for(MInt j = 0; j < nDim; ++j) {
              stringstream ss;
              ss << "coordinates_" << j;
              varNames.push_back(ss.str());
              ss.clear();
              ss.str("");
            }
            // counter for the higherLvl information
            MIntScratchSpace highLvlCnt(maxLvlDiff, AT_, "highLvlCnt");
            highLvlCnt.fill(0);
            // action
            for(MInt i = 0; i < locNoPartitionCells(domainId()); i++) {
              MInt mcCnt = locPartitionCellStart(domainId()) + i;
              MFloatScratchSpace srcPartitionCellsCoords(nDim, AT_, "srcPartitionCellsCoords");
              srcGrid.setOffset(1, srcPartitionCellsGlobalId(mcCnt));
              srcGrid.readArray(srcPartitionCellsCoords.begin(), varNames, nDim);
              srcPartitionCellsCoords(0) =
                  (fileTypeFac * srcPartitionCellsCoords(0) - srcCenterOfGravity[0] + srcLengthLevel0 * 0.5)
                  / srcLengthLevel0;
              srcPartitionCellsCoords(1) =
                  (fileTypeFac * srcPartitionCellsCoords(1) - srcCenterOfGravity[1] + srcLengthLevel0 * 0.5)
                  / srcLengthLevel0;
              IF_CONSTEXPR(nDim == 3)
              srcPartitionCellsCoords(2) =
                  (fileTypeFac * srcPartitionCellsCoords(2) - srcCenterOfGravity[2] + srcLengthLevel0 * 0.5)
                  / srcLengthLevel0;
              srcPartitionCellsHilbertId(mcCnt) =
                  maia::grid::hilbert::index<nDim>(&(srcPartitionCellsCoords(0)), srcMinLevel);
              for(MInt lDiff = 0; lDiff < srcPartitionCellsLvlDiff(i); lDiff++) {
                highLvlId(offTotalHigherLvl(lDiff) + highLvlOffset(lDiff) + highLvlCnt(lDiff)) = mcCnt;
                MLong tmpHilbert =
                    maia::grid::hilbert::index<nDim>(&(srcPartitionCellsCoords(0)), (MLong)(srcMinLevel + (lDiff + 1)));
                highLvlHilbert(offTotalHigherLvl(lDiff) + highLvlOffset(lDiff) + highLvlCnt(lDiff)) = tmpHilbert;
                highLvlCnt(lDiff)++;
              }
            }
            if(rem && domainId() >= rem) { // fake reads
              MFloatScratchSpace srcPartitionCellsCoords(nDim, AT_, "srcPartitionCellsCoords");
              srcGrid.setOffset(0, 0);
              srcGrid.readArray(srcPartitionCellsCoords.begin(), varNames, nDim);
            }
            varNames.clear();
            MPI_Barrier(mpiComm(), AT_);
            m_log << "  done" << endl;
            m_log << "  writing hilbert ids to file ..." << endl;
            // save lowest Lvl HilbertIds
            ParallelIo srcHilbertId("src/srcPartitionCellsHilbertId", maia::parallel_io::PIO_CREATE, mpiComm());
            // define arrays
            srcHilbertId.defineArray(maia::parallel_io::PIO_INT, "srcPartitionCellsHilbertId", srcNmbrPartitionCells);
            for(MInt lDiff = 0; lDiff < maxLvlDiff; lDiff++) {
              stringstream hilbertStr;
              hilbertStr << "higherLvlHilbertId_" << lDiff;
              stringstream idStr;
              idStr << "partitionCellId_" << lDiff;
              srcHilbertId.defineArray(maia::parallel_io::PIO_LONG, hilbertStr.str(), highLvlSum(lDiff));
              srcHilbertId.defineArray(maia::parallel_io::PIO_INT, idStr.str(), highLvlSum(lDiff));
            }
            // define scalars
            if(maxLvlDiff) srcHilbertId.defineScalar(maia::parallel_io::PIO_INT, "noHighLevels");
            // write lowest level
            srcHilbertId.setOffset(locNoPartitionCells(domainId()), locPartitionCellStart(domainId()));
            srcHilbertId.writeArray(srcPartitionCellsHilbertId.begin() + locPartitionCellStart(domainId()),
                                    "srcPartitionCellsHilbertId");
            // write the higher Lvl HilberIds and corresponding partitionCellIds (count not
            // globalId)
            for(MInt lDiff = 0; lDiff < maxLvlDiff; lDiff++) {
              stringstream hilbertStr;
              hilbertStr << "higherLvlHilbertId_" << lDiff;
              stringstream idStr;
              idStr << "partitionCellId_" << lDiff;
              srcHilbertId.setOffset(noHighLvl(lDiff), highLvlOffset(lDiff));
              srcHilbertId.writeArray(highLvlHilbert.begin() + offTotalHigherLvl(lDiff) + highLvlOffset(lDiff),
                                      hilbertStr.str());
              srcHilbertId.writeArray(highLvlId.begin() + offTotalHigherLvl(lDiff) + highLvlOffset(lDiff), idStr.str());
            }
            // write scalars
            if(maxLvlDiff) srcHilbertId.writeScalar(maxLvlDiff, "noHighLevels");
            // communicate the ids
            MPI_Barrier(mpiComm(), AT_);
            m_log << "  done" << endl;
            m_log << "  exchange hilbert ids ..." << endl;
            MPI_Allgatherv(MPI_IN_PLACE, 0, MPI_DATATYPE_NULL, srcPartitionCellsHilbertId.begin(),
                           locNoPartitionCells.begin(), locPartitionCellStart.begin(), MPI_INT, mpiComm(), AT_,
                           "MPI_IN_PLACE", "srcPartitionCellsHilbertId.begin()");
            for(MInt lDiff = 0; lDiff < maxLvlDiff; lDiff++) {
              MIntScratchSpace noHighLvlTmp(noDomains(), AT_, "noHighLvlTmp");
              MIntScratchSpace offHighLvlTmp(noDomains(), AT_, "offHighLvlTmp");
              noHighLvlTmp.fill(0);
              offHighLvlTmp.fill(0);
              noHighLvlTmp(domainId()) = noHighLvl(lDiff);
              MPI_Allgather(MPI_IN_PLACE, 0, MPI_DATATYPE_NULL, noHighLvlTmp.begin(), 1, MPI_INT, mpiComm(), AT_,
                            "MPI_IN_PLACE", "noHighLvlTmp.begin()");
              for(MInt dom = 1; dom < noDomains(); dom++) {
                offHighLvlTmp(dom) = offHighLvlTmp(dom - 1) + noHighLvlTmp(dom - 1);
              }
              MPI_Allgatherv(MPI_IN_PLACE, 0, MPI_DATATYPE_NULL, highLvlHilbert.begin() + offTotalHigherLvl(lDiff),
                             noHighLvlTmp.begin(), offHighLvlTmp.begin(), MPI_LONG, mpiComm(), AT_, "MPI_IN_PLACE",
                             "highLvlHilbert.begin() + offTotalHigherLvl(lDiff)");
              MPI_Allgatherv(MPI_IN_PLACE, 0, MPI_DATATYPE_NULL, highLvlId.begin() + offTotalHigherLvl(lDiff),
                             noHighLvlTmp.begin(), offHighLvlTmp.begin(), MPI_INT, mpiComm(), AT_, "MPI_IN_PLACE",
                             "highLvlId.begin() + offTotalHigherLvl(lDiff)");
            }
            MPI_Barrier(mpiComm(), AT_);
            m_log << "  done" << endl;
            // fill the multiset and multimaps
            for(MInt mcCnt = 0; mcCnt < srcNmbrPartitionCells; mcCnt++) {
              multiset<MInt>::iterator it = srcPartitionCellHilbertIds.end();
              srcPartitionCellHilbertIds.insert(it, srcPartitionCellsHilbertId(mcCnt));
            }
            for(MInt lDiff = 0; lDiff < maxLvlDiff; lDiff++) {
              higherLvlPartitionCellHilbertIds.push_back(multimap<MLong, MInt>());
              for(MInt cCnt = 0; cCnt < highLvlSum(lDiff); cCnt++) {
                higherLvlPartitionCellHilbertIds[lDiff].insert(make_pair(
                    highLvlHilbert(offTotalHigherLvl(lDiff) + cCnt), highLvlId(offTotalHigherLvl(lDiff) + cCnt)));
              }
            }
          }
        } // scope end
        MPI_Barrier(mpiComm(), AT_);
        m_log << "done" << endl;

        m_log << "create connectivity multimap ..." << endl;
        for(MInt cid = 0; cid < noInternalCells(); cid++) {
          if(c_noChildren(cid) > 0) continue;
          MFloatScratchSpace xyz(nDim, AT_, "xyz");
          xyz(0) = (a_coordinate(cid, 0) - srcCenterOfGravity[0] + srcLengthLevel0 * 0.5) / srcLengthLevel0;
          xyz(1) = (a_coordinate(cid, 1) - srcCenterOfGravity[1] + srcLengthLevel0 * 0.5) / srcLengthLevel0;
          IF_CONSTEXPR(nDim == 3)
          xyz(2) = (a_coordinate(cid, 2) - srcCenterOfGravity[2] + srcLengthLevel0 * 0.5) / srcLengthLevel0;
          MInt retVal = maia::grid::hilbert::index<nDim>(&(xyz(0)), srcMinLevel);

          pair<multiset<MInt>::iterator, multiset<MInt>::iterator> itPair =
              srcPartitionCellHilbertIds.equal_range(retVal);


          if(itPair.first == itPair.second) {
            if(a_bndryId(cid) > -1) {
              uncollatedBndryCells.push_back(cid);
            } else {
              uncollatedCells.push_back(cid);
            }
          } else if(distance(itPair.first, itPair.second) == 1) {
            MInt locSrcPartitionCellId = distance(srcPartitionCellHilbertIds.begin(), itPair.first);
            partitionCellsToLoad.insert(make_pair(locSrcPartitionCellId, cid)); // (srcPartitionCellId,cellId)
          } else {                                                              // partition level shift
            for(MInt lDiff = 0; lDiff < (MInt)higherLvlPartitionCellHilbertIds.size(); lDiff++) {
              MLong highRetVal = maia::grid::hilbert::index<nDim>(&(xyz(0)), (MLong)(srcMinLevel + (lDiff + 1)));
              pair<multimap<MLong, MInt>::iterator, multimap<MLong, MInt>::iterator> highItPair =
                  higherLvlPartitionCellHilbertIds[lDiff].equal_range(highRetVal);
              if(highItPair.first == highItPair.second) {
                if(a_bndryId(cid) > -1) {
                  uncollatedBndryCells.push_back(cid);
                } else {
                  uncollatedCells.push_back(cid);
                }
                break;
              } else if(distance(highItPair.first, highItPair.second) == 1) {
                MInt locSrcPartitionCellId = highItPair.first->second;
                partitionCellsToLoad.insert(make_pair(locSrcPartitionCellId, cid)); // (srcPartitionCellId,cellId)
                break;
              } else {
                if(lDiff == (MInt)higherLvlPartitionCellHilbertIds.size() - 1)
                  mTerm(1, "this should not happen, there should not be identical hilbertIds on "
                           "the highest level");
              }
            }
          }
        }
        MPI_Barrier(mpiComm(), AT_);
        m_log << "done" << endl;

        m_log << "cluster read operations ..." << endl;
        vector<multimap<MInt, MInt>::iterator> readClusteringIterators;
        MInt noReadOps;
        {
          MInt srcPartitionCellId;
          for(multimap<MInt, MInt>::iterator it = partitionCellsToLoad.begin(); it != partitionCellsToLoad.end();
              it = partitionCellsToLoad.upper_bound(srcPartitionCellId)) { // first element larger than the key

            readClusteringIterators.push_back(it);
            srcPartitionCellId = it->first;
            MInt srcPartitionCellNoOffsprings =
                srcPartitionCellsGlobalId(srcPartitionCellId + 1) - srcPartitionCellsGlobalId(srcPartitionCellId);

            // how much cells would extending the read to the next partition cell add?
            MInt additionalPartitionCellNoOffsprings = 0;
            while(1) {
              multimap<MInt, MInt>::iterator itNext = partitionCellsToLoad.upper_bound(srcPartitionCellId);
              if(itNext == partitionCellsToLoad.end()) break;
              MInt nextSrcPartitionCellId = itNext->first;
              for(MInt i = srcPartitionCellId + 1; i <= nextSrcPartitionCellId; i++) {
                additionalPartitionCellNoOffsprings += srcPartitionCellsGlobalId(i + 1) - srcPartitionCellsGlobalId(i);
              }
              if(additionalPartitionCellNoOffsprings + srcPartitionCellNoOffsprings > maxNoCellsToRead) break;
              srcPartitionCellId = nextSrcPartitionCellId;
            }
          }
          noReadOps = readClusteringIterators.size();
          readClusteringIterators.push_back(partitionCellsToLoad.end());
        }

        MPI_Barrier(mpiComm(), AT_);
        m_log << "done" << endl;

        MInt noFakeReads = 0;
        MInt minNoReadOps;
        if(noDomains() > 1) {
          MInt maxNoReadOps;
          MPI_Allreduce(&noReadOps, &maxNoReadOps, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "noReadOps", "maxNoReadOps");
          MPI_Allreduce(&noReadOps, &minNoReadOps, 1, MPI_INT, MPI_MIN, mpiComm(), AT_, "noReadOps", "minNoReadOps");
          noFakeReads = maxNoReadOps - noReadOps;
          m_log << maxNoReadOps << " max number of read operations" << endl;
          m_log << minNoReadOps << " min number of read operations" << endl;
        }

        MPI_Barrier(mpiComm(), AT_);
        m_log << "get leaf cell data ..." << endl;

        // allocate memory
        ParallelIo srcData("src/initialCondition", maia::parallel_io::PIO_READ, mpiComm());
        MFloatScratchSpace srcCoords(maxNoCellsToRead, nDim, AT_, "srcCoords");
        MIntScratchSpace srcChildIds(maxNoCellsToRead, IPOW2(nDim), AT_, "srcChildIds");
        MIntScratchSpace srcNoChildIds(maxNoCellsToRead, AT_, "srcNoChildIds");
        MIntScratchSpace srcLevel(maxNoCellsToRead, AT_, "srcLevel");
        MFloatScratchSpace srcVars(maxNoCellsToRead, noPVars, AT_, "srcVars");
        for(MInt noOps = 0; noOps < noReadOps; noOps++) {
          multimap<MInt, MInt>::iterator it = readClusteringIterators[noOps];
          multimap<MInt, MInt>::iterator nextIt = readClusteringIterators[noOps + 1];
          multimap<MInt, MInt>::iterator lastIt = prev(nextIt);
          MInt srcPartitionCellGlobalId = srcPartitionCellsGlobalId(it->first);
          MInt srcCellsToRead = 0;
          for(MInt smcid = it->first; smcid <= lastIt->first; smcid++)
            srcCellsToRead += srcPartitionCellsGlobalId(smcid + 1) - srcPartitionCellsGlobalId(smcid);
          srcGrid.setOffset(srcCellsToRead, srcPartitionCellGlobalId);
          srcData.setOffset(srcCellsToRead, srcPartitionCellGlobalId);
          // load coords
          for(MInt j = 0; j < nDim; ++j) {
            stringstream ss;
            ss << "coordinates_" << j;
            varNames.push_back(ss.str());
            ss.clear();
            ss.str("");
          }
          srcGrid.readArray(&srcCoords(0, 0), varNames, nDim);
          varNames.clear();
          // load nmbr child
          srcGrid.readArray(srcNoChildIds.begin(), "noChildIds");
          // level
          srcGrid.readArray(srcLevel.begin(), "level_0");
          // load childIds
          for(MInt j = 0; j < IPOW2(nDim); ++j) {
            stringstream ss;
            ss << "childIds_" << j;
            varNames.push_back(ss.str());
            ss.clear();
            ss.str("");
          }
          srcGrid.readArray(&srcChildIds(0, 0), varNames, IPOW2(nDim));
          varNames.clear();
          // correct Ids
          for(MInt i = 0; i < maxNoCellsToRead; i++)
            for(MInt j = 0; j < IPOW2(nDim); j++)
              srcChildIds(i, j) -= srcPartitionCellGlobalId;
          // correct Coords
          for(MInt i = 0; i < maxNoCellsToRead; i++)
            for(MInt j = 0; j < nDim; j++)
              srcCoords(i, j) *= fileTypeFac;
          // load vars
          for(MInt j = 0; j < noPVars; ++j) {
            stringstream ss;
            ss << "variables" << j;
            varNames.push_back(ss.str());
            ss.clear();
            ss.str("");
          }
          srcData.readArray(&srcVars(0, 0), varNames, noPVars);
          varNames.clear();
          // loop over corresponding internal cells
          for(multimap<MInt, MInt>::iterator i = it; i != nextIt; advance(i, 1)) {
            // vector<pair<MInt,MInt>> routeToStuck;
            // vector<MInt> debInfo;
            MInt locSrcPartitionCellId = srcPartitionCellsGlobalId(i->first) - srcPartitionCellGlobalId;
            MInt cid = i->second;
            MFloat* coord = (MFloat*)(&(a_coordinate(cid, 0)));
            // go to the leaf cell
            MInt srcSrcId = locSrcPartitionCellId;
            //              MInt LvlCnt = 0;
            while(srcNoChildIds(srcSrcId)) {
              // routeToStuck.push_back(make_pair(srcLevel(srcSrcId),srcNoChildIds(srcSrcId)));
              // debInfo.push_back(srcSrcId);
              //                whileCnt++;
              //                if(whileCnt > (srcMaxLevel - srcMinLevel)){ // suspicious, might
              //                lead to problem with partition level shift
              //                  cerr << " stuck in partition cell " <<
              //                  srcPartitionCellsGlobalId(i->first) << " " << whileCnt << endl;
              //                  cerr << "cell " << c_globalId(cid) << " at " << coord[0] << " " <<
              //                  coord[1] << " " << coord[2] << endl; cerr << "partition cell " <<
              //                  " at " << srcCoords(locSrcPartitionCellId,0) << " " <<
              //                  srcCoords(locSrcPartitionCellId,1) <<  " " <<
              //                  srcCoords(locSrcPartitionCellId,2) << endl;
              // for(MInt l = 0; l < (MInt)routeToStuck.size();l++){
              //  cerr << routeToStuck[l].first << " " << routeToStuck[l].second << " " <<
              //  debInfo[l] << endl;
              //}
              //                  mTerm(1," initial condition 81, stuck in partition cell ");
              //                }
              MFloat minDist = std::numeric_limits<MFloat>::max();
              MFloat minTcid = -1;
              for(MInt cc = 0; cc < IPOW2(nDim); cc++) {
                MInt tcid = srcChildIds(srcSrcId, cc);
                if(tcid >= 0) {
                  MFloat* srcCoord = &srcCoords(tcid, 0);
                  MFloat hdc = srcLengthLevel0 / IPOW2(srcLevel(tcid) + 1);
                  // if the cell is inside the child break loop
                  MInt insideCnt = 0;
                  for(MInt dim = 0; dim < nDim; dim++)
                    if(coord[dim] < srcCoord[dim] + hdc && coord[dim] >= srcCoord[dim] - hdc) insideCnt++;
                  if(insideCnt == nDim) {
                    srcSrcId = tcid;
                    break;
                  }
                  // otherwise prepare for a dist comparison
                  MFloat tmpDist = 0.0;
                  for(MInt dim = 0; dim < nDim; dim++)
                    tmpDist += pow(coord[dim] - srcCoord[dim], F2);
                  tmpDist = sqrt(tmpDist);
                  // if(srcNoChildIds(srcSrcId) == 1)
                  //  cerr << tmpDist << " " << minDist << " " << srcLengthLevel0 << endl;
                  if(tmpDist < minDist) {
                    minDist = tmpDist;
                    minTcid = tcid;
                  }
                }
                if(cc == IPOW2(nDim) - 1) srcSrcId = minTcid;
              }
            }
            // set cell data
            for(MInt var = 0; var < noPVars; var++)
              a_pvariable(cid, var) = srcVars(srcSrcId, var);
          }
        }

        // fake reads
        for(MInt fr = 0; fr < noFakeReads; fr++) {
          // load coords
          for(MInt j = 0; j < nDim; ++j) {
            stringstream ss;
            ss << "coordinates_" << j;
            varNames.push_back(ss.str());
            ss.clear();
            ss.str("");
          }
          srcGrid.setOffset(0, 0);
          srcData.setOffset(0, 0);
          srcGrid.readArray(&srcCoords(0, 0), varNames, nDim);
          varNames.clear();
          // load nmbr child
          srcGrid.readArray(srcNoChildIds.begin(), "noChildIds");
          // level
          srcGrid.readArray(srcLevel.begin(), "level_0");
          // load childIds
          for(MInt j = 0; j < IPOW2(nDim); ++j) {
            stringstream ss;
            ss << "childIds_" << j;
            varNames.push_back(ss.str());
            ss.clear();
            ss.str("");
          }
          srcGrid.readArray(&srcChildIds(0, 0), varNames, IPOW2(nDim));
          varNames.clear();
          // load vars
          for(MInt j = 0; j < noPVars; ++j) {
            stringstream ss;
            ss << "variables" << j;
            varNames.push_back(ss.str());
            ss.clear();
            ss.str("");
          }
          srcData.readArray(&srcVars(0, 0), varNames, noPVars);
          varNames.clear();
        }

        MPI_Barrier(mpiComm(), AT_);
        m_log << "done" << endl;

        // statistics of cells that could not be found in the source grid
        MInt sumUncollated = uncollatedCells.size();
        MPI_Allreduce(MPI_IN_PLACE, &sumUncollated, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                      "sumUncollated");
        m_log << sumUncollated << " uncollated cells" << endl;
        // to exclude other noncollated cells from the averaging below, we need the
        // globalIds frome all uncollated cells
        MInt sumUncollatedBndry = 0;
        set<MInt> allUncollatedBndryGlobalIds;
        {
          MIntScratchSpace noGlobalUncollatedBndry(noDomains(), AT_, "noGlobalUncollatedBndry");
          MIntScratchSpace noGlobalUncollatedBndryOffset(noDomains() + 1, AT_, "noGlobalUncollatedBndryOffset");
          noGlobalUncollatedBndry.fill(0);
          noGlobalUncollatedBndryOffset.fill(0);
          noGlobalUncollatedBndry[domainId()] = uncollatedBndryCells.size();
          MPI_Allgather(MPI_IN_PLACE, 0, MPI_DATATYPE_NULL, noGlobalUncollatedBndry.begin(), 1, MPI_INT, mpiComm(), AT_,
                        "MPI_IN_PLACE", "noGlobalUncollatedBndry.begin()");
          for(MInt dom = 0; dom < noDomains(); dom++) {
            sumUncollatedBndry += noGlobalUncollatedBndry[dom];
            noGlobalUncollatedBndryOffset[dom + 1] = sumUncollatedBndry;
          }
          MIntScratchSpace globalUncollatedBndry(sumUncollatedBndry, AT_, "globalUncollatedBndry");
          for(MInt cnt = 0; cnt < (MInt)uncollatedBndryCells.size(); cnt++) {
            MInt globalId = c_globalId(uncollatedBndryCells[cnt]);
            globalUncollatedBndry[noGlobalUncollatedBndryOffset[domainId()] + cnt] = globalId;
          }
          MPI_Allgatherv(MPI_IN_PLACE, 0, MPI_DATATYPE_NULL, globalUncollatedBndry.begin(),
                         noGlobalUncollatedBndry.begin(), noGlobalUncollatedBndryOffset.begin(), MPI_INT, mpiComm(),
                         AT_, "MPI_IN_PLACE", "globalUncollatedBndry.begin()");
          for(MInt cnt = 0; cnt < sumUncollatedBndry; cnt++)
            allUncollatedBndryGlobalIds.insert(allUncollatedBndryGlobalIds.end(), noGlobalUncollatedBndry[cnt]);
        }

        m_log << sumUncollatedBndry << " uncollated bndry cells" << endl;
        if(sumUncollatedBndry)
          m_log << "WARNING that is almost an ERROR: we have non "
                << "collated boundary cells in initial consdition 8111" << endl
                << "i will try to fix it, but we will see" << endl;

        exchangeAll();

        MPI_Barrier(mpiComm(), AT_);
        m_log << "exchange done" << endl;

        // fix uncollated boundary cells using the data of the neighbors
        for(MInt cnt = 0; cnt < (MInt)uncollatedBndryCells.size(); cnt++) {
          MInt cid = uncollatedBndryCells[cnt];
          cerr << "fixing uncollated state for cell " << c_globalId(cid) << endl;
          // reset variables
          for(MInt var = 0; var < noPVars; var++)
            a_pvariable(cid, var) = F0;
          // sum data of valid neighbors
          MInt validNghbrs = 0;

          for(MInt dir = 0; dir < a_noReconstructionNeighbors(cid); dir++) {
            MInt nid = a_reconstructionNeighborId(cid, dir);
            cerr << " rec nghbr " << dir << ", neighborId " << nid << endl;

            if(a_isBndryGhostCell(nid)) {
              cerr << "-- is ghost cell" << endl;
              continue;
            }

            if(allUncollatedBndryGlobalIds.find(c_globalId(nid)) != allUncollatedBndryGlobalIds.end()) {
              cerr << "-- neighbor " << c_globalId(nid) << " is also uncollated" << endl;
              continue;
            }

            validNghbrs++;
            for(MInt var = 0; var < noPVars; var++)
              a_pvariable(cid, var) += a_pvariable(nid, var);
          }
          if(!validNghbrs) mTerm(1, "no valid nghbrs for initialisation of uncollated boundary cell");
          // average
          for(MInt var = 0; var < noPVars; var++)
            a_pvariable(cid, var) /= validNghbrs;
        }

        exchangeAll();

        MPI_Barrier(mpiComm(), AT_);
        m_log << "exchange done" << endl;

        MInt tmpGlobalTimeStep = globalTimeStep;
        globalTimeStep = 0;
        saveRestartFile(false);
        globalTimeStep = tmpGlobalTimeStep;

        computeConservativeVariables();
        LSReconstructCellCenter();

        break;
      }

      case 1: {
        IF_CONSTEXPR(nDim == 2) mTerm(-1, "This IC is untested in 2D! If it works uncomment this warning.");

        // channel with perturbations

        computeInitialPressureLossForChannelFlow(); // computes m_deltaP.

        m_fvBndryCnd->m_deltaP = m_deltaP;

        MFloat factor, perturbation;
        MFloat UT = m_Ma * sqrt(m_TInfinity);

        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          if(cellId % 2 == 0) {
            factor = -F1;
          } else {
            factor = F1;
          }

          // density
          a_variable(cellId, CV->RHO) = m_rhoInfinity;
          // momentum
          for(MUint d = 0; d < nDim; d++) {
            // TODO labels:FV The rand call here makes this function noDomains dependent. To fix, halo cells have to be
            // excluded and the rand state has to communicated between domains. Also note that the function
            // applyInitialCondition() is called twice.
            perturbation = (MFloat(rand()) / RAND_MAX) * 0.001 * UT * factor;
            a_variable(cellId, CV->RHO_VV[d]) = F2B3 * m_rhoVVInfinity[d] + perturbation;
          }

          // energy
          const MFloat pressure = m_PInfinity - m_deltaP * (a_coordinate(cellId, 0) - m_domainBoundaries[0]);
          MFloat velPOW2 = 0;
          for(MUint d = 0; d < nDim; d++)
            velPOW2 += POW2(a_variable(cellId, CV->RHO_VV[d]));
          IF_CONSTEXPR(hasE<SysEqn>)
          a_variable(cellId, CV->RHO_E) = pressure / gammaMinusOne + (F1B2 * velPOW2) / m_rhoInfinity;
        }
        break;
      }
        // ring vortex - sphere interaction - artificially increased Mach number (factor 1000)
        // ring vortex - sphere interaction
      case 15: // Taylor-Green vortex (TGV), hijacked by Lennart ( for levelSetMb)
      {
        if(m_levelSetMb) {
          m_rhoInfinity = F1;
          m_TInfinity = F1;
          m_PInfinity = sysEqn().pressure_ES(m_TInfinity, m_rhoInfinity);
          m_UInfinity = m_Ma;
          m_rhoUInfinity = m_rhoInfinity * m_UInfinity;
          m_rhoVInfinity = m_rhoInfinity * m_VInfinity;
          m_rhoWInfinity = m_rhoInfinity * m_WInfinity;
          m_rhoEInfinity = sysEqn().internalEnergy(m_PInfinity, m_rhoInfinity, POW2(m_UInfinity));
          m_hInfinity = sysEqn().enthalpy(m_PInfinity, m_rhoInfinity);
          sysEqn().m_Re0 = m_Re * SUTHERLANDLAW(m_TInfinity) / (m_rhoInfinity * m_UInfinity);
          m_timeRef = m_Ma;
        }
        MFloat bbox[2 * nDim];
        for(MInt i = 0; i < nDim; i++) {
          bbox[i] = numeric_limits<MFloat>::max();
          bbox[nDim + i] = numeric_limits<MFloat>::lowest();
        }
        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          if(a_isHalo(cellId)) continue;
          if(a_isPeriodic(cellId)) continue;
          for(MInt i = 0; i < nDim; i++) {
            bbox[i] = mMin(bbox[i], a_coordinate(cellId, i) - F1B2 * c_cellLengthAtCell(cellId));
            bbox[nDim + i] = mMax(bbox[nDim + i], a_coordinate(cellId, i) + F1B2 * c_cellLengthAtCell(cellId));
          }
        }
        MPI_Allreduce(MPI_IN_PLACE, &bbox[0], nDim, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE", "bbox[0]");
        MPI_Allreduce(MPI_IN_PLACE, &bbox[nDim], nDim, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                      "bbox[nDim]");

        MFloat FX;
        IF_CONSTEXPR(nDim == 3) { FX = F2; }
        else {
          FX = F1;
        }
        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          const MFloat x = (a_coordinate(cellId, 0) - bbox[0]) / (bbox[nDim] - bbox[0]);
          const MFloat y = (a_coordinate(cellId, 1) - bbox[1]) / (bbox[nDim + 1] - bbox[1]);
          MFloat z;
          IF_CONSTEXPR(nDim == 3) { z = (a_coordinate(cellId, 2) - bbox[2]) / (bbox[nDim + 2] - bbox[2]); }
          else {
            z = 0.0;
          }
          const MFloat u = m_Ma * sin(FX * PI * x) * cos(FX * PI * y) * cos(F2 * PI * z);
          const MFloat v = -m_Ma * cos(FX * PI * x) * sin(FX * PI * y) * cos(F2 * PI * z);
          const MFloat w = F0;
          MFloat p;
          IF_CONSTEXPR(nDim == 3) {
            p = m_PInfinity
                + F1B16 * POW2(m_Ma) * m_rhoInfinity * (cos(F4 * PI * x) + cos(F4 * PI * y)) * (cos(F4 * PI * z) + F2);
          }
          else {
            p = m_PInfinity + F1B4 * POW2(m_Ma) * m_rhoInfinity * (cos(F2 * PI * x) + sin(F2 * PI * y));
          }
          const MFloat rho = sysEqn().density_ES(p, m_TInfinity);
          a_variable(cellId, CV->RHO) = rho;
          a_variable(cellId, CV->RHO_U) = rho * u;
          a_variable(cellId, CV->RHO_V) = rho * v;
          a_variable(cellId, CV->RHO_W) = rho * w;
          IF_CONSTEXPR(hasE<SysEqn>) {
            a_variable(cellId, CV->RHO_E) = sysEqn().internalEnergy(p, rho, (POW2(u) + POW2(v) + POW2(w)));
          }
        }
        break;
      }

        // isotropic turbulence spectrum
      case 16: {
        IF_CONSTEXPR(nDim == 2) mTerm(-1, "Only works for 3D!");
        const MFloat time0 = MPI_Wtime();
        computeCellVolumes();
        const MInt fftLevel = maxUniformRefinementLevel();
        const MFloat DX = c_cellLengthAtLevel(fftLevel);
        if(fftLevel > maxUniformRefinementLevel()) {
          mTerm(1, AT_, "Isotropic mesh expected (0).");
        }
        MFloat* bbox = new MFloat[2 * nDim];
        m_geometry->getBoundingBox(bbox);
        if(Context::propertyExists("cutOffCoordinates", m_solverId)) {
          for(MInt i = 0; i < nDim; i++) {
            bbox[i] = numeric_limits<MFloat>::max();
            bbox[nDim + i] = numeric_limits<MFloat>::lowest();
          }
          for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
            if(a_isHalo(cellId)) continue;
            if(a_isPeriodic(cellId)) continue;
            if(a_isBndryGhostCell(cellId)) continue;
            for(MInt i = 0; i < nDim; i++) {
              bbox[i] = mMin(bbox[i], a_coordinate(cellId, i) - F1B2 * c_cellLengthAtCell(cellId));
              bbox[nDim + i] = mMax(bbox[nDim + i], a_coordinate(cellId, i) + F1B2 * c_cellLengthAtCell(cellId));
            }
          }
          MPI_Allreduce(MPI_IN_PLACE, &bbox[0], nDim, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE", "bbox[0]");
          MPI_Allreduce(MPI_IN_PLACE, &bbox[nDim], nDim, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                        "bbox[nDim]");
        }

        // fft-domain dimensions
        // this holds the size of the domain in number of cells on lowest level
        const MFloat dxeps = 0.1 * DX;
        MInt nx = (bbox[3] - bbox[0] + dxeps) / DX;
        MInt ny = (bbox[4] - bbox[1] + dxeps) / DX;
        MInt nz = (bbox[5] - bbox[2] + dxeps) / DX;
        const MInt size = nx * ny * nz;

        m_rhoInfinity = F1;
        m_TInfinity = F1;
        m_PInfinity = sysEqn().pressure_ES(m_TInfinity, m_rhoInfinity);
        m_UInfinity = m_Ma;
        m_VInfinity = F0;
        m_WInfinity = F0;
        m_rhoUInfinity = m_rhoInfinity * m_UInfinity;
        m_rhoVInfinity = m_rhoInfinity * m_VInfinity;
        m_rhoWInfinity = m_rhoInfinity * m_WInfinity;
        m_rhoEInfinity = sysEqn().internalEnergy(m_PInfinity, m_rhoInfinity, POW2(m_UInfinity));
        m_hInfinity = sysEqn().enthalpy(m_PInfinity, m_rhoInfinity);
        sysEqn().m_muInfinity = SUTHERLANDLAW(m_TInfinity);
        sysEqn().m_Re0 = m_Re * sysEqn().m_muInfinity / (m_rhoInfinity * m_UInfinity);
        m_timeRef = m_Ma;
        m_VVInfinity[0] = m_UInfinity;
        m_VVInfinity[1] = m_VInfinity;
        m_VVInfinity[2] = m_WInfinity;
        m_rhoVVInfinity[0] = m_rhoUInfinity;
        m_rhoVVInfinity[1] = m_rhoVInfinity;
        m_rhoVVInfinity[2] = m_rhoWInfinity;
        /*! \page propertiesFV
         \section ReLambdaRestart
         <code>MFloat FvCartesianSolverXD::m_Re</code>\n
         default:  NONE \n \n
           <ul>
          <li> any float number</li>
          </ul>
         Sets the restart Re-number and triggers the restart from the
         out/restartVariables_init.Netcdf file.  \n Keywords: <i>FINITE_VOLUME, RESTART</i>
       */
        if(Context::propertyExists("ReLambdaRestart", m_solverId)) {
          m_Re = Context::getSolverProperty<MFloat>("ReLambdaRestart", m_solverId, AT_);
          sysEqn().m_Re0 = m_Re * SUTHERLANDLAW(m_TInfinity) / (m_rhoInfinity * m_UInfinity);
          if(domainId() == 0) cerr << "Loading out/restartVariables_init.Netcdf" << endl;
          loadGridFlowVarsPar("out/restartVariables_init.Netcdf");
          exchangeDataFV(&a_pvariable(0, 0), noPVars, false, m_rotIndVarsPV);
          computeConservativeVariables();
          m_log << "Restart Reynolds number: " << setprecision(15) << m_Re << " (Re_L=" << m_Re * (bbox[3] - bbox[0])
                << ")"
                << " " << sysEqn().m_Re0 << endl;
          break;
        }

        MBool goodSpectrum = false;
        MUlong seed = 0;
        while(!goodSpectrum) {
          const MInt spectrumId = 2; // prescribed energy spectrum, see maiamath.cpp
          const MFloat kpRatio = F4; // peak wave number of prescribed spectrum
          fftw_complex* uPhysField;
          fftw_complex* nabla2P;
          MIntScratchSpace fftInfo(4, AT_, "fftInfo");


          seed = maia::math::initFft(uPhysField, nabla2P, nx, ny, nz, kpRatio, spectrumId, fftInfo, mpiComm(), true);

          MInt maxRank = fftInfo[0];
          MInt local_n0 = fftInfo[1];
          MInt local_0_start = fftInfo[2];
          MInt alloc_local = fftInfo[3];

          MIntScratchSpace noSendIds(globalNoDomains(), AT_, "noSendIds");
          MInt sendIdsSize = 0;
          MIntScratchSpace offsetsIds(globalNoDomains() + 1, AT_, "offsetsIds");
          MInt locOffsetIds = (globalDomainId() < maxRank) ? ((MInt)local_0_start) * ny * nz : size;
          MPI_Allgather(&locOffsetIds, 1, MPI_INT, &offsetsIds[0], 1, MPI_INT, mpiComm(), AT_, "locOffsetIds",
                        "offsetsIds[0]");
          offsetsIds(globalNoDomains()) = size;
          noSendIds.fill(0);

          // Count no of sendIds
          for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
            if(a_isHalo(cellId)) continue;
            if(a_isBndryGhostCell(cellId)) continue;
            if(a_level(cellId) != fftLevel) continue;
            MFloat actualCellLength = c_cellLengthAtCell(cellId);
            MInt xPos = floor((F1B2 * nx + (a_coordinate(cellId, 0) - F1B2 * (actualCellLength)) / DX) + 0.1);
            MInt yPos = floor((F1B2 * ny + (a_coordinate(cellId, 1) - F1B2 * (actualCellLength)) / DX) + 0.1);
            MInt zPos = floor((F1B2 * nz + (a_coordinate(cellId, 2) - F1B2 * (actualCellLength)) / DX) + 0.1);
            MInt pos = maia::math::getGlobalPosFFTW(xPos, yPos, zPos, ny, nz);
            MInt nghbrDomain = mMin(maxRank - 1, pos / (size / maxRank));
            while(pos < offsetsIds(nghbrDomain) || pos >= offsetsIds(nghbrDomain + 1)) {
              if(pos < offsetsIds(nghbrDomain)) nghbrDomain--;
              if(pos >= offsetsIds(nghbrDomain + 1)) nghbrDomain++;
            }
            if(nghbrDomain >= maxRank) mTerm(1, AT_, "wrong domain");
            noSendIds(nghbrDomain)++;
            sendIdsSize++;
          }
          MIntScratchSpace sendIdsOffsets(globalNoDomains(), AT_, "sendIdsOffsets");
          MIntScratchSpace sendIdsOffsetsTmp(globalNoDomains(), AT_, "sendIdsOffsetsTmp");
          sendIdsOffsets[0] = 0;
          sendIdsOffsetsTmp[0] = 0;
          for(MInt nghbrDomain = 0; nghbrDomain < globalNoDomains() - 1; nghbrDomain++) {
            sendIdsOffsets[nghbrDomain + 1] = sendIdsOffsets[nghbrDomain] + noSendIds[nghbrDomain];
            sendIdsOffsetsTmp[nghbrDomain + 1] = sendIdsOffsets[nghbrDomain] + noSendIds[nghbrDomain];
          }
          MIntScratchSpace sendIds(sendIdsSize, AT_, "sendIdsSize");

          // Fill sendIds
          for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
            if(a_isHalo(cellId)) continue;
            if(a_isBndryGhostCell(cellId)) continue;
            if(a_level(cellId) != fftLevel) continue;
            MFloat actualCellLength = c_cellLengthAtCell(cellId);
            MInt xPos = floor((F1B2 * nx + (a_coordinate(cellId, 0) - F1B2 * (actualCellLength)) / DX) + 0.1);
            MInt yPos = floor((F1B2 * ny + (a_coordinate(cellId, 1) - F1B2 * (actualCellLength)) / DX) + 0.1);
            MInt zPos = floor((F1B2 * nz + (a_coordinate(cellId, 2) - F1B2 * (actualCellLength)) / DX) + 0.1);
            MInt pos = maia::math::getGlobalPosFFTW(xPos, yPos, zPos, nx, ny);
            MInt nghbrDomain = mMin(maxRank - 1, pos / (size / maxRank));
            while(pos < offsetsIds(nghbrDomain) || pos >= offsetsIds(nghbrDomain + 1)) {
              if(pos < offsetsIds(nghbrDomain)) nghbrDomain--;
              if(pos >= offsetsIds(nghbrDomain + 1)) nghbrDomain++;
            }
            if(nghbrDomain >= maxRank) mTerm(1, AT_, "wrong domain");
            sendIds[sendIdsOffsetsTmp[nghbrDomain]++] = pos;
          }
          MIntScratchSpace noRecvIds(globalNoDomains(), AT_, "noRecvIds");
          noRecvIds.fill(0);
          MPI_Alltoall(&noSendIds[0], 1, MPI_INT, &noRecvIds[0], 1, MPI_INT, mpiComm(), AT_, "noSendIds[0]",
                       "noRecvIds[0]");

          MIntScratchSpace recvIdsOffsets(globalNoDomains(), AT_, "recvIdsOffsets");
          recvIdsOffsets[0] = 0;
          MInt recvIdsSize = 0;
          for(MInt nghbrDomain = 0; nghbrDomain < globalNoDomains() - 1; nghbrDomain++) {
            recvIdsOffsets[nghbrDomain + 1] = recvIdsOffsets[nghbrDomain] + noRecvIds[nghbrDomain];
            recvIdsSize += noRecvIds[nghbrDomain];
          }
          recvIdsSize += noRecvIds[globalNoDomains() - 1];

          // Exchange Ids
          MIntScratchSpace recvIds(mMax(1, recvIdsSize), AT_, "recvIds");
          MPI_Alltoallv(&sendIds[0], &noSendIds[0], &sendIdsOffsets[0], MPI_INT, &recvIds[0], &noRecvIds[0],
                        &recvIdsOffsets[0], MPI_INT, mpiComm(), AT_, "sendIds[0]", "recvIds[0]");

          MIntScratchSpace sendVarsOffsets(globalNoDomains(), AT_, "sendVarsOffsets");
          MIntScratchSpace sendVarsOffsetsTmp(globalNoDomains(), AT_, "sendVarsOffsetsTmp");
          MIntScratchSpace noSendVars(globalNoDomains(), AT_, "noSendVars");
          sendVarsOffsets[0] = 0;
          sendVarsOffsetsTmp[0] = 0;
          MInt sendVarsSize = 0;
          for(MInt i = 0; i < globalNoDomains() - 1; i++) {
            sendVarsOffsets[i + 1] = sendVarsOffsets[i] + noRecvIds[i] * 4;
            sendVarsOffsetsTmp[i + 1] = sendVarsOffsetsTmp[i] + noRecvIds[i] * 4;
            noSendVars[i] = noRecvIds[i] * 4;
            sendVarsSize += noRecvIds[i] * 4;
          }
          if(recvIdsSize != 0) {
            noSendVars[globalNoDomains() - 1] = noRecvIds[globalNoDomains() - 1] * 4;
            sendVarsSize += noRecvIds[globalNoDomains() - 1] * 4;
          }

          // Fill sendVars: for each Id received 4 variables have to be send
          MFloatScratchSpace sendVars(mMax(1, sendVarsSize), AT_, "sendVars");
          sendVars.fill(0);
          MFloat cnt = F0;
          MFloat upr[3] = {F0, F0, F0};
          for(MInt i = 0; i < recvIdsSize; i++) {
            MInt pos = recvIds[i];
            ASSERT(pos > -1 && pos < size, "");
            if(!(pos >= ((MInt)local_0_start) * nx * ny && pos < ((MInt)(local_0_start + local_n0) * ny * nx))) {
              mTerm(1, AT_, "Position not available on this domain(1).");
            }
            MInt localPos = pos - (((MInt)local_0_start) * ny * nz);
            if(3 * localPos + 2 > alloc_local) {
              mTerm(1, AT_, "index exceeds array(1)");
            }
            sendVars[i * 4] = uPhysField[3 * localPos][0];
            sendVars[i * 4 + 1] = uPhysField[3 * localPos + 1][0];
            sendVars[i * 4 + 2] = uPhysField[3 * localPos + 2][0];
            sendVars[i * 4 + 3] = nabla2P[localPos][0];
            MFloat u = uPhysField[3 * localPos][0];
            MFloat v = uPhysField[3 * localPos + 1][0];
            MFloat w = uPhysField[3 * localPos + 2][0];
            upr[0] += POW2(u);
            upr[1] += POW2(v);
            upr[2] += POW2(w);
            cnt++;
          }

          MPI_Allreduce(MPI_IN_PLACE, &cnt, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "cnt");
          MPI_Allreduce(MPI_IN_PLACE, &upr, 3, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "upr");

          MFloat uprime0 = sqrt(F1B3 * (upr[0] + upr[1] + upr[2]) / cnt);

          fftw_free(uPhysField);
          fftw_free(nabla2P);

          MIntScratchSpace recvVarsOffsets(globalNoDomains(), AT_, "recvVarsOffsets");
          MIntScratchSpace noRecvVars(globalNoDomains(), AT_, "noRecvVars");
          recvVarsOffsets[0] = 0;
          MInt recvVarsSize = 0;
          for(MInt i = 0; i < globalNoDomains() - 1; i++) {
            recvVarsOffsets[i + 1] = recvVarsOffsets[i] + noSendIds[i] * 4;
            noRecvVars[i] = noSendIds[i] * 4;
            recvVarsSize += noSendIds[i] * 4;
          }
          recvVarsSize += noSendIds[globalNoDomains() - 1] * 4;
          noRecvVars[globalNoDomains() - 1] = noSendIds[globalNoDomains() - 1] * 4;

          // Exchange Variables
          MFloatScratchSpace recvVars(recvVarsSize, AT_, "recvVars");
          recvVars.fill(0);
          MPI_Alltoallv(&sendVars[0], &noSendVars[0], &sendVarsOffsets[0], MPI_DOUBLE, &recvVars[0], &noRecvVars[0],
                        &recvVarsOffsets[0], MPI_DOUBLE, mpiComm(), AT_, "sendVars[0]", "recvVars[0]");

          cnt = F0;
          upr[0] = 0;
          upr[1] = 0;
          upr[2] = 0;
          for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
            if(a_isHalo(cellId)) continue;
            if(a_isBndryGhostCell(cellId)) continue;
            if(a_level(cellId) != fftLevel) continue;
            // if (cellId+4 >= recvVarsSize ) mTerm(1, AT_, "Not enough Variables
            // received");
            MFloat actualCellLength = c_cellLengthAtCell(cellId);
            MInt xPos = floor((F1B2 * nx + (a_coordinate(cellId, 0) - F1B2 * (actualCellLength)) / DX) + 0.1);
            MInt yPos = floor((F1B2 * ny + (a_coordinate(cellId, 1) - F1B2 * (actualCellLength)) / DX) + 0.1);
            MInt zPos = floor((F1B2 * nz + (a_coordinate(cellId, 2) - F1B2 * (actualCellLength)) / DX) + 0.1);
            MInt pos = maia::math::getGlobalPosFFTW(xPos, yPos, zPos, nx, ny);
            MInt nghbrDomain = mMin(maxRank - 1, pos / (size / maxRank));
            while(pos < offsetsIds(nghbrDomain) || pos >= offsetsIds(nghbrDomain + 1)) {
              if(pos < offsetsIds(nghbrDomain)) nghbrDomain--;
              if(pos >= offsetsIds(nghbrDomain + 1)) nghbrDomain++;
            }
            if(nghbrDomain >= maxRank) mTerm(1, AT_, "wrong domain");
            if(sendIds[sendIdsOffsets[nghbrDomain]] != pos) mTerm(1, AT_, "pos mismatch");
            MFloat u = recvVars[sendIdsOffsets[nghbrDomain] * 4];
            MFloat v = recvVars[sendIdsOffsets[nghbrDomain] * 4 + 1];
            MFloat w = recvVars[sendIdsOffsets[nghbrDomain] * 4 + 2];
            MFloat p = recvVars[sendIdsOffsets[nghbrDomain] * 4 + 3];
            sendIdsOffsets[nghbrDomain]++;
            upr[0] += POW2(u);
            upr[1] += POW2(v);
            upr[2] += POW2(w);
            a_pvariable(cellId, PV->U) = u;
            a_pvariable(cellId, PV->V) = v;
            a_pvariable(cellId, PV->W) = w;
            a_pvariable(cellId, PV->P) = m_PInfinity + p * POW2(m_UInfinity);
            cnt++;
          }

          MPI_Allreduce(MPI_IN_PLACE, &cnt, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "cnt");
          MPI_Allreduce(MPI_IN_PLACE, &upr, 3, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "upr");

          MFloat uprime1 = sqrt(F1B3 * (upr[0] + upr[1] + upr[2]) / cnt);
          upr[0] = sqrt(upr[0] / cnt);
          upr[1] = sqrt(upr[1] / cnt);
          upr[2] = sqrt(upr[2] / cnt);

          if(fabs(uprime0 - uprime1) > exp(-10)) mTerm(1, AT_, "Communication went wrong.");

          if(domainId() == 0)
            cerr << "initial urpime: " << upr[0] << " " << upr[1] << " " << upr[2] << " (" << uprime1 << ")" << endl;

          // Konstantin: The initial spectrum is cut off for coarse LES grids which
          // results into a lower energy level. If uprime != 1, this energy
          // will be modified such that all resolved scales have the DNS-energy,
          // i.e. large scales get the energy which have been cut off at the small
          // scales.
          uprime1 = F1;

          for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
            if(a_isHalo(cellId)) continue;
            if(a_isBndryGhostCell(cellId)) continue;
            if(a_level(cellId) != fftLevel) continue;
            // scale velocities such that mean urms is m_UInfinity
            MFloat u = a_pvariable(cellId, PV->U) * m_UInfinity / uprime1;
            MFloat v = a_pvariable(cellId, PV->V) * m_UInfinity / uprime1;
            MFloat w = a_pvariable(cellId, PV->W) * m_UInfinity / uprime1;
            MFloat p = a_pvariable(cellId, PV->P);
            MFloat rho = sysEqn().density_ES(p, m_TInfinity);
            a_variable(cellId, CV->RHO) = rho;
            a_variable(cellId, CV->RHO_U) = rho * u;
            a_variable(cellId, CV->RHO_V) = rho * v;
            a_variable(cellId, CV->RHO_W) = rho * w;
            IF_CONSTEXPR(hasE<SysEqn>) {
              a_variable(cellId, CV->RHO_E) = sysEqn().internalEnergy(p, rho, (POW2(u) + POW2(v) + POW2(w)));
            }
            a_pvariable(cellId, PV->U) = u;
            a_pvariable(cellId, PV->V) = v;
            a_pvariable(cellId, PV->W) = w;
            a_pvariable(cellId, PV->P) = p;
            a_pvariable(cellId, PV->RHO) = rho;
          }

          exchangeDataFV(&a_variable(0, 0), noCVars, false, m_rotIndVarsPV);
          exchangeDataFV(&a_pvariable(0, 0), noPVars, false, m_rotIndVarsCV);

          MFloat umean[3] = {F0, F0, F0};
          MFloat urms[6] = {F0, F0, F0, F0, F0, F0};
          MFloat reyn[6] = {F0, F0, F0, F0, F0, F0};
          MFloat aniso[6] = {F0, F0, F0, F0, F0, F0};
          MFloat dudx[3] = {F0, F0, F0};
          MFloat skew[4] = {F0, F0, F0, F0};
          for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
            if(a_isHalo(cellId)) continue;
            if(a_isBndryGhostCell(cellId)) continue;
            if(a_level(cellId) != fftLevel) continue;
            MFloat u = a_pvariable(cellId, PV->U);
            MFloat v = a_pvariable(cellId, PV->V);
            MFloat w = a_pvariable(cellId, PV->W);
            for(MInt i = 0; i < nDim; i++) {
              MInt n0 = (a_hasNeighbor(cellId, 2 * i) > 0) ? c_neighborId(cellId, 2 * i) : cellId;
              MInt n1 = (a_hasNeighbor(cellId, 2 * i + 1) > 0) ? c_neighborId(cellId, 2 * i + 1) : cellId;
              if(n0 == n1) continue;
              dudx[i] += POW2((a_pvariable(n1, PV->VV[i]) - a_pvariable(n0, PV->VV[i]))
                              / (a_coordinate(n1, i) - a_coordinate(n0, i)));
              skew[i] += POW3((a_pvariable(n1, PV->VV[i]) - a_pvariable(n0, PV->VV[i]))
                              / (a_coordinate(n1, i) - a_coordinate(n0, i)));
            }
            urms[0] += POW2(u);
            urms[1] += POW2(v);
            urms[2] += POW2(w);
            urms[3] += u * v;
            urms[4] += u * w;
            urms[5] += v * w;
            umean[0] += u;
            umean[1] += v;
            umean[2] += w;
          }
          MPI_Allreduce(MPI_IN_PLACE, &urms[0], 6, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "urms[0]");
          MPI_Allreduce(MPI_IN_PLACE, &umean[0], 3, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "umean[0]");
          MPI_Allreduce(MPI_IN_PLACE, &dudx[0], 3, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "dudx[0]");
          MPI_Allreduce(MPI_IN_PLACE, &skew[0], 3, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "skew[0]");
          skew[3] = ((skew[0] + skew[1] + skew[2]) / (F3 * cnt)) / pow((dudx[0] + dudx[1] + dudx[2]) / (F3 * cnt), 1.5);
          for(MInt i = 0; i < 3; i++)
            skew[i] = (skew[i] / cnt) / pow(dudx[i] / cnt, 1.5);
          for(MInt i = 0; i < 6; i++)
            reyn[i] = urms[i] / cnt;
          for(MInt i = 0; i < 6; i++)
            aniso[i] = urms[i] / (urms[0] + urms[1] + urms[2]);
          for(MInt i = 0; i < 3; i++)
            aniso[i] -= F1B3;
          for(MInt i = 0; i < 6; i++)
            urms[i] = sqrt(fabs(urms[i]) / cnt);
          for(MInt i = 0; i < 3; i++)
            umean[i] /= cnt;
          for(MInt i = 0; i < 3; i++)
            dudx[i] /= cnt;
          MFloat lambda[3];
          MFloat Rel[4];
          MFloat eps[3];
          for(MInt i = 0; i < 3; i++)
            lambda[i] = urms[i] / sqrt(dudx[i]);

          if(domainId() == 0)
            cerr << "u_mean: " << umean[0] << " " << umean[1] << " " << umean[2] << " (" << (MInt)cnt << ")" << endl;
          if(domainId() == 0)
            cerr << "u_rms/u_inf: " << urms[0] / m_UInfinity << " " << urms[1] / m_UInfinity << " "
                 << urms[2] / m_UInfinity << " " << urms[3] / m_UInfinity << " " << urms[4] / m_UInfinity << " "
                 << urms[5] / m_UInfinity << " (" << F1B3 * (urms[0] + urms[1] + urms[2]) / m_UInfinity << ")" << endl;
          if(domainId() == 0)
            cerr << "skewness: " << skew[0] << " " << skew[1] << " " << skew[2] << " (" << skew[3] << ")" << endl;
          if(domainId() == 0)
            cerr << "Anisotropy: " << aniso[0] << " " << aniso[1] << " " << aniso[2] << " " << aniso[3] << " "
                 << aniso[4] << " " << aniso[5] << endl;
          if(domainId() == 0)
            cerr << "Reynolds stress: " << reyn[0] << " " << reyn[1] << " " << reyn[2] << " " << reyn[3] << " "
                 << reyn[4] << " " << reyn[5] << endl;
          if(domainId() == 0)
            cerr << "Realizability 1: " << reyn[3] * reyn[3] << " <= " << reyn[0] * reyn[1] << ", " << reyn[4] * reyn[4]
                 << " <= " << reyn[0] * reyn[2] << ", " << reyn[5] * reyn[5] << " <= " << reyn[1] * reyn[2] << endl;
          if(domainId() == 0)
            cerr << "Realizability 2: det = "
                 << reyn[0] * reyn[1] * reyn[2] + F2 * reyn[3] * reyn[4] * reyn[5] - reyn[0] * reyn[5] * reyn[5]
                        - reyn[1] * reyn[4] * reyn[4] - reyn[2] * reyn[4] * reyn[4]
                 << " >= 0" << endl;

          // prescribe Taylor microscale Reynolds number
          // Konstantin: ReLambda is unkown in LES and has to be defined to get the
          // same viscosity as in the DNS.
          const MFloat time1 = MPI_Wtime();
          m_log << "initFFT time " << time1 - time0 << endl;
          if(nx < 256) {
            /*! \page propertiesFV
              \section ReLambdaOverwrite
              <code>MInt FvCartesianSolverXD::m_Re</code>\n
              default = <code>none</code>\n \n
              Overwrite Reynolds number for FV isotropic turbulence spectrum initial condition (case
              16). \n \n
              Possible values are:
              <ul>
                <li>Any positive floating point value</li>
              </ul>
              Keywords: <i>FINITE_VOLUME, INITIAL_CONDITION, ISOTROPIC, TURBULENCE</i>
            */
            if(!Context::propertyExists("ReLambdaOverwrite", m_solverId)) {
              mTerm(1, AT_, "Undefined ReLambda for LES grid.");
            }
            m_Re = Context::getSolverProperty<MFloat>("ReLambdaOverwrite", m_solverId, AT_) / m_referenceLength;
            sysEqn().m_Re0 = m_Re * SUTHERLANDLAW(m_TInfinity) / (m_rhoInfinity * m_UInfinity);
            m_log << "Overwritten Reynolds number: " << setprecision(15) << m_Re
                  << " (Re_L=" << m_Re * (bbox[3] - bbox[0]) << ")"
                  << " " << sysEqn().m_Re0 << endl;
            break;
          }

          /*! \page propertiesFV
            \section ReLambda
            <code>MInt FvCartesianSolverXD::m_Re</code>\n
            default = <code>none</code>\n \n
            Overwrite Reynolds number for FV isotropic turbulence spectrum initial condition (case
            16). \n \n
            Possible values are:
            <ul>
              <li>Any positive floating point value</li>
            </ul>
            Keywords: <i>FINITE_VOLUME, INITIAL_CONDITION, ISOTROPIC, TURBULENCE</i>
          */
          m_Re = Context::getSolverProperty<MFloat>("ReLambda", m_solverId, AT_) / m_referenceLength;
          m_Re *= F3 / (lambda[0] + lambda[1] + lambda[2]);
          // m_Re *= (sqrt(dudx[0])+sqrt(dudx[1])+sqrt(dudx[2]))/(urms[0]+urms[1]+urms[2]);
          sysEqn().m_Re0 = m_Re * SUTHERLANDLAW(m_TInfinity) / (m_rhoInfinity * m_UInfinity);
          m_log << "Computed Reynolds number: " << setprecision(15) << m_Re << " (Re_L=" << m_Re * (bbox[3] - bbox[0])
                << ")"
                << " " << sysEqn().m_Re0 << endl;

          MFloat mue = SUTHERLANDLAW(m_TInfinity) / sysEqn().m_Re0;
          for(MInt i = 0; i < 3; i++)
            Rel[i] = m_rhoInfinity * urms[i] * lambda[i] / mue;
          Rel[3] =
              m_rhoInfinity * F1B3 * (urms[0] + urms[1] + urms[2]) * F1B3 * (lambda[0] + lambda[1] + lambda[2]) / mue;
          for(MInt i = 0; i < 3; i++)
            eps[i] = (15.0 * sysEqn().m_muInfinity * dudx[i]) * (bbox[nDim + i] - bbox[i])
                     / (sysEqn().m_Re0 * POW3(urms[i]));
          if(domainId() == 0)
            cerr << "lambda: " << lambda[0] << " " << lambda[1] << " " << lambda[2] << " ("
                 << F1B3 * (lambda[0] + lambda[1] + lambda[2]) << ")" << endl;
          if(domainId() == 0)
            cerr << "eps: " << eps[0] << " " << eps[1] << " " << eps[2] << " (" << F1B3 * (eps[0] + eps[1] + eps[2])
                 << ")" << endl;
          if(domainId() == 0)
            cerr << "Re_lambda: " << Rel[0] << " " << Rel[1] << " " << Rel[2] << " (" << Rel[3] << ", "
                 << F1B3 * (Rel[0] + Rel[1] + Rel[2]) << ")" << endl;
          if(domainId() == 0)
            cerr << "Kolmogorov length: "
                 << pow(sysEqn().m_muInfinity / sysEqn().m_Re0, 0.75) / pow(F1B3 * (eps[0] + eps[1] + eps[2]), 0.25)
                 << endl;


          MFloat maxd = mMax(fabs(Rel[0] - Rel[1]), mMax(fabs(Rel[0] - Rel[2]), fabs(Rel[1] - Rel[2])));
          if(maxd < F1) m_log << "spectrum " << maxd << " " << F1B3 * (Rel[0] + Rel[1] + Rel[2]) << " " << seed << endl;
          // if ( maxd < 0.3 && F1B3*(Rel[0]+Rel[1]+Rel[2]) > 79.0 ) {
          // if ( maxd < 0.3 ) {
          goodSpectrum = true;
          if(domainId() == 0) m_log << "spectrum " << seed << endl;
          //}
          //}
        }
        if(domainId() == 0) cerr << "seed " << seed << endl;
        m_randomDeviceSeed = seed;
        MPI_Barrier(mpiComm(), AT_);

        if(fftLevel < maxRefinementLevel()) {
          for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
            if(a_isHalo(cellId)) continue;
            if(a_isBndryGhostCell(cellId)) continue;
            if(a_level(cellId) <= fftLevel) continue;
            if(c_noChildren(cellId) > 0) continue;
            MInt parentId = c_parentId(cellId);
            while(a_level(parentId) != fftLevel) {
              parentId = c_parentId(parentId);
            }
            if(a_level(parentId) == fftLevel) {
              for(MInt varId = 0; varId < noCVars; varId++) {
                a_variable(cellId, varId) = a_variable(parentId, varId);
              }
              for(MInt varId = 0; varId < noPVars; varId++) {
                a_pvariable(cellId, varId) = a_pvariable(parentId, varId);
              }
            }
          }
        }

        exchangeDataFV(&a_pvariable(0, 0), noPVars, false, m_rotIndVarsPV);
        exchangeDataFV(&a_variable(0, 0), noCVars, false, m_rotIndVarsCV);

        break;
      }

      case 1155:
        /* 3D single round jet initial condition; simple extension to 2D from 3D version
         * Seong et. al. Turbulence and heat excited noise sources in single and coaxial jets,2010.
         * Onur Cetin, August 2013
         */
        {
          for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
            const MFloat radius = (nDim == 3) ? sqrt(POW2(a_coordinate(cellId, 1)) + POW2(a_coordinate(cellId, 2)))
                                              : a_coordinate(cellId, 1);

            // Round jet
            if(radius <= 1.5 * m_jetHeight) {
              // const MFloat jet = F1B2 * (1 + tanh((F1B2 - radius) / (0.05 / 2))); // old version
              const MFloat jet = F1B2 * (1.0 + tanh((m_jetHeight - radius) / (2 * m_momentumThickness)));
              // Temperature profile with Crocco-Busemann
              const MFloat profile_T = sysEqn().CroccoBusemann(m_Ma, jet);
              // Set the density
              a_variable(cellId, CV->RHO) = m_rhoInfinity / profile_T;
              // Set the velocities // old version
              /* a_variable(cellId, CV->RHO_U) = a_variable(cellId, CV->RHO) * m_Ma * F1B2 */
              /*                                 * (1 + tanh((F1B2 - radius) / (0.05 / 2))); */
              a_variable(cellId, CV->RHO_U) = a_variable(cellId, CV->RHO) * jet * m_VVInfinity[0];
              a_variable(cellId, CV->RHO_V) = F0;
              IF_CONSTEXPR(nDim == 3) a_variable(cellId, CV->RHO_W) = F0;
              // Set the energy
              IF_CONSTEXPR(hasE<SysEqn>)
              a_variable(cellId, CV->RHO_E) =
                  m_PInfinity / gammaMinusOne
                  + F1B2 * POW2(a_variable(cellId, CV->RHO_U)) / (a_variable(cellId, CV->RHO));
            }
            // Round jet end
            else {
              // zero velocity outside of the jet region;
              a_variable(cellId, CV->RHO) = m_rhoInfinity;
              a_variable(cellId, CV->RHO_V) = F0;
              a_variable(cellId, CV->RHO_U) = F0;
              IF_CONSTEXPR(nDim == 3) a_variable(cellId, CV->RHO_W) = F0;
              IF_CONSTEXPR(hasE<SysEqn>)
              a_variable(cellId, CV->RHO_E) =
                  m_PInfinity / gammaMinusOne + F1B2 * POW2(a_variable(cellId, CV->RHO_U)) / m_rhoInfinity;
            }
          }
          break;
        }

      case 1156:
        /* 3D round coaxial jet initial condition; simple extension to 2D from 3D version
         * Seong et. al. Turbulence and heat excited noise sources in single and coaxial jets,2010.
         * Onur Cetin, August 2013
         */
        {
          // Round jet region:
          for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
            // Round jet
            const MFloat radius = nDim == 3 ? sqrt(POW2(a_coordinate(cellId, 1)) + POW2(a_coordinate(cellId, 2)))
                                            : a_coordinate(cellId, 1);

            if(radius <= m_primaryJetRadius) {
              // Hot air jet---
              //---------------

              const MFloat jet = F1B2 * (1 + tanh((m_primaryJetRadius - radius) / (m_momentumThickness / 2)));
              // Temperature profile with Crocco-Busemann
              const MFloat profile_T = sysEqn().CroccoBusemann(m_Ma, jet) * m_densityRatio;
              // Set the density
              a_variable(cellId, CV->RHO) = m_rhoInfinity / profile_T;
              // Set the velocities (Take momentum thickness 0.05 ref:Bogey & Bailly)
              a_variable(cellId, CV->RHO_U) = a_variable(cellId, CV->RHO) * m_targetVelocityFactor * F1B2
                                              * (1 + tanh((m_primaryJetRadius - radius) / (m_momentumThickness / 2)));
              a_variable(cellId, CV->RHO_V) = F0;
              IF_CONSTEXPR(nDim == 3) a_variable(cellId, CV->RHO_W) = F0;
              // Set the energy
              IF_CONSTEXPR(hasE<SysEqn>)
              a_variable(cellId, CV->RHO_E) =
                  m_PInfinity / gammaMinusOne
                  + F1B2 * POW2(a_variable(cellId, CV->RHO_U)) / (a_variable(cellId, CV->RHO));
            }

            else if(radius <= m_secondaryJetRadius && m_primaryJetRadius <= radius) {
              // Cold air jet---
              //----------------
              const MFloat jet = F1B2 * (1 + tanh((m_secondaryJetRadius - radius) / (2 * m_momentumThickness)));
              // Temperature profile
              const MFloat profile_T = sysEqn().CroccoBusemann(m_Ma, jet);
              // Set the density
              a_variable(cellId, CV->RHO) = m_rhoInfinity / profile_T;
              a_variable(cellId, CV->RHO_U) = a_variable(cellId, CV->RHO) * m_targetVelocityFactor
                                              * m_targetVelocityFactor * F1B2
                                              * (1 + tanh((m_secondaryJetRadius - radius) / (2 * m_momentumThickness)));
              a_variable(cellId, CV->RHO_V) = F0;
              IF_CONSTEXPR(nDim == 3) a_variable(cellId, CV->RHO_W) = F0;
              // Set the energy
              IF_CONSTEXPR(hasE<SysEqn>)
              a_variable(cellId, CV->RHO_E) =
                  m_PInfinity / gammaMinusOne
                  + F1B2 * POW2(a_variable(cellId, CV->RHO_U)) / a_variable(cellId, CV->RHO);
            }
            // Round jet end
            else {
              // zero velocity outside of the jet region;

              a_variable(cellId, CV->RHO) = m_rhoInfinity;
              a_variable(cellId, CV->RHO_U) = F0;
              a_variable(cellId, CV->RHO_V) = F0;
              IF_CONSTEXPR(nDim == 3) a_variable(cellId, CV->RHO_W) = F0;
              IF_CONSTEXPR(hasE<SysEqn>)
              a_variable(cellId, CV->RHO_E) =
                  m_PInfinity / gammaMinusOne + F1B2 * POW2(a_variable(cellId, CV->RHO_U)) / m_rhoInfinity;
            }
          }
          break;
        }

      case 1164: // Initial conditions for jets with chevron nozzles
        /* Compare Xia et. al. 2009, 1067-1079, Int.J.Heat&Fluid
         *  Xia 2015, 189-197, Comp&Fluids
         *
         *  IC for chevron nozzle jet flow smc000 configuration with the reference length D_j = 1.0
         */
        {
          // const MFloat inletRadius = m_inletRadius;
          const MFloat outletRadius = m_outletRadius;
          const MFloat scale = 1.0;         // TODO labels:FV from vitali, not used so far
          const MFloat nozzleExit = 2.5959; // TODO labels:FV FIXME hard-coded nozzle exit position

          // exit conditions
          const MFloat mach_j = m_nozzleExitMaJet;
          const MFloat temperature_j = m_nozzleExitTemp;
          const MFloat density_j = m_nozzleExitRho;
          // ambient conditions
          const MFloat pressureAmbient = m_PInfinity;
          const MFloat densityAmbient = m_rhoInfinity;

          for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
            const MFloat x = a_coordinate(cellId, 0);
            // Initialisation of the surrounding domain
            a_variable(cellId, CV->RHO) = densityAmbient;
            a_variable(cellId, CV->RHO_U) = 0.0;
            a_variable(cellId, CV->RHO_V) = 0.0;
            a_variable(cellId, CV->RHO_W) = 0.0;
            IF_CONSTEXPR(hasE<SysEqn>)
            a_variable(cellId, CV->RHO_E) = sysEqn().internalEnergy(pressureAmbient, densityAmbient, 0.0);

            // Note: assumes center of nozzle is y=z=0.0 and various other nozzle specific
            // parameters
            const MFloat radius = sqrt(POW2(a_coordinate(cellId, 1) - 0.0) + POW2(a_coordinate(cellId, 2) - 0.0));

            MFloat splineRadius = m_inletRadius;
            MFloat Ma_x = m_maNozzleInlet;

            // Check the spline functions
            if((x >= -1.0 * scale) && (x < 0.0 * scale)) {
              splineRadius = m_inletRadius;
              Ma_x = m_maNozzleInlet;
            }

            if((x >= 0.0 * scale) && (x < 0.25 * scale)) {
              splineRadius = (0.000352 * x * x * x) / (scale * scale) - (0.678568 * x * x) / scale + 0.84 * scale;
              Ma_x = m_maNozzleInlet;
            }

            if((x >= 0.25 * scale) && (x < 2.19473 * scale)) {
              splineRadius = -(0.049195 * x * x * x) / (scale * scale) + (0.236615 * x * x) / scale - 0.445812 * x
                             + 0.89286 * scale;
              Ma_x = 0.5;
            }

            if((x >= 2.19473 * scale) && (x < 2.5959 * scale)) {
              splineRadius = -(0.00011 * x * x * x) / (scale * scale) + (0.00072617 * x * x) / scale - 0.08883 * x
                             + 0.727624 * scale;
              Ma_x = 0.85;
            }

            // Newton-Method for calculating Ma_x = Ma(x)
            const MInt newtonSteps = 5;
            for(MInt n = 0; n < newtonSteps; n++) {
              const MFloat fkt_g = POW2(m_outletRadius / splineRadius) * m_maNozzleExit
                                   / pow(1 / (sysEqn().temperature_IR(m_maNozzleExit)), 3);
              const MFloat diff_g = -625 * (1 - POW2(Ma_x)) / pow(POW2(Ma_x) + 5, 4); // = g'(x_n)
              Ma_x = Ma_x - fkt_g / diff_g;
            }

            // Check the spline functions
            if((x >= -1.0 * scale) && (x < 0.0 * scale)) {
              splineRadius = m_inletRadius;
              Ma_x = m_maNozzleInlet;
            }

            if((x <= nozzleExit * scale) && (radius <= splineRadius)) {
              // Within the nozzle
              const MFloat temperature_x = sysEqn().temperature_IR(Ma_x);
              const MFloat pressure_x = sysEqn().pressure_IR(temperature_x);
              const MFloat density_x = sysEqn().density_ES(pressure_x, temperature_x);
              const MFloat u_jet = Ma_x * sysEqn().speedOfSound(temperature_x);
              const MFloat deltaMomentum = m_momentumThickness * splineRadius;
              const MFloat jet = tanh((splineRadius - radius) / (2.0 * deltaMomentum));

              // With Crocco-Busemann:
              a_variable(cellId, CV->RHO) = density_x / sysEqn().CroccoBusemann(Ma_x, jet);
              // Without Crocco-Busemann:
              // a_variable(cellId, CV->RHO) = density_x;

              a_variable(cellId, CV->RHO_U) = a_variable(cellId, CV->RHO) * u_jet * jet;
              a_variable(cellId, CV->RHO_V) = 0.0;
              a_variable(cellId, CV->RHO_W) = 0.0;

              IF_CONSTEXPR(hasE<SysEqn>) {
                a_variable(cellId, CV->RHO_E) =
                    sysEqn().internalEnergy(pressure_x, a_variable(cellId, CV->RHO), POW2(u_jet * jet));
              }

            } else if((x >= nozzleExit * scale) && (x <= 4.5 * scale) && (radius <= outletRadius)) {
              // Downstream of nozzle exit
              const MFloat xFactor = 0.5 * (1.0 + cos(PI / ((4.5 - nozzleExit) * scale) * (x - nozzleExit * scale)));
              const MFloat deltaMomentum = m_momentumThickness * outletRadius;

              const MFloat u_jet = xFactor * m_maNozzleExit * sqrt(temperature_j);
              const MFloat jet = tanh((outletRadius - radius) / (2.0 * deltaMomentum));

              // With Crocco-Busemann:
              const MFloat density_crocco = density_j / sysEqn().CroccoBusemann(mach_j, jet);
              // Without Crocco-Busemann:
              // MFloat density_crocco = density_j;

              a_variable(cellId, CV->RHO) = densityAmbient + (density_crocco - densityAmbient) * xFactor;

              a_variable(cellId, CV->RHO_U) = a_variable(cellId, CV->RHO) * u_jet * jet;
              a_variable(cellId, CV->RHO_V) = 0.0;
              a_variable(cellId, CV->RHO_W) = 0.0;

              IF_CONSTEXPR(hasE<SysEqn>) {
                a_variable(cellId, CV->RHO_E) =
                    pressureAmbient / (m_gamma - 1)
                    + 0.5 * POW2(a_variable(cellId, CV->RHO_U)) / (a_variable(cellId, CV->RHO));
              }
            }
          }
          break;
        }

        // pipe --> Alexej Pogorelov
      case 34: {
        IF_CONSTEXPR(nDim == 2) mTerm(-1, "Pipe IC in 2D meaningless, because of the use of deltaP_pipe!");

        /*! \page propertiesFV
          \section fluctuations
          <code>MInt FvCartesianSolverXD::initialCondition()::fluctuations</code>\n
          default = <code>0</code>\n \n
          If enabled adds velocity perturbations to the pipe initial condition 34. \n \n
          Possible values are:
          <ul>
            <li><code>0</code> (off)</li>
            <li><code>1</code> (on)</li>
          </ul>
          Keywords: <i>FINITE_VOLUME, INITIAL_CONDITION</i>
        */
        MBool fluctuations = false;
        fluctuations = Context::getSolverProperty<MBool>("fluctuations", m_solverId, AT_, &fluctuations);

        MFloat UT = m_Ma * sqrt(m_TInfinity);

        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          m_deltaP = 0.3164 / sqrt(sqrt(sysEqn().m_Re0)) * m_referenceLength * F1B2 * m_rhoInfinity * POW2(UT);
          // m_deltaP = 64 / m_Re0 * F1 / m_referenceLength * F1B2 * m_rhoInfinity * POW2(UT);
          m_fvBndryCnd->m_deltaP = m_deltaP;


          MFloat radius_1 =
              sqrt((a_coordinate(cellId, 1) - m_rotAxisCoord[0]) * (a_coordinate(cellId, 1) - m_rotAxisCoord[0])
                   + (a_coordinate(cellId, 2) - m_rotAxisCoord[1]) * (a_coordinate(cellId, 2) - m_rotAxisCoord[1]));
          MFloat fk = 0;

          if((a_coordinate(cellId, 0) > 4.0 && a_coordinate(cellId, 0) < 1.0)
             && radius_1 > 0.45) { // FIXME labels:FV,toenhance This can never be satisfied
            fk = 0;
          } else {
            if(cellId % 2 == 0) {
              fk = -F1;
            } else {
              fk = F1;
            }
          }

          if(!fluctuations) {
            fk = 0.0;
          }

          a_variable(cellId, CV->RHO) = m_rhoInfinity;
          a_variable(cellId, CV->RHO_VV[0]) = m_rhoVVInfinity[0] * 2.0 * (1.0 - (radius_1 / 0.5) * (radius_1 / 0.5))
                                              + (MFloat(rand()) / RAND_MAX) * 0.005 * UT * fk;
          for(MInt d = 1; d < nDim; d++) {
            a_variable(cellId, CV->RHO_VV[d]) = m_rhoVVInfinity[d] + (MFloat(rand()) / RAND_MAX) * 0.005 * UT * fk;
          }
          const MFloat pressure = m_PInfinity; // - m_deltaP *
          //( a_coordinate( cellId ,  0 )  );
          MFloat velPOW2 = 0;
          for(MInt d = 0; d < nDim; d++)
            velPOW2 += POW2(a_variable(cellId, CV->RHO_VV[d]));
          IF_CONSTEXPR(hasE<SysEqn>)
          a_variable(cellId, CV->RHO_E) = pressure / gammaMinusOne + F1B2 * velPOW2 / m_rhoInfinity;
        }
        break;
      }

        // cyl 3d
      case 36: {
        IF_CONSTEXPR(nDim == 2) mTerm(-1, "Pipe IC with 3D features in 2D meaningless!");

        MFloat UT = m_Ma * sqrt(m_TInfinity);
        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          m_deltaP = 3.0 * 64.0 / sysEqn().m_Re0 * F1 / m_referenceLength * F1B2 * m_rhoInfinity * POW2(m_UInfinity);
          m_fvBndryCnd->m_deltaP = m_deltaP;

          MFloat radius_1 =
              sqrt((a_coordinate(cellId, 1) - m_rotAxisCoord[0]) * (a_coordinate(cellId, 1) - m_rotAxisCoord[0])
                   + (a_coordinate(cellId, 2) - m_rotAxisCoord[1]) * (a_coordinate(cellId, 2) - m_rotAxisCoord[1]));

          MFloat phi_1 = 0;
          if((a_coordinate(cellId, 1) - m_rotAxisCoord[0]) >= 0 && (a_coordinate(cellId, 2) - m_rotAxisCoord[1]) >= 0) {
            phi_1 = asin((a_coordinate(cellId, 1) - m_rotAxisCoord[0]) / radius_1);
          } else if((a_coordinate(cellId, 1) - m_rotAxisCoord[0]) >= 0
                    && (a_coordinate(cellId, 2) - m_rotAxisCoord[1]) < 0) {
            phi_1 = PI - asin((a_coordinate(cellId, 1) - m_rotAxisCoord[0]) / radius_1);
          } else if((a_coordinate(cellId, 1) - m_rotAxisCoord[0]) < 0
                    && (a_coordinate(cellId, 2) - m_rotAxisCoord[1]) < 0) {
            phi_1 = PI - asin((a_coordinate(cellId, 1) - m_rotAxisCoord[0]) / radius_1);
          } else {
            phi_1 = 2 * PI + asin((a_coordinate(cellId, 1) - m_rotAxisCoord[0]) / radius_1);
          }
          MFloat fk = 0;

          // if((a_coordinate(cellId, 0) > 73.0 && a_coordinate(cellId, 0) < 1.0) && radius_1
          // > 24.0) {
          //  fk = 0;
          //}
          // else {
          // if(cellId % 2 == 0) {
          // fk = 0.0;//-F1;
          //} else { fk = 0.0; }// F1;
          //}
          a_variable(cellId, CV->RHO) = m_rhoInfinity;
          a_variable(cellId, CV->RHO_VV[0]) = m_rhoVVInfinity[0] + (MFloat(rand()) / RAND_MAX) * 0.0005 * UT * fk;
          a_variable(cellId, CV->RHO_VV[1]) =
              m_rhoVVInfinity[1] * cos(phi_1) / 29.0 * radius_1 + (MFloat(rand()) / RAND_MAX) * 0.0005 * UT * fk;
          a_variable(cellId, CV->RHO_VV[2]) =
              -m_rhoVVInfinity[1] * sin(phi_1) / 29.0 * radius_1 + (MFloat(rand()) / RAND_MAX) * 0.0005 * UT * fk;
          const MFloat pressure = m_PInfinity; // - m_deltaP *

          IF_CONSTEXPR(hasE<SysEqn>)
          a_variable(cellId, CV->RHO_E) =
              pressure / gammaMinusOne
              + (F1B2
                 * (POW2(m_rhoVVInfinity[0]) + POW2(m_rhoVVInfinity[1] * cos(phi_1) / 29.0 * radius_1)
                    + POW2(m_rhoVVInfinity[1] * sin(phi_1) / 29.0 * radius_1)))
                    * m_rhoInfinity;
        }
        break;
      }
      case 21: {
        IF_CONSTEXPR(nDim == 2) mTerm(-1, "Pipe IC with 3D features in 2D meaningless!");

        // circular pipe flow with square profile
        MFloat UT = m_Ma * sqrt(m_TInfinity);
        m_deltaP = 0.3164 / sqrt(sqrt(sysEqn().m_Re0)) * F5 * m_referenceLength * F1B2 * m_rhoInfinity * POW2(UT);

        m_fvBndryCnd->m_deltaP = m_deltaP;
        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          const MFloat pressure = m_PInfinity;

          a_variable(cellId, CV->RHO) = m_rhoInfinity;

          a_variable(cellId, CV->RHO_U) = F0;
          if(fabs(a_coordinate(cellId, 0)) < 0.2 || fabs(a_coordinate(cellId, 2)) < 0.2) {
            a_variable(cellId, CV->RHO_V) = m_rhoVInfinity;
          } else {
            a_variable(cellId, CV->RHO_V) = F0;
          }
          a_variable(cellId, CV->RHO_W) = F0;

          IF_CONSTEXPR(hasE<SysEqn>)
          a_variable(cellId, CV->RHO_E) =
              pressure / gammaMinusOne
              + (F1B2
                 * (POW2(a_variable(cellId, CV->RHO_VV[0])) + POW2(a_variable(cellId, CV->RHO_VV[1]))
                    + POW2(a_variable(cellId, CV->RHO_VV[2]))))
                    / m_rhoInfinity;
        }

        break;
      }
      case 22: { // round pipe -- Konstantin, Laurent (check also updateInfinityVar in FVMB)
        IF_CONSTEXPR(nDim == 2) mTerm(-1, AT_, "Pipe flow only implemented in 3D.");

        MFloat noPeriodicDirs = 0;
        for(MInt dim = 0; dim < nDim; dim++) {
          if(grid().periodicCartesianDir(dim)) {
            m_volumeForcingDir = dim;
            noPeriodicDirs++;
          }
        }
        if(noPeriodicDirs > 1) mTerm(1, AT_, "Only one periodic direction is implemented for the pipe case");
        if(m_volumeForcingDir == -1) mTerm(-1, AT_, "IC 22 requires a volumeForcingDir");

        // Reynolds set in properties is based on unit length L=1
        MInt Re_r = Context::getSolverProperty<MFloat>("Re", m_solverId, AT_) * m_pipeRadius;
        m_pipeRadius = Context::getSolverProperty<MFloat>("pipeRadius", m_solverId, AT_);

        MBool fluctuations = false;
        fluctuations = Context::getSolverProperty<MBool>("pipeFluctuations", m_solverId, AT_, &fluctuations);
        MFloat fluctuationsPercentage = 0.005;
        fluctuationsPercentage =
            Context::getSolverProperty<MFloat>("pipeFluctuationsPercentage", m_solverId, AT_, &fluctuationsPercentage);

        // Any other perpendicular direction indicates the pipe diameter
        const MInt rDir1 = ((m_volumeForcingDir + 1) % nDim);
        const MInt rDir2 = ((rDir1 + 1) % nDim);
        if(rDir1 == rDir2 || rDir1 == m_volumeForcingDir || rDir2 == m_volumeForcingDir)
          mTerm(-1, AT_, "Inconsistent dirs.");

        const MFloat pipeLength = computeDomainLength(m_volumeForcingDir);

        cerr0 << "Intialized with IC 22: found pipeRadius = " << m_pipeRadius << " and pipeLength = " << pipeLength
              << ". Fluctuations: " << fluctuations << " (" << fluctuationsPercentage << ")" << endl;

        MFloat lambda = F0;
        MFloat uMax = F2 * m_UInfinity;
        if(Re_r < 1500) {
          lambda = 32.0 / Re_r;
          if(domainId() == 0) cerr << "IC 22, using case Re<1500" << endl;
        } else {
          lambda = 0.316 / pow(Re_r * F2, 0.25);
          if(domainId() == 0) cerr << "IC 22, using case Re>=1500" << endl;
        }
        MFloat reTau = Re_r * sqrt(lambda / F8);
        MFloat uTau = reTau * m_Ma * sqrt(m_TInfinity) / Re_r;
        MFloat deltaP = F2 * m_rhoInfinity * POW2(uTau) * (pipeLength) / m_pipeRadius;
        m_volumeAcceleration[m_volumeForcingDir] = deltaP / (m_rhoInfinity * pipeLength);

        MFloat rMin = m_pipeRadius / F2;
        MFloat ampl = uMax * (F1 - POW2((m_pipeRadius - rMin / F4) / m_pipeRadius));
        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          if(a_isHalo(cellId)) continue;
          if(a_isPeriodic(cellId)) continue;
          if(a_isBndryGhostCell(cellId)) continue;
          // center of mass should be in the pipe axis
          const MFloat r = sqrt(POW2(a_coordinate(cellId, rDir1)) + POW2(a_coordinate(cellId, rDir2)));

          MFloat fk = F0;
          MFloat u = F0;
          // if within pipe set streamwise velocity to u else 0
          if(r <= m_pipeRadius) {
            if(Re_r > 1500) {
              const MFloat dist = m_pipeRadius - r;
              // faster convergence towards a turbulent profile via initial shear layer
              u = (dist > rMin ? (F1 - POW2(r / rMin)) * uMax : sin(dist / rMin * F2 * M_PI) * ampl);
            } else {
              u = (F1 - POW2(r / m_pipeRadius)) * uMax; // parabolic Poiseuille profile
            }
            if(fluctuations) {
              if(cellId % 2 == 0)
                fk = -F1;
              else
                fk = F1;
            }
          }
          MFloat fluct = fluctuationsPercentage * m_UInfinity * fk;
          a_pvariable(cellId, PV->VV[m_volumeForcingDir]) = u + (MFloat(rand()) / RAND_MAX) * fluct;
          a_pvariable(cellId, PV->VV[rDir1]) = (MFloat(rand()) / RAND_MAX) * fluct;
          a_pvariable(cellId, PV->VV[rDir2]) = (MFloat(rand()) / RAND_MAX) * fluct;
          a_pvariable(cellId, PV->P) = m_PInfinity;
          a_pvariable(cellId, PV->RHO) = sysEqn().density_ES(m_PInfinity, m_TInfinity);
        }
        exchange();
        computeConservativeVariables();
        break;
      }
      case 30:
      case 45302: { // careful, special setting for TINA engine triggered with TINA_TC keyword!
        IF_CONSTEXPR(nDim == 2) mTerm(-1, "This is a 3D IC!");
        MFloat UT = m_Ma * sqrt(m_TInfinity);
        if((string2enum(m_testCaseName) == SUZI_TC) || (string2enum(m_testCaseName) == TINA_TC)) {
          m_deltaP = 64 / sysEqn().m_Re0 * F1 / m_referenceLength * F1B2 * m_rhoInfinity * POW2(UT) / 10.0;
        } else {
          m_deltaP = 64 / sysEqn().m_Re0 * F1 / m_referenceLength * F1B2 * m_rhoInfinity * POW2(UT) / 5.0;
        }
        m_log << " Initializing pressure difference: m_deltaP = " << m_deltaP
              << " (built with m_Re0 = " << sysEqn().m_Re0 << " , refLength = " << m_referenceLength << ")" << endl;
        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          a_variable(cellId, CV->RHO) = 1.0;
          for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
            a_variable(cellId, CV->RHO_VV[spaceId]) = 0;
          }
          IF_CONSTEXPR(hasE<SysEqn>)
          a_variable(cellId, CV->RHO_E) = sysEqn().pressureEnergy(sysEqn().p_Ref());
        }

        computePV();

        for(MInt bndryId = 0; bndryId < m_bndryCells->size(); bndryId++) {
          MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
          for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
            for(MInt v = 0; v < PV->noVariables; v++) {
              // compute initial image point value
              m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_imageVariables[v] =
                  a_pvariable(cellId, v);
              a_pvariable(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId, v) =
                  a_pvariable(cellId, v);
            }
          }
        }
        break;
      }

        ///* one or two initial flame field with plenum above (tested for flame tube radius chosen
        /// to 0.2), forced response (for G-equation/progress variable)
      case 1751600:
      case 2751600: {
        IF_CONSTEXPR(nDim == 2) mTerm(-1, "This is a 3D IC!");
        IF_CONSTEXPR(!hasPV_C<SysEqn>::value) mTerm(1, AT_, "SysEqn not suitable!");
        else {
          MFloat err = 0.01;
          MFloat activationTemperature = 30;
          MFloat alpha = F1 - F1 / mMax(1.1, m_burntUnburntTemperatureRatio);
          MFloat beta = alpha * activationTemperature / m_burntUnburntTemperatureRatio;
          MFloat filteredFlameThickness = 10.0 * m_subfilterVariance * c_cellLengthAtLevel(maxRefinementLevel());
          MFloat theta = F0, c = F0, x, xCoord, zCoord;
          MFloat jetArea = F0, jetInflowArea = F0, massflux = F0;
          MFloat factor1, factor2;

          //---
          for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
            xCoord = a_coordinate(cellId, 0);
            zCoord = a_coordinate(cellId, 2);

            if((xCoord > -m_radiusFlameTube - err) && (xCoord < m_radiusFlameTube + err)
               && (zCoord > -m_jetHalfLength - err) && (zCoord < m_jetHalfLength + err)) {
              MFloat minXG = ABS(xCoord) - (m_jetHalfWidth + err);
              MFloat minZG = ABS(zCoord) - (m_jetHalfLength + err);
              MFloat maxG = mMax(minXG, minZG);

              x = sqrt(2.0 - 1.0) * m_initialFlameHeight * maxG + a_coordinate(cellId, 1) - m_yOffsetFlameTube;

              if(x < F0) {
                theta = (F1 - F1 / beta) * exp(x / filteredFlameThickness);
                c = m_c0 * exp(x / filteredFlameThickness);
                // progress variabel in unburnt premixed gas
              } else {
                theta = F1 - F1 / beta * exp((F1 - beta) * x / filteredFlameThickness);
                c = F1 - (F1 - m_c0) * exp(-x * m_c0 / ((F1 - m_c0) * filteredFlameThickness));
                // progress variabel in burnt premixed gas
              }
            } else {
              x = a_coordinate(cellId, 1) - 1.0;
              if(x < F0) {
                theta = (F1 - F1 / beta) * exp(x / filteredFlameThickness);
                c = m_c0 * exp(x / filteredFlameThickness);
              } else {
                theta = F1 - F1 / beta * exp((F1 - beta) * x / filteredFlameThickness);
                c = F1 - (F1 - m_c0) * exp(-x * m_c0 / ((F1 - m_c0) * filteredFlameThickness));
              }
            }
            // compute the density
            a_variable(cellId, CV->RHO) =
                m_rhoFlameTube + (m_rhoFlameTube / m_burntUnburntTemperatureRatio - m_rhoFlameTube) * theta;
            // compute the specific momentum
            a_variable(cellId, CV->RHO_U) = F0;
            a_variable(cellId, CV->RHO_W) = F0;

            factor1 = a_coordinate(cellId, 0);
            //		factor2 = a_coordinate( cellId , 1);
            factor2 = a_coordinate(cellId, 2);


            if(fabs(a_coordinate(cellId, 0)) <= m_jetHalfWidth && fabs(a_coordinate(cellId, 2)) <= m_jetHalfLength
               && fabs(a_coordinate(cellId, 1)) <= 4.5) {
              a_variable(cellId, CV->RHO_V) = a_variable(cellId, CV->RHO) * m_Ma
                                              * (F1B2 * (1 + tanh(m_shearLayerThickness * (factor1 + m_jetHalfWidth)))
                                                     * (1 - tanh(m_shearLayerThickness * (factor1 - m_jetHalfWidth)))
                                                 - 1)
                                              * (F1B2 * (1 + tanh(m_shearLayerThickness * (factor2 + m_jetHalfLength)))
                                                     * (1 - tanh(m_shearLayerThickness * (factor2 - m_jetHalfLength)))
                                                 - 1);

              jetArea = POW2(c_cellLengthAtCell(cellId));
              if(cellId < noInternalCells() && c_isLeafCell(cellId)) {
                massflux += a_variable(cellId, CV->RHO_V) * jetArea;
                jetInflowArea += jetArea;
              }
            } else {
              a_variable(cellId, CV->RHO_V) = a_variable(cellId, CV->RHO) * m_Ma * 0.5;
            }


            //	    a_variable( cellId ,  CV->RHO_E ) = m_pressureFlameTube / gammaMinusOne + F1B2 *
            // POW2( m_velocityFlameTube ) * a_variable( cellId ,  CV->RHO );
            // progress variable
            IF_CONSTEXPR(hasPV_C<SysEqn>::value)
            a_variable(cellId, CV->RHO_C) = a_variable(cellId, CV->RHO) * c;
          }

          MPI_Allreduce(MPI_IN_PLACE, &massflux, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "massflux");
          MPI_Allreduce(MPI_IN_PLACE, &jetInflowArea, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                        "jetInflowArea");

          // compute massflux per unit area
          massflux /= jetInflowArea;

          // compute static pressure and density iteratively (see e.g. thesis of Ingolf Hoerschler)
          m_jetPressure = sysEqn().p_Ref();
          for(MInt i = 0; i < 20; i++) {
            m_jetPressure = pow((1 - gammaMinusOne / F2 * pow(m_jetPressure, -2.0 / m_gamma) * POW2(massflux)),
                                (m_gamma * FgammaMinusOne));
          }
          m_jetDensity = sysEqn().density_IR_P(m_jetPressure);
          m_jetPressure = m_jetPressure / m_gamma;
          m_jetTemperature = sysEqn().temperature_ES(m_jetDensity, m_jetPressure);
          m_log << "calculated pressure" << m_jetPressure << endl;
          m_log << "calculated density" << m_jetDensity << endl;
          m_log << "calculated temperature" << m_jetTemperature << endl;
          m_log << "calculated massflux" << massflux << endl;


          for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
            IF_CONSTEXPR(hasE<SysEqn>)
            a_variable(cellId, CV->RHO_E) =
                m_jetPressure / gammaMinusOne + F1B2 * POW2(a_variable(cellId, CV->RHO_V)) / m_rhoInfinity;
          }
        }

        break;
      }
      case 5401000: {
        IF_CONSTEXPR(!hasPV_C<SysEqn>::value) mTerm(1, AT_, "SysEqn not suitable!");
        else {
          MFloat err = 0.0001;
          MFloat activationTemperature = 30;
          MFloat alpha = F1 - F1 / mMax(1.1, m_burntUnburntTemperatureRatio);
          MFloat beta = alpha * activationTemperature / m_burntUnburntTemperatureRatio;
          MFloat filteredFlameThickness = 10.0 * m_subfilterVariance * c_cellLengthAtLevel(maxRefinementLevel());
          MFloat theta = F0, c = F0, x, xCoord, zCoord;
          MFloat jetArea = F0, jetInflowArea = F0, massflux = F0;
          MFloat radius;

          //---
          for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
            xCoord = a_coordinate(cellId, 0);
            zCoord = a_coordinate(cellId, 2);
            radius = sqrt(POW2(xCoord) + POW2(zCoord));

            if((radius > -0.52 - err) && (radius < 0.52 + err)) {
              MFloat maxG = ABS(radius) - (0.52 + err);
              x = sqrt(2.0 - 1.0) * m_initialFlameHeight * maxG + a_coordinate(cellId, 1) - m_yOffsetFlameTube;

              if(x < F0) {
                theta = (F1 - F1 / beta) * exp(x / filteredFlameThickness);
                c = m_c0 * exp(x / filteredFlameThickness);
                // progress variabel in unburnt premixed gas
              } else {
                theta = F1 - F1 / beta * exp((F1 - beta) * x / filteredFlameThickness);
                c = F1 - (F1 - m_c0) * exp(-x * m_c0 / ((F1 - m_c0) * filteredFlameThickness));
                // progress variabel in burnt premixed gas
              }
            } else {
              x = a_coordinate(cellId, 1) - 1.0;
              if(x < F0) {
                theta = (F1 - F1 / beta) * exp(x / filteredFlameThickness);
                c = m_c0 * exp(x / filteredFlameThickness);
              } else {
                theta = F1 - F1 / beta * exp((F1 - beta) * x / filteredFlameThickness);
                c = F1 - (F1 - m_c0) * exp(-x * m_c0 / ((F1 - m_c0) * filteredFlameThickness));
              }
            }
            // compute the density
            a_variable(cellId, CV->RHO) =
                m_rhoFlameTube + (m_rhoFlameTube / m_burntUnburntTemperatureRatio - m_rhoFlameTube) * theta;
            // compute the specific momentum
            a_variable(cellId, CV->RHO_U) = F0;
            a_variable(cellId, CV->RHO_W) = F0;

            radius = sqrt(POW2(xCoord) + POW2(zCoord));


            if(radius <= 0.52 && fabs(a_coordinate(cellId, 1)) <= 4.5) {
              a_variable(cellId, CV->RHO_V) = a_variable(cellId, CV->RHO) * m_Ma
                                              * (F1B2 * (1 + tanh(m_shearLayerThickness * (radius + 0.5)))
                                                     * (1 - tanh(m_shearLayerThickness * (radius - 0.5)))
                                                 - 1);

              jetArea = POW2(c_cellLengthAtCell(cellId));
              if(cellId < noInternalCells() && c_isLeafCell(cellId)) {
                massflux += a_variable(cellId, CV->RHO_V) * jetArea;
                jetInflowArea += jetArea;
              }
            } else {
              a_variable(cellId, CV->RHO_V) = a_variable(cellId, CV->RHO) * m_Ma * 0.5;
            }
            // progress variable
            IF_CONSTEXPR(hasPV_C<SysEqn>::value)
            a_variable(cellId, CV->RHO_C) = a_variable(cellId, CV->RHO) * c;
          }

          MPI_Allreduce(MPI_IN_PLACE, &massflux, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "massflux");
          MPI_Allreduce(MPI_IN_PLACE, &jetInflowArea, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                        "jetInflowArea");

          // compute massflux per unit area
          massflux /= jetInflowArea;

          // compute static pressure and density iteratively (see e.g. thesis of Ingolf Hoerschler)
          m_jetPressure = sysEqn().p_Ref();
          for(MInt i = 0; i < 20; i++) {
            m_jetPressure = pow((1 - gammaMinusOne / F2 * pow(m_jetPressure, -2.0 / m_gamma) * POW2(massflux)),
                                (m_gamma * FgammaMinusOne));
          }
          m_jetDensity = sysEqn().density_IR_P(m_jetPressure);
          m_jetPressure = m_jetPressure / m_gamma;
          m_jetTemperature = sysEqn().temperature_ES(m_jetDensity, m_jetPressure);
          m_log << "calculated pressure" << m_jetPressure << endl;
          m_log << "calculated density" << m_jetDensity << endl;
          m_log << "calculated temperature" << m_jetTemperature << endl;
          m_log << "calculated massflux" << massflux << endl;


          for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
            IF_CONSTEXPR(hasE<SysEqn>)
            a_variable(cellId, CV->RHO_E) =
                m_jetPressure / gammaMinusOne + F1B2 * POW2(a_variable(cellId, CV->RHO_V)) / m_rhoInfinity;
          }
        }

        break;
      }

      case 1184: { // initial condition for fvape::lae convergence test: pulse for RHO_U
        if(Context::getSolverProperty<MString>("solvertype", m_solverId, AT_) != "MAIA_FV_APE") {
          mTerm(1, "this initial condition is for the FV_APE solver only");
        }
        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          // compute squared distance from pulse center at (0.5,0.5) for 2D and (0.5, 0.5, 0.5) for
          // 3D cases
          MFloat pulse_center_length_unnormed = 0.0;
          for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
            pulse_center_length_unnormed += std::pow(a_coordinate(cellId, spaceId) - 0.5, 2.0);
          }
          // set other variables to free stream values
          IF_CONSTEXPR(hasE<SysEqn>)
          a_variable(cellId, CV->RHO_E) = m_rhoEInfinity;
          a_variable(cellId, CV->RHO) = m_rhoInfinity;

          // initialize velocity densities in y (and z) - direction to zero (just to be sure)
          for(MInt spaceId = 1; spaceId < nDim; spaceId++) {
            a_variable(cellId, CV->RHO_VV[spaceId]) = 0;
          }
          // set RHO_U to pulse initial condition
          a_variable(cellId, CV->RHO_VV[0]) =
              m_rhoVVInfinity[0] * (1.0 + std::exp(-pulse_center_length_unnormed * 20.0));
        }
        break;
      }

      case 361: // spinning vortices
      {
        // Fixed values for initial time and density
        const MFloat t = 0.0;
        const MFloat rho = 1.0;

        // Get circulation (gamma) and core radius (rC) parameters from properties
        /*! \page propertiesFV
         \section circulation
         <code>MFloat FvCartesianSolverXD::initialcondition::circulation (local) </code>\n
         default = <code>none</code>\n
         circulation of spinning vortices in initial condition 361.\n
         Possible values are:
         <ul>
           <li>values > 0 and < O(lengthLevel0) </li>
         </ul>
         Keywords: <i>FINITE VOLUME, INITIAL CONDITION, SPINNING VORTEX</i>
       */
        const MFloat gamma = Context::getSolverProperty<MFloat>("circulation", m_solverId, AT_);

        /*! \page propertiesFV
          \section coreRadius
          <code>MFloat FvCartesianSolverXD::initialcondition::coreRadius (local) </code>\n
          default = <code>none</code>\n
          Core radius of spinning vortices in initial condition 361.\n
          Possible values are:
          <ul>
            <li>values > 0 and < O(lengthLevel0) </li>
          </ul>
          Keywords: <i>FINITE VOLUME, INITIAL CONDITION, SPINNING VORTEX</i>
        */
        const MFloat rC = Context::getSolverProperty<MFloat>("coreRadius", m_solverId, AT_);

        // Vatistas vortex core model (nC = 1 corresponds to Scully model)
        MInt nC = 1;
        nC = Context::getSolverProperty<MInt>("coreModelExponent", m_solverId, AT_, &nC);

        // Calculate rotation frequency and offsets
        const MFloat omega = gamma / 4. / PI;
        const MFloat bx = cos(omega * t);
        const MFloat by = sin(omega * t);

        // Set initial condition for all cells
        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          // Calculate vortex-local coordinates
          const MFloat x = a_coordinate(cellId, 0);
          const MFloat y = a_coordinate(cellId, 1);
          const MFloat rPos = sqrt(POW2(x - bx) + POW2(y - by));
          const MFloat thetaPos = atan2(y - by, x - bx);
          const MFloat rNeg = sqrt(POW2(x + bx) + POW2(y + by));
          const MFloat thetaNeg = atan2(y + by, x + bx);

          // Determine velocity from potential flow theory (x-direction)
          MFloat ux = 0.;
          if(nC == 1) {
            ux += rPos / (rC * rC + rPos * rPos) * sin(thetaPos);
            ux += rNeg / (rC * rC + rNeg * rNeg) * sin(thetaNeg);
          } else {
            ux += rPos / pow(pow(rC, 2 * nC) + pow(rPos, 2 * nC), 1.0 / nC) * sin(thetaPos);
            ux += rNeg / pow(pow(rC, 2 * nC) + pow(rNeg, 2 * nC), 1.0 / nC) * sin(thetaNeg);
          }
          ux *= -gamma / 2. / PI;

          // Determine velocity from potential flow theory (y-direction)
          MFloat uy = 0.;
          if(nC == 1) {
            uy += rPos / (rC * rC + rPos * rPos) * cos(thetaPos);
            uy += rNeg / (rC * rC + rNeg * rNeg) * cos(thetaNeg);
          } else {
            uy += rPos / pow(pow(rC, 2 * nC) + pow(rPos, 2 * nC), 1.0 / nC) * cos(thetaPos);
            uy += rNeg / pow(pow(rC, 2 * nC) + pow(rNeg, 2 * nC), 1.0 / nC) * cos(thetaNeg);
          }
          uy *= gamma / 2. / PI;

          // Determine pressure using steady-state Bernoulli equation
          const MFloat p = 1. / m_gamma - 0.5 * rho * (ux * ux + uy * uy);

          // Set conservative variables
          a_variable(cellId, CV->RHO) = rho;
          a_variable(cellId, CV->RHO_VV[0]) = rho * ux;
          a_variable(cellId, CV->RHO_VV[1]) = rho * uy;
          IF_CONSTEXPR(hasE<SysEqn>) {
            a_variable(cellId, CV->RHO_E) = sysEqn().internalEnergy(p, rho, (ux * ux + uy * uy));
          }

          // Set primitive variables
          a_pvariable(cellId, PV->P) = p;
          a_pvariable(cellId, PV->RHO) = rho;
          a_pvariable(cellId, PV->U) = ux;
          a_pvariable(cellId, PV->V) = uy;
        }
        break;
      }

        // vortex dipole - cylinder interaction (Lamb vortex)
        // thickened flame test cases
        // parallel inflow field with a burnt circle in the middle
        // hybrid capturing-tracking scheme
        // Bunsen flame
        // Bunsen flame (G-equation)
        // steady flame front in a duct
        // vortex-flame interactions (for G-equation/progress variable)
        // DL instability (for G-equation/progress variable) optimized version
        ///* one or two initial flame field with plenum above (tested for flame tube radius chosen
        /// to 0.2), forced response (for G-equation/progress variable)
      case 17516: {
        MFloat err = 0.01;
        MFloat activationTemperature = 30;
        MFloat alpha = F1 - F1 / mMax(1.1, m_burntUnburntTemperatureRatio);
        MFloat beta = alpha * activationTemperature / m_burntUnburntTemperatureRatio;
        MFloat filteredFlameThickness = 10.0 * m_subfilterVariance * c_cellLengthAtLevel(maxRefinementLevel());
        MFloat theta = F0, c = F0, x;
        IF_CONSTEXPR(!hasPV_C<SysEqn>::value) std::ignore = c;
        MFloat deltaX = m_flameRadiusOffset;

        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          // two flame initial field
          if(m_twoFlames) {
            err = 0.2;
            // first flame surface
            if((a_coordinate(cellId, 0) <= m_radiusFlameTube + m_xOffsetFlameTube + err)
               && (a_coordinate(cellId, 0) >= -m_radiusFlameTube + m_xOffsetFlameTube - err)) {
              x = sqrt(2.0 - 1.0) * (ABS(a_coordinate(cellId, 0) - m_xOffsetFlameTube) - m_radiusFlameTube)
                  + a_coordinate(cellId, 1) - m_yOffsetFlameTube;

              if((x < F0)) {
                theta = (F1 - F1 / beta) * exp(x / filteredFlameThickness);
                c = m_c0 * exp(x / filteredFlameThickness);
                // progress variabel in unburnt premixed gas
              } else {
                theta = F1 - F1 / beta * exp((F1 - beta) * x / filteredFlameThickness);
                c = F1 - (F1 - m_c0) * exp(-x * m_c0 / ((F1 - m_c0) * filteredFlameThickness));
                // progress variabel in burnt premixed gas
              }
              // second flame surface
            } else if((a_coordinate(cellId, 0) <= (m_radiusFlameTube2 + m_xOffsetFlameTube2 + err))
                      && (a_coordinate(cellId, 0) >= (-m_radiusFlameTube2 + m_xOffsetFlameTube2 - err))) {
              x = sqrt(2.0 - 1.0) * (ABS(a_coordinate(cellId, 0) - m_xOffsetFlameTube2) - m_radiusFlameTube2)
                  + a_coordinate(cellId, 1) - m_yOffsetFlameTube2;

              if(x < F0) {
                theta = (F1 - F1 / beta) * exp(x / filteredFlameThickness);
                c = m_c0 * exp(x / filteredFlameThickness);
              } else {
                theta = F1 - F1 / beta * exp((F1 - beta) * x / filteredFlameThickness);
                c = F1 - (F1 - m_c0) * exp(-x * m_c0 / ((F1 - m_c0) * filteredFlameThickness));
              }
              // defining the initial function outside the domain between the tubes
            } else if(((a_coordinate(cellId, 0) > (m_radiusFlameTube + m_xOffsetFlameTube + err))
                       || (a_coordinate(cellId, 0) < (-m_radiusFlameTube + m_xOffsetFlameTube - err)))
                      && (a_coordinate(cellId, 0) >= 0.0)) {
              x = a_coordinate(cellId, 1) + 0.5;
              if(x < F0) {
                theta = (F1 - F1 / beta) * exp(x / filteredFlameThickness);
                c = m_c0 * exp(x / filteredFlameThickness);
              } else {
                theta = F1 - F1 / beta * exp((F1 - beta) * x / filteredFlameThickness);
                c = F1 - (F1 - m_c0) * exp(-x * m_c0 / ((F1 - m_c0) * filteredFlameThickness));
              }
              // defining the initial function outside the domain between the tubes
            } else if(((a_coordinate(cellId, 0) > (m_radiusFlameTube2 + m_xOffsetFlameTube2 + err))
                       || (a_coordinate(cellId, 0) < (-m_radiusFlameTube2 + m_xOffsetFlameTube2 - err)))
                      && (a_coordinate(cellId, 0) < 0.0)) {
              x = a_coordinate(cellId, 1) + 0.5;
              if((x < F0)) {
                theta = (F1 - F1 / beta) * exp(x / filteredFlameThickness);
                c = m_c0 * exp(x / filteredFlameThickness);
              } else {
                theta = F1 - F1 / beta * exp((F1 - beta) * x / filteredFlameThickness);
                c = F1 - (F1 - m_c0) * exp(-x * m_c0 / ((F1 - m_c0) * filteredFlameThickness));
              }
            }

            // one flame initial field with plenum
          } else if(m_plenum) {
            // determine the reduced temperature and the progress variable
            if((a_coordinate(cellId, 0) <= m_radiusFlameTube + m_xOffsetFlameTube + err)
               && (a_coordinate(cellId, 0) >= -m_radiusFlameTube + m_xOffsetFlameTube - err)) {
              x = sqrt(2.0 - 1.0) * (ABS(a_coordinate(cellId, 0) - m_xOffsetFlameTube) - m_radiusFlameTube)
                  + a_coordinate(cellId, 1) - m_yOffsetFlameTube;

              if((x < F0)) {
                theta = (F1 - F1 / beta) * exp(x / filteredFlameThickness);
                c = m_c0 * exp(x / filteredFlameThickness);
                // progress variabel in unburnt premixed gas
              } else {
                theta = F1 - F1 / beta * exp((F1 - beta) * x / filteredFlameThickness);
                c = F1 - (F1 - m_c0) * exp(-x * m_c0 / ((F1 - m_c0) * filteredFlameThickness));
                // progress variabel in burnt premixed gas
              }


              // defining the initial function outside the domain
            } else if((a_coordinate(cellId, 0) > m_radiusFlameTube + err)
                      || (a_coordinate(cellId, 0) < -(m_radiusFlameTube + err))) {
              x = a_coordinate(cellId, 1) + 0.5;
              if((x < F0)) {
                theta = (F1 - F1 / beta) * exp(x / filteredFlameThickness);
                c = m_c0 * exp(x / filteredFlameThickness);
              } else {
                theta = F1 - F1 / beta * exp((F1 - beta) * x / filteredFlameThickness);
                c = F1 - (F1 - m_c0) * exp(-x * m_c0 / ((F1 - m_c0) * filteredFlameThickness));
              }
            }
            // one flame initial field without plenum
          } else {
            x = sqrt(2.0 - 1.0) * (ABS(a_coordinate(cellId, 0) - m_xOffsetFlameTube) - (m_radiusFlameTube + deltaX))
                + a_coordinate(cellId, 1) - m_yOffsetFlameTube;

            if(x < F0) {
              theta = (F1 - F1 / beta) * exp(x / filteredFlameThickness);
              c = m_c0 * exp(x / filteredFlameThickness);
              // progress variabel in unburnt premixed gas
            } else {
              theta = F1 - F1 / beta * exp((F1 - beta) * x / filteredFlameThickness);
              c = F1 - (F1 - m_c0) * exp(-x * m_c0 / ((F1 - m_c0) * filteredFlameThickness));
              // progress variabel in burnt premixed gas
            }
          }


          // compute the density
          a_variable(cellId, CV->RHO) =
              m_rhoFlameTube + (m_rhoFlameTube / m_burntUnburntTemperatureRatio - m_rhoFlameTube) * theta;
          // compute the specific momentum
          a_variable(cellId, CV->RHO_U) = F0;
          a_variable(cellId, CV->RHO_V) =
              a_variable(cellId, CV->RHO) * m_velocityFlameTube; // a_variable( cellId ,  CV->RHO ) * ( v0 );
          IF_CONSTEXPR(hasE<SysEqn>)
          a_variable(cellId, CV->RHO_E) =
              m_pressureFlameTube / gammaMinusOne + F1B2 * POW2(m_velocityFlameTube) * a_variable(cellId, CV->RHO);
          // progress variable
          IF_CONSTEXPR(hasPV_C<SysEqn>::value)
          a_variable(cellId, CV->RHO_C) = a_variable(cellId, CV->RHO) * c;

          if(m_twoFlames) {
            a_variable(cellId, CV->RHO_V) =
                a_variable(cellId, CV->RHO) * m_velocityFlameTube; // a_variable( cellId ,  CV->RHO ) * ( v0 );
            IF_CONSTEXPR(hasE<SysEqn>)
            a_variable(cellId, CV->RHO_E) =
                m_pressureFlameTube / gammaMinusOne + F1B2 * POW2(m_velocityFlameTube) * a_variable(cellId, CV->RHO);
          }
        }

        break;
      }

        /// SFB686 Bielefeld burner initial field
        // symmetric flame (tested for tube radius chosen to 0.5), forced response (for
        // G-equation/progress variable)

      default: {
        stringstream errorMessage;
        errorMessage << "WARNING: Initial condition " << m_initialCondition << ", does not exist" << endl;
        if(domainId() == 0) {
          cerr << errorMessage.str() << endl;
        }
        m_log << errorMessage.str() << endl;
        // mTerm(1, AT_, errorMessage.str());
        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          // parallel inflow field
          a_variable(cellId, CV->RHO) = m_rhoInfinity;
          for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
            a_variable(cellId, CV->RHO_VV[spaceId]) = m_rhoVVInfinity[spaceId];
          }
          IF_CONSTEXPR(hasE<SysEqn>)
          a_variable(cellId, CV->RHO_E) = m_rhoEInfinity;
        }
        break;
      }
    } // switch(m_initialCondition)
  } else {
    // initialize all ghost cells
    for(MInt bndryId = 0; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
      MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
      for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        MInt ghostCellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
        for(MInt varId = 0; varId < noCVars; varId++) {
          a_variable(ghostCellId, varId) = a_variable(cellId, varId);
        }
      }
    }
  }

  if(!m_combustion) {
    MFloat L = F1;
    /*! \page propertiesFV
      \section pressureDropLength
      <code>MFloat FvCartesianSolverXD::L </code>\n
      default = <code>1</code>\n \n
      Sets the length of the pressure drop \n
      Also used in FvCartesianSolverXD.cpp \n
      Possible values are:
      <ul>
      <li> non-negative values</li>
      </ul>
      Keywords: <i> FINITE_VOLUME, PRESSURE </i>
    */
    L = Context::getSolverProperty<MFloat>("pressureDropLength", m_solverId, AT_, &L);
    m_deltaPL = m_deltaP * L;
    m_fvBndryCnd->m_deltaP = m_deltaP;
    m_fvBndryCnd->m_deltaPL = m_deltaPL;
  }

  // Initialize all old cell variables with the conservative variables
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    for(MInt varId = 0; varId < noCVars; varId++) {
      a_oldVariable(cellId, varId) = a_variable(cellId, varId);
    }
  }

  // For dual time stepping, initialize additional variables as well
  if(m_dualTimeStepping) {
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      for(MInt varId = 0; varId < noCVars; varId++) {
        a_dt1Variable(cellId, varId) = a_variable(cellId, varId);
        a_dt2Variable(cellId, varId) = a_variable(cellId, varId);
      }
    }
  }

  m_log << "**************************" << endl;
  m_log << "Initial Condition summary" << endl;
  m_log << "**************************" << endl;
  m_log << "Re = " << m_Re << endl;
  m_log << "Re0 = " << sysEqn().m_Re0 << endl;
  m_log << "Ma = " << m_Ma << endl;
  m_log << "TInfinity = " << m_TInfinity << endl;
  m_log << "UInfinity = " << m_UInfinity << endl;
  m_log << "VInfinity = " << m_VInfinity << endl;
  IF_CONSTEXPR(nDim == 3) { m_log << "WInfinity = " << m_WInfinity << endl; }
  m_log << "PInfinity = " << m_PInfinity << endl;
  m_log << "rhoInfinity = " << m_rhoInfinity << endl;
  m_log << "rhoEInfinity = " << m_rhoEInfinity << endl;
  m_log << "muInfinity = " << sysEqn().m_muInfinity << endl;
  m_log << "DInfinity = " << m_DInfinity << endl;
  m_log << "DthInfinity = " << m_DthInfinity << endl;
  m_log << "timeRef = " << m_timeRef << endl;

  checkInfinityVarsConsistency();

  // check initial condition
  if(!m_restart && !m_resetInitialCondition) {
    for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
      for(MInt v = 0; v < CV->noVariables; v++) {
        if(std::isnan(a_variable(cellId, v))) {
          cerr << "Variable " << v << " cellId : " << cellId << endl;
          mTerm(1, AT_, "Invalid initialcondition formulation!");
        }
      }
    }
  }
}


/// \brief Check that all infinity (or other global) variables are equal on all ranks
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::checkInfinityVarsConsistency() {
  TRACE();

  std::vector<MFloat> infVars{};
  std::vector<MString> infVarNames{};

  infVars.push_back(m_UInfinity);
  infVarNames.push_back("m_UInfinity");
  infVars.push_back(m_VInfinity);
  infVarNames.push_back("m_VInfinity");
  IF_CONSTEXPR(nDim == 3) {
    infVars.push_back(m_WInfinity);
    infVarNames.push_back("m_WInfinity");
  }
  infVars.push_back(m_PInfinity);
  infVarNames.push_back("m_PInfinity");
  infVars.push_back(m_TInfinity);
  infVarNames.push_back("m_TInfinity");
  infVars.push_back(m_DthInfinity);
  infVarNames.push_back("m_DthInfinity");
  infVars.push_back(sysEqn().m_muInfinity);
  infVarNames.push_back("m_muInfinity");
  infVars.push_back(m_DInfinity);
  infVarNames.push_back("m_DInfinity");
  infVars.push_back(m_SInfinity);
  infVarNames.push_back("m_SInfinity");
  infVars.push_back(m_hInfinity);
  infVarNames.push_back("m_hInfinity");

  infVars.push_back(m_VVInfinity[0]);
  infVarNames.push_back("m_VVInfinity[0]");
  infVars.push_back(m_VVInfinity[1]);
  infVarNames.push_back("m_VVInfinity[1]");
  IF_CONSTEXPR(nDim == 3) {
    infVars.push_back(m_VVInfinity[2]);
    infVarNames.push_back("m_VVInfinity[2]");
  }

  infVars.push_back(m_rhoUInfinity);
  infVarNames.push_back("m_rhoUInfinity");
  infVars.push_back(m_rhoVInfinity);
  infVarNames.push_back("m_rhoVInfinity");
  IF_CONSTEXPR(nDim == 3) {
    infVars.push_back(m_rhoWInfinity);
    infVarNames.push_back("m_rhoWInfinity");
  }
  infVars.push_back(m_rhoEInfinity);
  infVarNames.push_back("m_rhoEInfinity");
  infVars.push_back(m_rhoInfinity);
  infVarNames.push_back("m_rhoInfinity");

  infVars.push_back(m_rhoVVInfinity[0]);
  infVarNames.push_back("m_rhoVVInfinity[0]");
  infVars.push_back(m_rhoVVInfinity[1]);
  infVarNames.push_back("m_rhoVVInfinity[1]");
  IF_CONSTEXPR(nDim == 3) {
    infVars.push_back(m_rhoVVInfinity[2]);
    infVarNames.push_back("m_rhoVVInfinity[2]");
  }

  infVars.push_back(m_Ma);
  infVarNames.push_back("m_Ma");
  infVars.push_back(sysEqn().m_Re0);
  infVarNames.push_back("m_Re0");
  infVars.push_back(m_rRe0);
  infVarNames.push_back("m_rRe0");
  infVars.push_back(m_timeRef);
  infVarNames.push_back("m_timeRef");
  infVars.push_back(m_deltaP);
  infVarNames.push_back("m_deltaP");
  infVars.push_back(m_strouhal);
  infVarNames.push_back("m_strouhal");
  infVars.push_back(m_timeStep);
  infVarNames.push_back("m_timeStep");

  // TODO labels:FV,COMM add missing variables!

  const MInt noInfVars = infVars.size();
  std::vector<MFloat> recvInfVars(noInfVars);

  if(infVars.size() != infVarNames.size()) {
    mTerm(1, "number of infinity variables mismatch");
  }

  if(domainId() == 0) {
    std::copy(infVars.begin(), infVars.end(), recvInfVars.begin());
  } else {
    std::fill(recvInfVars.begin(), recvInfVars.end(), -1.0);
  }

  MPI_Bcast(&recvInfVars[0], noInfVars, maia::type_traits<MFloat>::mpiType(), 0, mpiComm(), AT_, "recvInfVars[0]");

  for(MInt i = 0; i < noInfVars; i++) {
    // Catch NaNs, might be used to invalidate some variables and prevent/detect their usage
    if(std::isnan(recvInfVars[i]) && std::isnan(infVars[i])) {
      const MString msg =
          "Infinity variable '" + infVarNames[i] + "' is NaN on multiple ranks, check if this is correct!";
      m_log << msg << std::endl;
      if(domainId() == 0) {
        std::cerr << msg << std::endl;
      }
      continue;
    }
    if(!approx(recvInfVars[i], infVars[i], MFloatEps)) {
      mTerm(1, "Infinity variable '" + infVarNames[i]
                   + "' is inconsistent among ranks, domainId=" + std::to_string(domainId())
                   + ", value=" + std::to_string(infVars[i]) + ", recvValue=" + std::to_string(recvInfVars[i]));
    }
  }
}


// -------------------------------------------

/// \fn void FvCartesianSolverXD::computeInitialPressureLossForChannelFlow()
/// \brief Computes pressure loss for the initial condition of channel flow
/// testcases as \f$ \Delta_p =
/// \frac{(\mathit{M} \mathit{Re}_{\tau} \sqrt{T_{\infty}})^{2}}{\mathit{Re}}
/// \frac{\rho_{\infty}}{ L_{\infty} } \f$. Requires property ReTau to be set
/// in the property file.
///
/// WARNING: m_deltaP is set only when m_restart == false!
/// (see initial conditions)
///
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeInitialPressureLossForChannelFlow() {
  TRACE();

  IF_CONSTEXPR(nDim == 2)
  mTerm(1, "Info: untested in 2D. By now only used in 3D."
           " To use in 2D delete this warning.");

  /// \page propertiesFV
  ///  \section ReTau
  ///  <code>MFloat ReTau </code>\n
  ///  default = <code>no default value</code>\n \n
  ///  ReTau \f$ \mathit{Re}_{\tau} \f$ is used to compute the pressure loss as
  ///  \f$ \Delta_p = \frac{( \mathit{M} \mathit{Re}_{\tau} \sqrt{T_{\infty}})^{2}}{\mathit{Re}}
  ///  \frac{\rho_{\infty}}{ L_{\infty} } \f$ Possible values are: <ul> <li>Non-negative floating
  ///  point values</li>
  ///  </ul>
  ///  Keywords: <i>FINITE_VOLUME, VARIABLES</i>
  MFloat ReTau = Context::getSolverProperty<MFloat>("ReTau", m_solverId, AT_) / m_referenceLength;

  /// \f$ \Delta_p =
  /// \frac{(\mathit{M} \mathit{Re}_{\tau} \sqrt{T_{\infty}})^{2}}{\mathit{Re}}
  /// \frac{\rho_{\infty}}{ L_{\infty} } \f$
  m_deltaP = POW2(m_Ma * ReTau * sqrt(m_TInfinity) / m_Re) * m_rhoInfinity / m_referenceLength;

  m_fvBndryCnd->m_deltaP = m_deltaP;
}

// -----------------------------------------------------------------
/** \brief jet volume forcing
 * jet volume forcing with vortex rings.
 * Velocity profile and forcing ref: "Effects of Inflow Conditions and Forcing on Subsonic Jet Flows
 * and Noise" Bogey and Bailly.
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::updateJet() {
  TRACE();

  if(m_jet && !m_levelSet) {
    switch(m_jetType) {
      //---Single Jet------
      //-------------------
      case 19516: {
        IF_CONSTEXPR(nDim == 2) mTerm(-1, "This case is designed for 3D!");

        const MInt noCells = a_noCells();
        MInt cellId; // nghbrId;
        // ------------------Single Jet Forcing-------------------------
        //--------------------------------------------------------------
        for(cellId = 0; cellId < noCells; cellId++) {
          MFloat jet, uy1 = 0, uy11 = 0, ur0 = 0, ur = 0, u = 0, w = 0, radius, angle, swtrad, swtxsgn, swtzsgn;
          MFloat dx, dy, dz, angle2;

          dx = a_coordinate(cellId, 0);
          dy = a_coordinate(cellId, 1);
          dz = a_coordinate(cellId, 2);
          radius = sqrt(POW2(dy) + POW2(dz));
          if(fabs(radius) > 1.5 * m_jetHeight) continue;

          swtrad = 0.5 * F1 * (radius - 0.01 + abs(radius - 0.01)) / (abs(radius - 0.01) + 1e-32);
          swtxsgn = 0.5 * F1 * (dy + abs(dy)) / (abs(dy) + 1e-32);
          swtzsgn = 0.5 * F1 * (dz + abs(dz)) / (abs(dz) + 1e-32);
          angle = abs(dy) / (radius + 1e-32) * swtrad;
          angle = acos(angle);
          angle = angle * swtxsgn * swtzsgn + (PI - angle) * (1 - swtxsgn) * swtzsgn
                  + (PI + angle) * (1 - swtxsgn) * (1 - swtzsgn) - angle * swtxsgn * (1 - swtzsgn);

          // Mean inflow velocity profile
          jet = m_Ma * F1B2
                * (1
                   - tanh(m_shearLayerThickness * (((dx) - (m_jetHeight)) / (m_jetHeight))
                          * (((dx) + (m_jetHeight)) / (m_jetHeight))))
                * swtrad;
          radius = radius + 0.0000000000000001;
          // Vortex ring velocities
          uy1 = 2 * 0.5 / radius * (radius - 0.5) / 0.01
                * exp(-log(2) * (POW2(dx - 0.49) + POW2(radius - 0.5)) / POW2(0.01)) * jet;
          ur0 = -2 * 0.5 / radius * (dx - 0.49) / 0.01
                * exp(-log(2) * (POW2(dx - 0.49) + POW2(radius - 0.5)) / POW2(0.01)) * jet;

          // Angle 2 and definition of modes
          angle2 = atan2(dz, dy);
          MFloat az = 0;
          // Choose noOfModes=16 for Bogey&Bailly reference.
          // Choose forceCoefficient 0.007 for Bogey&Bailly reference.

          for(MInt i = 0; i < m_modeNumbers; i++) {
            // a[i]= -1.0 + rand()/(RAND_MAX/(1.0- (-1.0)));
            // phi[i]= 2*PI*rand()/(RAND_MAX/(1.0- (-1.0)));
            // Fluctuated part of the vortex rind
            const MFloat a = -1.0 + (float)rand() / ((float)RAND_MAX / (1.0 - (-1.0)));
            const MFloat phi = 0.00 + (float)rand() / ((float)RAND_MAX / (2 * acos(-1) - 0.00));

            az += a * cos(phi + i * angle2);
          }
          uy11 = (m_forceCoefficient * az * uy1);
          ur = (m_forceCoefficient * az * ur0);
          u = ur * cos(angle2);
          w = ur * sin(angle2);
          a_rightHandSide(cellId, CV->RHO_U) += (a_cellVolume(cellId) * m_rhoInfinity * uy11);
          a_rightHandSide(cellId, CV->RHO_V) += (a_cellVolume(cellId) * m_rhoInfinity * u);
          a_rightHandSide(cellId, CV->RHO_W) += (a_cellVolume(cellId) * m_rhoInfinity * w);
          // cout<<angle<< endl;
        }
        break;
      }
      //---Single Jet (updated version; TODO labels:FV,toremove remove/replace 19516)------
      case 19517:
      case 19518: {
        if(!m_jetForcing) {
          break;
        }
        // ------------------Single Jet Forcing-------------------------
        // Bogey&Bailly reference:
        // noOfModes=16; forceCoefficient=0.007

        // Random number generation
        std::vector<MFloat> randAng{};
        randAng.resize(m_modeNumbers);
        std::vector<MFloat> randAmp{};
        randAmp.resize(m_modeNumbers);

        // Initial seed for deterministic same random number generation on all ranks
        const MInt seed = m_jetRandomSeed + globalTimeStep * m_noRKSteps + m_RKStep;
        if(Context::propertyExists("RNGSeed") || Context::propertyExists("seedRNGWithTime"))
          mTerm(1, "Properties RNGSeed or seedRNGWithTime not compatible with jetForcing");
        srand(seed); // use initial seed
        for(MInt i = 0; i < 10; i++) {
          srand(rand()); // re-seed with first random number of previous seed to obtain a seed for the random engine
                         // below which is not a linear function of the globalTimeStep anymore
        }
        const MInt randSeed = rand();
        // m_log << "DEBUG seed " << seed << " " << randSeed << std::endl;

        // Update random engine each timestep
        std::default_random_engine gen(randSeed);
        std::uniform_real_distribution<MFloat> ampDist(-1., 1.);
        std::uniform_real_distribution<MFloat> angDist(0., 2 * PI);

        // Accumulate random amplitudes and angles
        for(MInt i = 0; i < m_modeNumbers; i++) {
          randAmp[i] = ampDist(gen);
          randAng[i] = angDist(gen);
        }

        const MFloat r0 = m_jetHeight;
        const MFloat x0 = m_jetForcingPosition;
        const MFloat deltaY = c_cellLengthAtLevel(maxLevel());
        const MInt noCells = a_noCells();

        for(MInt cellId = 0; cellId < noCells; cellId++) {
          const MFloat dx = a_coordinate(cellId, 0);
          const MFloat dy = a_coordinate(cellId, 1);
          const MFloat dz = a_coordinate(cellId, 2);
          const MFloat radius = sqrt(POW2(dy) + POW2(dz));

          // Mean inflow velocity
          const MFloat u0 = m_UInfinity;

          // for tanh inflow profile velocity is basically zero out of this range
          if(fabs(radius) / r0 <= 1.5) {
            MFloat prefac = 2.0 * r0 / (radius * deltaY);
            prefac *= exp(-log(2.0) * (POW2(dx - x0) + POW2(radius - r0)) / POW2(deltaY)) * u0;
            const MFloat u_ring = prefac * (radius - r0);
            const MFloat v_ring = -1.0 * prefac * (dx - x0);
            const MFloat angle = atan2(dz, dy);

            MFloat randFluct = 0.0;
            for(MInt i = 0; i < m_modeNumbers; i++) {
              randFluct += randAmp[i] * cos(randAng[i] + i * angle);
            }
            const MFloat u_ax = (m_forceCoefficient * randFluct * u_ring);
            const MFloat u_rad = (m_forceCoefficient * randFluct * v_ring);
            const MFloat v = u_rad * cos(angle);
            const MFloat w = u_rad * sin(angle);

            if(m_jetType == 19517) {
              a_rightHandSide(cellId, CV->RHO_U) += (a_cellVolume(cellId) * m_rhoInfinity * u_ax);
              a_rightHandSide(cellId, CV->RHO_V) += (a_cellVolume(cellId) * m_rhoInfinity * v);
              a_rightHandSide(cellId, CV->RHO_W) += (a_cellVolume(cellId) * m_rhoInfinity * w);
            } else {
              const MFloat rho = a_variable(cellId, CV->RHO);
              // Apply perturbation directly to velocities (see Bogey); jet type 19517 is not useful if the correct
              // velocity profile from the paper is used; previously the jet profile was cut of a m_jetHeight which lead
              // to a steep velocity gradient in the shear layer in the simulations, thus the negligible influence of
              // the jet forcing was not relevant/detected
              a_variable(cellId, CV->RHO_U) += (rho * u_ax);
              a_variable(cellId, CV->RHO_V) += (rho * v);
              a_variable(cellId, CV->RHO_W) += (rho * w);
            }
          }
        }
        break;
      }
      case 1156: {
        //---Coaxial Jet------
        //-------------------
        IF_CONSTEXPR(nDim == 2) mTerm(-1, "This case is designed for 3D!");

        const MInt noCells = a_noCells();
        MInt cellId; // nghbrId;

        // ------------------Coaxial Jet Forcing-------------------------
        //--------------------------------------------------------------
        for(cellId = 0; cellId < noCells; cellId++) {
          MFloat jet, uy1 = 0, uy11 = 0, ur0 = 0, ur = 0, u = 0, w = 0, radius, radius2, angle, swtrad, swtxsgn,
                      swtzsgn;
          MFloat dx, dy, dz, angle2;

          dx = a_coordinate(cellId, 0);
          dy = a_coordinate(cellId, 1);
          dz = a_coordinate(cellId, 2);
          radius = sqrt(POW2(dy) + POW2(dz));
          swtrad = 0.5 * F1 * (radius - 0.01 + abs(radius - 0.01)) / (abs(radius - 0.01) + 1e-32);
          swtxsgn = 0.5 * F1 * (dy + abs(dy)) / (abs(dy) + 1e-32);
          swtzsgn = 0.5 * F1 * (dz + abs(dz)) / (abs(dz) + 1e-32);
          angle = abs(dy) / (radius + 1e-32) * swtrad;
          angle = acos(angle);
          angle = angle * swtxsgn * swtzsgn + (PI - angle) * (1 - swtxsgn) * swtzsgn
                  + (PI + angle) * (1 - swtxsgn) * (1 - swtzsgn) - angle * swtxsgn * (1 - swtzsgn);

          //-- Primary JET --
          if(radius <= m_primaryJetRadius) {
            jet = m_Ma * F1B2
                  * (1
                     - tanh(m_shearLayerThickness * (((dx) - (m_jetHeight)) / (m_jetHeight))
                            * (((dx) + (m_jetHeight)) / (m_jetHeight))))
                  * swtrad;
            radius = radius + 0.0000000000000001;
            // Vortex ring velocities
            uy1 = 2 * m_primaryJetRadius / radius * (radius - m_primaryJetRadius) / 0.01
                  * exp(-log(2) * (POW2(dx - 0.49) + POW2(radius - m_primaryJetRadius)) / POW2(0.01)) * jet;
            ur0 = -2 * m_primaryJetRadius / radius * (dx - 0.49) / 0.01
                  * exp(-log(2) * (POW2(dx - 0.49) + POW2(radius - m_primaryJetRadius)) / POW2(0.01)) * jet;

            // Angle 2 and definition of modes
            angle2 = atan2(dz, dy);
            MFloat az = 0;
            MFloat* a = new MFloat[m_modeNumbers];
            MFloat* phi = new MFloat[m_modeNumbers];
            for(MInt i = 0; i < m_modeNumbers; i++) {
              a[i] = -1.0 + (float)rand() / ((float)RAND_MAX / (1.0 - (-1.0)));
              phi[i] = 0.00 + (float)rand() / ((float)RAND_MAX / (2 * acos(-1) - 0.00));

              az += a[i] * cos(phi[i] + i * angle2);
            }
            uy11 = (m_forceCoefficient * az * uy1);
            ur = (m_forceCoefficient * az * ur0);
            u = ur * cos(angle2);
            w = ur * sin(angle2);
          }
          //-- Secondary JET --
          else if(radius <= m_secondaryJetRadius) {
            radius2 = radius - m_primaryJetRadius;
            jet = m_Ma * F1B2
                  * (1
                     - tanh(m_shearLayerThickness * (((dx) - (m_jetHeight)) / (m_jetHeight))
                            * (((dx) + (m_jetHeight)) / (m_jetHeight))))
                  * swtrad;
            radius2 = radius2 + 0.0000000000000001;

            uy1 = 2 * m_secondaryJetRadius / radius * (radius - m_secondaryJetRadius) / 0.01
                  * exp(-log(2) * (POW2(dx - 0.49) + POW2(radius - m_secondaryJetRadius)) / POW2(0.01)) * jet;
            ur0 = -2 * m_secondaryJetRadius / radius * (dx - 0.49) / 0.01
                  * exp(-log(2) * (POW2(dx - 0.49) + POW2(radius - m_secondaryJetRadius)) / POW2(0.01)) * jet;

            // Angle 2 and definition of modes
            angle2 = atan2(dz, dy);
            MFloat az = 0;
            MFloat a[16];
            MFloat phi[16];
            for(MInt i = 0; i < 16; i++) {
              a[i] = -1.0 + (float)rand() / ((float)RAND_MAX / (1.0 - (-1.0)));
              phi[i] = 0.00 + (float)rand() / ((float)RAND_MAX / (2 * acos(-1) - 0.00));
              // To get better acoustic results first 4 modes are ommited for the secondary jet!!
              a[0] = 0;
              a[1] = 0;
              a[2] = 0;
              a[3] = 0;
              phi[0] = 0;
              phi[1] = 0;
              phi[2] = 0;
              phi[3] = 0;
              az += a[i] * cos(phi[i] + (i)*angle2);
            }
            uy11 = (m_forceCoefficient * az * uy1);
            ur = (m_forceCoefficient * az * ur0);
            u = ur * cos(angle2);
            w = ur * sin(angle2);
          }
          a_rightHandSide(cellId, CV->RHO_U) += (a_cellVolume(cellId) * m_rhoInfinity * uy11);
          a_rightHandSide(cellId, CV->RHO_V) += (a_cellVolume(cellId) * m_rhoInfinity * u);
          a_rightHandSide(cellId, CV->RHO_W) += (a_cellVolume(cellId) * m_rhoInfinity * w);
        }
        break;
      }
      // Dummy jetType, s.th. jet-BC can be used also with inletTurbulence and without the updateJet()-forcing
      case -1:
        break;

      default: {
        stringstream errorMessage;
        errorMessage << "FvCartesianSolverXD::updateJet() switch variable 'm_jetType' with value " << m_jetType
                     << " not matching any case." << endl;
        mTerm(1, AT_, errorMessage.str());
      }
    }
  }
}


// -------------------------------------------------------------------------


/*
 * \brief Creates a surface
 *
 * @author Daniel Hartmann, January 12, 2006
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeSrfcs(MInt cellId, MInt nghbrId, MInt dirId, MInt srfcId) {
  // TRACE();

  /*! \page propertiesFV
    \section bndryRfnJump
    <code>void FvCartesianSolverXD::computeSrfcs</code>\n
    default = <code>0</code>\n \n
    This trigger enables a cut point correction for grid refinement jumps along boundaries.
    Split cells and multiple ghost cells are not supported.
    Possible values are:
    <ul>
    <li>0: deactivated</li>
    <li>1: activated</li>
    </ul>
    Keywords: <i>CUT_POINTS, BOUNDARY_REFINEMENT</i>
  */
  MBool bndryRfnJump = false;
  bndryRfnJump = Context::getSolverProperty<MBool>("bndryRfnJump", m_solverId, AT_, &bndryRfnJump);

  //---

  // store grid cell coordinates
  MFloat* coordinates = new MFloat[nDim];
  for(MInt dimId = 0; dimId < nDim; dimId++) {
    coordinates[dimId] = a_coordinate(cellId, dimId);
    if(a_bndryId(cellId) > -1) {
      MInt bndryId = a_bndryId(cellId);
      // correct coordinates of boundary cells
      coordinates[dimId] -= m_fvBndryCnd->m_bndryCells->a[bndryId].m_coordinates[dimId];
    }
  }
  // correct coordinates of internal cells which are masters of a small cell
  for(MInt smallId = 0; smallId < m_fvBndryCnd->m_smallBndryCells->size(); smallId++) {
    const MInt smallCell = m_fvBndryCnd->m_smallBndryCells->a[smallId];
    if(m_fvBndryCnd->m_bndryCells->a[smallCell].m_linkedCellId != -1) {
      if(a_bndryId(m_fvBndryCnd->m_bndryCells->a[smallCell].m_linkedCellId) == -1
         && m_fvBndryCnd->m_bndryCells->a[smallCell].m_linkedCellId == cellId) {
        for(MInt dimId = 0; dimId < nDim; dimId++) {
          coordinates[dimId] = m_fvBndryCnd->m_bndryCells->a[smallCell].m_masterCoordinates[dimId];
        }
        break;
      }
    }
  }

  // create the surface
  m_surfaces.append();

  const MInt spaceId = dirId / 2;
  const MInt sideId = dirId % 2;
  const MInt otherSideId = (sideId + 1) % 2;

  // store orientation
  a_surfaceOrientation(srfcId) = spaceId;

  a_surfaceNghbrCellId(srfcId, sideId) = nghbrId;
  a_surfaceNghbrCellId(srfcId, otherSideId) = cellId;

  // compute the surface coordinates and the surface area
  a_surfaceArea(srfcId) = F1;

  MFloat cellHalfLength[nDim];
  for(MInt dimId = 0; dimId < nDim; dimId++) {
    cellHalfLength[dimId] = c_cellLengthAtLevel(a_level(cellId) + 1);
  }

  a_surfaceCoordinate(srfcId, spaceId) = coordinates[spaceId] + F2 * ((MFloat)sideId - F1B2) * cellHalfLength[spaceId];

  for(MInt dimId = 0; dimId < nDim; dimId++) {
    if(dimId != spaceId) {
      // surface area
      a_surfaceArea(srfcId) *= F2 * cellHalfLength[dimId];
      // coordinates
      a_surfaceCoordinate(srfcId, dimId) = coordinates[dimId];
      // bndry refinement jump method (new name: wall mesh variation method. See Paper Schilden2020)
      if(bndryRfnJump) {
        if(m_bndryRfnJumpInformation_[cellId] != -1 && nghbrId == m_bndryRfnJumpInformation_[cellId]) {
          a_surfaceArea(srfcId) = F0;
        }
      }
    }
  }

  delete[] coordinates;
  coordinates = 0;
}


//-------------------------------------------------------------------------------------------------------


/** \brief Check all existing cells if surfaces have to be created
 * member function with the task to check all existing cells for
 * the creation of surfaces. If a surface has to be created, another
 * member function is called.
 *
 * corrected some inconsistencies which occur for complex geometries
 * could also be used with the original method without multiple ghost cells
 *
 * \author changed by Claudia Guenther, December 2009
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::checkForSrfcsMGC() {
  TRACE();

  const MInt noCells = a_noCells();
  const MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();
  MBoolScratchSpace surfaceDenied(noBndryCells, m_noDirs, AT_, "surfaceDenied");
  MBoolScratchSpace surfaceCreated(noBndryCells, m_noDirs, AT_, "surfaceCreated");
  for(MInt i = 0; i < noBndryCells; i++) {
    for(MInt j = 0; j < m_noDirs; j++) {
      surfaceDenied(i, j) = false;
      surfaceCreated(i, j) = false;
    }
  }

  MInt otherDir[2 * nDim];
  for(MInt dim = 0; dim < nDim; dim++) {
    otherDir[2 * dim] = 2 * dim + 1;
    otherDir[2 * dim + 1] = 2 * dim;
  }

  m_surfaces.size(m_bndryCellSurfacesOffset);

  // store the surfaces of all boundary cells
  // here equal level neighbors are assumed!!!
  MInt counter = 0;
  for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;

    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      continue;
    }
    for(MInt dirId = 0; dirId < m_noDirs; dirId++) {
      if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_externalFaces[dirId]) {
        surfaceDenied(bndryId, dirId) = true;
      }
      MInt nghbrId;
      if(m_identNghbrIds[cellId * m_noDirs + dirId] < m_identNghbrIds[cellId * m_noDirs + dirId + 1]) {
        nghbrId = m_storeNghbrIds[m_identNghbrIds[cellId * m_noDirs + dirId]];
        if(a_level(cellId) < a_level(nghbrId)) {
          continue;
        }
      } else {
        continue;
      }

      if(a_bndryId(nghbrId) < 0) {
        continue;
      }

      MBool createSrfc = true;

      MInt oldSrfcId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_associatedSrfc[dirId];
      if(oldSrfcId >= 0) {
        ASSERT(a_surfaceNghbrCellId(oldSrfcId, 0) > -1 && a_surfaceNghbrCellId(oldSrfcId, 1) > -1, "");
        // check conditions for surface generation
        // (1) no master-slave interface
        // (2) no slave-slave interface if both slave cells have the same master
        // (3) no periodic-periodic interface
        if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId > -1) {
          if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId == nghbrId
             || m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId
                    == m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId) {
            createSrfc = false;
            surfaceDenied(bndryId, dirId) = true;
          }
        }
        if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId > -1) {
          if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId == (MInt)cellId
             || m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId
                    == m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId) {
            createSrfc = false;
            surfaceDenied(bndryId, dirId) = true;
          }
        }
        if(a_isPeriodic(cellId) && a_isPeriodic(nghbrId)) {
          createSrfc = false;
          surfaceDenied(bndryId, dirId) = true;
        }

        // do not create a surface between two halo cells
        // create a surface if slave-neighbor are both halo cells but the master is not
        if(a_isHalo(cellId) && a_isHalo(nghbrId)) {
          if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId == -1
             && m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId == -1) {
            createSrfc = false;
            surfaceDenied(bndryId, dirId) = true;
          }
        }

        // this is valid for isotropical refinement only!!
        if(!createSrfc) {
          continue;
        }

        if((a_level(cellId) > a_level(nghbrId)) || ((a_level(cellId) == a_level(nghbrId)) && dirId % 2 == 0)) {
          surfaceCreated(bndryId, dirId) = true;

          if(oldSrfcId != counter) {
            m_surfaces.copy(oldSrfcId, counter);
            m_surfaces.erase(oldSrfcId);
            m_fvBndryCnd->m_bndryCells->a[bndryId].m_associatedSrfc[dirId] = counter;
            if(a_level(cellId) == a_level(nghbrId)) {
              m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_associatedSrfc[otherDir[dirId]] = counter;
            }
          }
          counter++;
        }
      }
    }
  }

  // delete all other surfaces created in createCutFace
  while(a_noSurfaces() > counter) {
    MInt size = a_noSurfaces();
    m_surfaces.erase(size - 1);
    m_surfaces.size(size - 1);
  }

  // set the offset of all boundary interfaces (important for mesh adaptation!)
  m_bndryCellSurfacesOffset = a_noSurfaces();

  // set srfcId
  MInt srfcId = a_noSurfaces();
  MLong sumSrfc = srfcId;
  MPI_Allreduce(MPI_IN_PLACE, &sumSrfc, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "sumSrfc");
  m_log << "DEBUG: " << sumSrfc << " number of surfaces after first loop" << endl;

  MLong nmbr1 = 0;
  MLong nmbr2 = 0;

  for(MInt cellId = 0; cellId < noCells; cellId++) {
    if(a_isBndryGhostCell(cellId)) {
      nmbr1++;
      continue;
    }
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      nmbr2++;
      continue;
    }

    for(MInt dirId = 0; dirId < m_noDirs; dirId++) {
      for(MInt nghbr = m_identNghbrIds[cellId * m_noDirs + dirId];
          nghbr < m_identNghbrIds[cellId * m_noDirs + dirId + 1];
          nghbr++) {
        MBool createSrfc = false;
        const MInt nghbrId = m_storeNghbrIds[nghbr];
        ASSERT(nghbrId > -1, "");
        if(a_bndryId(cellId) > -1 && a_bndryId(nghbrId) > -1) {
          if((surfaceDenied(a_bndryId(cellId), dirId) == false
              || surfaceDenied(a_bndryId(nghbrId), otherDir[dirId]) == false)
             && (surfaceCreated(a_bndryId(cellId), dirId) == false
                 && surfaceCreated(a_bndryId(nghbrId), otherDir[dirId]) == false)) {
            createSrfc = true;
          }
        }

        if(a_bndryId(cellId) == -1 || a_bndryId(nghbrId) == -1) {
          createSrfc = true;
        }

        if(createSrfc) {
          // create one surface if the desicive level of the current cell is
          // less than the one from its neighbor

          // do not create a surface between the master and the linked cell
          if(a_bndryId(cellId) > -1) {
            if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_linkedCellId == nghbrId) {
              createSrfc = false;
            }
          }

          if(a_bndryId(nghbrId) > -1) {
            if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId == cellId) {
              createSrfc = false;
            }
          }

          // do not create a surface between periodic cells
          if(a_isPeriodic(cellId) && a_isPeriodic(nghbrId)) {
            createSrfc = false;
          }

          // do not create a surface between two halo cells
          if(a_isHalo(cellId) && a_isHalo(nghbrId)) {
            createSrfc = false;
          }

          // this is valid for isotropical refinement only!!
          if(createSrfc) {
            if((a_level(cellId) > a_level(nghbrId)) || ((a_level(cellId) == a_level(nghbrId)) && dirId % 2 == 0)) {
              computeSrfcs(cellId, nghbrId, dirId, srfcId);
              srfcId++;
            }
          }
        }
      }
    }
  }

  for(MInt srfc = 0; srfc < a_noSurfaces(); srfc++) {
    MInt nghbr0 = a_surfaceNghbrCellId(srfc, 0);
    MInt nghbr1 = a_surfaceNghbrCellId(srfc, 1);
    MInt dir = a_surfaceOrientation(srfc);
    MInt dir0 = 2 * dir + 1;
    MInt dir1 = 2 * dir;
    if(a_bndryId(nghbr0) > -1) {
      m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbr0)].m_associatedSrfc[dir0] = srfc;
    }
    if(a_bndryId(nghbr1) > -1) {
      m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbr1)].m_associatedSrfc[dir1] = srfc;
    }
  }
  sumSrfc = a_noSurfaces();
  MPI_Allreduce(MPI_IN_PLACE, &sumSrfc, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "sumSrfc");
  MPI_Allreduce(MPI_IN_PLACE, &nmbr1, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "nmbr1");
  MPI_Allreduce(MPI_IN_PLACE, &nmbr2, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "nmbr2");
  m_log << "DEBUG: " << nmbr1 << " number of cells skipped: boundaryId ==-2" << endl;
  m_log << "DEBUG: " << nmbr2 << " number of cells skipped: IsOnCurrentMGLevel" << endl;
  m_log << "DEBUG: " << sumSrfc << " number of surfaces after second loop" << endl;
  return;
}


//-------------------------------------------------------------------------------------------------------

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::checkForSrfcsMGC_2() {
  IF_CONSTEXPR(nDim == 2) { mTerm(1, "Only available in 3D. MGC not yet implemented in 2D."); }
  else {
    checkForSrfcsMGC_2_();
  }
}

/** \brief Check all existing cells if surfaces have to be created
 * member function with the task to check all existing cells for
 * the creation of surfaces. If a surface has to be created, another
 * member function is called.
 *
 * corrected some inconsistencies which occur for complex geometries
 * could also be used with the original method without multiple ghost cells
 * adapted to split cells
 *
 * \author changed by Claudia Guenther, December 2009
 *
 * \todo labels:FV change allocation of memory for surfaceDenied and surfaceCreated (avoid new())
 */
template <MInt nDim_, class SysEqn>
inline void FvCartesianSolverXD<nDim_, SysEqn>::checkForSrfcsMGC_2_() {
  TRACE();
  MBool createSrfc = true;
  MInt cell, counter;
  MInt srfcId, bndryId2, cell2;
  MInt nghbrId = 0, oldSrfcId, size;
  MInt noCells = a_noCells();
  MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();
  MBool** surfaceDenied = new MBool*[noBndryCells];
  MBoolScratchSpace surfaceDenied_scratch(noBndryCells * m_noDirs, AT_, "surfaceDenied_scratch");
  for(MInt i = 0; i < noBndryCells; i++) {
    surfaceDenied[i] = &surfaceDenied_scratch.p[m_noDirs * i];
    for(MInt j = 0; j < m_noDirs; j++) {
      surfaceDenied[i][j] = false;
    }
  }
  MBool** surfaceCreated = new MBool*[noBndryCells];
  MBoolScratchSpace surfaceCreated_scratch(noBndryCells * m_noDirs, AT_, "surfaceCreated_scratch");
  for(MInt i = 0; i < noBndryCells; i++) {
    surfaceCreated[i] = &surfaceCreated_scratch.p[m_noDirs * i];
    for(MInt j = 0; j < m_noDirs; j++) {
      surfaceCreated[i][j] = false;
    }
  }
  constexpr MInt otherDir[] = {1, 0, 3, 2, 5, 4};
  MInt nghbr0, nghbr1;
  //---

  m_surfaces.size(m_bndryCellSurfacesOffset);

  // store the surfaces of all boundary cells
  // here equal level neighbors are assumed!!!
  counter = 0;
  for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
    cell = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;

    if(m_fvBndryCnd->m_splitParents[bndryId] >= 0) {
      continue;
    }
    if(!a_hasProperty(cell, SolverCell::IsInvalid)) {
      if(a_hasProperty(cell, SolverCell::IsOnCurrentMGLevel)) {
        for(MInt dirId = 0; dirId < m_noDirs; dirId++) {
          if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_externalFaces[dirId]) {
            surfaceDenied[bndryId][dirId] = true;
          }
          if(m_identNghbrIds[cell * m_noDirs + dirId] < m_identNghbrIds[cell * m_noDirs + dirId + 1]) {
            nghbrId = m_storeNghbrIds[m_identNghbrIds[cell * m_noDirs + dirId]];
            if(a_level(cell) < a_level(nghbrId)) {
              continue;
            }
          } else {
            continue;
          }

          if(a_bndryId(nghbrId) < 0) {
            continue;
          }

          if(a_hasProperty(nghbrId, SolverCell::IsInvalid)) {
            continue;
          }
          createSrfc = true;

          // check if surface is a split surface - if yes, take care of the other neighbor, too;
          oldSrfcId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_associatedSrfc[dirId];
          if(oldSrfcId >= 0) {
            // check conditions for surface generation
            // (1) no master-slave interface
            // (2) no slave-slave interface if both slave cells have the same master
            // (3) no periodic-periodic interface
            if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId > -1) {
              if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId == nghbrId
                 || m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId
                        == m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId) {
                createSrfc = false;
                surfaceDenied[bndryId][dirId] = true;
              }
            }
            if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId > -1) {
              if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId == (MInt)cell
                 || m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId
                        == m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId) {
                createSrfc = false;
                surfaceDenied[bndryId][dirId] = true;
              }
            }
            if(a_isPeriodic(cell) && a_isPeriodic(nghbrId)) {
              createSrfc = false;
              surfaceDenied[bndryId][dirId] = true;
            }

            // do not create a surface between two halo cells
            // create a surface if slave-neighbor are both halo cells but the master is not
            if(a_isHalo(cell) && a_isHalo(nghbrId)) {
              if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId == -1
                 && m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId == -1) {
                createSrfc = false;
                surfaceDenied[bndryId][dirId] = true;
              }
            }

            // this is valid for isotropical refinement only!!
            if(!createSrfc) {
              continue;
            }

            oldSrfcId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_associatedSrfc[dirId];

            if((a_level(cell) > a_level(nghbrId)) || ((a_level(cell) == a_level(nghbrId)) && dirId % 2 == 0)) {
              surfaceCreated[bndryId][dirId] = true;

              if(oldSrfcId != counter) {
                m_surfaces.copy(oldSrfcId, counter);
                m_surfaces.erase(oldSrfcId);
                m_fvBndryCnd->m_bndryCells->a[bndryId].m_associatedSrfc[dirId] = counter;
                if(a_level(cell) == a_level(nghbrId)) {
                  m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_associatedSrfc[otherDir[dirId]] = counter;
                }
              }
              counter++;
            }
          } else if(oldSrfcId < -1) { // split surface, check both neighbors

            // first surface:
            srfcId = m_fvBndryCnd->m_splitSurfaces[-oldSrfcId * 6];
            nghbr0 = a_surfaceNghbrCellId(srfcId, 0);
            nghbr1 = a_surfaceNghbrCellId(srfcId, 1);
            if(nghbr0 == cell) {
              nghbrId = nghbr1;
            } else {
              nghbrId = nghbr0;
            }

            // check conditions for surface generation
            // (1) no master-slave interface
            // (2) no slave-slave interface if both slave cells have the same master
            // (3) no periodic-periodic interface
            if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId > -1) {
              if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId == nghbrId
                 || m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId
                        == m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId) {
                createSrfc = false;
                surfaceDenied[bndryId][dirId] = true;
              }
            }
            if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId > -1) {
              if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId == (MInt)cell
                 || m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId
                        == m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId) {
                createSrfc = false;
                surfaceDenied[bndryId][dirId] = true;
              }
            }
            if(a_isPeriodic(cell) && a_isPeriodic(nghbrId)) {
              createSrfc = false;
              surfaceDenied[bndryId][dirId] = true;
            }

            // do not create a surface between two halo cells
            // create a surface if slave-neighbor are both halo cells but the master is not
            if(a_isHalo(cell) && a_isHalo(nghbrId)) {
              if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId == -1
                 && m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId == -1) {
                createSrfc = false;
                surfaceDenied[bndryId][dirId] = true;
              }
            }

            // this is valid for isotropical refinement only!!
            if(!createSrfc) {
              continue;
            }

            // check validity of first surface:
            if((a_level(cell) > a_level(nghbrId)) || ((a_level(cell) == a_level(nghbrId)) && dirId % 2 == 0)) {
              surfaceCreated[bndryId][dirId] = true;

              if(srfcId != counter) {
                m_surfaces.copy(srfcId, counter);
                m_surfaces.erase(srfcId);
                m_fvBndryCnd->m_splitSurfaces[-oldSrfcId * 6] = counter;
              }
              counter++;
            }

            // second surface:
            srfcId = m_fvBndryCnd->m_splitSurfaces[-oldSrfcId * 6 + 3];
            nghbr0 = a_surfaceNghbrCellId(srfcId, 0);
            nghbr1 = a_surfaceNghbrCellId(srfcId, 1);
            if(nghbr0 == cell) {
              nghbrId = nghbr1;
            } else {
              nghbrId = nghbr0;
            }

            // check conditions for surface generation
            // (1) no master-slave interface
            // (2) no slave-slave interface if both slave cells have the same master
            // (3) no periodic-periodic interface
            if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId > -1) {
              if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId == nghbrId
                 || m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId
                        == m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId) {
                createSrfc = false;
                surfaceDenied[bndryId][dirId] = true;
              }
            }
            if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId > -1) {
              if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId == (MInt)cell
                 || m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId
                        == m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId) {
                createSrfc = false;
                surfaceDenied[bndryId][dirId] = true;
              }
            }
            if(a_isPeriodic(cell) && a_isPeriodic(nghbrId)) {
              createSrfc = false;
              surfaceDenied[bndryId][dirId] = true;
            }

            // do not create a surface between two halo cells
            // create a surface if slave-neighbor are both halo cells but the master is not
            if(a_isHalo(cell) && a_isHalo(nghbrId)) {
              if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId == -1
                 && m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId == -1) {
                createSrfc = false;
                surfaceDenied[bndryId][dirId] = true;
              }
            }

            // this is valid for isotropical refinement only!!
            if(!createSrfc) {
              continue;
            }

            // check validity of second surface:
            if((a_level(cell) > a_level(nghbrId)) || ((a_level(cell) == a_level(nghbrId)) && dirId % 2 == 0)) {
              surfaceCreated[bndryId][dirId] = true;

              if(srfcId != counter) {
                m_surfaces.copy(srfcId, counter);
                m_surfaces.erase(srfcId);
                m_fvBndryCnd->m_splitSurfaces[-oldSrfcId * 6 + 3] = counter;
              }
              counter++;
            }
          }
        }
      }
    }
    for(MInt child = 0; child < 3; child++) {
      bndryId2 = m_fvBndryCnd->m_splitChildren[bndryId * 3 + child];
      if(bndryId2 == -1) {
        break;
      }
      cell2 = m_fvBndryCnd->m_bndryCells->a[bndryId2].m_cellId;
      if(!a_hasProperty(cell2, SolverCell::IsInvalid)) {
        for(MInt dirId = 0; dirId < m_noDirs; dirId++) {
          if(m_fvBndryCnd->m_bndryCells->a[bndryId2].m_externalFaces[dirId]) {
            surfaceDenied[bndryId2][dirId] = true;
          }
          if(m_identNghbrIds[cell2 * m_noDirs + dirId] < m_identNghbrIds[cell2 * m_noDirs + dirId + 1]) {
            nghbrId = m_storeNghbrIds[m_identNghbrIds[cell2 * m_noDirs + dirId]];
            if(a_level(cell2) < a_level(nghbrId)) {
              continue;
            }
          } else {
            continue;
          }

          if(a_bndryId(nghbrId) < 0) {
            continue;
          }
          createSrfc = true;

          // check conditions for surface generation
          // (1) no master-slave interface
          // (2) no slave-slave interface if both slave cells have the same master
          // (3) no periodic-periodic interface
          if(m_fvBndryCnd->m_bndryCells->a[bndryId2].m_linkedCellId > -1) {
            if(m_fvBndryCnd->m_bndryCells->a[bndryId2].m_linkedCellId == nghbrId
               || m_fvBndryCnd->m_bndryCells->a[bndryId2].m_linkedCellId
                      == m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId) {
              createSrfc = false;
              surfaceDenied[bndryId2][dirId] = true;
            }
          }
          if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId > -1) {
            if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId == (MInt)cell2
               || m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId
                      == m_fvBndryCnd->m_bndryCells->a[bndryId2].m_linkedCellId) {
              createSrfc = false;
              surfaceDenied[bndryId2][dirId] = true;
            }
          }
          if(a_isPeriodic(cell2) && a_isPeriodic(nghbrId)) {
            createSrfc = false;
            surfaceDenied[bndryId2][dirId] = true;
          }

          // do not create a surface between two halo cells
          // create a surface if slave-neighbor are both halo cells but the master is not
          if(a_isHalo(cell2) && a_isHalo(nghbrId)) {
            if(m_fvBndryCnd->m_bndryCells->a[bndryId2].m_linkedCellId == -1
               && m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId == -1) {
              createSrfc = false;
              surfaceDenied[bndryId2][dirId] = true;
            }
          }

          // this is valid for isotropical refinement only!!
          if(!createSrfc) {
            continue;
          }


          oldSrfcId = m_fvBndryCnd->m_bndryCells->a[bndryId2].m_associatedSrfc[dirId];

          if(oldSrfcId == -1) {
            continue;
          }

          if(oldSrfcId >= 0) {
            // create surface if its is no split surface:

            if((a_level(cell2) > a_level(nghbrId)) || ((a_level(cell2) == a_level(nghbrId)) && dirId % 2 == 0)) {
              surfaceCreated[bndryId2][dirId] = true;

              if(oldSrfcId != counter) {
                m_surfaces.copy(oldSrfcId, counter);
                m_surfaces.erase(oldSrfcId);
                m_fvBndryCnd->m_bndryCells->a[bndryId2].m_associatedSrfc[dirId] = counter;
                if(a_level(cell2) == a_level(nghbrId)) {
                  m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_associatedSrfc[otherDir[dirId]] = counter;
                }
              }
              counter++;
            }
          }
        }
      }
    }
  }

  createSrfc = false;

  // delete all other surfaces created in createCutFace
  while(a_noSurfaces() > counter) {
    size = a_noSurfaces();
    m_surfaces.erase(size - 1);
    m_surfaces.size(size - 1);
  }

  // set the offset of all boundary interfaces (important for mesh adaptation!)
  m_bndryCellSurfacesOffset = a_noSurfaces();

  // set srfcId
  srfcId = a_noSurfaces();

  for(MInt cellId = 0; cellId < noCells; cellId++) {
    if(a_isBndryGhostCell(cellId)) {
      continue;
    }
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      continue;
    }

    for(MInt dirId = 0; dirId < m_noDirs; dirId++) {
      for(MInt nghbr = m_identNghbrIds[cellId * m_noDirs + dirId];
          nghbr < m_identNghbrIds[cellId * m_noDirs + dirId + 1];
          nghbr++) {
        createSrfc = false;
        nghbrId = m_storeNghbrIds[nghbr];

        if(a_bndryId(cellId) > -1 && a_bndryId(nghbrId) > -1) {
          if((surfaceDenied[a_bndryId(cellId)][dirId] == false
              || surfaceDenied[a_bndryId(nghbrId)][otherDir[dirId]] == false)
             && (surfaceCreated[a_bndryId(cellId)][dirId] == false
                 && surfaceCreated[a_bndryId(nghbrId)][otherDir[dirId]] == false)) {
            createSrfc = true;
          }
        }

        if(a_bndryId(cellId) == -1 || a_bndryId(nghbrId) == -1) {
          createSrfc = true;
        }

        if(createSrfc) {
          // create one surface if the desicive level of the current cell is
          // less than the one from its neighbor

          // do not create a surface between the master and the linked cell
          if(a_bndryId(cellId) > -1) {
            if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_linkedCellId == nghbrId) {
              createSrfc = false;
            }
          }

          if(a_bndryId(nghbrId) > -1) {
            if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId == cellId) {
              createSrfc = false;
            }
          }

          // do not create a surface between periodic cells
          if(a_isPeriodic(cellId) && a_isPeriodic(nghbrId)) {
            createSrfc = false;
          }

          // do not create a surface between two halo cells
          if(a_isHalo(cellId) && a_isHalo(nghbrId)) {
            createSrfc = false;
          }

          // this is valid for isotropical refinement only!!
          if(createSrfc) {
            if((a_level(cellId) > a_level(nghbrId)) || ((a_level(cellId) == a_level(nghbrId)) && dirId % 2 == 0)) {
              computeSrfcs(cellId, nghbrId, dirId, srfcId);

              srfcId++;
            }
          }
        }
      }
    }
  }
  delete[] surfaceDenied;
  surfaceDenied = 0;
  delete[] surfaceCreated;
  surfaceCreated = 0;

  for(MInt srfc = 0; srfc < a_noSurfaces(); srfc++) {
    nghbr0 = a_surfaceNghbrCellId(srfc, 0);
    nghbr1 = a_surfaceNghbrCellId(srfc, 1);
    MInt dir = a_surfaceOrientation(srfc);
    MInt dir0 = 2 * dir + 1;
    MInt dir1 = 2 * dir;
    if(a_bndryId(nghbr0) > -1) {
      m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbr0)].m_associatedSrfc[dir0] = srfc;
    }
    if(a_bndryId(nghbr1) > -1) {
      m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbr1)].m_associatedSrfc[dir1] = srfc;
    }
  }
  return;
}

//-----------------------------------------------------------------------------

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::correctBoundarySurfaces() {
  IF_CONSTEXPR(nDim == 2) { mTerm(1, "Only meaningful in 3D."); }
  else {
    correctBoundarySurfaces_();
  }
}

template <MInt nDim_, class SysEqn>
inline void FvCartesianSolverXD<nDim_, SysEqn>::correctBoundarySurfaces_() {
  TRACE();

  const MInt noCells = a_noCells();
  const MInt noBCCells = m_fvBndryCnd->m_bndryCells->size();
  const MInt noSurfaces = a_noSurfaces();
  const MFloat eps = c_cellLengthAtLevel(maxRefinementLevel()) * 0.00001;
  ScratchSpace<MFloat> area(3 * maxNoGridCells(), AT_, "area");
  //---

  m_surfaces.size(m_bndrySurfacesOffset);

  for(MInt bc = 0; bc < noBCCells; bc++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bc].m_cellId;
    for(MInt d = 0; d < nDim; d++) {
      area[d * noCells + cellId] = F0;
    }
  }

  for(MInt s = 0; s < noSurfaces; s++) {
    MInt i = a_surfaceOrientation(s);
    area[i * noCells + a_surfaceNghbrCellId(s, 0)] -= a_surfaceArea(s);
    area[i * noCells + a_surfaceNghbrCellId(s, 1)] += a_surfaceArea(s);
  }

  for(MInt bc = 0; bc < noBCCells; bc++) {
    if(m_fvBndryCnd->m_bndryCells->a[bc].m_linkedCellId == -1) {
      const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bc].m_cellId;

      if(a_isHalo(cellId)) continue;

      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;

      if(c_noChildren(cellId) > 0) continue;

      // check whether a refined cell is present
      MBool check = false;
      for(MInt d = 0; d < m_noDirs; d++) {
        if(a_hasNeighbor(cellId, d) > 0) {
          if(c_noChildren(c_neighborId(cellId, d)) > 0) {
            check = true;
          }
        }
      }
      if(check) {
        for(MInt d = 0; d < nDim; d++) {
          if(ABS(area[d * noCells + cellId]) > eps) {
            // correct
            MFloat totalArea = F0;
            for(MInt dd = 0; dd < nDim; dd++) {
              if(m_fvBndryCnd->m_bndryCells->a[bc].m_srfcs[0]->m_normalVector[dd] > F0) {
                totalArea += POW2(ABS(m_fvBndryCnd->m_bndryCells->a[bc].m_srfcs[0]->m_normalVector[dd])
                                      * m_fvBndryCnd->m_bndryCells->a[bc].m_srfcs[0]->m_area
                                  + area[dd * noCells + cellId]);
                area[dd * noCells + cellId] = ABS(m_fvBndryCnd->m_bndryCells->a[bc].m_srfcs[0]->m_normalVector[dd])
                                                  * m_fvBndryCnd->m_bndryCells->a[bc].m_srfcs[0]->m_area
                                              + area[dd * noCells + cellId];
              } else {
                totalArea += POW2(ABS(m_fvBndryCnd->m_bndryCells->a[bc].m_srfcs[0]->m_normalVector[dd])
                                      * m_fvBndryCnd->m_bndryCells->a[bc].m_srfcs[0]->m_area
                                  - area[dd * noCells + cellId]);
                area[dd * noCells + cellId] = -ABS(m_fvBndryCnd->m_bndryCells->a[bc].m_srfcs[0]->m_normalVector[dd])
                                                  * m_fvBndryCnd->m_bndryCells->a[bc].m_srfcs[0]->m_area
                                              - area[dd * noCells + cellId];
              }
            }
            // update the surface area and the normal vector
            m_fvBndryCnd->m_bndryCells->a[bc].m_srfcs[0]->m_area = sqrt(totalArea);
            for(MInt dd = 0; dd < nDim; dd++) {
              m_fvBndryCnd->m_bndryCells->a[bc].m_srfcs[0]->m_normalVector[dd] =
                  area[dd * noCells + cellId] / sqrt(totalArea);
            }
            break;
          }
        }
      }
    }
  }
}


// === Azimuthal periodic concept (3D stuff) ==================================

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeRecConstPeriodic() {
  IF_CONSTEXPR(nDim == 2) { mTerm(1, "Azimuthal periodicity concept meaningful only in 3D."); }
  else {
    computeRecConstPeriodic_();
  }
}

/**
 * \computes reconstruction constants for LS recinstruction (azimuthal periodicity concept)
 * \author Alexej Pogorelov
 */
template <MInt nDim_, class SysEqn>
inline void FvCartesianSolverXD<nDim_, SysEqn>::computeRecConstPeriodic_() {
  TRACE();


  MBool nonlinear = true; // false;
  MInt maxNoNghbrs = 200;
  MInt matrix_dim = nDim + 1;
  if(nonlinear) {
    matrix_dim = 3 * nDim + 1;
  }

  MFloatScratchSpace mat(maxNoNghbrs, matrix_dim, AT_, "mat");
  MFloatScratchSpace matInv(matrix_dim, maxNoNghbrs, AT_, "matInv");
  MFloatScratchSpace weights(maxNoNghbrs, AT_, "weights");
  MIntScratchSpace nghbrList_(maxNoNghbrs, AT_, "nghbrList");
  MIntScratchSpace layerId_(maxNoNghbrs, AT_, "layerList");


  mat.fill(F0);
  weights.fill(F0);

  // rec const for non bndry cells
  MInt n_Id = -1;
  MInt cell_Id = -1;
  MInt sortedId = -1;
  MInt k_ = 0;
  MInt offset_cell = 0;
  MInt off_ = 0;
  MInt noSendingCells = 0;
  MInt counter_ = 0;

  for(MInt d = 0; d < noDomains(); d++) {
    noSendingCells += m_noPerCellsToSend[d];
  }


  mAlloc(m_reconstructionDataPeriodic, noSendingCells + 1, "m_reconstructionDataPeriodic", -1, AT_);
  mAlloc(m_reconstructionConstantsPeriodic, (noSendingCells * maxNoNghbrs * 2), "m_reconstructionConstantsPeriodic", F0,
         AT_);

  m_reconstructionDataPeriodic[0] = 0;

  for(MInt d = 0; d < noDomains(); d++) {
    for(MInt c = 0; c < m_noPerCellsToSend[d]; c++) {
      cell_Id = static_cast<MInt>(m_periodicDataToSend[d][6 + c * m_noPeriodicData]);
      sortedId = static_cast<MInt>(m_periodicDataToSend[d][5 + c * m_noPeriodicData]);


      MFloat normalizationFactor = FPOW2(a_level(cell_Id)) / c_cellLengthAtLevel(0);

      counter_ = 0;

      counter_ = getAdjacentLeafCells<2, true>(cell_Id, 2, nghbrList_, layerId_);
      k_ = 0;

      if(counter_ > maxNoNghbrs) {
        mTerm(1, AT_, "raise noMaxNghbrs");
      }

      /*	   MBool correct = false;
      if(a_bndryId(cell_Id)>-1 && correct)
        {
            MInt srfc=0;
        MFloat dn=0.0;//c_cellLengthAtCell(cell_Id)/100.0;//0.0;
        MInt bndryId=a_bndryId(cell_Id);

        for( MInt i=0; i<nDim; i++ ) { dn += m_bndryCells->a[ bndryId
      ].m_srfcs[srfc]->m_normalVector[ i ] * ( m_periodicCellDataDom[d][i+sortedId*5] -
      m_bndryCells->a[ bndryId ].m_srfcs[srfc]->m_coordinates[ i ] );
        }



        if(dn<0.0){
          cerr << "rotated point is outside / will be corrected" <<
      m_periodicCellDataDom[d][0+sortedId*5]  << " " << m_periodicCellDataDom[d][1+sortedId*5] << "
      " << m_periodicCellDataDom[d][2+sortedId*5]<< " dn " << dn <<endl;

         dn=fabs(dn);
       for ( MInt i = 0; i < nDim; i++ ) {
         m_periodicCellDataDom[d][i+sortedId*5] = m_periodicCellDataDom[d][i+sortedId*5]
      + 2.0*dn*m_bndryCells->a[ bndryId ].m_srfcs[srfc]->m_normalVector[ i ];
       }


        dn=0.0;



         for( MInt i=0; i<nDim; i++ ) { dn += m_bndryCells->a[ bndryId
      ].m_srfcs[srfc]->m_normalVector[ i ] * ( m_periodicCellDataDom[d][i+sortedId*5] -
      m_bndryCells->a[ bndryId ].m_srfcs[srfc]->m_coordinates[ i ] );
         }

         if(dn<0.0){

         cerr << "rotated point is still outside " <<  m_periodicCellDataDom[d][0+sortedId*5]  << "
      " << m_periodicCellDataDom[d][1+sortedId*5] << " " << m_periodicCellDataDom[d][2+sortedId*5]<<
      " dn " << dn<<endl; mTerm(1,AT_, "point still outside domain");
       }
        }

        }


*/

      for(MInt n = 0; n < counter_; n++) {
        n_Id = nghbrList_[n];
        if(n_Id < 0) {
          continue;
        }
        if(a_hasProperty(n_Id, SolverCell::IsPeriodicWithRot)) {
          continue;
        }
        if(!a_hasProperty(n_Id, SolverCell::IsOnCurrentMGLevel)) {
          continue;
        }
        if(c_noChildren(n_Id) > 0) {
          continue;
        }
        if(n_Id == cell_Id) {
          continue;
        }

        m_reconstructionConstantsPeriodic[offset_cell + k_] = nghbrList_[n];

        MInt cnt = 0;

        mat(k_, cnt) = F1;
        cnt++;

        MFloat dx = F0;
        for(MInt i = 0; i < nDim; i++) {
          mat(k_, cnt) = (a_coordinate(n_Id, i) - m_periodicCellDataDom[d][i + sortedId * m_noPeriodicCellData])
                         * normalizationFactor;
          dx += POW2(a_coordinate(n_Id, i) - m_periodicCellDataDom[d][i + sortedId * m_noPeriodicCellData]);
          cnt++;
        }

        weights(k_) = maia::math::RBF(dx, POW2(c_cellLengthAtCell(cell_Id)));


        if(nonlinear) {
          for(MInt i = 0; i < nDim; i++) {
            mat(k_, cnt) =
                0.5
                * POW2((a_coordinate(n_Id, i) - m_periodicCellDataDom[d][i + sortedId * m_noPeriodicCellData])
                       * normalizationFactor);
            cnt++;
          }

          for(MInt i = 0; i < nDim; i++) {
            for(MInt j = i + 1; j < nDim; j++) {
              mat(k_, cnt) = (a_coordinate(n_Id, j) - m_periodicCellDataDom[d][j + sortedId * m_noPeriodicCellData])
                             * (a_coordinate(n_Id, i) - m_periodicCellDataDom[d][i + sortedId * m_noPeriodicCellData])
                             * POW2(normalizationFactor);
              cnt++;
            }
          }
        }
        k_++;
      }


      if(!a_hasProperty(cell_Id, SolverCell::IsPeriodicWithRot)) // add cell for rec
      {
        m_reconstructionConstantsPeriodic[offset_cell + k_] = cell_Id;
        MInt cnt = 0;

        mat(k_, cnt) = F1;
        cnt++;

        MFloat dx = F0;
        for(MInt i = 0; i < nDim; i++) {
          mat(k_, cnt) = (a_coordinate(cell_Id, i) - m_periodicCellDataDom[d][i + sortedId * m_noPeriodicCellData])
                         * normalizationFactor;
          dx += POW2(a_coordinate(cell_Id, i) - m_periodicCellDataDom[d][i + sortedId * m_noPeriodicCellData]);
          cnt++;
        }

        weights(k_) = maia::math::RBF(dx, POW2(c_cellLengthAtCell(cell_Id)));


        if(nonlinear) {
          for(MInt i = 0; i < nDim; i++) {
            mat(k_, cnt) =
                0.5
                * POW2((a_coordinate(cell_Id, i) - m_periodicCellDataDom[d][i + sortedId * m_noPeriodicCellData])
                       * normalizationFactor);
            cnt++;
          }


          for(MInt i = 0; i < nDim; i++) {
            for(MInt j = i + 1; j < nDim; j++) {
              mat(k_, cnt) =
                  (a_coordinate(cell_Id, j) - m_periodicCellDataDom[d][j + sortedId * m_noPeriodicCellData])
                  * (a_coordinate(cell_Id, i) - m_periodicCellDataDom[d][i + sortedId * m_noPeriodicCellData])
                  * POW2(normalizationFactor);
              cnt++;
            }
          }
        }

        k_++;
      }


      maia::math::invert(mat, weights, matInv, k_, matrix_dim);


      for(MInt l = 0; l < k_; l++) {
        for(MInt i = 0; i < matrix_dim - 1; i++) {
          matInv(1 + i, l) *= normalizationFactor;
        }
      }


      for(MInt l = 0; l < k_; l++) {
        m_reconstructionConstantsPeriodic[offset_cell + k_ + l] = matInv(0, l);
        if((offset_cell + k_ + l) > (noSendingCells * maxNoNghbrs * 2)) {
          mTerm(1, AT_, "raise noSendingCells");
        }
      }


      offset_cell += 2 * k_;

      m_reconstructionDataPeriodic[off_ + c + 1] = offset_cell;
    }

    off_ += m_noPerCellsToSend[d];
  }
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::identPeriodicCells() {
  IF_CONSTEXPR(nDim == 2) { mTerm(1, "Azimuthal periodicity concept meaningful only in 3D."); }
  else {
    identPeriodicCells_();
  }
}

/**
 * \identifies periodic cells to copy PV from (azimuthal periodicity concept)
 * \author Alexej Pogorelov
 */
template <MInt nDim_, class SysEqn>
inline void FvCartesianSolverXD<nDim_, SysEqn>::identPeriodicCells_() {
  TRACE();

  m_noPeriodicCellData = PV->noVariables;
  m_noPeriodicData = m_noPeriodicCellData + 2;

  MFloat periodic_coord[2];
  periodic_coord[0] = 0.0;
  periodic_coord[1] = 0.0;
  if(m_periodicCells == 2 || m_periodicCells == 3) {
    for(MInt i = 0; i < 2; i++) {
      periodic_coord[i] = Context::getSolverProperty<MFloat>("periodic_coord", m_solverId, AT_, i);
    }
  }
  // init
  MInt m_maxNoPeriodicCells = 0;
  m_maxNoPeriodicCells = Context::getSolverProperty<MInt>("maxNoPeriodicCells", m_solverId, AT_, &m_maxNoPeriodicCells);

  m_sortedPeriodicCells->setSize(0);

  MFloat z_min_1, z_min_2, z_min_11, z_min_12;
  MFloat halfLength_1, halfLength_2;

  MFloat xmax = -900.0;
  MFloat ymax = -900.0;
  MFloat zmax = -900.0;

  MFloat xmin = 900.0;
  MFloat ymin = 900.0;
  MFloat zmin = 900.0;


  // domain boundaries
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    xmax = mMax(xmax, a_coordinate(cellId, 0));
    ymax = mMax(ymax, a_coordinate(cellId, 1));
    zmax = mMax(zmax, a_coordinate(cellId, 2));
    xmin = mMin(xmin, a_coordinate(cellId, 0));
    ymin = mMin(ymin, a_coordinate(cellId, 1));
    zmin = mMin(zmin, a_coordinate(cellId, 2));
  }

  // m_fvBndryCnd->recorrectCellCoordinates();

  // search cells in overlapping region and add them to m_sortedPeriodicCells (skip ghost cells)
  // m_periodicCells=1 --> azimuthal periodicity (with LS interpolation)
  // m_periodicCells=2 --> periodicity in x-direction (without LS interpolation)
  // m_periodicCells=3 --> periodicity in x-direction (without LS interpolation + volume forcing)
  if(m_periodicCells == 1) {
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      a_hasProperty(cellId, SolverCell::IsPeriodicWithRot) = false;

      if(a_isBndryGhostCell(cellId) || c_noChildren(cellId) != 0
         || !a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        continue;
      }


      halfLength_1 = c_cellLengthAtLevel(a_level(cellId) + 1);
      halfLength_2 = c_cellLengthAtLevel(maxLevel() + 1);

      z_min_1 = -6.3137515147 * a_coordinate(cellId, 1) + 1462.750302935;
      z_min_2 = -0.1583844403 * a_coordinate(cellId, 1) + 231.6768880649;
      z_min_11 = -6.3137515147 * (a_coordinate(cellId, 1) - halfLength_1) + 1462.750302935;
      z_min_12 = -0.1583844403 * (a_coordinate(cellId, 1) + halfLength_1) + 231.6768880649;


      if(( // Cells between periodic Bndry
             a_coordinate(cellId, 1) < m_rotAxisCoord[0] && a_coordinate(cellId, 2) <= z_min_1
             && a_coordinate(cellId, 2) >= z_min_2)
         || ( // intersection Cells on left periodic Bndry
             a_coordinate(cellId, 1) < m_rotAxisCoord[0] && a_coordinate(cellId, 2) > z_min_1
             && (a_coordinate(cellId, 2) - halfLength_1) < z_min_11 //&&a_bndryId( cellId )< 0
             )
         || ( // intersection Cells on left periodic Bndry
             a_coordinate(cellId, 1) > (m_rotAxisCoord[0] - 4.0 * halfLength_2)
             && a_coordinate(cellId, 1) < m_rotAxisCoord[0] && a_coordinate(cellId, 2) < z_min_2
             && (a_coordinate(cellId, 2) + halfLength_1) > z_min_12 //&&a_bndryId( cellId )< 0
             )
         || ( // Cells at rotAxis
             (fabs(a_coordinate(cellId, 1) - m_rotAxisCoord[0]) < halfLength_1 * 2.0)
             && (fabs(a_coordinate(cellId, 2) - m_rotAxisCoord[1]) < halfLength_1 * 2.0))) {
        continue;
      }

      m_sortedPeriodicCells->a[m_sortedPeriodicCells->size()] = cellId;
      a_hasProperty(cellId, SolverCell::IsPeriodicWithRot) = true;
      m_sortedPeriodicCells->append();
    }
  } else if(m_periodicCells == 2 || m_periodicCells == 3) {
    m_fvBndryCnd->recorrectCellCoordinates();

    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      a_hasProperty(cellId, SolverCell::IsPeriodicWithRot) = false;

      if(a_isBndryGhostCell(cellId) || c_noChildren(cellId) != 0
         || !a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        continue;
      }

      if( // Cells between periodic Bndry
          a_coordinate(cellId, 0) > periodic_coord[0] && a_coordinate(cellId, 0) < periodic_coord[1]) {
        continue;
      }

      m_sortedPeriodicCells->a[m_sortedPeriodicCells->size()] = cellId;
      a_hasProperty(cellId, SolverCell::IsPeriodicWithRot) = true;
      m_sortedPeriodicCells->append();
    }
    m_fvBndryCnd->rerecorrectCellCoordinates();
  }

  if(m_maxNoPeriodicCells < m_sortedPeriodicCells->size()) {
    mTerm(1, AT_, "raise max periodc cells");
  }


  m_log << "*************************" << endl;
  m_log << "PeriodicCells Identified" << endl;
  m_log << "*************************" << endl;

  xmax += c_cellLengthAtLevel(minLevel());
  ymax += c_cellLengthAtLevel(minLevel());
  zmax += c_cellLengthAtLevel(minLevel());
  xmin -= c_cellLengthAtLevel(minLevel());
  ymin -= c_cellLengthAtLevel(minLevel());
  zmin -= c_cellLengthAtLevel(minLevel());


  // m_fvBndryCnd->rerecorrectCellCoordinates();
  MInt noPeriodicCells; // no of Cells(in this Domain) in overlapping Region
  noPeriodicCells = m_sortedPeriodicCells->size();

  // excahnge number of Cells in overlapping region for every domain
  mAlloc(m_noPeriodicCellsDom, noDomains(), "m_noPeriodicCellsDom", -1, AT_);

  for(MInt i = 0; i < noDomains(); i++) {
    m_noPeriodicCellsDom[i] = 0;
  }

  MPI_Allgather(&noPeriodicCells, 1, MPI_INT, m_noPeriodicCellsDom, 1, MPI_INT, mpiComm(), AT_, "noPeriodicCells",
                "m_noPeriodicCellsDom");


  // save coordinates of cutted cells and exchange them.....after rotating compare them to uncutted
  // cells m_periodicCellDataDom[x][y][z][cellId or -1][left=-1 right=+1] save coordinates of cutted
  // cells in m_noPeriodicCellsDom
  m_periodicCellDataDom = new MFloat*[noDomains()];
  for(MInt domains = 0; domains < noDomains(); domains++) {
    m_periodicCellDataDom[domains] = new MFloat[m_noPeriodicCellsDom[domains] * m_noPeriodicCellData];
  }
  m_log << "*************************" << endl;
  m_log << "Alloc Memory" << endl;
  m_log << "*************************" << endl;

  MFloat z_min_45 = 0.0;
  MFloat x_mid = 0;
  x_mid = (periodic_coord[0] + periodic_coord[1]) / 2.0;

  if(m_periodicCells == 1) {
    for(MInt id = 0; id < noPeriodicCells; id++) {
      for(MInt dim = 0; dim < 3; dim++) {
        m_periodicCellDataDom[domainId()][dim + m_noPeriodicCellData * id] =
            a_coordinate(m_sortedPeriodicCells->a[id], dim);
      }
      m_periodicCellDataDom[domainId()][3 + m_noPeriodicCellData * id] = -1; // set cellsId to copy from to -1
      z_min_45 = -a_coordinate(m_sortedPeriodicCells->a[id], 1) + 400 - c_cellLengthAtLevel(minLevel()) / 10.0;

      if(a_coordinate(m_sortedPeriodicCells->a[id], 2) >= z_min_45) {
        m_periodicCellDataDom[domainId()][4 + m_noPeriodicCellData * id] = -1.0; /// left
      } else {
        m_periodicCellDataDom[domainId()][4 + m_noPeriodicCellData * id] = 1.0; /// right
      }
    }
  } else if(m_periodicCells == 2 || m_periodicCells == 3) {
    for(MInt id = 0; id < noPeriodicCells; id++) {
      for(MInt dim = 0; dim < 3; dim++) {
        m_periodicCellDataDom[domainId()][dim + m_noPeriodicCellData * id] =
            a_coordinate(m_sortedPeriodicCells->a[id], dim);
      }
      m_periodicCellDataDom[domainId()][3 + m_noPeriodicCellData * id] = -1; // set cellsId to copy from to -1

      if(a_coordinate(m_sortedPeriodicCells->a[id], 2) < x_mid) {
        m_periodicCellDataDom[domainId()][4 + m_noPeriodicCellData * id] = -1.0; // left periodic boundary
      } else {
        m_periodicCellDataDom[domainId()][4 + m_noPeriodicCellData * id] = 1.0; // right periodic boundary
      }
    }
  }

  ScratchSpace<MPI_Request> send_Req(noDomains(), AT_, "sendReq");
  ScratchSpace<MPI_Request> recv_Req(noDomains(), AT_, "recvReq");
  send_Req.fill(MPI_REQUEST_NULL);
  recv_Req.fill(MPI_REQUEST_NULL);

  // exchange cell coordinates
  for(MInt snd = 0; snd < domainId(); snd++) {
    if(m_noPeriodicCellsDom[snd] > 0) {
      MInt bufSize = m_noPeriodicCellsDom[snd] * m_noPeriodicCellData;
      MPI_Irecv(m_periodicCellDataDom[snd], bufSize, MPI_DOUBLE, snd, 0, mpiComm(), &recv_Req[snd], AT_,
                "m_periodicCellDataDom[snd]");
    }
  }
  for(MInt rcv = 0; rcv < noDomains(); rcv++) {
    if(rcv != domainId()) {
      if(m_noPeriodicCellsDom[domainId()] > 0) {
        MInt bufSize = m_noPeriodicCellsDom[domainId()] * m_noPeriodicCellData;
        MPI_Isend(m_periodicCellDataDom[domainId()], bufSize, MPI_DOUBLE, rcv, 0, mpiComm(), &send_Req[rcv], AT_,
                  "m_periodicCellDataDom[domainId()]");
      }
    }
  }

  if(domainId() < noDomains() - 1) {
    for(MInt snd = domainId() + 1; snd < noDomains(); snd++) {
      if(m_noPeriodicCellsDom[snd] > 0) {
        MInt bufSize = m_noPeriodicCellsDom[snd] * m_noPeriodicCellData;
        MPI_Irecv(m_periodicCellDataDom[snd], bufSize, MPI_DOUBLE, snd, 0, mpiComm(), &recv_Req[snd], AT_,
                  "m_periodicCellDataDom[snd]");
      }
    }
  }

  MPI_Waitall(noDomains(), &recv_Req[0], MPI_STATUSES_IGNORE, AT_);
  MPI_Waitall(noDomains(), &send_Req[0], MPI_STATUSES_IGNORE, AT_);


  MFloat halfLength = 0;
  MFloat c_x, c_y, c_z, c_x_rot, c_y_rot, c_z_rot;
  MBool rotated = false;
  MBool found = false;
  MFloat count_found = 0;
  MInt rot_counter = 0;

  // get coordinates of uncutted cells
  m_fvBndryCnd->recorrectCellCoordinates();


  m_log << "*************************" << endl;
  m_log << "Build Tree" << endl;
  m_log << "*************************" << endl;


  const MInt maxNoNghbrs_ = 45;
  MIntScratchSpace nghbrList_(maxNoNghbrs_, AT_, "nghbrList");
  MIntScratchSpace layerId_(maxNoNghbrs_, AT_, "layerList");
  MInt counter_ = 0;


  MInt noCells = noInternalCells();

  vector<Point<3>> pts;
  for(MInt cellId = 0; cellId < noCells; ++cellId) {
    if(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) && !a_isBndryGhostCell(cellId) && !a_isHalo(cellId)
       && c_isLeafCell(cellId)) {
      Point<3> a(a_coordinate(cellId, 0), a_coordinate(cellId, 1), a_coordinate(cellId, 2), cellId);
      pts.push_back(a);
    }
  }

  // build up the tree
  KDtree<3> tree(pts);
  MFloat distance = -1.0;
  MFloat eps_ = c_cellLengthAtLevel(maxRefinementLevel()) / 100.0;


  m_log << "*************************" << endl;
  m_log << "Tree Built" << endl;
  m_log << "*************************" << endl;

  // rotate coordinates and look for cells to copy from in each domain
  for(MInt domain = 0; domain < noDomains(); domain++) {
    for(MInt cell = 0; cell < m_noPeriodicCellsDom[domain]; cell++) {
      found = false;
      rot_counter = 0;
      c_x = m_periodicCellDataDom[domain][0 + m_noPeriodicCellData * cell];
      c_y = m_periodicCellDataDom[domain][1 + m_noPeriodicCellData * cell];
      c_z = m_periodicCellDataDom[domain][2 + m_noPeriodicCellData * cell];

      // rotate until inner region reached
      z_min_45 = -c_y + 400 - c_cellLengthAtLevel(minLevel()) / 10.0;

      if(m_periodicCells == 1) {
        if(c_z < z_min_45) {
          do {
            rot_counter++;
            rotated = false;
            c_y_rot = cos(72.0 / 180.0 * PI) * (c_y - m_rotAxisCoord[0])
                      + sin(72.0 / 180.0 * PI) * (c_z - m_rotAxisCoord[1]) + m_rotAxisCoord[0];
            c_z_rot = -sin(72.0 / 180.0 * PI) * (c_y - m_rotAxisCoord[0])
                      + cos(72.0 / 180.0 * PI) * (c_z - m_rotAxisCoord[1]) + m_rotAxisCoord[1];
            c_x_rot = c_x;
            m_periodicCellDataDom[domain][1 + m_noPeriodicCellData * cell] = c_y_rot;
            m_periodicCellDataDom[domain][2 + m_noPeriodicCellData * cell] = c_z_rot;
            c_y = c_y_rot;
            c_z = c_z_rot;

            z_min_1 = -6.3137515147 * c_y + 1462.750302935;
            z_min_2 = -0.1583844403 * c_y + 231.6768880649;


            if((c_z >= (z_min_2 - eps_) && c_z <= (z_min_1 + eps_) && c_y <= m_rotAxisCoord[0])
               || rot_counter == 2 // && c_z> 200.0
            ) {
              rotated = true;
            }
          } while(!rotated);
        } else {
          do {
            rot_counter++;
            rotated = false;
            c_y_rot = cos(72.0 / 180.0 * PI) * (c_y - m_rotAxisCoord[0])
                      - sin(72.0 / 180.0 * PI) * (c_z - m_rotAxisCoord[1]) + m_rotAxisCoord[0];
            c_z_rot = +sin(72.0 / 180.0 * PI) * (c_y - m_rotAxisCoord[0])
                      + cos(72.0 / 180.0 * PI) * (c_z - m_rotAxisCoord[1]) + m_rotAxisCoord[0];
            c_x_rot = c_x;
            m_periodicCellDataDom[domain][1 + m_noPeriodicCellData * cell] = c_y_rot;
            m_periodicCellDataDom[domain][2 + m_noPeriodicCellData * cell] = c_z_rot;
            c_y = c_y_rot;
            c_z = c_z_rot;

            z_min_1 = -6.3137515147 * c_y + 1462.750302935;
            z_min_2 = -0.1583844403 * c_y + 231.6768880649;

            if((c_z >= (z_min_2 - eps_) && c_z <= (z_min_1 + eps_) && c_y <= m_rotAxisCoord[0])
               || rot_counter == 2 // && c_z> 200.0
            ) {
              rotated = true;
            }
          } while(!rotated);
        }
      } else if(m_periodicCells == 2 || m_periodicCells == 3) {
        eps_ = 0.0;
        if(c_x < x_mid) {
          rot_counter++;
          c_x_rot = periodic_coord[1] - (periodic_coord[0] - c_x);
          c_y_rot = c_y;
          c_z_rot = c_z;
          m_periodicCellDataDom[domain][0 + m_noPeriodicCellData * cell] = c_x_rot;
          c_x = c_x_rot;
        } else {
          rot_counter++;
          c_x_rot = (c_x - periodic_coord[1]) + periodic_coord[0];
          c_y_rot = c_y;
          c_z_rot = c_z;
          m_periodicCellDataDom[domain][0 + m_noPeriodicCellData * cell] = c_x_rot;
          c_x = c_x_rot;
        }
      }

      if((c_x >= xmin && c_x <= xmax) && (c_y >= ymin) && (c_y <= ymax) && (c_z >= zmin) && (c_z <= zmax)) {
        distance = -1.1111;
        Point<3> pt(c_x, c_y, c_z);
        MInt cI = tree.nearest(pt, distance);
        MFloat delta_x = fabs(a_coordinate(cI, 0) - c_x - eps_);
        MFloat delta_y = fabs(a_coordinate(cI, 1) - c_y);
        MFloat delta_z = fabs(a_coordinate(cI, 2) - c_z);

        halfLength = c_cellLengthAtLevel(a_level(cI) + 1);

        if(distance < 0.0) {
          mTerm(1, AT_, "negative distance");
        }
        if(delta_x <= halfLength && delta_y <= halfLength && delta_z <= halfLength && distance >= 0.0) {
          found = true;
          m_periodicCellDataDom[domain][3 + m_noPeriodicCellData * cell] = cI; // store cellId to copy from
          m_periodicCellDataDom[domain][4 + m_noPeriodicCellData * cell] =
              m_periodicCellDataDom[domain][4 + m_noPeriodicCellData * cell] * rot_counter; // store number of rotations

          if(rot_counter > 2 || rot_counter < -2) {
            //	cout <<   "ROT_COUNTER " <<  m_periodicCellDataDom[domain][4+5*cell] <<  " y_rot "
            //<< c_y_rot << " z_rot" <<c_z_rot<<endl;
          }
          count_found++;
        } else if((delta_x > halfLength || delta_y > halfLength || delta_z > halfLength)
                  && distance <= 8.0 * halfLength) {
          counter_ = 0;
          counter_ = getAdjacentLeafCells<2, false>(cI, 1, nghbrList_, layerId_);

          for(MInt k = 0; k < counter_; k++) {
            MInt nghbr_Id = nghbrList_[k];
            if(nghbr_Id < 0) {
              continue;
            }
            if(!a_hasProperty(nghbr_Id, SolverCell::IsOnCurrentMGLevel)) {
              continue;
            }
            if(a_isBndryGhostCell(nghbr_Id)) {
              continue;
            }
            if(a_isHalo(nghbr_Id)) {
              continue;
            }
            if(c_noChildren(nghbr_Id) != 0) {
              continue;
            }
            delta_x = fabs(a_coordinate(nghbr_Id, 0) - c_x - eps_);
            delta_y = fabs(a_coordinate(nghbr_Id, 1) - c_y);
            delta_z = fabs(a_coordinate(nghbr_Id, 2) - c_z);


            halfLength = c_cellLengthAtLevel(a_level(nghbr_Id) + 1);
            if(delta_x <= halfLength && delta_y <= halfLength && delta_z <= halfLength) {
              found = true;
              m_periodicCellDataDom[domain][3 + m_noPeriodicCellData * cell] = nghbr_Id; // store cellId to copy from
              m_periodicCellDataDom[domain][4 + m_noPeriodicCellData * cell] =
                  m_periodicCellDataDom[domain][4 + m_noPeriodicCellData * cell]
                  * rot_counter; // store number of rotations

              if(rot_counter > 2 || rot_counter < -2) {
                //   cout <<   "ROT_COUNTER " <<
                //   m_periodicCellDataDom[domain][4+5*cell] <<  " y_rot "
                //   << c_y_rot << " z_rot" <<c_z_rot<<endl;
              }
              count_found++;
              break;
            }
          }
        }
      }
      if(!found) {
        m_periodicCellDataDom[domain][3 + m_noPeriodicCellData * cell] = -1;
        m_periodicCellDataDom[domain][4 + m_noPeriodicCellData * cell] =
            m_periodicCellDataDom[domain][4 + m_noPeriodicCellData * cell] * rot_counter; // store number of rotations
        if(noDomains() == 1) {
          cout << "nothing found: " << domainId() << " cx: " << c_x << " cy: " << c_y << " cz: " << c_z
               << " cx_r: " << c_x << " cy_r: " << c_y << " cz_r: " << c_z << endl;
          mTerm(1, AT_, "NOTHING FOUND");
        }
      }
    }
  }


  // correct cell coordinates back
  m_fvBndryCnd->rerecorrectCellCoordinates();


  MPI_Status status;

  // array with information how many cells data to send/receive to/from wich domain
  m_noPerCellsToSend = new MInt[noDomains()];
  m_noPerCellsToReceive = new MInt[noDomains()];


  for(MInt dom = 0; dom < noDomains(); dom++) {
    m_noPerCellsToSend[dom] = 0;
    for(MInt c = 0; c < m_noPeriodicCellsDom[dom]; c++) {
      if(m_periodicCellDataDom[dom][3 + m_noPeriodicCellData * c] >= 0) {
        m_noPerCellsToSend[dom] = m_noPerCellsToSend[dom] + 1;
      }
    }
  }

  m_noPerCellsToReceive[domainId()] = m_noPerCellsToSend[domainId()];

  for(MInt dom = 0; dom < noDomains(); dom++) {
    // cout<<  "DOMAIN; " << domainId() << " has to send " <<  m_noPerCellsToSend[dom] << " to
    // Domain " << dom << endl;
  }


  // exchange information how many cell data to send/receive

  for(MInt snd = 0; snd < domainId(); snd++) {
    MPI_Recv(&m_noPerCellsToReceive[snd], 1, MPI_INT, snd, 0, mpiComm(), &status, AT_, "m_noPerCellsToReceive[snd]");
  }
  for(MInt rcv = 0; rcv < noDomains(); rcv++) {
    if(rcv != domainId()) {
      MPI_Send(&m_noPerCellsToSend[rcv], 1, MPI_INT, rcv, 0, mpiComm(), AT_, "m_noPerCellsToSend[rcv]");
    }
  }

  if(domainId() < noDomains() - 1) {
    for(MInt snd = domainId() + 1; snd < noDomains(); snd++) {
      MPI_Recv(&m_noPerCellsToReceive[snd], 1, MPI_INT, snd, 0, mpiComm(), &status, AT_, "m_noPerCellsToReceive[snd]");
    }
  }


  for(MInt dom = 0; dom < noDomains(); dom++) {
    // cout<<  "DOMAIN; " << domainId() << " has to receive " <<  m_noPerCellsToReceive[dom] << "
    // from Domain " << dom << endl;
  }


  m_log << "*************************" << endl;
  m_log << "AllocateMemory 2" << endl;
  m_log << "*************************" << endl;


  // memory for storage of conservative variables + sortedId + cellId to copy from
  m_periodicDataToSend = new MFloat*[noDomains()];

  m_noPeriodicCellData = PV->noVariables;
  m_noPeriodicData = m_noPeriodicCellData + 2;


  // RANS Azimuthal
  for(MInt dom = 0; dom < noDomains(); dom++) {
    m_periodicDataToSend[dom] = new MFloat[m_noPerCellsToSend[dom] * m_noPeriodicData];
  }

  // memory for storage of received cell data
  m_periodicDataToReceive = new MFloat*[noDomains()];

  for(MInt dom = 0; dom < noDomains(); dom++) {
    m_periodicDataToReceive[dom] = new MFloat[m_noPerCellsToReceive[dom] * m_noPeriodicData];
  }

  MInt counting;

  for(MInt dom = 0; dom < noDomains(); dom++) {
    counting = 0;
    for(MInt c = 0; c < m_noPeriodicCellsDom[dom]; c++) {
      if(m_periodicCellDataDom[dom][3 + m_noPeriodicCellData * c] >= 0) { // ACHTUNG int -- float conversion

        m_periodicDataToSend[dom][5 + counting * m_noPeriodicData] = c;
        m_periodicDataToSend[dom][6 + counting * m_noPeriodicData] =
            m_periodicCellDataDom[dom][3 + m_noPeriodicCellData * c];
        counting++;
      }
    }
  }

  m_log << "*************************" << endl;
  m_log << "Connectivity Matrix created" << endl;
  m_log << "*************************" << endl;
}

// === Azimuthal periodic concept ends ========================================

// check cells
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::checkCells() {
  TRACE();

  IF_CONSTEXPR(nDim == 2)
  mTerm(1, "By now only used in 3D. If you want to use it in 2D,"
           " just remove this warning.");

  MBool bndNghbr;
  // MBool invalidCells = false;
  MBool noNghbr;
  MInt nghbrId;
  MInt noCells = noInternalCells();
  //---

  for(MInt id = 0; id < noCells; id++) {
    // edit claudia: do not reset property 8 (cell is valid) here!
    // invalid cells may also be detected during boundary cell preprocessing - this information
    // should not be lost!
    bndNghbr = false;
    noNghbr = false;
    if(a_bndryId(id) == -1) {
      for(MInt dir = 0; dir < m_noDirs; dir++) {
        if(a_hasNeighbor(id, dir) > 0) {
          nghbrId = c_neighborId(id, dir);
          if(a_bndryId(nghbrId) > -1) {
            bndNghbr = true;
          }
        } else {
          if(c_parentId(id) == -1) {
            noNghbr = true;
          } else if(a_hasNeighbor(c_parentId(id), dir) == 0) {
            noNghbr = true;
          }
        }
      }
      if(noNghbr && bndNghbr && !a_isPeriodic(id) && !a_hasProperty(id, SolverCell::IsCutOff)
         && !a_hasProperty(id, SolverCell::IsNotGradient) && c_noChildren(id) == 0) {
        a_hasProperty(id, SolverCell::IsInvalid) = true;
        // invalidCells = true;
        m_log << id << " is invalid";
        for(MInt spaceId = 0; spaceId < nDim; spaceId++)
          m_log << " " << a_coordinate(id, spaceId);
        m_log << endl;
        m_log << a_isInterface(id) << " " << a_isPeriodic(id) << " " << a_hasProperty(id, SolverCell::IsCutOff) << endl;
        for(MInt dir = 0; dir < m_noDirs; dir++) {
          if(a_hasNeighbor(id, dir) > 0) {
            m_log << "direction " << dir << " " << c_neighborId(id, dir) << " " << a_bndryId(c_neighborId(id, dir))
                  << endl;
          }
        }
        a_variable(id, CV->RHO) = 2.0;
      }
    }
  }
  //   if( invalidCells ) {
  //     saveSolverSolution(1);
  //     mTerm(1,AT_, "Invalid cells found, see log file for details - writing
  //     output file");
  //
  //   }
}

//-----------------------------------------------------------------------------


/** \brief help-function for engine calculations which returns the crank-angle
 *         for a given time
 *         mode = 0: return CAD in range of (0-720)
 *         mode = 1: return accumulated crankAnge in radian
 *
 *  \author Tim Wegmann
 */
template <MInt nDim_, class SysEqn>
MFloat FvCartesianSolverXD<nDim_, SysEqn>::crankAngle(const MFloat elapsedTime, const MInt mode) {
  TRACE();

  MFloat& Strouhal = m_static_crankAngle_Strouhal;
  MFloat& initialCad = m_static_crankAngle_initialCad;

  if(initialCad < 0) {
    Strouhal = Context::getSolverProperty<MFloat>("Strouhal", m_solverId, AT_, &Strouhal);
    initialCad = 0;
    initialCad = Context::getSolverProperty<MFloat>("initialCrankAngle", m_solverId, AT_, &initialCad);
  }

  return maia::math::crankAngle(elapsedTime, Strouhal, initialCad, mode);
}

//---------------------------------------------------------------------------

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeSamplingTimeStep() {
  IF_CONSTEXPR(nDim == 3) { mTerm(1, "Only available in 2D."); }
  else {
    computeSamplingTimeStep_();
  }
}

/** \brief computes the time step according to the sample variables
 *
 *  \author Stephan Schlimpert
 *  \date April, 2014
 *
 **/
template <MInt nDim_, class SysEqn>
inline void FvCartesianSolverXD<nDim_, SysEqn>::computeSamplingTimeStep_() {
  TRACE();

  if(m_timeStepMethod != 17511 && !m_combustion) {
    mTerm(1, AT_,
          "this function should only be called with timeStepMethod 17511 "
          "and combustion enabled");
  }

  if(!m_combustion) {
    stringstream errorMessage;
    errorMessage << "ERROR: combustion is turned off, this time step method is especially written "
                    "for combustion cases ... exiting";
    mTerm(1, AT_, errorMessage.str());
  }

  MInt bcSpId;
  MFloat cycleTime, sampleTime; //,sample;
  // MFloat inletTubeAreaRatio = 2.002/0.412;
  const MFloat slOverU = m_flameSpeed / m_MaFlameTube;
  const MFloat Lf = m_realRadiusFlameTube * tan(acos(slOverU)); // nominal flame length
  MFloat Af = F2 * sqrt(POW2(Lf) + POW2(m_realRadiusFlameTube));
  const MFloat slantLength = Af * F1B2; // slant flame length (2D)
  const MFloat rLaminarFlameThickness = 1. / m_laminarFlameThickness;
  MFloat rFlameSpeed = 1. / m_flameSpeed;
  MFloat DInfinityFlameTube = SUTHERLANDLAW(m_temperatureFlameTube);
  MFloat ReFl = m_rPr * rLaminarFlameThickness * DInfinityFlameTube * m_MaFlameTube
                * rFlameSpeed; ///< Re = D / (Pr * lf *(s_u/Ma)) : Reynolds number based on the flame
                               ///< properties, should be the same as chosen for Re in your property
  MFloat sigma = m_subfilterVariance * c_cellLengthAtLevel(maxRefinementLevel());
  MFloat flameStr = -1.0;
  //	MFloat calcMarksteinLength = 1./ReFl*m_rPr*1./m_flameSpeed* DInfinityFlameTube; ///<
  // calculated Markstein length referred to the flame properties MFloat calcMarksteinLengthTR
  // = 1./ReFl*1./(F2*m_realRadiusFlameTube)*m_rPr*1./m_flameSpeed*DInfinityFlameTube; ///<
  // calculated Markstein length referred to the flame properties and the flame tube radius
  //---

  // compute the cycle time and the cycle
  cycleTime = (F2 * PI) / m_flameStrouhal;
  sampleTime = cycleTime / m_samplesPerCycle;

  m_log << endl;
  m_log << "*****************************" << endl;
  m_log << "2D Flame test case properties" << endl;
  m_log << "*****************************" << endl << endl;
  m_log << "flame tube radius (used for levelSet BC): " << m_radiusFlameTube << endl;
  m_log << "flame tube real radius: " << m_realRadiusFlameTube << endl;
  m_log << "nominal flame length L_f: " << Lf << endl;
  m_log << "nominal slant flame length: " << slantLength << endl;
  m_log << "nominal flame surface area: " << Af << endl;
  m_log << "uncurved flame tip angle in Grad: " << atan(m_realRadiusFlameTube / Lf) * 180. / PI << endl;
  m_log << "laminar flame speed: " << m_flameSpeed << endl;
  m_log << "laminar flame thickness: " << m_laminarFlameThickness << endl;
  m_log << "subfilter variance sigma: " << sigma << endl;
  m_log << "******************************" << endl;
  m_log << "Corrugated Flamelet regime:" << endl;
  m_log << "lf < l_kolmogorov -> Ka_F < 1" << endl;
  m_log << "******************************" << endl;
  if(domainId() == 0) {
    cerr << "*****************************" << endl;
    cerr << "2D Flame test case properties" << endl;
    cerr << "*****************************" << endl << endl;
    cerr << "flame tube radius (used for levelSet BC): " << m_radiusFlameTube << endl;
    cerr << "flame tube real radius: " << m_realRadiusFlameTube << endl;
    cerr << "nominal flame length L_f: " << Lf << endl;
    cerr << "nominal slant flame length: " << slantLength << endl;
    cerr << "nominal flame surface area: " << Af << endl;
    cerr << "uncurved flame tip angle in Grad: " << atan(m_realRadiusFlameTube / Lf) * 180. / PI << endl;
    cerr << "laminar flame speed: " << m_flameSpeed << endl;
    cerr << "laminar flame thickness: " << m_laminarFlameThickness << endl;
    cerr << "subfilter variance sigma: " << sigma << endl;
  }

  if((m_subfilterVariance < m_laminarFlameThickness)) {
    m_log << "+Case 1: sigma (=filter size) < laminar flame thickness" << endl;
    m_log << " *Conclusion: flame is resolved -> filtered flame thickness = laminar flame thickness" << endl;
    m_log << " *Conclusion: no turbulent contribution" << endl;
    m_log << " *Info: filtered flame speed s_F = s_l laminar flame speed" << endl;
    m_log << " *Info: Dth_turb,F (subfilter eddy diffusivity) = Dth_lam (laminar diffusivity) " << endl;
  } else {
    m_log << "+Case 2: sigma (=filter size) > laminar flame thickness" << endl;
    m_log << " *Conclusion: sub-filter flame front wrinkling increases the resolved burning velocity" << endl;
    m_log << " *Conclusion: filtered flame speed s_F > s_l (laminar flame speed)" << endl;
    m_log << " *Info: if the flame front is not altered by turbulence," << endl;
    m_log << "        the chemical time scale of the turbulent flame time_c_F" << endl;
    m_log << "        remains the same as the laminar one time_c" << endl;
  }
  m_log << endl;
  m_log << "mach number inlet: " << m_Ma << endl;
  m_log << "mach number in flame tube: " << m_MaFlameTube << endl;
  m_log << "Re (ref. to stagnation point): " << sysEqn().m_Re0 << endl;
  m_log << "Re (ref. to infinity values): " << m_Re << endl;
  m_log << "Re (ref. to the flame properties): " << ReFl << endl;
  if((ReFl < (m_Re - 10.0)) || (ReFl > (m_Re + 10.0))) {
    if(domainId() == 0) {
      cerr << "Warning: Your Reynolds number should be Re= " << ReFl << " , but it is chosen to Re= " << m_Re << endl;
    }
    m_log << "Warning: Your Reynolds number should be Re= " << ReFl << " , but it is chosen to Re= " << m_Re << endl;
  }
  m_log << "Re (ref. to the flame properties and to the flame tube diameter): " << ReFl * F2 * m_realRadiusFlameTube
        << endl;
  m_log << "markstein length (controls the flame curvature): " << m_marksteinLength << endl;
  /*
if((calcMarksteinLength < (m_marksteinLength - 0.002)) || (calcMarksteinLength >
(calcMarksteinLength + 0.002)) ) { cerr << "Instability Warning: Markstein number should be
marksteinLength= " << calcMarksteinLength << " , but it is chosen to marksteinLength= " <<
m_marksteinLength << endl; m_log << "Instability Warning: Markstein number should be
marksteinLength= " << calcMarksteinLength << " , but it is chosen to marksteinLength= " <<
m_marksteinLength << endl;
}
  */
  m_log << "CFL number: " << m_cfl << endl;
  m_log << "smallest Cell distance according to max refinement Level: " << c_cellLengthAtLevel(maxRefinementLevel())
        << endl;
  m_log.precision(16);
  m_log << "reference time (=u_0): " << m_timeRef << endl;
  m_log << "time step according to the CFL condition: " << timeStep(true) * m_timeRef << endl;
  m_log.precision(9);

  m_log << "cycleTime (nondim): " << cycleTime << endl;
  m_log << "sampleTime (nondim): " << sampleTime << endl;
  if(m_structuredFlameOutput || m_forcing) {
    m_noTimeStepsBetweenSamples = 0;
    for(MInt n = 1; n < 10000000; n++) {
      if(sampleTime / (MFloat)(n) < timeStep(true)) {
        forceTimeStep(sampleTime / (MFloat)(n));
        m_noTimeStepsBetweenSamples = n;
        break;
      }
    }
    sampleTime = m_noTimeStepsBetweenSamples * timeStep(true);
    cycleTime = sampleTime * m_samplesPerCycle;

    if(m_noTimeStepsBetweenSamples == 0) {
      mTerm(1, AT_, "Time step calculation error");
    }

    if(m_neutralFlameStrouhal > 0) {
      flameStr = m_neutralFlameStrouhal * Lf / (F2 * PI);
      if(domainId() == 0) {
        cerr << "Be careful, strouhal number is based on length one, not on flame length (for "
                "neutral markstein length computation) "
             << endl;
        cerr << "time step due to sampling (depends on the Strouhal number) (phys): " << timeStep(true) * m_timeRef
             << endl;
        cerr << "Excitation frequency f = " << m_neutralFlameStrouhal / (F2 * PI) << endl;
        cerr << "Excitation frequency f (phys) = " << m_neutralFlameStrouhal / (F2 * PI * m_timeRef) << endl;
        cerr << "flame Strouhal number Stf (based on Lf) = " << flameStr << endl;
        cerr << "flame Strouhal number Stf (based on Lf phys) = " << flameStr / m_timeRef << endl;
        cerr << "check flame Strouhal number Stf = 1/t * Lf / u_mean = " << 1. / cycleTime * Lf << endl;
      }
      m_log << "time step due to sampling (depends on the Strouhal number) (phys): " << timeStep(true) * m_timeRef
            << endl;
      m_log << "Excitation frequency f = " << m_neutralFlameStrouhal / (F2 * PI) << endl;
      m_log << "Excitation frequency f (phys) = " << m_neutralFlameStrouhal / (F2 * PI * m_timeRef) << endl;
      m_log << "flame Strouhal number Stf (based on Lf) = " << flameStr << endl;
      m_log << "flame Strouhal number Stf (based on Lf phys) = " << flameStr / m_timeRef << endl;
      m_log << "check flame Strouhal number Stf = 1/t * Lf / u_mean= " << 1. / cycleTime * Lf << endl;
      if(((flameStr < (1. / cycleTime * Lf - 0.05)) || (flameStr > (1. / cycleTime * Lf + 0.05))) && domainId() == 0) {
        cerr << "Warning: Your flame strouhal is = " << flameStr << " , but it is checked to = " << 1. / cycleTime * Lf
             << endl;
      }
      m_log << "wave number (based on length one!!) omega=St/1.0: " << m_flameStrouhal
            << endl; // equals neutralFlameStrouhal
      m_log << "wave number (based on length one!!) omega=St/1.0 (phys): " << m_flameStrouhal / m_timeRef
            << endl; // equals neutralFlameStrouhal
      if(domainId() == 0) {
        cerr << "wave number (based on length one!!) omega=St/1.0: " << m_flameStrouhal
             << endl; // equals neutralFlameStrouhal
        cerr << "wave number (based on length one!!) omega=St/1.0 (phys): " << m_flameStrouhal / m_timeRef
             << endl; // equals neutralFlameStrouhal
      }
    } else {
      flameStr = m_flameStrouhal / (F2 * PI);
      m_log << "time step due to sampling (depends on the Strouhal number)  (phys): " << timeStep(true) * m_timeRef
            << endl;
      m_log << "Excitation frequency f = " << m_strouhal / (F2 * PI) << endl;
      m_log << "flame Strouhal number Stf (based on Lf) = " << flameStr << endl;
      m_log << "check flame Strouhal number Stf = 1/t * Lf / u_mean = " << 1. / cycleTime * Lf << endl;
      m_log << "wave number (based on flame length!!) omega=St/L_f: " << m_flameStrouhal << endl;

      if(domainId() == 0) {
        cerr << "time step due to sampling (depends on the Strouhal number)  (phys): " << timeStep(true) * m_timeRef
             << endl;
        cerr << "Excitation frequency f = " << m_strouhal / (F2 * PI) << endl;
        cerr << "flame Strouhal number Stf (based on Lf) = " << flameStr << endl;
        cerr << "check flame Strouhal number Stf = 1/t * Lf / u_mean = " << 1. / cycleTime * Lf << endl;
        cerr << "wave number (based on flame length!!) omega=St/L_f: " << m_flameStrouhal << endl;
      }
    }
  }

  m_log << "excitation amplitude at the inlet: " << m_forcingAmplitude * m_VInfinity << endl;
  m_log << "excitation amplitude in the flame tube: " << m_forcingAmplitude * m_VInfinity * m_inletTubeAreaRatio
        << endl;
  m_log << "excitation amplitude in the flame tube in % (ref. to the laminar flame speed): "
        << m_forcingAmplitude * m_VInfinity * m_inletTubeAreaRatio / m_flameSpeed * 100.0 << " %" << endl;
  m_log << "excitation amplitude in the flame tube in % (ref. to inflow velocity): "
        << m_forcingAmplitude * m_VInfinity * m_inletTubeAreaRatio * 100.0 << " %" << endl;

  if(domainId() == 0) {
    cerr << "excitation amplitude at the inlet: " << m_forcingAmplitude * m_VInfinity << endl;
    cerr << "excitation amplitude in the flame tube: " << m_forcingAmplitude * m_VInfinity * m_inletTubeAreaRatio
         << endl;
    cerr << "excitation amplitude in the flame tube in % (ref. to the laminar flame speed): "
         << m_forcingAmplitude * m_VInfinity * m_inletTubeAreaRatio / m_flameSpeed * 100.0 << " %" << endl;
    cerr << "excitation amplitude in the flame tube in % (ref. to inflow velocity): "
         << m_forcingAmplitude * m_inletTubeAreaRatio * 100.0 << " %" << endl;

    if(m_samplingStartIteration < 0) {
      cerr << "ERROR: set samplingStartIteration to some value" << endl;
    }
  }
  m_samplingStartCycle = (MInt)(m_samplingStartIteration / (m_samplesPerCycle * m_noTimeStepsBetweenSamples));

  //	if(m_samplesPerCycle *
  // m_noTimeStepsBetweenSamples*m_samplingStartCycle<m_samplingStartIteration)
  //  m_samplingStartCycle += 1;

  m_samplingEndCycle = m_samplingStartCycle + m_noSamplingCycles;

  if(m_structuredFlameOutput && m_forcing) {
    switch(m_structuredFlameOutputLevel) {
      default:
        m_log << "Warning: structured Output on finest level because unknown "
                 "structuredFlameOutputLevel"
              << endl;
        if(domainId() == 0) {
          cerr << "Warning: structured Output on finest level because unknown "
                  "structuredFlameOutputLevel"
               << endl;
        }
        break;
      case 0:
        if(domainId() == 0) {
          cerr << "Warning: structuredFlameOutput is on, but structuredOuputLevel  is set to "
               << m_structuredFlameOutputLevel << endl;
          cerr << "Warning: no structured Output" << endl;
        }
        m_log << "Warning: structuredFlameOutput is on, but structuredOuputLevel  is set to "
              << m_structuredFlameOutputLevel << endl;
        m_log << "Warning: no structured Output" << endl;
        break;
      case 1:
        m_log << "structured Output for single flame (old version): " << endl;
        break;
      case 2:
        m_log << "structured Output for single flame (optimized version): " << endl;
        break;
      case 3:
        m_log << "structured Output for single flame with plenum (optimized version): " << endl;
        break;
      case 4:
        m_log << "structured Output for single flame with plenum, ascii output of whole domain "
                 "(optimized version): "
              << endl;
        break;
      case 40:
        m_log << "structured Output for single flame with plenum, ascii output of whole domain + "
                 "dPdT source tem (optimized version): "
              << endl;
        break;
      case 5:
        m_log << "unstructured Output for single flame, netcdf output of whole domain: " << endl;
        break;
    }
    m_log << "cycleTime (nondim, adapted): " << cycleTime << endl;
    m_log << "sampleTime (nondim, adapted): " << sampleTime << endl;
    m_log << "number of timesteps between samples: " << m_noTimeStepsBetweenSamples << endl;
    m_log << "sampling Start cycle: " << m_samplingStartCycle << endl;
    m_log << " start flameSurfaceArea - Output at Iteration: "
          << m_samplingStartCycle * m_samplesPerCycle * m_noTimeStepsBetweenSamples << endl;
    m_log << " end flameSurfaceArea - Output at Iteration: "
          << m_samplingEndCycle * m_samplesPerCycle * m_noTimeStepsBetweenSamples << endl;

    if(domainId() == 0) {
      cerr << "cycleTime (nondim): " << cycleTime << endl;
      cerr << "sampleTime (nondim): " << sampleTime << endl;
      cerr << "number of timesteps between samples: " << m_noTimeStepsBetweenSamples << endl;
      cerr << "sampling Start cycle: " << m_samplingStartCycle << endl;
      cerr << " start flameSurfaceArea - Output at Iteration: "
           << m_samplingStartCycle * m_samplesPerCycle * m_noTimeStepsBetweenSamples << endl;
      cerr << " end flameSurfaceArea - Output at Iteration: "
           << m_samplingEndCycle * m_samplesPerCycle * m_noTimeStepsBetweenSamples << endl;
    }

    if((g_timeSteps + m_restartTimeStep) < m_samplingEndCycle * m_samplesPerCycle * m_noTimeStepsBetweenSamples) {
      if(!m_forceNoTimeSteps) {
        m_log << "WARNING: timeSteps changed from : " << g_timeSteps;
        if(domainId() == 0) {
          cerr << "WARNING: timeSteps changed from : " << g_timeSteps;
        }
        g_timeSteps = m_samplingEndCycle * m_samplesPerCycle * m_noTimeStepsBetweenSamples + 5000 - m_restartTimeStep;
        if(domainId() == 0) {
          cerr << " to " << g_timeSteps << endl;
        }
        m_log << " to " << g_timeSteps << endl;
      }
    } else {
      m_log << "WARNING: timeSteps are NOT adapted to the required number of time steps (used "
               "for reference testcases)";
      if(domainId() == 0) {
        cerr << "WARNING: timeSteps are NOT adapted to the required number of time steps (used for "
                "reference testcases)";
      }
    }

  } else {
    if(m_structuredFlameOutput && !m_forcing) {
      if(domainId() == 0) {
        cerr << "Warning: Forcing ist turned off, but structuredFlameOutput is on" << endl;
      }
      m_log << "Warning: Forcing ist turned off, but structuredFlameOutput is on" << endl;
      switch(m_structuredFlameOutputLevel) {
        default:
          m_log << "Warning: structured Output on finest level because unknown "
                   "structuredFlameOutputLevel"
                << endl;
          if(domainId() == 0) {
            cerr << "Warning: structured Output on finest level because unknown "
                    "structuredFlameOutputLevel"
                 << endl;
          }
          break;
        case 0:
          if(domainId() == 0) {
            cerr << "Warning: structuredFlameOutput is on, but structuredOuputLevel  is set to "
                 << m_structuredFlameOutputLevel << endl;
            cerr << "Warning: no structured Output" << endl;
          }
          m_log << "Warning: structuredFlameOutput is on, but structuredOuputLevel  is set to "
                << m_structuredFlameOutputLevel << endl;
          m_log << "Warning: no structured Output" << endl;
          break;
        case 1:
          m_log << "structured Output for single flame (old version): " << endl;
          break;
        case 2:
          m_log << "structured Output for single flame (optimized version): " << endl;
          break;
        case 3:
          m_log << "structured Output for single flame with plenum (optimized version): " << endl;
          break;
        case 4:
          m_log << "structured Output for single flame, ascii output of whole domain (optimized "
                   "version): "
                << endl;
          break;
        case 40:
          m_log << "structured Output for single flame with plenum, ascii output of whole domain "
                   "+ dPdT source tem (optimized version): "
                << endl;
          break;
        case 5:
          m_log << "unstructured Output for single flame, netcdf output of whole domain: " << endl;
          break;
      }
      m_log << "cycleTime: " << cycleTime << endl;
      m_log << "sampleTime: " << sampleTime << endl;
      m_log << "number of timesteps between samples: " << m_noTimeStepsBetweenSamples << endl;
      m_log << "sampling Start cycle: " << m_samplingStartCycle << endl;
      m_log << " start flameSurfaceArea - Output at Iteration: "
            << m_samplingStartCycle * m_samplesPerCycle * m_noTimeStepsBetweenSamples << endl;

      if(m_noTimeStepsBetweenSamples == -1) {
        mTerm(1, AT_,
              "Error no time steps between samples is not calculated, prbably wron "
              "structuredFlameOutput");
      }
      if(domainId() == 0) {
        cerr << "cycleTime: " << cycleTime << endl;
        cerr << "sampleTime: " << sampleTime << endl;
        cerr << "number of timesteps between samples: " << m_noTimeStepsBetweenSamples << endl;
        cerr << "sampling Start cycle: " << m_samplingStartCycle << endl;
        cerr << " start flameSurfaceArea - Output at Iteration: "
             << m_samplingStartCycle * m_samplesPerCycle * m_noTimeStepsBetweenSamples << endl;
      }
    } else {
      if(!m_structuredFlameOutput && m_forcing) {
        if(domainId() == 0) {
          cerr << "Warning: Forcing ist turned on, but structuredFlameOutput is off" << endl;
          cerr << "Warning: There will be no structured Output and no flameSurfaceArea - Output" << endl;
        }
        m_log << "Warning: Forcing ist turned on, but structuredFlameOutput is off" << endl;
        m_log << "Warning: There will be no structured Output and no flameSurfaceArea - Output" << endl;

      } else {
        m_log << "no structured Output, structuredFlameOutput= " << m_structuredFlameOutput << endl;
      }
    }
  }
  for(MInt bcId = 0; bcId < m_noSpongeBndryCndIds; bcId++) {
    bcSpId = m_spongeBndryCndIds[bcId];
    // calculate time dependent sigma sponge
    if(m_spongeTimeDependent[bcId]) {
      m_log << endl;
      m_log << "*************************************************************" << endl;
      m_log << "Additional Information for time dependent sponge boundary Id: " << bcSpId << endl;
      m_log << "*************************************************************" << endl;
      m_log << "sponge end iteration= " << m_spongeEndIteration[bcId] << endl;
      m_log << "sigma_max(t=" << m_spongeEndIteration[bcId] << ") = "
            << m_sigmaSpongeBndryId[bcId] / tanh(F1)
                   * (tanh(F1
                           - (m_spongeEndIteration[bcId] - m_spongeStartIteration[bcId])
                                 / (m_spongeEndIteration[bcId] - m_spongeStartIteration[bcId])))
            << endl;
      m_log << "sponge end time = " << m_spongeEndIteration[bcId] * (timeStep(true) * m_timeRef) << endl << endl;
      //  m_sigmaSpongeBndryId[bcId] = m_sigmaSpongeBndryId[bcId]*(F1-tanh(
      //  F4*m_time/m_spongeEndTime[bcId]));
    }
  }
  if(m_forcing && approx(flameStr, -1.0, MFloatEps)) {
    mTerm(1, AT_, "Error flame strouhal number based on Lf not determined");
  }
  if(domainId() == 0) {
    FILE* datei;
    datei = fopen("flameLog", "a+");
    fprintf(datei, " %-10.10f", sampleTime);
    fprintf(datei, " %-10.10f", m_realRadiusFlameTube);
    fprintf(datei, " %-10.10f", m_flameSpeed);
    fprintf(datei, " %-10.10f", m_MaFlameTube);
    fprintf(datei, " %-10.10f", m_timeRef);
    fprintf(datei, " %-10.10f", flameStr);
    fprintf(datei, " %-10.10f", m_forcingAmplitude);
    fprintf(datei, " %-10.10f", m_rhoFlameTube);
    fprintf(datei, " %-10.10f", m_Ma);
    fprintf(datei, " %d", m_samplingStartCycle);
    fprintf(datei, " %d", m_samplingEndCycle);
    fprintf(datei, " %d", (MInt)m_samplesPerCycle);
    fprintf(datei, " %-10.10f", m_marksteinLength);
    fprintf(datei, " %-10.10f", m_laminarFlameThickness);
    fprintf(datei, " %-10.10f", ReFl);
    fprintf(datei, " %-10.10f", m_burntUnburntTemperatureRatio);
    fprintf(datei, " %-10.10f", m_flameStrouhal);
    fprintf(datei, "\n");
    fclose(datei);
  }
}

// -----------------------------------------------------------

/** \brief Computes the viscous flux using a central difference scheme
 *
 * \authors Daniel Hartmann, Stephan Schlimpert
 * \date November 16, 2006, November 2011
 *
 * last change: using muInfinity gives solution independent from rhoInfinity, which could changes
 * for DL instability computations (TInfinity is kept constant)
 */

template <MInt nDim_, class SysEqn>
inline void FvCartesianSolverXD<nDim_, SysEqn>::viscousFlux_Gequ_Pv() {
  IF_CONSTEXPR(nDim == 3) mTerm(1, "Not available in 3D.");
  TRACE();
  if(!m_divergenceTreatment) {
    viscousFlux();
    return;
  }
  constexpr MInt index0[2] = {1, 0};
  const MInt noPVars = PV->noVariables;
  const MInt noData = m_surfaceVarMemory;
  const MInt noSurfaces = a_noSurfaces();
  const MInt slopeMemory = m_slopeMemory;
  const MFloat gammaMinusOne = m_gamma - 1.0;
  const MFloat FgammaMinusOne = F1 / gammaMinusOne;
  const MFloat gFGMO = m_gamma * FgammaMinusOne;
  MInt* nghbrs = (MInt*)(&(a_surfaceNghbrCellId(0, 0)));
  MFloatScratchSpace tau(nDim, AT_, "tau");
  MFloat* area = &a_surfaceArea(0);
  MFloat* slope = (MFloat*)(&(a_slope(0, 0, 0)));
  MFloat* var = (MFloat*)(&(a_surfaceVariable(0, 0, 0)));
  // --- end of initialization

  // assuming m_TInfinity is the temperature of the unburnt gas
  // Dth = mue^u / ( rho^u *Pr ) = const, rhoU = m_rhoInfinity (density of the unburnt gas)

  // changed: because gives solution independent from rhoInfinity which is useful if rhoInfinity is
  // changing at a thermal inlet boundary condition
  const MFloat rhoUDth = sysEqn().m_muInfinity * m_rPr; // = m_DthInfinity * m_rhoInfinity;

  for(MInt srfcId = 0; srfcId < noSurfaces; srfcId++) {
    // calculate the primitve variables on the surface u,v,rho,p
    // LR
    const MInt i = srfcId * noData;
    const MFloat u = F1B2 * (var[i] + var[i + noPVars]);
    const MFloat v = F1B2 * (var[i + 1] + var[i + noPVars + 1]);
    const MFloat rho = F1B2 * (var[i + 2] + var[i + noPVars + 2]);
    const MFloat Frho = F1 / rho;
    const MFloat p = F1B2 * (var[i + 3] + var[i + noPVars + 3]);

    // compute the temperature on the surface p = rho * T * 1.0/gamma
    const MFloat T = sysEqn().temperature_ES(rho, p);

    // indices for the orientation
    const MInt id0 = a_surfaceOrientation(srfcId);
    const MInt id1 = index0[id0];

    // Compute A / Re0
    const MFloat dAOverRe0 = area[srfcId] * m_rRe0;

    // calculate the viscosity with the sutherland law mue = T^3/2 * (1+S/T_0)(T + S/T_0)
    const MFloat mue = SUTHERLANDLAW(T);
    // calculate the thermal conductivity
    const MFloat lambda = m_rPr * mue;

    // calculate the heat flux (T_x = gamma*(p_x/rho - p/rho^2 * rho_x))
    const MFloat q =
        lambda * gFGMO * Frho
        * ((a_surfaceFactor(srfcId, 0) * slope[nghbrs[2 * srfcId] * slopeMemory + PV->P * nDim + id0]
            + a_surfaceFactor(srfcId, 1) * slope[nghbrs[2 * srfcId + 1] * slopeMemory + PV->P * nDim + id0])
           - p * Frho
                 * (a_surfaceFactor(srfcId, 0) * slope[nghbrs[2 * srfcId] * slopeMemory + PV->RHO * nDim + id0]
                    + a_surfaceFactor(srfcId, 1) * slope[nghbrs[2 * srfcId + 1] * slopeMemory + PV->RHO * nDim + id0]));

    //------------------------------------------------------------------------
    // tau_ij:
    // (matrix entries
    // stored in tau[ ? ]:    id0,id1,id2
    //
    // { 0 1 2 }               0   1   2   -> u*tau[0]+v*tau[1]+w*tau[3]
    // { 0 1 2 }               1   2   0   -> u*tau[0]+v*tau[1]+w*tau[2]
    // { 0 1 2 }               2   0   1   -> u*tau[0]+v*tau[1]+w*tau[2]

    if(m_divergenceTreatment) {
      if(a_surfaceCoordinate(srfcId, 1) < 0.0341) {
        tau.p[id0] =
            mue
            * (a_surfaceFactor(srfcId, 0) * (F2 * slope[nghbrs[2 * srfcId] * slopeMemory + id0 * nDim + id0])
               + a_surfaceFactor(srfcId, 1) * (F2 * slope[nghbrs[2 * srfcId + 1] * slopeMemory + id0 * nDim + id0]));

        tau.p[id1] = mue
                     * (a_surfaceFactor(srfcId, 0)
                            * (slope[nghbrs[2 * srfcId] * slopeMemory + id0 * nDim + id1]
                               + slope[nghbrs[2 * srfcId] * slopeMemory + id1 * nDim + id0])
                        + a_surfaceFactor(srfcId, 1)
                              * (slope[nghbrs[2 * srfcId + 1] * slopeMemory + id0 * nDim + id1]
                                 + slope[nghbrs[2 * srfcId + 1] * slopeMemory + id1 * nDim + id0]));

      } else {
        // Compute the stress terms
        tau.p[id0] = mue
                     * (a_surfaceFactor(srfcId, 0)
                            * (F4B3 * slope[nghbrs[2 * srfcId] * slopeMemory + id0 * nDim + id0]
                               - F2B3 * (slope[nghbrs[2 * srfcId] * slopeMemory + id1 * nDim + id1]))
                        + a_surfaceFactor(srfcId, 1)
                              * (F4B3 * slope[nghbrs[2 * srfcId + 1] * slopeMemory + id0 * nDim + id0]
                                 - F2B3 * (slope[nghbrs[2 * srfcId + 1] * slopeMemory + id1 * nDim + id1])));

        tau.p[id1] = mue
                     * (a_surfaceFactor(srfcId, 0)
                            * (slope[nghbrs[2 * srfcId] * slopeMemory + id0 * nDim + id1]
                               + slope[nghbrs[2 * srfcId] * slopeMemory + id1 * nDim + id0])
                        + a_surfaceFactor(srfcId, 1)
                              * (slope[nghbrs[2 * srfcId + 1] * slopeMemory + id0 * nDim + id1]
                                 + slope[nghbrs[2 * srfcId + 1] * slopeMemory + id1 * nDim + id0]));
      }
    } else {
      // Compute the stress terms
      tau.p[id0] = mue
                   * (a_surfaceFactor(srfcId, 0)
                          * (F4B3 * slope[nghbrs[2 * srfcId] * slopeMemory + id0 * nDim + id0]
                             - F2B3 * (slope[nghbrs[2 * srfcId] * slopeMemory + id1 * nDim + id1]))
                      + a_surfaceFactor(srfcId, 1)
                            * (F4B3 * slope[nghbrs[2 * srfcId + 1] * slopeMemory + id0 * nDim + id0]
                               - F2B3 * (slope[nghbrs[2 * srfcId + 1] * slopeMemory + id1 * nDim + id1])));

      tau.p[id1] = mue
                   * (a_surfaceFactor(srfcId, 0)
                          * (slope[nghbrs[2 * srfcId] * slopeMemory + id0 * nDim + id1]
                             + slope[nghbrs[2 * srfcId] * slopeMemory + id1 * nDim + id0])
                      + a_surfaceFactor(srfcId, 1)
                            * (slope[nghbrs[2 * srfcId + 1] * slopeMemory + id0 * nDim + id1]
                               + slope[nghbrs[2 * srfcId + 1] * slopeMemory + id1 * nDim + id0]));
    }
    /*
      if( !(dAOverRe0 <=0) && !(dAOverRe0 >=0) ) {
        cerr << "dAOverRe0" <<  dAOverRe0 << endl;
        saveSolverSolution(1);
        mTerm(1, AT_);
      }
      */

    // Compute the fluxes
    a_surfaceFlux(srfcId, FV->RHO_U) -= dAOverRe0 * tau.p[0];
    a_surfaceFlux(srfcId, FV->RHO_V) -= dAOverRe0 * tau.p[1];
    IF_CONSTEXPR(hasE<SysEqn>)
    a_surfaceFlux(srfcId, FV->RHO_E) -= dAOverRe0 * (u * tau.p[0] + v * tau.p[1] + q);

    // progress variable
    IF_CONSTEXPR(hasPV_C<SysEqn>::value)
    a_surfaceFlux(srfcId, FV->RHO_C) -=
        dAOverRe0 * rhoUDth
        * (a_surfaceFactor(srfcId, 0) * slope[nghbrs[2 * srfcId] * slopeMemory + PV->C * nDim + id0]
           + a_surfaceFactor(srfcId, 1) * slope[nghbrs[2 * srfcId + 1] * slopeMemory + PV->C * nDim + id0]);
  }
}

/** \brief Computes the viscous flux using a central difference scheme, modified version for flame
 * plenum computations
 *
 * \author Stephan Schlimpert
 * \date Februar, 2011
 */
template <MInt nDim_, class SysEqn>
inline void FvCartesianSolverXD<nDim_, SysEqn>::viscousFlux_Gequ_Pv_Plenum() {
  IF_CONSTEXPR(nDim == 3) mTerm(1, "Not available in 3D.");
  TRACE();

  MInt id0, id1, i;
  MInt index0[2] = {1, 0};
  const MInt noPVars = PV->noVariables;
  const MInt noData = m_surfaceVarMemory;
  const MInt noSurfaces = a_noSurfaces();
  const MInt slopeMemory = m_slopeMemory;
  MFloat T, u, v;
  MFloat q, mue, lambda;
  MFloat dAOverRe0;
  const MFloat gammaMinusOne = m_gamma - 1.0;
  const MFloat FgammaMinusOne = F1 / gammaMinusOne;
  const MFloat gFGMO = m_gamma * FgammaMinusOne;
  MFloat Frho, rho, p;
  MFloat rhoUDth;
  MInt* nghbrs = (MInt*)(&(a_surfaceNghbrCellId(0, 0)));
  MFloatScratchSpace tau(nDim, AT_, "tau");
  MFloat* area = &a_surfaceArea(0);
  MFloat* slope = (MFloat*)(&(a_slope(0, 0, 0)));
  MFloat* var = (MFloat*)(&(a_surfaceVariable(0, 0, 0)));
  // --- end of initialization

  // assuming m_TInfinity is the temperature of the unburnt gas
  // Dth = mue^u / ( rho^u *Pr ) = const, rhoU = m_rhoInfinity (density of the unburnt gas)
  rhoUDth = m_DthInfinity * m_rhoFlameTube;

  for(MInt srfcId = 0; srfcId < noSurfaces; srfcId++) {
    // calculate the primitve variables on the surface u,v,rho,p
    // LR
    i = srfcId * noData;
    u = F1B2 * (var[i] + var[i + noPVars]);
    v = F1B2 * (var[i + 1] + var[i + noPVars + 1]);
    rho = F1B2 * (var[i + 2] + var[i + noPVars + 2]);
    Frho = F1 / rho;
    p = F1B2 * (var[i + 3] + var[i + noPVars + 3]);

    // compute the temperature on the surface p = rho * T * 1.0/gamma
    T = sysEqn().temperature_ES(rho, p);

    // indices for the orientation
    id0 = a_surfaceOrientation(srfcId);
    id1 = index0[id0];

    // Compute A / Re0
    dAOverRe0 = area[srfcId] * m_rRe0;

    // calculate the viscosity with the sutherland law mue = T^3/2 * (1+S/T_0)(T + S/T_0)
    mue = SUTHERLANDLAW(T);
    // calculate the thermal conductivity
    lambda = m_rPr * mue;

    // calculate the heat flux (T_x = gamma*(p_x/rho - p/rho^2 * rho_x))
    q = lambda * gFGMO * Frho
        * ((a_surfaceFactor(srfcId, 0) * slope[nghbrs[2 * srfcId] * slopeMemory + PV->P * nDim + id0]
            + a_surfaceFactor(srfcId, 1) * slope[nghbrs[2 * srfcId + 1] * slopeMemory + PV->P * nDim + id0])
           - p * Frho
                 * (a_surfaceFactor(srfcId, 0) * slope[nghbrs[2 * srfcId] * slopeMemory + PV->RHO * nDim + id0]
                    + a_surfaceFactor(srfcId, 1) * slope[nghbrs[2 * srfcId + 1] * slopeMemory + PV->RHO * nDim + id0]));

    //------------------------------------------------------------------------
    // tau_ij:
    // (matrix entries
    // stored in tau[ ? ]:    id0,id1,id2
    //
    // { 0 1 2 }               0   1   2   -> u*tau[0]+v*tau[1]+w*tau[3]
    // { 0 1 2 }               1   2   0   -> u*tau[0]+v*tau[1]+w*tau[2]
    // { 0 1 2 }               2   0   1   -> u*tau[0]+v*tau[1]+w*tau[2]

    // Compute the stress terms
    tau.p[id0] = mue
                 * (a_surfaceFactor(srfcId, 0)
                        * (F4B3 * slope[nghbrs[2 * srfcId] * slopeMemory + id0 * nDim + id0]
                           - F2B3 * (slope[nghbrs[2 * srfcId] * slopeMemory + id1 * nDim + id1]))
                    + a_surfaceFactor(srfcId, 1)
                          * (F4B3 * slope[nghbrs[2 * srfcId + 1] * slopeMemory + id0 * nDim + id0]
                             - F2B3 * (slope[nghbrs[2 * srfcId + 1] * slopeMemory + id1 * nDim + id1])));

    tau.p[id1] = mue
                 * (a_surfaceFactor(srfcId, 0)
                        * (slope[nghbrs[2 * srfcId] * slopeMemory + id0 * nDim + id1]
                           + slope[nghbrs[2 * srfcId] * slopeMemory + id1 * nDim + id0])
                    + a_surfaceFactor(srfcId, 1)
                          * (slope[nghbrs[2 * srfcId + 1] * slopeMemory + id0 * nDim + id1]
                             + slope[nghbrs[2 * srfcId + 1] * slopeMemory + id1 * nDim + id0]));

    // Compute the fluxes
    a_surfaceFlux(srfcId, FV->RHO_U) -= dAOverRe0 * tau.p[0];
    a_surfaceFlux(srfcId, FV->RHO_V) -= dAOverRe0 * tau.p[1];
    IF_CONSTEXPR(hasE<SysEqn>)
    a_surfaceFlux(srfcId, FV->RHO_E) -= dAOverRe0 * (u * tau.p[0] + v * tau.p[1] + q);

    // progress variable
    IF_CONSTEXPR(hasPV_C<SysEqn>::value)
    a_surfaceFlux(srfcId, FV->RHO_C) -=
        dAOverRe0 * rhoUDth
        * (a_surfaceFactor(srfcId, 0) * slope[nghbrs[2 * srfcId] * slopeMemory + PV->C * nDim + id0]
           + a_surfaceFactor(srfcId, 1) * slope[nghbrs[2 * srfcId + 1] * slopeMemory + PV->C * nDim + id0]);
  }
}

// ------------------------------------------------------------------------------------------

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::filterConservativeVariablesAtFineToCoarseGridInterfaces() {
  TRACE();

  IF_CONSTEXPR(nDim == 3) mTerm(-1, "Info: untested in 3D. By now only used in 2D.");

  // filter the conservative variables
  // MBool coarseInterface0,coarseInterface1,coarseInterface2,coarseInterface3;
  // MBool fineOrNoInterface0,fineOrNoInterface1,fineOrNoInterface2,fineOrNoInterface3;
  // MBool filter0,filter1;
  //---

  // remove the u component
  if(m_force1DFiltering) {
    for(MInt id = 0; id < m_noActiveCells; id++) {
      const MInt cellId = m_activeCellIds[id];
      a_variable(cellId, 0) = F0;
    }
  }

  // new
  for(MInt id = 0; id < m_noActiveCells; id++) {
    const MInt cellId = m_activeCellIds[id];
    // select parents
    if(c_noChildren(cellId) == 0) {
      continue;
    }
    MBool grandparent = false;
    for(MInt ch = 0; ch < IPOW2(nDim); ch++) {
      if(c_childId(cellId, ch) == -1) {
        continue;
      }
      if(c_noChildren(c_childId(cellId, ch)) > 0) {
        grandparent = true;
        break;
      }
    }
    if(grandparent) {
      continue;
    }
    // filter
    for(MInt varId = 0; varId < CV->noVariables; varId++) {
      a_variable(cellId, varId) = F0;
    }
    for(MInt ch = 0; ch < IPOW2(nDim); ch++) {
      if(c_childId(cellId, ch) == -1) {
        continue;
      }
      for(MInt varId = 0; varId < CV->noVariables; varId++) {
        a_variable(cellId, varId) += a_variable(c_childId(cellId, ch), varId);
      }
    }
    for(MInt varId = 0; varId < CV->noVariables; varId++) {
      a_variable(cellId, varId) /= (MFloat)c_noChildren(cellId);
    }
    // copy the filtered variables to the child cells
    for(MInt ch = 0; ch < IPOW2(nDim); ch++) {
      if(c_childId(cellId, ch) == -1) {
        continue;
      }
      for(MInt varId = 0; varId < CV->noVariables; varId++) {
        a_variable(c_childId(cellId, ch), varId) =
            F1B2 * (a_variable(c_childId(cellId, ch), varId) + a_variable(cellId, varId));
      }
    }
  }

  /*

  // copy all CV to &a_pvariable(0,0)for( MInt id = 0; id < m_noActiveCells; id++ ) {
    cellId = m_activeCellIds[ id ];
    for( MInt var=0; var<CV->noVariables; var++ ) {
 a_pvariable( cellId ,  var ) = a_variable( cellId ,  var );
    }
  }

  for( MInt id = 0; id < m_noActiveCells; id++ ) {
    cellId = m_activeCellIds[ id ];
    filter0 = false;
    filter1 = false;
    // check if coarser or finer grid in the -x-direction
    coarseInterface0 = false;
    fineOrNoInterface0 = false;
    if( a_hasNeighbor( cellId ,  0 ) == 0 ) {
      if( c_parentId( cellId ) > -1 ) {
  if( a_hasNeighbor( c_parentId( cellId ) ,  0 ) > 0 )
    coarseInterface0 = true;
  else
    fineOrNoInterface0 = true;
      } else
  fineOrNoInterface0 = true;
    } else {
      if( c_noChildren( c_neighborId( cellId ,  0 ) ) > 0 )
  fineOrNoInterface0 = true;
    }
    // check if coarser or finer grid in the +x-direction
    coarseInterface1 = false;
    fineOrNoInterface1 = false;
    if( a_hasNeighbor( cellId ,  1 ) == 0 ) {
      if( c_parentId( cellId ) > -1 ) {
  if( a_hasNeighbor( c_parentId( cellId ) ,  1 ) > 0 )
    coarseInterface1 = true;
  else
    fineOrNoInterface1 = true;
      } else
  fineOrNoInterface1 = true;
    } else {
      if( c_noChildren( c_neighborId( cellId ,  1 ) ) > 0 )
  fineOrNoInterface1 = true;
    }
    // check if coarser or finer grid in the -y-direction
    coarseInterface2 = false;
    fineOrNoInterface2 = false;
    if( a_hasNeighbor( cellId ,  2 ) == 0 ) {
      if( c_parentId( cellId ) > -1 ) {
  if( a_hasNeighbor( c_parentId( cellId ) ,  2 ) > 0 )
    coarseInterface2 = true;
  else
    fineOrNoInterface2 = true;
      } else
  fineOrNoInterface2 = true;
    } else {
      if( c_noChildren( c_neighborId( cellId ,  2 ) ) > 0 )
  fineOrNoInterface2 = true;
    }
    // check if coarser or finer grid in the +y-direction
    coarseInterface3 = false;
    fineOrNoInterface3 = false;
    if( a_hasNeighbor( cellId ,  3 ) == 0 ) {
      if( c_parentId( cellId ) > -1 ) {
  if( a_hasNeighbor( c_parentId( cellId ) ,  3 ) > 0 )
    coarseInterface3 = true;
  else
    fineOrNoInterface3 = true;
      } else
  fineOrNoInterface3 = true;
    } else {
      if( c_noChildren( c_neighborId( cellId ,  3 ) ) > 0 )
  fineOrNoInterface3 = true;
    }

    if( !fineOrNoInterface0 && !fineOrNoInterface1 && !fineOrNoInterface2 && !fineOrNoInterface3 ) {
      if( ( coarseInterface0 || coarseInterface1 ) &&
    !( coarseInterface2 || coarseInterface3 ) )
  filter1 = true;
      if( !( coarseInterface0 || coarseInterface1 ) &&
    ( coarseInterface2 || coarseInterface3 ) )
  filter0 = true;
  }

    if( filter0 ) {
      for( MInt var=0; var<CV->noVariables; var++ ) {
  a_variable( cellId ,  var ) *= F1B2;
  a_variable( cellId ,  var ) += F1B4 *
    (a_pvariable( c_neighborId( cellId ,  0 ) ,  var ) +
  a_pvariable( c_neighborId( cellId ,  1 ) ,  var ) );
      }
    } else {
      if( filter1 ) {
  for( MInt var=0; var<CV->noVariables; var++ ) {
    a_variable( cellId ,  var ) *= F1B2;
    a_variable( cellId ,  var ) += F1B4 *
      (a_pvariable( c_neighborId( cellId ,  2 ) ,  var ) +
  a_pvariable( c_neighborId( cellId ,  3 ) ,  var ) );
  }
      }
    }
  }
*/
}


/** \brief Initializes the solver
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initSolutionStep(MInt mode) {
  TRACE();

  // only relevant for fvmb!
  std::ignore = mode;

  // init property IsInvalid - cell is invalid (MGC)
  // init property IsPeriodicWithRot - periodic cell (azimuthal periodicity concept)
  // will be set false during initSolutionStep if necessary
  // cannot be done in setCellProperties as that routine is called more than once
  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    a_hasProperty(cellId, SolverCell::IsInvalid) = false;
    a_hasProperty(cellId, SolverCell::IsPeriodicWithRot) = false;
  }

  grid().updateGridInfo();

  setCellProperties();

  // NOTE: this is/can be a major time consumer during init/DLB
  generateBndryCells();

  IF_CONSTEXPR(nDim == 3) {
    if(m_fvBndryCnd->m_multipleGhostCells) {
      // shiftHaloAndSplitCells(); //commented out since otherwise split cells are written out as
      // regular cells, while no mechanisms exists to detect these cells upon restart. Thus multiple
      // cells at the same location will appear, each of which will then be split again into new
      // cells, and so forth... Also domainOffsets needs to be updated correspondingly. (Lennart)
    }

    // deactivates wrong cells when periodic bc is used (azimuthal periodicity concept)
    if(m_periodicCells == 0) {
      checkCells();
    }
  }

  // shift cell center of boundary cells
  m_fvBndryCnd->correctCellCoordinates();

  // MULTILEVEL
  // correct (xyz)cc and body surfaces of coarse boundary cells
  // requires that small and master cells are not yet merged!
  // for MGC formulation, this does not provide the correct result!
  // do not use multilevel with MGC formulation
  m_fvBndryCnd->correctCoarseBndryCells();

  IF_CONSTEXPR(nDim == 3) {
    // identifies cells to copy PV from (using kd tree, azimuthal periodicity concept)
    // m_periodicCells=1 --> azimuthal periodicity (with LS interpolation)
    // m_periodicCells=2 --> special case: periodicity in x-direction (without LS interpolation)
    // m_periodicCells=3 --> special case: periodicity in x-direction (without LS interpolation +
    // volume forcing)
    if(m_periodicCells == 1 || m_periodicCells == 2 || m_periodicCells == 3) identPeriodicCells();

    // set the neighbor arrays storeNghbrIds, identNghbrIds
    if(m_fvBndryCnd->m_multipleGhostCells) findNghbrIdsMGC();
  }

  if(m_fvBndryCnd->m_cellMerging) {
    // detects small cells and identifies a master cell for each
    // merges master and small cell(s)
    IF_CONSTEXPR(nDim == 2) {
      m_fvBndryCnd->detectSmallBndryCells();
      m_log << "Connecting master and slave cells...";
      m_fvBndryCnd->mergeCells();
    }
    else IF_CONSTEXPR(nDim == 3) {
      if(m_fvBndryCnd->m_multipleGhostCells)
        m_fvBndryCnd->detectSmallBndryCellsMGC();
      else
        m_fvBndryCnd->detectSmallBndryCells();
      m_log << "Connecting master and slave cells...";

      if(m_fvBndryCnd->m_multipleGhostCells)
        m_fvBndryCnd->mergeCellsMGC();
      else
        m_fvBndryCnd->mergeCells();
    }
    m_log << " found " << m_fvBndryCnd->m_smallBndryCells->size() << "small cells." << endl;
  } else {
    // flux-redistribution method
    m_fvBndryCnd->setBCTypes();
    computeCellVolumes();
    m_fvBndryCnd->setNearBoundaryRecNghbrs();
    m_fvBndryCnd->computeImagePointRecConst();
    if(m_fvBndryCnd->m_smallCellRHSCorrection) {
      m_fvBndryCnd->initSmallCellRHSCorrection();
    } else {
      m_fvBndryCnd->initSmallCellCorrection();
    }
  }

  // write out centerline data
  if(m_writeOutData) {
    cerr << "Writing out center line and boundary data" << endl;
    applyInitialCondition();
    writeCenterLineVel();
    mTerm(0, AT_);
  }

  // set the neighbor arrays storeNghbrIds, identNghbrIds
  IF_CONSTEXPR(nDim == 2) { findNghbrIds(); }
  else IF_CONSTEXPR(nDim == 3) {
    if(!m_fvBndryCnd->m_multipleGhostCells) findNghbrIds();
  }

  m_log << "Creating surfaces...";
  // create surfaces
  m_bndryCellSurfacesOffset = a_noSurfaces();
  IF_CONSTEXPR(nDim == 2) {
    checkForSrfcsMGC(); // small cell must already be extracted
  }
  else IF_CONSTEXPR(nDim == 3) {
    if(m_fvBndryCnd->m_multipleGhostCells)
      checkForSrfcsMGC_2(); // small cell must already be extracted
    else
      checkForSrfcsMGC();
  }

  // correct all surfaces which were built between two boundary cells
  m_fvBndryCnd->correctMasterSlaveSurfaces();
  m_log << "ok" << endl;


  // adds one ghost cell for each boundary cell
  m_log << "Creating ghost cells...";
  m_bndryGhostCellsOffset = a_noCells();
  IF_CONSTEXPR(nDim == 2) { m_fvBndryCnd->computeGhostCells(); }
  else IF_CONSTEXPR(nDim == 3) {
    if(m_fvBndryCnd->m_multipleGhostCells)
      m_fvBndryCnd->computeGhostCellsMGC();
    else
      m_fvBndryCnd->computeGhostCells();
  }
  m_log << "ok" << endl;

  // update the cell properties
  setCellProperties();

  IF_CONSTEXPR(nDim == 2) {
    m_log << "Setting the neighbor arrays...";
    // set the neighbor arrays storeNghbrIds, identNghbrIds
    findNghbrIds();
    m_log << "ok" << endl;
  }
  else IF_CONSTEXPR(nDim == 3) {
    if(!m_fvBndryCnd->m_multipleGhostCells) {
      m_log << "Setting the neighbor arrays...";
      // set the neighbor arrays storeNghbrIds, identNghbrIds
      findNghbrIds();
      m_log << "ok" << endl;
    }
  }

  // creates boundary surfaces
  // requires ghost and small cells
  m_log << "Adding body surfaces...";
  m_bndrySurfacesOffset = a_noSurfaces();
  IF_CONSTEXPR(nDim == 2) { m_fvBndryCnd->addBoundarySurfaces(); }
  else IF_CONSTEXPR(nDim == 3) {
    if(m_fvBndryCnd->m_multipleGhostCells) {
      m_fvBndryCnd->addBoundarySurfacesMGC();
    } else {
      m_fvBndryCnd->addBoundarySurfaces();
      // adds a correction part the boundary surface on interface boundary cells
      correctBoundarySurfaces();
      m_fvBndryCnd->addBoundarySurfaces();
    }
  }

  m_log << "ok" << endl;
  m_log << " *** All surfaces created" << endl;

  m_log << "Tagging cells needed for the surface flux computation...";
  tagCellsNeededForSurfaceFlux();
  m_log << "ok" << endl;

  // second part of the initialisation of the manual limiter
  if(string2enum(m_surfaceValueReconstruction) == HOCD_LIMITED_SLOPES_MAN) initComputeSurfaceValuesLimitedSlopesMan2();

  m_log << "Fill nghbrInterface...";
  setNghbrInterface();
  m_log << "ok" << endl;

  m_log << "Filling cell surface mapping...";
  cellSurfaceMapping();
  m_log << "ok" << endl;

  m_log << "Setting upwind coefficient...";
  setUpwindCoefficient();
  m_log << "ok" << endl;


  m_log << "Computing plane vectors...";
  m_fvBndryCnd->computePlaneVectors();
  m_log << "ok" << endl;


  m_log << "Initializing the least-squares reconstruction...";
  // builds the least-squares stencil and computes the LS constants
  // MGC stencil works bad for refined grids. More research necessary!
  buildLeastSquaresStencilSimple();
  m_log << "ok" << endl;


  m_log << "Initializing the viscous flux computation...";
  initViscousFluxComputation();
  m_log << "ok" << endl;

  if(grid().azimuthalPeriodicity()) {
    initAzimuthalReconstruction();
    computeAzimuthalReconstructionConstants();
  }

  m_log << "Initializing boundary conditions...";
  // initialize the reconstruction scheme for the boundary and ghost cells
  m_fvBndryCnd->initBndryCnds();

  initCutOffBoundaryCondition();

  IF_CONSTEXPR(nDim == 3) {
    if(m_fvBndryCnd->m_multipleGhostCells) m_fvBndryCnd->computeReconstructionConstants_interpolation();
  }
  m_log << "ok" << endl;

  m_log << "Computing reconstruction constants...";
  // Computes the reconstruction constants for each cell
  if(m_fvBndryCnd->m_cellMerging)
    computeReconstructionConstants();
  else
    computeReconstructionConstantsSVD();
  m_log << "ok" << std::endl;

  IF_CONSTEXPR(nDim == 3) {
    // computes reconstruction constants for LS reconstruction (azimuthal periodicity concept)
    if(m_periodicCells == 1) computeRecConstPeriodic();
  }

  if(m_checkCellSurfaces) checkCellSurfaces();

  // compute dx between surfaces and their neighbor cells
  computeCellSurfaceDistanceVectors();


  // multigrid: set all taus to zero
  // deleteTau();


  // compute all volumes of the cells inside the integration domain
  computeCellVolumes();

  // Add cut-cell information to grid file if enabled in properties
  if(m_writeCutCellsToGridFile) {
    m_log << "Writing cut cells to grid file...";
    m_fvBndryCnd->recorrectCellCoordinates();
    writeCutCellsToGridFile();
    m_fvBndryCnd->rerecorrectCellCoordinates();
    m_log << "ok" << endl;
  }

  // count internal master cells
  MInt countFMC = 0;
  MInt smallCell;
  for(MInt smallId = 0; smallId < m_fvBndryCnd->m_smallBndryCells->size(); smallId++) {
    smallCell = m_fvBndryCnd->m_smallBndryCells->a[smallId];
    if(a_bndryId(m_fvBndryCnd->m_bndryCells->a[smallCell].m_linkedCellId) == -1) {
      countFMC++;
    }
  }
  MLong smallCells = m_fvBndryCnd->m_smallBndryCells->size();
  MPI_Allreduce(MPI_IN_PLACE, &smallCells, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "smallCells");

  checkGhostCellIntegrity();

  // @felix cellMaterialNo needs to be updated in size to be equal to the total number of cells
  // including all bndry/ghost/... cells, else this the code will access the memory after the
  // currently allocated array, which will lead to segmentation faults in certain cases (i.e. due to
  // values of some other allocated variable
  // !=0 in memory) / ansgar
  IF_CONSTEXPR(nDim == 3) { updateMaterialNo(); }

  // Reset interpolation data structures used for sampling data
  m_cellInterpolationIndex.resize(a_noCells());
  std::fill(m_cellInterpolationIndex.begin(), m_cellInterpolationIndex.end(), -1);
  m_cellInterpolationMatrix.clear();
  m_cellInterpolationIds.clear();

  if(m_wmLES) {
    if(m_restart) {
      restartWMSurfaces();
    }
    initWMExchange();
    exchangeWMVars();

    if(m_wmSurfaceProbeInterval > 0) {
      initWMSurfaceProbes();
    }
  }

  if(m_saSrfcProbeInterval > 0) {
    initSpanAvgSrfcProbes();
  }

  if(m_wallNormalOutput && m_normalOutputInterval) {
    computeWallNormalPointCoords();
    findWallNormalCellIds();
  }

  if(m_useSandpaperTrip) {
    initSandpaperTrip();
  }

  if(m_useChannelForce) {
    initChannelForce();
  }
  if(m_isEEGas) {
    // Set implicit coefficient to zero
    resetImplicitCoefficients();
  }

  //  if ( m_restart ) m_restart = false;

  m_log << "_________________________________________________________________" << endl << endl;
  m_log << "Grid summary at time step " << globalTimeStep << endl;
  m_log << "_________________________________________________________________" << endl << endl;
  m_log << setfill(' ');
  m_log << "number of cells                 " << setw(7) << a_noCells() << endl;
  m_log << "number of surfaces              " << setw(7) << a_noSurfaces() << endl;
  m_log << "total number of small cells on all process " << setw(7) << smallCells << endl;
  m_log << "number of internal master cells " << setw(7) << countFMC << endl;
  m_log << "minimum grid level              " << setw(7) << minLevel() << endl;
  m_log << "maximum grid level              " << setw(7) << maxLevel() << endl << endl;
  m_log << "level | total no cells | no of leaf cells | ghost cells | bndry cells" << endl;
  for(MInt level = maxLevel(); level >= minLevel(); level--) {
    MInt total = 0;
    MInt leaf = 0;
    MInt ghost = 0;
    MInt bnd = 0;
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      if(a_isBndryGhostCell(cellId)) {
        if(a_level(cellId) == level) {
          total++;
          leaf++;
          ghost++;
        }
      } else if(a_level(cellId) == level) {
        total++;
        if(a_hasProperty(cellId, SolverCell::IsSplitClone)) continue;
        if(c_isLeafCell(cellId)) {
          leaf++;
        }
        if(a_bndryId(cellId) > -1) {
          bnd++;
        }
      }
    }
    m_log << setfill(' ');
    m_log << setw(3) << level << "  " << setw(12) << total << "  " << setw(16) << leaf << "  " << setw(14) << ghost
          << "  " << setw(14) << bnd << endl;
  }

  // check domain boundaries
  MFloat maxC[] = {-10000.0, -10000.0, -10000.0};
  MFloat minC[] = {10000.0, 10000.0, 10000.0};
  for(MInt c = 0; c < noInternalCells(); c++) {
    if(!a_hasProperty(c, SolverCell::IsOnCurrentMGLevel)) {
      continue;
    }
    if(a_isHalo(c)) {
      continue;
    }
    if(a_isPeriodic(c)) {
      continue;
    }
    const MFloat cellLength = c_cellLengthAtCell(c);
    for(MInt i = 0; i < nDim; i++) {
      maxC[i] = mMax(maxC[i], a_coordinate(c, i) + F1B2 * cellLength);
      minC[i] = mMin(minC[i], a_coordinate(c, i) - F1B2 * cellLength);
    }
  }
  m_log << "_________________________________________________________________" << endl << endl;

  m_log << "Physical domain boundaries: " << endl;
  m_log << "min (x,y" << (nDim == 3 ? ",z): (" : "): (") << minC[0] << "," << minC[1];
  IF_CONSTEXPR(nDim == 3) m_log << "," << minC[2];
  m_log << ")" << endl;
  m_log << "max (x,y" << (nDim == 3 ? ",z): (" : "): (") << maxC[0] << "," << maxC[1];
  IF_CONSTEXPR(nDim == 3) m_log << "," << maxC[2];
  m_log << ")" << endl;

  m_log << "_________________________________________________________________" << endl << endl;

  m_log << "Process " << domainId() << " finished initialization" << endl;

  /*
  if( globalTimeStep == m_restartTimeStep ) {
    // patch for restart from explicit solution
    for( MInt cellId = 0 ; cellId < a_noCells(); cellId++ ) {
      for( MInt varId = 0; varId < CV->noVariables; varId ++ ) {
  a_dt1Variable( cellId ,  varId ) =
    a_variable( cellId ,  varId );
  a_dt2Variable( cellId ,  varId ) =
    a_variable( cellId ,  varId );
      }
    }
  }
  */
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initSandpaperTrip() {
  TRACE();

  m_log << "Initializing Sandpaper Trip... ";

  IF_CONSTEXPR(nDim == 2) {
    cerr << "Tripping not implemented for 2D" << endl;
    return;
  }

  IF_CONSTEXPR(nDim == 3) {
    m_tripAirfoil = false;

    if(Context::propertyExists("tripAirfoil", m_solverId)) {
      m_tripAirfoil = Context::getSolverProperty<MBool>("tripAirfoil", m_solverId, AT_, &m_tripAirfoil);
    }

    m_tripNoTrips = Context::propertyLength("tripDelta1", m_solverId);

    mAlloc(m_tripDelta1, m_tripNoTrips, "m_tripDelta1", 1.0, AT_);
    mAlloc(m_tripXOrigin, m_tripNoTrips, "m_tripXOrigin", 0.0, AT_);
    mAlloc(m_tripXLength, m_tripNoTrips, "m_tripXLength", 4.0, AT_);
    mAlloc(m_tripYOrigin, m_tripNoTrips, "m_tripYOrigin", 0.0, AT_);
    mAlloc(m_tripYHeight, m_tripNoTrips, "m_tripYHeight", 1.0, AT_);
    mAlloc(m_tripCutoffZ, m_tripNoTrips, "m_tripCutoffZ", 1.7, AT_);
    mAlloc(m_tripMaxAmpSteady, m_tripNoTrips, "m_tripMaxAmpSteady", 0.0, AT_);
    mAlloc(m_tripMaxAmpFluc, m_tripNoTrips, "m_tripMaxAmpFluc", 0.005, AT_);
    mAlloc(m_tripDeltaTime, m_tripNoTrips, "m_tripDeltaTime", 4.0, AT_);
    mAlloc(m_tripTimeStep, m_tripNoTrips, "m_tripTimeStep", 0, AT_);
    mAlloc(m_tripNoCells, m_tripNoTrips, "m_tripNoCells", 0, AT_);
    mAlloc(m_tripCellOffset, m_tripNoTrips, "m_tripCellOffset", 0, AT_);

    for(MInt i = 0; i < m_tripNoTrips; i++) {
      m_tripDelta1[i] = Context::getSolverProperty<MFloat>("tripDelta1", m_solverId, AT_, &m_tripDelta1[i], i);

      if(!m_tripAirfoil) {
        m_tripXOrigin[i] = Context::getSolverProperty<MFloat>("tripXOrigin", m_solverId, AT_, &m_tripXOrigin[i], i);
        if(Context::propertyExists("tripYOrigin", m_solverId)) {
          m_tripYOrigin[i] = Context::getSolverProperty<MFloat>("tripYOrigin", m_solverId, AT_, &m_tripYOrigin[i], i);
        }
      }

      MFloat tripX = 4.0;
      if(Context::propertyExists("tripXLength", m_solverId)) {
        tripX = Context::getSolverProperty<MFloat>("tripXLength", m_solverId, AT_, &tripX);
      }
      m_tripXLength[i] = m_tripDelta1[i] * tripX;


      MFloat tripY = 1.0;
      if(Context::propertyExists("tripYHeight", m_solverId)) {
        tripY = Context::getSolverProperty<MFloat>("tripYHeight", m_solverId, AT_, &tripY);
      }
      m_tripYHeight[i] = m_tripDelta1[i] * tripY;

      MFloat tripZ = 1.7;
      if(Context::propertyExists("tripCutoffZ", m_solverId)) {
        tripZ = Context::getSolverProperty<MFloat>("tripCutoffZ", m_solverId, AT_, &tripZ);
      }
      m_tripCutoffZ[i] = m_tripDelta1[i] * tripZ;

      m_tripMaxAmpSteady[i] =
          Context::getSolverProperty<MFloat>("tripMaxAmpSteady", m_solverId, AT_, &m_tripMaxAmpSteady[i], i);

      m_tripMaxAmpFluc[i] =
          Context::getSolverProperty<MFloat>("tripMaxAmpFluc", m_solverId, AT_, &m_tripMaxAmpFluc[i], i);

      m_tripNoModes = 100;

      MFloat timeCutoff = 4.0;
      if(Context::propertyExists("tripDeltaTime", m_solverId)) {
        timeCutoff = Context::getSolverProperty<MFloat>("tripDeltaTime", m_solverId, AT_, &timeCutoff);
      }
      m_tripDeltaTime[i] = timeCutoff * m_tripDelta1[i] / m_UInfinity;
      m_tripTimeStep[i] = (MInt)(m_time / m_tripDeltaTime[i]);
    }

    if(Context::propertyExists("RNGSeed") || Context::propertyExists("seedRNGWithTime"))
      mTerm(1, "Properties RNGSeed or seedRNGWithTime not compatible with SandpaperTrip!");
    m_tripSeed = 70;
    srand(m_tripSeed);
    m_tripDomainWidth = 0.0;

    m_tripUseRestart = false;
    if(Context::propertyExists("tripUseRestart", m_solverId)) {
      m_tripUseRestart = Context::getSolverProperty<MBool>("tripUseRestart", m_solverId, AT_, &m_tripUseRestart);
    }

    if(m_tripAirfoil) {
      mAlloc(m_tripAirfoilBndryId, m_tripNoTrips, "m_tripAirfoilBndryId", 0, AT_);
      mAlloc(m_tripAirfoilSide, m_tripNoTrips, "m_tripAirfoilSide", 0, AT_);
      mAlloc(m_tripAirfoilChordPos, m_tripNoTrips, "m_tripAirfoilChordPos", 0.0, AT_);
      mAlloc(m_tripAirfoilNosePos, nDim, "m_tripAirfoilNoisePos", 0.0, AT_);
      mAlloc(m_tripAirfoilForceDir, nDim * m_tripNoTrips, "m_tripAirfoilForceDir", 0.0, AT_);

      m_tripAirfoilChordLength =
          Context::getSolverProperty<MFloat>("tripAirfoilChordLength", m_solverId, AT_, &m_tripAirfoilChordLength);
      m_tripAirfoilAOA = Context::getSolverProperty<MFloat>("tripAirfoilAOA", m_solverId, AT_, &m_tripAirfoilAOA);
      for(MInt dim = 0; dim < nDim; dim++) {
        m_tripAirfoilNosePos[dim] =
            Context::getSolverProperty<MFloat>("tripAirfoilNosePos", m_solverId, AT_, &m_tripAirfoilNosePos[dim], dim);
      }
      for(MInt i = 0; i < m_tripNoTrips; i++) {
        m_tripAirfoilBndryId[i] =
            Context::getSolverProperty<MInt>("tripAirfoilBndryId", m_solverId, AT_, &m_tripAirfoilBndryId[i], i);
        m_tripAirfoilSide[i] =
            Context::getSolverProperty<MInt>("tripAirfoilSide", m_solverId, AT_, &m_tripAirfoilSide[i], i);
        m_tripAirfoilChordPos[i] =
            Context::getSolverProperty<MFloat>("tripAirfoilChordPos", m_solverId, AT_, &m_tripAirfoilChordPos[i], i);
        if(m_tripAirfoilChordPos[i] < 0.0 || m_tripAirfoilChordPos[i] > 1.0)
          mTerm(-1, "tripAirfoilChordPos not within the allowed range of 0.0 to 1.0");
      }
    }

    // find cells that belong to the trip zone
    for(MInt i = 0; i < m_tripNoTrips; i++) {
      if(m_tripAirfoil) {
        // finds the center of the tripping region on the airfoil surface with respect to a specified chord position and
        // angle of attack get x-position within the domain find bndryCells with minimum distance to the x-position to
        // define the x-y center of the tripping region
        MInt avgWeight = 0;
        for(MInt bCellId = 0; bCellId < m_fvBndryCnd->m_bndryCells->size(); bCellId++) {
          MInt bc = m_tripAirfoilBndryId[i];
          MInt cellId = m_fvBndryCnd->m_bndryCells->a[bCellId].m_cellId;
          MFloat eta = (a_coordinate(cellId, 0) - m_tripAirfoilNosePos[0]) * cos(m_tripAirfoilAOA * PI / 180.0)
                       - (a_coordinate(cellId, 1) - m_tripAirfoilNosePos[1]) * sin(m_tripAirfoilAOA * PI / 180.0);
          MFloat zeta = (a_coordinate(cellId, 0) - m_tripAirfoilNosePos[0]) * sin(m_tripAirfoilAOA * PI / 180.0)
                        + (a_coordinate(cellId, 1) - m_tripAirfoilNosePos[1]) * cos(m_tripAirfoilAOA * PI / 180.0);
          MFloat dEta = abs(eta - (m_tripAirfoilChordPos[i] * m_tripAirfoilChordLength));
          if(dEta <= 0.5 * c_cellLengthAtLevel(maxRefinementLevel())) {
            if((m_tripAirfoilSide[i] > 0 && zeta > 0.0) || (m_tripAirfoilSide[i] < 0 && zeta < 0.0)) {
              for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[bCellId].m_noSrfcs; srfc++) {
                // find the normal vector of the surface to determine the force direction
                // this is ambiguous if the cell has multiple surfaces with the same bc, I dont have a better solution
                // yet
                if(m_fvBndryCnd->m_bndryCells->a[bCellId].m_srfcs[srfc]->m_bndryCndId == bc) {
                  for(MInt dim = 0; dim < nDim; dim++) {
                    m_tripAirfoilForceDir[i * nDim + dim] =
                        m_fvBndryCnd->m_bndryCells->a[bCellId].m_srfcs[srfc]->m_normalVector[dim];
                    m_tripXOrigin[i] = m_fvBndryCnd->m_bndryCells->a[bCellId].m_srfcs[srfc]->m_coordinates[0];
                    m_tripYOrigin[i] = m_fvBndryCnd->m_bndryCells->a[bCellId].m_srfcs[srfc]->m_coordinates[1];
                  }
                  avgWeight = 1;
                  break;
                }
              }
              break;
            }
          }
        }
        // weights are summed to avoid incorporating domains which do not contain any tripping cells into the averaging
        MPI_Allreduce(&avgWeight, &avgWeight, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "avgWeight", "avgWeight");
        MPI_Allreduce(&m_tripXOrigin[i], &m_tripXOrigin[i], 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "m_tripXOrigin",
                      "m_tripXOrigin");
        MPI_Allreduce(&m_tripYOrigin[i], &m_tripYOrigin[i], 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "m_tripYOrigin",
                      "m_tripYOrigin");
        for(MInt dim = 0; dim < nDim; dim++) {
          MPI_Allreduce(&m_tripAirfoilForceDir[i * nDim + dim], &m_tripAirfoilForceDir[i * nDim + dim], 1, MPI_DOUBLE,
                        MPI_SUM, mpiComm(), AT_, "m_tripAirfoilForceDir", "m_tripAirfoilForceDir");
          m_tripAirfoilForceDir[i * nDim + dim] /= avgWeight;
        }
        m_tripXOrigin[i] /= avgWeight;
        m_tripYOrigin[i] /= avgWeight;

        if(avgWeight > 0) {
          for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
            MFloat maxR2 = POW2(2 * m_tripXLength[i]) + POW2(2 * m_tripYHeight[i]);
            MFloat cellR2 =
                POW2(a_coordinate(cellId, 0) - m_tripXOrigin[i]) + POW2(a_coordinate(cellId, 1) - m_tripYOrigin[i]);
            if(cellR2 < maxR2) {
              m_tripCellIds.push_back(cellId);
              m_tripCoords.push_back(a_coordinate(cellId, 2));
              a_isSandpaperTripCell(cellId) = true;
            }
          }
        }
        m_tripNoCells[i] = m_tripCellIds.size() - m_tripCellOffset[i];
      } else {
        if(i > 0) {
          m_tripCellOffset[i] = m_tripCellOffset[i - 1] + m_tripNoCells[i - 1];
        }
        // all cellIds in the tripping zone will be collected in m_tripCellIds
        for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
          MFloat maxR2 = POW2(2 * m_tripXLength[i]) + POW2(2 * m_tripYHeight[i]);
          MFloat cellR2 =
              POW2(a_coordinate(cellId, 0) - m_tripXOrigin[i]) + POW2(a_coordinate(cellId, 1) - m_tripYOrigin[i]);
          if(cellR2 < maxR2) {
            m_tripCellIds.push_back(cellId);
            m_tripCoords.push_back(a_coordinate(cellId, 2));
            a_isSandpaperTripCell(cellId) = true;
          }
        }
        m_tripNoCells[i] = m_tripCellIds.size() - m_tripCellOffset[i];
      }
    }
    MInt tripTotalNoCells = m_tripCellIds.size();

    MFloat bbox[6];
    geometry().getBoundingBox(&bbox[0]);
    m_tripDomainWidth = bbox[5] - bbox[2];

    m_log << "=================================================" << endl
          << "           SANDPAPER TRIP PROPERTIES             " << endl
          << "=================================================" << endl;
    for(MInt i = 0; i < m_tripNoTrips; ++i) {
      m_log << "######### TRIP NUMBER " << i << " ###########" << endl
            << "tripXOrigin: " << m_tripXOrigin[i] << endl
            << "tripXLength: " << m_tripXLength[i] << endl
            << "tripYOrigin: " << m_tripYOrigin[i] << endl
            << "tripYHeight: " << m_tripYHeight[i] << endl
            << "tripMaxAmpFluc: " << m_tripMaxAmpFluc[i] << endl
            << "tripNoModes: " << m_tripNoModes << endl
            << "tripDeltaTime: " << m_tripDeltaTime[i] << endl
            << "tripTimeStep: " << m_tripTimeStep[i] << endl
            << "tripDomainWidth: " << m_tripDomainWidth << endl
            << "###########################################" << endl;
    }
    m_log << "=================================================" << endl;

    if(tripTotalNoCells > 0) {
      mAlloc(m_tripG, m_tripNoTrips * tripTotalNoCells, "m_tripG", F0, AT_);
      mAlloc(m_tripH1, m_tripNoTrips * tripTotalNoCells, "m_tripH1", F0, AT_);
      mAlloc(m_tripH2, m_tripNoTrips * tripTotalNoCells, "m_tripH2", F0, AT_);
    }
    mAlloc(m_tripModesG, m_tripNoTrips * 2 * m_tripNoModes, "m_tripModesG", F0, AT_);
    mAlloc(m_tripModesH1, m_tripNoTrips * 2 * m_tripNoModes, "m_tripModesH1", F0, AT_);
    mAlloc(m_tripModesH2, m_tripNoTrips * 2 * m_tripNoModes, "m_tripModesH2", F0, AT_);

    if(m_restart && m_tripUseRestart) {
      m_log << "Reading Sandpaper Trip Vars... ";

      stringstream fileName;
      if(m_useNonSpecifiedRestartFile) {
        fileName << restartDir() << "tripRestart" << ParallelIo::fileExt();
      } else {
        if(!isMultilevel()) {
          fileName << restartDir() << "tripRestart_" << m_restartTimeStep << ParallelIo::fileExt();
        } else {
          mTerm(-1, "loading Sandpaper trip variables not implemented for multiLevel");
        }
      }

      using namespace maia::parallel_io;
      ParallelIo parallelIo(fileName.str(), PIO_READ, mpiComm());

      ParallelIo::size_type dataSize = m_tripNoTrips * 2 * m_tripNoModes;

      parallelIo.setOffset(dataSize, 0);
      parallelIo.readArray(&m_tripModesG[0], "tripModesG");
      parallelIo.readArray(&m_tripModesH1[0], "tripModesH1");
      parallelIo.readArray(&m_tripModesH2[0], "tripModesH2");

      m_log << "ok." << endl;

    } else {
      for(MInt i = 0; i < m_tripNoTrips; ++i) {
        const MInt offsetModes = i * 2 * m_tripNoModes;
        tripFourierCoefficients(&m_tripModesG[offsetModes], m_tripNoModes, m_tripDomainWidth, m_tripCutoffZ[i]);
        tripFourierCoefficients(&m_tripModesH1[offsetModes], m_tripNoModes, m_tripDomainWidth, m_tripCutoffZ[i]);
        tripFourierCoefficients(&m_tripModesH2[offsetModes], m_tripNoModes, m_tripDomainWidth, m_tripCutoffZ[i]);
      }
    }

    for(MInt i = 0; i < m_tripNoTrips; ++i) {
      const MInt offset = m_tripCellOffset[i];
      const MInt offsetModes = i * 2 * m_tripNoModes;
      tripForceCoefficients(&m_tripModesG[offsetModes], &m_tripG[offset], &m_tripCoords[0], m_tripNoCells[i],
                            m_tripNoModes);
      tripForceCoefficients(&m_tripModesH1[offsetModes], &m_tripH1[offset], &m_tripCoords[0], m_tripNoCells[i],
                            m_tripNoModes);
      tripForceCoefficients(&m_tripModesH2[offsetModes], &m_tripH2[offset], &m_tripCoords[0], m_tripNoCells[i],
                            m_tripNoModes);
    }
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::applySandpaperTrip() {
  TRACE();

  for(MInt ii = 0; ii < m_tripNoTrips; ii++) {
    const MFloat t = m_time + m_timeStep * m_RKalpha[m_RKStep];
    const MInt tripTime = (MInt)(t / m_tripDeltaTime[ii]);
    const MFloat p = t / m_tripDeltaTime[ii] - tripTime;
    const MFloat b = 3 * pow(p, 2) - 2 * pow(p, 3);
    const MInt offset = m_tripCellOffset[ii];
    const MInt offsetModes = ii * 2 * m_tripNoModes;

    if(tripTime > m_tripTimeStep[ii]) {
      m_tripTimeStep[ii] = tripTime;

      // copy old values from H1 to H2
      for(MInt k = 0; k < m_tripNoCells[ii]; k++) {
        if(m_tripNoCells[ii] > 0) m_tripH1[offset + k] = m_tripH2[offset + k];
      }
      // copy old mode coefficients
      for(MInt n = 0; n < m_tripNoModes; n++) {
        m_tripModesH1[offsetModes + n] = m_tripModesH2[offsetModes + n];
      }

      // compute new fourier coefficients
      tripFourierCoefficients(&m_tripModesH2[offsetModes], m_tripNoModes, m_tripDomainWidth, m_tripCutoffZ[ii]);
      // if(m_tripNoCells[ii] > 0) {
      tripForceCoefficients(&m_tripModesH2[offsetModes], &m_tripH2[offset], &m_tripCoords[0], m_tripNoCells[ii],
                            m_tripNoModes);
      //}
    }

    for(MInt cell = 0; cell < m_tripNoCells[ii]; cell++) {
      //
      const MFloat forceStrength =
          (m_tripMaxAmpSteady[ii] * m_tripG[offset + cell]
           + m_tripMaxAmpFluc[ii] * ((1.0 - b) * m_tripH1[offset + cell] + b * m_tripH2[offset + cell]));
      const MInt cellId = m_tripCellIds[cell];
      const MFloat x = a_coordinate(cellId, 0);
      const MFloat y = a_coordinate(cellId, 1);

      MInt force =
          exp(-POW2((x - m_tripXOrigin[ii]) / m_tripXLength[ii]) - POW2((y - m_tripYOrigin[ii]) / m_tripYHeight[ii]))
          * forceStrength;
      if(!m_tripAirfoil) {
        // assuming the surface is +y-normal
        a_rightHandSide(cellId, CV->RHO_V) -= force * a_pvariable(cellId, PV->RHO) * a_cellVolume(cellId);
        // should this be an absolute?
        IF_CONSTEXPR(hasE<SysEqn>)
        a_rightHandSide(cellId, CV->RHO_E) -=
            force * a_pvariable(cellId, PV->RHO) * a_pvariable(cellId, PV->V) * a_cellVolume(cellId);
      } else {
        const MFloat nx = m_tripAirfoilForceDir[ii * nDim + 0];
        const MFloat ny = m_tripAirfoilForceDir[ii * nDim + 1];
        a_rightHandSide(cellId, CV->RHO_U) -= force * a_pvariable(cellId, PV->RHO) * a_cellVolume(cellId) * nx;
        a_rightHandSide(cellId, CV->RHO_V) -= force * a_pvariable(cellId, PV->RHO) * a_cellVolume(cellId) * ny;
        // should i get a total velocity aligned with the force here
        IF_CONSTEXPR(hasE<SysEqn>)
        a_rightHandSide(cellId, CV->RHO_E) -= force * a_pvariable(cellId, PV->RHO)
                                              * (a_pvariable(cellId, PV->U) * nx + a_pvariable(cellId, PV->V) * ny)
                                              * a_cellVolume(cellId);
      }
    }
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::saveSandpaperTripVars() {
  m_log << "writing Sandpaper Trip Vars... ";

  stringstream fileName;
  if(m_useNonSpecifiedRestartFile) {
    fileName << restartDir() << "tripRestart" << ParallelIo::fileExt();
  } else {
    if(!isMultilevel()) {
      fileName << restartDir() << "tripRestart_" << globalTimeStep << ParallelIo::fileExt();
    } else {
      mTerm(-1, "writing Sandpaper trip variables not implemented for multiLevel");
    }
  }

  using namespace maia::parallel_io;
  ParallelIo parallelIo(fileName.str(), PIO_REPLACE, mpiComm());

  MInt dataSize = m_tripNoModes * 2 * m_tripNoTrips;

  parallelIo.defineArray(PIO_FLOAT, "tripModesG", dataSize);
  parallelIo.defineArray(PIO_FLOAT, "tripModesH1", dataSize);
  parallelIo.defineArray(PIO_FLOAT, "tripModesH2", dataSize);

  if(domainId() == 0) {
    parallelIo.setOffset(dataSize, 0);
    parallelIo.writeArray(&m_tripModesG[0], "tripModesG");
    parallelIo.writeArray(&m_tripModesH1[0], "tripModesH1");
    parallelIo.writeArray(&m_tripModesH2[0], "tripModesH2");

  } else {
    parallelIo.setOffset(0, 0);
    parallelIo.writeArray(&m_tripModesG[0], "tripModesG");
    parallelIo.writeArray(&m_tripModesH1[0], "tripModesH1");
    parallelIo.writeArray(&m_tripModesH2[0], "tripModesH2");
  }
  m_log << " ok." << endl;
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::tripForceCoefficients(MFloat* modes, MFloat* forceCoef, MFloat* coords,
                                                               MInt noCells, MInt noModes) {
  MFloat maxLocalValue = -999999.0;
  MFloat minLocalValue = 999999.0;
  MFloat* ak = &modes[0];
  MFloat* phik = &modes[noModes];

  for(MInt k = 0; k < noCells; k++) {
    const MFloat z = coords[k];
    for(MInt n = 0; n < noModes; n++) {
      forceCoef[k] += sin(z * ak[n] + phik[n]);
    }

    maxLocalValue = mMax(maxLocalValue, forceCoef[k]);
    minLocalValue = mMin(minLocalValue, forceCoef[k]);
  }

  // find out min and max to normalize coefficients to interval [-1,1]
  MFloat maxGlobalValue = 0.0;
  MFloat minGlobalValue = 0.0;
  MPI_Allreduce(&maxLocalValue, &maxGlobalValue, 1, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "maxLocalValue",
                "maxGlobalValue");
  MPI_Allreduce(&minLocalValue, &minGlobalValue, 1, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "minLocalValue",
                "minGlobalValue");

  // normalize the series
  for(MInt k = 0; k < noCells; k++) {
    forceCoef[k] = 2 * (forceCoef[k] - minGlobalValue) / (maxGlobalValue - minGlobalValue) - 1.0;
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::tripFourierCoefficients(MFloat* modes, MInt noModes, MFloat maxWaveLength,
                                                                 MFloat minWaveLength) {
  const MFloat minWavenumber = 2 * PI / maxWaveLength;
  const MFloat maxWavenumber = 2 * PI / minWaveLength;

  MFloat* ak = &modes[0];
  MFloat* phik = &modes[noModes];
  if(domainId() == 0) {
    for(MInt n = 0; n < noModes; n++) {
      ak[n] = (maxWavenumber - minWavenumber) * (rand() / MFloat(RAND_MAX)) + minWavenumber;
      phik[n] = 2 * PI * rand() / MFloat(RAND_MAX);
    }
  }

  MPI_Bcast(&ak[0], noModes, MPI_DOUBLE, 0, mpiComm(), AT_, "ak[0]");
  MPI_Bcast(&phik[0], noModes, MPI_DOUBLE, 0, mpiComm(), AT_, "phik[0]");
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initChannelForce() {
  TRACE();
  // only for channels for a height of 2*referenceLength
  const MFloat channelReTau = Context::getSolverProperty<MFloat>("channelReTau", m_solverId, AT_, &channelReTau);
  // Both forumlations give mostly identical results
  // m_channelVolumeForce = m_rhoInfinity / m_referenceLength * POW2(channelReTau / m_Re * m_UInfinity);
  m_channelVolumeForce = POW2(channelReTau / sysEqn().m_Re0);
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::applyChannelForce() {
  TRACE();
  for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
    a_rightHandSide(cellId, CV->RHO_U) -= m_channelVolumeForce * a_pvariable(cellId, PV->RHO) * a_cellVolume(cellId);
    a_rightHandSide(cellId, CV->RHO_E) -=
        m_channelVolumeForce * a_pvariable(cellId, PV->RHO) * a_pvariable(cellId, PV->U) * a_cellVolume(cellId);
  }
}

// only for y-normal surface
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initSpanAvgSrfcProbes() {
  TRACE();

  const MInt noVars = 16;

  m_saNoSrfcProbes = Context::propertyLength("saSrfcProbesX", m_solverId);

  MInt probeBcId = 3399;
  probeBcId = Context::getSolverProperty<MInt>("saSrfcBcId", m_solverId, AT_, &probeBcId);

  m_saSrfcProbeStart = Context::getSolverProperty<MInt>("saSrfcProbeStart", m_solverId, AT_, &m_saSrfcProbeStart);

  if(m_saNoSrfcProbes != Context::propertyLength("saSrfcProbesSide", m_solverId))
    mTerm(1, "length of saSrfcProbesX and length of saSrfcProbesSide must match!");

  m_saSrfcProbeIds.resize(m_saNoSrfcProbes);
  m_saSrfcProbeSrfcs.resize(m_saNoSrfcProbes);

  for(MInt p = 0; p < m_saNoSrfcProbes; p++) {
    m_saSrfcProbeIds[p].clear();
    m_saSrfcProbeSrfcs[p].clear();

    const MFloat probeCoord = Context::getSolverProperty<MFloat>("saSrfcProbesX", m_solverId, AT_, &probeCoord, p);
    const MInt probeSide = Context::getSolverProperty<MInt>("saSrfcProbesSide", m_solverId, AT_, &probeSide, p);

    for(MInt bCellId = 0; bCellId < m_bndryCells->size(); bCellId++) {
      MInt cellId = m_bndryCells->a[bCellId].m_cellId;
      if(!a_isHalo(cellId)) {
        if(abs(a_coordinate(cellId, 0) - probeCoord) < F1B2 * c_cellLengthAtLevel(maxRefinementLevel()) + m_eps) {
          for(MInt srfc = 0; srfc < m_bndryCells->a[bCellId].m_noSrfcs; srfc++) {
            if(m_bndryCells->a[bCellId].m_srfcs[srfc]->m_bndryCndId == probeBcId) {
              const MFloat ny = m_bndryCells->a[bCellId].m_srfcs[srfc]->m_normalVector[1];
              if(ny * (MFloat)probeSide > 0) {
                m_saSrfcProbeIds[p].push_back(cellId);
                m_saSrfcProbeSrfcs[p].push_back(srfc);
                break;
              }
            }
          }
        }
      }
    }
  }


  mAlloc(m_saSrfcProbeBuffer, m_saNoSrfcProbes * noVars, "m_saSrfcProbeBuffer", 0.0, AT_);

  MIntScratchSpace localNoSamples(m_saNoSrfcProbes, AT_, "localNoSamples");
  for(MInt p = 0; p < m_saNoSrfcProbes; p++) {
    localNoSamples[p] = m_saSrfcProbeIds[p].size();
  }

  if(domainId() == 0) {
    mAlloc(m_saSrfcProbeNoSamples, m_saNoSrfcProbes, "m_saSrfcProbeNoSamples", 0, AT_);
  }
  MPI_Reduce(&localNoSamples[0], &m_saSrfcProbeNoSamples[0], m_saNoSrfcProbes, MPI_INT, MPI_SUM, 0, mpiComm(), AT_,
             "&localNoSamples[0]", "&m_saSrfcProbeNoSamples[0]");
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::writeSpanAvgSrfcProbes() {
  TRACE();

  const MInt noVars = 16;

  // reset buffer
  memset(&(m_saSrfcProbeBuffer[0]), 0.0, m_saNoSrfcProbes * noVars * sizeof(MFloat));

  // collect local data
  for(MInt p = 0; p < m_saNoSrfcProbes; p++) {
    for(MUint s = 0; s < m_saSrfcProbeIds[p].size(); s++) {
      const MInt cellId = m_saSrfcProbeIds[p][s];
      const MInt srfc = m_saSrfcProbeSrfcs[p][s];
      const MInt bCellId = a_bndryId(cellId);
      const MInt wmSrfcId = m_bndryCells->a[bCellId].m_srfcVariables[srfc]->m_wmSrfcId;

      MFloat pSrfc = m_bndryCells->a[bCellId].m_srfcVariables[srfc]->m_primVars[PV->P];
      MFloat rhoSrfc = m_bndryCells->a[bCellId].m_srfcVariables[srfc]->m_primVars[PV->RHO];
      MFloat uSrfc = m_bndryCells->a[bCellId].m_srfcVariables[srfc]->m_primVars[PV->U];
      MFloat vSrfc = m_bndryCells->a[bCellId].m_srfcVariables[srfc]->m_primVars[PV->V];
      MFloat wSrfc = m_bndryCells->a[bCellId].m_srfcVariables[srfc]->m_primVars[PV->W];
      MFloat TSrfc = sysEqn().temperature_ES(rhoSrfc, pSrfc);
      MFloat mueSrfc = SUTHERLANDLAW(TSrfc);

      MFloat nx = m_bndryCells->a[bCellId].m_srfcs[srfc]->m_normalVector[0];
      MFloat ny = m_bndryCells->a[bCellId].m_srfcs[srfc]->m_normalVector[1];
      MFloat nz = m_bndryCells->a[bCellId].m_srfcs[srfc]->m_normalVector[2];

      MFloat dudn = m_bndryCells->a[bCellId].m_srfcVariables[srfc]->m_normalDeriv[PV->U];
      MFloat dvdn = m_bndryCells->a[bCellId].m_srfcVariables[srfc]->m_normalDeriv[PV->V];
      MFloat dwdn = m_bndryCells->a[bCellId].m_srfcVariables[srfc]->m_normalDeriv[PV->W];

      MFloat tau_w = mueSrfc * (dudn * ny - dvdn * nx) / sysEqn().m_Re0;
      MFloat mue_wm = F0;
      MFloat tau_wm = F0;

      if(m_wmLES) {
        if(wmSrfcId > -1) {
          mue_wm += m_wmSurfaces[wmSrfcId].m_wmMUEWM;
          tau_wm += (mueSrfc + mue_wm) * (dudn * ny - dvdn * nx) / sysEqn().m_Re0;
        }
      }

      m_saSrfcProbeBuffer[noVars * p + 0] += m_bndryCells->a[bCellId].m_srfcs[srfc]->m_coordinates[0];
      m_saSrfcProbeBuffer[noVars * p + 1] += nx;
      m_saSrfcProbeBuffer[noVars * p + 2] += ny;
      m_saSrfcProbeBuffer[noVars * p + 3] += nz;
      m_saSrfcProbeBuffer[noVars * p + 4] += uSrfc;
      m_saSrfcProbeBuffer[noVars * p + 5] += vSrfc;
      m_saSrfcProbeBuffer[noVars * p + 6] += wSrfc;
      m_saSrfcProbeBuffer[noVars * p + 7] += rhoSrfc;
      m_saSrfcProbeBuffer[noVars * p + 8] += pSrfc;
      m_saSrfcProbeBuffer[noVars * p + 9] += mueSrfc;
      m_saSrfcProbeBuffer[noVars * p + 10] += dudn;
      m_saSrfcProbeBuffer[noVars * p + 11] += dvdn;
      m_saSrfcProbeBuffer[noVars * p + 12] += dwdn;
      m_saSrfcProbeBuffer[noVars * p + 13] += tau_w;
      m_saSrfcProbeBuffer[noVars * p + 14] += mue_wm;
      m_saSrfcProbeBuffer[noVars * p + 15] += tau_wm;
    }
  }

  if(domainId() == 0) {
    MPI_Reduce(MPI_IN_PLACE, &m_saSrfcProbeBuffer[0], noVars * m_saNoSrfcProbes, MPI_DOUBLE, MPI_SUM, 0, mpiComm(), AT_,
               "MPI_IN_PLACE", "&m_saSrfcProbeBuffer[0]");
  } else {
    MPI_Reduce(&m_saSrfcProbeBuffer[0], &m_saSrfcProbeBuffer[0], noVars * m_saNoSrfcProbes, MPI_DOUBLE, MPI_SUM, 0,
               mpiComm(), AT_, "&m_saSrfcProbeBuffer[0]", "&m_saSrfcProbeBuffer[0]");
  }

  if(domainId() == 0) {
    for(MInt p = 0; p < m_saNoSrfcProbes; p++) {
      // write output
      FILE* datei;
      stringstream filename;
      filename << outputDir() << m_saSrfcProbeDir << "/"
               << "spanAvgSrfcProbes_" << p;
      datei = fopen(filename.str().c_str(), "a");

      // print head
      if(globalTimeStep == m_saSrfcProbeStart) {
        fprintf(datei, "0: globalTimeStep");
        fprintf(datei, "  1: x");
        fprintf(datei, "  2: nx");
        fprintf(datei, "  3: ny");
        fprintf(datei, "  4: nz");
        fprintf(datei, "  5: u_srfc");
        fprintf(datei, "  6: v_srfc");
        fprintf(datei, "  7: w_srfc");
        fprintf(datei, "  8: rho_srfc");
        fprintf(datei, "  9: p_srfc");
        fprintf(datei, "  10: mue_srfc");
        fprintf(datei, "  11: dudn");
        fprintf(datei, "  12: dvdn");
        fprintf(datei, "  13: dwdn");
        fprintf(datei, "  14: tau_w");
        fprintf(datei, "  15: mue_wm");
        fprintf(datei, "  16: tau_wm");
        fprintf(datei, "\n");
      }

      fprintf(datei, "%d  ", globalTimeStep);

      for(MInt v = 0; v < noVars; v++) {
        fprintf(datei, "%f  ", m_saSrfcProbeBuffer[noVars * p + v] / m_saSrfcProbeNoSamples[p]);
      }
      fprintf(datei, "\n");
      fclose(datei);
    }
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::writeWMTimersASCII() {
  MFloat timerValue[3];
  timerValue[0] = RETURN_TIMER_TIME(m_timers[Timers::WMExchange]);
  timerValue[1] = RETURN_TIMER_TIME(m_timers[Timers::WMSurfaceLoop]);
  timerValue[2] = RETURN_TIMER_TIME(m_timers[Timers::WMFluxCorrection]);

  for(MInt i = 0; i < 3; i++) {
    if(domainId() == 0) {
      MPI_Reduce(MPI_IN_PLACE, &timerValue[i], 1, MPI_DOUBLE, MPI_MAX, 0, mpiComm(), AT_, "MPI_IN_PLACE",
                 "&timerValue[i]");
    } else {
      MPI_Reduce(&timerValue[i], &timerValue[i], 1, MPI_DOUBLE, MPI_MAX, 0, mpiComm(), AT_, "&timerValue[i]",
                 "&timerValue[i]");
    }
  }

  if(domainId() == 0) {
    MPI_Reduce(MPI_IN_PLACE, &m_wmIterator, 1, MPI_INT, MPI_MAX, 0, mpiComm(), AT_, "MPI_IN_PLACE", "&m_wmIterator");
  } else {
    MPI_Reduce(&m_wmIterator, &m_wmIterator, 1, MPI_INT, MPI_MAX, 0, mpiComm(), AT_, "&m_wmIterator", "&m_wmIterator");
  }


  if(domainId() == 0) {
    FILE* datei;
    stringstream filename;
    filename << outputDir() << "wmTimers";
    datei = fopen(filename.str().c_str(), "a");

    fprintf(datei, "WMExchange: %f    ", timerValue[0]);
    fprintf(datei, "WMSurfaceLoop: %f    ", timerValue[1]);
    fprintf(datei, "WMFluxCorrection: %f    ", timerValue[2]);
    fprintf(datei, "WMIterator: %d    ", m_wmIterator);
    fprintf(datei, "\n");

    fclose(datei);
  }
}

// Project Thesis: Wall Normal Output Work by Karlis Vagalis and Simon Cremer
// Supervisor: Thomas Luerkens
// Description:
//  Provides a line output of cell centered values  on wall normals of a
//  specified boundary condition
// TODO:
//  - enable interpolation within cells to allow proper computation of gradients in postprocessing
//  - allow online averaging to allow quick calculation of turbulent statistics in postprocessing
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::computeWallNormalPointCoords() {
  TRACE();

  m_log << "Computing Wall Normal Point Coordinates ... " << endl;

  MInt noSegments = m_normalNoPoints - 1;
  MFloat segmentLength = m_normalLength / noSegments;

  MInt size = m_bndryCells->size();
  MInt k = m_normalSamplingSide.size();

  ScratchSpace<MInt> sampleUsage(k, AT_, "sampleUsage");
  sampleUsage.fill(0);

  for(MInt i = 0; i < size; i++) {
    MInt cellId = m_bndryCells->a[i].m_cellId;
    if(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      if(!a_hasProperty(cellId, SolverCell::IsHalo)) {
        for(MInt srfc = 0; srfc < m_bndryCells->a[i].m_noSrfcs; srfc++) {
          MInt cellCnd = m_bndryCells->a[i].m_srfcs[srfc]->m_bndryCndId;
          if(cellCnd == m_normalBcId) {
            MFloat dist = c_cellLengthAtCell(cellId) / 2;
            MFloat x = (a_coordinate(cellId, 0) - m_bndryCells->a[i].m_coordinates[0]);
            MFloat xUpper = x + dist;
            MFloat xLower = x - dist;
            MFloat z = 0;
            MFloat zUpper = 0;
            MFloat zLower = 0;

            if(nDim == 3) {
              z = (a_coordinate(cellId, 2) - m_bndryCells->a[i].m_coordinates[2]);
              zUpper = z + dist;
              zLower = z - dist;
            }

            for(MInt o = 0; o < k; o++) {
              if(sampleUsage[o] == 0) {
                MFloat xCompare = m_normalSamplingCoords[o * 2];
                MFloat zCompare = 0;
                if(nDim == 3) {
                  zCompare = m_normalSamplingCoords[o * 2 + 1];
                }

                if((xCompare <= xUpper) && (xCompare >= xLower) && (zCompare <= zUpper) && (zCompare >= zLower)) {
                  MInt side = m_normalSamplingSide[o];
                  MFloat ny = m_bndryCells->a[i].m_srfcs[srfc]->m_normalVector[1];

                  if(((side < 0) && (ny < 0)) || ((side > 0) && (ny > 0))) {
                    sampleUsage[o] = 1;
                    m_wallSetupOrigin.push_back(xCompare);
                    m_wallSetupOrigin.push_back(zCompare);
                    m_wallSetupOriginSide.push_back(side);

                    MFloat initCoordx = m_bndryCells->a[i].m_srfcs[srfc]->m_coordinates[0];
                    MFloat initCoordy = m_bndryCells->a[i].m_srfcs[srfc]->m_coordinates[1];
                    MFloat initCoordz = 0;

                    MFloat nx = m_bndryCells->a[i].m_srfcs[srfc]->m_normalVector[0];
                    MFloat nz = 0;

                    m_wallNormalVectors.push_back(nx);
                    m_wallNormalVectors.push_back(ny);

                    if(nDim == 3) {
                      initCoordz = m_bndryCells->a[i].m_srfcs[srfc]->m_coordinates[2];
                      nz = m_bndryCells->a[i].m_srfcs[srfc]->m_normalVector[2];
                    }

                    MFloat r = sqrt(nx * nx + ny * ny + nz * nz);
                    MFloat scalingFactor = segmentLength / r;

                    MFloat stepX = nx * scalingFactor;
                    MFloat stepY = ny * scalingFactor;
                    MFloat stepZ = nz * scalingFactor;

                    for(MInt step = 0; step <= noSegments; step++) {
                      MFloat coordX = initCoordx + (step * stepX);
                      MFloat coordY = initCoordy + (step * stepY);

                      m_wallNormalPointCoords.push_back(coordX);
                      m_wallNormalPointCoords.push_back(coordY);

                      if(nDim == 3) {
                        MFloat coordZ = initCoordz + (step * stepZ);
                        m_wallNormalPointCoords.push_back(coordZ);
                      }
                    }
                    m_noWallNormals++;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  m_log << "done." << endl;
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::findWallNormalCellIds() {
  TRACE();

  MPI_Barrier(mpiComm(), AT_);

  m_log << "Finding Wall Normal Cell Ids ... " << endl;

  ScratchSpace<MInt> localNoWallNormalPointCoords(noDomains(), AT_, "localNoWallNormalPointCoords");
  localNoWallNormalPointCoords.fill(0);

  ScratchSpace<MInt> localNoWallNormalPoints(noDomains(), AT_, "localNoWallNormalPoints");
  localNoWallNormalPoints.fill(0);

  localNoWallNormalPointCoords[domainId()] = m_wallNormalPointCoords.size();

  localNoWallNormalPoints[domainId()] = (m_wallNormalPointCoords.size() / nDim);

  MPI_Allgather(&localNoWallNormalPointCoords[domainId()], 1, MPI_INT, &localNoWallNormalPointCoords[0], 1, MPI_INT,
                mpiComm(), AT_, "localNoWallNormalPointCoords", "localNoWallNormalPointCoords");
  MPI_Allgather(&localNoWallNormalPoints[domainId()], 1, MPI_INT, &localNoWallNormalPoints[0], 1, MPI_INT, mpiComm(),
                AT_, "localNoWallNormalPoints", "localNoWallNormalPoints");

  // Output vector for domainId to which point belongs to
  m_wallNormalPointDomains.resize(localNoWallNormalPoints[domainId()]);
  std::fill(m_wallNormalPointDomains.begin(), m_wallNormalPointDomains.end(), -1);

  // Output vector for cellId in which point lies
  m_wallNormalPointCellIDs.resize(localNoWallNormalPoints[domainId()]);
  std::fill(m_wallNormalPointCellIDs.begin(), m_wallNormalPointCellIDs.end(), -1);
  // temporary vector containing the neighbors cell Ids
  std::vector<MInt> tempNeghbrIds;
  tempNeghbrIds.clear();

  // Output vector for neghbrIds of cellId in which point lies
  m_neighborPointIds.resize(localNoWallNormalPoints[domainId()]);
  std::fill(m_neighborPointIds.begin(), m_neighborPointIds.end(), tempNeghbrIds);

  for(MInt dom = 0; dom < noDomains(); dom++) {
    MInt noCoords = localNoWallNormalPointCoords[dom];
    MInt noPoints = localNoWallNormalPoints[dom];

    if(noPoints > 0) {
      // temporary vector containing found cell's domainId
      std::vector<MInt> domainContainingCell;
      domainContainingCell.clear();
      // temporary vector containing found cellId
      std::vector<MInt> normalPointCellId;
      normalPointCellId.clear();
      // temporary vector containing the index of point (order, e.g first point, etc)
      std::vector<MInt> placement;
      placement.clear();

      // temporary vector containing the neighbors cell Ids
      std::vector<MInt> neghbrIds;
      neghbrIds.clear();

      // vector collecting the vectors containing the neighbors cellIds
      std::vector<std::vector<MInt>> neghbrIdsofId;
      neghbrIdsofId.clear();

      // neighbor ids as one dimensional array for communication
      std::vector<MInt> oneDimNeghbrs;
      oneDimNeghbrs.clear();

      std::vector<MInt> noOfNeghbrs;
      noOfNeghbrs.clear();
      // temporary coord array for croodinate distribution to other domains
      ScratchSpace<MFloat> sendCoordsBuffer(noCoords, AT_, "sendCoordsBuffer");
      sendCoordsBuffer.fill(0.0);

      // array for all domainIds for gathering
      ScratchSpace<MInt> allDomainsContainingCell(noPoints, AT_, "allDomainsContainingCell");
      allDomainsContainingCell.fill(-1);
      // array for all point cellIds for gathering
      ScratchSpace<MInt> allNormalPointCellIds(noPoints, AT_, "allNormalPointCellIds");
      allNormalPointCellIds.fill(-1);

      ScratchSpace<MInt> noNeighbors(noPoints, AT_, "noNeighbors");
      noNeighbors.fill(-1);

      ScratchSpace<MInt> allNeighbors(noPoints * ((pow(3, nDim) - 1) * pow(2, nDim) + 1), AT_, "allNeighbors");
      allNeighbors.fill(-1);

      // array fpr all neighbrIds for gathering
      std::vector<std::vector<MInt>> allNeghbrIdsofId;
      allNeghbrIdsofId.clear();

      // array for determining,  which point index from distributed coords array responds to which calculated cellId
      ScratchSpace<MInt> allPlacements(noPoints, AT_, "allPlacements");
      allPlacements.fill(-1);

      // number of points for the send/recv buffer count
      ScratchSpace<MInt> bufferNoWallNormalPoints(noDomains(), AT_, "bufferNoWallNormalPoints");
      bufferNoWallNormalPoints.fill(0);

      ScratchSpace<MInt> bufferNoNeighbor(noDomains(), AT_, "bufferNoNeighborOffsets");
      bufferNoNeighbor.fill(0);

      // point offsets for displacement in the recombined list
      ScratchSpace<MInt> bufferPointOffsets(noDomains(), AT_, "bufferPointOffsets");
      bufferPointOffsets.fill(0);

      ScratchSpace<MInt> bufferNeighborOffsets(noDomains(), AT_, "bufferNeighborOffsets");
      bufferNeighborOffsets.fill(0);

      // copy localNormalPointCoords to coordBuffer for broadcasting
      if(domainId() == dom) {
        for(MInt c = 0; c < noCoords; c++) {
          sendCoordsBuffer[c] = m_wallNormalPointCoords[c];
        }
      }

      // boradcast point coords from one working domain to all domains
      MPI_Bcast(&sendCoordsBuffer[0], noCoords, MPI_DOUBLE, dom, mpiComm(), AT_, "sendCoordsBuffer");

      // take coords from the localWallPointCoords list to run findContainingLeafCell
      for(MInt p = 0; p < noPoints; p++) {
        MInt tmpId = -1;
        MFloat pointCoords[nDim];

        pointCoords[0] = sendCoordsBuffer[nDim * p];
        pointCoords[1] = sendCoordsBuffer[nDim * p + 1];

        if(nDim == 3) {
          pointCoords[2] = sendCoordsBuffer[nDim * p + 2];
        }

        // checking coordinates with findContainingLeafCell
        tmpId = grid().raw().findContainingLeafCell(pointCoords);

        // checking wether the cell is a part of the domain and wether it is not halo
        if(tmpId != -1 && !a_hasProperty(tmpId, SolverCell::IsHalo)) {
          // make a list of all neighbors
          neghbrIds = findWallNormalNeighbors(tmpId);
          // distance criteria: make sure only direct neighbors are included:
          std::vector<MInt> deleteElements;
          deleteElements.clear();

          for(MInt i = 0; i < MInt(neghbrIds.size()); i++) {
            MFloat distance = 0.0;
            // initialize cut off factor to biggest value
            MFloat dist_factor = 2.4;
            MFloat dist_x = a_coordinate(neghbrIds[i], 0) - a_coordinate(tmpId, 0);
            MFloat dist_y = a_coordinate(neghbrIds[i], 1) - a_coordinate(tmpId, 1);
            MFloat dist_z = 0.0;
            // reference distance
            MFloat dist_ref = grid().cellLengthAtLevel(a_level(tmpId));

            if(nDim == 3) {
              dist_z = a_coordinate(neghbrIds[i], 2) - a_coordinate(tmpId, 2);
            }

            if(abs(dist_x) < 0.05 * dist_ref || abs(dist_y) < 0.05 * dist_ref || abs(dist_z) < 0.05 * dist_ref) {
              dist_factor = 1.9;
            }

            if((abs(dist_x) < 0.05 * dist_ref && abs(dist_y) < 0.05 * dist_ref)
               || (abs(dist_x) < 0.05 * dist_ref && abs(dist_z) < 0.05 * dist_ref)
               || (abs(dist_y) < 0.05 * dist_ref && abs(dist_z) < 0.05 * dist_ref)) {
              dist_factor = 1.33;
            }

            distance = sqrt(dist_x * dist_x + dist_y * dist_y + dist_z * dist_z);
            if(distance > dist_factor * grid().cellLengthAtLevel(a_level(tmpId))) {
              deleteElements.push_back(i);
            }
          }

          for(MInt i = 0; i < MInt(deleteElements.size()); i++) {
            MInt eraseElement = deleteElements.end()[-1 - i];
            neghbrIds.erase(neghbrIds.begin() + eraseElement);
          }


          MInt d = domainId();
          // add domain to the list
          domainContainingCell.push_back(d);
          // add cellId if to the list
          normalPointCellId.push_back(tmpId);
          // add placement of the point
          placement.push_back(p);
          // collect neighbrIds for every Id
          neghbrIdsofId.push_back(neghbrIds);

          // clear temporary vectors
          neghbrIds.clear();
        }
      }

      // transform 2D neighbor id array into one dimensional array for communication
      oneDimNeghbrs.clear();
      for(MInt i = 0; i < MInt(neghbrIdsofId.size()); i++) {
        noOfNeghbrs.push_back(MInt(neghbrIdsofId[i].size()));
        for(MInt j = 0; j < MInt(neghbrIdsofId[i].size()); j++) {
          oneDimNeghbrs.push_back(neghbrIdsofId[i][j]);
        }
      }

      bufferNoWallNormalPoints[domainId()] = normalPointCellId.size();

      for(MInt i = 0; i < MInt(neghbrIdsofId.size()); i++) {
        bufferNoNeighbor[domainId()] += neghbrIdsofId[i].size();
      }

      MPI_Allgather(&bufferNoNeighbor[domainId()], 1, MPI_INT, &bufferNoNeighbor[0], 1, MPI_INT, mpiComm(), AT_,
                    "bufferNoNeighbor", "bufferNoNeighbor");

      MPI_Allgather(&bufferNoWallNormalPoints[domainId()], 1, MPI_INT, &bufferNoWallNormalPoints[0], 1, MPI_INT,
                    mpiComm(), AT_, "bufferNoWallNormalPoints", "bufferNoWallNormalPoints");


      for(MInt d = 0; d < noDomains(); d++) {
        if(d > 0) {
          bufferPointOffsets[d] = bufferPointOffsets[d - 1] + bufferNoWallNormalPoints[d - 1];
          bufferNeighborOffsets[d] = bufferNeighborOffsets[d - 1] + bufferNoNeighbor[d - 1];
        }
      }

      // gather domainIds
      MPI_Gatherv(&domainContainingCell[0], bufferNoWallNormalPoints[domainId()], MPI_INT, &allDomainsContainingCell[0],
                  &bufferNoWallNormalPoints[0], &bufferPointOffsets[0], MPI_INT, dom, mpiComm(), AT_,
                  "domainContainingCell", "allDomainsContainingCell");

      // gather cellIds
      MPI_Gatherv(&normalPointCellId[0], bufferNoWallNormalPoints[domainId()], MPI_INT, &allNormalPointCellIds[0],
                  &bufferNoWallNormalPoints[0], &bufferPointOffsets[0], MPI_INT, dom, mpiComm(), AT_,
                  "normalPointCellId", "allNormalPointCellIds");

      // gather placements
      MPI_Gatherv(&placement[0], bufferNoWallNormalPoints[domainId()], MPI_INT, &allPlacements[0],
                  &bufferNoWallNormalPoints[0], &bufferPointOffsets[0], MPI_INT, dom, mpiComm(), AT_, "placement",
                  "allPlacements");

      // gather neighbors
      MPI_Gatherv(&oneDimNeghbrs[0], bufferNoNeighbor[domainId()], MPI_INT, &allNeighbors[0], &bufferNoNeighbor[0],
                  &bufferNeighborOffsets[0], MPI_INT, dom, mpiComm(), AT_, "oneDimNeghbrs", "allNeighbors");

      // gather number of neighbors per point
      MPI_Gatherv(&noOfNeghbrs[0], bufferNoWallNormalPoints[domainId()], MPI_INT, &noNeighbors[0],
                  &bufferNoWallNormalPoints[0], &bufferPointOffsets[0], MPI_INT, dom, mpiComm(), AT_, "noOfNeghbrs",
                  "noNeighbors");

      if(domainId() == dom) {
        MInt count = 0;
        MInt count_next = 0;
        std::vector<MInt> tempVec;
        tempVec.clear();
        for(MInt k = 0; k < noPoints; k++) {
          count_next = count_next + noNeighbors[k];
          for(MInt j = count; j < count_next; j++) {
            tempVec.push_back(allNeighbors[j]);
          }

          allNeghbrIdsofId.push_back(tempVec);
          count = count_next;
          tempVec.clear();
        }

        for(MInt c = 0; c < noPoints; c++) {
          MInt p = allPlacements[c];
          if(p != -1) {
            m_wallNormalPointDomains[p] = allDomainsContainingCell[c];
            m_wallNormalPointCellIDs[p] = allNormalPointCellIds[c];
            m_neighborPointIds[p] = allNeghbrIdsofId[c];
          }
        }
      }
    }
  }
}

template <MInt nDim_, class SysEqn>
std::vector<MInt> FvCartesianSolverXD<nDim_, SysEqn>::findWallNormalNeighbors(MInt pointId) {
  TRACE();

  m_log << "Find Neighbor Points of Wall Normal Point" << endl;

  const MInt tmpId = pointId;
  MInt tempNeghbrId = 0;

  // temporary vector containing the neighbors cell Ids
  std::vector<MInt> neghbrIds;
  neghbrIds.clear();
  // temporary vector containing the directions in which neighbors were found
  std::vector<MInt> dirOfNeghbrIds;
  dirOfNeghbrIds.clear();
  // temporary vector containing the diagonal neighbor cellIds
  std::vector<MInt> diagNeghbrIds;
  diagNeghbrIds.clear();
  // temporary vector containing the directions in which diaganol neighbors were found
  std::vector<std::vector<MInt>> dirOfDiagNeghbrIds;
  dirOfDiagNeghbrIds.clear();

  // checking wether the cell is a part of the domain and wether it is not halo
  if(tmpId != -1 && !a_hasProperty(tmpId, SolverCell::IsHalo)) {
    // make a list of all neighbors
    if(!a_isBndryGhostCell(tmpId)) {
      if(a_hasProperty(tmpId, SolverCell::IsOnCurrentMGLevel)) {
        for(MInt dir = 0; dir < m_noDirs; dir++) {
          if(a_hasNeighbor(tmpId, dir) > 0 && checkNeighborActive(tmpId, dir)) {
            tempNeghbrId = c_neighborId(tmpId, dir);
            if(a_hasProperty(tempNeghbrId, SolverCell::IsOnCurrentMGLevel)) {
              neghbrIds.push_back(tempNeghbrId);
              dirOfNeghbrIds.push_back(dir);
            } else {
              // investigate neighbor children
              for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
                if(c_childId(tempNeghbrId, childId) == -1) {
                  continue;
                }
                neghbrIds.push_back(c_childId(tempNeghbrId, childId));
                dirOfNeghbrIds.push_back(dir);
              }
            }
          }
        }

        // 2D case find all neighbors in xy plane
        for(MInt dir = 0; dir < 2; dir++) {
          if(a_hasNeighbor(neghbrIds[dir], 2) > 0 && checkNeighborActive(neghbrIds[dir], 2)) {
            tempNeghbrId = c_neighborId(neghbrIds[dir], 2);
            if(a_hasProperty(tempNeghbrId, SolverCell::IsOnCurrentMGLevel)) {
              diagNeghbrIds.push_back(tempNeghbrId);
              dirOfDiagNeghbrIds.push_back({dir, 2});
            } else {
              // investigate neighbor children
              for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
                if(c_childId(tempNeghbrId, childId) == -1) {
                  continue;
                }
                neghbrIds.push_back(c_childId(tempNeghbrId, childId));
                dirOfDiagNeghbrIds.push_back({dir, 2});
              }
            }
          }

          if(a_hasNeighbor(neghbrIds[dir], 3) > 0 && checkNeighborActive(neghbrIds[dir], 3)) {
            tempNeghbrId = c_neighborId(neghbrIds[dir], 3);
            if(a_hasProperty(tempNeghbrId, SolverCell::IsOnCurrentMGLevel)) {
              diagNeghbrIds.push_back(tempNeghbrId);
              dirOfDiagNeghbrIds.push_back({dir, 3});
            } else {
              // investigate neighbor children
              for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
                if(c_childId(tempNeghbrId, childId) == -1) {
                  continue;
                }
                neghbrIds.push_back(c_childId(tempNeghbrId, childId));
                dirOfDiagNeghbrIds.push_back({dir, 3});
              }
            }
          }
        }

        // search in all orthogonal directions of the neighbor you just found
        if(nDim == 3) {
          for(MInt i = 0; i < MInt(neghbrIds.size()); i++) {
            MInt tempDir[4];
            if(dirOfNeghbrIds[i] == 0 || dirOfNeghbrIds[i] == 1) {
              tempDir[0] = 2;
              tempDir[1] = 3;
              tempDir[2] = 4;
              tempDir[3] = 5;
            }
            if(dirOfNeghbrIds[i] == 2 || dirOfNeghbrIds[i] == 3) {
              tempDir[0] = 0;
              tempDir[1] = 1;
              tempDir[2] = 4;
              tempDir[3] = 5;
            }
            if(dirOfNeghbrIds[i] == 4 || dirOfNeghbrIds[i] == 5) {
              tempDir[0] = 0;
              tempDir[1] = 1;
              tempDir[2] = 2;
              tempDir[3] = 3;
            }

            for(MInt j = 0; j < 4; j++) {
              if(a_hasNeighbor(neghbrIds[i], tempDir[j]) > 0 && checkNeighborActive(neghbrIds[i], tempDir[j])) {
                tempNeghbrId = c_neighborId(neghbrIds[i], tempDir[j]);
                if(a_hasProperty(tempNeghbrId, SolverCell::IsOnCurrentMGLevel)) {
                  diagNeghbrIds.push_back(tempNeghbrId);
                  dirOfDiagNeghbrIds.push_back({dirOfNeghbrIds[i], tempDir[j]});
                } else {
                  // investigate neighbor children
                  for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
                    if(c_childId(tempNeghbrId, childId) == -1) {
                      continue;
                    }
                    diagNeghbrIds.push_back(c_childId(tempNeghbrId, childId));
                    dirOfDiagNeghbrIds.push_back({dirOfNeghbrIds[i], tempDir[j]});
                  }
                }
              }
            }
          }
        }

        if(nDim == 3) {
          if(neghbrIds.size() > 5) {
            for(MInt dir = 1; dir < nDim; dir++) {
              MInt dirOfNeghbr = 2 * dir + 2;
              if(dirOfNeghbr == 6) {
                dirOfNeghbr -= 6;
              }
              if(a_hasNeighbor(neghbrIds[2 * dir], dirOfNeghbr) > 0
                 && checkNeighborActive(neghbrIds[2 * dir], dirOfNeghbr)) {
                tempNeghbrId = c_neighborId(neghbrIds[2 * dir], dirOfNeghbr);
                if(a_hasProperty(tempNeghbrId, SolverCell::IsOnCurrentMGLevel)) {
                  diagNeghbrIds.push_back(tempNeghbrId);
                } else {
                  // investigate neighbor children
                  for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
                    if(c_childId(tempNeghbrId, childId) == -1) {
                      continue;
                    }
                    neghbrIds.push_back(c_childId(tempNeghbrId, childId));
                  }
                }
              }

              if(a_hasNeighbor(neghbrIds[2 * dir], dirOfNeghbr + 1) > 0
                 && checkNeighborActive(neghbrIds[2 * dir], dirOfNeghbr + 1)) {
                tempNeghbrId = c_neighborId(neghbrIds[2 * dir], dirOfNeghbr + 1);
                if(a_hasProperty(tempNeghbrId, SolverCell::IsOnCurrentMGLevel)) {
                  diagNeghbrIds.push_back(tempNeghbrId);
                } else {
                  // investigate neighbor children
                  for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
                    if(c_childId(tempNeghbrId, childId) == -1) {
                      continue;
                    }
                    neghbrIds.push_back(c_childId(tempNeghbrId, childId));
                  }
                }
              }

              if(a_hasNeighbor(neghbrIds[2 * dir + 1], dirOfNeghbr) > 0
                 && checkNeighborActive(neghbrIds[2 * dir + 1], dirOfNeghbr)) {
                tempNeghbrId = c_neighborId(neghbrIds[2 * dir + 1], dirOfNeghbr);
                if(a_hasProperty(tempNeghbrId, SolverCell::IsOnCurrentMGLevel)) {
                  diagNeghbrIds.push_back(tempNeghbrId);
                  // cout << "found diag neighbr three"<<endl;
                } else {
                  // investigate neighbor children
                  for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
                    if(c_childId(tempNeghbrId, childId) == -1) {
                      continue;
                    }
                    neghbrIds.push_back(c_childId(tempNeghbrId, childId));
                  }
                }
              }

              if(a_hasNeighbor(neghbrIds[2 * dir + 1], dirOfNeghbr + 1) > 0
                 && checkNeighborActive(neghbrIds[2 * dir + 1], dirOfNeghbr + 1)) {
                tempNeghbrId = c_neighborId(neghbrIds[2 * dir + 1], dirOfNeghbr + 1);
                if(a_hasProperty(tempNeghbrId, SolverCell::IsOnCurrentMGLevel)) {
                  diagNeghbrIds.push_back(tempNeghbrId);
                } else {
                  // investigate neighbor children
                  for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
                    if(c_childId(tempNeghbrId, childId) == -1) {
                      continue;
                    }
                    neghbrIds.push_back(c_childId(tempNeghbrId, childId));
                  }
                }
              }
            }
          }

          // find all tridiagonal neighbors
          if(diagNeghbrIds.size() > 3) {
            for(MInt dir = 0; dir < 4; dir++) {
              if(a_hasNeighbor(diagNeghbrIds[dir], 4) > 0 && checkNeighborActive(diagNeghbrIds[dir], 4)) {
                tempNeghbrId = c_neighborId(diagNeghbrIds[dir], 4);
                if(a_hasProperty(tempNeghbrId, SolverCell::IsOnCurrentMGLevel)) {
                  diagNeghbrIds.push_back(tempNeghbrId);
                } else {
                  // investigate neighbor children
                  for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
                    if(c_childId(tempNeghbrId, childId) == -1) {
                      continue;
                    }
                    neghbrIds.push_back(c_childId(tempNeghbrId, childId));
                  }
                }
              }

              if(a_hasNeighbor(diagNeghbrIds[dir], 5) > 0 && checkNeighborActive(diagNeghbrIds[dir], 5)) {
                tempNeghbrId = c_neighborId(diagNeghbrIds[dir], 5);
                if(a_hasProperty(tempNeghbrId, SolverCell::IsOnCurrentMGLevel)) {
                  diagNeghbrIds.push_back(tempNeghbrId);
                } else {
                  // investigate neighbor children
                  for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
                    if(c_childId(tempNeghbrId, childId) == -1) {
                      continue;
                    }
                    neghbrIds.push_back(c_childId(tempNeghbrId, childId));
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // combine the two neighbor vectors and erase elements that were found multiple times
  neghbrIds.insert(neghbrIds.end(), diagNeghbrIds.begin(), diagNeghbrIds.end());
  sort(neghbrIds.begin(), neghbrIds.end());
  neghbrIds.erase(unique(neghbrIds.begin(), neghbrIds.end()), neghbrIds.end());
  // include the actual cell after sorting to have it in the last place of the vector
  neghbrIds.push_back(tmpId);
  m_log << "done" << endl;
  return neghbrIds;
}


template <MInt nDim_, class SysEqn>
MFloat FvCartesianSolverXD<nDim_, SysEqn>::interpolateWallNormalPointVars(MInt variable, MFloat coords[], MInt localId,
                                                                          std::vector<MInt> neighborList) {
  TRACE();

  m_log << "Interpolate Wall Normal Point Variables ... " << endl;

  MFloat result = -99999999.9;
  const MInt tmpId = localId;
  MFloat pointCoords[nDim];
  // inizialize interpolation matrix
  MFloatTensor LMatrix(nDim + 1, nDim + 1);
  MFloatTensor InverseMatrix(nDim + 1, nDim + 1);

  LMatrix.set(0.0);
  InverseMatrix.set(0.0);
  MFloat originX = 0.0;
  MFloat originY = 0.0;
  MFloat originZ = 0.0;

  std::vector<MInt> neghbrIds;
  neghbrIds.clear();
  neghbrIds = neighborList;
  const MInt noNeghbrs = neghbrIds.size();

  // if list is to short for interpolation just return variable value
  if(noNeghbrs < ((nDim + 1) * 2)) {
    return a_pvariable(tmpId, variable);
  }
  // when the wrong list is identified, search for neighbors again
  if(!neghbrIds.empty() && neghbrIds.back() != tmpId) {
    cout << "WrongList " << endl;
    neghbrIds = findWallNormalNeighbors(tmpId);
  }

  originX = a_coordinate(tmpId, 0);
  originY = a_coordinate(tmpId, 1);
  pointCoords[0] = coords[0];
  pointCoords[1] = coords[1];

  if(nDim == 3) {
    originZ = a_coordinate(tmpId, 2);
    pointCoords[2] = coords[2];
  }

  // setup interpolation matrix and vector
  if(tmpId != -1) {
    MFloat sumX = 0.0;
    MFloat sumY = 0.0;
    MFloat sumZ = 0.0;
    MFloat sumXY = 0.0;
    MFloat sumXZ = 0.0;
    MFloat sumYZ = 0.0;
    MFloat sumX2 = 0.0;
    MFloat sumY2 = 0.0;
    MFloat sumZ2 = 0.0;
    MFloat sumVar = 0.0;
    MFloat sumVarX = 0.0;
    MFloat sumVarY = 0.0;
    MFloat sumVarZ = 0.0;

    for(MInt nId = 0; nId < noNeghbrs; nId++) {
      MFloat x = 0.0;
      MFloat y = 0.0;
      MFloat z = 0.0;

      const MInt tmpNeghbrId = neghbrIds[nId];
      if(tmpNeghbrId < 0) {
        mTerm(1, "neighborId < 0 during normal point interpolation");
      }

      x = a_coordinate(tmpNeghbrId, 0) - originX;
      y = a_coordinate(tmpNeghbrId, 1) - originY;
      if(nDim == 3) {
        z = a_coordinate(tmpNeghbrId, 2) - originZ;
      }

      const MFloat var = a_pvariable(tmpNeghbrId, variable);
      sumX += x;
      sumY += y;
      sumZ += z;
      sumXY += x * y;
      sumXZ += x * z;
      sumYZ += y * z;
      sumX2 += x * x;
      sumY2 += y * y;
      sumZ2 += z * z;
      sumVar += var;
      sumVarX += var * x;
      sumVarY += var * y;
      sumVarZ += var * z;
    }

    // fill matrix
    if(nDim == 2) {
      LMatrix(0, 0) = noNeghbrs;
      LMatrix(1, 1) = sumX2;
      LMatrix(2, 2) = sumY2;

      LMatrix(0, 1) = LMatrix(1, 0) = sumX;
      LMatrix(0, 2) = LMatrix(2, 0) = sumY;

      LMatrix(1, 2) = LMatrix(2, 1) = sumXY;
    } else {
      LMatrix(0, 0) = noNeghbrs;
      LMatrix(1, 1) = sumX2;
      LMatrix(2, 2) = sumY2;
      LMatrix(3, 3) = sumZ2;

      LMatrix(0, 1) = LMatrix(1, 0) = sumX;
      LMatrix(0, 2) = LMatrix(2, 0) = sumY;
      LMatrix(0, 3) = LMatrix(3, 0) = sumZ;

      LMatrix(1, 2) = LMatrix(2, 1) = sumXY;
      LMatrix(1, 3) = LMatrix(3, 1) = sumXZ;

      LMatrix(2, 3) = LMatrix(3, 2) = sumYZ;
    }

    MFloat normFactor = FPOW2(2 * a_level(tmpId)) / grid().cellLengthAtLevel(0);

    for(MInt i = 0; i < nDim + 1; i++) {
      for(MInt j = 0; j < nDim + 1; j++) {
        LMatrix(i, j) *= normFactor;
      }
    }

    maia::math::invert(LMatrix, InverseMatrix, nDim + 1, nDim + 1);


    // setup right hand side vector
    MFloat rightVector[4];
    MFloat coeffVector[4];
    std::fill_n(&rightVector[0], nDim + 1, 0.0);
    std::fill_n(&coeffVector[0], nDim + 1, 0.0);

    rightVector[0] = sumVar;
    rightVector[1] = sumVarX;
    rightVector[2] = sumVarY;
    if(nDim == 3) {
      rightVector[3] = sumVarZ;
    }

    for(MInt i = 0; i < nDim + 1; i++) {
      rightVector[i] *= normFactor;
    }

    for(MInt i = 0; i < nDim + 1; i++) {
      for(MInt j = 0; j < nDim + 1; j++) {
        coeffVector[i] += InverseMatrix(i, j) * rightVector[j];
      }
    }

    result = coeffVector[0] + coeffVector[1] * (pointCoords[0] - originX) + coeffVector[2] * (pointCoords[1] - originY);
    if(nDim == 3) {
      result += coeffVector[3] * (pointCoords[2] - originZ);
    }
  }
  // return interpolated variable value
  return result;
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::getWallNormalPointVars() {
  TRACE();

  const MInt noVars = PV->noVariables;

  ScratchSpace<MInt> localNoWallNormalPoints(noDomains(), AT_, "localNoWallNormalPoints");
  localNoWallNormalPoints.fill(0);

  ScratchSpace<MInt> localNoWallNormalCoords(noDomains(), AT_, "localNoWallNormalPoints");
  localNoWallNormalCoords.fill(0);

  localNoWallNormalPoints[domainId()] = m_wallNormalPointCellIDs.size();
  localNoWallNormalCoords[domainId()] = m_wallNormalPointCoords.size();

  MPI_Allgather(&localNoWallNormalPoints[domainId()], 1, MPI_INT, &localNoWallNormalPoints[0], 1, MPI_INT, mpiComm(),
                AT_, "localNoWallNormalPoints", "localNoWallNormalPoints");
  MPI_Allgather(&localNoWallNormalCoords[domainId()], 1, MPI_INT, &localNoWallNormalCoords[0], 1, MPI_INT, mpiComm(),
                AT_, "localNoWallNormalCoords", "localNoWallNormalCoords");

  // Output vector for variables
  ScratchSpace<MFloat> outVariables(localNoWallNormalPoints[domainId()] * noVars, AT_, "outVariables");
  outVariables.fill(-99999999.9);
  ScratchSpace<MFloat> outVariablesTransformed(localNoWallNormalPoints[domainId()], AT_, "outVariablesTransformed");
  outVariablesTransformed.fill(-99999999.9);

  for(MInt dom = 0; dom < noDomains(); dom++) {
    MInt noPoints = localNoWallNormalPoints[dom];
    MInt noCoords = localNoWallNormalCoords[dom];
    if(noPoints > 0) {
      std::vector<MInt> placement;
      placement.clear();
      std::vector<MFloat> variables;
      variables.clear();

      ScratchSpace<MInt> sendDomainsBuffer(noPoints, AT_, "sendDomainsBuffer");
      sendDomainsBuffer.fill(-1);

      ScratchSpace<MInt> sendLocalIdsBuffer(noPoints, AT_, "sendLocalIdsBuffer");
      sendLocalIdsBuffer.fill(-1);

      ScratchSpace<MFloat> sendLocalCoordsBuffer(noCoords, AT_, "sendLocalCoordsBuffer");
      sendLocalCoordsBuffer.fill(0.0);

      ScratchSpace<MInt> sendLocalNeighborsBuffer(noPoints * ((pow(3, nDim) - 1) * pow(2, nDim) + 1), AT_,
                                                  "sendLocalNeighborsBuffer");
      sendLocalIdsBuffer.fill(-1);
      ScratchSpace<MInt> sendLocalNoNeighborsBuffer(noPoints, AT_, "sendLocalNoNeighborsBuffer");
      sendLocalIdsBuffer.fill(-1);


      ScratchSpace<MInt> allPlacements(noPoints, AT_, "allPlacements");
      allPlacements.fill(-1);

      ScratchSpace<MFloat> allVariables(noPoints * noVars, AT_, "allVariables");
      allVariables.fill(-99999999.9);

      // number of variables for the send/recv buffer count
      ScratchSpace<MInt> bufferNoVariables(noDomains(), AT_, "bufferNoVariables");
      bufferNoVariables.fill(0);
      // vairable offsets for displacement in the recombined list
      ScratchSpace<MInt> bufferVarsOffsets(noDomains(), AT_, "bufferVarsOffsets");
      bufferVarsOffsets.fill(0);

      ScratchSpace<MInt> bufferNoPoints(noDomains(), AT_, "bufferNoPoints");
      bufferNoPoints.fill(0);
      ScratchSpace<MInt> bufferPointOffsets(noDomains(), AT_, "bufferPointOffsets");
      bufferPointOffsets.fill(0);

      // copy info to the buffer
      if(domainId() == dom) {
        std::vector<MInt> localNeighbors;
        localNeighbors.clear();
        for(MInt c = 0; c < noPoints; c++) {
          sendDomainsBuffer[c] = m_wallNormalPointDomains[c];
          sendLocalIdsBuffer[c] = m_wallNormalPointCellIDs[c];
          sendLocalNoNeighborsBuffer[c] = m_neighborPointIds[c].size();
          for(MInt position = 0; position < MInt(m_neighborPointIds[c].size()); position++) {
            localNeighbors.push_back(m_neighborPointIds[c][position]);
          }
        }
        for(MInt neighbor = 0; neighbor < MInt(localNeighbors.size()); neighbor++) {
          sendLocalNeighborsBuffer[neighbor] = localNeighbors[neighbor];
        }
        for(MInt co = 0; co < noCoords; co++) {
          sendLocalCoordsBuffer[co] = m_wallNormalPointCoords[co];
        }
      }

      MPI_Bcast(&sendDomainsBuffer[0], noPoints, MPI_INT, dom, mpiComm(), AT_, "sendDomainsBuffer");
      MPI_Bcast(&sendLocalIdsBuffer[0], noPoints, MPI_INT, dom, mpiComm(), AT_, "sendLocalIdsBuffer");
      MPI_Bcast(&sendLocalCoordsBuffer[0], noCoords, MPI_DOUBLE, dom, mpiComm(), AT_, "sendLocalCoordsBuffer");
      MPI_Bcast(&sendLocalNoNeighborsBuffer[0], noPoints, MPI_INT, dom, mpiComm(), AT_, "sendLocalNoNeighborsBuffer");
      MPI_Bcast(&sendLocalNeighborsBuffer[0], noPoints * 209, MPI_INT, dom, mpiComm(), AT_, "sendLocalNeighborsBuffer");

      MInt count = 0;
      MInt count_next = 0;
      std::vector<std::vector<MInt>> neighborList;
      neighborList.clear();

      std::vector<MInt> tempVec;
      tempVec.clear();

      for(MInt k = 0; k < noPoints; k++) {
        count_next = count_next + sendLocalNoNeighborsBuffer[k];
        for(MInt j = count; j < count_next; j++) {
          tempVec.push_back(sendLocalNeighborsBuffer[j]);
        }

        neighborList.push_back(tempVec);
        count = count_next;
        tempVec.clear();
      }


      for(MInt p = 0; p < noPoints; p++) {
        MInt originDomain = sendDomainsBuffer[p];
        if(originDomain == domainId()) {
          MInt localId = sendLocalIdsBuffer[p];
          placement.push_back(p);

          MFloat localCoords[nDim];
          localCoords[0] = sendLocalCoordsBuffer[nDim * p];
          localCoords[1] = sendLocalCoordsBuffer[nDim * p + 1];
          if(nDim == 3) {
            localCoords[2] = sendLocalCoordsBuffer[nDim * p + 2];
          }


          for(MInt v = 0; v < noVars; v++) {
            // get primitive variables and add them to variable list
            MFloat var = a_pvariable(localId, v);
            MFloat interpolatedVar = interpolateWallNormalPointVars(v, localCoords, localId, neighborList[p]);
            if(m_useWallNormalInterpolation) {
              variables.push_back(interpolatedVar);
            } else {
              variables.push_back(var);
            }
          }
        }
      }

      bufferNoVariables[domainId()] = variables.size() * 2;
      bufferNoPoints[domainId()] = placement.size();


      MPI_Allgather(&bufferNoVariables[domainId()], 1, MPI_INT, &bufferNoVariables[0], 1, MPI_INT, mpiComm(), AT_,
                    "bufferNoVariables", "bufferNoVariables");

      MPI_Allgather(&bufferNoPoints[domainId()], 1, MPI_INT, &bufferNoPoints[0], 1, MPI_INT, mpiComm(), AT_,
                    "bufferNoPoints", "bufferNoPoints");

      for(MInt d = 0; d < noDomains(); d++) {
        if(d > 0) {
          bufferVarsOffsets[d] = bufferVarsOffsets[d - 1] + bufferNoVariables[d - 1];
          bufferPointOffsets[d] = bufferPointOffsets[d - 1] + bufferNoPoints[d - 1];
        }
      }

      MPI_Gatherv(&placement[0], bufferNoPoints[domainId()], MPI_INT, &allPlacements[0], &bufferNoPoints[0],
                  &bufferPointOffsets[0], MPI_INT, dom, mpiComm(), AT_, "placement", "allPlacements");

      MPI_Gatherv(&variables[0], bufferNoVariables[domainId()], MPI_FLOAT, &allVariables[0], &bufferNoVariables[0],
                  &bufferVarsOffsets[0], MPI_FLOAT, dom, mpiComm(), AT_, "variables", "allVariables");

      // copy all the info into correct order into output vectors
      if(domainId() == dom) {
        for(MInt c = 0; c < noPoints; c++) {
          MInt p = allPlacements[c];
          if(p != -1) {
            for(MInt v = 0; v < noVars; v++) {
              outVariables[p * noVars + v] = allVariables[c * noVars + v];
            }
          }
        }
      }
    }
  }

  if(domainId() == 0) {
    MString interpolated = "";
    if(m_useWallNormalInterpolation) {
      interpolated = "interpolated";
    }
    cerr << "Writing " << interpolated << " NETCDF wallNormalData at time step " << globalTimeStep << " ... ";
  }

  //-------------TRANSFORMATION

  MFloat nx = 0;
  MFloat ny = 0;
  MFloat u = 0;
  MFloat v = 0;
  MInt n = 0;
  MFloat ut = 0;

  for(MInt p = 0; p < localNoWallNormalPoints[domainId()]; p++) {
    if((p % m_normalNoPoints) == 0) {
      nx = m_wallNormalVectors[n * 2];
      ny = m_wallNormalVectors[n * 2 + 1];
      n++;
    }

    u = outVariables[p * noVars];
    v = outVariables[p * noVars + 1];

    MFloat tg1 = 0;
    MFloat tg2 = 0;
    if(ny >= 0) {
      tg1 = (nx * cos((3 * PI) / 2) - ny * sin((3 * PI) / 2));
      tg2 = (nx * sin((3 * PI) / 2) + ny * cos((3 * PI) / 2));
    } else if(ny < 0) {
      tg1 = (nx * cos(PI / 2) - ny * sin(PI / 2));
      tg2 = (nx * sin(PI / 2) + ny * cos(PI / 2));
    }

    ut = u * tg1 + v * tg2;

    outVariablesTransformed[p] = ut;
  }

  //-------------OUTPUT

  using namespace maia::parallel_io;
  MString dataFileName;

  if(m_useWallNormalInterpolation) {
    dataFileName = outputDir() + "/pp_normals/interpolatedWallNormalData_" + to_string(globalTimeStep) + ".Netcdf";
  } else {
    dataFileName = outputDir() + "/pp_normals/wallNormalData_" + to_string(globalTimeStep) + ".Netcdf";
  }

  ParallelIo parallelIo(dataFileName, PIO_REPLACE, mpiComm());

  MInt localNoNormalPoints = m_wallNormalPointCoords.size() / nDim;

  MInt workaround = 0;
  if(localNoNormalPoints == 0) {
    workaround++;
  }

  ParallelIo::size_type pointOffset;
  ParallelIo::size_type globalNoPoints;

  ParallelIo::size_type normalOffset;
  ParallelIo::size_type globalNoNormals;

  parallelIo.calcOffset(localNoNormalPoints, &pointOffset, &globalNoPoints, mpiComm());
  parallelIo.calcOffset(m_noWallNormals, &normalOffset, &globalNoNormals, mpiComm());

  parallelIo.defineScalar(PIO_INT, "points_per_normal");
  parallelIo.defineScalar(PIO_FLOAT, "normal_length");
  parallelIo.defineScalar(PIO_FLOAT, "segment_length");

  parallelIo.defineArray(PIO_FLOAT, "originCoordX", globalNoNormals);
  parallelIo.defineArray(PIO_FLOAT, "originCoordZ", globalNoNormals);
  parallelIo.defineArray(PIO_INT, "originSide", globalNoNormals);

  parallelIo.defineArray(PIO_FLOAT, "coordinate_x", globalNoPoints);
  parallelIo.defineArray(PIO_FLOAT, "coordinate_y", globalNoPoints);
  if(nDim == 3) {
    parallelIo.defineArray(PIO_FLOAT, "coordinate_z", globalNoPoints);
  }

  parallelIo.defineArray(PIO_FLOAT, "variable_U_t", globalNoPoints);

  parallelIo.defineArray(PIO_FLOAT, "variable_rho", globalNoPoints);
  parallelIo.defineArray(PIO_FLOAT, "variable_p", globalNoPoints);

  MFloat segmentLength = m_normalLength / (m_normalNoPoints - 1);

  parallelIo.writeScalar(m_normalNoPoints, "points_per_normal");
  parallelIo.writeScalar(m_normalLength, "normal_length");
  parallelIo.writeScalar(segmentLength, "segment_length");

  if(workaround == 0) {
    parallelIo.setOffset(localNoNormalPoints, pointOffset);

    parallelIo.writeArray(&m_wallNormalPointCoords[0], "coordinate_x", nDim);
    parallelIo.writeArray(&m_wallNormalPointCoords[1], "coordinate_y", nDim);
    if(nDim == 3) {
      parallelIo.writeArray(&m_wallNormalPointCoords[2], "coordinate_z", nDim);
    }

    parallelIo.writeArray(&outVariablesTransformed[0], "variable_U_t", 1);

    if(nDim == 2) {
      parallelIo.writeArray(&outVariables[2], "variable_rho", noVars);
      parallelIo.writeArray(&outVariables[3], "variable_p", noVars);
    } else {
      parallelIo.writeArray(&outVariables[3], "variable_rho", noVars);
      parallelIo.writeArray(&outVariables[4], "variable_p", noVars);
    }

    parallelIo.setOffset(m_noWallNormals, normalOffset);

    parallelIo.writeArray(&m_wallSetupOrigin[0], "originCoordX", 2);
    parallelIo.writeArray(&m_wallSetupOrigin[1], "originCoordZ", 2);
    parallelIo.writeArray(&m_wallSetupOriginSide[0], "originSide", 1);

  } else {
    parallelIo.setOffset(localNoNormalPoints, pointOffset);
    parallelIo.writeArray(&workaround, "coordinate_x", 1);
    parallelIo.writeArray(&workaround, "coordinate_y", 1);

    if(nDim == 3) {
      parallelIo.writeArray(&workaround, "coordinate_z", 1);
    }

    parallelIo.writeArray(&workaround, "variable_U_t", 1);

    parallelIo.writeArray(&workaround, "variable_rho", 1);
    parallelIo.writeArray(&workaround, "variable_p", 1);

    parallelIo.setOffset(m_noWallNormals, normalOffset);

    parallelIo.writeArray(&workaround, "originCoordX", 1);
    parallelIo.writeArray(&workaround, "originCoordZ", 1);
    parallelIo.writeArray(&workaround, "originSide", 1);
  }

  //----------------------------------

  if(domainId() == 0) {
    cerr << "ok" << endl;
  }
}


/// \brief Dump cell data of each rank to a separate file for debugging purposes
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::dumpCellData(const MString name) {
  std::ofstream logfile;
  logfile.open(name + "_" + std::to_string(domainId()));

  // All cells
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    logfile << cellId << " g" << c_globalId(cellId);
    logfile << " " << a_properties(cellId);
    logfile << " bnd" << a_bndryId(cellId) << std::endl;
  }
  logfile << std::endl;

  // Bndry cells
  const MInt noBndryCells = m_bndryCells->size();
  for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
    MInt cellId = m_bndryCells->a[bndryId].m_cellId;

    logfile << "b" << bndryId << " g" << c_globalId(cellId) << " " << cellId << " " << a_bndryId(cellId) << " leaf"
            << c_isLeafCell(cellId) << " halo" << a_isHalo(cellId) << " " << a_properties(cellId) << std::endl;
  }
}

/** \brief
 * Initialize the azimuthal periodic exchange based on cartesian cell coordinates
 * \author Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvCartesianSolverXD<nDim, SysEqn>::initAzimuthalCartesianHaloInterpolation() {
  TRACE();

  if(grid().noAzimuthalNeighborDomains() == 0) return;

  MUint sndSize = maia::mpi::getBufferSize(grid().azimuthalHaloCells());
  MFloatScratchSpace haloBuff(sndSize * nDim, AT_, "haloBuff");
  haloBuff.fill(0);
  MUint rcvSize = maia::mpi::getBufferSize(grid().azimuthalWindowCells());
  MFloatScratchSpace windowBuff(rcvSize * nDim, AT_, "windowBuff");
  windowBuff.fill(0);

  this->m_azimuthalCartRecCoord.clear();
  this->m_azimuthalCartRecCoord.resize(rcvSize * nDim);
  MFloat angle = grid().azimuthalAngle();

  // Get azimuthal image coordinate
  MInt sndCnt = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MInt j = 0; j < grid().noAzimuthalHaloCells(i); j++) {
      MInt cellId = grid().azimuthalHaloCell(i, j);
      ASSERT(a_isPeriodic(cellId), "azimuthal halo is not isPeriodic!");

      MFloat recCoord[3];
      for(MInt d = 0; d < nDim; d++) {
        recCoord[d] = c_coordinate(cellId, d);
      }

      MInt side = grid().determineAzimuthalBoundarySide(recCoord);

      grid().rotateCartesianCoordinates(recCoord, (side * angle));

      ASSERT(!cellOutside(cellId), "Halo outside!");

      for(MInt d = 0; d < nDim; d++) {
        haloBuff[sndCnt++] = recCoord[d];
      }
    }
  }

  maia::mpi::exchangeBuffer(grid().azimuthalNeighborDomains(), grid().azimuthalWindowCells(),
                            grid().azimuthalHaloCells(), mpiComm(), haloBuff.getPointer(), windowBuff.getPointer(),
                            nDim);

  MInt rcvCnt = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MInt j = 0; j < grid().noAzimuthalWindowCells(i); j++) {
      for(MInt d = 0; d < nDim; d++) {
        this->m_azimuthalCartRecCoord[rcvCnt] = windowBuff[rcvCnt];
        rcvCnt++;
      }
#ifndef NDEBUG
      MFloat point[nDim];
      for(MInt d = 0; d < nDim; d++) {
        point[d] = this->m_azimuthalCartRecCoord[rcvCnt - nDim + d];
      }
      if(!this->inCell(grid().azimuthalWindowCell(i, j), point, F1 + pow(10, -12))) {
        mTerm(1, AT_, "Point not inside");
      }
#endif
    }
  }
}


/** Resets the containiners for the azimuthal periodic exchange and communicates the reconstruction coordinates
 */
template <MInt nDim, class SysEqn>
void FvCartesianSolverXD<nDim, SysEqn>::initAzimuthalReconstruction() {
  TRACE();

  if(domainId() == 0) {
    cerr << "Init Azimuthal Reconstruction...";
  }

  m_planeInterp = false;
  m_planeInterp = Context::getSolverProperty<MBool>("planeInterp", m_solverId, AT_, &m_planeInterp);
  ASSERT(!m_planeInterp, "m_planeInterp is untested");

  MBool noInterp = Context::getSolverProperty<MBool>("noInterp", m_solverId, AT_);
  if(noInterp && grid().noAzimuthalUnmappedHaloCells()) mTerm(1, AT_ "Grid not symmetric!");

  MFloat recCoord[nDim];
  MFloat angle = grid().azimuthalAngle();

  // First the unmapped halos are handled.
  MIntScratchSpace sndSize(grid().noAzimuthalNeighborDomains(), AT_, "sndSize");
  sndSize.fill(0);
  MInt sndSizeTotal = 0;
  for(MInt i = 0; i < grid().noAzimuthalUnmappedHaloCells(); i++) {
    MInt cellId = grid().azimuthalUnmappedHaloCell(i);
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(a_bndryId(cellId) < 0) continue;
    MInt dom = grid().azimuthalDomainIndex(grid().azimuthalUnmappedHaloDomain(i));
    sndSize[dom]++;
    sndSizeTotal++;
  }

  MIntScratchSpace rcvSize(grid().noAzimuthalNeighborDomains(), AT_, "rcvSize");
  ScratchSpace<MPI_Request> sndReq(grid().noAzimuthalNeighborDomains(), AT_, "sndReq");
  ScratchSpace<MPI_Request> rcvReq(grid().noAzimuthalNeighborDomains(), AT_, "rcvReq");
  sndReq.fill(MPI_REQUEST_NULL);
  rcvReq.fill(MPI_REQUEST_NULL);

  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    MPI_Isend(&sndSize[i], 1, MPI_INT, grid().azimuthalNeighborDomain(i), 9, mpiComm(), &sndReq[i], AT_, "sndSize[i]");
  }
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    MPI_Recv(&rcvSize[i], 1, MPI_INT, grid().azimuthalNeighborDomain(i), 9, mpiComm(), MPI_STATUS_IGNORE, AT_,
             "rcvSize[i]");
  }
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    MPI_Wait(&sndReq[i], MPI_STATUSES_IGNORE, AT_);
  }

  MInt rcvSizeTotal = 0;
  MIntScratchSpace sndOffsets(grid().noAzimuthalNeighborDomains() + 1, AT_, "sndOffsets");
  MIntScratchSpace rcvOffsets(grid().noAzimuthalNeighborDomains() + 1, AT_, "rcvOffsets");
  sndOffsets[0] = 0;
  rcvOffsets[0] = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    rcvSizeTotal += rcvSize[i];
    rcvOffsets[i + 1] = rcvOffsets[i] + rcvSize[i];

    sndOffsets[i + 1] = sndOffsets[i] + sndSize[i];
    sndSize[i] = 0;
  }

  MFloatScratchSpace sndBuff(sndSizeTotal * (nDim + 1), AT_, "sndBuff");
  MFloatScratchSpace rcvBuff(rcvSizeTotal * (nDim + 1), AT_, "rcvBuff");

  for(MInt i = 0; i < grid().noAzimuthalUnmappedHaloCells(); i++) {
    MInt cellId = grid().azimuthalUnmappedHaloCell(i);
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(a_bndryId(cellId) < 0) continue;

    if(a_bndryId(cellId) < 0) {
      cerr << "D:" << domainId() << " " << cellId << "/" << c_globalId(cellId) << " "
           << grid().azimuthalUnmappedHaloDomain(i) << " " << grid().tree().solver2grid(cellId) << "/"
           << c_globalId(grid().tree().solver2grid(cellId));
      if(c_parentId(cellId) > -1) {
        cerr << " " << grid().tree().solver2grid(c_parentId(cellId)) << "/"
             << c_globalId(grid().tree().solver2grid(c_parentId(cellId)));
      }
      cerr << " " << a_coordinate(cellId, 0) << " " << a_coordinate(cellId, 1) << " " << a_coordinate(cellId, 2) << " "
           << a_hasProperty(cellId, SolverCell::IsInactive) << " level:  " << a_level(cellId) << endl;
      mTerm(1, AT_, "Unmapped halo which is not bndryCell?");
    }

    MInt dom = grid().azimuthalDomainIndex(grid().azimuthalUnmappedHaloDomain(i));

    MInt side = grid().determineAzimuthalBoundarySide(&a_coordinate(cellId, 0));

    for(MInt d = 0; d < nDim; d++) {
      recCoord[d] = a_coordinate(cellId, d);
    }
    grid().rotateCartesianCoordinates(recCoord, (side * angle));

    for(MInt d = 0; d < nDim; d++) {
      sndBuff[sndOffsets[dom] * (nDim + 1) + sndSize[dom] * (nDim + 1) + d] = recCoord[d];
    }
    sndBuff[sndOffsets[dom] * (nDim + 1) + sndSize[dom] * (nDim + 1) + nDim] = (MFloat)side;

    sndSize[dom]++;
  }

  sndReq.fill(MPI_REQUEST_NULL);
  rcvReq.fill(MPI_REQUEST_NULL);

  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    if(sndSize[i] <= 0) continue;
    MPI_Isend(&sndBuff[sndOffsets[i] * (nDim + 1)], sndSize[i] * (nDim + 1), maia::type_traits<MFloat>::mpiType(),
              grid().azimuthalNeighborDomain(i), 13, mpiComm(), &sndReq[i], AT_, "sndBuff[sndOffsets[i]*(nDim+1)]");
  }

  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    if(rcvSize[i] <= 0) continue;
    MPI_Recv(&rcvBuff[rcvOffsets[i] * (nDim + 1)], rcvSize[i] * (nDim + 1), maia::type_traits<MFloat>::mpiType(),
             grid().azimuthalNeighborDomain(i), 13, mpiComm(), MPI_STATUS_IGNORE, AT_,
             "rcvBuff[rcvOffsets[i]*(nDim+1)]");
  }

  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    if(sndSize[i] <= 0) continue;
    MPI_Wait(&sndReq[i], MPI_STATUSES_IGNORE, AT_);
  }


  MIntScratchSpace nghbrList(m_maxNoAzimuthalRecConst, AT_, "nghbrList");
  set<MInt> nearBndryCells;
  const MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();
  for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(!a_isHalo(cellId)) {
      nearBndryCells.insert(cellId);
    }
    MInt counter = grid().getAdjacentGridCells(cellId, 1, nghbrList, a_level(cellId), 0);
    for(MInt n = 0; n < counter; n++) {
      MInt nghbrId = nghbrList[n];
      if(!a_isHalo(nghbrId)) {
        nearBndryCells.insert(nghbrId);
      }
    }
  }

  MUint rcvCnt = 0;
  MUint sndCnt = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MInt j = 0; j < rcvSize[i]; j++) {
      for(MInt d = 0; d < nDim; d++) {
        recCoord[d] = rcvBuff[rcvCnt++];
      }
      MInt side = (MInt)rcvBuff[rcvCnt++];

      MInt actualDom = domainId();

      // Find containing cell
      MInt cellId = -1;
      for(MInt e = -12; e < 0; e++) {
        MFloat eps = F1 + pow(10, e);
        for(auto it = nearBndryCells.begin(); it != nearBndryCells.end(); ++it) {
          MInt bndryCell = *it;

          if(this->inCell(bndryCell, recCoord, eps)) {
            // bndryCells already on max level
            cellId = bndryCell;
            break;
          }
        }

        if(cellId < 0) {
          // Search in halo cells
          for(MInt n = 0; n < noNeighborDomains(); n++) {
            for(MInt c = 0; c < noHaloCells(n); c++) {
              if(!c_isLeafCell(haloCellId(n, c))) continue;
              if(this->inCell(haloCellId(n, c), recCoord, eps)) {
                cellId = haloCellId(n, c);
                actualDom = neighborDomain(n);
                break;
              }
            }
          }
        }
        if(cellId > -1) break;
      }

      if(cellId < 0) {
        MFloat dummyCoord[3];
        std::copy_n(&recCoord[0], nDim, &dummyCoord[0]);
        grid().rotateCartesianCoordinates(dummyCoord, (-side * angle));
        cerr << "D:" << domainId() << " " << grid().azimuthalNeighborDomain(i) << " " << j << " " << recCoord[0] << " "
             << recCoord[1] << " " << recCoord[nDim - 1] << " " << dummyCoord[0] << " " << dummyCoord[1] << " "
             << dummyCoord[nDim - 1] << endl;
        mTerm(1, AT_, "No containing window found!");
      }

      rcvBuff[rcvOffsets[i] + j] = actualDom;
    }
  }

  sndReq.fill(MPI_REQUEST_NULL);
  rcvReq.fill(MPI_REQUEST_NULL);

  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    if(rcvSize[i] <= 0) continue;
    MPI_Isend(&rcvBuff[rcvOffsets[i]], rcvSize[i], maia::type_traits<MFloat>::mpiType(),
              grid().azimuthalNeighborDomain(i), 13, mpiComm(), &sndReq[i], AT_, "rcvBuff[rcvOffsets[i]]");
  }

  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    if(sndSize[i] <= 0) continue;
    MPI_Recv(&sndBuff[sndOffsets[i]], sndSize[i], maia::type_traits<MFloat>::mpiType(),
             grid().azimuthalNeighborDomain(i), 13, mpiComm(), MPI_STATUS_IGNORE, AT_, "sndBuff[sndOffsets[i]]");
  }

  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    if(rcvSize[i] <= 0) continue;
    MPI_Wait(&sndReq[i], MPI_STATUSES_IGNORE, AT_);
  }

  sndSize.fill(0);
  MInt sndSizeTotalG = 0;
  MIntScratchSpace sndSizeG(noDomains(), AT_, "sndSizeG");
  sndSizeG.fill(0);
  MIntScratchSpace azimuthalUnmappedDomains(grid().noAzimuthalUnmappedHaloCells(), AT_, "azimuthalUnmappedDomains");
  azimuthalUnmappedDomains.fill(-1);

  for(MInt i = 0; i < grid().noAzimuthalUnmappedHaloCells(); i++) {
    MInt cellId = grid().azimuthalUnmappedHaloCell(i);
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(a_bndryId(cellId) < 0) continue;

    MInt assumedDomainIndex = grid().azimuthalDomainIndex(grid().azimuthalUnmappedHaloDomain(i));
    MInt actualDomain = sndBuff[sndOffsets[assumedDomainIndex] + sndSize[assumedDomainIndex]];
    sndSize[assumedDomainIndex]++;

    sndSizeG[actualDomain]++;
    sndSizeTotalG++;

    azimuthalUnmappedDomains[i] = actualDomain;
  }

  MIntScratchSpace rcvSizeG(noDomains(), AT_, "rcvSizeG");
  rcvSizeG.fill(0);
  ScratchSpace<MPI_Request> sndReqG(noDomains(), AT_, "sndReqG");
  ScratchSpace<MPI_Request> rcvReqG(noDomains(), AT_, "rcvReqG");
  sndReqG.fill(MPI_REQUEST_NULL);
  rcvReqG.fill(MPI_REQUEST_NULL);

  for(MInt i = 0; i < noDomains(); i++) {
    MPI_Isend(&sndSizeG[i], 1, MPI_INT, i, 9, mpiComm(), &sndReqG[i], AT_, "sndSizeG[i]");
  }
  for(MInt i = 0; i < grid().noDomains(); i++) {
    MPI_Recv(&rcvSizeG[i], 1, MPI_INT, i, 9, mpiComm(), MPI_STATUS_IGNORE, AT_, "rcvSizeG[i]");
  }
  MPI_Waitall(noDomains(), &sndReqG[0], MPI_STATUSES_IGNORE, AT_);

  MInt noAzimuthalRemappedNeighborDoms = 0;
  MInt rcvSizeTotalG = 0;
  for(MInt i = 0; i < noDomains(); i++) {
    rcvSizeTotalG += rcvSizeG[i];
    if(rcvSizeG[i] > 0 || sndSizeG[i] > 0) noAzimuthalRemappedNeighborDoms++;
  }

  m_azimuthalRemappedNeighborDomains.resize(noAzimuthalRemappedNeighborDoms);
  m_azimuthalRemappedNeighborsDomainIndex.assign(noDomains(), -1);
  m_azimuthalRemappedWindowCells.resize(noAzimuthalRemappedNeighborDoms);
  m_azimuthalRemappedHaloCells.resize(noAzimuthalRemappedNeighborDoms);
  MIntScratchSpace sndOffsetsG(noAzimuthalRemappedNeighborDoms + 1, AT_, "sndOffsetsG");
  MIntScratchSpace rcvOffsetsG(noAzimuthalRemappedNeighborDoms + 1, AT_, "rcvOffsetsG");
  sndOffsetsG[0] = 0;
  rcvOffsetsG[0] = 0;
  MInt cnt = 0;
  for(MInt i = 0; i < noDomains(); i++) {
    if(rcvSizeG[i] > 0 || sndSizeG[i] > 0) {
      m_azimuthalRemappedNeighborDomains[cnt] = i;
      m_azimuthalRemappedNeighborsDomainIndex[i] = cnt;
      m_azimuthalRemappedHaloCells[cnt].resize(sndSizeG[i]);
      m_azimuthalRemappedWindowCells[cnt].resize(rcvSizeG[i]);
      rcvOffsetsG[cnt + 1] = rcvOffsetsG[cnt] + rcvSizeG[i];
      sndOffsetsG[cnt + 1] = sndOffsetsG[cnt] + sndSizeG[i];

      rcvSizeG[cnt] = rcvSizeG[i];
      cnt++;
    }
    sndSizeG[i] = 0;
    // rcvSizeG[i] = 0;
  }

  // Now the regular azimuthal window halos cells are handled
  sndCnt = maia::mpi::getBufferSize(grid().azimuthalHaloCells());
  sndCnt += sndSizeTotalG;
  MFloatScratchSpace haloBuff(sndCnt * (nDim + 1), AT_, "haloBuff");
  haloBuff.fill(0);
  rcvCnt = maia::mpi::getBufferSize(grid().azimuthalWindowCells());
  rcvCnt += rcvSizeTotalG;
  MFloatScratchSpace windowBuff(rcvCnt * (nDim + 1), AT_, "windowBuff");
  windowBuff.fill(0);

  m_noAzimuthalReconstNghbrs.clear();
  m_noAzimuthalReconstNghbrs.assign(rcvCnt, 0);
  m_azimuthalCutRecCoord.clear();
  m_azimuthalCutRecCoord.assign(rcvCnt * nDim, F0);
  m_azimuthalRecConsts.clear();
  m_azimuthalRecConsts.assign(rcvCnt * m_maxNoAzimuthalRecConst, F0);
  m_azimuthalReconstNghbrIds.clear();
  m_azimuthalReconstNghbrIds.assign(rcvCnt * m_maxNoAzimuthalRecConst, -1);
  m_azimuthalBndrySide.assign(rcvCnt, 0);

  // Get azimuthal image coordinate
  sndCnt = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MInt j = 0; j < grid().noAzimuthalHaloCells(i); j++) {
      MInt cellId = grid().azimuthalHaloCell(i, j);
      ASSERT(a_isPeriodic(cellId), "azimuthal halo is not isPeriodic!");
      ASSERT(!cellOutside(cellId), "Halo outside!");

      MInt side = grid().determineAzimuthalBoundarySide(&a_coordinate(cellId, 0));

      for(MInt d = 0; d < nDim; d++) {
        recCoord[d] = a_coordinate(cellId, d);
      }

      if(!(!m_geometry->pointIsInside(recCoord) || c_noChildren(cellId) > 0
           || a_hasProperty(cellId, SolverCell::IsInactive))) {
        cerr << "O:" << domainId() << " " << cellId << "/" << c_globalId(cellId) << " " << c_coordinate(cellId, 0)
             << " " << c_coordinate(cellId, 1) << " " << c_coordinate(cellId, 2) << " " << a_coordinate(cellId, 0)
             << " " << a_coordinate(cellId, 1) << " " << a_coordinate(cellId, 2) << " " << a_level(cellId) << " "
             << m_geometry->pointIsInside(recCoord) << " " << c_noChildren(cellId) << " "
             << a_hasProperty(cellId, SolverCell::IsInactive) << " " << recCoord[0] << " " << recCoord[1] << " "
             << recCoord[nDim - 1] << endl;
      }
      // ASSERT(!m_geometry->pointIsInside(recCoord) || c_noChildren(cellId) > 0 || a_hasProperty(cellId,
      // SolverCell::IsInactive), "Rec coord outside!");

      grid().rotateCartesianCoordinates(recCoord, (side * angle));

      for(MInt d = 0; d < nDim; d++) {
        haloBuff[sndCnt++] = recCoord[d];
      }
      haloBuff[sndCnt++] = (MFloat)side;
    }
  }

  if(grid().noAzimuthalNeighborDomains() > 0) {
    maia::mpi::exchangeBuffer(grid().azimuthalNeighborDomains(), grid().azimuthalWindowCells(),
                              grid().azimuthalHaloCells(), mpiComm(), haloBuff.getPointer(), windowBuff.getPointer(),
                              nDim + 1);
  }

  rcvCnt = 0;
  MInt offset = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MInt j = 0; j < grid().noAzimuthalWindowCells(i); j++) {
      for(MInt d = 0; d < nDim; d++) {
        recCoord[d] = windowBuff[rcvCnt++];
      }

      for(MInt d = 0; d < nDim; d++) {
        m_azimuthalCutRecCoord[offset * nDim + d] = recCoord[d];
      }

      MInt side = (MInt)windowBuff[rcvCnt++];
      m_azimuthalBndrySide[offset] = side;

      offset++;
    }
  }

  // Unmapped halos part 2
  MFloatScratchSpace sndBuffG(sndSizeTotalG * (nDim + 1), AT_, "sndBuffG");
  MFloatScratchSpace rcvBuffG(rcvSizeTotalG * (nDim + 1), AT_, "rcvBuffG");
  for(MInt i = 0; i < grid().noAzimuthalUnmappedHaloCells(); i++) {
    MInt cellId = grid().azimuthalUnmappedHaloCell(i);
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(a_bndryId(cellId) < 0) continue;

    MInt actualDomain = azimuthalUnmappedDomains[i];
    MInt dom = m_azimuthalRemappedNeighborsDomainIndex[actualDomain];
    m_azimuthalRemappedHaloCells[dom][sndSizeG[dom]] = cellId;

    MInt side = grid().determineAzimuthalBoundarySide(&a_coordinate(cellId, 0));

    for(MInt d = 0; d < nDim; d++) {
      recCoord[d] = a_coordinate(cellId, d);
    }
    grid().rotateCartesianCoordinates(recCoord, (side * angle));

    for(MInt d = 0; d < nDim; d++) {
      sndBuffG[sndOffsetsG[dom] * (nDim + 1) + sndSizeG[dom] * (nDim + 1) + d] = recCoord[d];
    }
    sndBuffG[sndOffsetsG[dom] * (nDim + 1) + sndSizeG[dom] * (nDim + 1) + nDim] = (MFloat)side;
    sndSizeG[dom]++;
  }

  sndReqG.fill(MPI_REQUEST_NULL);
  rcvReqG.fill(MPI_REQUEST_NULL);

  for(MUint i = 0; i < m_azimuthalRemappedNeighborDomains.size(); i++) {
    if(sndSizeG[i] <= 0) continue;
    MPI_Isend(&sndBuffG[sndOffsetsG[i] * (nDim + 1)], sndSizeG[i] * (nDim + 1), maia::type_traits<MFloat>::mpiType(),
              m_azimuthalRemappedNeighborDomains[i], 13, mpiComm(), &sndReqG[i], AT_,
              "sndBuffG[sndOffsetsG[i]*(nDim+1)]");
  }

  for(MUint i = 0; i < m_azimuthalRemappedNeighborDomains.size(); i++) {
    if(rcvSizeG[i] <= 0) continue;
    MPI_Recv(&rcvBuffG[rcvOffsetsG[i] * (nDim + 1)], rcvSizeG[i] * (nDim + 1), maia::type_traits<MFloat>::mpiType(),
             m_azimuthalRemappedNeighborDomains[i], 13, mpiComm(), MPI_STATUS_IGNORE, AT_,
             "rcvBuffG[rcvOffsetsG[i]*(nDim+1)]");
  }

  for(MUint i = 0; i < m_azimuthalRemappedNeighborDomains.size(); i++) {
    if(sndSizeG[i] <= 0) continue;
    MPI_Wait(&sndReqG[i], MPI_STATUSES_IGNORE, AT_);
  }


  rcvCnt = 0;
  sndCnt = 0;
  for(MUint i = 0; i < m_azimuthalRemappedNeighborDomains.size(); i++) {
    for(MInt j = 0; j < rcvSizeG[i]; j++) {
      for(MInt d = 0; d < nDim; d++) {
        recCoord[d] = rcvBuffG[rcvCnt++];
      }
      MInt side = (MInt)rcvBuffG[rcvCnt++];

      // Find containing cell
      MInt cellId = -1;
      for(MInt e = -12; e < 0; e++) {
        MFloat eps = F1 + pow(10, e);
        for(auto it = nearBndryCells.begin(); it != nearBndryCells.end(); ++it) {
          MInt bndryCell = *it;

          if(this->inCell(bndryCell, recCoord, eps)) {
            // bndryCells already on max level
            cellId = bndryCell;
            break;
          }
        }
        if(cellId > -1) break;
      }
      if(cellId < 0) {
        MFloat dummyCoord[3];
        std::copy_n(&recCoord[0], nDim, &dummyCoord[0]);
        grid().rotateCartesianCoordinates(dummyCoord, (-side * angle));
        cerr << "D:" << domainId() << " " << m_azimuthalRemappedNeighborDomains[i] << " " << j << " " << rcvSizeG[i]
             << " " << recCoord[0] << " " << recCoord[1] << " " << recCoord[nDim - 1] << " " << dummyCoord[0] << " "
             << dummyCoord[1] << " " << dummyCoord[nDim - 1] << endl;
        mTerm(1, AT_, "No containing window found!");
      }

      m_azimuthalRemappedWindowCells[i][j] = cellId;

      for(MInt d = 0; d < nDim; d++) {
        m_azimuthalCutRecCoord[offset * nDim + d] = recCoord[d];
      }
      m_azimuthalBndrySide[offset] = side;

      offset++;
    }
  }

  m_azimuthalRecConstSet = true;

  if(domainId() == 0) {
    cerr << " done" << endl;
  }
}

/** \brief Compute the reconstruction constants for azimuthal periodic exchange using a weighted least squares
 * approached solved via singular value decomposition - Derieved form
 * FvCartesianSolverXD::computeReconstructionConstantsSVD() \author Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvCartesianSolverXD<nDim, SysEqn>::computeAzimuthalReconstructionConstants(MInt mode) {
  TRACE();

  MFloat recCoord[nDim];

  MInt offset = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MInt j = 0; j < grid().noAzimuthalWindowCells(i); j++) {
      MInt cellId = grid().azimuthalWindowCell(i, j);

      std::copy_n(&m_azimuthalCutRecCoord[offset * nDim], nDim, &recCoord[0]);

      rebuildAzimuthalReconstructionConstants(cellId, offset, recCoord, mode);

      offset++;
    }
  }

  for(MUint i = 0; i < m_azimuthalRemappedNeighborDomains.size(); i++) {
    for(MUint j = 0; j < m_azimuthalRemappedWindowCells[i].size(); j++) {
      MInt cellId = m_azimuthalRemappedWindowCells[i][j];

      std::copy_n(&m_azimuthalCutRecCoord[offset * nDim], nDim, &recCoord[0]);

      rebuildAzimuthalReconstructionConstants(cellId, offset, recCoord, mode);

      offset++;
    }
  }
}

template <MInt nDim, class SysEqn>
void FvCartesianSolverXD<nDim, SysEqn>::rebuildAzimuthalReconstructionConstants(MInt cellId, MInt offset,
                                                                                MFloat* recCoord, MInt mode) {
  TRACE();

  const MInt maxNoNghbrs = m_maxNoAzimuthalRecConst;
  MIntScratchSpace nghbrList(1.5 * maxNoNghbrs, AT_, "nghbrList"); // Plus 50%

  m_noAzimuthalReconstNghbrs[offset] = 0;

  if(m_geometry->pointIsInside(recCoord)) {
    if(a_bndryId(cellId) < 0) {
      // Halo is inActive or a parent of bndryCells
      m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst] = cellId;
      m_noAzimuthalReconstNghbrs[offset] = 1;
      m_azimuthalRecConsts[offset * m_maxNoAzimuthalRecConst] = F1;
      if(a_level(cellId) == maxRefinementLevel()) mTerm(1, AT_, "");
      return;
    } else {
      std::vector<MFloat> ghostCoord{F0, F0, F0};
      for(MInt srfc = 0; srfc < m_bndryCells->a[a_bndryId(cellId)].m_noSrfcs; srfc++) {
        MInt ghostCellId = m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_srfcVariables[srfc]->m_ghostCellId;
        std::copy_n(&a_coordinate(ghostCellId, 0), nDim, &ghostCoord[0]);

        if(a_level(cellId) == maxLevel()) {
          cerr << "cut cell and stl issue"
               << " D:" << domainId() << " " << cellId << "/" << c_globalId(cellId) << " (" << a_coordinate(cellId, 0)
               << ", " << a_coordinate(cellId, 1) << ", " << a_coordinate(cellId, 2) << ") | "
               << "GC: (" << ghostCoord[0] << ", " << ghostCoord[1] << ", " << ghostCoord[2] << ") | "
               << "RC: (" << recCoord[0] << ", " << recCoord[1] << ", " << recCoord[2] << ")" << endl;
        }
      }
    }
  }

  // Only debug info! Not an error.
#ifndef NDEBUG
  if((abs(a_coordinate(cellId, 0) - recCoord[0]) > c_cellLengthAtLevel(a_level(cellId))
      || abs(a_coordinate(cellId, 1) - recCoord[1]) > c_cellLengthAtLevel(a_level(cellId))
      || abs(a_coordinate(cellId, nDim - 1) - recCoord[nDim - 1]) > c_cellLengthAtLevel(a_level(cellId)))
     && !a_hasProperty(cellId, SolverCell::IsInactive)) {
    MInt side = m_azimuthalBndrySide[offset];
    MFloat dummyCoord[3];
    MFloat angle = grid().azimuthalAngle();
    cerr << "Rec coord " << domainId() << " " << cellId << "/" << c_globalId(cellId) << " " << recCoord[0] << " "
         << recCoord[1] << " " << recCoord[nDim - 1] << " / Window G " << c_coordinate(cellId, 0) << " "
         << c_coordinate(cellId, 1) << " " << c_coordinate(cellId, nDim - 1) << " FV " << a_coordinate(cellId, 0) << " "
         << a_coordinate(cellId, 1) << " " << a_coordinate(cellId, nDim - 1) << " / " << a_level(cellId) << " "
         << c_cellLengthAtLevel(a_level(cellId)) << " " << side;

    std::copy_n(&recCoord[0], nDim, &dummyCoord[0]);
    grid().rotateCartesianCoordinates(dummyCoord, (-side * angle));
    cerr << " / Halo " << dummyCoord[0] << " " << dummyCoord[1] << " " << dummyCoord[nDim - 1] << endl;
  }
#endif

  MInt contCell = -1;
  if(this->inCell(cellId, recCoord)) {
    contCell = cellId;
  } else {
    MInt counter = grid().getAdjacentGridCells(cellId, 1, nghbrList, (a_level(cellId) - 1), 2);
    for(MInt n = 0; n < counter; n++) {
      MInt nghbrId = nghbrList[n];
      if(this->inCell(nghbrId, recCoord)) {
        contCell = nghbrId;
        break;
      }
    }
  }

  if(contCell < 0) {
    MInt counter = grid().getAdjacentGridCells(cellId, 1, nghbrList, (a_level(cellId) - 1), 2);
    cerr << domainId() << " No contCell"
         << " " << cellId << "/" << c_globalId(cellId) << " " << a_level(cellId) << " G " << c_coordinate(cellId, 0)
         << " " << c_coordinate(cellId, 1) << " " << c_coordinate(cellId, nDim - 1) << " S " << a_coordinate(cellId, 0)
         << " " << a_coordinate(cellId, 1) << " " << a_coordinate(cellId, nDim - 1) << " R " << recCoord[0] << " "
         << recCoord[1] << " " << recCoord[2] << endl;
    for(MInt n = 0; n < counter; n++) {
      MInt nghbrId = nghbrList[n];
      cerr << "Nghbr: " << n << "/" << (counter - 1) << " " << nghbrId << "/" << c_globalId(nghbrId) << " "
           << a_coordinate(nghbrId, 0) << " " << a_coordinate(nghbrId, 1) << " " << a_coordinate(nghbrId, nDim - 1)
           << endl;
    }
    mTerm(1, AT_, "No containing cell found?");
  }

  MInt contCellLC = contCell;
  contCellLC = grid().findContainingLeafCell(recCoord, contCell);
  MInt cellIdLC = cellId;
  if(c_noChildren(cellId) > 0) {
    if(this->inCell(cellId, recCoord)) {
      cellIdLC = grid().findContainingLeafCell(recCoord, cellId);
    } else {
      // In this case haloCell is a bndryCell and a_hasProperty(haloCell, SolverCell::IsNotGradient) = true.
      MInt nextId = cellId;
      for(MInt l = 0; l < (maxLevel() - a_level(cellId)); l++) {
        MFloat minDist = numeric_limits<MFloat>::max();
        MInt closestChild = -1;
        for(MInt child = 0; child < grid().m_maxNoChilds; child++) {
          const MInt childId = c_childId(nextId, child);
          if(childId < 0) {
            continue;
          }
          MFloat dist = F0;
          for(MInt d = 0; d < nDim; d++) {
            dist += pow(recCoord[d] - c_coordinate(childId, d), F2);
          }
          if(dist < minDist) {
            closestChild = childId;
          }
        }
        nextId = closestChild;
      }
      cellIdLC = nextId;
    }
  }

  if(a_isPeriodic(contCellLC)) {
    mTerm(1, "azimuthal window cell is isPeriodic!");
  }

  // No interp can be specified for 90 degree periodicity
  MBool noInterp = Context::getSolverProperty<MBool>("noInterp", m_solverId, AT_);
  if(noInterp) {
    m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst] = contCellLC;
    m_noAzimuthalReconstNghbrs[offset]++;
    m_azimuthalRecConsts[offset * m_maxNoAzimuthalRecConst] = F1;
    return;
  }

  // Add contCellLC to recNghbrs
  if(a_hasProperty(contCellLC, SolverCell::IsOnCurrentMGLevel)) {
    m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst + m_noAzimuthalReconstNghbrs[offset]] = contCellLC;
    m_noAzimuthalReconstNghbrs[offset]++;
  }
  if(cellIdLC != contCellLC && a_hasProperty(cellIdLC, SolverCell::IsOnCurrentMGLevel)) {
    m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst + m_noAzimuthalReconstNghbrs[offset]] = cellIdLC;
    m_noAzimuthalReconstNghbrs[offset]++;
  }

  // Add bndryGhostCell
  if(mode == 0 && a_bndryId(contCellLC) > -1) {
    for(MInt srfc = 0; srfc < m_bndryCells->a[a_bndryId(contCellLC)].m_noSrfcs; srfc++) {
      MInt ghostCellId = m_fvBndryCnd->m_bndryCells->a[a_bndryId(contCellLC)].m_srfcVariables[srfc]->m_ghostCellId;
      if(ghostCellId < 0) mTerm(1, AT_, "ghostCellId not set!");
      m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst + m_noAzimuthalReconstNghbrs[offset]] = ghostCellId;
      m_noAzimuthalReconstNghbrs[offset]++;
    }
  }

  MInt axDir = grid().raw().m_azimuthalAxialDir;
  const MInt counter = grid().getAdjacentGridCells(cellIdLC, 2, nghbrList, a_level(cellIdLC), 2);
  MInt nghbrTmpCnt = 0;
  MInt dbgCnt = 0;
  for(MInt k = 0; k < counter; k++) {
    MInt nghbrId = nghbrList[k];
    if(nghbrId < 0) continue;
    if(a_isPeriodic(nghbrId)) mTerm(1, "azimuthal recNghbr is periodic! Increase cutOffNmbrLayers");
    if(!a_hasProperty(nghbrId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(nghbrId == contCellLC) {
      continue;
    }
    if(nghbrId == cellIdLC) {
      continue;
    }
    if(m_planeInterp
       && abs(a_coordinate(nghbrId, axDir) - recCoord[axDir]) / c_cellLengthAtLevel(a_level(contCellLC)) > F1B2) {
      continue;
    }

    dbgCnt++;
    if(m_noAzimuthalReconstNghbrs[offset] >= m_maxNoAzimuthalRecConst) {
      cerr << "too many rec nghbrs " << contCellLC << "/" << c_globalId(contCellLC) << " " << dbgCnt << " "
           << m_maxNoAzimuthalRecConst << " " << c_coordinate(contCellLC, 0) << " " << c_coordinate(contCellLC, 1)
           << " " << c_coordinate(contCellLC, 2) << endl;
      continue;
    }

    m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst + m_noAzimuthalReconstNghbrs[offset]] = nghbrId;
    m_noAzimuthalReconstNghbrs[offset]++;
    nghbrTmpCnt++;
  }

  // This handels inactive cells, i.e., ls-value < 0 in moving Bndry cases.
  if(nghbrTmpCnt == 0 && !a_hasProperty(contCellLC, SolverCell::IsNotGradient)) {
    m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst] = cellIdLC;
    m_noAzimuthalReconstNghbrs[offset] = 1;
    m_azimuthalRecConsts[offset * m_maxNoAzimuthalRecConst] = F1;
    return;
  }

  if(nghbrTmpCnt == 0) {
    cerr << "D:" << domainId() << " " << cellId << "/" << c_globalId(cellId) << " " << contCell << "/"
         << c_globalId(contCell) << " " << c_level(contCell) << " " << c_noChildren(contCell) << " "
         << c_coordinate(contCell, 0) << " " << c_coordinate(contCell, 1) << " " << c_coordinate(contCell, nDim - 1)
         << " " << contCellLC << "/" << c_globalId(contCellLC) << " " << c_level(contCellLC) << " "
         << c_coordinate(contCellLC, 0) << " " << c_coordinate(contCellLC, 1) << " "
         << c_coordinate(contCellLC, nDim - 1) << endl;
    mTerm(1, "Cell without neighbors?");
  }

  const MInt noNghbrIds = m_noAzimuthalReconstNghbrs[offset];

  // Compute and store the reconstruction constants
  MBool nonlinear = true; // false;
  MInt recDim = nDim + 1;
  if(nonlinear) {
    if(m_planeInterp) {
      recDim = 2 * nDim; // Plane
    } else {
      recDim = 3 * nDim + 1;
    }
  }
  MFloatScratchSpace tmpA(m_maxNoAzimuthalRecConst, recDim, AT_, "tmpA");
  MFloatScratchSpace tmpC(recDim, m_maxNoAzimuthalRecConst, AT_, "tmpC");
  MFloatScratchSpace weights(m_maxNoAzimuthalRecConst, AT_, "weights");

  const MFloat normalizationFactor = FPOW2(a_level(contCellLC)) / c_cellLengthAtLevel(0);
  weights.fill(F0);

  // loop over least-squares cell cluster
  for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
    MInt recId = m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst + nghbr];

    MInt dimCnt = 0;

    MFloat fac = F1; // pow(F1B2, (MInt) (a_coordinate(recId,axDir) - recCoord[axDir]) /
                     // c_cellLengthAtLevel(a_level(contCellLC)));
    if(!a_isBndryGhostCell(recId) && a_isBndryCell(recId)) {
      const MFloat vf = a_cellVolume(recId) / c_cellVolumeAtLevel(a_level(recId));
      fac = maia::math::deltaFun(vf, 1e-6, 0.1);
    }

    tmpA(nghbr, dimCnt) = F1;
    dimCnt++;

    MFloat dxdx = F0;
    MFloat dx[nDim];
    if(m_planeInterp) {
      for(MInt i = 0; i < (nDim - 1); i++) {
        MInt perDir1 = grid().azimuthalDir(i);
        dx[i] = (a_coordinate(recId, perDir1) - recCoord[perDir1]) * normalizationFactor;
        dxdx += POW2(a_coordinate(recId, perDir1) - recCoord[perDir1]);
      }
      for(MInt i = 0; i < (nDim - 1); i++) {
        tmpA(nghbr, dimCnt) = dx[i];
        dimCnt++;
      }
    } else {
      for(MInt i = 0; i < nDim; i++) {
        dx[i] = (a_coordinate(recId, i) - recCoord[i]) * normalizationFactor;
        dxdx += POW2(a_coordinate(recId, i) - recCoord[i]);
      }
      for(MInt i = 0; i < nDim; i++) {
        tmpA(nghbr, dimCnt) = dx[i];
        dimCnt++;
      }
    }

    weights[nghbr] = fac * maia::math::RBF(dxdx, POW2(c_cellLengthAtCell(contCellLC)));

    if(nonlinear) {
      if(m_planeInterp) {
        for(MInt i = 0; i < (nDim - 1); i++) {
          MInt perDir1 = grid().azimuthalDir(i);
          tmpA(nghbr, dimCnt) = 0.5 * POW2((a_coordinate(recId, perDir1) - recCoord[perDir1]) * normalizationFactor);
          dimCnt++;
        }
        for(MInt i = 0; i < (nDim - 1); i++) {
          MInt perDir1 = grid().azimuthalDir(i);
          for(MInt j = i + 1; j < (nDim - 1); j++) {
            MInt perDir2 = grid().azimuthalDir(j);
            tmpA(nghbr, dimCnt) = (a_coordinate(recId, perDir2) - recCoord[perDir2])
                                  * (a_coordinate(recId, perDir1) - recCoord[perDir1]) * POW2(normalizationFactor);
            dimCnt++;
          }
        }
      } else {
        for(MInt i = 0; i < nDim; i++) {
          tmpA(nghbr, dimCnt) = 0.5 * POW2((a_coordinate(recId, i) - recCoord[i]) * normalizationFactor);
          dimCnt++;
        }
        for(MInt i = 0; i < nDim; i++) {
          for(MInt j = i + 1; j < nDim; j++) {
            tmpA(nghbr, dimCnt) = (a_coordinate(recId, j) - recCoord[j]) * (a_coordinate(recId, i) - recCoord[i])
                                  * POW2(normalizationFactor);
            dimCnt++;
          }
        }
      }
    }
    ASSERT(dimCnt == recDim, "");
  }

  const MInt rank = maia::math::invertR(tmpA, weights, tmpC, noNghbrIds, recDim);
  if(rank < min(noNghbrIds, recDim)) {
    cerr << domainId() << ": QRD failed for azimuthal periodic cell " << cellId << "(" << c_globalId(cellId) << ") "
         << a_isHalo(cellId) << " " << a_level(cellId) << " " << c_noChildren(cellId) << " " << noNghbrIds << endl;
    cerr << "G: (" << a_coordinate(cellId, 0) << ", " << a_coordinate(cellId, 1) << ", "
         << a_coordinate(cellId, nDim - 1) << ") " << endl;
    cerr << "R: (" << recCoord[0] << ", " << recCoord[1] << ", " << recCoord[2] << "), "
         << m_geometry->pointIsInside(recCoord) << " " << a_hasProperty(cellId, SolverCell::IsInactive) << endl;
    MFloat angle = grid().azimuthalAngle();
    MInt side = grid().determineAzimuthalBoundarySide(recCoord);
    grid().rotateCartesianCoordinates(recCoord, (side * angle));
    cerr << " M " << contCellLC << "(" << c_globalId(contCellLC) << ")"
         << " " << a_bndryId(contCellLC) << " " << a_coordinate(contCellLC, 0) << " " << a_coordinate(contCellLC, 1)
         << " " << a_coordinate(contCellLC, nDim - 1) << " H " << recCoord[0] << " " << recCoord[1] << " "
         << recCoord[nDim - 1] << endl;

    for(MInt i = 0; i < noNghbrIds; i++) {
      for(MInt j = 0; j < recDim; j++) {
        cerr << " " << tmpA(i, j);
      }
      cerr << endl;
    }
    mTerm(1, AT_, "Error in matrix inverse!");
  }

  for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
    MInt recId = m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst + nghbr];
    ASSERT(!a_isPeriodic(recId), "ERROR");

    // First entry is not normalized!
    m_azimuthalRecConsts[offset * m_maxNoAzimuthalRecConst + nghbr] = tmpC(0, nghbr); // * normalizationFactor;
  }

  const MInt condNum = maia::math::frobeniusMatrixNormSquared(tmpA, noNghbrIds, recDim);
  if(condNum < F0 || condNum > 1e7 || std::isnan(condNum)) {
    cerr << domainId() << " SVD decomposition for azimuthal periodic windowCell " << contCell << "/"
         << c_globalId(contCell) << " level " << a_level(contCell) << " with large condition number: " << condNum << " "
         << noNghbrIds << "x" << recDim << " "
         << a_cellVolume(contCell) / pow(c_cellLengthAtCell(contCell), (MFloat)nDim) << " coords "
         << a_coordinate(contCell, 0) << ", " << a_coordinate(contCell, 1) << ", " << a_coordinate(contCell, 2)
         << " bndryId " << a_bndryId(contCell) << endl;
  }
}

/** \brief Initialize the azimuthal periodic near boundary exchange
 * \author Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvCartesianSolverXD<nDim, SysEqn>::initAzimuthalNearBoundaryExchange(MIntScratchSpace& activeFlag) {
  TRACE();

  MUint rcvSize = maia::mpi::getBufferSize(m_azimuthalMaxLevelWindowCells);
  MIntScratchSpace windowData(rcvSize, AT_, "windowData");
  windowData.fill(0);
  MUint sndSize = maia::mpi::getBufferSize(m_azimuthalMaxLevelHaloCells);
  MIntScratchSpace haloData(sndSize, AT_, "haloData");
  haloData.fill(0);

  m_fvBndryCnd->m_azimuthalNearBoundaryWindowCells.resize(grid().noAzimuthalNeighborDomains());
  m_fvBndryCnd->m_azimuthalNearBoundaryWindowMap.resize(grid().noAzimuthalNeighborDomains());
  m_fvBndryCnd->m_azimuthalNearBoundaryHaloCells.resize(grid().noAzimuthalNeighborDomains());

  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    m_fvBndryCnd->m_azimuthalNearBoundaryWindowCells[i].clear();
    m_fvBndryCnd->m_azimuthalNearBoundaryWindowMap[i].clear();
    m_fvBndryCnd->m_azimuthalNearBoundaryHaloCells[i].clear();
  }

  if(grid().noAzimuthalNeighborDomains() > 0) {
    MInt sndCnt = 0;
    for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
      for(MUint j = 0; j < m_azimuthalMaxLevelHaloCells[i].size(); j++) {
        MInt cellId = m_azimuthalMaxLevelHaloCells[i][j];
        if(activeFlag[cellId] > 0) {
          ASSERT(a_isPeriodic(cellId), "");
          m_fvBndryCnd->m_azimuthalNearBoundaryHaloCells[i].push_back(cellId);
          haloData[sndCnt] = 1;
        }
        sndCnt++;
      }
    }

    // Exchange
    maia::mpi::exchangeBuffer(grid().azimuthalNeighborDomains(), m_azimuthalMaxLevelWindowCells,
                              m_azimuthalMaxLevelHaloCells, mpiComm(), haloData.getPointer(), windowData.getPointer(),
                              1);

    MInt rcvCnt = 0;
    for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
      for(MUint j = 0; j < m_azimuthalMaxLevelWindowCells[i].size(); j++) {
        MInt cellId = m_azimuthalMaxLevelWindowCells[i][j];
        MInt offset = m_azimuthalMaxLevelWindowMap[i][j];
        if(windowData[rcvCnt] > 0) {
          m_fvBndryCnd->m_azimuthalNearBoundaryWindowCells[i].push_back(cellId);
          m_fvBndryCnd->m_azimuthalNearBoundaryWindowMap[i].push_back(offset);

          MInt noNghbrIds = m_noAzimuthalReconstNghbrs[offset];
          for(MInt n = 0; n < noNghbrIds; n++) {
            MInt recId = m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst + n];
            activeFlag[recId] = 1;
          }
        }
        // m_azimuthalHaloActive[offset] = windowData[rcvCnt];
        rcvCnt++;
      }
    }
  }

  if(m_azimuthalRemappedNeighborDomains.size() > 0) {
    MInt offset = maia::mpi::getBufferSize(grid().azimuthalWindowCells());
    for(MUint i = 0; i < m_azimuthalRemappedNeighborDomains.size(); i++) {
      for(MUint j = 0; j < m_azimuthalRemappedWindowCells[i].size(); j++) {
        MInt noNghbrIds = m_noAzimuthalReconstNghbrs[offset];
        for(MInt n = 0; n < noNghbrIds; n++) {
          MInt recId = m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst + n];
          activeFlag[recId] = 1;
        }

        offset++;
      }
    }
  }
  m_azimuthalNearBndryInit = true;
}


/** \brief Performs the nearBoundaryExchange for azimuthal periodic window/halo cells
 * \author Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvCartesianSolverXD<nDim, SysEqn>::azimuthalNearBoundaryExchange() {
  TRACE();

  if(!m_azimuthalRecConstSet) mTerm(1, AT_, "Azimuthal reconstruction constants not initialized!");

  MInt noVars = m_sysEqn.CV->noVariables;

  MUint sndSize = mMax(maia::mpi::getBufferSize(m_fvBndryCnd->m_azimuthalNearBoundaryWindowCells),
                       maia::mpi::getBufferSize(m_azimuthalRemappedWindowCells));
  MFloatScratchSpace windowData(sndSize * noVars, AT_, "windowData");
  windowData.fill(0);
  MUint rcvSize = mMax(maia::mpi::getBufferSize(m_fvBndryCnd->m_azimuthalNearBoundaryHaloCells),
                       maia::mpi::getBufferSize(m_azimuthalRemappedHaloCells));
  MFloatScratchSpace haloData(rcvSize * noVars, AT_, "windowData");
  haloData.fill(0);

  MInt sndCnt = 0;
  MInt rcvCnt = 0;
  if(grid().noAzimuthalNeighborDomains() > 0) {
    for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
      for(MUint j = 0; j < m_fvBndryCnd->m_azimuthalNearBoundaryWindowCells[i].size(); j++) {
        MInt cellId = m_fvBndryCnd->m_azimuthalNearBoundaryWindowCells[i][j];
        MInt offset = m_fvBndryCnd->m_azimuthalNearBoundaryWindowMap[i][j];
        MInt noNghbrIds = m_noAzimuthalReconstNghbrs[offset];
        for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
          MInt recId = m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst + nghbr];
          if(a_isBndryGhostCell(recId)) {
            setConservativeVariables(recId);
          }
#ifndef NDEBUG
          checkAzimuthalRecNghbrConsistency(recId);
#endif
        }

        // loop over least-squares cell cluster
        interpolateAzimuthalData(&windowData[sndCnt * noVars], offset, noVars, &a_variable(0, 0));
        // Transform cartesian velocities
        MInt side = m_azimuthalBndrySide[offset];
        rotateVectorAzimuthal(side, &windowData[sndCnt * noVars], noVars, m_rotIndVarsCV);

        if(windowData[sndCnt * noVars + m_sysEqn.CV->RHO] < F0
           && (a_cellVolume(cellId) / pow(c_cellLengthAtLevel(a_level(cellId)), 3) > m_fvBndryCnd->m_volumeLimitWall)) {
          cerr << globalTimeStep << "/" << m_RKStep << " Window data CV " << domainId() << " " << cellId << "/"
               << c_globalId(cellId) << " " << c_level(cellId) << " " << side << " "
               << a_hasProperty(cellId, SolverCell::IsSplitChild) << " " << a_coordinate(cellId, 0) << " "
               << a_coordinate(cellId, 1) << " " << a_coordinate(cellId, nDim - 1);
          for(MInt v = 0; v < noVars; v++) {
            cerr << " /" << v << " " << windowData[sndCnt * noVars + v] << " " << a_variable(cellId, v);
          }
          cerr << endl;

          for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
            MInt recId = m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst + nghbr];
            cerr << "Window nghbr " << domainId() << " " << recId << "/";
            if(a_isBndryGhostCell(recId)) {
              cerr << " ";
            } else {
              cerr << c_globalId(recId) << " " << a_level(recId);
            }
            cerr << " " << a_coordinate(recId, 0) << " " << a_coordinate(recId, 1) << " "
                 << a_coordinate(recId, nDim - 1) << " "
                 << m_azimuthalRecConsts[offset * m_maxNoAzimuthalRecConst + nghbr] << " "
                 << a_variable(recId, m_sysEqn.CV->RHO) << " " << a_isHalo(recId) << " " << a_isPeriodic(recId) << " "
                 << (a_cellVolume(cellId) / pow(c_cellLengthAtLevel(a_level(cellId)), 3)
                     > m_fvBndryCnd->m_volumeLimitWall)
                 << endl;
          }
        }

        sndCnt++;
      }
    }

    // Exchange
    maia::mpi::exchangeBuffer(grid().azimuthalNeighborDomains(), m_fvBndryCnd->m_azimuthalNearBoundaryHaloCells,
                              m_fvBndryCnd->m_azimuthalNearBoundaryWindowCells, mpiComm(), windowData.getPointer(),
                              haloData.getPointer(), noVars);

    // Extract
    for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
      for(MUint j = 0; j < m_fvBndryCnd->m_azimuthalNearBoundaryHaloCells[i].size(); j++) {
        MInt cellId = m_fvBndryCnd->m_azimuthalNearBoundaryHaloCells[i][j];
        for(MInt v = 0; v < noVars; v++) {
          a_variable(cellId, v) = haloData[rcvCnt + v];
        }
        if(a_variable(cellId, m_sysEqn.CV->RHO) < F0) {
          cerr << domainId() << ": EXC Halo CV " << cellId << "/" << c_globalId(cellId) << " " << a_bndryId(cellId)
               << " " << a_level(cellId) << " /r " << a_variable(cellId, m_sysEqn.CV->RHO) << " "
               << a_coordinate(cellId, 0) << " " << a_coordinate(cellId, 1) << " " << a_coordinate(cellId, nDim - 1)
               << " " << a_hasProperty(cellId, SolverCell::IsSplitChild) << " "
               << a_hasProperty(cellId, SolverCell::IsSplitCell) << endl;
        }

        rcvCnt += noVars;
      }
    }
  }


  // Remapped azimuthal window cells
  if(m_azimuthalRemappedNeighborDomains.size() > 0) {
    windowData.fill(F0);
    haloData.fill(F0);
    sndCnt = 0;
    MInt offset = maia::mpi::getBufferSize(grid().azimuthalWindowCells());
    for(MUint i = 0; i < m_azimuthalRemappedNeighborDomains.size(); i++) {
      for(MUint j = 0; j < m_azimuthalRemappedWindowCells[i].size(); j++) {
        MInt cellId = m_azimuthalRemappedWindowCells[i][j];

        MInt noNghbrIds = m_noAzimuthalReconstNghbrs[offset];
        for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
          MInt recId = m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst + nghbr];
          if(a_isBndryGhostCell(recId)) {
            setConservativeVariables(recId);
          }
#ifndef NDEBUG
          checkAzimuthalRecNghbrConsistency(recId);
#endif
        }
        // loop over least-squares cell cluster
        interpolateAzimuthalData(&windowData[sndCnt * noVars], offset, noVars, &a_variable(0, 0));
        // Transform cartesian velocities
        MInt side = m_azimuthalBndrySide[offset];
        rotateVectorAzimuthal(side, &windowData[sndCnt * noVars], noVars, m_rotIndVarsCV);

        if(windowData[sndCnt * noVars + m_sysEqn.CV->RHO] < F0
           && (a_cellVolume(cellId) / pow(c_cellLengthAtLevel(a_level(cellId)), 3) > m_fvBndryCnd->m_volumeLimitWall)) {
          cerr << "Window data CV Rem " << domainId() << " " << cellId << "/" << c_globalId(cellId) << " "
               << c_level(cellId) << " " << a_hasProperty(cellId, SolverCell::IsSplitChild) << " "
               << a_coordinate(cellId, 0) << " " << a_coordinate(cellId, 1) << " " << a_coordinate(cellId, nDim - 1);
          for(MInt v = 0; v < noVars; v++) {
            cerr << " /" << v << " " << windowData[sndCnt * noVars + v] << " " << a_variable(cellId, v);
          }
          cerr << endl;

          for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
            MInt recId = m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst + nghbr];
            cerr << "Window nghbr " << domainId() << " " << recId << "/";
            if(a_isBndryGhostCell(recId)) {
              cerr << " ";
            } else {
              cerr << c_globalId(recId) << " " << a_level(recId);
            }
            cerr << " " << a_coordinate(recId, 0) << " " << a_coordinate(recId, 1) << " "
                 << a_coordinate(recId, nDim - 1) << " "
                 << m_azimuthalRecConsts[offset * m_maxNoAzimuthalRecConst + nghbr] << " "
                 << a_variable(recId, m_sysEqn.CV->RHO) << " " << a_isHalo(recId) << " " << a_isPeriodic(recId) << " "
                 << (a_cellVolume(cellId) / pow(c_cellLengthAtLevel(a_level(cellId)), 3)
                     > m_fvBndryCnd->m_volumeLimitWall)
                 << endl;
          }
        }

        sndCnt++;
        offset++;
      }
    }

    // Exchange
    maia::mpi::exchangeBuffer(m_azimuthalRemappedNeighborDomains, m_azimuthalRemappedHaloCells,
                              m_azimuthalRemappedWindowCells, mpiComm(), windowData.getPointer(), haloData.getPointer(),
                              noVars);

    // Extract
    rcvCnt = 0;
    for(MUint i = 0; i < m_azimuthalRemappedNeighborDomains.size(); i++) {
      for(MUint j = 0; j < m_azimuthalRemappedHaloCells[i].size(); j++) {
        MInt cellId = m_azimuthalRemappedHaloCells[i][j];
        for(MInt v = 0; v < noVars; v++) {
          a_variable(cellId, v) = haloData[rcvCnt + v];
        }
        rcvCnt += noVars;
      }
    }
  }
}

/** \brief Performs the nearBoundaryReverseExchange for azimuthal periodic window/halo cells
 * \author Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvCartesianSolverXD<nDim, SysEqn>::azimuthalNearBoundaryReverseExchange() {
  TRACE();

  MInt noVars = m_sysEqn.CV->noVariables;

  MUint sndSize = mMax(maia::mpi::getBufferSize(m_fvBndryCnd->m_azimuthalNearBoundaryWindowCells),
                       maia::mpi::getBufferSize(m_azimuthalRemappedWindowCells));
  MFloatScratchSpace windowData(sndSize * noVars, AT_, "windowData");
  windowData.fill(0);
  MUint rcvSize = mMax(maia::mpi::getBufferSize(m_fvBndryCnd->m_azimuthalNearBoundaryHaloCells),
                       maia::mpi::getBufferSize(m_azimuthalRemappedHaloCells));
  MFloatScratchSpace haloData(rcvSize * noVars, AT_, "windowData");
  haloData.fill(0);

  // Send
  MInt sndCnt = 0;
  MInt rcvCnt = 0;
  if(grid().noAzimuthalNeighborDomains() > 0) {
    for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
      for(MUint j = 0; j < m_fvBndryCnd->m_azimuthalNearBoundaryHaloCells[i].size(); j++) {
        MInt cellId = m_fvBndryCnd->m_azimuthalNearBoundaryHaloCells[i][j];
        for(MInt v = 0; v < noVars; v++) {
          haloData[sndCnt + v] = a_variable(cellId, v);
        }
        sndCnt += noVars;
      }
    }

    // Exchange
    maia::mpi::exchangeBuffer(grid().azimuthalNeighborDomains(), m_fvBndryCnd->m_azimuthalNearBoundaryWindowCells,
                              m_fvBndryCnd->m_azimuthalNearBoundaryHaloCells, mpiComm(), haloData.getPointer(),
                              windowData.getPointer(), noVars);

    // Extract
    for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
      for(MUint j = 0; j < m_fvBndryCnd->m_azimuthalNearBoundaryWindowCells[i].size(); j++) {
        MInt offset = m_fvBndryCnd->m_azimuthalNearBoundaryWindowMap[i][j];
        // Transform cartesian velocities
        MInt side = -1 * m_azimuthalBndrySide[offset];
        rotateVectorAzimuthal(side, &windowData[rcvCnt * noVars], noVars, m_rotIndVarsCV);
        // loop over least-squares cell cluster
        interpolateAzimuthalDataReverse(&a_variable(0, 0), offset, noVars, &windowData[rcvCnt * noVars]);

        rcvCnt++;
      }
    }
  }

  // Send Remapped
  if(m_azimuthalRemappedNeighborDomains.size() > 0) {
    windowData.fill(F0);
    haloData.fill(F0);
    sndCnt = 0;
    for(MUint i = 0; i < m_azimuthalRemappedNeighborDomains.size(); i++) {
      for(MUint j = 0; j < m_azimuthalRemappedHaloCells[i].size(); j++) {
        MInt cellId = m_azimuthalRemappedHaloCells[i][j];
        for(MInt v = 0; v < noVars; v++) {
          haloData[sndCnt + v] = a_variable(cellId, v);
        }
        sndCnt += noVars;
      }
    }

    // Exchange
    maia::mpi::exchangeBuffer(m_azimuthalRemappedNeighborDomains, m_azimuthalRemappedWindowCells,
                              m_azimuthalRemappedHaloCells, mpiComm(), haloData.getPointer(), windowData.getPointer(),
                              noVars);

    // Extract
    rcvCnt = 0;
    MInt offset = maia::mpi::getBufferSize(grid().azimuthalWindowCells());
    for(MUint i = 0; i < m_azimuthalRemappedNeighborDomains.size(); i++) {
      for(MUint j = 0; j < m_azimuthalRemappedWindowCells[i].size(); j++) {
        // Transform cartesian velocities
        MInt side = -1 * m_azimuthalBndrySide[offset];
        rotateVectorAzimuthal(side, &windowData[rcvCnt * noVars], noVars, m_rotIndVarsCV);
        // loop over least-squares cell cluster
        interpolateAzimuthalDataReverse(&a_variable(0, 0), offset, noVars, &windowData[rcvCnt * noVars]);

        rcvCnt++;
        offset++;
      }
    }
  }
}

/** \brief Computes and exchanges the azimuthal periodic window/halos
 * \author Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
template <MBool exchangeAll_>
void FvCartesianSolverXD<nDim, SysEqn>::exchangeFloatDataAzimuthal(MFloat* data, MInt noVars,
                                                                   const vector<MInt>& rotIndices) {
  TRACE();

  if(grid().noAzimuthalNeighborDomains() > 0) {
    MUint sndSize = (exchangeAll_) ? maia::mpi::getBufferSize(grid().azimuthalWindowCells())
                                   : maia::mpi::getBufferSize(m_azimuthalMaxLevelWindowCells);
    MFloatScratchSpace windowData(sndSize * noVars, AT_, "windowData");
    windowData.fill(0);
    MUint rcvSize = (exchangeAll_) ? maia::mpi::getBufferSize(grid().azimuthalHaloCells())
                                   : maia::mpi::getBufferSize(m_azimuthalMaxLevelHaloCells);
    MFloatScratchSpace haloData(rcvSize * noVars, AT_, "haloData");
    haloData.fill(0);

    MInt sndCnt = 0;
    for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
      MInt noWindows =
          (exchangeAll_) ? grid().noAzimuthalWindowCells(i) : (signed)m_azimuthalMaxLevelWindowCells[i].size();
      for(MInt j = 0; j < noWindows; j++) {
        MInt cellId = (exchangeAll_) ? grid().azimuthalWindowCell(i, j) : m_azimuthalMaxLevelWindowCells[i][j];
        MInt offset = (exchangeAll_) ? sndCnt : m_azimuthalMaxLevelWindowMap[i][j];
        fillExcBufferAzimuthal(cellId, offset, &windowData[sndCnt * noVars], data, noVars, rotIndices);
        sndCnt++;
      }
    }

    // Exchange
    if(exchangeAll_) {
      maia::mpi::exchangeBuffer(grid().azimuthalNeighborDomains(), grid().azimuthalHaloCells(),
                                grid().azimuthalWindowCells(), mpiComm(), windowData.getPointer(),
                                haloData.getPointer(), noVars);
    } else {
      maia::mpi::exchangeBuffer(grid().azimuthalNeighborDomains(), m_azimuthalMaxLevelHaloCells,
                                m_azimuthalMaxLevelWindowCells, mpiComm(), windowData.getPointer(),
                                haloData.getPointer(), noVars);
    }

    // Extract
    MInt rcvCnt = 0;
    for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
      MInt noHalos = (exchangeAll_) ? grid().noAzimuthalHaloCells(i) : (signed)m_azimuthalMaxLevelHaloCells[i].size();
      for(MInt j = 0; j < noHalos; j++) {
        MInt cellId = (exchangeAll_) ? grid().azimuthalHaloCell(i, j) : m_azimuthalMaxLevelHaloCells[i][j];
        for(MInt v = 0; v < noVars; v++) {
          data[cellId * noVars + v] = haloData[rcvCnt + v];
        }
        rcvCnt += noVars;
      }
    }
  }

  // Handle azimuthal unmapped halos
  exchangeAzimuthalRemappedHaloCells();

  if(exchangeAll_) {
    for(MInt i = 0; i < grid().noAzimuthalUnmappedHaloCells(); i++) {
      MInt cellId = grid().azimuthalUnmappedHaloCell(i);
      reduceData(cellId, data, noVars);
    }
  }
}

/** \brief Exchange the primitive variables in unmapped azimuthal halo cells
 * \author Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvCartesianSolverXD<nDim, SysEqn>::exchangeAzimuthalRemappedHaloCells() {
  TRACE();

  if(m_azimuthalRemappedNeighborDomains.size() == 0) return;

  MInt noVars = PV->noVariables;
  MUint sndSize = maia::mpi::getBufferSize(m_azimuthalRemappedWindowCells);
  MFloatScratchSpace windowData(sndSize * noVars, AT_, "windowData");
  windowData.fill(0);
  MUint rcvSize = maia::mpi::getBufferSize(m_azimuthalRemappedHaloCells);
  MFloatScratchSpace haloData(rcvSize * noVars, AT_, "haloData");
  haloData.fill(0);

  MInt sndCnt = 0;
  MInt offset = maia::mpi::getBufferSize(grid().azimuthalWindowCells());
  for(MUint i = 0; i < m_azimuthalRemappedNeighborDomains.size(); i++) {
    for(MUint j = 0; j < m_azimuthalRemappedWindowCells[i].size(); j++) {
      MInt cellId = m_azimuthalRemappedWindowCells[i][j];
      fillExcBufferAzimuthal(cellId, offset, &windowData[sndCnt * noVars], &a_pvariable(0, 0), noVars, m_rotIndVarsCV);
      sndCnt++;
      offset++;
    }
  }

  // Exchange
  maia::mpi::exchangeBuffer(m_azimuthalRemappedNeighborDomains, m_azimuthalRemappedHaloCells,
                            m_azimuthalRemappedWindowCells, mpiComm(), windowData.getPointer(), haloData.getPointer(),
                            noVars);

  // Extract
  MInt rcvCnt = 0;
  for(MUint i = 0; i < m_azimuthalRemappedNeighborDomains.size(); i++) {
    for(MUint j = 0; j < m_azimuthalRemappedHaloCells[i].size(); j++) {
      MInt cellId = m_azimuthalRemappedHaloCells[i][j];

      for(MInt v = 0; v < noVars; v++) {
        a_pvariable(cellId, v) = haloData[rcvCnt + v];
      }
      rcvCnt += noVars;
    }
  }
}


/** \brief Initializes the maxLevelExchange for azimuthal periodic connection
 * \author Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvCartesianSolverXD<nDim, SysEqn>::initAzimuthalMaxLevelExchange() {
  TRACE();

  if(grid().noAzimuthalNeighborDomains() == 0) return;

  m_azimuthalMaxLevelHaloCells.resize(grid().noAzimuthalNeighborDomains());
  m_azimuthalMaxLevelWindowCells.resize(grid().noAzimuthalNeighborDomains());
  m_azimuthalMaxLevelWindowMap.resize(grid().noAzimuthalNeighborDomains());

  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    m_azimuthalMaxLevelHaloCells[i].clear();
    m_azimuthalMaxLevelWindowCells[i].clear();
    m_azimuthalMaxLevelWindowMap[i].clear();
  }

  MUint rcvSize = maia::mpi::getBufferSize(grid().azimuthalWindowCells());
  MIntScratchSpace windowData(rcvSize, AT_, "windowData");
  windowData.fill(0);
  MUint sndSize = maia::mpi::getBufferSize(grid().azimuthalHaloCells());
  MIntScratchSpace haloData(sndSize, AT_, "haloData");
  haloData.fill(0);

  m_azimuthalHaloActive.clear();
  m_azimuthalHaloActive.assign(rcvSize, 0);

  MInt sndCnt = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    m_azimuthalMaxLevelHaloCells[i].reserve(grid().noAzimuthalHaloCells(i));

    for(MInt j = 0; j < grid().noAzimuthalHaloCells(i); j++) {
      MInt cellId = grid().azimuthalHaloCell(i, j);
      if(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        ASSERT(a_isPeriodic(cellId), "");
        m_azimuthalMaxLevelHaloCells[i].push_back(cellId);
        haloData[sndCnt] = 1;
      }
      sndCnt++;
    }
  }

  // Exchange
  if(grid().noAzimuthalNeighborDomains() > 0) {
    maia::mpi::exchangeBuffer(grid().azimuthalNeighborDomains(), grid().azimuthalWindowCells(),
                              grid().azimuthalHaloCells(), mpiComm(), haloData.getPointer(), windowData.getPointer());
  }

  MInt rcvCnt = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    m_azimuthalMaxLevelWindowCells[i].reserve(grid().noAzimuthalWindowCells(i));

    for(MInt j = 0; j < grid().noAzimuthalWindowCells(i); j++) {
      MInt cellId = grid().azimuthalWindowCell(i, j);
      ASSERT(m_noAzimuthalReconstNghbrs[rcvCnt] >= 1, "");
      if(windowData[rcvCnt] > 0) {
        m_azimuthalMaxLevelWindowCells[i].push_back(cellId);
        m_azimuthalMaxLevelWindowMap[i].push_back(rcvCnt);
      }

      rcvCnt++;
    }
  }
}


/** brief: Interpolate data from azimuthal reconstruction neighbors (window to halo)
 * Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvCartesianSolverXD<nDim, SysEqn>::interpolateAzimuthalData(MFloat* data, MInt offset, MInt noVars,
                                                                 const MFloat* vars) {
  TRACE();

  MInt noNghbrIds = m_noAzimuthalReconstNghbrs[offset];
  for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
    MInt recId = m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst + nghbr];
    for(MInt v = 0; v < noVars; v++) {
      data[v] += m_azimuthalRecConsts[offset * m_maxNoAzimuthalRecConst + nghbr] * vars[recId * noVars + v];
    }
  }
}


/** brief: Interpolate data from azimuthal reconstruction neighbors (halo to window)
 * Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvCartesianSolverXD<nDim, SysEqn>::interpolateAzimuthalDataReverse(MFloat* data, MInt offset, MInt noVars,
                                                                        const MFloat* vars) {
  TRACE();

  MInt noNghbrIds = m_noAzimuthalReconstNghbrs[offset];

  for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
    MInt recId = m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst + nghbr];

    if(a_isBndryGhostCell(recId)) {
      // The first recNghbr is the cell containg the reconstruction coordinate.
      // c.f. rebuildAzimuthalReconstructionConstants
      MInt baseId = m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst];
      recId = baseId;
    }

    for(MInt v = 0; v < noVars; v++) {
      data[recId * noVars + v] += m_azimuthalRecConsts[offset * m_maxNoAzimuthalRecConst + nghbr] * vars[v];
    }
  }
}

/** brief: Rotate vector data for azimuthal periodicity)
 * Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvCartesianSolverXD<nDim, SysEqn>::rotateVectorAzimuthal(MInt side, MFloat* data, MInt noData,
                                                              const std::vector<MInt>& indices) {
  TRACE();

  MFloat phi = grid().azimuthalAngle();
  MInt dir1 = -1;
  MInt dir2 = -1;

  MInt sum = 0;
  for(MInt d = 0; d < noData; d++) {
    if(indices[d] > 0) {
      if(sum == 0) {
        dir1 = d;
      }
      if(sum == 1) {
        dir2 = d;
      }
      sum++;
    }
  }
  if(!(sum == 2)) {
    mTerm(1, AT_, "Vector is only rotated along one axis.");
  }

  MFloatScratchSpace vTmp(noData, AT_, "vTmp");
  for(MInt d = 0; d < noData; d++) {
    vTmp[d] = data[d];
  }

  data[dir1] = cos(phi) * vTmp[dir1] + side * sin(phi) * vTmp[dir2];
  data[dir2] = -side * sin(phi) * vTmp[dir1] + cos(phi) * vTmp[dir2];
}

/** brief: Check if cellId is in nearBoundaryHaloCells.
 * Ensures that cells used in azimuthal reconstruction are properly updated!
 * Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvCartesianSolverXD<nDim, SysEqn>::checkAzimuthalRecNghbrConsistency(MInt cellId) {
  TRACE();

  if(!a_isBndryGhostCell(cellId) && a_isHalo(cellId)) {
    MBool isNearBndry = false;
    for(MInt n = 0; n < noNeighborDomains(); n++) {
      for(MUint m = 0; m < m_fvBndryCnd->m_nearBoundaryHaloCells[n].size(); m++) {
        MInt bndryId = m_fvBndryCnd->m_nearBoundaryHaloCells[n][m];
        if(a_hasProperty(bndryId, SolverCell::IsSplitChild)) bndryId = getAssociatedInternalCell(bndryId);
        if(c_globalId(bndryId) == c_globalId(cellId)) {
          isNearBndry = true;
        }
      }
    }
    if(!isNearBndry) {
      cerr << "Not near bndry! " << domainId() << " " << cellId << "/" << c_globalId(cellId) << " "
           << c_coordinate(cellId, 0) << " " << c_coordinate(cellId, 1) << " " << c_coordinate(cellId, nDim - 1) << " "
           << c_level(cellId);
      for(MInt n = 0; n < noNeighborDomains(); n++) {
        for(MInt m = 0; m < m_noMaxLevelHaloCells[n]; m++) {
          MInt bndryId = m_maxLevelHaloCells[n][m];
          if(c_globalId(bndryId) == c_globalId(cellId)) {
            cerr << " Is maxLevel!";
          }
        }
      }
      cerr << endl;
      mTerm(1, AT_, "Not near bndry");
    }
  }
}

/** brief: See function name
 * Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvCartesianSolverXD<nDim, SysEqn>::setConservativeVarsOnAzimuthalRecCells() {
  TRACE();
  if(grid().noAzimuthalNeighborDomains() == 0) return;

  MInt sndCnt = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MInt j = 0; j < grid().noAzimuthalWindowCells(i); j++) {
      const MInt noNghbrIds = m_noAzimuthalReconstNghbrs[sndCnt];
      for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
        MInt recId = m_azimuthalReconstNghbrIds[sndCnt * m_maxNoAzimuthalRecConst + nghbr];
        setConservativeVariables(recId);
      }
      sndCnt++;
    }
  }
}


/** \brief RHS interpolation method
 *         Apply a stable correction to small-cells RHS
 *         For details see upcoming paper
 *
 *
 * \author Felix Wietbuescher and Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvCartesianSolverXD<nDim, SysEqn>::smallCellRHSCorrection(const MInt /*timerId*/) {
  TRACE();

  const MInt noSmallCells = (signed)m_fvBndryCnd->m_smallCutCells.size();
  const MInt noFVars = FV->noVariables;
  const MInt noCVars = CV->noVariables;
  const MInt noPVars = PV->noVariables;
  ScratchSpace<MFloat> rhsUpdate(noSmallCells * noFVars, AT_, "rhsUpdate");
  // interpolated rhs from all reconstruction neighbors
  MFloatScratchSpace rhsNB(noFVars, AT_, "rhsNB");

  MIntScratchSpace sendBufferCnts(mMax(1, noNeighborDomains()), AT_, "sendBufferCnts");
  MIntScratchSpace recvBufferCnts(mMax(1, noNeighborDomains()), AT_, "recvBufferCnts");
  ScratchSpace<MPI_Request> sendReq(mMax(1, noNeighborDomains()), AT_, "sendReq");
  ScratchSpace<MPI_Request> recvReq(mMax(1, noNeighborDomains()), AT_, "recvReq");

  MFloatScratchSpace rhsSponge(noFVars, AT_, "rhsSponge");

  //-------------

  // 0. Request rhs values of involved halo cells
  {
    sendReq.fill(MPI_REQUEST_NULL);
    recvReq.fill(MPI_REQUEST_NULL);
    sendBufferCnts.fill(0);
    recvBufferCnts.fill(0);
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      sendBufferCnts(i) = noFVars * (signed)m_fvBndryCnd->m_nearBoundaryWindowCells[i].size();
      recvBufferCnts(i) = noFVars * (signed)m_fvBndryCnd->m_nearBoundaryHaloCells[i].size();
      if(m_fvBndryCnd->m_nearBoundaryWindowCells[i].empty()) {
        continue;
      }
      MInt sendBufferCounter = 0;
      for(MUint j = 0; j < m_fvBndryCnd->m_nearBoundaryWindowCells[i].size(); j++) {
        MInt cellId = m_fvBndryCnd->m_nearBoundaryWindowCells[i][j];
        for(MInt v = 0; v < noFVars; v++) {
          m_sendBuffers[i][sendBufferCounter] = a_rightHandSide(cellId, v);
          sendBufferCounter++;
        }
      }
    }
    MInt sendCnt = 0;
    MInt recvCnt = 0;
    if(m_nonBlockingComm) {
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(sendBufferCnts(i) == 0) {
          continue;
        }
        ASSERT(sendBufferCnts(i) <= m_noMaxLevelWindowCells[i] * noFVars, "");
        MPI_Isend(m_sendBuffers[i], sendBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 12, mpiComm(), &sendReq[sendCnt],
                  AT_, "m_sendBuffers[i]");
        sendCnt++;
      }
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(recvBufferCnts(i) == 0) {
          continue;
        }
        ASSERT(recvBufferCnts(i) <= m_noMaxLevelHaloCells[i] * noFVars, "");
        MPI_Irecv(m_receiveBuffers[i], recvBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 12, mpiComm(),
                  &recvReq[recvCnt], AT_, "m_receiveBuffers[i]");
        recvCnt++;
      }
      if(recvCnt > 0) {
        MPI_Waitall(recvCnt, &recvReq[0], MPI_STATUSES_IGNORE, AT_);
      }
    } else {
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(sendBufferCnts(i) == 0) {
          continue;
        }
        ASSERT(sendBufferCnts(i) <= m_noMaxLevelWindowCells[i] * noFVars, "");
        MPI_Issend(m_sendBuffers[i], sendBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 12, mpiComm(), &sendReq[sendCnt],
                   AT_, "m_sendBuffers[i]");
        sendCnt++;
      }
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(recvBufferCnts(i) == 0) {
          continue;
        }
        ASSERT(recvBufferCnts(i) <= m_noMaxLevelHaloCells[i] * noFVars, "");
        MPI_Recv(m_receiveBuffers[i], recvBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 12, mpiComm(),
                 MPI_STATUS_IGNORE, AT_, "m_receiveBuffers[i]");
        recvCnt++;
      }
    }
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_fvBndryCnd->m_nearBoundaryHaloCells[i].empty()) {
        continue;
      }
      MInt recvBufferCounter = 0;
      for(MUint j = 0; j < m_fvBndryCnd->m_nearBoundaryHaloCells[i].size(); j++) {
        MInt cellId = m_fvBndryCnd->m_nearBoundaryHaloCells[i][j];
        for(MInt v = 0; v < noFVars; v++) {
          a_rightHandSide(cellId, v) = m_receiveBuffers[i][recvBufferCounter];
          recvBufferCounter++;
        }
      }
    }
    if(sendCnt > 0) {
      MPI_Waitall(sendCnt, &sendReq[0], MPI_STATUSES_IGNORE, AT_);
    }

#ifndef NDEBUG
    divCheck(1);
#endif
  }

#if !defined NDEBUG || defined _MB_DEBUG_
  MInt nanCnt = 0;
#endif
  // 1) Compute the rhs-Update for all small-cells
  // interpolation based on bndry-reconstructionConstants,
  // which are distance and volume fraction weighted
  // rhs/cellVolumes is the effective variable change in the cell (i.e. dQ/dt)
  for(MInt smallc = 0; smallc < noSmallCells; smallc++) {
    const MInt bndryId = m_fvBndryCnd->m_smallCutCells[smallc];
    ASSERT(std::count(m_fvBndryCnd->m_smallCutCells.begin(), m_fvBndryCnd->m_smallCutCells.end(), bndryId) == 1, "");
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_isPeriodic(cellId)) {
      continue;
    }
    if(a_isHalo(cellId)) {
      continue;
    }
    if(a_hasProperty(cellId, SolverCell::IsPeriodicWithRot)) {
      continue;
    }
    if(a_hasProperty(cellId, SolverCell::IsCutOff) && !m_fvBndryCnd->m_cbcCutOff) {
      continue;
    }

    const MInt noSrfcs = m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs;
    const MInt noRecNghbrs = m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.size();
    if(noRecNghbrs == 0) {
      cerr << domainId() << ": Warning: no reconstruction posible in small cell " << cellId << endl;
      continue;
    }

    for(MInt v = 0; v < noFVars; v++) {
      rhsNB[v] = F0;

      // SmallCell itself and BCs are excluded
      for(MInt n = noSrfcs + 1; n < noRecNghbrs; n++) {
        if(fabs(m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * n]) > m_eps) {
          const MInt recNId = m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n];
          rhsNB[v] += m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * n] * a_FcellVolume(recNId)
                      * a_rightHandSide(recNId, v);
        }

#if !defined NDEBUG || defined _MB_DEBUG_
        if(nanCnt < 100
           && (std::isnan(m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * n])
               || std::isnan(a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n], v)))) {
          cerr << domainId() << ": "
               << " nan detected in smallCellCorrection " << globalTimeStep << "/" << m_RKStep << " "
               << " " << cellId << "(" << c_globalId(cellId) << ") " << n << "/" << noRecNghbrs << " " << v << " "
               << m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n] << "("
               << c_globalId(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n]) << ")"
               << " " << m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * n] << " "
               << a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n], v) << endl;
          nanCnt++;
          if(nanCnt == 100) {
            cerr << domainId() << ": More than 100 nan's, not reporting any more." << endl;
          }
        }
#endif
      }
      rhsUpdate[smallc * noFVars + v] = rhsNB[v];
    }
  }

  // 2. Update smallCell RHS
  for(MInt smallc = 0; smallc < noSmallCells; smallc++) {
    const MInt bndryId = m_fvBndryCnd->m_smallCutCells[(unsigned)smallc];
    ASSERT(std::count(m_fvBndryCnd->m_smallCutCells.begin(), m_fvBndryCnd->m_smallCutCells.end(), bndryId) == 1, "");
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_isPeriodic(cellId)) {
      continue;
    }
    if(a_isHalo(cellId)) {
      continue;
    }
    if(a_hasProperty(cellId, SolverCell::IsPeriodicWithRot)) {
      continue;
    }
    // correct for cbc cutOff cells!
    if(a_hasProperty(cellId, SolverCell::IsCutOff) && !m_fvBndryCnd->m_cbcCutOff) {
      continue;
    }
    ASSERT(maxLevel() >= maxUniformRefinementLevel() && maxLevel() <= maxRefinementLevel(), "");

    MFloat vfrac = a_cellVolume(cellId) / c_cellVolumeAtLevel(maxLevel());
    if(m_localTS) {
      vfrac = a_cellVolume(cellId) / c_cellVolumeAtLevel(a_level(cellId));
    }
    const MFloat volumeLimit = m_fvBndryCnd->m_volumeLimitWall;
    MFloat fac = maia::math::deltaFun(vfrac, 1e-16, volumeLimit);

    // compute additional factor for boundary condition-sponging
    const MFloat volumeLimitSponge = 0.6 * m_fvBndryCnd->m_volumeLimitWall;
    const MFloat facSponge = 0.5 - 0.5 * maia::math::deltaFun(vfrac, 1e-16, volumeLimitSponge);

    // correction for very very small cells:
    // limit the own RHS and increase bndry-cnd sponging for faster convergence
    const MFloat limitValue = 0.000047872 * 1.5 / m_cfl;
    MFloat spongeFactor = 2;
    if(fac < limitValue) {
      fac = limitValue;
      spongeFactor = 20.0;
    }

    // set surfc primary variables for sponging towards surface values
    // take surface averaged variable
    setPrimitiveVariables(cellId);

    const MInt noSrfcs = m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs;
    MFloatScratchSpace pvars(noPVars, AT_, "pvars");
    pvars.fill(0);
    MFloat combSurfArea = 0;
    for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
      combSurfArea += m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
      if(m_fvBndryCnd->m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId == 3007) {
        mTerm(1, AT_, "Not presribed for 3007 bc yet!");
      }
      for(MInt var = 0; var < noPVars; var++) {
        if(m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[var] == BC_DIRICHLET) {
          const MInt ghostCellId = m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
          const MFloat imageVar = F2 * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[var]
                                  - a_pvariable(ghostCellId, var);
          const MFloat imageDist =
              mMax(F0, (mMax(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance,
                             F1B2 * c_cellLengthAtLevel(a_level(cellId)))
                        - m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance));
          const MFloat distSum = imageDist + m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance;
          // interpolate cell variable based on distance average of surface and image-point variable
          pvars(var) += (m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area / distSum
                         * (m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[var] * imageDist
                            + imageVar * m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance));
        } else if(m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[var] == BC_ROBIN) {
          MFloat imageVar = 0;
          for(MInt s = 0; s < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs; s++) {
            // imageVar += a_pvariable(cellId,var) *
            // m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst[n];
            imageVar += m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[var]
                        * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst[s];
          }
          for(MUint n = m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs;
              n < m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.size();
              n++) {
            const MInt nghbrId = m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n];
            imageVar += m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst[n]
                        * a_pvariable(nghbrId, var);
          }
          const MFloat imageDist =
              mMax(F0, (mMax(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance,
                             F1B2 * c_cellLengthAtLevel(a_level(cellId)))
                        - m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance));
          const MFloat distSum = imageDist + m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance;
          pvars(var) += (m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area / distSum
                         * (m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[var] * imageDist
                            + imageVar * m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance));
        } else {
          // use cell variable directly
          pvars(var) += m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area * a_pvariable(cellId, var);
          // use surface gradient to extrapolate value in cell
          // only different from the above when using the image-variable as reference in the bndry-Cnd!
          // const MFloat pValue = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[var] +
          //                      m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance *
          //                      m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[var];
          // pvars(var) += m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area * pValue;
        }
      }
    }
    for(MInt var = 0; var < noPVars; var++) {
      pvars(var) /= combSurfArea;
    }

    // compute rhs-Sponge based on averaged primary variable on all surfaces
    // convert to conservative variables
    MFloatScratchSpace cvars(noCVars, AT_, "cvars");
    MFloat* avars = hasAV ? &a_avariable(cellId, 0) : nullptr;
    sysEqn().computeConservativeVariables(&pvars(0), &cvars(0), avars);

    // and apply sponging based on conservative variables
    rhsSponge[CV->RHO] = 3 * spongeFactor * (a_variable(cellId, CV->RHO) - cvars(CV->RHO));
    for(MInt i = 0; i < nDim; i++) {
      rhsSponge[CV->RHO_VV[i]] = spongeFactor * (a_variable(cellId, CV->RHO_VV[i]) - cvars[CV->RHO_VV[i]]);
    }
    rhsSponge[CV->RHO_E] = spongeFactor * (a_variable(cellId, CV->RHO_E) - cvars[CV->RHO_E]);
    for(MInt v = 0; v < noFVars; v++) {
      a_rightHandSide(cellId, v) = fac * a_rightHandSide(cellId, v) + facSponge * rhsSponge[v] * a_cellVolume(cellId)
                                   + (F1 - fac - facSponge) * rhsUpdate[smallc * noFVars + v] / a_FcellVolume(cellId);
    }
  }
}

/** brief: See function name
 * Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvCartesianSolverXD<nDim, SysEqn>::fillExcBufferAzimuthal(MInt cellId, MInt offset, MFloat* dataDest,
                                                               MFloat* dataSrc, MInt noData,
                                                               const std::vector<MInt>& rotIndex) {
  TRACE();

  if(m_azimuthalRecConstSet) {
    // loop over least-squares cell cluster
    interpolateAzimuthalData(&dataDest[0], offset, noData, &dataSrc[0]);
    // Transform cartesian velocities
    if(rotIndex.size() >= (unsigned)1) {
      MInt side = m_azimuthalBndrySide[offset];
      rotateVectorAzimuthal(side, &dataDest[0], noData, rotIndex);
    }
  } else {
    // cerr << "azimuthalRecConstSet == False; Using nearest neighbor!" << endl;
    for(MInt v = 0; v < noData; v++) {
      dataDest[v] = dataSrc[cellId * noData + v];
    }
    // Transform cartesian velocities
    // m_azimuthalNearBoundarySide is not allocated yet. Therefore, rotation is not possible yet!
  }

  for(MInt v = 0; v < noData; v++) {
    if(!(dataDest[v] >= F0 || dataDest[v] < F0) || std::isnan(dataDest[v])) {
      cerr << globalTimeStep << "/" << m_RKStep << " Window data:" << domainId() << " " << offset << " " << cellId
           << "/" << c_globalId(cellId) << " " << c_level(cellId) << " " << c_coordinate(cellId, 0) << " "
           << c_coordinate(cellId, 1) << " " << c_coordinate(cellId, nDim - 1) << " "
           << (m_levelSetMb ? a_levelSetValuesMb(cellId, 0) : -1) << " // " << v << " " << dataDest[v] << " "
           << dataSrc[cellId * noData + v] << endl;

      if(m_azimuthalRecConstSet) {
        const MInt noNghbrIds = m_noAzimuthalReconstNghbrs[offset];
        for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
          MInt recId = m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst + nghbr];
          if(!(dataSrc[recId * noData + v] >= F0 || dataSrc[recId * noData + v] < F0)
             || std::isnan(dataSrc[recId * noData + v])) {
            cerr << "Rec " << nghbr << "/" << (noNghbrIds - 1) << " " << recId << "/";
            if(!a_isBndryGhostCell(recId)) {
              cerr << c_globalId(recId) << " " << c_level(recId) << " " << c_parentId(recId);
            } else {
              cerr << "- -";
            }
            cerr << " " << a_isHalo(recId) << " " << a_hasProperty(recId, SolverCell::IsCutOff) << " "
                 << a_hasProperty(recId, SolverCell::IsOnCurrentMGLevel) << " " << a_coordinate(recId, 0) << " "
                 << a_coordinate(recId, 1) << " " << a_coordinate(recId, nDim - 1) << " // " << v << " "
                 << dataSrc[recId * noData + v] << " "
                 << m_azimuthalRecConsts[offset * m_maxNoAzimuthalRecConst + nghbr] << endl;
          }
        }
      }
    }
  }
}

//----------------------------------------------------------------------------

/**
 * \brief Returns the length of the domain in the given direction
 * \author Laurent Andre
 */
template <MInt nDim, class SysEqn>
MFloat FvCartesianSolverXD<nDim, SysEqn>::computeDomainLength(MInt direction) {
  MFloat minCoord = std::numeric_limits<MFloat>::max();
  MFloat maxCoord = std::numeric_limits<MFloat>::lowest();
  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    minCoord = mMin(minCoord, a_coordinate(cellId, direction) - F1B2 * c_cellLengthAtLevel(maxRefinementLevel()));
    maxCoord = mMax(maxCoord, a_coordinate(cellId, direction) + F1B2 * c_cellLengthAtLevel(maxRefinementLevel()));
  }
  MPI_Allreduce(MPI_IN_PLACE, &minCoord, 1, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE", "minCoord");
  MPI_Allreduce(MPI_IN_PLACE, &maxCoord, 1, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "maxCoord");
  return maxCoord - minCoord;
}

/**
 * \brief Releases all allocated memory by the solver
 * \author Borja Pedro Beltran
 */
template <MInt nDim, class SysEqn>
void FvCartesianSolverXD<nDim, SysEqn>::releaseMemory() {
  mDeallocate(m_A);
  mDeallocate(m_ATA);
  mDeallocate(m_ATAi);
  mDeallocate(m_cellSurfaceMapping);
  mDeallocate(m_smallCellIds);
  mDeallocate(m_masterCellIds);
  mDeallocate(m_activeCellIds);

  mDeallocate(m_maxLevelHaloCells);
  mDeallocate(m_maxLevelWindowCells);
  mDeallocate(m_noMaxLevelHaloCells);
  mDeallocate(m_noMaxLevelWindowCells);
  mDeallocate(m_sendBuffers);
  mDeallocate(m_receiveBuffers);
  mDeallocate(m_mpi_request);
  mDeallocate(m_sendBuffersNoBlocking);
  mDeallocate(m_receiveBuffersNoBlocking);
  mDeallocate(m_mpi_sendRequest);
  mDeallocate(m_mpi_receiveRequest);

  IF_CONSTEXPR(isDetChem<SysEqn>) {
    mDeallocate(m_detChem.infSpeciesName);
    mDeallocate(m_detChem.infSpeciesMassFraction);
    mDeallocate(m_YInfinity);
    mDeallocate(m_molarMass);
    mDeallocate(m_fMolarMass);
    mDeallocate(m_standardHeatFormation);
  }

  if(m_wmLES) {
    mDeallocate(m_noWMImgPointsSend);
    mDeallocate(m_noWMImgPointsRecv);
    mDeallocate(m_wmImgSendBuffer);
    mDeallocate(m_wmImgRecvBuffer);
    mDeallocate(m_wmImgRecvIdMap);
    mDeallocate(m_mpi_wmRequest);
    mDeallocate(m_mpi_wmSendReq);
    mDeallocate(m_mpi_wmRecvReq);
  }
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::finalizeLESAverage() {
  TRACE();

  IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) return;

  // sort array
  sort(m_LESAverageCells.begin(), m_LESAverageCells.end());

  mAlloc(m_LESVarAverage, m_LESNoVarAverage, "m_LESVarAverage", AT_);

  for(MInt var = 0; var < m_LESNoVarAverage; var++) {
    for(MInt c = 0; c < (MInt)m_LESAverageCells.size(); c++) {
      m_LESVarAverage[var].push_back(F0);
    }
  }

  if(m_calcLESAverage && m_restartLESAverage
     && (globalTimeStep > m_zonalAveragingTimeStep || globalTimeStep > m_averageStartTimeStep)) {
    loadLESAverage();
  } else {
    for(MInt var = 0; var < noVariables(); var++) {
      for(MInt c = 0; c < (MInt)m_LESAverageCells.size(); c++) {
        MInt cellId = m_LESAverageCells[c];
        ASSERT(c < (MInt)m_LESVarAverage[var].size(),
               "Trying to access data [" + to_string(var) + "][" + to_string(c) + "] in m_LESVarAverage with length "
                   + to_string(m_LESVarAverage[var].size()));

        m_LESVarAverage[var][c] = a_pvariable(cellId, var);
      }
    }

    MInt count = 0;
    MInt index = 0;
    for(MInt i = 0; i < nDim; i++) {
      for(MInt j = count; j < nDim; j++) {
        MInt indexAvg = index + noVariables();
        for(MInt c = 0; c < (MInt)m_LESAverageCells.size(); c++) {
          MInt cellId = m_LESAverageCells[c];

          ASSERT(c < (MInt)m_LESVarAverage[indexAvg].size(),
                 "Trying to access data [" + to_string(indexAvg) + "][" + to_string(c)
                     + "] in m_LESVarAverage with length " + to_string(m_LESVarAverage[indexAvg].size()));

          m_LESVarAverage[indexAvg][c] = a_pvariable(cellId, i) * a_pvariable(cellId, j);
        }
        index++;
      }
      count++;
    }
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::calcLESAverage() {
  TRACE();

  IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) return;

  MFloat avgFactor = getAveragingFactor();

  for(MInt var = 0; var < noVariables(); var++) {
    for(MInt c = 0; c < (MInt)m_LESAverageCells.size(); c++) {
      MInt cellId = m_LESAverageCells[c];

      ASSERT(c < (MInt)m_LESVarAverage[var].size(),
             "Trying to access data [" + to_string(var) + "][" + to_string(c) + "] in m_LESVarAverage with length "
                 + to_string(m_LESVarAverage[var].size()) + ", domainId: " + to_string(domainId()));

      m_LESVarAverage[var][c] = avgFactor * a_pvariable(cellId, var) + (1 - avgFactor) * m_LESVarAverage[var][c];
    }
  }

  MInt count = 0;
  MInt index = 0;
  for(MInt i = 0; i < nDim; i++) {
    for(MInt j = count; j < nDim; j++) {
      MInt indexAvg = index + noVariables() + m_averageReconstructNut[0];
      for(MInt c = 0; c < (MInt)m_LESAverageCells.size(); c++) {
        MInt cellId = m_LESAverageCells[c];

        ASSERT(c < (MInt)m_LESVarAverage[indexAvg].size(),
               "Trying to access data [" + to_string(indexAvg) + "][" + to_string(c)
                   + "] in m_LESVarAverage with length " + to_string(m_LESVarAverage[indexAvg].size()));

        m_LESVarAverage[indexAvg][c] = avgFactor * a_pvariable(cellId, i) * a_pvariable(cellId, j)
                                       + (1 - avgFactor) * m_LESVarAverage[indexAvg][c];
      }
      index++;
    }
    count++;
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::loadLESAverage() {
  TRACE();

  IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) return;

  stringstream fn;
  fn.clear();
  if(m_useNonSpecifiedRestartFile) {
    fn << restartDir() << "restartLESAverage" << m_solverId;
  } else {
    fn << restartDir() << "restartLESAverage" << m_solverId << "_" << globalTimeStep;
  }
  fn << ParallelIo::fileExt();

  MString fileName = fn.str();

  if(domainId() == 0) {
    cerr << "loading LES average restart file " << fn.str() << "...";
  }

  using namespace maia::parallel_io;
  ParallelIo parallelIo(fileName, PIO_READ, mpiComm());

  ParallelIo::size_type size = 0;
  ParallelIo::size_type start = 0;
  ParallelIo::size_type count = 0;

  size = parallelIo.getArraySize("avgCellIds");

  start = 0;
  count = size;

  vector<MLong> avgCellIds((MInt)size, -1);
  ScratchSpace<MFloat> LESVar((MInt)size, AT_, "LESVar");

  parallelIo.setOffset(count, start);
  parallelIo.readArray(&avgCellIds[0], "avgCellIds");

  for(MInt var = 0; var < m_LESNoVarAverage; var++) {
    MString s = "LESAverageVar" + to_string(var);
    parallelIo.readArray(&LESVar[0], s);

    for(MInt c = 0; c < (MInt)m_LESAverageCells.size(); c++) {
      MInt cellId = m_LESAverageCells[c];

      if(a_isBndryGhostCell(cellId)) continue;

      MLong gCellId = (MLong)c_globalId(cellId);
      vector<MLong>::iterator findLESGlobalId = find(avgCellIds.begin(), avgCellIds.end(), gCellId);
      if(findLESGlobalId != avgCellIds.end()) {
        MInt dist = std::distance(avgCellIds.begin(), findLESGlobalId);
        m_LESVarAverage[var][c] = LESVar[dist];
      }
    }
  }

  // set bndryGhostCells
  for(MInt c = 0; c < (MInt)m_LESAverageCells.size(); c++) {
    MInt cellId = m_LESAverageCells[c];
    if(a_isBndryCell(cellId)) {
      // find corresponding bndryGhostCell and set the value according to BC
      for(MInt nghbr = 0; nghbr < a_noReconstructionNeighbors(cellId); nghbr++) {
        const MInt recNghbrId = a_reconstructionNeighborId(cellId, nghbr);
        if(a_isBndryGhostCell(recNghbrId)) {
          vector<MInt>::iterator findBndryGhostId =
              find(m_LESAverageCells.begin(), m_LESAverageCells.end(), recNghbrId);
          if(findBndryGhostId != m_LESAverageCells.end()) {
            MInt index = std::distance(m_LESAverageCells.begin(), findBndryGhostId);

            // set values (TODO: only for wall-BC implemented for now)
            for(MInt var = 0; var < noVariables(); var++) {
              m_LESVarAverage[var][index] = -m_LESVarAverage[var][c];
            }
            for(MInt var = noVariables(); var < m_LESNoVarAverage; var++) {
              m_LESVarAverage[var][index] = m_LESVarAverage[var][c];
            }
          }
        }
      }
    }
  }

  if(domainId() == 0) {
    cerr << "done" << endl;
  }
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::saveLESAverage() {
  TRACE();

  IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) return;

  if(domainId() == 0) {
    cerr << "Writing LES average restart file at " << globalTimeStep << "...";
  }

  MLong noAvgCells = 0;
  vector<pair<MInt, MInt>> LESCellsGlobalId;
  for(MInt c = 0; c < (MInt)m_LESAverageCells.size(); c++) {
    MInt cellId = m_LESAverageCells[c];
    if(a_isHalo(cellId)) continue;
    if(a_isPeriodic(cellId)) continue;
    if(a_isBndryGhostCell(cellId)) continue;
    if(a_hasProperty(cellId, FvCell::IsSplitChild)) continue;
    if(a_hasProperty(cellId, FvCell::IsSplitClone)) continue;
    MInt globalLESId = c_globalId(cellId);
    LESCellsGlobalId.emplace_back(make_pair(globalLESId, c));
    noAvgCells++;
  }

  MLong noAvgCellsGlobal = noAvgCells;
  ScratchSpace<MPI_Offset> offsets(noDomains() + 1, AT_, "offsets");
  offsets(0) = 0;
  if(noDomains() > 1) {
    offsets(domainId() + 1) = (MPI_Offset)noAvgCells;

    MPI_Allgather(&noAvgCells, 1, MPI_LONG, &offsets[1], 1, MPI_LONG, mpiComm(), AT_, "noAvgCells", "offsets[1]");

    for(MInt d = 0; d < noDomains(); d++) {
      offsets(d + 1) += offsets(d);
    }
    noAvgCellsGlobal = noAvgCells;

    MPI_Allreduce(MPI_IN_PLACE, &noAvgCellsGlobal, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "noAvgCellsGlobal");

    if(noAvgCellsGlobal != offsets(noDomains())) {
      mTerm(1, AT_, "Dimension mismatch.");
    }
  }

  offsets(noDomains()) = (MPI_Offset)noAvgCellsGlobal;

  stringstream fn;
  fn.clear();
  if(m_useNonSpecifiedRestartFile) {
    fn << outputDir() << "restartLESAverage" << m_solverId;
  } else {
    fn << outputDir() << "restartLESAverage" << m_solverId << "_" << globalTimeStep;
  }
  fn << ParallelIo::fileExt();
  MString fileName = fn.str();

  MLongScratchSpace avgCellIds(noAvgCells, AT_, "avgCellIds");
  for(MInt i = 0; i < noAvgCells; i++) {
    avgCellIds[i] = LESCellsGlobalId[i].first;
  }

  ParallelIo::size_type start = 0;
  ParallelIo::size_type count = 0;

  using namespace maia::parallel_io;
  ParallelIo parallelIo(fileName, PIO_REPLACE, mpiComm());

  count = noAvgCellsGlobal;
  parallelIo.defineArray(PIO_LONG, "avgCellIds", count);
  for(MInt var = 0; var < m_LESNoVarAverage; var++) {
    MString s = "LESAverageVar" + to_string(var);
    parallelIo.defineArray(PIO_FLOAT, s, count);
  }

  start = offsets(domainId());
  count = noAvgCells;
  parallelIo.setOffset(count, start);

  parallelIo.writeArray(avgCellIds.begin(), "avgCellIds");

  ScratchSpace<MFloat> LESVar(noAvgCells, AT_, "LESVar");
  for(MInt var = 0; var < m_LESNoVarAverage; var++) {
    MString s = "LESAverageVar" + to_string(var);
    for(MInt i = 0; i < noAvgCells; i++) {
      LESVar[i] = m_LESVarAverage[var][LESCellsGlobalId[i].second];
    }
    parallelIo.writeArray(LESVar.begin(), s);
  }

  if(domainId() == 0) cerr << "ok" << endl;
}


/** \brief Initializes zonal exchange arrays
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initSTGSponge() {
  TRACE();

  IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) return;

  mAlloc(m_STGSpongeFactor, nDim + 3, "m_STGSpongeFactor", AT_);
  for(MInt i = 0; i < nDim + 3; i++) {
    m_STGSpongeFactor[i].clear();
  }

  for(MInt varId = 0; varId < nDim + 3; varId++) {
    m_STGSpongeFactor[varId].resize(c_noCells());
    for(MInt c = 0; c < c_noCells(); c++) {
      ASSERT(c < (MInt)m_STGSpongeFactor[varId].size(),
             "Trying to access data [" + to_string(varId) + "][" + to_string(c) + "] in m_STGSpongeFactor with length "
                 + to_string(m_STGSpongeFactor[varId].size()));

      m_STGSpongeFactor[varId][c] = F0;
    }
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::initSTGSpongeExchange() {
  TRACE();

  IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) return;

  m_spongeLocations.clear();
  m_spongeCells.clear();

  MInt noSpongeCells = 0;
  MInt noSpongeLocations = 0;

  // ======================================================
  // 1) Determine cells for periodic average
  // ======================================================
  MFloat periodicL = 0;
  MBool first = true;

  for(MInt c = 0; c < (MInt)m_LESAverageCells.size(); c++) {
    MInt cellId = m_LESAverageCells[c];
    if(!c_isLeafCell(cellId)) continue;
    MInt averageDir = abs(m_7901wallDir + m_7901periodicDir - nDim);
    MFloat pos = a_coordinate(cellId, averageDir);
    MFloat halfCellLength = grid().halfCellLength(cellId);

    if(approx(m_7901Position, pos, halfCellLength) && !a_isInactive(cellId)) {
      if(first) {
        periodicL = a_coordinate(cellId, m_7901periodicDir) - F1B3 * halfCellLength;
        first = false;
      }
      if(abs(a_coordinate(cellId, m_7901periodicDir) + halfCellLength - 1e-16 - periodicL) < halfCellLength) {
        m_spongeLocations.push_back(a_coordinate(cellId, m_7901wallDir));
        m_spongeLocations.push_back(a_coordinate(cellId, m_7901periodicDir));
        noSpongeLocations++;
        noSpongeLocations++;
      }
      m_spongeCells.push_back(cellId);
      noSpongeCells++;
    }
  }

  m_noSpongeCells = noSpongeCells;

  // ======================================================
  // 2) Create communicator commSponge
  // ======================================================
  MInt comm_size;
  MPI_Comm_size(mpiComm(), &comm_size);
  std::vector<MInt> spongeCellsperDomain(comm_size);

  if(noDomains() > 1) {
    MPI_Allgather(&noSpongeCells, 1, MPI_INT, &spongeCellsperDomain[0], 1, MPI_INT, mpiComm(), AT_, "noSpongeCells ",
                  "spongeCellsperDomain");
  }

  MInt noInvolvedRanks = 0;
  std::vector<MInt> involvedRanks(comm_size);
  for(MInt i = 0; i < comm_size; i++) {
    if(spongeCellsperDomain[i]) {
      involvedRanks[noInvolvedRanks] = i;
      ++noInvolvedRanks;
    }
  }

  MPI_Comm commSponge;
  MPI_Group group;
  MPI_Group groupSponge;
  MPI_Comm_group(mpiComm(), &group, AT_, "group");
  MPI_Group_incl(group, noInvolvedRanks, &involvedRanks[0], &groupSponge, AT_);
  MPI_Comm_create(mpiComm(), groupSponge, &commSponge, AT_, "commStg");

  m_spongeComm = commSponge;
  m_spongeCommSize = noInvolvedRanks;

  // find all sponge locations locally on ranks containing the comparison plane
  if(m_noSpongeCells > 0) {
    for(MInt i = 0; i < noInvolvedRanks; i++) {
      if(involvedRanks[i] == domainId()) {
        m_spongeRank = i;
        break;
      }
    }

    m_spongeRoot = involvedRanks[0];

    // ======================================================
    // 3) Determine global locations in wall-normal direction for spanwise average
    // ======================================================
    MInt globalNoBcStgLocations = 0;
    MInt globalNoBcStgCells = 0;
    MPI_Allreduce(&noSpongeLocations, &globalNoBcStgLocations, 1, MPI_INT, MPI_SUM, m_spongeComm, AT_,
                  "noSpongeLocations", "globalNoBcStgLocations");

    MPI_Allreduce(&noSpongeCells, &globalNoBcStgCells, 1, MPI_INT, MPI_SUM, m_spongeComm, AT_, "noSpongeCells",
                  "globalNoBcStgCells");

    // ScratchSpace<MFloat> globalBcStgLocations(globalNoBcStgLocations, "globalBcStgLocations", FUN_);
    mAlloc(m_globalBcStgLocationsG, globalNoBcStgLocations, "m_globalBcStgLocationsG", AT_);
    if(m_spongeCommSize > 0) {
      ScratchSpace<MInt> recvbuf(comm_size, "recvbuf", FUN_);
      recvbuf.fill(0);

      MPI_Gather(&noSpongeLocations, 1, MPI_INT, &recvbuf[0], 1, MPI_INT, 0, m_spongeComm, AT_, "noSpongeLocations",
                 "recvbuf");

      ScratchSpace<MInt> displs(comm_size, "displspos", FUN_);
      if(domainId() == m_spongeRoot) {
        MInt offset = 0;
        for(MInt dom = 0; dom < comm_size; dom++) {
          displs[dom] = offset;
          offset += recvbuf[dom];
        }
      }

      MPI_Gatherv(&m_spongeLocations[0], noSpongeLocations, MPI_DOUBLE, &m_globalBcStgLocationsG[0],
                  &recvbuf[m_spongeRank], &displs[m_spongeRank], MPI_DOUBLE, 0, m_spongeComm, AT_, "m_spongeLocations",
                  "globalBcStgLocations");

      MPI_Bcast(&m_globalBcStgLocationsG[0], globalNoBcStgLocations, MPI_DOUBLE, 0, m_spongeComm, AT_,
                "m_globalBcStgLocationsG");

      // for broadcasting to all
      m_globalNoSpongeLocations = globalNoBcStgLocations;
      // if(domainId() == m_spongeRoot){
      //   mAlloc(m_globalBcStgLocationsG, globalNoBcStgLocations, "m_globalBcStgLocationsG", AT_);
      //   for(MInt i = 0; i < globalNoBcStgLocations; i++) {
      //     m_globalBcStgLocationsG[i] = globalBcStgLocations[i];
      //   }
      // }
    }
  }

  // Broadcast sponge root to all
  MPI_Allreduce(MPI_IN_PLACE, &m_spongeRoot, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "m_spongeRoot");

  // Broadcast from sponge root to all
  MInt globalNoBcStgLocationsG = 0;
  if(m_noSpongeCells > 0) {
    globalNoBcStgLocationsG = m_globalNoSpongeLocations;
  }
  MPI_Allreduce(MPI_IN_PLACE, &globalNoBcStgLocationsG, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                "globalNoBcStgLocationsG");

  if(m_noSpongeCells == 0) {
    mAlloc(m_globalBcStgLocationsG, globalNoBcStgLocationsG, "m_globalBcStgLocationsG", AT_);
  }
  MPI_Bcast(&m_globalBcStgLocationsG[0], globalNoBcStgLocationsG, MPI_DOUBLE, m_spongeRoot, mpiComm(), AT_,
            "m_globalBcStgLocationsG");

  m_globalSpongeLocations.clear();
  m_globalNoSpongeLocations = 0;

  for(MInt i = 0; i < globalNoBcStgLocationsG / 2; i++) {
    MFloat L1 = m_globalBcStgLocationsG[2 * i + 0];
    MFloat L2 = m_globalBcStgLocationsG[2 * i + 1];
    auto it =
        std::find_if(m_globalSpongeLocations.begin(), m_globalSpongeLocations.end(),
                     [&L1](const std::pair<MFloat, MFloat>& element) { return approx(element.first, L1, 1e-16); });
    if(it == m_globalSpongeLocations.end()) {
      m_globalSpongeLocations.push_back(make_pair(L1, L2));
      m_globalNoSpongeLocations++;
    }
  }

  sort(m_globalSpongeLocations.begin(), m_globalSpongeLocations.end());

  // ======================================================
  // 4) Determine local cells in periodic locations of global wall-normal locations
  // ======================================================
  if(m_noSpongeCells > 0) {
    mAlloc(m_spongeAverageCellId, m_globalNoSpongeLocations, "m_spongeAverageCellId", FUN_);
    mAlloc(m_globalNoPeriodicExchangeCells, m_globalNoSpongeLocations, "m_globalNoPeriodicExchangeCells", 0, FUN_);

    for(MInt i = 0; i < m_globalNoSpongeLocations; i++) {
      m_spongeAverageCellId[i].clear();
    }

    vector<MInt> noPeriodicExchangeCells(m_globalNoSpongeLocations, F0);

    for(MInt i = 0; i < m_globalNoSpongeLocations; i++) {
      for(MInt c = 0; c < m_noSpongeCells; c++) {
        MInt cellId = m_spongeCells[c];
        if(abs(a_coordinate(cellId, m_7901wallDir) - m_globalSpongeLocations[i].first) < 1e-16) {
          if(!a_isHalo(cellId)) {
            m_spongeAverageCellId[i].push_back(cellId);
            ++noPeriodicExchangeCells[i];
          }
        }
      }
    }

    if(m_spongeCommSize > 0) {
      MPI_Allreduce(&noPeriodicExchangeCells[0], &m_globalNoPeriodicExchangeCells[0], m_globalNoSpongeLocations,
                    MPI_INT, MPI_SUM, m_spongeComm, AT_, "noPeriodicExchangeCells", "m_globalNoPeriodicExchangeCells");
    }
  }

  mAlloc(m_LESPeriodicAverage, m_LESNoVarAverage, m_globalNoSpongeLocations, "m_LESPeriodicAverage", F0, FUN_);
  mAlloc(m_uvErr, m_globalNoSpongeLocations, "m_uvErr", F0, FUN_);
  mAlloc(m_uvRans, m_globalNoSpongeLocations, "m_uvRans", F0, FUN_);
  mAlloc(m_uvInt, m_globalNoSpongeLocations, "m_uvInt", F0, FUN_);
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::readPreliminarySTGSpongeData() {
  TRACE();

  IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) return;

  // load preliminary sponge data and fill m_uvRans
  stringstream fn;
  fn.clear();
  MString fname = Context::getSolverProperty<MString>("preliminarySpongeDataFile", m_solverId, AT_, &fname);
  if(m_spongeRank == 0) cerr << "loading STG preliminary sponge data from " << fname << "...";

  ifstream preliminarySpongeData;
  preliminarySpongeData.open(fname);

  vector<MFloat> data;
  MFloat num;
  string line;

  while(preliminarySpongeData >> num) {
    data.push_back(num);
  }

  // MInt count = 0;
  MInt preliminarySpongeDataVarCount = Context::getSolverProperty<MInt>("preliminarySpongeDataVarCount", m_solverId,
                                                                        AT_, &preliminarySpongeDataVarCount);
  MInt uvIndex = Context::getSolverProperty<MInt>("preliminarySpongeDataUVIndex", m_solverId, AT_, &uvIndex);
  MInt dataCount = data.size() / preliminarySpongeDataVarCount;

  vector<vector<MFloat>> preData(dataCount, vector<MFloat>(preliminarySpongeDataVarCount, 0));

  MInt index = 0;
  for(MInt d = 0; d < dataCount; d++) {
    for(MInt dd = 0; dd < preliminarySpongeDataVarCount; dd++) {
      index = preliminarySpongeDataVarCount * d + dd;
      preData[d][dd] = data[index];
    }
  }

  preliminarySpongeData.close();

  for(MInt i = 0; i < m_globalNoSpongeLocations; i++) {
    MFloat pos = m_globalSpongeLocations[i].first;
    for(MInt d = 0; d < dataCount - 1; d++) {
      // Interpolation
      if(preData[d][0] < pos && preData[d + 1][0] > pos) {
        m_uvRans[i] = preData[d][uvIndex]
                      + (preData[d + 1][uvIndex] - preData[d][uvIndex]) / (preData[d + 1][0] - preData[d][0])
                            * (pos - preData[d][0]);
      }
    }
  }

  if(m_spongeRank == 0) cerr << "ok" << endl;
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::calcPeriodicSpongeAverage() {
  TRACE();

  IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) return;

  for(MInt i = 0; i < m_globalNoSpongeLocations; i++) {
    if(m_zonal) m_uvRans[i] = F0;
    for(MInt var = 0; var < m_LESNoVarAverage; var++) {
      m_LESPeriodicAverage[var][i] = F0;
    }
  }

  if(m_spongeRank > -1) {
    for(MInt i = 0; i < m_globalNoSpongeLocations; i++) {
      for(MInt p = 0; p < (MInt)m_spongeAverageCellId[i].size(); p++) {
        MInt cellId = m_spongeAverageCellId[i][p];
        // find index of cellId
        vector<MInt>::iterator findAvgId = find(m_LESAverageCells.begin(), m_LESAverageCells.end(), cellId);
        if(findAvgId != m_LESAverageCells.end()) {
          MInt avgId = distance(m_LESAverageCells.begin(), findAvgId);
          for(MInt var = 0; var < m_LESNoVarAverage; var++) {
            m_LESPeriodicAverage[var][i] += m_LESVarAverage[var][avgId] / m_globalNoPeriodicExchangeCells[i];
          }
          if(m_zonal) {
            m_uvRans[i] += m_RANSValues[m_noRANSVariables - 1][cellId] / m_globalNoPeriodicExchangeCells[i];
          }
        }
      }
    }

    for(MInt var = 0; var < m_LESNoVarAverage; var++) {
      MPI_Allreduce(MPI_IN_PLACE, m_LESPeriodicAverage[var], m_globalNoSpongeLocations, MPI_DOUBLE, MPI_SUM,
                    m_spongeComm, AT_, "MPI_IN_PLACE", "m_LESPeriodicAverage[var]");
    }

    if(m_zonal) {
      MPI_Allreduce(MPI_IN_PLACE, &m_uvRans[0], m_globalNoSpongeLocations, MPI_DOUBLE, MPI_SUM, m_spongeComm, AT_,
                    "MPI_IN_PLACE", "m_uvRans");
    }

    // calculate m_uvInt and m_uvErr
    for(MInt i = 0; i < m_globalNoSpongeLocations; i++) {
      MFloat uv_LES =
          m_LESPeriodicAverage[noVariables() + 1][i] - m_LESPeriodicAverage[0][i] * m_LESPeriodicAverage[1][i];
      m_uvErr[i] = m_uvRans[i] - uv_LES;
      if(abs(m_uvInt[i]) < m_spongeLimitFactor * abs(m_uvRans[i]) ||
         // if the sign is differnt, allow the integral to get smaller
         m_uvErr[i] * m_uvInt[i] < 1e-16) {
        m_uvInt[i] += timeStep() * m_uvErr[i];
      }
    }
  }

  // broadcast to all
  for(MInt var = 0; var < m_LESNoVarAverage; var++) {
    MPI_Bcast(&m_LESPeriodicAverage[var][0], m_globalNoSpongeLocations, MPI_DOUBLE, m_spongeRoot, mpiComm(), AT_,
              "m_LESPeriodicAverage");
  }
  MPI_Bcast(&m_uvInt[0], m_globalNoSpongeLocations, MPI_DOUBLE, m_spongeRoot, mpiComm(), AT_, "m_uvInt");
  MPI_Bcast(&m_uvErr[0], m_globalNoSpongeLocations, MPI_DOUBLE, m_spongeRoot, mpiComm(), AT_, "m_uvErr");

  if(m_STGSponge) {
    MFloat alpha = 10.0;
    MFloat beta = 2.0;
    // fill m_STGSpongeFactor
    for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
      for(MInt i = 0; i < m_globalNoSpongeLocations; i++) {
        MFloat uv_LES =
            m_LESPeriodicAverage[noVariables() + 1][i] - m_LESPeriodicAverage[0][i] * m_LESPeriodicAverage[1][i];
        MFloat pos = m_globalSpongeLocations[i].first;
        if(approx(pos, a_coordinate(cellId, m_7901wallDir), 1e-16)) {
          for(MInt d = 0; d < nDim; d++) {
            // u - <u>_{z,t}
            m_STGSpongeFactor[d][cellId] = a_pvariable(cellId, d) - m_LESPeriodicAverage[d][i];
          }
          m_STGSpongeFactor[nDim - 1][cellId] = m_uvRans[i];
          // e(y,t)
          m_STGSpongeFactor[nDim][cellId] = m_uvErr[i];
          // r(y,t)
          m_STGSpongeFactor[nDim + 1][cellId] = alpha * m_uvErr[i] + beta * m_uvInt[i];
          // debug: <u'v'>_{z,t}
          m_STGSpongeFactor[nDim + 2][cellId] = uv_LES;
        }
      }
    }
  }
}


/** \brief Initializes zonal exchange arrays
 *
 */
template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::resetZonalLESAverage() {
  TRACE();

  IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) return;

  for(MInt var = 0; var < m_LESNoVarAverage; var++) {
    m_LESVarAverage[var].clear();
    for(auto it = std::begin(m_LESAverageCells); it != std::end(m_LESAverageCells); ++it) {
      m_LESVarAverage[var].push_back(F0);
    }
  }
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::determineLESAverageCells() {
  TRACE();

  IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) return;
  // find LES cells to be averaged
  m_LESAverageCells.clear();

  if(!grid().isActive()) return;

  if(!m_zonal) {
    m_LESNoVarAverage = noVariables() + (nDim - 1) * 3;

    MFloat averagePos = m_7901Position;
    MInt averageDir = abs(m_7901wallDir + m_7901periodicDir - nDim);
    // MInt averageFaceDir = m_7901faceNormalDir;

    if(!std::isinf(m_7901Position)) {
      // positions to find cells for LES average
      m_averagePos.push_back(averagePos);
      m_averageDir.push_back(averageDir);
      m_averageReconstructNut.push_back(false);
    }
  }

  IF_CONSTEXPR(SysEqn::m_noRansEquations == 0) {
    for(MInt p = 0; p < (MInt)m_averagePos.size(); p++) {
      MInt noLESAverageCells = 0;
      for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
        MFloat halfCellLength = grid().halfCellLength(cellId);
        MFloat pos = a_coordinate(cellId, m_averageDir[p]);
        if(approx(m_averagePos[p], pos, halfCellLength)) {
          m_LESAverageCells.push_back(cellId);
          noLESAverageCells++;
        }
      }

      // add neignbor for nu_t reconstruction
      if(m_averageReconstructNut[p]) {
        for(MInt l = 0; l < noLESAverageCells; l++) {
          MInt cellId = m_LESAverageCells[l];
          for(MInt nghbr = 0; nghbr < a_noReconstructionNeighbors(cellId); nghbr++) {
            const MInt recNghbrId = a_reconstructionNeighborId(cellId, nghbr);

            vector<MInt>::iterator findRecNghbrId =
                find(m_LESAverageCells.begin(), m_LESAverageCells.end(), recNghbrId);

            if(findRecNghbrId == m_LESAverageCells.end()) {
              m_LESAverageCells.push_back(recNghbrId);
            }
          }
        }
      }

      MInt noAvgCellsGlobal = 0;
      MInt size = (MInt)m_LESAverageCells.size();
      MPI_Allreduce(&size, &noAvgCellsGlobal, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "size", "noAvgCellsGlobal");

      if(domainId() == 0) {
        cerr << "m_noLESAverageCells: " << noAvgCellsGlobal << endl;
      }
    }
  }
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::resetZonalSolverData() {
  TRACE();

  IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
    for(MInt var = 0; var < m_noLESVariables; var++) {
      m_LESValues[var].resize(c_noCells());
    }
  }
  else {
    for(MInt var = 0; var < m_noRANSVariables; var++) {
      m_RANSValues[var].resize(c_noCells());
    }
  }
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::saveSpongeData() {
  TRACE();

  IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) return;

  if(m_spongeRank > -1 && domainId() == m_spongeRoot) {
    stringstream fn;
    fn.clear();
    if(m_useNonSpecifiedRestartFile) {
      fn << outputDir() << "stgSpongeData";
    } else {
      fn << outputDir() << "stgSpongeData_" << globalTimeStep;
    }
    fn << ".txt";

    MString fname = fn.str();

    cerr << "Writing STG sponge data at " << globalTimeStep << " ..";

    MString header = "#x1 x2 m_uvInt";

    ofstream spongeData;
    spongeData.precision(16);

    spongeData.open(fname);
    for(MInt i = 0; i < m_globalNoSpongeLocations; i++) {
      MString line;
      line.append(to_string(m_globalSpongeLocations[i].first) + ";" + to_string(m_globalSpongeLocations[i].second) + ";"
                  + to_string(m_uvInt[i]) + ";");

      spongeData << line << endl;
    }
    spongeData.close();

    cerr << "ok" << endl;
  }
}

template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::loadSpongeData() {
  TRACE();

  IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) return;

  if(m_spongeRank > -1 && domainId() == m_spongeRoot) {
    stringstream fn;
    fn.clear();
    if(m_useNonSpecifiedRestartFile) {
      fn << restartDir() << "stgSpongeData";
    } else {
      fn << restartDir() << "stgSpongeData_" << globalTimeStep;
    }
    fn << ".txt";

    MString fname = fn.str();

    cerr << "Loading STG sponge data at " << globalTimeStep << " ..";

    ifstream spongeData;
    spongeData.open(fname);

    vector<double> data(3);
    char ch;
    MFloat num;

    while(spongeData >> num) {
      data.push_back(num);
      spongeData >> ch;
    }

    // MInt count = 0;
    if(m_globalSpongeLocations.size() == 0) {
      cerr << "ERROR in loading sponge data" << endl;
      return;
    }
    MInt dataCount = 0;
    for(MInt i = 0; i < m_globalNoSpongeLocations; i++) {
      for(unsigned int d = 0; d < data.size() - 3; d++) {
        // read wall normal position and compare it to calculated wall positions
        if(d % 3 == 0) {
          // Interpolation
          if((data[d] <= m_globalSpongeLocations[i].first || approx(data[d], m_globalSpongeLocations[i].first, 1e-8))
             && (data[d + 3] >= m_globalSpongeLocations[i].first
                 || approx(data[d + 3], m_globalSpongeLocations[i].first, 1e-8))) {
            m_uvInt[i] =
                data[d + 2]
                + (data[d + 5] - data[d + 2]) / (data[d + 3] - data[d]) * (m_globalSpongeLocations[i].first - data[d]);
            dataCount++;
          }
        }
      }
    }

    // check if all data was correctly read
    if(dataCount != m_globalNoSpongeLocations) {
      cerr << "not all data was correctly read" << endl;
      cerr << "read data count: " << dataCount << ", should be: " << m_globalNoSpongeLocations << endl;
    }

    spongeData.close();

    cerr << "ok" << endl;
  }

  // commuicate data to all ranks
  if(m_spongeRank > -1 && m_spongeCommSize > 0) {
    MPI_Allreduce(MPI_IN_PLACE, &m_uvInt[0], m_globalNoSpongeLocations, MPI_DOUBLE, MPI_SUM, m_spongeComm, AT_,
                  "MPI_IN_PLACE", "m_uvInt");
  }
}


template <MInt nDim_, class SysEqn>
void FvCartesianSolverXD<nDim_, SysEqn>::exchangeZonalAverageCells() {
  TRACE();

  // exchange LESVarAverage
  IF_CONSTEXPR(SysEqn::m_noRansEquations == 0) {
    // add halo cells
    //----------------------------------
    for(MInt p = 0; p < (MInt)m_averagePos.size(); p++) {
      for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
        MFloat halfCellLength = grid().halfCellLength(cellId);
        MFloat pos = a_coordinate(cellId, m_averageDir[p]);
        if(approx(m_averagePos[p], pos, halfCellLength) && a_isHalo(cellId)) {
          m_LESAverageCells.push_back(cellId);
          for(MInt v = 0; v < m_LESNoVarAverage; v++) {
            m_LESVarAverage[v].push_back(F0);
          }
        }
      }

      // add neignbor for nu_t reconstruction
      if(m_averageReconstructNut[p]) {
        for(auto it = std::begin(m_LESAverageCells); it != std::end(m_LESAverageCells); ++it) {
          // for(MInt c = 0; c < m_noLESAverageCells ; c++){
          MInt cellId = *it; // m_LESAverageCells[c];
          if(a_isHalo(cellId)) {
            for(MInt nghbr = 0; nghbr < a_noReconstructionNeighbors(cellId); nghbr++) {
              const MInt recNghbrId = a_reconstructionNeighborId(cellId, nghbr);

              if(a_hasProperty(recNghbrId, FvCell::IsSplitChild)) continue;
              if(a_hasProperty(recNghbrId, FvCell::IsSplitClone)) continue;

              vector<MInt>::iterator findRecNghbrId =
                  find(m_LESAverageCells.begin(), m_LESAverageCells.end(), recNghbrId);

              if(findRecNghbrId == m_LESAverageCells.end()) {
                m_LESAverageCells.push_back(recNghbrId);
                for(MInt v = 0; v < m_LESNoVarAverage; v++) {
                  m_LESVarAverage[v].push_back(F0);
                }
              }
            }
          }
        }
      }
    }
    //----------------------------------

    // exchange halo cells
    for(MInt v = 0; v < m_LESNoVarAverage; v++) {
      ScratchSpace<MFloat> exchangeLESVarAverage(c_noCells(), "exchangeLESVarAverage", FUN_);
      exchangeLESVarAverage.fill(F0);
      for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
        vector<MInt>::iterator findAverageId = find(m_LESAverageCells.begin(), m_LESAverageCells.end(), cellId);
        if(findAverageId != m_LESAverageCells.end()) {
          MInt LESAvgId = distance(m_LESAverageCells.begin(), findAverageId);
          if(!a_isHalo(cellId)) {
            // if(LESAvgId < m_LESAverageCellsHaloOffset){
            exchangeLESVarAverage[cellId] = m_LESVarAverage[v][LESAvgId];
          }
        }
      }

      exchangeData(&exchangeLESVarAverage[0], 1);

      for(MInt LESAvgId = 0; LESAvgId < (MInt)m_LESAverageCells.size(); LESAvgId++) {
        MInt cellId = m_LESAverageCells[LESAvgId];
        if(a_isHalo(cellId)) {
          m_LESVarAverage[v][LESAvgId] = exchangeLESVarAverage[cellId];
        }
      }
    }
  }
}
