// Copyright (C) 2024 The m-AIA AUTHORS
//
// This file is part of m-AIA (https://git.rwth-aachen.de/aia/m-AIA/m-AIA)
//
// SPDX-License-Identifier: LGPL-3.0-only

#include "fvmbcartesiansolverxd.h"

#include <cmath>
#include <cstring>
#include <iomanip>
#include <stack>
#include "COMM/mpiexchange.h"
#include "COMM/mpioverride.h"
#include "GEOM/geometryintersectionlookuptable.h"
#include "IO/parallelio.h"
#include "UTIL/functions.h"
#include "fvcartesianbndrycell.h"
#include "fvcartesiansolverxd.h"
#include "globals.h"


//#define _MB_DEBUG_
#define _ALE_FORM_
#define GEOM_CONS_LAW
//#define VISCOUS_FLUX_FREEZING


using namespace std;


template <MInt nDim, class SysEqn>
constexpr MFloat FvMbCartesianSolverXD<nDim, SysEqn>::m_distThresholdStat[];


/**
 * Constructor
 */
template <MInt nDim, class SysEqn>
FvMbCartesianSolverXD<nDim, SysEqn>::FvMbCartesianSolverXD(MInt solverId_, MInt noSpecies,
                                                           const MBool* propertiesGroups,
                                                           maia::grid::Proxy<nDim>& gridProxy_,
                                                           Geometry<nDim>& geometry_, const MPI_Comm comm)
  : FvCartesianSolverXD<nDim, SysEqn>(solverId_, noSpecies, propertiesGroups, gridProxy_, geometry_, comm),
    m_t0(clock()),
    m_noCVars(CV->noVariables),
    m_noFVars(FV->noVariables),
    m_noPVars(PV->noVariables),
    m_noSlopes(nDim * m_noPVars),
    m_gammaMinusOne(m_gamma - F1) {
  TRACE();

  this->m_fvBndryCnd = FvCartesianSolverXD<nDim, SysEqn>::m_fvBndryCnd;
  if(this->m_fvBndryCnd == nullptr) mTerm(1, AT_, "something went wrong with the boundary condition in MB...");

  m_levelSetMb = propertiesGroups[LEVELSETMB];
  ASSERT(m_levelSetMb, "Calling fvMb without levelSetMb");

  initializeMb();
  m_maxNoSets = m_noLevelSetsUsedForMb;
}


/**
 * Destructor
 */
template <MInt nDim, class SysEqn>
FvMbCartesianSolverXD<nDim, SysEqn>::~FvMbCartesianSolverXD() {
  TRACE();

  const clock_t t1 = clock();
  const MFloat t = static_cast<MFloat>(t1 - m_t0) / CLOCKS_PER_SEC;
  m_log << "========================================" << endl;
  m_log << "Total execution time FvMbSolver3D: " << printTime(t) << " (" << setprecision(8) << t << ")" << endl;
  m_log << "========================================" << endl;
}


/**
 * \fn void FvMbCartesianSolverXD<nDim, SysEqn>::initializeMb()
 * \brief called by the constructor
 *        1) read additional fvmb properties
 *        2) allocate fvmb specific memory
 *        3) initAnalyticalLevelSet
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::initializeMb() {
  TRACE();

#ifdef _MB_DEBUG_
  if(domainId() == 0) {
    char hostname[256];
    char execname[1024];
    memset(execname, 0, sizeof(execname));
    readlink("/proc/self/exe", execname, sizeof(execname) - 1);
    gethostname(hostname, sizeof(hostname));
    cerr << endl << domainId() << ": PID " << getpid() << " on " << hostname << " ready for attach." << endl;
    cerr << domainId() << ": ssh " << hostname << " \"gdb " << execname << " " << getpid()
         << " -ex 'tbreak initializeMb()'\"" << endl;
  }
#endif

#ifdef _LOCAL_TIME_STEPPING
  if(domainId() == 0) {
    cerr << endl << "Local time stepping active!" << endl << endl;
  }
#endif

  const MLong oldAllocatedBytes = allocatedBytes();

#if defined _MB_DEBUG_ || !defined NDEBUG
  cerr0 << "DEBUG macro enabled." << endl;
  m_log << "DEBUG macro enabled." << endl;
#endif
#ifdef GEOM_CONS_LAW
  m_log << "Geometric conservation law enabled." << endl;
#endif

  // settings
  m_constructGField = true;
  m_constructGField = Context::getSolverProperty<MBool>("constructGField", m_solverId, AT_, &m_constructGField);

  /*! \page propertiesFVMB
    \section motionEquation
    <code>MInt FvMbCartesianSolverXD::m_motionEquation </code>\n
    default = <code>0</code>\n
    How do bodys move in moving boundary computations?\n
    Possible values are:
    <ul>
      <li>0: forced motion </li>
      <li>1: free motion under gravity </li>
      <li>2: Ahn & Kallinderis scheme </li>
      <li>3: Borazjani scheme </li>
      <li>4: Lennart's scheme</li>
    </ul>
    Keywords: <i>MOVING BOUNDARY</i>
  */

  m_motionEquation = 0;
  m_motionEquation = Context::getSolverProperty<MInt>("motionEquation", m_solverId, AT_, &m_motionEquation);
  m_log << "motion equation: " << m_motionEquation << endl;

  /*! \page propertiesFVMB
    \section euler
    <code>MBool FvCartesianSolver::m_euler</code>\n
    default = <code>0</code>\n \n
    Sets the system of equations to solve to the Euler Equations
    in the moving boundary solver.
    Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY</i>
  */
  m_euler = 0;
  m_euler = Context::getSolverProperty<MBool>("euler", m_solverId, AT_, &m_euler);

  m_solverType = (SolverType)string2enum(Context::getSolverProperty<MString>("solvertype", m_solverId, AT_));
  execRungeKuttaStep = nullptr;

  /*! \page propertiesFVMB
    \section generateOuterBndryCells
    <code>MBool FvMbCartesianSolverXD::m_generateOuterBndryCells</code>\n
    default = <code>1</code>\n \n
    Controls whether or not outer (not-moving) boundary cells should be created.\n
    Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, BOUNDARY</i>
  */
  m_generateOuterBndryCells = 1;
  m_generateOuterBndryCells =
      Context::getSolverProperty<MBool>("generateOuterBndryCells", m_solverId, AT_, &m_generateOuterBndryCells);

  /*! \page propertiesFVMB
    \section centralizeSurfaceVariables
    <code>MInt FvMbCartesianSolverXD::m_centralizeSurfaceVariables </code>\n
    default = <code>0</code>\n
    How to compute surface values in moving boundary Ausm?\n
    Possible values are:
    <ul>
      <li>0: standard method from computeSurfaceValues </li>
      <li>1: Thornber version (Thornber et al. JCP 2008)</li>
      <li>2: Thornber, changed upwind factor min(1,max(A,B)) -> min(1,A*B), more central, less dissipative, but less
    damping </li> <li>3: central, not recommended </li> <li>4: refinement depending upwind factor pow(min(1,A*B),fac),
    fac=f(a_level) </li> <li>5: upwind factor computation based on property: centralizeSurfaceVariablesFactor </li>
    </ul>
    Keywords: <i>MOVING BOUNDARY, AUSM, NUMERICS</i>
  */
  m_centralizeSurfaceVariables = 0;
  m_centralizeSurfaceVariables =
      Context::getSolverProperty<MInt>("centralizeSurfaceVariables", m_solverId, AT_, &m_centralizeSurfaceVariables);
  m_log << "centralize surface vars: " << m_centralizeSurfaceVariables << endl;

  /*! \page propertiesFVMB
    \section m_levelSetAdaptationScheme
    <code>MInt FvMbCartesianSolverXD::m_levelSetAdaptationScheme</code>\n
    default = <code>0</code>\n\n
    Can be used to switch between the function updateLevelSetOutsideBandPar (0) and updateLevelSetOutsideBand (1) and no
    Update of the OutsideBand (2)\n The first two compute an approximate level set value for cells outside the level-set
    computing band, which is necessary for the according adaptation!\n Possible values are:\n <ul>\n <li>0, 1</li>\n
    </ul>\n
    Keywords: <i>FINITE_VOLUME, LEVEL_SET</i>\n
  */
  m_levelSetAdaptationScheme = 0;
  m_levelSetAdaptationScheme =
      Context::getSolverProperty<MInt>("adaptLevelSetExtensionScheme", m_solverId, AT_, &m_levelSetAdaptationScheme);

  // this sensorMethod does not lead to a stable grid!
  if(!m_constructGField && m_levelSetAdaptationScheme != 2) m_singleAdaptation = true;

  /*! \page propertiesFVMB
  \section haloCellOutput
  <code>MInt FvMbCartesianSolverXD::m_haloCellOutput </code>\n
  default = <code> 0 (false) </code>\n
  Write haloCells output (???).
  Keywords: <i>MOVING BOUNDARY, FINITE_VOLUME</i>
  */
  m_haloCellOutput = false;
  m_haloCellOutput = Context::getSolverProperty<MBool>("haloCellOutput", m_solverId, AT_, &m_haloCellOutput);

  m_solutionDiverged = false;

  m_movingBndryCndId = m_euler ? 3007 : 3006;
  m_movingBndryCndId = Context::getSolverProperty<MInt>("movingBndryCndId", m_solverId, AT_, &m_movingBndryCndId);

  m_loggingInterval = 100;
  m_loggingInterval = Context::getSolverProperty<MInt>("loggingInterval", m_solverId, AT_, &m_loggingInterval);

  /*! \page propertiesFVMB
    \section bodySamplingInterval
    <code>MInt FvMbCartesianSolverXD::m_bodySamplingInterval</code>\n
    default = <code>0</code>\n\n
    Defines the sampling interval of the body\n
    Possible values are:\n
    <ul>\n
    <li>positive integers</li>\n
    </ul>\n
    Keywords: <i>FINITE_VOLUME, PARTICLE, I/O</i>\n
  */
  m_bodySamplingInterval = 0;
  m_bodySamplingInterval =
      Context::getSolverProperty<MInt>("bodySamplingInterval", m_solverId, AT_, &m_bodySamplingInterval);

  /*! \page propertiesFVMB
    \section particleSamplingInterval
    <code>MInt FvMbCartesianSolverXD::m_particleSamplingInterval</code>\n
    default = <code>0</code>\n\n
    Defines the interval in which the properties of the particles are saved by saveParticleSamples()\n
    Possible values are:\n
    <ul>\n
    <li>positive integers</li>\n
    </ul>\n
    Keywords: <i>FINITE_VOLUME, PARTICLE, I/O</i>\n
  */
  m_particleSamplingInterval = 0;
  m_particleSamplingInterval =
      Context::getSolverProperty<MInt>("particleSamplingInterval", m_solverId, AT_, &m_particleSamplingInterval);

  /*! \page propertiesFVMB
    \section conservationCheck
    <code>MBool FvMbCartesianSolverXD::m_conservationCheck </code>\n
    default = <code>false</code>\n
    Checks conservation of the conservative variables in FvMbCartesianSolverXD::applyBoundaryCondition(). Since
    FSFvMbCartesianSolverXD::applyBoundaryConditionMb() is used, the property seems deprecated.\n Possible values are:
    <ul> <li>true</li> <li>false</li>
    </ul>
    Keywords: <i>FINITE VOLUME, MOVING BOUNDARY, CONSERVATION, BOUNDARY CONDITION, UNUSED</i>
  */
  m_conservationCheck = false;
  m_conservationCheck = Context::getSolverProperty<MBool>("conservationCheck", m_solverId, AT_, &m_conservationCheck);

  /*! \page propertiesFVMB
    \section writeCenterLineData
    <code>MBool FvMbCartesianSolverXD::m_writeCenterLineData </code>\n
    default = <code>false</code>\n
    Writes out the Data at the center line of the domain.  \n
    <ul>
      <li>true</li>
      <li>false</li>
    </ul>
    Keywords: <i>FINITE VOLUME, MOVING BOUNDARY, OUTPUT </i>
  */
  m_writeCenterLineData = false;
  m_writeCenterLineData =
      Context::getSolverProperty<MBool>("writeCenterLineData", m_solverId, AT_, &m_writeCenterLineData);

  /*! \page propertiesFVMB
   \section trackMovingBndry
   <code>MBool FvMbSolver2/3D::m_trackMovingBndry </code>\n
   default = <code>true</code>\n
   Also read in fvsolver.h and lssolver.cpp\n
   Triggers the displacement of bodies in the moving boundary solver using the G Field.\n
   Possible values are:
   <ul>
     <li>true: displace bodies</li>
     <li>false: do not displace bodies</li>
   </ul>
   Keywords: <i>MOVING BOUNDARY, FINITE VOLUME, BODY DISPLACEMENT</i>
 */
  m_trackMovingBndry = true;
  m_trackMovingBndry = Context::getSolverProperty<MBool>("trackMovingBndry", m_solverId, AT_, &m_trackMovingBndry);

  m_structureStep = 0;
  m_maxStructureSteps = 1;
  m_maxStructureSteps = Context::getSolverProperty<MInt>("maxIterations", m_solverId, AT_, &m_maxStructureSteps);

  m_gclIntermediate = m_levelSetMb;

  if((m_motionEquation > 0) && !m_constructGField) {
    mTerm(1, AT_, "Please turn on 'constructGField'-property to start fluid structure interaction!");
  }

  /*! \page propertiesFVMB
   \section trackMbStart
   <code>MInt FvMbSolver2/3D::m_trackMbStart </code>\n
   default = <code>numeric_limits<MInt>::max()</code>\n
   Also read in fvsolver.h and lssolver.cpp\n
   For time steps smaller than m_trackMbStart, the bodies are not displaced and the G Field is not updated\n
   Possible values are:
   <ul>
     <li>integer > 0 and < numeric_limits<MInt>::max()</li>
   </ul>
   Keywords: <i>MOVING BOUNDARY, FINITE VOLUME, BODY DISPLACEMENT</i>
 */
  m_trackMbStart = 0;
  m_trackMbStart = Context::getSolverProperty<MInt>("trackMbStart", m_solverId, AT_, &m_trackMbStart);

  /*! \page propertiesFVMB
    \section FSIStart
    <code>MInt FvMbSolver2/3D::m_FSIStart </code>\n
    default = <code>numeric_limits<MInt>::max()</code>\n
    Start interation of the fluid structure interaction, from\n
    which the body is then displaced \n
    Possible values are:
    <ul>
      <li>integer > 0 and < numeric_limits<MInt>::max()</li>
    </ul>
    Keywords: <i>MOVING BOUNDARY, FINITE VOLUME, BODY DISPLACEMENT</i>
  */
  m_FSIStart = m_trackMbStart;
  m_FSIStart = Context::getSolverProperty<MInt>("FSIStart", m_solverId, AT_, &m_FSIStart);

  m_FSIToleranceU = 1e-6;
  m_FSIToleranceU = Context::getSolverProperty<MFloat>("FSIToleranceU", m_solverId, AT_, &m_FSIToleranceU);
  m_FSIToleranceX = 1e-6;
  m_FSIToleranceX = Context::getSolverProperty<MFloat>("FSIToleranceX", m_solverId, AT_, &m_FSIToleranceX);
  m_FSIToleranceW = 1e-5;
  m_FSIToleranceW = Context::getSolverProperty<MFloat>("FSIToleranceW", m_solverId, AT_, &m_FSIToleranceW);
  m_FSIToleranceR = 1e-5;
  m_FSIToleranceR = Context::getSolverProperty<MFloat>("FSIToleranceR", m_solverId, AT_, &m_FSIToleranceR);

  /*! \page propertiesFVMB
   \section trackMbEnd
   <code>MInt FvMbSolver2/3D::m_trackMbEnd </code>\n
   default = <code>numeric_limits<MInt>::max()</code>\n
   Also read in fvsolver.h and lssolver.cpp\n
   For time steps larger than m_trackMbEnd, the bodies are not displaced and the G Field is not updated\n
   Possible values are:
   <ul>
     <li>integer > 0 and < numeric_limits<MInt>::max()</li>
   </ul>
   Keywords: <i>MOVING BOUNDARY, FINITE VOLUME, BODY DISPLACEMENT</i>
 */
  m_trackMbEnd = numeric_limits<MInt>::max();
  m_trackMbEnd = Context::getSolverProperty<MInt>("trackMbEnd", m_solverId, AT_, &m_trackMbEnd);

  m_noLevelSetsUsedForMb = 1;
  m_noLevelSetsUsedForMb = Context::getSolverProperty<MInt>("maxNoLevelSets", m_solverId, AT_, &m_noLevelSetsUsedForMb);

  m_lsCutCellBaseLevel = -1;
  m_lsCutCellMinLevel = 99;
  mAlloc(m_lsCutCellLevel, m_noLevelSetsUsedForMb, "m_lsCutCellLevel", maxRefinementLevel(), AT_);

  if(!Context::propertyExists("cutCellLevel", m_solverId)) {
    m_lsCutCellBaseLevel = maxRefinementLevel();
    m_lsCutCellMinLevel = maxRefinementLevel();
  } else {
    ASSERT(Context::propertyLength("cutCellLevel", m_solverId) == m_noLevelSetsUsedForMb, "");
    m_lsCutCellBaseLevel = Context::getSolverProperty<MInt>("cutCellLevel", m_solverId, AT_, 0);

    for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
      m_lsCutCellLevel[set] = Context::getSolverProperty<MInt>("cutCellLevel", m_solverId, AT_, set);
      m_lsCutCellMinLevel = mMin(m_lsCutCellMinLevel, m_lsCutCellLevel[set]);
    }
  }

  ASSERT(m_lsCutCellBaseLevel <= maxRefinementLevel() && m_lsCutCellBaseLevel >= maxUniformRefinementLevel()
             && m_lsCutCellMinLevel <= maxRefinementLevel() && m_lsCutCellMinLevel >= maxUniformRefinementLevel(),
         "");

  MInt maxSensorLevel = 0;
  for(MInt s = 0; s < this->m_noSensors; s++) {
    maxSensorLevel = mMax(maxSensorLevel, this->m_maxSensorRefinementLevel[s]);
  }


  m_bndryLevelJumps = false;
  if(maxRefinementLevel() != m_lsCutCellBaseLevel || maxRefinementLevel() != m_lsCutCellMinLevel) {
    if(!m_multilevel) {
      m_bndryLevelJumps = true;
      cerr0 << "Warning: Using different levels for levelset bndryd: cutCellBaseLevel ( " << m_lsCutCellBaseLevel
            << ") , maxRefinementLevel (" << maxRefinementLevel() << ") and cutCellMinLevel ( " << m_lsCutCellMinLevel
            << " )" << endl;
    } else {
      cerr0 << "Solver " << m_solverId << " is multi-level secondary with maxLevel " << maxLevel()
            << ", maxRefinementLevel " << maxRefinementLevel() << ", maxSensorLevel " << maxSensorLevel
            << " and cutCellLevel " << m_lsCutCellBaseLevel << endl;
    }

    // update m_bandWidth:
    MFloat distFac[2] = {18.0, 9.0};
    for(MInt i = 0; i < 2; i++) {
      distFac[i] = Context::getSolverProperty<MFloat>("mbBandWidth", m_solverId, AT_, &distFac[i], i);
    }
    m_bandWidth[m_lsCutCellBaseLevel - 1] = distFac[0];
    for(MInt i = maxRefinementLevel() - 2; i >= 0; i--) {
      m_bandWidth[i] = (m_bandWidth[i + 1] / 2) + 1 + distFac[1];
    }
  }

  m_maxLevelChange = false;
  if(globalTimeStep > 0 && isActive() && m_restartFile && maxLevel() != maxRefinementLevel() && !m_bndryLevelJumps
     && !m_multilevel) {
    cerr0 << "MaxLevel is " << maxLevel() << " and maxRefinementLevel is " << maxRefinementLevel()
          << " => temporarily reduction of lsCutCellMinLevel to MaxLevel! " << endl;
    m_maxLevelChange = true;
    m_lsCutCellMinLevel = maxLevel();
    m_bndryLevelJumps = true;
  }


  m_maxLevelDecrease = false;
  if(globalTimeStep > 0 && m_restartFile && isActive() && this->m_adaptation && maxLevel() > maxSensorLevel) {
    m_maxLevelDecrease = true;
    cerr0 << "MaxLevel will be reduced from " << maxLevel() << " to " << maxSensorLevel << endl;
    ASSERT(m_lsCutCellMinLevel <= maxSensorLevel, "");
  }

  /*! \page propertiesFVMB
    \section bodyTypeMb
    <code>MInt FvMbSolver2/3D::m_bodyTypeMb</code>\n
    default = <code>1</code>\n \n
    Select the moving boundary body type to simulate.\n \n
    Possible values are:
    <ul>
      <li> 0: generic body (STL)</li>
      <li> 1: sphere</li>
      <li> 2: piston</li>
      <li> 3: ellipsoid</li>
      <li> 4: NACA00XX</li>
      <li> 5: split sphere</li>
      <li> 6: cube</li>
      <li> 7: tetrahedron</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, BODY_TYPE</i>
  */
  m_bodyTypeMb = 1;
  m_bodyTypeMb = Context::getSolverProperty<MInt>("bodyTypeMb", m_solverId, AT_, &m_bodyTypeMb);
  if(m_bodyTypeMb < 0 || m_bodyTypeMb > 7) {
    mTerm(1, AT_, "Unknown body type!");
  }

  /*! \page propertiesFVMB
    \section logBoundaryData
    <code> MBool FvBndryCnd::m_logBoundaryData> </code> \n
    default = <code>"FALSE"</code>\n \n
    Triggers the logs of several boundary values to the given output file.
    <ul>
    <li>0 (deactivated)</li>
    <li>1 (activated)</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, BOUNDARY CONDITION, OUTPUT</i>
   */
  m_logBoundaryData = false;
  m_logBoundaryData = Context::getSolverProperty<MBool>("logBoundaryData", m_solverId, AT_, &m_logBoundaryData);

  m_recordBodyData = true;

  m_trackBodySurfaceData = true;
  m_trackBodySurfaceData =
      Context::getSolverProperty<MBool>("trackBodySurfaceData", m_solverId, AT_, &m_trackBodySurfaceData);

  if(m_outputOffset > 0) m_solutionOffset = m_outputOffset;

  // TODO labels:FVMB,DOC,toremove remove depricated version use balanceInterval instead!
  m_onlineRestart = false;
  m_onlineRestartInterval = 0;
  m_onlineRestartInterval =
      Context::getSolverProperty<MInt>("onlineRestartInterval", m_solverId, AT_, &m_onlineRestartInterval);

  /*! \page propertiesFVMB
  \section complexBoundary
  <code>MBool FvMbSolverXD::m_complexBoundary </code>\n
  default = <code>0</code>\n \n
  This property triggers if complex boundaries should be considered in MB solver, i.e., cut cells are based on
  information from multiple level-set functions \n possible values are: <ul> <li>0 or 1 (false or true)</li>
  </ul>
  Keywords: <i>MOVING BOUNDARY, MULTIPLE LEVEL SET FUNCTIONS</i>
*/
  m_complexBoundary = false;
  m_complexBoundary = Context::getSolverProperty<MBool>("complexBoundaryForMb", m_solverId, AT_, &m_complexBoundary);

  m_physicalTime = F0;
  m_physicalTimeDt1 = F0;

  const MInt maxNoCells = maxNoGridCells();

  // offsets & counters
  m_noFlowCells = 0;
  m_noSurfaces = 0;
  m_noBndryCells = 0;
  m_noOuterBndryCells = 0;
  m_noLsMbBndryCells = 0;
  m_deleteNeighbour = false;
  m_noNearBndryCells = 0;
  m_noEmergedCells = 0;
  m_noEmergedWindowCells = 0;
  m_reconstructionDataSize = 0;
  m_bndryCellSurfacesOffset = 0;
  m_bndrySurfacesOffset = 0;
  m_totalnosplitchilds = 0;

  mAlloc(m_gridCellArea, maxRefinementLevel() + 1, "m_gridCellArea", -F1, AT_);

  for(MInt level = 0; level < maxRefinementLevel() + 1; level++) {
    m_gridCellArea[level] = F1;
    for(MInt spaceId = 1; spaceId < nDim; spaceId++) {
      m_gridCellArea[level] *= c_cellLengthAtLevel(level);
    }
  }

  mAlloc(m_gravity, 3, "m_gravity", F0, AT_);

  cerr0 << "min/max cell length is " << setprecision(15) << c_cellLengthAtLevel(maxRefinementLevel()) << "/"
        << c_cellLengthAtLevel(maxUniformRefinementLevel()) << setprecision(6) << endl;

  MInt maxFacesXD = m_noDirs + FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces;
  MInt maxPointsXD = 12;
  IF_CONSTEXPR(nDim == 3) maxPointsXD = 12;
  m_noSurfacePointSamples = 0;

  /*! \page propertiesFVMB
    \section maxNoSurfacePointSamples
    <code>MInt FvMbCartesianSolverXD::m_maxNoSurfacePointSamples </code>\n
    default = <code>property maxNoBndryCells</code>\n
    STL files can be read and data at the triangle centroids can be sampled. maxNoSurfacePointSamples is the upper limit
    for the number of sampling points. However the function for determining the sampling points (readStlFile) is not
    called in the trunk.\n Possible values are: <ul> <li>integers > O(maxNoBndryCells) </li>
    </ul>
    Keywords: <i>MOVING BOUNDARY, FINITE VOLUME, PROBING, UNUSED</i>
  */
  m_maxNoSurfacePointSamples = m_fvBndryCnd->m_maxNoBndryCells;
  m_maxNoSurfacePointSamples =
      Context::getSolverProperty<MInt>("maxNoSurfacePointSamples", m_solverId, AT_, &m_maxNoSurfacePointSamples);

  m_maxNoSampleNghbrs = 6;
  m_stableVolumeFraction = m_fvBndryCnd->m_volumeLimitWall;

  /*! \page propertiesFVMB
   \section timeStepAdaptationStart
   <code>MInt fvmbcartesiansolverxd::m_timeStepAdaptationStart</code>\n
   default = <code>-1</code>\n \n
   which time step to adaptTimeStep
   Possible values are:
   <ul>
     <li> Int </li>
   </ul>
   Keywords: <i>time step</i>
 */
  m_timeStepAdaptationStart = -1;
  m_timeStepAdaptationStart =
      Context::getSolverProperty<MInt>("timeStepAdaptationStart", m_solverId, AT_, &m_timeStepAdaptationStart);

  /*! \page propertiesFVMB
    \section timeStepAdaptationEnd
    <code>MInt FvMbCartesianSolverXD::m_timeStepAdaptationEnd </code>\n
    default = <code>-1</code>\n
    The time step at which a desired cfl number cflTarget is reached.\n
    Possible values are:
    <ul>
      <li>-1: no time step adaptation</li>
    </ul>
    Keywords: <i>FINITE VOLUME, MOVING BOUNDARY, TIME STEP, CFL</i>
  */
  m_timeStepAdaptationEnd = -1;
  m_timeStepAdaptationEnd =
      Context::getSolverProperty<MInt>("timeStepAdaptationEnd", m_solverId, AT_, &m_timeStepAdaptationEnd);

  /*! \page propertiesFVMB
    \section cflInitial
    <code>MInt FvMbCartesianSolverXD::m_cflInitial </code>\n
    default = <code>-1</code>\n
    The initial CFL number for the time step adaptation.\n
    Possible values are:
    <ul>
      <li>Floating point number for CFL</li>
    </ul>
    Keywords: <i>FINITE VOLUME, MOVING BOUNDARY, TIME STEP, CFL</i>
  */
  m_cflInitial = Context::getSolverProperty<MFloat>("cflInitial", m_solverId, AT_, &m_cfl);
  m_cflTarget = m_cfl;

  m_g = F0;
  m_Fr = F1;

  /*! \page propertiesFVMB
    \section Fr
    <code>MFloat FvMbCartesianSolverXD::m_Fr</code>\n
    default = <code>1.0</code>\n\n
    Defines the Froude-Number\n
    Possible values are:
    <ul>\n
    <li>positive floating-point values</li>\n
    </ul>\n
    Keywords: <i>FINITE_VOLUME, FROUDE</i>
  */
  if(Context::propertyExists("Froude", m_solverId)) {
    m_Fr = Context::getSolverProperty<MFloat>("Froude", m_solverId, AT_, &m_Fr);
    m_g = POW2(m_Ma / m_Fr);
  } else if(Context::propertyExists("gravitationalAcceleration", m_solverId)) {
    /*! \page propertiesFVMB
      \section gravitationalAcceleration
      <code>MFloat FvMbCartesianSolverXD::m_g</code>\n
      default = <code>0</code>\n\n
      Defines the gravitational acceleration\n
      Possible values are:
      <ul>\n
      <li></li>\n
      </ul>\n
      Keywords: <i>MOVING BOUNDARY, FINITE_VOLUME</i>
    */
    m_g = Context::getSolverProperty<MFloat>("gravitationalAcceleration", m_solverId, AT_, &m_g);
    m_Fr = m_Ma / sqrt(m_g);
  }
  if(Context::propertyExists("gravity", m_solverId)) {
    /*! \page propertiesFVMB
    \section gravity
    <code>MInt FvMbCartesianSolverXD::m_gravity </code>\n
    <code> default = None </code>\n
     Gravitational acceleration in each of the directions.\n\n
     <code>Valid values: Any floating point values with length being spaceDimension. </code>
    Keywords: <i>MOVING BOUNDARY, FINITE_VOLUME</i>
    */
    for(MInt i = 0; i < nDim; i++)
      m_gravity[i] = Context::getSolverProperty<MFloat>("gravity", m_solverId, AT_, i);
    m_g = mMax(mMax(m_gravity[0], m_gravity[1]), m_gravity[2]);
    m_log << "gravity: " << m_gravity[0] << " " << m_gravity[1] << " " << m_gravity[2] << ", Froude: " << F1 / sqrt(m_g)
          << endl;
  } else {
    m_gravity[2] = -m_g;
  }
  m_log << "gravity: " << m_g << ", Froude: " << m_Fr << endl;

  MInt noPeriodicDirs = 0;
  for(MInt dir = 0; dir < nDim; dir++) {
    if(grid().periodicCartesianDir(dir)) noPeriodicDirs++;
  }

  m_maxBndryLayerLevel = maxRefinementLevel();
  m_maxBndryLayerWidth = 6;
  m_outsideFactor = F2;

  // body properties
  // m_noEmbeddedBodies might already initialized in readLevelSetProperties() (called by constructor of base class
  // fvsolverxd.cpp)
  m_noEmbeddedBodies = 1;
  if(!Context::propertyExists("bodyBndryCndIds", m_solverId) || !m_complexBoundary) {
    m_noEmbeddedBodies = Context::getSolverProperty<MInt>("noEmbeddedBodies", m_solverId, AT_, &m_noEmbeddedBodies);
  } else {
    m_noEmbeddedBodies = Context::propertyLength("bodyBndryCndIds", m_solverId);
  }
  m_log << "noEmbeddedBodies " << m_noEmbeddedBodies << endl;
  m_noPeriodicGhostBodies = 0;

  m_maxNoEmbeddedBodiesPeriodic = (noPeriodicDirs > 0)
                                      ? ((m_noEmbeddedBodies < 100) ? 12 * m_noEmbeddedBodies : 4 * m_noEmbeddedBodies)
                                      : m_noEmbeddedBodies;
  if(m_noEmbeddedBodies > 9999 && noPeriodicDirs > 0) {
    m_maxNoEmbeddedBodiesPeriodic =
        m_noEmbeddedBodies + m_noEmbeddedBodies / 2; // typical values are 25% periodic particles
  }
  m_log << "m_maxNoEmbeddedBodiesPeriodic"
        << " " << m_maxNoEmbeddedBodiesPeriodic << endl;

  // allocate body memory and fill with (mostly) zeroes
  allocateBodyMemory(0);

  mAlloc(m_levelSetValuesMb, m_noLevelSetsUsedForMb * maxNoCells, "m_levelSetValuesMb", F0, AT_);

  m_bndryCandidateIds.reserve(maxNoCells);

  m_maxNearestBodies = 20;
  m_maxNearestBodies = Context::getSolverProperty<MInt>("maxNearestBodies", m_solverId, AT_, &m_maxNearestBodies);
  MInt noParticles = 0;

  if(isActive() && m_noEmbeddedBodies > 0) {
    m_particleOffsets.push_back(0);
    for(MLong dom = 0; dom < noDomains(); dom++) {
      MLong tmpv = (((MLong)m_noEmbeddedBodies) * (dom + 1)) / ((MLong)noDomains());
      if(tmpv > numeric_limits<MInt>::max()) mTerm(1, "int overflow");
      m_particleOffsets.push_back((MInt)tmpv);
    }
    noParticles = m_particleOffsets[domainId() + 1] - m_particleOffsets[domainId()];
  }
  m_slipInterval = Context::propertyExists("slipInterval", 0)
                       ? Context::getSolverProperty<MInt>("slipInterval", m_solverId, AT_, &m_slipInterval)
                       : 0;
  m_saveSlipInterval = 0;
  if(m_noEmbeddedBodies > 0 && m_slipInterval > 0) {
    // There are different possibilities for particle-fluid-interaction statistics
    MInt noSetups = m_noAngleSetups * m_noDistSetups;
    m_saveSlipInterval = Context::propertyExists("saveSlipInterval", 0)
                             ? Context::getSolverProperty("saveSlipInterval", m_solverId, AT_, &m_saveSlipInterval)
                             : 0;
    // Allocate memory for particle-fluid-interaction statistics which will be stored every m_slipInterval and written
    // to file every m_saveSlipInterval. This is only required for post-processing and eventually has to move to the
    // post processing class
    m_noSlipDataOutputs = m_saveSlipInterval / m_slipInterval;
    if(m_noSlipDataOutputs < 1) {
      mTerm(0, "Properties saveSlipInterval and slipInterval inconsistent.");
    }
    mAlloc(m_slipDataParticleCollision, mMax(1, noParticles) * m_noSlipDataOutputs * 1, "m_slipDataParticleCollision",
           -5, AT_);
    mAlloc(m_slipDataParticleQuaternion, mMax(1, noParticles) * m_noSlipDataOutputs * 4, "m_slipDataParticleQuaternion",
           -F1, AT_);
    mAlloc(m_slipDataParticleVel, mMax(1, noParticles) * m_noSlipDataOutputs * nDim, "m_slipDataParticleVel", -F1, AT_);
    mAlloc(m_slipDataParticleAngularVel, mMax(1, noParticles) * m_noSlipDataOutputs * 3, "m_slipDataParticleAngularVel",
           -F1, AT_);
    mAlloc(m_slipDataParticleForce, mMax(1, noParticles) * m_noSlipDataOutputs * nDim, "m_slipDataParticleForce", -F1,
           AT_);
    mAlloc(m_slipDataParticleTorque, mMax(1, noParticles) * m_noSlipDataOutputs * 3, "m_slipDataParticleTorque", -F1,
           AT_);
    mAlloc(m_slipDataParticleFluidVel, mMax(1, noParticles) * m_noSlipDataOutputs * noSetups * nDim,
           "m_slipDataParticleFluidVel", -F1, AT_);
    mAlloc(m_slipDataParticleFluidVelGrad, mMax(1, noParticles) * m_noSlipDataOutputs * noSetups * POW2(nDim),
           "m_slipDataParticleFluidVelGrad", -F1, AT_);
    mAlloc(m_slipDataParticleFluidVelRot, mMax(1, noParticles) * m_noSlipDataOutputs * noSetups * 3,
           "m_slipDataParticleFluidVelRot", -F1, AT_);
    mAlloc(m_slipDataParticlePosition, mMax(1, noParticles) * m_noSlipDataOutputs * nDim, "m_slipDataParticlePosition",
           -F1, AT_);
  }

  m_bndryLayerCells.reserve(m_fvBndryCnd->m_maxNoBndryCells);
  mAlloc(m_volumeFraction, m_fvBndryCnd->m_maxNoBndryCells, "m_volumeFraction", -F1, AT_);
  mAlloc(m_maxBndryLayerDistances, m_maxBndryLayerLevel + 1, 2, "m_maxBndryLayerDistances", F0, AT_);
  mAlloc(m_associatedBodyIds, m_noLevelSetsUsedForMb * maxNoCells, "m_associatedBodyIds", -1, AT_);
  mAlloc(m_stableCellVolume, m_maxBndryLayerLevel + 1, "m_stableCellVolume", F0, AT_);
  mAlloc(m_cellVolumesDt1, maxNoCells, "m_cellVolumesDt1", F0, AT_);
  if(m_dualTimeStepping) {
    mAlloc(m_cellVolumesDt2, maxNoCells, "m_cellVolumesDt2", F0, AT_);
  }
  mAlloc(m_sweptVolume, m_fvBndryCnd->m_maxNoBndryCells, "m_sweptVolume", F0, AT_);
  mAlloc(m_sweptVolumeDt1, m_fvBndryCnd->m_maxNoBndryCells, "m_sweptVolumeDt1", F0, AT_);
  mAlloc(m_rhs0, maxNoCells, m_noFVars, "m_rhs0", F0, AT_);

#ifdef VISCOUS_FLUX_FREEZING
  mAlloc(m_rhsViscous, maxNoCells, m_noFVars, "m_rhsViscous", F0, AT_);
#else
  m_rhsViscous = nullptr;
#endif

  mAlloc(m_noCutCellFaces, m_fvBndryCnd->m_maxNoBndryCells, "m_noCutCellFaces", 0, AT_);
  mAlloc(m_cutFacePointIds, m_fvBndryCnd->m_maxNoBndryCells, maxFacesXD * maxPointsXD, "m_cutFacePointIds", -1, AT_);
  mAlloc(m_noCutFacePoints, m_fvBndryCnd->m_maxNoBndryCells, maxFacesXD, "m_noCutFacePoints", 0, AT_);
  mAlloc(m_cutFaceArea, m_fvBndryCnd->m_maxNoBndryCells, m_noDirs, "m_cutFaceArea", F0, AT_);
  mAlloc(m_pointIsInside, m_fvBndryCnd->m_maxNoBndryCells, m_noLevelSetsUsedForMb * m_noCellNodes, "m_pointIsInside",
         false, AT_);
  mAlloc(m_bbox, 2 * nDim, "m_bbox", F0, AT_);
  mAlloc(m_bboxLocal, 2 * nDim, "m_bboxLocal", F0, AT_);
  mAlloc(m_nghbrList, 27 * m_noCellNodes, "m_nghbrList", -1, AT_);
  mAlloc(m_sendBufferSize, mMax(1, noNeighborDomains()), "m_sendBufferSize", 0, AT_);
  mAlloc(m_receiveBufferSize, mMax(1, noNeighborDomains()), "m_receiveBufferSize", 0, AT_);
  mAlloc(g_mpiRequestMb, mMax(1, noNeighborDomains()), "g_mpiRequestMb", MPI_REQ_NULL, AT_);
  mAlloc(m_cellSurfaceMapping, maxNoCells, m_noDirs, "m_cellSurfaceMapping", -1, AT_);

  /*! \page propertiesFVMB
    \section noPointParticles
    <code>MInt FvMbCartesianSolverXD::m_noPointParticles </code>\n
    default = <code>0</code>\n
    Number of point particles in the moving boundary solver.\n
    Possible values are:
    <ul>
      <li>integers >= 0 and < O(maxNoCells) </li>
    </ul>
    Keywords: <i>CAPITALS</i>
  */
  m_noPointParticles = 0;
  m_noPointParticles = Context::getSolverProperty<MInt>("noPointParticles", m_solverId, AT_, &m_noPointParticles);
  m_noPointParticlesLocal = 0;

  /*! \page propertiesFVMB
    \section pointParticleType
    <code>MInt FvMbCartesianSolverXD::m_pointParticleType </code>\n
    default = <code>1</code>\n
    defines the shape of point particles in the moving boundary solver. \n
    Possible values are:
    <ul>
    <li> 1: sphere </li>
    <li> 2: generic (shape factor) </li>
    <li> 3: spheroid </li>
    </ul>
    Keywords: <i> MOVING BOUNDARY, PARTICLES, FINITE_VOLUME</i>
  */

  m_pointParticleType = 1;
  m_pointParticleType = Context::getSolverProperty<MInt>("pointParticleType", m_solverId, AT_, &m_pointParticleType);

  /*! \page propertiesFVMB
   \section pointParticleTwoWayCoupling
    <code>MInt FvMbCartesianSolverXD::m_pointParticleTwoWayCoupling </code>\n
    default = <code>0</code>\n
    Activates or Deactivates two way coupling of point particles with the flow grid. \n
    Possible values are:
    <ul>
    <li> 0: Inactive </li>
    <li> 1: Active </li>
    </ul>
    Keywords: <i> MOVING BOUNDARY, PARTICLES, FINITE_VOLUME</i>
  */
  m_pointParticleTwoWayCoupling = 0;
  m_pointParticleTwoWayCoupling =
      Context::getSolverProperty<MInt>("pointParticleTwoWayCoupling", m_solverId, AT_, &m_pointParticleTwoWayCoupling);

  /*! \page propertiesFVMB
  \section particleTerminalVelocity
  <code>MInt FvMbCartesianSolverXD::m_particleTerminalVelocity </code>\n
  default = None\n
  Sets the terminal velocity for all particles.\n
  Possible values are:
  <ul>
    <li>Any floating point values with length spaceDimension.</li>
  </ul>
  Keywords: <i>MOVING BOUNDARY, PARTICLES, FINITE_VOLUME</i>
*/
  mAlloc(m_particleTerminalVelocity, nDim, "m_particleTerminalVelocity", F0, AT_);
  if(Context::propertyExists("particleTerminalVelocity", m_solverId)) {
    for(MInt dir = 0; dir < nDim; dir++) {
      m_particleTerminalVelocity[dir] = Context::getSolverProperty<MFloat>("particleTerminalVelocity", m_solverId, AT_,
                                                                           &m_particleTerminalVelocity[dir], dir);
    }
  }
  if(m_pointParticleTwoWayCoupling == 1 && m_noPointParticles > 0) {
    mAlloc(m_coupling, maxNoGridCells(), nDim, "m_coupling", F0, AT_);
  }

  m_couplingRate = F0;
  m_particleCoords.clear();
  m_particleCoordsDt1.clear();
  m_particleVelocity.clear();
  m_particleTemperature.clear();
  m_particleTemperatureDt1.clear();
  m_particleHeatFlux.clear();
  m_particleVelocityDt1.clear();
  m_particleVelocityFluid.clear();
  m_particleFluidTemperature.clear();
  m_particleAcceleration.clear();
  m_particleAccelerationDt1.clear();
  m_particleQuaternions.clear();
  m_particleQuaternionsDt1.clear();
  m_particleAngularVelocity.clear();
  m_particleAngularVelocityDt1.clear();
  m_particleVelocityGradientFluid.clear();
  m_particleAngularAcceleration.clear();
  m_particleAngularAccelerationDt1.clear();
  m_particleShapeParams.clear();
  m_particleRadii.clear();
  m_particleCellLink.clear();

  m_linkedWindowCells = nullptr;
  m_linkedHaloCells = nullptr;

  mAlloc(m_linkedWindowCells, mMax(1, noNeighborDomains()), "m_linkedWindowCells", AT_);
  mAlloc(m_linkedHaloCells, mMax(1, noNeighborDomains()), "m_linkedHaloCells", AT_);

  for(MInt b = 0; b < m_noEmbeddedBodies; b++) {
    m_internalBodyId[b] = b;
  }

  std::vector<MInt>().swap(m_bndryLayerCells);

  for(MInt i = 0; i <= m_maxBndryLayerLevel; i++) {
    m_maxBndryLayerDistances[i][0] = -c_cellLengthAtLevel(i) * F3;
    m_maxBndryLayerDistances[i][1] = c_cellLengthAtLevel(i) * (MFloat)m_maxBndryLayerWidth;
    m_log << "bndry layer width level " << i << ": " << m_maxBndryLayerDistances[i][0] << " "
          << m_maxBndryLayerDistances[i][1] << endl;
  }

  if(m_adaptation) {
    m_bodyDistThreshold = 1.1
                          * (mMax(m_outerBandWidth[mMin(maxUniformRefinementLevel(), maxRefinementLevel() - 1)],
                                  m_maxBndryLayerDistances[maxRefinementLevel()][1])
                             + c_cellLengthAtLevel(minLevel()));
    m_periodicGhostBodyDist = 1.1
                              * (m_outerBandWidth[mMin(maxUniformRefinementLevel(), maxRefinementLevel() - 1)]
                                 + ((MFloat)noHaloLayers()) * c_cellLengthAtLevel(minLevel()));
  } else {
    m_bodyDistThreshold = 1.1 * m_maxBndryLayerDistances[maxRefinementLevel()][1] + c_cellLengthAtLevel(minLevel());
    m_periodicGhostBodyDist = 1.1 * ((MFloat)noHaloLayers()) * c_cellLengthAtLevel(minLevel());
  }
  m_log << "body dist threshold " << m_bodyDistThreshold << " " << m_periodicGhostBodyDist << endl;

  for(MInt i = 0; i <= m_maxBndryLayerLevel; i++) {
    m_stableCellVolume[i] = grid().gridCellVolume(i) * m_stableVolumeFraction;
  }

  // collision triggers
  m_applyCollisionModel = (m_initialCondition == 15 || m_initialCondition == 16);
  m_applyCollisionModel =
      Context::getSolverProperty<MBool>("applyCollisionModel", m_solverId, AT_, &m_applyCollisionModel);

  m_massRedistributionIds.clear();
  m_massRedistributionVariables.clear();
  m_massRedistributionRhs.clear();
  m_massRedistributionVolume.clear();
  m_massRedistributionSweptVol.clear();
  m_temporarilyLinkedCells.clear();

  m_splitCells.clear();
  m_splitChilds.clear();
  m_splitChildToSplitCell.clear();

  m_gapOpened = false;

  m_fvBndryCnd->m_noBoundarySurfaces = 0;

  if(domainId() == 0) {
    if(fileExists("Residual")) {
      remove("Residual");
    }
  }

  computeLocalBoundingBox();
  for(MInt i = 0; i < 2 * nDim; i++) {
    m_bbox[i] = m_bboxLocal[i];
  }

  if(isActive()) {
    MPI_Allreduce(MPI_IN_PLACE, &m_bbox[0], nDim, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE", "m_bbox[0]");
    MPI_Allreduce(MPI_IN_PLACE, &m_bbox[nDim], nDim, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                  "m_bbox[nDim]");
  }

  if(domainId() == 0) {
    cerr << "bounding box: " << setprecision(15);
    for(MInt i = 0; i < nDim; i++)
      cerr << m_bbox[i] << ":" << m_bbox[nDim + i] << " ";
    cerr << setprecision(6) << endl;
    m_log << "bounding box: ";
    for(MInt i = 0; i < nDim; i++)
      m_log << m_bbox[i] << ":" << m_bbox[nDim + i] << " ";
    m_log << endl;
  }

  stringstream solver_data;
  solver_data.str("");
  solver_data << m_solutionOutput;
  solver_data << "/solver_data";
  struct stat s0 {};
  if(stat((solver_data.str()).c_str(), &s0) < 0) {
#if defined(MAIA_MS_COMPILER)
#pragma message("WARNING: Not compatible")
    mTerm(0, "ERROR: Not implemented!");
#else
    mkdir((solver_data.str()).c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
#endif
  }

  m_log << "eps is " << m_eps << endl;

  m_geometryIntersection = new GeometryIntersection<nDim>(&grid(), m_geometry);

  m_closeGaps = Context::getSolverProperty<MBool>("closeGaps", m_solverId, AT_, &m_closeGaps);
  m_gapInitMethod = 2;
  m_noGapRegions = 0;

  if(m_closeGaps) {
    // Gap-Properties and Settings:
    /*! \page propertiesFVMB
      \section m_gapInitMethod
      <code>MInt FvMbCartesianSolverXD::m_gapInitMethod </code>\n
      default = <code>2</code>\n
      Possible values are:
      <ul>
      <li> 0: all gap Cells are reseted and initialized (older version from Claudia) </li>
      <li> 1: only new arising gap Cells are reseted! </li>
      <li> 2: only new arising gap Cells are reseted and mew epsilons are used</li>
      </ul>
      Keywords: <i> MOVING BOUNDARY, GAP, FINITE_VOLUME</i>
    */
    m_gapInitMethod = Context::getSolverProperty<MInt>("gapInitMethod", 0, AT_, &m_gapInitMethod);
    m_noGapRegions = Context::getSolverProperty<MInt>("noGapRegions", 0, AT_, &m_noGapRegions);

    mAlloc(m_gapState, m_noGapRegions, "m_gapState", 0, AT_);

    m_gapCells.clear();

    m_gapWindowCells = nullptr;
    m_gapHaloCells = nullptr;
    mAlloc(m_gapWindowCells, noNeighborDomains(), "m_gapWindowCells", AT_);
    mAlloc(m_gapHaloCells, noNeighborDomains(), "m_gapHaloCells", AT_);
  }

  m_LsMovement = false;
  m_LsMovement = Context::getSolverProperty<MBool>("LsMovement", m_solverId, AT_, &m_LsMovement);

  /*! \page propertiesFVMB
   \section LsRotate
   <code>MString FvMbSolver::m_LsRotate </code>\n
   default = <code> flase </code>\n \n
   This property needs to be true for rotating levelset
 */
  m_LsRotate = false;
  m_LsRotate = Context::getSolverProperty<MBool>("LsRotate", m_solverId, AT_, &m_LsRotate);
  if(m_LsRotate) {
    m_refineDiagonals = false;
  }

  m_alwaysResetCutOff = false;
  m_alwaysResetCutOff = Context::getSolverProperty<MBool>("resetCutOff", m_solverId, AT_, &m_alwaysResetCutOff);

  m_maxIterations = 1;
  m_maxIterations = Context::getSolverProperty<MInt>("maxIterations", m_solverId, AT_, &m_maxIterations);

  if(!Context::propertyExists("bodyIdOutput", m_solverId)) {
    m_bodyIdOutput = m_bodyIdOutput || !m_constructGField;
  }
  if(!Context::propertyExists("levelSetOutput", m_solverId)) {
    m_levelSetOutput = m_levelSetOutput || !m_constructGField;
  }

  if(m_constructGField) initAnalyticalLevelSet();

  m_reConstSVDWeightMode = 1;
  if(m_bndryLevelJumps) m_reConstSVDWeightMode = 0;

  /*! \page propertiesFVMB
      \section surfaceValueReconstruction
      <code>MInt FvCartesianSolver::m_reConstSVDWeightMode </code>\n
      default = <code>0/1</code>\n \n
      Selects the weight mode for the weights in the reconstruction Constant
      computation in SVD for cells near the moving bndry! \n \n
      possible values are:
      <ul>
      <li> 0: only use distance weights </li>
      <li> 1: only use distance weights and set weight = 0 for diagonal neighbors  </li>
      <li> 2: use distance and cellFraction weights for all neighbors </li>
      </ul>
      Keywords: <i> FINITE_VOLUME, SVD, reconstructionConstants </i>
    */
  m_reConstSVDWeightMode =
      Context::getSolverProperty<MInt>("reConstSVDWeightMode", m_solverId, AT_, &m_reConstSVDWeightMode);

  if(m_bndryLevelJumps) {
    ASSERT(m_reConstSVDWeightMode != 1, "Mode not working for bndry-level-jumps!");
  }

  /*! \page propertiesFVMB
    \section engineSetup
    <code>MBool LsCartesianSolver::m_engineSetup </code>\n
    Triggers specific stuff for TINA or other engine applications
    default = <code>false</code>\n \n
    Keywords: <i>LEVELSET, ADAPTATION, ENGINE</i>
  */
  m_engineSetup = Context::getSolverProperty<MBool>("engineSetup", m_solverId, AT_, &m_engineSetup);

  /*! \page propertiesFVMB
    \section linerLvlJump
    <code>MBool LsCartesianSolver::m_linerLvlJump </code>\n
    Triggers a level Jump in the levelset of the engine liner, so that only the liner inside is refined!
    default = <code>false</code>\n \n
    Keywords: <i>LEVELSET, ADAPTATION, ENGINE</i>
  */
  m_linerLvlJump = Context::getSolverProperty<MBool>("linerLevelJump", m_solverId, AT_, &m_linerLvlJump);

  if(domainId() == 0 && m_engineSetup) {
    cerr << "Applying engine setup with " << m_linerLvlJump << "liner level Jumps!" << endl;
  }

  if(m_linerLvlJump) ASSERT(m_engineSetup, "");

  if(m_engineSetup) {
    /*! \page propertiesFVMB
      \section forceNoGaps
      <code>MInt LsCartesianSolver::m_forceNoGaps </code>\n
      default = <code>0</code>\n
      triggers the surpression of gap cells
      <ul>
      <li> 0: do not surpress gap cells </li> (1)
      <li> 1: surpress gap cells for multi-valve engine </li> (2)
      <li> 2: surpress gap cells for single-valve engine</li>
      </ul>
      Keywords: <i> MOVING BOUNDARY, GAP, LS</i>
    */
    m_forceNoGaps = 0;
    m_forceNoGaps = Context::getSolverProperty<MInt>("forceNoGaps", m_solverId, AT_, &m_forceNoGaps);

    MInt noGapRegions = 0;
    noGapRegions = Context::getSolverProperty<MInt>("noGapRegions", m_solverId, AT_, &noGapRegions);

    if(m_forceNoGaps == 1) { // surpress gap cells for multi-valve engine

      mAlloc(m_gapAngleClose, noGapRegions, "m_gapAngleClose", F0, AT_);
      mAlloc(m_gapAngleOpen, noGapRegions, "m_gapAngleOpen", F0, AT_);
      mAlloc(m_gapSign, noGapRegions, "m_gapSign", F1, AT_);

      for(MInt i = 0; i < noGapRegions; i++) {
        m_gapAngleClose[i] =
            Context::getSolverProperty<MFloat>("gapAngleClose", m_solverId, AT_, &m_gapAngleClose[i], i);
        m_gapAngleOpen[i] = Context::getSolverProperty<MFloat>("gapAngleOpen", m_solverId, AT_, &m_gapAngleClose[i], i);
        if(m_gapAngleClose[i] < 0.0) {
          m_gapAngleClose[i] = 720 + m_gapAngleClose[i];
        }
        if(m_gapAngleOpen[i] < 0.0) {
          m_gapAngleOpen[i] = 720 + m_gapAngleOpen[i];
        }
        if(m_gapAngleOpen[i] > m_gapAngleClose[i]) {
          m_gapSign[i] = -1;
        }
      }
    } else if(m_forceNoGaps == 2) { // surpress gap cells for single-valve engine

      ASSERT(noGapRegions == 1, "Mode only intended for 1 gap-region!");

      mAlloc(m_gapAngleClose, noGapRegions + 1, "m_gapAngleClose", F0, AT_);
      mAlloc(m_gapAngleOpen, noGapRegions + 1, "m_gapAngleOpen", F0, AT_);
      mAlloc(m_gapSign, noGapRegions + 1, "m_gapSign", F1, AT_);

      ASSERT(noGapRegions + 1 == Context::propertyLength("gapAngleOpen", m_solverId), "");

      for(MInt i = 0; i < noGapRegions + 1; i++) {
        m_gapAngleClose[i] =
            Context::getSolverProperty<MFloat>("gapAngleClose", m_solverId, AT_, &m_gapAngleClose[i], i);
        m_gapAngleOpen[i] = Context::getSolverProperty<MFloat>("gapAngleOpen", m_solverId, AT_, &m_gapAngleClose[i], i);
        if(m_gapAngleClose[i] < 0.0) {
          m_gapAngleClose[i] = 720 + m_gapAngleClose[i];
        }
        if(m_gapAngleOpen[i] < 0.0) {
          m_gapAngleOpen[i] = 720 + m_gapAngleOpen[i];
        }
        if(m_gapAngleOpen[i] > m_gapAngleClose[i]) {
          m_gapSign[i] = -1;
        }
      }
    }
  }

  if(Context::propertyExists("LsGeometryChange", m_solverId)) {
    mAlloc(m_geometryChange, m_noLevelSetsUsedForMb, "geometryChange", false, AT_);

    MBool anychange = false;
    for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
      m_geometryChange[set] =
          Context::getSolverProperty<MBool>("LsGeometryChange", m_solverId, AT_, &m_geometryChange[set], set);
      if(m_geometryChange[set]) anychange = true;
    }

    if(!anychange) {
      mDeallocate(m_geometryChange);
      ASSERT(m_geometryChange == nullptr, "");
    }
  }

  m_dynamicStencil = false;
  m_dynamicStencil = Context::getSolverProperty<MBool>("dynamicStencil", m_solverId, AT_, &m_dynamicStencil);

  m_reComputedBndry = true;

  if(isActive()) printAllocatedMemory(oldAllocatedBytes, "FvMbSolver", mpiComm());

  if(m_hasExternalSource /*&& g_splitMpiComm*/) {
    mAlloc(m_externalSourceDt1, maxNoGridCells(), CV->noVariables, "m_externalForces", 0.0, AT_);
    m_log << "Allocated memory for old external sources." << endl;
  }

  if(grid().azimuthalPeriodicity()) {
    m_noFloatDataBalance = 3 + CV->noVariables; // cellVol, cellVollDt1, sweptVol, vars
    m_noFloatDataAdaptation = 3;                // cellVol, cellVollDt1, sweptVol
    m_noLongData = 2;                           // m_oldBndryCells.count(), cell properties
    m_noLongDataBalance = 3;                    // globalId, m_oldBndryCells.count(), cell properties
  }

  if(calcSlopesAfterStep()) mTerm(1, AT_, "calcSlopesAfterStep not implemented for FvMb");
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::allocateBodyMemory(const MInt mode) {
  if(mode == 1) {
    mDeallocate(m_bodyTerminalVelocity);
    mDeallocate(m_bodyCenter);
    mDeallocate(m_projectedArea);
    mDeallocate(m_bodyRadii);
    mDeallocate(m_bodyRadius);
    mDeallocate(m_bodyDiameter);
    mDeallocate(m_bodyVelocity);
    mDeallocate(m_bodyAcceleration);
    mDeallocate(m_bodyAngularVelocity);
    mDeallocate(m_bodyAngularVelocityDt1);
    mDeallocate(m_bodyTorque);
    mDeallocate(m_bodyTorqueDt1);
    mDeallocate(m_bodyQuaternion);
    mDeallocate(m_bodyQuaternionDt1);
    mDeallocate(m_bodyAngularAcceleration);
    mDeallocate(m_bodyAngularAccelerationDt1);
    mDeallocate(m_bodyDensity);
    mDeallocate(m_bodyMomentOfInertia);
    mDeallocate(m_bodyAccelerationDt1);
    mDeallocate(m_bodyVelocityDt1);
    mDeallocate(m_bodyCenterDt1);

    if(m_motionEquation > 1) {
      mDeallocate(m_bodyCenterDt2);
      mDeallocate(m_bodyVelocityDt2);
      mDeallocate(m_bodyAccelerationDt2);
      mDeallocate(m_bodyAccelerationDt3);

      mDeallocate(m_bodyReducedVelocity);
      mDeallocate(m_bodyReducedFrequency);
      mDeallocate(m_bodyReducedMass);
      mDeallocate(m_bodyDampingCoefficient);

      mDeallocate(m_bodyNeutralCenter);
    }

    mDeallocate(m_bodyForce);
    mDeallocate(m_bodyHeatFlux);
    mDeallocate(m_bodyForceDt1);
    mDeallocate(m_hydroForce);

    mDeallocate(m_bodyTemperature);
    mDeallocate(m_bodyTemperatureDt1);
    mDeallocate(m_bodyEquation);
    mDeallocate(m_bodyInCollision);
    mDeallocate(m_periodicGhostBodies);
    mDeallocate(m_internalBodyId);
    mDeallocate(m_bodyNearDomain);

    mDeallocate(m_fixedBodyComponents);
    mDeallocate(m_fixedBodyComponentsRotation);
  }

  mAlloc(m_bodyTerminalVelocity, nDim, "m_bodyTerminalVelocity", F0, AT_);

  mAlloc(m_bodyCenter, nDim * m_maxNoEmbeddedBodiesPeriodic, "m_bodyCenter", F0, AT_);
  mAlloc(m_bodyVolume, m_noEmbeddedBodies, "m_bodyVolume", F0, AT_);
  mAlloc(m_bodyMass, m_noEmbeddedBodies, "m_bodyMass", F0, AT_);
  mAlloc(m_projectedArea, m_noEmbeddedBodies, "m_projectedArea", F0, AT_);
  mAlloc(m_bodyRadii, 3 * m_maxNoEmbeddedBodiesPeriodic, "m_bodyRadii", F0, AT_);
  mAlloc(m_bodyRadius, m_maxNoEmbeddedBodiesPeriodic, "m_bodyRadius", F0, AT_);
  mAlloc(m_bodyDiameter, m_maxNoEmbeddedBodiesPeriodic, "m_bodyDiameter", F0, AT_);
  mAlloc(m_bodyVelocity, nDim * m_maxNoEmbeddedBodiesPeriodic, "m_bodyVelocity", F0, AT_);
  mAlloc(m_bodyAcceleration, nDim * m_maxNoEmbeddedBodiesPeriodic, "m_bodyAcceleration", F0, AT_);
  mAlloc(m_bodyAngularVelocity, 3 * m_maxNoEmbeddedBodiesPeriodic, "m_bodyAngularVelocity", F0, AT_);
  mAlloc(m_bodyAngularVelocityDt1, 3 * m_noEmbeddedBodies, "m_bodyAngularVelocityDt1", F0, AT_);
  mAlloc(m_bodyTorque, 3 * m_noEmbeddedBodies, " m_bodyTorque", F0, AT_);
  mAlloc(m_bodyTorqueDt1, 3 * m_noEmbeddedBodies, "m_bodyTorqueDt1", F0, AT_);
  mAlloc(m_bodyQuaternion, 4 * m_maxNoEmbeddedBodiesPeriodic, "m_bodyQuaternion", F0, AT_);
  mAlloc(m_bodyQuaternionDt1, 4 * m_noEmbeddedBodies, "m_bodyQuaternionDt1", F0, AT_);
  mAlloc(m_bodyAngularAcceleration, 3 * m_maxNoEmbeddedBodiesPeriodic, "m_bodyAngularAcceleration", F0, AT_);
  mAlloc(m_bodyAngularAccelerationDt1, 3 * m_noEmbeddedBodies, "m_bodyAngularAccelerationDt1", F0, AT_);
  mAlloc(m_bodyDensity, m_noEmbeddedBodies, "m_bodyDensity", F0, AT_);
  mAlloc(m_bodyMomentOfInertia, 3 * m_noEmbeddedBodies, "m_bodyMomentOfInertia", F0, AT_);
  mAlloc(m_bodyAccelerationDt1, nDim * m_noEmbeddedBodies, "m_bodyAccelerationDt1", F0, AT_);
  mAlloc(m_bodyVelocityDt1, nDim * m_noEmbeddedBodies, "m_bodyVelocityDt1", F0, AT_);
  mAlloc(m_bodyCenterDt1, nDim * m_noEmbeddedBodies, "m_bodyCenterDt1", F0, AT_);

  if(m_motionEquation > 1) {
    mAlloc(m_bodyAccelerationDt2, nDim * m_noEmbeddedBodies, "m_bodyAccelerationDt2", F0, AT_);
    mAlloc(m_bodyAccelerationDt3, nDim * m_noEmbeddedBodies, "m_bodyAccelerationDt3", F0, AT_);
    mAlloc(m_bodyVelocityDt2, nDim * m_noEmbeddedBodies, "m_bodyVelocityDt2", F0, AT_);
    mAlloc(m_bodyCenterDt2, nDim * m_noEmbeddedBodies, "m_bodyCenterDt2", F0, AT_);
    mAlloc(m_bodyReducedVelocity, m_noEmbeddedBodies, "m_bodyReducedVelocity", F0, AT_);
    mAlloc(m_bodyReducedFrequency, m_noEmbeddedBodies, "m_bodyReducedFrequency", F0, AT_);
    mAlloc(m_bodyReducedMass, m_noEmbeddedBodies, "m_bodyReducedMass", F0, AT_);
    mAlloc(m_bodyDampingCoefficient, m_noEmbeddedBodies, "m_bodyDampingCoefficient", F0, AT_);
    mAlloc(m_bodyNeutralCenter, nDim * m_noEmbeddedBodies, "m_bodyNeutralCenter", F0, AT_);
  }

  mAlloc(m_bodyTemperature, m_noEmbeddedBodies, "m_bodyTemperature", F1, AT_);
  mAlloc(m_bodyTemperatureDt1, m_noEmbeddedBodies, "m_bodyTemperatureDt1", F1, AT_);
  mAlloc(m_bodyEquation, m_noEmbeddedBodies, "m_bodyEquation", -1, AT_);
  mAlloc(m_bodyInCollision, m_noEmbeddedBodies, "m_bodyInCollision", 0, AT_);
  mAlloc(m_periodicGhostBodies, m_noEmbeddedBodies, "m_periodicGhostBodies", AT_);
  mAlloc(m_internalBodyId, m_maxNoEmbeddedBodiesPeriodic, "m_internalBodyId", -1, AT_);
  mAlloc(m_bodyNearDomain, m_maxNoEmbeddedBodiesPeriodic, "m_bodyNearDomain", true, AT_);
  mAlloc(m_fixedBodyComponents, nDim, "m_fixedBodyComponents", 0, AT_);
  mAlloc(m_fixedBodyComponentsRotation, 3, "m_fixedBodyComponentsRotation", 0, AT_);

  mAlloc(m_bodyForce, nDim * m_noEmbeddedBodies, "m_bodyForce", F0, AT_);
  mAlloc(m_bodyForceDt1, nDim * m_noEmbeddedBodies, "m_bodyForceDt1", F0, AT_);
  mAlloc(m_bodyHeatFlux, m_noEmbeddedBodies, "m_bodyHeatFlux", F0, AT_);
  mAlloc(m_hydroForce, nDim * m_noEmbeddedBodies, "m_hydroForce", F0, AT_);
}


/**
 * \brief determines relevant cell properties
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::setLevelSetMbCellProperties() {
  TRACE();

  constructGField(false);

  std::vector<MInt>().swap(m_bndryLayerCells);
  set<MInt> rebuildCells;
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    if(a_bndryId(cellId) < -1) continue;

    ASSERT(!a_isBndryGhostCell(cellId), "");

    if(c_noChildren(cellId) > 0) {
      ASSERT(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel), "Non leaf cell is on current mg level!");
      a_hasProperty(cellId, SolverCell::NearWall) = false;
    }

    MBool oldStatus = a_hasProperty(cellId, SolverCell::NearWall);

    ASSERT(a_level(cellId) > -1 && a_level(cellId) <= maxRefinementLevel(),
           "unexpected cell level " << a_level(cellId) << " for cell " << cellId << endl);

    if((a_level(cellId) >= m_lsCutCellMinLevel)
       && a_levelSetValuesMb(cellId, 0) > m_maxBndryLayerDistances[a_level(cellId)][0]
       && a_levelSetValuesMb(cellId, 0) < m_maxBndryLayerDistances[a_level(cellId)][1] && c_isLeafCell(cellId)) {
      m_bndryLayerCells.push_back(cellId);
      a_hasProperty(cellId, SolverCell::NearWall) = true;
    } else {
      a_hasProperty(cellId, SolverCell::NearWall) = false;
    }
    if(a_levelSetValuesMb(cellId, 0) < F0) {
      a_hasProperty(cellId, SolverCell::IsInactive) = true;
      a_hasProperty(cellId, SolverCell::IsActive) = false;           // change_1a
      a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = false; // change_1a
    } else {
      a_hasProperty(cellId, SolverCell::IsInactive) = false;
      if(c_isLeafCell(cellId)) {
        a_hasProperty(cellId, SolverCell::IsActive) = true;
        a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = true;
      }
      if(oldStatus && (!a_hasProperty(cellId, SolverCell::NearWall))
         && !a_hasProperty(cellId, SolverCell::IsNotGradient)) {
        a_hasProperty(cellId, SolverCell::IsFlux) = true;
        rebuildCells.insert(cellId);
        // rebuildReconstructionConstants( cellId );
      }
    }
  }

  m_fvBndryCnd->correctCellCoordinates();
  for(auto it = rebuildCells.begin(); it != rebuildCells.end(); ++it) {
    rebuildReconstructionConstants(*it);
  }
  rebuildCells.clear();
  m_fvBndryCnd->recorrectCellCoordinates();

  // TODO labels:FVMB update IsInactive on cells at a Leveljump!
  //      the coarser cell needs to have a neighbor in the direction of the finer cell
  //      if any of the neighboring fine cells is !IsInactive.
  //      => IsInactive of the parent must be set to false, but the cell must not be
  //         IsOnCurrentMGLevel!
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::descendLevelSetValue(const MInt cellId, const MInt* const bodyIds,
                                                               const MInt bodyCnt) {
  for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
    a_associatedBodyIds(cellId, set) = -1;
    a_levelSetValuesMb(cellId, set) = m_bodyDistThreshold + 1e-14;
  }

  for(MInt b = 0; b < bodyCnt; b++) {
    const MInt k = bodyIds[b];
    const MInt set = m_bodyToSetTable[k];
    MFloat dist = getDistance(cellId, k);

    if(fabs(dist) < fabs(a_levelSetValuesMb(cellId, set)) || (dist < F0)) {
      a_levelSetValuesMb(cellId, set) = dist;
      a_associatedBodyIds(cellId, set) = k;
    }
  }

  if(m_startSet > 0) {
    a_levelSetValuesMb(cellId, 0) = a_levelSetValuesMb(cellId, m_startSet);
    a_associatedBodyIds(cellId, 0) = a_associatedBodyIds(cellId, m_startSet);
    for(MInt i = (m_startSet + 1); i < m_noSets; i++) {
      if(a_levelSetValuesMb(cellId, i) < a_levelSetValuesMb(
             cellId, 0)) { // a distinction between concave and convex boundaries has to be made here!!!!!
        a_levelSetValuesMb(cellId, 0) = a_levelSetValuesMb(cellId, i);
        a_associatedBodyIds(cellId, 0) = a_associatedBodyIds(cellId, i);
      }
    }
  }

  for(MInt child = 0; child < m_noCellNodes; child++) {
    if(c_childId(cellId, child) < 0) continue;
    descendLevelSetValue(c_childId(cellId, child), bodyIds, bodyCnt);
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::descendDistance(const MInt cellId, const MInt* const bodyIds,
                                                          const MInt bodyCnt, MIntScratchSpace& nearestBodies,
                                                          MFloatScratchSpace& nearestDist) {
  MInt* const nearBodies = &nearestBodies[cellId * m_maxNearestBodies];
  MFloat* const nearDist = &nearestDist[cellId * m_maxNearestBodies];

  for(MInt b = 0; b < bodyCnt; b++) {
    const MInt k = bodyIds[b];
    MFloat dist = getDistance(cellId, k);

    for(MInt n = 0; n < m_maxNearestBodies; n++) {
      if(fabs(dist) < fabs(nearDist[n])) {
        if(n < m_maxNearestBodies - 1) {
          std::rotate(nearBodies + n, nearBodies + m_maxNearestBodies - 1, nearBodies + m_maxNearestBodies);
          std::rotate(nearDist + n, nearDist + m_maxNearestBodies - 1, nearDist + m_maxNearestBodies);
        }
        nearDist[n] = dist;
        nearBodies[n] = k;
        break;
      }
    }
  }

  for(MInt child = 0; child < m_noCellNodes; child++) {
    if(c_childId(cellId, child) < 0) continue;
    descendDistance(c_childId(cellId, child), bodyIds, bodyCnt, nearestBodies, nearestDist);
  }
}


/**
 * \brief stores all cells and surfaces needed for the flux computation
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::writeListOfActiveFlowCells() {
  TRACE();

  // 1. update collector sizes
  m_noFlowCells = a_noCells();
  m_noSurfaces = a_noSurfaces();
  m_noBndryCells = m_fvBndryCnd->m_bndryCells->size();

  // 2. set active cells
  const MInt noAllCells = a_noCells();

  m_noActiveCells = 0;
  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    if(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      m_activeCellIds[m_noActiveCells] = cellId;
      m_noActiveCells++;
    }
  }

  m_noActiveHaloCellOffset = m_noActiveCells;
  for(MInt cellId = noInternalCells(); cellId < noAllCells; cellId++) {
    if(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      m_activeCellIds[m_noActiveCells] = cellId;
      m_noActiveCells++;
    }
  }

  // 3. log statistics
  logOutput();
}


/**
 * \brief logs several collector sizes
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::logOutput() {
  TRACE();

  MInt noCells_solver = m_cells.size();
  MInt noCells_grid = c_noCells();
  MInt nosplitchilds = m_totalnosplitchilds;
  MInt nosurfaces = m_noSurfaces;
  MInt noboundarycells = m_noBndryCells;
  MInt nolsmbcells = m_noLsMbBndryCells;

  if(globalTimeStep % m_loggingInterval == 0) {
    MPI_Allreduce(MPI_IN_PLACE, &noCells_solver, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE ",
                  "noCells_solver");
    MPI_Allreduce(MPI_IN_PLACE, &noCells_grid, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE ", "noCells_grid");
    MPI_Allreduce(MPI_IN_PLACE, &nosplitchilds, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE ", "nosplitchilds");
    MPI_Allreduce(MPI_IN_PLACE, &nosurfaces, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE ", "nosurfaces");
    MPI_Allreduce(MPI_IN_PLACE, &noboundarycells, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE ",
                  "noboundarycells");
    MPI_Allreduce(MPI_IN_PLACE, &nolsmbcells, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE ", "nolsmbcells");

    m_log << "======================================================" << endl << endl;
    m_log << "Grid summary at time step " << globalTimeStep << endl << endl;
    m_log << setfill(' ');
    m_log << "number of grid-cells                         " << setw(7) << noCells_grid << endl;
    m_log << "number of fv-cells                           " << setw(7) << noCells_solver << endl;
    m_log << "number of splitchilds                        " << setw(7) << nosplitchilds << endl;
    m_log << "number of surfaces                           " << setw(7) << nosurfaces << endl;
    m_log << "number of boundary cells                     " << setw(7) << noboundarycells << endl;
    m_log << "number of moving boundary cells              " << setw(7) << nolsmbcells << endl;
    m_log << "======================================================" << endl << endl;
  }
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::applyInitialCondition() {
  TRACE();

  if(m_initialCondition == 465 && m_constructGField) setInfinityState();
  FvCartesianSolverXD<nDim, SysEqn>::applyInitialCondition();
  updateInfinityVariables();
}


/**
 * \brief initializes the level-set data at startup
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::initGField() {
  TRACE();

  ASSERT(m_constructGField, "");

  if(m_constructGField && m_bodyTypeMb > 0) {
    initBodyProperties();
    constructGField();
  } else if(m_bodyTypeMb != 0) {
    mTerm(1, AT_, "Unknown body type.");
  }
}


/**
 * \brief initializes the bndryLayer data and is/was inactive at solver initialisation
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::initBndryLayer() {
  TRACE();

  std::vector<MInt>().swap(m_bndryLayerCells);
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    a_hasProperty(cellId, SolverCell::NearWall) = false;

    if(a_bndryId(cellId) < -1) continue;

    a_hasProperty(cellId, SolverCell::IsInactive) = false;
    a_hasProperty(cellId, SolverCell::WasInactive) = false;

    if(c_noChildren(cellId) > 0) {
      a_hasProperty(cellId, SolverCell::IsInactive) = true;
      a_hasProperty(cellId, SolverCell::WasInactive) = true;
      continue;
    }

    if(a_levelSetValuesMb(cellId, 0) > m_maxBndryLayerDistances[a_level(cellId)][0]
       && a_levelSetValuesMb(cellId, 0) < m_maxBndryLayerDistances[a_level(cellId)][1] && c_isLeafCell(cellId)) {
      m_bndryLayerCells.push_back(cellId);
      a_hasProperty(cellId, SolverCell::NearWall) = true;
    }

    if(a_levelSetValuesMb(cellId, 0) < F0 || !c_isLeafCell(cellId)) {
      a_hasProperty(cellId, SolverCell::IsInactive) = true;
      a_hasProperty(cellId, SolverCell::WasInactive) = true;
      a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = false;
    }
  }
}


/**
 * \brief Re-initializes the solver
 * \author Lennart Schneiders
 * mode = -1: default argument, regular call (each time step)
 * mode =  0: reinit after mesh adaptation
 * mode =  1: initial call before first time step
 * mode =  2: reinit after load balancing (depricated)
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::reInitSolutionStep(const MInt mode) {
  TRACE();

  if((mode < 0) && (!m_trackMovingBndry || globalTimeStep < m_trackMbStart || globalTimeStep > m_trackMbEnd)) {
    return;
  }

  NEW_TIMER_GROUP_STATIC(t_initTimer, "reInitSolutionStep");
  NEW_TIMER_STATIC(t_timertotal, "reInitSolutionStep", t_initTimer);
  NEW_SUB_TIMER_STATIC(t_resetSolverMb, "resetSolverMb", t_timertotal);
  NEW_SUB_TIMER_STATIC(t_trackBoundaryLayer, "trackBoundaryLayer", t_timertotal);
  NEW_SUB_TIMER_STATIC(t_generateBndryCellsMb, "generateBndryCellsMb", t_timertotal);
  NEW_SUB_TIMER_STATIC(t_imagePointRec, "imagePointRec", t_timertotal);
  NEW_SUB_TIMER_STATIC(t_initBndEx, "initBndEx", t_timertotal);
  NEW_SUB_TIMER_STATIC(t_massRedist, "massRedist", t_timertotal);
  NEW_SUB_TIMER_STATIC(t_initSmallCells, "initSmallCells", t_timertotal);
  NEW_SUB_TIMER_STATIC(t_generateSurfaces, "generateSurfaces", t_timertotal);
  NEW_SUB_TIMER_STATIC(t_buildLeastSquaresStencil, "buildLeastSquaresStencil", t_timertotal);
  NEW_SUB_TIMER_STATIC(t_finalize, "finalize", t_timertotal);
  m_tCutGroupTotal = t_timertotal;
  m_tCutGroup = t_generateBndryCellsMb;
  RECORD_TIMER_START(t_timertotal);

  RECORD_TIMER_START(m_timers[Timers::ReinitSolu]);

  // update cfl-number and change timeStep
  if(m_timeStepAdaptationStart > -1 && m_structureStep == 0) {
    setTimeStep();
  }

  m_reComputedBndry = true;
  RECORD_TIMER_START(t_resetSolverMb);
  if(mode != 0) {
    resetSolverMb();
  }
  RECORD_TIMER_STOP(t_resetSolverMb);

  RECORD_TIMER_START(t_trackBoundaryLayer);
  setLevelSetMbCellProperties();
#if defined _MB_DEBUG_ || !defined NDEBUG
  checkHaloCells();
#endif
  RECORD_TIMER_STOP(t_trackBoundaryLayer);

  RECORD_TIMER_START(m_timers[Timers::BndryMb]);
  RECORD_TIMER_START(t_generateBndryCellsMb);
  generateBndryCellsMb(mode);
  RECORD_TIMER_STOP(t_generateBndryCellsMb);
  RECORD_TIMER_STOP(m_timers[Timers::BndryMb]);

  if(m_wmLES) {
    m_fvBndryCnd->initWMSurfaces();
    Base::initWMExchange();
    Base::exchangeWMVars();
  }

#if defined _MB_DEBUG_ || !defined NDEBUG
  // In debug mode exhange() calls maxResidual(), which fails if RHS
  // is not set to 0 during init call (contains nans otherwise)
  resetRHS();
#endif

  m_bndryGhostCellsOffset = a_noCells();
  m_initialSurfacesOffset = a_noSurfaces();

  // possibility for bndryCell distribution over all ranks!
  // This is useful to check the balance/distribution
  //=> keep the commented code below!
  /*
  if(mode != -1 || globalTimeStep % 10 == 0) {
    MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();
    MInt maxBndryCells = 0;
    MInt minBndryCells = -1;
    MInt sumBndryCells = 0;

    MPI_Allreduce(&noBndryCells, &maxBndryCells, 1, MPI_INT, MPI_MAX, mpiComm(),
           AT_, "maxBndryCells","noBndryCells" );

    MPI_Allreduce(&noBndryCells, &minBndryCells, 1, MPI_INT, MPI_MIN, mpiComm(),
            AT_, "maxBndryCells","noBndryCells" );
    MPI_Allreduce(&noBndryCells, &sumBndryCells, 1, MPI_INT, MPI_SUM, mpiComm(),
            AT_, "maxBndryCells","noBndryCells" );


     if(domainId() == 0) {
       cerr << "Min/Max/Avg Bndry-Cell-Count: " << minBndryCells << " "
            << maxBndryCells << " " << sumBndryCells/noDomains() << endl;
     }

     if(noBndryCells == maxBndryCells) {
       cerr << "Rank with max-BndryCells has " << a_noCells() << " cells and "
            << m_initialSurfacesOffset << " surfaces!" << endl;
     }
  }
  */

  m_fvBndryCnd->correctCellCoordinates();

  if((!m_levelSetMb || m_gapOpened) && mode < 1 && m_gapInitMethod == 0) {
    initializeEmergedCells();
  }

#ifdef _MB_DEBUG_XXX
  for(MInt i = 0; i < a_noCells(); i++) {
    if((a_levelSetValuesMb(i, 0) > F0 || a_bndryId(i) > -1) && (c_noChildren(i) == 0)
       && ((!a_hasProperty(i, SolverCell::IsActive) && !a_isHalo(i))
           || ((!a_hasProperty(i, SolverCell::IsOnCurrentMGLevel) || a_hasProperty(i, SolverCell::IsInactive))
               && !a_hasProperty(i, SolverCell::IsNotGradient)))) {
      cerr << domainId() << ": " << i << " " << c_globalId(i) << " /b " << a_bndryId(i) << " /l "
           << a_levelSetValuesMb(i, 0) << " /i " << a_hasProperty(i, SolverCell::IsInactive) << " /p15 " << a_isHalo(i)
           << " /p7 " << a_hasProperty(i, SolverCell::IsNotGradient) << " /p10 " << a_hasProperty(i, SolverCell::IsFlux)
           << " /p11 " << a_hasProperty(i, SolverCell::IsActive) << " /p13 "
           << a_hasProperty(i, SolverCell::IsOnCurrentMGLevel) << endl;
      mTerm(1, AT_, "Invalid cell flag.");
    }
  }
#endif

  if(m_fvBndryCnd->m_cellMerging) {
    findNghbrIds();
    if(m_fvBndryCnd->m_multipleGhostCells) {
      m_fvBndryCnd->detectSmallBndryCellsMGC();
    } else {
      m_fvBndryCnd->detectSmallBndryCells();
    }
    if(m_fvBndryCnd->m_multipleGhostCells) {
      m_fvBndryCnd->mergeCellsMGC();
    } else {
      m_fvBndryCnd->mergeCells();
    }
    mDeallocate(m_storeNghbrIds);
    mDeallocate(m_identNghbrIds);
    m_log << " found " << m_fvBndryCnd->m_smallBndryCells->size() << "small cells." << endl;
  } else {
    RECORD_TIMER_START(m_timers[Timers::NearBndry]);
    RECORD_TIMER_START(t_initBndEx);
    m_fvBndryCnd->setNearBoundaryRecNghbrs(m_movingBndryCndId);
    if(grid().azimuthalPeriodicity()) {
      updateAzimuthalMaxLevelRecCoords();
      updateAzimuthalNearBoundaryExchange();
      buildAdditionalAzimuthalReconstructionStencil(1);
      if(mode == 0) initAzimuthalCartesianHaloInterpolation();
    }
    initNearBoundaryExchange(1, m_noOuterBndryCells);

    RECORD_TIMER_STOP(m_timers[Timers::NearBndry]);
    RECORD_TIMER_STOP(t_initBndEx);
    RECORD_TIMER_START(t_massRedist);
#ifdef _ALE_FORM_
    if(mode > 0) {
      std::vector<MInt>().swap(m_massRedistributionIds);
      std::vector<MFloat>().swap(m_massRedistributionVariables);
      std::vector<MFloat>().swap(m_massRedistributionRhs);
      std::vector<MFloat>().swap(m_massRedistributionVolume);
      std::vector<MFloat>().swap(m_massRedistributionSweptVol);
      std::vector<std::tuple<MInt, MInt, MInt>>().swap(m_temporarilyLinkedCells);
    }
    redistributeMass();
    // call before initSmallCellCorrection
    // but after correctCellCoordinates and initNearBoundaryExchange !!
#endif
    RECORD_TIMER_STOP(t_massRedist);

    RECORD_TIMER_START(t_imagePointRec);
    m_fvBndryCnd->computeImagePointRecConst(m_movingBndryCndId);
    RECORD_TIMER_STOP(t_imagePointRec);

    RECORD_TIMER_START(m_timers[Timers::InitSmallCorr]);
    RECORD_TIMER_START(t_initSmallCells);
    if(m_fvBndryCnd->m_smallCellRHSCorrection) {
      m_fvBndryCnd->initSmallCellRHSCorrection(m_movingBndryCndId);
    } else {
      m_fvBndryCnd->initSmallCellCorrection(m_movingBndryCndId);
    }
    RECORD_TIMER_STOP(t_initSmallCells);
    RECORD_TIMER_STOP(m_timers[Timers::InitSmallCorr]);
  }

  // check surfaces for gapClosing
  if(m_levelSet && m_closeGaps) {
    for(MInt region = 0; region < m_noGapRegions; region++) {
      if(m_gapState[region] != -2) continue;
      for(MInt srfcId = 0; srfcId < a_noSurfaces(); srfcId++) {
        MInt nghbrId0 = a_surfaceNghbrCellId(srfcId, 0);
        MInt nghbrId1 = a_surfaceNghbrCellId(srfcId, 1);
        if(nghbrId0 <= 0 || nghbrId1 <= 0) continue;
        if(a_isGapCell(nghbrId0) && a_isGapCell(nghbrId1) && a_hasProperty(nghbrId0, SolverCell::IsInactive)
           && a_hasProperty(nghbrId1, SolverCell::IsInactive)) {
          ASSERT(!a_hasProperty(nghbrId0, SolverCell::WasInactive) && !a_hasProperty(nghbrId1, SolverCell::WasInactive),
                 "");

          ASSERT(a_levelSetValuesMb(nghbrId0, 0) < 0 && a_levelSetValuesMb(nghbrId1, 0) < 0, "");

          ASSERT(m_gapInitMethod == 0, "This should have already been done in gapHandling! ");
          deleteSurface(srfcId);

          cerr << "Deleting Gap-shadowed surfaces in region " << region << " due to Gap-Closure at timestep "
               << globalTimeStep << endl;
          cerr << " Of Cells: " << c_globalId(nghbrId0) << " and " << c_globalId(nghbrId1) << endl;
        }
      }
    }
  }

  RECORD_TIMER_START(m_timers[Timers::GhostCells]);
  RECORD_TIMER_START(t_generateSurfaces);
  correctSrfcsMb();
  compactSurfaces();

#if defined _MB_DEBUG_ || !defined NDEBUG
  for(MInt srfcId = 0; srfcId < a_noSurfaces(); srfcId++) {
    MInt nghbrId0 = a_surfaceNghbrCellId(srfcId, 0);
    MInt nghbrId1 = a_surfaceNghbrCellId(srfcId, 1);
    ASSERT(nghbrId0 > -1 && nghbrId1 > -1, "");
    if(a_hasProperty(nghbrId0, SolverCell::IsInactive) || a_hasProperty(nghbrId1, SolverCell::IsInactive)) {
      cerr << "p15/p7: " << a_isHalo(nghbrId0) << " " << a_isHalo(nghbrId1) << " / " << nghbrId0 << " " << nghbrId1
           << " / " << c_globalId(nghbrId0) << " " << c_globalId(nghbrId1) << " / "
           << a_hasProperty(nghbrId0, SolverCell::IsNotGradient) << " "
           << a_hasProperty(nghbrId1, SolverCell::IsNotGradient) << " / " << a_isGapCell(nghbrId0) << " "
           << a_isGapCell(nghbrId1) << " / " << a_hasProperty(nghbrId0, SolverCell::IsInactive) << " "
           << a_hasProperty(nghbrId1, SolverCell::IsInactive) << endl;
      cerr << "ls: " << a_levelSetValuesMb(nghbrId0, 0) << " " << a_levelSetValuesMb(nghbrId1, 0) << endl;
      cerr << "coord " << a_coordinate(nghbrId0, 0) << " " << a_coordinate(nghbrId0, 1) << " "
           << a_coordinate(nghbrId0, 2) << endl;
    }
    ASSERT(!a_hasProperty(nghbrId0, SolverCell::IsInactive) && !a_hasProperty(nghbrId1, SolverCell::IsInactive),
           to_string(srfcId) << " " << to_string(nghbrId0) << " " << to_string(nghbrId1) << " "
                             << to_string(a_noCells()) << " " << to_string(c_globalId(nghbrId0)) << " "
                             << to_string(c_globalId(nghbrId1)));
  }
#endif


  // restore outer boundary ghost cells and outer bounday surfaces
  const MInt noBnd = m_fvBndryCnd->m_bndryCells->size();
  m_fvBndryCnd->m_bndryCells->resetSize(m_noOuterBndryCells);
  m_initialSurfacesOffset = a_noSurfaces();
  setOuterBoundaryGhostCells();
  setOuterBoundarySurfaces();
  m_fvBndryCnd->m_bndryCells->resetSize(noBnd);

  // add Mb ghost cells and surfaces
  computeGhostCellsMb();
  addBoundarySurfacesMb();
  RECORD_TIMER_STOP(t_generateSurfaces);
  RECORD_TIMER_STOP(m_timers[Timers::GhostCells]);

  RECORD_TIMER_START(t_buildLeastSquaresStencil);
  buildAdditionalReconstructionStencil();
  RECORD_TIMER_STOP(t_buildLeastSquaresStencil);

  if(grid().azimuthalPeriodicity()) {
    buildAdditionalAzimuthalReconstructionStencil(0);
    initAzimuthalLinkedHaloExc();
    if(mode == 0 || m_wasBalanced) {
      m_wasBalanced = false;
    }
  }

  // possibility for surface distribution over all ranks!
  // This is useful to check the balance/distribution
  //=> keep the commented code below!
  /*
  if(mode != -1 || globalTimeStep % 10 == 0) {
    MInt initalSurf = m_initialSurfacesOffset;

    MInt maxInital = 0;
    MInt minInitial = 0;
    MInt sumInitial = 0;

    MPI_Allreduce(&initalSurf, &maxInital, 1,MPI_INT, MPI_MAX, mpiComm(),
                   AT_, "maxInitial","initialSurf" );

    MPI_Allreduce(&initalSurf, &minInitial, 1,  MPI_INT, MPI_MIN, mpiComm(),
                    AT_, "minTotal","minInitial" );

    MPI_Allreduce(&initalSurf, &sumInitial, 1,  MPI_INT, MPI_SUM, mpiComm(),
                    AT_, "minTotal","totalSurf" );

    if(domainId() == 0 ) {
      cerr << "Min/Max/Avg inital-Surface-Count: " << minInitial << " " << maxInital << " " << sumInitial/noDomains() <<
  endl;
    }

    if(maxInital == initalSurf) {
      cerr << "Rank with max-Surfaces has " << a_noCells() << " cells and "
           << m_fvBndryCnd->m_bndryCells->size() << "bndry-Cells" << endl;
    }
  }
  */

  RECORD_TIMER_START(t_finalize);
  if(m_fvBndryCnd->m_cellMerging) {
    m_fvBndryCnd->computePlaneVectors();
  }

#ifdef SAFOKSAJFKO
  const MFloat EPS = 1e-6;
  const MInt xdim = a_noCells();
  MFloat area[m_noDirs];
  MInt errorFlag = false;
  for(MInt cellId = xdim; cellId--;) {
    if(a_hasProperty(cellId, SolverCell::IsCutOff)) continue;
    if(a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;
    if(a_isPeriodic(cellId)) continue;
    if(a_isBndryGhostCell(cellId)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(a_isHalo(cellId) && a_level(cellId) < maxRefinementLevel()) continue;
    if(a_isHalo(cellId)) continue;
    if(a_isHalo(cellId) && a_bndryId(cellId) > -1 && a_bndryId(cellId) < m_noOuterBndryCells) continue;
    MBool skip = false;
    if(a_isHalo(cellId) && a_level(cellId) == maxRefinementLevel()) {
      for(MInt dir = 0; dir < m_noDirs; dir++) {
        if(a_hasNeighbor(cellId, dir) > 0) {
          MInt nghbrId = c_neighborId(cellId, dir);
          if(a_hasProperty(nghbrId, SolverCell::IsNotGradient)) skip = true;
        } else {
          skip = true;
        }
      }
    }
    if(skip) continue;
    // if ( c_noChildren( cellId ) > 0 ) continue;
    MFloat test[nDim];
    const MFloat sign[2] = {-F1, F1};
    for(MInt k = 0; k < nDim; k++)
      test[k] = F0;
    MBool hasBndrySurface = false;
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      area[dir] = F0;
      if(m_cellSurfaceMapping[cellId][dir] > -1) {
        MInt srfcId = m_cellSurfaceMapping[cellId][dir];
        // if ( m_isActiveSurface[ srfcId ] ) {
        {
          MInt id = -1;
          if(a_surfaceNghbrCellId(srfcId, 0) == cellId)
            id = 1;
          else if(a_surfaceNghbrCellId(srfcId, 1) == cellId)
            id = 0;
          if(id < 0) continue;
          test[a_surfaceOrientation(srfcId)] += sign[id] * a_surfaceArea(srfcId);
          area[dir] = a_surfaceArea(srfcId);
        }
      } else if(a_hasNeighbor(cellId, dir) > 0) {
        MInt nghbrId = c_neighborId(cellId, dir);
        if(c_noChildren(nghbrId) > 0) {
          for(MInt child = 0; child < m_noCellNodes; child++) {
            if(!childCode[dir][child]) continue;
            MInt childId = c_childId(nghbrId, child);
            if(childId < 0) continue;
            if(m_cellSurfaceMapping[childId][m_revDir[dir]] > -1) {
              if(a_surfaceNghbrCellId(m_cellSurfaceMapping[childId][m_revDir[dir]], m_nghbrCellIds[m_revDir[dir] % 2) == cellId) {
                MInt srfcId = m_cellSurfaceMapping[childId][m_revDir[dir]];
                // if ( m_isActiveSurface[ srfcId ] ) {
                {
                  MInt id = -1;
                  if(a_surfaceNghbrCellId(srfcId, 0) == cellId)
                    id = 1;
                  else if(a_surfaceNghbrCellId(srfcId, 1) == cellId)
                    id = 0;
                  if(id < 0) continue;
                  test[a_surfaceOrientation(srfcId)] += sign[id] * a_surfaceArea(srfcId);
                  area[dir] = a_surfaceArea(srfcId);
                }
              }
            }
          }
        } else if(a_hasProperty(cellId, SolverCell::HasSplitFace)) {
          for(MInt srfcId = a_noSurfaces(); srfcId--;) {
            // if ( !m_isActiveSurface[ srfcId ] ) continue;
            if(a_surfaceBndryCndId(srfcId) > -1) continue;
            MInt id = -1;
            if(a_surfaceNghbrCellId(srfcId, 0) == cellId && dir == 2 * a_surfaceOrientation(srfcId) + 1)
              id = 1;
            else if(a_surfaceNghbrCellId(srfcId, 1) == cellId && dir == 2 * a_surfaceOrientation(srfcId))
              id = 0;
            if(id > -1) {
              test[a_surfaceOrientation(srfcId)] += sign[id] * a_surfaceArea(srfcId);
              area[dir] = a_surfaceArea(srfcId);
            }
          }
        }
      }
    }
    if(a_bndryId(cellId) > -1) {
      for(MInt bs = 0; bs < m_fvBndryCnd->m_noBoundarySurfaces; bs++) {
        MInt srfcId = m_fvBndryCnd->m_boundarySurfaces[bs];
        // if ( m_isActiveSurface[ srfcId ] ) {
        {
          MInt id = -1;
          if(a_surfaceNghbrCellId(srfcId, 0) == cellId)
            id = 1;
          else if(a_surfaceNghbrCellId(srfcId, 1) == cellId)
            id = 0;
          if(id < 0) continue;
          hasBndrySurface = true;
          test[a_surfaceOrientation(srfcId)] += sign[id] * a_surfaceArea(srfcId);
        }
      }
    }
    MBool testPassed = true;
    for(MInt k = 0; k < nDim; k++) {
      if(fabs(test[k]) > EPS * m_gridCellArea[a_level(cellId)]) {
        testPassed = false;
      }
    }

    if(!testPassed) {
      for(MInt k = 0; k < nDim; k++) {
        cerr << domainId() << " " << nDim << ": cell " << cellId << " " << a_bndryId(cellId) << " "
             << a_hasProperty(cellId, SolverCell::IsInactive) << " " << (a_bndryId(cellId) < m_noOuterBndryCells)
             << " / " << hasBndrySurface << " " << a_isHalo(cellId) << " "
             << a_hasProperty(cellId, SolverCell::IsNotGradient) << " / " << k << " " << fabs(test[k]) << endl;
      }
      cerr << "Cell surface is not closed. Check the surfaces! " << domainId() << " " << cellId << " "
           << a_bndryId(cellId) << " " << a_isHalo(cellId) << " " << a_level(cellId) << " "
           << a_hasProperty(cellId, SolverCell::IsInactive) << " " << a_hasProperty(cellId, SolverCell::IsSplitCell)
           << " " << a_hasProperty(cellId, SolverCell::IsSplitChild) << " "
           << a_hasProperty(cellId, SolverCell::HasSplitFace) << endl;
      m_log << "Cell surface is not closed. Check the surfaces! " << domainId() << " " << cellId << " "
            << a_bndryId(cellId) << " " << a_isHalo(cellId) << " " << a_level(cellId) << endl;
      for(MInt dir2 = 0; dir2 < m_noDirs; dir2++) {
        cerr << m_cellSurfaceMapping[cellId][dir2] << "(";
        MInt nghbrId = (a_hasNeighbor(cellId, dir2) > 0) ? c_neighborId(cellId, dir2) : -1;
        MInt state = (nghbrId > -1) ? a_hasProperty(nghbrId, SolverCell::IsInactive) : -1;
        cerr << nghbrId << "/" << state << ") ";
      }
      cerr << endl;
      errorFlag = true;
    }
  }

  const MInt xdim0 = a_noCells();
  for(MInt i = xdim0; i--;) {
    if(a_hasProperty(i, SolverCell::IsCutOff)) continue;
    if(a_hasProperty(i, SolverCell::IsNotGradient)) continue;
    if(a_isBndryGhostCell(i)) continue;
    if(a_hasProperty(i, SolverCell::IsInactive)) continue;
    ASSERT((a_noReconstructionNeighbors(i) == 0 || c_noChildren(i) == 0), "No reconstruction nghbrs expected");
    if(c_noChildren(i) > 0) continue;
    MBool localError = false;
    for(MInt n = a_noReconstructionNeighbors(i); n--;) {
      if((a_bndryId(a_reconstructionNeighborId(i, n)) > -2)
         && (a_isBndryGhostCell(a_reconstructionNeighborId(i, n))
             || a_hasProperty(a_reconstructionNeighborId(i, n), SolverCell::IsInactive)
             || !a_hasProperty(a_reconstructionNeighborId(i, n), SolverCell::IsOnCurrentMGLevel))) {
        cerr << domainId() << ": Inactive cell used in least squares reconstruction!!!!" << i << " " << n << "/"
             << a_noReconstructionNeighbors(i) << " / " << a_reconstructionNeighborId(i, n) << " " << a_isHalo(i) << " "
             << a_isBndryGhostCell(i) << " /l " << a_level(i) << " " << a_level(a_reconstructionNeighborId(i, n))
             << " / " << a_hasProperty(i, SolverCell::IsInactive) << " " << a_bndryId(i) << " /c "
             << a_coordinate(a_reconstructionNeighborId(i, n), 0) << " "
             << a_coordinate(a_reconstructionNeighborId(i, n), 1) << " " << a_coordinate(i, 0) << " "
             << a_coordinate(i, 1) << " / "
             << a_hasProperty(a_reconstructionNeighborId(i, n), SolverCell::IsOnCurrentMGLevel) << " "
             << a_isHalo(a_reconstructionNeighborId(i, n)) << " "
             << a_hasProperty(a_reconstructionNeighborId(i, n), SolverCell::IsNotGradient) << " "
             << a_isBndryGhostCell(a_reconstructionNeighborId(i, n)) << " "
             << a_hasProperty(a_reconstructionNeighborId(i, n), SolverCell::IsInactive) << " "
             << a_bndryId(a_reconstructionNeighborId(i, n)) << endl;
        // writeVtkErrorFile();
        localError = true;
      }
    }
    if(localError) {
      for(MInt n = 0; n < a_noReconstructionNeighbors(i); n++) {
        m_log << a_reconstructionNeighborId(i, n) << " ";
      }
      m_log << endl;
      errorFlag = true;
    }
  }
  if(errorFlag) {
    cerr << domainId() << ": Error in reInitSolutionStep" << endl;
    m_log << "Error in reInitSolutionStep" << endl;
  }

  MPI_Allreduce(MPI_IN_PLACE, &errorFlag, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "errorFlag");

  if(errorFlag) {
    cerr << "Error in reInitSolutionStep" << endl;
    m_log << "Error in reInitSolutionStep" << endl;
    writeVtkErrorFile();
    MPI_Barrier(mpiComm(), AT_);
    mTerm(1, AT_, ".");
  }
#endif

  if((mode == 1)) {
    MFloat* RESTRICT slope = (MFloat*)(&(a_slope(0, 0, 0)));
    const MInt size = a_noCells() * m_slopeMemory * sizeof(MFloat);
    memset(&(slope[0]), 0, size);
    applyBoundaryConditionMb();
    leastSquaresReconstruction();
    applyBoundaryConditionMb();
    if(m_trackBodySurfaceData) computeBodySurfaceData();
    if(m_initialCondition == 15 || m_initialCondition == 16) {
      if(globalTimeStep == 0 && mode == 1) computeFlowStatistics(true);
    }
  }

  if(m_restart) m_restart = false;

#ifdef _MB_DEBUG_
  MFloatScratchSpace rhsTest(a_noCells(), AT_, "rhsTest");
  rhsTest.fill(F0);
  for(MInt srfcId = a_noSurfaces(); srfcId--;) {
    rhsTest[a_surfaceNghbrCellId(srfcId, 0)] += a_surfaceArea(srfcId);
    rhsTest[a_surfaceNghbrCellId(srfcId, 1)] -= a_surfaceArea(srfcId);
  }

  for(MInt i = a_noCells(); i--;) {
    if(!a_hasProperty(i, SolverCell::IsActive)) continue;
    if(!a_hasProperty(i, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_isHalo(i)) continue;
    if(a_isBndryGhostCell(i)) continue;
    if(a_hasProperty(i, SolverCell::IsInactive)) continue;
    if(fabs(rhsTest[i]) > 1e-10) {
      cerr << domainId() << " Warning: cell may not be water tight " << i << " " << rhsTest[i] << " "
           << a_coordinate(i, 0) << " " << a_coordinate(i, 1) << " " << a_coordinate(i, mMin(nDim - 1, 2)) << endl;
    }
  }
#endif

  // memory statistics:
  /*
  MLong noBndryCells = (MLong)m_fvBndryCnd->m_bndryCells->size();
  MLong noSurfaces = (MLong)a_noSurfaces();
  MLong noCells = (MLong)a_noCells();

  m_log << "Maximum memory-values: " << endl;
  m_log << "Cells      : " << noCells << endl;
  m_log << "Bndry-Cells: " << noBndryCells << endl;
  m_log << "Surfaces   : " << noSurfaces << endl;

  MPI_Allreduce(MPI_IN_PLACE, &noBndryCells, 1, MPI_LONG, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "noBndryCells");
  MPI_Allreduce(MPI_IN_PLACE, &noSurfaces, 1, MPI_LONG, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "noSurfaces");
  MPI_Allreduce(MPI_IN_PLACE, &noCells, 1, MPI_LONG, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "noCells");

  cerr0 << "Maximum memory-values: " << endl;
  cerr0 << "Cells      : " << noCells << endl;
  cerr0 << "Bndry-Cells: " << noBndryCells << endl;
  cerr0 << "Surfaces   : " << noSurfaces << endl;
  */

  RECORD_TIMER_STOP(m_timers[Timers::ReinitSolu]);
  RECORD_TIMER_STOP(t_finalize);
  RECORD_TIMER_STOP(t_timertotal);
  DISPLAY_TIMER_OFFSET(t_timertotal, m_restartInterval);
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::updateSplitParentVariables() {
  for(MUint sc = 0; sc < m_splitCells.size(); sc++) {
    const MInt cellId = m_splitCells[sc];
    MFloat volCnt = F0;

    for(MInt v = 0; v < m_noCVars; v++) {
      a_variable(cellId, v) = F0;
    }

    for(MInt v = 0; v < m_noFVars; v++) {
      a_rightHandSide(cellId, v) = F0;
      m_rhs0[cellId][v] = F0;
    }

    for(MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) {
      const MInt splitChildId = m_splitChilds[sc][ssc];
      for(MInt v = 0; v < m_noCVars; v++) {
        a_variable(cellId, v) += a_cellVolume(splitChildId) * a_variable(splitChildId, v);
      }

      for(MInt v = 0; v < m_noFVars; v++) {
        a_rightHandSide(cellId, v) += a_rightHandSide(splitChildId, v);
        m_rhs0[cellId][v] += m_rhs0[splitChildId][v];
      }
      volCnt += a_cellVolume(splitChildId);
    }
    volCnt = mMax(volCnt, m_eps);

    for(MInt v = 0; v < m_noCVars; v++) {
      a_variable(cellId, v) /= volCnt;
    }
  }

  if(m_useCentralDifferencingSlopes) {
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      if(a_bndryId(cellId) != -1) continue;
      if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
      if(c_isLeafCell(cellId)) continue;

      if(a_level(cellId) == minLevel()) {
        reduceData(cellId, &a_pvariable(0, 0), m_noPVars);
        reduceData(cellId, &a_variable(0, 0), m_noCVars);
      }
    }
  }
}


/**
 * \brief Reconstructs the flux on the surfaces
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::Muscl(MInt NotUsed(timerId)) {
  TRACE();

  applyBoundaryConditionMb();

  RECORD_TIMER_START(m_timers[Timers::MusclReconst]);
  leastSquaresReconstruction();
  RECORD_TIMER_STOP(m_timers[Timers::MusclReconst]);

  RECORD_TIMER_START(m_timers[Timers::MusclCopy]);
  m_fvBndryCnd->copySlopesToSmallCells();
  RECORD_TIMER_STOP(m_timers[Timers::MusclCopy]);

  RECORD_TIMER_START(m_timers[Timers::MusclGhostSlopes]);
  updateGhostCellSlopesInviscid();
  RECORD_TIMER_STOP(m_timers[Timers::MusclGhostSlopes]);

  RECORD_TIMER_START(m_timers[Timers::MusclCutSlopes]);
  m_fvBndryCnd->updateCutOffSlopesInviscid();
  RECORD_TIMER_STOP(m_timers[Timers::MusclCutSlopes]);

  RECORD_TIMER_START(m_timers[Timers::MusclReconstSrfc]);
  (this->*m_reconstructSurfaceData)(-1);
  RECORD_TIMER_STOP(m_timers[Timers::MusclReconstSrfc]);

#ifdef _MB_DEBUG_
  m_solutionDiverged = false;
  for(MInt srfcId = a_noSurfaces(); srfcId--;) {
    {
      MInt nghbr0 = a_surfaceNghbrCellId(srfcId, 0);
      MInt nghbr1 = a_surfaceNghbrCellId(srfcId, 1);
      MInt ghost =
          (a_bndryId(mMin(nghbr0, nghbr1)) > -1)
              ? m_fvBndryCnd->m_bndryCells->a[a_bndryId(mMin(nghbr0, nghbr1))].m_srfcVariables[0]->m_ghostCellId
              : -2;
      MBool divd = false;
      for(MInt v = 0; v < m_noCVars; v++) {
        if(std::isnan(a_surfaceVariable(srfcId, 0, v)) || std::isnan(a_surfaceVariable(srfcId, 1, v))) divd = true;
      }
      if(a_surfaceVariable(srfcId, 0, PV->P) < F0 || a_surfaceVariable(srfcId, 1, PV->P) < F0
         || a_surfaceVariable(srfcId, 0, PV->RHO) < F0 || a_surfaceVariable(srfcId, 1, PV->RHO) < F0)
        divd = true;
      if(divd) {
        cerr << domainId() << ": surf var " << globalTimeStep << " " << srfcId << " " << c_globalId(nghbr0) << " "
             << c_globalId(nghbr1) << " /g " << ghost << " " << a_bndryId(nghbr0) << " " << a_bndryId(nghbr1) << " /bc "
             << a_surfaceBndryCndId(srfcId) << " /sp " << a_surfaceVariable(srfcId, 0, PV->P) << " "
             << a_surfaceVariable(srfcId, 1, PV->P) << " /vf "
             << a_cellVolume(nghbr0) / grid().gridCellVolume(a_level(nghbr0)) << " "
             << a_cellVolume(nghbr1) / grid().gridCellVolume(a_level(nghbr1)) << " /l " << a_level(nghbr0) << " "
             << a_level(nghbr1) << " /p15 " << a_isHalo(nghbr0) << " " << a_isHalo(nghbr1) << " /p7 "
             << a_hasProperty(nghbr0, SolverCell::IsNotGradient) << " "
             << a_hasProperty(nghbr1, SolverCell::IsNotGradient) << " /c " << a_surfaceCoordinate(srfcId, 0) << " "
             << a_surfaceCoordinate(srfcId, 1) << " " << a_surfaceCoordinate(srfcId, mMin(nDim - 1, 2)) << " /pc "
             << a_pvariable(nghbr0, PV->P) << " " << a_pvariable(nghbr1, PV->P) << " /p "
             << a_surfaceVariable(srfcId, 0, PV->P) << " " << a_surfaceVariable(srfcId, 1, PV->P) << " /rho "
             << a_surfaceVariable(srfcId, 0, PV->RHO) << " " << a_surfaceVariable(srfcId, 1, PV->RHO) << " /sl "
             << a_slope(nghbr0, PV->U, a_surfaceOrientation(srfcId)) << " "
             << a_slope(nghbr1, PV->U, a_surfaceOrientation(srfcId)) << " /ls  " << a_levelSetValuesMb(nghbr0, 0) << " "
             << a_levelSetValuesMb(nghbr1, 0) << endl;
        m_solutionDiverged = true;
      }
    }
  }
  MPI_Allreduce(MPI_IN_PLACE, &m_solutionDiverged, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                "m_solutionDiverged");
  if(m_solutionDiverged) {
    writeVtkXmlFiles("QOUT", "GEOM", false, true);
    MPI_Barrier(mpiComm(), AT_);
    mTerm(1, AT_,
          "Solution diverged after surface value computation @ " + to_string(m_RKStep) + "/"
              + to_string(globalTimeStep));
  }
#endif


  RECORD_TIMER_START(m_timers[Timers::MusclGhostSlopes]);
  updateGhostCellSlopesViscous();
  m_fvBndryCnd->updateCutOffSlopesViscous();
  RECORD_TIMER_STOP(m_timers[Timers::MusclGhostSlopes]);

  correctBoundarySurfaceVariablesMb();
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::computeLocalBoundingBox() {
  for(MInt i = 0; i < nDim; i++) {
    m_bboxLocal[i] = std::numeric_limits<MFloat>::max();
    m_bboxLocal[nDim + i] = std::numeric_limits<MFloat>::lowest();
  }

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    if(a_isPeriodic(cellId)) continue;

    for(MInt i = 0; i < nDim; i++) {
      m_bboxLocal[i] = mMin(m_bboxLocal[i], a_coordinate(cellId, i) - F1B2 * c_cellLengthAtCell(cellId));
      m_bboxLocal[nDim + i] = mMax(m_bboxLocal[nDim + i], a_coordinate(cellId, i) + F1B2 * c_cellLengthAtCell(cellId));
    }
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::rebuildKDTree() {
  IF_CONSTEXPR(nDim == 3) {
    if(m_bodyTree != nullptr) {
      delete m_bodyTree;
      m_bodyTree = nullptr;
    }
    m_bodyCenters.clear();

    for(MInt k = 0; k < (m_noEmbeddedBodies + m_noPeriodicGhostBodies); k++) {
      Point<3> a(m_bodyCenter[k * nDim], m_bodyCenter[k * nDim + 1], m_bodyCenter[k * nDim + 2], k);
      if(std::isnan(a.x[0]) || std::isnan(a.x[1]) || std::isnan(a.x[2]) || std::isinf(a.x[0]) || std::isinf(a.x[1])
         || std::isinf(a.x[2])) {
        mTerm(1, "ERROR body center is NAN " + to_string(k) + " " + to_string(a.x[0]) + " " + to_string(a.x[1]) + " "
                     + to_string(a.x[2]));
      }
      m_bodyCenters.push_back(a);
    }

    if(m_bodyCenters.size() > 0) {
      m_bodyTree = new KDtree<3>(m_bodyCenters);
    }
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::rebuildKDTreeLocal() {
  IF_CONSTEXPR(nDim == 3) {
    if(m_bodyTreeLocal != nullptr) {
      delete m_bodyTreeLocal;
      m_bodyTreeLocal = nullptr;
    }
    m_bodyCentersLocal.clear();

    for(MInt k = 0; k < (m_noEmbeddedBodies + m_noPeriodicGhostBodies); k++) {
      if(!m_bodyNearDomain[k]) continue;
      Point<nDim> a(m_bodyCenter[k * nDim + 0], m_bodyCenter[k * nDim + 1], m_bodyCenter[k * nDim + 2], k);
      if(std::isnan(a.x[0]) || std::isnan(a.x[1]) || std::isnan(a.x[2]) || std::isinf(a.x[0]) || std::isinf(a.x[1])
         || std::isinf(a.x[2])) {
        mTerm(1, "ERROR body center is NAN " + to_string(k) + " " + to_string(a.x[0]) + " " + to_string(a.x[1]) + " "
                     + to_string(a.x[2]));
      }
      m_bodyCentersLocal.push_back(a);
    }
    m_bodyTreeLocal = new KDtree<nDim>(m_bodyCentersLocal);
  }
}


/**
 * \brief manually constructs the level-set field after each time step
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::constructGField(MBool updateBody) {
  TRACE();

  if(m_noEmbeddedBodies == 0) {
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      a_levelSetValuesMb(cellId, 0) = c_cellLengthAtLevel(0);
      a_hasProperty(cellId, SolverCell::IsInactive) = false;
    }
    return;
  }

  if(m_motionEquation == 0) {
    if(updateBody) {
      updateBodyProperties();
    }
    createPeriodicGhostBodies();
    createBodyTree();
  }

  const MInt noBodies = m_noEmbeddedBodies + m_noPeriodicGhostBodies;
  if(m_noLevelSetsUsedForMb == 1) {
    for(MInt k = 0; k < noBodies; k++) {
      m_bodyNearDomain[k] = true;
      for(MInt i = 0; i < nDim; i++) {
        if(m_bodyCenter[k * nDim + i] < m_bboxLocal[i] - (m_bodyDistThreshold + m_bodyRadius[k])) {
          m_bodyNearDomain[k] = false;
        }
        if(m_bodyCenter[k * nDim + i] > m_bboxLocal[nDim + i] + (m_bodyDistThreshold + m_bodyRadius[k])) {
          m_bodyNearDomain[k] = false;
        }
      }
    }
  }

  if(!m_constructGField) {
    return;
  }

  rebuildKDTreeLocal();

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    a_levelSetValuesMb(cellId, 0) = c_cellLengthAtLevel(0);
  }

  constexpr MFloat safetyFac = 1.1;
  const MFloat uncertaintyAngle = sqrt(FD) * c_cellLengthAtLevel(minLevel());
  const MFloat uncertaintyRotation = m_maxBodyRadius;
  const MFloat minWallDist = F3 * c_cellLengthAtLevel(maxLevel());
  const MFloat delta1 = safetyFac * (uncertaintyAngle + uncertaintyRotation);
  const MFloat delta0 = delta1 + safetyFac * minWallDist;

  MFloatScratchSpace bodyDist(noBodies, AT_, "bodyDist");
  MIntScratchSpace bodyIds(noBodies, AT_, "bodyIds");
  MFloat deltaMax = m_bodyDistThreshold + m_maxBodyRadius;
  bodyDist.fill(deltaMax);
  bodyIds.fill(-1);

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
      a_associatedBodyIds(cellId, set) = -1;
      a_levelSetValuesMb(cellId, set) = m_bodyDistThreshold + 1e-14;
    }
  }

  for(MInt i = 0; i < noMinCells(); i++) {
    MInt cellId = minCell(i);
    MFloat minDist = c_cellLengthAtLevel(0);
    MInt bodyCnt = noBodies;

    IF_CONSTEXPR(nDim == 3) {
      if(m_bodyTypeMb == 1 || m_bodyTypeMb == 3) {
        MBool overflow = false;
        Point<nDim> pt(a_coordinate(cellId, 0), a_coordinate(cellId, 1), a_coordinate(cellId, 2));
        bodyCnt = m_bodyTreeLocal->locatenearest(pt, deltaMax, &bodyIds[0], &bodyDist[0], noBodies, overflow);
      } else {
        for(MInt k = 0; k < noBodies; k++) {
          bodyIds[k] = k;
        }
      }
    }
    else {
      for(MInt k = 0; k < noBodies; k++) {
        bodyIds[k] = k;
      }
    }

    // first check to improve performance: remove bodies which are too far away to be relevant
    for(MInt k = 0; k < bodyCnt; k++) {
      MFloat dist = F0;
      IF_CONSTEXPR(nDim == 2) {
        dist = sqrt(POW2(a_coordinate(cellId, 0) - m_bodyCenter[bodyIds[k] * nDim + 0])
                    + POW2(a_coordinate(cellId, 1) - m_bodyCenter[bodyIds[k] * nDim + 1]));
      }
      IF_CONSTEXPR(nDim == 3) {
        dist = sqrt(POW2(a_coordinate(cellId, 0) - m_bodyCenter[bodyIds[k] * nDim + 0])
                    + POW2(a_coordinate(cellId, 1) - m_bodyCenter[bodyIds[k] * nDim + 1])
                    + POW2(a_coordinate(cellId, 2) - m_bodyCenter[bodyIds[k] * nDim + 2]));
      }
      if(dist > delta0 && dist > minDist + delta1) {
        if(k < bodyCnt - 1) {
          bodyIds[k] = bodyIds[bodyCnt - 1];
          bodyDist[k] = bodyDist[bodyCnt - 1];
          k--;
        }
        bodyCnt--;
      }
      minDist = mMin(minDist, dist);
    }

    if(bodyCnt > 0) descendLevelSetValue(cellId, &bodyIds[0], bodyCnt);

    MInt parentId = c_parentId(cellId);
    while(parentId > -1) {
      for(MInt set = 0; set < m_noSets; set++) {
        a_levelSetValuesMb(c_parentId(cellId), set) = a_levelSetValuesMb(cellId, set);
        a_associatedBodyIds(parentId, set) = a_associatedBodyIds(cellId, set);
      }
      parentId = c_parentId(parentId);
    }
  }
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
MInt FvMbCartesianSolverXD<nDim, SysEqn>::constructDistance(const MFloat deltaMax, MIntScratchSpace& nearestBodies,
                                                            MFloatScratchSpace& nearestDist) {
  TRACE();

  if(!m_constructGField) mTerm(1, AT_, "m_constructGField not set.");
  if(m_noEmbeddedBodies == 0) {
    return 0;
  }

  if(m_bodyTypeMb) {
    const MInt noBodies = m_noEmbeddedBodies + m_noPeriodicGhostBodies;

    MFloatScratchSpace bodyDist(noBodies, AT_, "bodyDist");
    MIntScratchSpace bodyIds(noBodies, AT_, "bodyIds");

    constexpr MFloat safetyFac = 1.1;
    const MFloat deltaMax1 = safetyFac * (deltaMax + c_cellLengthAtLevel(minLevel()) + m_maxBodyRadius);
    bodyDist.fill(deltaMax1);
    bodyIds.fill(-1);

    MInt maxBodyCnt = 0;
    for(MInt i = 0; i < noMinCells(); i++) {
      MInt cellId = minCell(i);
      MInt bodyCnt = noBodies;
      IF_CONSTEXPR(nDim == 3) {
        if(m_bodyTypeMb == 1 || m_bodyTypeMb == 3) {
          MBool overflow = false;
          Point<nDim> pt(a_coordinate(cellId, 0), a_coordinate(cellId, 1), a_coordinate(cellId, 2));
          if(deltaMax1 < m_bodyDistThreshold) {
            bodyCnt = m_bodyTreeLocal->locatenearest(pt, deltaMax1, &bodyIds[0], &bodyDist[0], noBodies, overflow);
          } else {
            bodyCnt = m_bodyTree->locatenearest(pt, deltaMax1, &bodyIds[0], &bodyDist[0], noBodies, overflow);
          }
        } else {
          for(MInt k = 0; k < noBodies; k++) {
            bodyIds[k] = k;
          }
        }
      }
      else {
        for(MInt k = 0; k < noBodies; k++) {
          bodyIds[k] = k;
        }
      }
      if(bodyCnt > 0) descendDistance(cellId, &bodyIds[0], bodyCnt, nearestBodies, nearestDist);
      maxBodyCnt = mMax(maxBodyCnt, bodyCnt);
    }
    MPI_Allreduce(MPI_IN_PLACE, &maxBodyCnt, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "maxBodyCnt");
    return maxBodyCnt;
  }
  return 0;
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::getNormal(const MInt cellId, const MInt set, MFloat normal[]) {
  const MFloat FcellLength = F1 / c_cellLengthAtCell(cellId);
  normal[0] = numeric_limits<MFloat>::max();
  normal[1] = numeric_limits<MFloat>::max();
  IF_CONSTEXPR(nDim == 3) { normal[2] = numeric_limits<MFloat>::max(); }

  if(m_bodyTypeMb == 1) {
    getNormalSphere(cellId, set, normal);
  } else if(m_bodyTypeMb == 3) {
    getNormalEllipsoid(cellId, set, normal);
  } else {
    MInt cndId = (a_hasProperty(cellId, SolverCell::IsSplitChild))
                     ? m_bndryCandidateIds[getAssociatedInternalCell(cellId)]
                     : m_bndryCandidateIds[cellId];
    if(cndId < 0) mTerm(1, AT_, "candidate not found");
    for(MInt node = 0; node < m_noCellNodes; node++) {
      if(!m_candidateNodeSet[cndId * m_noCellNodes + node]) mTerm(1, AT_, "candidate node not set");
    }
    IF_CONSTEXPR(nDim == 3) {
      normal[0] = F1B4 * FcellLength
                  * (-m_candidateNodeValues[IDX_LSSETNODES(cndId, 0, set)]
                     + m_candidateNodeValues[IDX_LSSETNODES(cndId, 1, set)]
                     - m_candidateNodeValues[IDX_LSSETNODES(cndId, 2, set)]
                     + m_candidateNodeValues[IDX_LSSETNODES(cndId, 3, set)]
                     - m_candidateNodeValues[IDX_LSSETNODES(cndId, 4, set)]
                     + m_candidateNodeValues[IDX_LSSETNODES(cndId, 5, set)]
                     - m_candidateNodeValues[IDX_LSSETNODES(cndId, 6, set)]
                     + m_candidateNodeValues[IDX_LSSETNODES(cndId, 7, set)]);
      normal[1] = F1B4 * FcellLength
                  * (-m_candidateNodeValues[IDX_LSSETNODES(cndId, 0, set)]
                     - m_candidateNodeValues[IDX_LSSETNODES(cndId, 1, set)]
                     + m_candidateNodeValues[IDX_LSSETNODES(cndId, 2, set)]
                     + m_candidateNodeValues[IDX_LSSETNODES(cndId, 3, set)]
                     - m_candidateNodeValues[IDX_LSSETNODES(cndId, 4, set)]
                     - m_candidateNodeValues[IDX_LSSETNODES(cndId, 5, set)]
                     + m_candidateNodeValues[IDX_LSSETNODES(cndId, 6, set)]
                     + m_candidateNodeValues[IDX_LSSETNODES(cndId, 7, set)]);
      normal[2] = F1B4 * FcellLength
                  * (-m_candidateNodeValues[IDX_LSSETNODES(cndId, 0, set)]
                     - m_candidateNodeValues[IDX_LSSETNODES(cndId, 1, set)]
                     - m_candidateNodeValues[IDX_LSSETNODES(cndId, 2, set)]
                     - m_candidateNodeValues[IDX_LSSETNODES(cndId, 3, set)]
                     + m_candidateNodeValues[IDX_LSSETNODES(cndId, 4, set)]
                     + m_candidateNodeValues[IDX_LSSETNODES(cndId, 5, set)]
                     + m_candidateNodeValues[IDX_LSSETNODES(cndId, 6, set)]
                     + m_candidateNodeValues[IDX_LSSETNODES(cndId, 7, set)]);
    }
    else {
      normal[0] = F1B4 * FcellLength
                  * (-m_candidateNodeValues[IDX_LSSETNODES(cndId, 0, set)]
                     + m_candidateNodeValues[IDX_LSSETNODES(cndId, 1, set)]
                     - m_candidateNodeValues[IDX_LSSETNODES(cndId, 2, set)]
                     + m_candidateNodeValues[IDX_LSSETNODES(cndId, 3, set)]);
      normal[1] = F1B4 * FcellLength
                  * (-m_candidateNodeValues[IDX_LSSETNODES(cndId, 0, set)]
                     - m_candidateNodeValues[IDX_LSSETNODES(cndId, 1, set)]
                     + m_candidateNodeValues[IDX_LSSETNODES(cndId, 2, set)]
                     + m_candidateNodeValues[IDX_LSSETNODES(cndId, 3, set)]);
    }
    MFloat sum = F0;
    for(MInt i = 0; i < nDim; i++) {
      sum += POW2(normal[i]);
    }
    sum = sqrt(sum);
    for(MInt i = 0; i < nDim; i++) {
      normal[i] /= sum;
    }
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::getNormalSphere(const MInt cellId, const MInt set, MFloat normal[]) {
  const MInt bodyId = a_associatedBodyIds(cellId, set);
  ASSERT(bodyId > -1 && bodyId < m_noEmbeddedBodies + m_noPeriodicGhostBodies, "");

  for(MInt i = 0; i < nDim; i++) {
    normal[i] = F0;
  }
  MFloat cnt = F0;
  for(MInt i = 0; i < nDim; i++) {
    normal[i] = a_coordinate(cellId, i) - m_bodyCenter[nDim * bodyId + i];
    cnt += POW2(normal[i]);
  }
  cnt = sqrt(cnt);
  for(MInt i = 0; i < nDim; i++) {
    normal[i] /= cnt;
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::getNormalEllipsoid(const MInt cellId, const MInt set, MFloat normal[]) {
  const MInt bodyId = a_associatedBodyIds(cellId, set);
  ASSERT(bodyId > -1 && bodyId < m_noEmbeddedBodies + m_noPeriodicGhostBodies, "");

  MFloatScratchSpace R(3, 3, AT_, "R");
  computeRotationMatrix(R, &(m_bodyQuaternion[4 * bodyId]));

  // shift centroid to body center
  MFloat x = a_coordinate(cellId, 0) - m_bodyCenter[bodyId * nDim + 0];
  MFloat y = a_coordinate(cellId, 1) - m_bodyCenter[bodyId * nDim + 1];
  MFloat z = a_coordinate(cellId, 2) - m_bodyCenter[bodyId * nDim + 2];

  MFloat xw[3];
  MFloat xb[3];
  xw[0] = x;
  xw[1] = y;
  xw[2] = z;
  matrixVectorProduct(xb, R, xw); // rotate to body principal axes
  x = xb[0];
  y = xb[1];
  z = xb[2];

  MFloat a = m_bodyRadii[bodyId * nDim + 0];
  MFloat b = m_bodyRadii[bodyId * nDim + 1];
  MFloat c = m_bodyRadii[bodyId * nDim + 2];

  MFloat ee[3] = {a, b, c};
  MFloat yy[3] = {x, y, z};
  MFloat xx[3] = {F0, F0, F0};

  // query nearest surface point
  distancePointEllipsoid(ee, yy, xx);

  MFloat norm2[3];
  MFloat n2sum = F0;
  for(MInt i = 0; i < nDim; i++) {
    norm2[i] = F2 * xx[i] / POW2(m_bodyRadii[bodyId * nDim + i]);
    n2sum += POW2(norm2[i]);
  }
  n2sum = sqrt(n2sum);
  for(MInt i = 0; i < nDim; i++) {
    norm2[i] /= n2sum;
  }

  matrixVectorProductTranspose(normal, R, norm2); // rotate back
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::getDistance(const MFloat* const coordinates, const MInt bodyId) {
  MFloat dist = c_cellLengthAtLevel(0);

  if(m_bodyTypeMb == 1) {
    dist = getDistanceSphere(coordinates, bodyId);
  } else if(m_bodyTypeMb == 2) {
    dist = getDistancePiston(coordinates, bodyId);
  } else if(m_bodyTypeMb == 3) {
    dist = getDistanceEllipsoid(coordinates, bodyId);
  } else if(m_bodyTypeMb == 7) {
    dist = getDistanceTetrahedron(coordinates, bodyId);
  } else {
    mTerm(1, AT_, "generalize here");
  }

  return dist;
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::getDistance(const MInt cellId, const MInt bodyId) {
  return getDistance(&a_coordinate(cellId, 0), bodyId);
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::getDistanceSphere(const MFloat* const coordinates, const MInt bodyId) {
  ASSERT(bodyId > -1 && bodyId < m_noEmbeddedBodies + m_noPeriodicGhostBodies, "");
  MFloat dist = F0;
  IF_CONSTEXPR(nDim == 2) {
    dist = sqrt(POW2(coordinates[0] - m_bodyCenter[bodyId * nDim])
                + POW2(coordinates[1] - m_bodyCenter[bodyId * nDim + 1]))
           - (m_bodyRadius[bodyId]);
  }
  else IF_CONSTEXPR(nDim == 3) {
    dist =
        sqrt(POW2(coordinates[0] - m_bodyCenter[bodyId * nDim]) + POW2(coordinates[1] - m_bodyCenter[bodyId * nDim + 1])
             + POW2(coordinates[2] - m_bodyCenter[bodyId * nDim + 2]))
        - (m_bodyRadius[bodyId]);
  }
  return dist;
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::getDistanceSphere(const MInt cellId, const MInt bodyId) {
  return getDistanceSphere(&a_coordinate(cellId, 0), bodyId);
}


/**
 * \fn MFloat FvMbCartesianSolverXD<nDim, SysEqn>::getDistanceSplitSphere()
 * \brief determines the level-set value for the given cell provided that the embedded body is spherical
 * \author Lennart Schneiders
 * extended to multiple bodies (Lennart Schneiders)
 */
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::getDistanceSplitSphere(const MInt cellId, const MInt bodyId) {
  MFloat& h = m_static_getDistanceSplitSphere_h;
  MBool& first = m_static_getDistanceSplitSphere_first;
  if(first) {
    MFloat h_default = m_bodyRadius[0] / 100;
    /*! \page propertiesFVMB
      \section splitSphereSlitHeight
      <code>MFloat FvMbCartesianSolverXD::getDistanceSplitSphere::h </code>\n
      default = <code>property bodyRadius (default 0.5)</code>\n
      The extend of the gap of a splitted sphere\n
      Possible values are:
      <ul>
        <li>values > 0 and < O(lengthLevel0) </li>
      </ul>
      Keywords: <i>FINITTE VOLUME, MOVING BOUNDARY, SPLIT SPHERE</i>
    */
    h = Context::getSolverProperty<MFloat>("splitSphereSlitHeight", m_solverId, AT_, &h_default);
    first = false;
  }
  MFloat dist = 123456.789;
  if(m_noEmbeddedBodies > 2) mTerm(1, AT_, "splitSphere does only work for one or two bodies");
  MFloat signCode[2] = {-F1, F1};

  MFloat x = a_coordinate(cellId, 0);
  MFloat y = a_coordinate(cellId, 1);
  MFloat r = sqrt(POW2(a_coordinate(cellId, 0) - m_bodyCenter[0 * nDim])
                  + POW2(a_coordinate(cellId, 1) - m_bodyCenter[0 * nDim + 1]));
  MFloat yIS = h / 2;
  const MInt k = bodyId;
  MFloat xIS = sqrt(m_bodyRadius[k] * m_bodyRadius[k] - yIS * yIS);
  MFloat phi1 = r - m_bodyRadius[k];
  MFloat phi2 = -signCode[k] * (y - signCode[k] * yIS - m_bodyCenter[0 * nDim + 1]);
  MFloat phi3 =
      sqrt((y - signCode[k] * yIS - m_bodyCenter[0 * nDim + 1]) * (y - signCode[k] * yIS - m_bodyCenter[0 * nDim + 1])
           + (x - xIS) * (x - xIS));
  MFloat phi4 =
      sqrt((y - signCode[k] * yIS - m_bodyCenter[0 * nDim + 1]) * (y - signCode[k] * yIS - m_bodyCenter[0 * nDim + 1])
           + (x + xIS) * (x + xIS));

  if(x < -xIS && phi2 > F0)
    dist = phi4;
  else if(x > xIS && phi2 > F0)
    dist = phi3;
  else if(phi2 > F0)
    dist = phi2;
  else if(phi1 > F0)
    dist = phi1;
  else
    dist = mMax(phi1, phi2);

  return dist;
}


template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::getLevelSetValueNaca00XX(const MFloat* const coordinate,
                                                                     const MFloat sign) {
  // static constexpr MFloat XXTMP = 12.0;
  MFloat XXTMP = 12.0;

  ASSERT(nDim == 2, "Untested for 3D");

  /*! \page propertiesFVMB
    \section NACA00XX
    <code>MFloat xx</code>\n
    default = <code>0</code>\n \n
    Percentage of thickness to chord of a symmetrical (no camber) NACA00xx airfoil used by the
    NACA00XX body type to set the wing shape.
    Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, BODY_TYPE</i>
  */
  const MFloat XX = Context::getSolverProperty<MFloat>("NACA00XX", m_solverId, AT_, &XXTMP);
  const MFloat b = 0.05 * XX;
  const MFloat eps = 1e-10;
  const MInt maxIter = 1000;
  const MFloat p0 = coordinate[0];
  const MFloat q0 = coordinate[1];
  MFloat bodyRotation[3] = {0};
  getBodyRotation(0, bodyRotation);
  const MFloat p = cos(-bodyRotation[2]) * p0 - sin(-bodyRotation[2]) * q0 + F1B4;
  const MFloat q = sin(-bodyRotation[2]) * p0 + cos(-bodyRotation[2]) * q0;
  // const MFloat sign = ( q < F0 ) ? -F1 : F1;

  if(fabs(q) < m_eps) {
    if(p < F0)
      return (-p);
    else if(p > F1)
      return (p - F1);
  }

  // MFloat Y097 = b * ( (0.2969*sqrt(0.97)) - (0.126*0.97) - (0.3516*0.97*0.97) + (0.2843*0.97*0.97*0.97) -
  // (0.1036*0.97*0.97*0.97*0.97) );
  //-> y(x>=0.97) = Y097-(Y097*(x-0.97)/(F1-0.97))

  MFloat x = 1e-12;
  // MFloat y = sign * b * ( (0.2969*sqrt(x)) - (0.126*x) - (0.3516*x*x) + (0.2843*x*x*x) - (0.1015*x*x*x*x) );
  MFloat y = sign * b
             * ((0.2969 * sqrt(x)) - (0.126 * x) - (0.3516 * x * x) + (0.2843 * x * x * x) - (0.1036 * x * x * x * x));
  // MFloat yp = sign * b * ( (F1B2*0.2969/sqrt(x)) - (0.126) - (F2*0.3516*x) + (F3*0.2843*x*x) - (F4*0.1015*x*x*x) );
  MFloat yp =
      sign * b
      * ((F1B2 * 0.2969 / sqrt(x)) - (0.126) - (F2 * 0.3516 * x) + (F3 * 0.2843 * x * x) - (F4 * 0.1036 * x * x * x));
  MFloat f = (p - x) + yp * (q - y);
  MFloat xa = x;
  MFloat ya = y;
  MFloat fa = f;

  x = F1;
  // y = sign * b * ( (0.2969*sqrt(x)) - (0.126*x) - (0.3516*x*x) + (0.2843*x*x*x) - (0.1015*x*x*x*x) );
  y = sign * b
      * ((0.2969 * sqrt(x)) - (0.126 * x) - (0.3516 * x * x) + (0.2843 * x * x * x) - (0.1036 * x * x * x * x));
  // yp = sign * b * ( (F1B2*0.2969/sqrt(x)) - (0.126) - (F2*0.3516*x) + (F3*0.2843*x*x) - (F4*0.1015*x*x*x) );
  yp = sign * b
       * ((F1B2 * 0.2969 / sqrt(x)) - (0.126) - (F2 * 0.3516 * x) + (F3 * 0.2843 * x * x) - (F4 * 0.1036 * x * x * x));
  f = (p - x) + yp * (q - y);
  MFloat xb = x;
  MFloat yb = y;
  MFloat fb = f;

  if(fa * fb > F0) {
    if(p < F0) {
      // cerr << "Bisection warning " << p << " " << q << endl;
      x = xa;
      y = ya;

      /*
            // NEWTON
            MFloat res = F1;
            MInt iter = 0;
            xb = 0.2;
            x = F1B2*(xa+xb);
            //x = mMin(xb-m_eps,mMax(xa+m_eps,p));
            while ( ( res > eps ) && ( iter < maxIter ) && ( x > xa ) && ( x < xb ) ) {
              y = sign * b * ( (0.2969*sqrt(x)) - (0.126*x) - (0.3516*x*x) + (0.2843*x*x*x) - (0.1036*x*x*x*x) );
              yp = sign * b * ( (F1B2*0.2969/sqrt(x)) - (0.126) - (F2*0.3516*x) + (F3*0.2843*x*x) - (F4*0.1036*x*x*x) );
              MFloat ypp = sign * b * ( (-F1B4*0.2969/(x*sqrt(x))) - (F2*0.3516) + (6.0*0.2843*x) - (12.0*0.1036*x*x)
         ); f = (p-x) + yp*(q-y); MFloat fp = -F1 + ypp*(y-q) - POW2(yp); MFloat dx = - f/fp; x += dx; res =
         fabs(dx); iter++;
            }
      */

    } else if(p > F1) {
      x = xb;
      y = yb;
    } else {
      // cerr << cellId << " p/q=" << p << "/" << q << " " << sign << endl;
      // mTerm(1,AT_, "Bisection failed.");
      // cin.get();


      // NEWTON
      MFloat res = F1;
      MInt iter = 0;
      // x = F1B2*(xa+xb);
      x = mMin(xb - m_eps, mMax(xa + m_eps, p));
      while((res > eps) && (iter < maxIter) && (x > xa) && (x < xb)) {
        y = sign * b
            * ((0.2969 * sqrt(x)) - (0.126 * x) - (0.3516 * x * x) + (0.2843 * x * x * x) - (0.1036 * x * x * x * x));
        yp = sign * b
             * ((F1B2 * 0.2969 / sqrt(x)) - (0.126) - (F2 * 0.3516 * x) + (F3 * 0.2843 * x * x)
                - (F4 * 0.1036 * x * x * x));
        MFloat ypp =
            sign * b
            * ((-F1B4 * 0.2969 / (x * sqrt(x))) - (F2 * 0.3516) + (6.0 * 0.2843 * x) - (12.0 * 0.1036 * x * x));
        f = (p - x) + yp * (q - y);
        MFloat fp = -F1 + ypp * (y - q) - POW2(yp);
        MFloat dx = -f / fp;
        x += dx;
        res = fabs(dx);
        iter++;
      }
    }
  } else {
    // BISECTION
    MFloat res = F1;
    MInt iter = 0;
    while((res > eps) && (iter < maxIter)) {
      x = F1B2 * (xa + xb);
      // y = sign * b * ( (0.2969*sqrt(x)) - (0.126*x) - (0.3516*x*x) + (0.2843*x*x*x) - (0.1015*x*x*x*x) );
      y = sign * b
          * ((0.2969 * sqrt(x)) - (0.126 * x) - (0.3516 * x * x) + (0.2843 * x * x * x) - (0.1036 * x * x * x * x));
      // yp = sign * b * ( (F1B2*0.2969/sqrt(x)) - (0.126) - (F2*0.3516*x) + (F3*0.2843*x*x) - (F4*0.1015*x*x*x) );
      yp = sign * b
           * ((F1B2 * 0.2969 / sqrt(x)) - (0.126) - (F2 * 0.3516 * x) + (F3 * 0.2843 * x * x)
              - (F4 * 0.1036 * x * x * x));
      f = (p - x) + yp * (q - y);
      if(fa * f < F0) {
        xb = x;
        yb = y;
        fb = f;
      } else {
        xa = x;
        ya = y;
        fa = f;
      }
      // res = fabs(xb-xa);
      // res = fabs(f);
      res = mMax(fabs(f), fabs(xb - xa));
      iter++;
    }
    if(iter >= maxIter) {
      cerr << "Warning: max iterations exceeded in bisection" << endl;
    }
  }


  /*
    while ( ( fabs(dpx) > eps ) && ( iter < maxIter ) ) {

    MFloat fx = x - px + ( y - py ) * pyp;
      MFloat fxp = -F1 + pypp * ( y - py ) - POW2(pyp);
      dpx = - fx/fxp;
      px += dpx;
      py = sign * b * ( (0.2969*sqrt(px)) - (0.126*px) - (0.3516*px*px) + (0.2843*px*px*px) - (0.1015*px*px*px*px) );
      pyp = sign * b * ( (F1B2*0.2969/sqrt(px)) - (0.126) - (F2*0.3516*px) + (F3*0.2843*px*px) - (F4*0.1015*px*px*px) );
      pypp = sign * b * ( (-F1B4*0.2969/(px*sqrt(px))) - (F2*0.3516) + (6.0*0.2843*px) - (12.0*0.1015*px*px) );
      iter++;

    }
  */

  MFloat dist = sqrt(POW2(p - x) + POW2(q - y));
  // if ( (p > F0) && (p < F1) && ( sign*q < sign*y ) ) dist *= -F1;
  if((p > F0) && (p < F1) && (sign * q < sign * y)) dist *= -F1;
    // if ( sign*q < sign*y ) dist *= -F1;
    // if ( y*q < F0 ) dist = -F1*fabs(dist);


#ifndef NACA0012SPLIT
  // rounded traling edge !!!
  // const MFloat xr = 0.988; // -> -1%
  // const MFloat xr = 0.982; // -> -1.5%
  const MFloat xr = 0.994; // -> -0.5%
  const MFloat yr = b
                    * ((0.2969 * sqrt(xr)) - (0.126 * xr) - (0.3516 * xr * xr) + (0.2843 * xr * xr * xr)
                       - (0.1036 * xr * xr * xr * xr));
  if(p > xr) {
    dist = sqrt(POW2(p - xr) + POW2(q)) - yr;
  }
#endif

  return dist;
}


/** \brief computes an approximate level set value for cells outside the level-set computing band
 *    \author Claudia Guenther
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::updateLevelSetOutsideBand() {
  TRACE();


  MIntScratchSpace flag(a_noCells(), AT_, "flag");
  multimap<MFloat, MInt> approximateLSV;
  multimap<MFloat, MInt> initLSV;
  MFloat eps = 1.0e-10;
  const MInt _far = 2;
  const MInt band = 1;
  const MInt accepted = 0;

  findNghbrIds();

  // find first layer of halo cells:
  MBoolScratchSpace isFirstLayerHalo(a_noCells(), AT_, "isFirstLayerHalo");
  MIntScratchSpace firstLayerHalos(a_noCells(), AT_, "firstLayerHalos");
  MBoolScratchSpace isFarHalo(a_noCells(), AT_, "isFarHalo");
  MInt firstLayerHaloCount = 0;
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    isFirstLayerHalo[cellId] = false;
    isFarHalo[cellId] = false;
    if(!a_isHalo(cellId)) continue;
    isFarHalo[cellId] = true;
    for(MInt direction = 0; direction < (2 * nDim); direction++) {
      for(MInt j = m_identNghbrIds[2 * cellId * nDim + direction];
          j < m_identNghbrIds[2 * cellId * nDim + direction + 1];
          j++) {
        MInt nghbrId = m_storeNghbrIds[j];
        if(a_isWindow(nghbrId)) {
          isFirstLayerHalo[cellId] = true;
          isFarHalo[cellId] = false;
          firstLayerHalos[firstLayerHaloCount++] = cellId;
          break;
        }
      }
    }
  }

  // initialize flag:
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    flag[cellId] = _far;
  }

  // Initialize: Search calculated Points , create NarrowBand with approximated levelSetValues
  MBoolScratchSpace isStartCell(a_noCells(), AT_, "isStartCell");
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    isStartCell[cellId] = false;
    if(c_noChildren(cellId)) {
      a_levelSetValuesMb(cellId, 0) = c_cellLengthAtLevel(0);
      continue;
    }
    if(isFarHalo[cellId] || isFirstLayerHalo[cellId]) {
      a_levelSetValuesMb(cellId, 0) = c_cellLengthAtLevel(0);
      continue;
    }
    MFloat limitValue = c_cellLengthAtLevel(a_level(cellId)) * sqrt(nDim);
    if(a_levelSetValuesMb(cellId, 0) < 0 || (false && a_levelSetValuesMb(cellId, 0) < limitValue)) {
      flag[cellId] = accepted;
      initLSV.insert(make_pair(a_levelSetValuesMb(cellId, 0), cellId));
      isStartCell[cellId] = true;
    } else {
      a_levelSetValuesMb(cellId, 0) = c_cellLengthAtLevel(0);
    }
  }

  while(!initLSV.empty()) {
    multimap<MFloat, MInt>::iterator it = initLSV.begin();
    MInt cellId = it->second;
    initLSV.erase(it);
    for(MInt direction = 0; direction < (2 * nDim); direction++) {
      for(MInt j = m_identNghbrIds[2 * cellId * nDim + direction];
          j < m_identNghbrIds[2 * cellId * nDim + direction + 1];
          j++) {
        MInt nghbrId = m_storeNghbrIds[j];
        if(isFarHalo[nghbrId]) continue;
        if(flag[nghbrId] == accepted) continue;
        if(!isFirstLayerHalo[nghbrId] && !isStartCell[nghbrId]) { // for halos a new value can't be computed!
          a_levelSetValuesMb(nghbrId, 0) = CalculateLSV(nghbrId, flag);
        }
        approximateLSV.insert(make_pair(a_levelSetValuesMb(nghbrId, 0), nghbrId));
        flag[nghbrId] = band; // halo cells may be included in the narrow band!
      }
    }
  }

  MBool somethingOnBoundaryChanged = true;
  MInt count = 0;
  while(somethingOnBoundaryChanged) {
    count++;
    somethingOnBoundaryChanged = false;
    MFloatScratchSpace oldLVS(a_noCells(), AT_, "oldLVS");
    for(MInt cellId = 0; cellId < a_noCells(); cellId++)
      oldLVS[cellId] = a_levelSetValuesMb(cellId, 0);

    // main loop of the algorithm: take the cell with the smallest approximate value out of the band, update its
    // neighbors and put them into the band if necessary
    while(!approximateLSV.empty()) {
      multimap<MFloat, MInt>::iterator it = approximateLSV.begin();
      MInt cellId = it->second;
      approximateLSV.erase(it);
      if(flag[cellId] == accepted) continue;
      flag[cellId] = accepted;
      for(MInt direction = 0; direction < (m_noDirs); direction++) {
        for(MInt j = m_identNghbrIds[2 * cellId * nDim + direction];
            j < m_identNghbrIds[2 * cellId * nDim + direction + 1];
            j++) {
          MInt nghbrId = m_storeNghbrIds[j];
          if(isFarHalo[nghbrId]) continue;
          if(flag[nghbrId] == accepted) continue;
          if(!isFirstLayerHalo[nghbrId]
             && !isStartCell[nghbrId]) { // for halos and start cells a new value can't be computed!
            a_levelSetValuesMb(nghbrId, 0) = CalculateLSV(nghbrId, flag);
          }
          approximateLSV.insert(make_pair(a_levelSetValuesMb(nghbrId, 0), nghbrId));
          flag[nghbrId] = band; // halo cells may be included in the narrow band!
        }
      }
    }

    // compute changes in the field after main loop
    MFloat change = F0;
    MInt noCells = 0;
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      if(isFirstLayerHalo[cellId] || isFarHalo[cellId]) continue;
      if(c_noChildren(cellId) > 0) continue;
      MFloat tmpChange =
          (a_levelSetValuesMb(cellId, 0) - oldLVS[cellId]) * (a_levelSetValuesMb(cellId, 0) - oldLVS[cellId]);
      if(tmpChange > F0) {
        change += tmpChange;
        noCells++;
      }
    }
    if(noCells > 0) change = sqrt(change) / noCells;

    // special part for parallel execution
    if(noNeighborDomains() > 0) {
      // exchange values of halo cells
      MBoolScratchSpace valueChanged(a_noCells(), AT_, "valueChanged");
      MInt sendCount = 0;
      MInt receiveCount = 0;
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        sendCount += (signed)noWindowCells(i);
        receiveCount += (signed)noHaloCells(i);
      }
      ScratchSpace<MFloat> sendBuffer(sendCount, AT_, "sendBuffer");
      ScratchSpace<MFloat> receiveBuffer(receiveCount, AT_, "receiveBuffer");

      // 1. gather
      sendCount = 0;
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        for(MInt j = 0; j < (signed)noWindowCells(i); j++) {
          sendBuffer.p[sendCount] = a_levelSetValuesMb(windowCellId(i, j), 0);
          sendCount++;
        }
      }
      // 2. send
      sendCount = 0;
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        MInt bufSize = (signed)noWindowCells(i);
        MPI_Issend(&(sendBuffer.p[sendCount]), bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &g_mpiRequestMb[i],
                   AT_, "(sendBuffer.p[sendCount])");
        sendCount += noWindowCells(i);
      }
      // 3. receive
      MPI_Status status;
      receiveCount = 0;
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        MInt bufSize = (signed)noHaloCells(i);
        MPI_Recv(&(receiveBuffer.p[receiveCount]), bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &status, AT_,
                 "(receiveBuffer.p[ receiveCount ])");
        receiveCount += noHaloCells(i);
      }
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        MPI_Wait(&g_mpiRequestMb[i], &status, AT_);
      }

      // 4. scatter
      receiveCount = 0;
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        for(MInt j = 0; j < (signed)noHaloCells(i); j++) {
          MInt cellId = haloCellId(i, j);
          valueChanged[cellId] = false;
          if(abs(a_levelSetValuesMb(cellId, 0) - receiveBuffer.p[receiveCount]) > eps) {
            valueChanged[cellId] = true;
          }
          a_levelSetValuesMb(cellId, 0) = receiveBuffer.p[receiveCount];
          receiveCount++;
        }
      }

      // check if halo acts as a source for at least one close halo cell
      MBoolScratchSpace isSource(firstLayerHaloCount, AT_, "isSource");
      for(MInt hc = 0; hc < firstLayerHaloCount; hc++) {
        isSource[hc] = false;
        MInt haloId = firstLayerHalos[hc];
        for(MInt direction = 0; direction < (2 * nDim); direction++) {
          for(MInt j = m_identNghbrIds[2 * haloId * nDim + direction];
              j < m_identNghbrIds[2 * haloId * nDim + direction + 1];
              j++) {
            MInt nghbrId = m_storeNghbrIds[j];
            if(!isFarHalo[nghbrId] && !isFirstLayerHalo[nghbrId]
               && !isStartCell[nghbrId]) { // nghbr is internal cell and not start cell
              if(a_levelSetValuesMb(haloId, 0) < a_levelSetValuesMb(nghbrId, 0)) {
                isSource[hc] = true;
              }
            }
          }
        }
      }

      // compute min val of source halos that changed their value
      MFloat minHaloVal = c_cellLengthAtLevel(0);
      for(MInt hc = 0; hc < firstLayerHaloCount; hc++) {
        MInt haloId = firstLayerHalos[hc];
        if(isSource[hc] && valueChanged[haloId]) {
          minHaloVal = mMin(minHaloVal, a_levelSetValuesMb(haloId, 0));
          somethingOnBoundaryChanged = true;
        }
        if(isSource[hc]) {
          flag[haloId] = band;
          approximateLSV.insert(make_pair(a_levelSetValuesMb(haloId, 0), haloId));
        } else {
          flag[haloId] = _far;
        }
      }

      // exchange somethingChanged globally
      MIntScratchSpace globalSomethingChanged(1, AT_, "globalSomethingChanged");
      MIntScratchSpace somethingChangedExchange(1, AT_, "somethingChangedExchange");
      somethingChangedExchange[0] = somethingOnBoundaryChanged;
      MPI_Allreduce(somethingChangedExchange.getPointer(), globalSomethingChanged.getPointer(), 1, MPI_INT, MPI_MAX,
                    mpiComm(), AT_, "somethingChangedExchange.getPointer()", "globalSomethingChanged.getPointer()");
      somethingOnBoundaryChanged = globalSomethingChanged[0];

      // reassign flags for all cells and reset their value if necessary
      for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
        if(isFarHalo[cellId] || isFirstLayerHalo[cellId]) continue;
        if(c_noChildren(cellId) > 0) continue;
        if(isStartCell[cellId]) {
          flag[cellId] = accepted;
        } else if(abs(a_levelSetValuesMb(cellId, 0) - minHaloVal) < eps) {
          flag[cellId] = band;
          approximateLSV.insert(make_pair(a_levelSetValuesMb(cellId, 0), cellId));
        } else if(a_levelSetValuesMb(cellId, 0) < minHaloVal) {
          flag[cellId] = accepted;
        } else {
          flag[cellId] = _far;
        }
      }
      // set all neighbors of accepted cells (that are not accepted themselves) in band
      for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
        if(flag[cellId] != accepted) continue;
        for(MInt direction = 0; direction < (2 * nDim); direction++) {
          for(MInt j = m_identNghbrIds[2 * cellId * nDim + direction];
              j < m_identNghbrIds[2 * cellId * nDim + direction + 1];
              j++) {
            MInt nghbrId = m_storeNghbrIds[j];
            if(isFarHalo[nghbrId]) continue;
            if(flag[nghbrId] == _far) {
              flag[nghbrId] = band;
              approximateLSV.insert(make_pair(a_levelSetValuesMb(nghbrId, 0), nghbrId));
            }
          }
        }
      }
      // reset the value of all far cells to c_cellLengthAtLevel(0)
      for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
        if(flag[cellId] != _far) continue;
        if(isFarHalo[cellId] || isFirstLayerHalo[cellId]) continue;
        a_levelSetValuesMb(cellId, 0) = c_cellLengthAtLevel(0);
      }
    }
  }

  // make sure, parent cells have a meaningful value:
  for(MInt level = maxRefinementLevel() - 1; level >= maxUniformRefinementLevel(); level--) {
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      if(a_level(cellId) != level) continue;
      if(c_isLeafCell(cellId)) continue;
      a_levelSetValuesMb(cellId, 0) = F0;
      for(MInt child = 0; child < IPOW2(nDim); child++) {
        MInt childId = c_childId(cellId, child);
        if(childId > -1) a_levelSetValuesMb(cellId, 0) += a_levelSetValuesMb(childId, 0);
      }
      a_levelSetValuesMb(cellId, 0) /= c_noChildren(cellId);
    }
  }

  mDeallocate(m_storeNghbrIds);
  mDeallocate(m_identNghbrIds);
}


/**
 * \brief Calculate LevelSetValue with an Approximation of the Neighbours
 *        for a grid in the NarrowBand
 * \author Claudia Guenther
 */
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::CalculateLSV(MInt cellId, MIntScratchSpace& flag) {
  TRACE();

  // LevelSetValues of the direct and second Neighbours
  MFloat a[3] = {F0, F0, F0};
  MFloat delta_cell[3] = {F0, F0, F0};
  // 1.Index: approximation level 2.Index: direction
  MFloat delta_taylor[2][3] = {{F0, F0, F0}, {F0, F0, F0}};
  MFloat levelSetValues = c_cellLengthAtLevel(0);
  const MFloat eps = 1.0e-3 * c_cellLengthAtLevel(m_lsCutCellBaseLevel);
  const MInt accepted = 0;

  // find smallest values and associated delta_cell by every axes direction
  for(MInt direction = 0; direction < (2 * nDim); direction++) {
    MInt index = (MInt)direction / 2;
    for(MInt j = m_identNghbrIds[2 * cellId * nDim + direction]; j < m_identNghbrIds[2 * cellId * nDim + direction + 1];
        j++) {
      MInt nghbrId = m_storeNghbrIds[j];
      if(flag[nghbrId] == accepted && a_levelSetValuesMb(nghbrId, 0) < a_levelSetValuesMb(cellId, 0)) {
        if(a[index] > F0) {
          if(a_levelSetValuesMb(nghbrId, 0) < a[index]) {
            a[index] = a_levelSetValuesMb(nghbrId, 0);
            delta_cell[index] = c_cellLengthAtLevel(a_level(nghbrId));
          }
        } else {
          a[index] = a_levelSetValuesMb(nghbrId, 0);
          delta_cell[index] = c_cellLengthAtLevel(a_level(nghbrId));
        }
      }
    }
  }
  // 2D CalculateLSV by approximation with taylor
  IF_CONSTEXPR(nDim == 2) {
    if(!(a[0] > F0) && !(a[1] > F0)) {
    } else if(!(a[0] > F0)) {
      // only in y-Direction
      delta_taylor[0][1] = (c_cellLengthAtLevel(a_level(cellId)) + delta_cell[1]) * FFPOW2(1);
      levelSetValues = a[1] + delta_taylor[0][1];
    } else if(!(a[1] > F0)) {
      // only in x-Direction
      delta_taylor[0][0] = (c_cellLengthAtLevel(a_level(cellId)) + delta_cell[0]) * FFPOW2(1);
      levelSetValues = a[0] + delta_taylor[0][0];
    } else {
      // in both directions
      // 1.Order
      MFloat p, q;
      if(abs(delta_cell[0] - delta_cell[1]) < eps) { // same distance to both cells
        // pq-equation
        delta_taylor[0][0] = (delta_cell[0] + c_cellLengthAtLevel(a_level(cellId))) * FFPOW2(1);
        p = -(a[0] + a[1]);
        q = (a[0] * a[0] + a[1] * a[1] - delta_taylor[0][0] * delta_taylor[0][0]) * FFPOW2(1);
      } else {
        delta_taylor[0][0] = (c_cellLengthAtLevel(a_level(cellId)) + delta_cell[0]) * FFPOW2(1);
        delta_taylor[0][1] = (c_cellLengthAtLevel(a_level(cellId)) + delta_cell[1]) * FFPOW2(1);
        p = -2 * (delta_taylor[0][1] * delta_taylor[0][1] * a[0] + delta_taylor[0][0] * delta_taylor[0][0] * a[1])
            / (delta_taylor[0][0] * delta_taylor[0][0] + delta_taylor[0][1] * delta_taylor[0][1]);
        q = (delta_taylor[0][1] * delta_taylor[0][1] * a[0] * a[0]
             + delta_taylor[0][0] * delta_taylor[0][0] * a[1] * a[1]
             - delta_taylor[0][1] * delta_taylor[0][1] * delta_taylor[0][0] * delta_taylor[0][0])
            / (delta_taylor[0][1] * delta_taylor[0][1] + delta_taylor[0][0] * delta_taylor[0][0]);
      }
      MFloat psqf4mq = p * p * FFPOW2(2) - q;
      if(psqf4mq < F0) psqf4mq = F0;
      levelSetValues = -p * FFPOW2(1) + sqrt(psqf4mq);
    }
  }
  else IF_CONSTEXPR(nDim == 3) {
    // 3D CalculateLSV by approximation with taylor
    if(!(a[0] > F0) && !(a[1] > F0) && !(a[2] > F0)) { // no valid neighbor
    } else if(!(a[1] > F0) && !(a[2] > F0)) {
      // only in x-Direction
      delta_taylor[0][0] = (c_cellLengthAtLevel(a_level(cellId)) + delta_cell[0]) * FFPOW2(1);
      levelSetValues = a[0] + delta_taylor[0][0];
    } else if(!(a[0] > F0) && !(a[2] > F0)) {
      // only in y-Direction
      delta_taylor[0][1] = (c_cellLengthAtLevel(a_level(cellId)) + delta_cell[1]) * FFPOW2(1);
      levelSetValues = a[1] + delta_taylor[0][1];
    } else if(!(a[0] > F0) && !(a[1] > F0)) {
      // only in z-Direction
      delta_taylor[0][2] = (c_cellLengthAtLevel(a_level(cellId)) + delta_cell[2]) * FFPOW2(1);
      levelSetValues = a[2] + delta_taylor[0][2];
    } else if(!(a[2] > F0)) {
      // in x- and y-Direction
      MFloat p, q;
      if(abs(delta_cell[0] - delta_cell[1]) < eps) { // same distance to both cells
        // pq-equation
        delta_taylor[0][0] = (delta_cell[0] + c_cellLengthAtLevel(a_level(cellId))) * FFPOW2(1);
        p = -(a[0] + a[1]);
        q = (a[0] * a[0] + a[1] * a[1] - delta_taylor[0][0] * delta_taylor[0][0]) * FFPOW2(1);
      } else {
        delta_taylor[0][0] = (c_cellLengthAtLevel(a_level(cellId)) + delta_cell[0]) * FFPOW2(1);
        delta_taylor[0][1] = (c_cellLengthAtLevel(a_level(cellId)) + delta_cell[1]) * FFPOW2(1);
        MFloat x2 = delta_taylor[0][0] * delta_taylor[0][0];
        MFloat y2 = delta_taylor[0][1] * delta_taylor[0][1];
        MFloat denominator = x2 + y2;
        MFloat x2y2 = x2 * y2;
        p = -2 * (a[0] * y2 + a[1] * x2) / denominator;
        q = (a[0] * a[0] * y2 + a[1] * a[1] * x2 - x2y2) / denominator;
      }
      MFloat psqf4mq = p * p * FFPOW2(2) - q;
      if(psqf4mq < F0) psqf4mq = F0;
      levelSetValues = -p * FFPOW2(1) + sqrt(psqf4mq);
    } else if(!(a[1] > F0)) {
      // in x- and z-Direction
      MFloat p, q;
      if(abs(delta_cell[0] - delta_cell[2]) < eps) { // same distance to both cells
        // pq-equation
        delta_taylor[0][0] = (delta_cell[0] + c_cellLengthAtLevel(a_level(cellId))) * FFPOW2(1);
        p = -(a[0] + a[2]);
        q = (a[0] * a[0] + a[2] * a[2] - delta_taylor[0][0] * delta_taylor[0][0]) * FFPOW2(1);
      } else {
        delta_taylor[0][0] = (c_cellLengthAtLevel(a_level(cellId)) + delta_cell[0]) * FFPOW2(1);
        delta_taylor[0][2] = (c_cellLengthAtLevel(a_level(cellId)) + delta_cell[2]) * FFPOW2(1);
        MFloat x2 = delta_taylor[0][0] * delta_taylor[0][0];
        MFloat z2 = delta_taylor[0][2] * delta_taylor[0][2];
        MFloat denominator = x2 + z2;
        MFloat x2z2 = x2 * z2;
        p = -2 * (a[0] * z2 + a[2] * x2) / denominator;
        q = (a[0] * a[0] * z2 + a[2] * a[2] * x2 - x2z2) / denominator;
      }
      MFloat psqf4mq = p * p * FFPOW2(2) - q;
      if(psqf4mq < F0) psqf4mq = F0;
      levelSetValues = -p * FFPOW2(1) + sqrt(psqf4mq);
    } else if(!(a[0] > F0)) {
      // in y- and z-Direction
      MFloat p, q;
      if(abs(delta_cell[1] - delta_cell[2]) < eps) { // same distance to both cells
        // pq-equation
        delta_taylor[0][0] = (delta_cell[1] + c_cellLengthAtLevel(a_level(cellId))) * FFPOW2(1);
        p = -(a[1] + a[2]);
        q = (a[1] * a[1] + a[2] * a[2] - delta_taylor[0][0] * delta_taylor[0][0]) * FFPOW2(1);
      } else {
        delta_taylor[0][1] = (c_cellLengthAtLevel(a_level(cellId)) + delta_cell[1]) * FFPOW2(1);
        delta_taylor[0][2] = (c_cellLengthAtLevel(a_level(cellId)) + delta_cell[2]) * FFPOW2(1);
        MFloat y2 = delta_taylor[0][1] * delta_taylor[0][1];
        MFloat z2 = delta_taylor[0][2] * delta_taylor[0][2];
        MFloat denominator = z2 + y2;
        MFloat z2y2 = z2 * y2;
        p = -2 * (a[1] * z2 + a[2] * y2) / denominator;
        q = (a[1] * a[1] * z2 + a[2] * a[2] * y2 - z2y2) / denominator;
      }
      MFloat psqf4mq = p * p * FFPOW2(2) - q;
      if(psqf4mq < F0) psqf4mq = F0;
      levelSetValues = -p * FFPOW2(1) + sqrt(psqf4mq);
    } else {
      // in all three directions
      MFloat p, q;
      if(abs(delta_cell[0] - delta_cell[2]) < eps
         && abs(delta_cell[1] - delta_cell[2]) < eps) { // same distance to all three cells
        // pq-equation
        delta_taylor[0][0] = (delta_cell[0] + c_cellLengthAtLevel(a_level(cellId))) * FFPOW2(1);
        p = -F2B3 * (a[0] + a[1] + a[2]);
        q = F1B3 * (a[0] * a[0] + a[1] * a[1] + a[2] * a[2] - delta_taylor[0][0] * delta_taylor[0][0]);
      } else { // different distances in at least one direction
        delta_taylor[0][0] = (c_cellLengthAtLevel(a_level(cellId)) + delta_cell[0]) * FFPOW2(1);
        delta_taylor[0][1] = (c_cellLengthAtLevel(a_level(cellId)) + delta_cell[1]) * FFPOW2(1);
        delta_taylor[0][2] = (c_cellLengthAtLevel(a_level(cellId)) + delta_cell[2]) * FFPOW2(1);
        MFloat x2y2 = delta_taylor[0][0] * delta_taylor[0][0] * delta_taylor[0][1] * delta_taylor[0][1];
        MFloat x2z2 = delta_taylor[0][0] * delta_taylor[0][0] * delta_taylor[0][2] * delta_taylor[0][2];
        MFloat y2z2 = delta_taylor[0][1] * delta_taylor[0][1] * delta_taylor[0][2] * delta_taylor[0][2];
        MFloat x2y2z2 = delta_taylor[0][0] * delta_taylor[0][0] * delta_taylor[0][1] * delta_taylor[0][1]
                        * delta_taylor[0][2] * delta_taylor[0][2];
        MFloat denominator = (x2y2 + x2z2 + y2z2);
        p = -2 * (y2z2 * a[0] + x2z2 * a[1] + x2y2 * a[2]) / denominator;
        q = (y2z2 * a[0] * a[0] + x2z2 * a[1] * a[1] + x2y2 * a[2] * a[2] - x2y2z2) / denominator;
      }
      MFloat psqf4mq = p * p * FFPOW2(2) - q;
      if(psqf4mq < F0) psqf4mq = F0;
      levelSetValues = -p * FFPOW2(1) + sqrt(psqf4mq);
    }
  }

  return levelSetValues;
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::getDistancePiston(const MFloat* const coordinates, const MInt bodyId) {
  ASSERT(bodyId > -1 && bodyId < m_noEmbeddedBodies + m_noPeriodicGhostBodies, "");

  MFloat dist = fabs(coordinates[0] - m_bodyCenter[bodyId * nDim]) - m_bodyRadius[bodyId];

  return dist;
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::getDistancePiston(const MInt cellId, const MInt bodyId) {
  return getDistancePiston(&a_coordinate(cellId, 0), bodyId);
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::getDistanceNaca00XX(const MInt cellId, const MInt bodyId) {
  ASSERT(bodyId > -1 && bodyId < m_noEmbeddedBodies + m_noPeriodicGhostBodies, "");
  if(bodyId != 0) mTerm(1, AT_, "Extend Naca00XX.");

  const MFloat phi0 = getLevelSetValueNaca00XX(&a_coordinate(cellId, 0), -F1);
  const MFloat phi1 = getLevelSetValueNaca00XX(&a_coordinate(cellId, 0), F1);
  const MFloat phi = (fabs(phi0) < fabs(phi1)) ? phi0 : phi1;

  return phi;
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::getDistanceEllipsoid(const MFloat* const coordinates, const MInt bodyId) {
  ASSERT(bodyId > -1 && bodyId < m_noEmbeddedBodies + m_noPeriodicGhostBodies, "");

  MFloatScratchSpace R(3, 3, AT_, "R");
  MFloat xw[3];
  MFloat xb[3];

  computeRotationMatrix(R, &(m_bodyQuaternion[4 * bodyId]));

  MFloat x = coordinates[0] - m_bodyCenter[bodyId * nDim + 0];
  MFloat y = coordinates[1] - m_bodyCenter[bodyId * nDim + 1];
  MFloat z = coordinates[2] - m_bodyCenter[bodyId * nDim + 2];

  xw[0] = x;
  xw[1] = y;
  xw[2] = z;
  matrixVectorProduct(xb, R, xw);
  x = xb[0];
  y = xb[1];
  z = xb[2];

  const MFloat a = m_bodyRadii[bodyId * nDim + 0];
  const MFloat b = m_bodyRadii[bodyId * nDim + 1];
  const MFloat c = m_bodyRadii[bodyId * nDim + 2];

  MFloat ee[3] = {a, b, c};
  MFloat yy[3] = {x, y, z};
  MFloat xx[3] = {F0, F0, F0};
  MFloat dist = distancePointEllipsoid(ee, yy, xx);
  if((POW2(x / a) + POW2(y / b) + POW2(z / c)) < F1) dist = -dist;

  return dist;
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::getDistanceEllipsoid(const MInt cellId, const MInt bodyId) {
  return getDistanceEllipsoid(&a_coordinate(cellId, 0), bodyId);
}


/**
 * \brief Compute the distance between two ellipsoids by iteratively searching the nearest point on the respectively
 * other surface, xc0 and xc1 are the corresponding surface coordinates \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::distEllipsoidEllipsoid(const MInt k0, const MInt k1, MFloat* xc0,
                                                                   MFloat* xc1) {
  MFloatScratchSpace R0(3, 3, AT_, "R0");
  MFloatScratchSpace R1(3, 3, AT_, "R1");
  MFloat xw[3];
  MFloat xb[3];

  computeRotationMatrix(R0, &(m_bodyQuaternion[4 * k0]));
  computeRotationMatrix(R1, &(m_bodyQuaternion[4 * k1]));

  for(MInt i = 0; i < nDim; i++)
    xc0[i] = m_bodyCenter[k0 * nDim + i];
  for(MInt i = 0; i < nDim; i++)
    xc1[i] = m_bodyCenter[k1 * nDim + i];

  MFloat x = xc1[0] - xc0[0];
  MFloat y = xc1[1] - xc0[1];
  MFloat z = xc1[2] - xc0[2];

  MFloat* xc = xc1;
  MFloat* xc_next = xc0;

  MFloat dist0 = 9999998.0;
  MFloat dist = sqrt(x * x + y * y + z * z);
  MInt iter = 0;
  MInt id = -1;
  const MInt maxIter = 200;
  const MFloat eps = 1e-3 * c_cellLengthAtLevel(m_lsCutCellBaseLevel);
  while(fabs(dist0 - dist) > eps && iter < maxIter) {
    id = (iter % 2 == 0) ? k0 : k1;
    xc = (iter % 2 == 0) ? xc1 : xc0;
    xc_next = (iter % 2 == 0) ? xc0 : xc1;

    x = xc[0] - m_bodyCenter[id * nDim + 0];
    y = xc[1] - m_bodyCenter[id * nDim + 1];
    z = xc[2] - m_bodyCenter[id * nDim + 2];

    xw[0] = x;
    xw[1] = y;
    xw[2] = z;
    if(iter % 2 == 0)
      matrixVectorProduct(xb, R0, xw);
    else
      matrixVectorProduct(xb, R1, xw);
    x = xb[0];
    y = xb[1];
    z = xb[2];

    MFloat a = m_bodyRadii[id * nDim + 0];
    MFloat b = m_bodyRadii[id * nDim + 1];
    MFloat c = m_bodyRadii[id * nDim + 2];

    MFloat ee[3] = {a, b, c};
    MFloat yy[3] = {x, y, z};
    MFloat xx[3] = {F0, F0, F0};

    dist0 = dist;
    dist = distancePointEllipsoid(ee, yy, xx);
    if((POW2(x / a) + POW2(y / b) + POW2(z / c)) < F1) dist = -dist;

    xb[0] = xx[0];
    xb[1] = xx[1];
    xb[2] = xx[2];
    if(iter % 2 == 0)
      matrixVectorProductTranspose(xw, R0, xb);
    else
      matrixVectorProductTranspose(xw, R1, xb);

    xc_next[0] = xw[0] + m_bodyCenter[id * nDim + 0];
    xc_next[1] = xw[1] + m_bodyCenter[id * nDim + 1];
    xc_next[2] = xw[2] + m_bodyCenter[id * nDim + 2];

    iter++;
  }
  if(iter >= maxIter && domainId() == 0)
    cerr << setprecision(12) << domainId() << ": ellipsoid dist did not converge " << k0 << " " << k1 << " / "
         << dist - dist0 << " " << dist << " " << dist0 << " " << iter << " " << endl;

  return dist;
}


// The ellipsoid is (x0/e0)^2 + (x1/e1)^2 + (x2/e2)^2 = 1 with e0 >= e1 >= e2.
// The query point is (y0,y1,y2) with y0 >= 0, y1 >= 0, and y2 >= 0. The
// function returns the distance from the query point to the ellipsoid. It
// also computes the ellipsoid point (x0,x1,x2) in the first octant that is
// closest to (y0,y1,y2).
// author: David Eberly, Geometric Tools, LLC
// http://www.geometrictools.com/
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::distancePointEllipsoidSpecial(const MFloat e[3], const MFloat y[3],
                                                                          MFloat x[3]) {
  constexpr MFloat eps = 1e-14;
  MFloat distance;

  if(y[2] > (MFloat)0) {
    if(y[1] > (MFloat)0) {
      if(y[0] > (MFloat)0) {
        // Bisect to compute the root of F(t) for t >= -e2*e2.
        MFloat esqr[3] = {e[0] * e[0], e[1] * e[1], e[2] * e[2]};
        MFloat ey[3] = {e[0] * y[0], e[1] * y[1], e[2] * y[2]};
        MFloat t0 = -esqr[2] + ey[2];
        MFloat t1 = -esqr[2] + sqrt(ey[0] * ey[0] + ey[1] * ey[1] + ey[2] * ey[2]);
        MFloat t = t0;
        const MInt imax = 2 * std::numeric_limits<MFloat>::max_exponent;
        for(MInt i = 0; i < imax; ++i) {
          t = ((MFloat)0.5) * (t0 + t1);
          if(fabs(t - t0) < eps || fabs(t - t1) < eps) {
            break;
          }
          MFloat r[3] = {ey[0] / (t + esqr[0]), ey[1] / (t + esqr[1]), ey[2] / (t + esqr[2])};
          MFloat f = r[0] * r[0] + r[1] * r[1] + r[2] * r[2] - (MFloat)1;
          if(f > (MFloat)0) {
            t0 = t;
          } else if(f < (MFloat)0) {
            t1 = t;
          } else {
            break;
          }
        }
        // if ( fabs( t0  - t1 ) > eps ) cerr << "ellipsoid dist not converged!" << endl;
        x[0] = esqr[0] * y[0] / (t + esqr[0]);
        x[1] = esqr[1] * y[1] / (t + esqr[1]);
        x[2] = esqr[2] * y[2] / (t + esqr[2]);
        MFloat d[3] = {x[0] - y[0], x[1] - y[1], x[2] - y[2]};
        distance = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
      } else // y0 == 0
      {
        x[0] = (MFloat)0;
        MFloat etmp[2] = {e[1], e[2]};
        MFloat ytmp[2] = {y[1], y[2]};
        MFloat xtmp[2];
        distance = distancePointEllipseSpecial(etmp, ytmp, xtmp);
        x[1] = xtmp[0];
        x[2] = xtmp[1];
      }
    } else // y1 == 0
    {
      x[1] = (MFloat)0;
      if(y[0] > (MFloat)0) {
        MFloat etmp[2] = {e[0], e[2]};
        MFloat ytmp[2] = {y[0], y[2]};
        MFloat xtmp[2];
        distance = distancePointEllipseSpecial(etmp, ytmp, xtmp);
        x[0] = xtmp[0];
        x[2] = xtmp[1];
      } else // y0 == 0
      {
        x[0] = (MFloat)0;
        x[2] = e[2];
        distance = fabs(y[2] - e[2]);
      }
    }
  } else // y2 == 0
  {
    MFloat denom[2] = {e[0] * e[0] - e[2] * e[2], e[1] * e[1] - e[2] * e[2]};
    MFloat ey[2] = {e[0] * y[0], e[1] * y[1]};
    if(ey[0] < denom[0] && ey[1] < denom[1]) {
      // (y0,y1) is inside the axis-aligned bounding rectangle of the
      // subellipse. This intermediate test is designed to guard
      // against the division by zero when e0 == e2 or e1 == e2.
      MFloat xde[2] = {ey[0] / denom[0], ey[1] / denom[1]};
      MFloat xdesqr[2] = {xde[0] * xde[0], xde[1] * xde[1]};
      MFloat discr = (MFloat)1 - xdesqr[0] - xdesqr[1];
      if(discr > (MFloat)0) {
        // (y0,y1) is inside the subellipse. The closest ellipsoid
        // point has x2 > 0.
        x[0] = e[0] * xde[0];
        x[1] = e[1] * xde[1];
        x[2] = e[2] * sqrt(discr);
        MFloat d[2] = {x[0] - y[0], x[1] - y[1]};
        distance = sqrt(d[0] * d[0] + d[1] * d[1] + x[2] * x[2]);
      } else {
        // (y0,y1) is outside the subellipse. The closest ellipsoid
        // point has x2 == 0 and is on the domain-boundary ellipse
        // (x0/e0)^2 + (x1/e1)^2 = 1.
        x[2] = (MFloat)0;
        distance = distancePointEllipseSpecial(e, y, x);
      }
    } else {
      // (y0,y1) is outside the subellipse. The closest ellipsoid
      // point has x2 == 0 and is on the domain-boundary ellipse
      // (x0/e0)^2 + (x1/e1)^2 = 1.
      x[2] = (MFloat)0;
      distance = distancePointEllipseSpecial(e, y, x);
    }
  }
  return distance;
}


// The ellipsoid is (x0/e0)^2 + (x1/e1)^2 + (x2/e2)^2 = 1 with e0 >= e1 >= e2.
// The query point is (y0,y1,y2) with y0 >= 0, y1 >= 0, and y2 >= 0. The
// function returns the distance from the query point to the ellipsoid. It
// also computes the ellipsoid point (x0,x1,x2) in the first octant that is
// closest to (y0,y1,y2).
// author: David Eberly, Geometric Tools, LLC
// http://www.geometrictools.com/
// note: variant of distancePointEllipsoidSpecial(...) assuming y>0 and using dynamic eps to improve performance,
// Lennart
// Performance optimizations: division elimination, loop unrolling

template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::distancePointEllipsoidSpecial2(const MFloat e[3], const MFloat y[3],
                                                                           MFloat x[3]) {
  constexpr MFloat eps0 = 1e-12;
  constexpr MFloat eps1 = 1e-6;
  const MFloat dist0 = c_cellLengthAtLevel(m_lsCutCellBaseLevel);
  const MFloat dist1 = m_maxBndryLayerWidth * c_cellLengthAtLevel(m_lsCutCellBaseLevel);
  MFloat distance;
  // Bisect to compute the root of F(t) for t >= -e2*e2.
  MFloat esqr[3] = {e[0] * e[0], e[1] * e[1], e[2] * e[2]};
  MFloat ey[3] = {e[0] * y[0], e[1] * y[1], e[2] * y[2]};
  MFloat t0 = -esqr[2] + ey[2];
  MFloat t1 = -esqr[2] + sqrt(ey[0] * ey[0] + ey[1] * ey[1] + ey[2] * ey[2]);
  MFloat t;
  const MInt imax = 2 * std::numeric_limits<MFloat>::max_exponent;
  MFloat eps = eps1;
  if(fabs(t1 - t0) < eps) t1 = t0 + F2 * eps;
  t = F1B2 * (t0 + t1);
  MInt i = 0;
  distance = c_cellLengthAtLevel(0);

  while(fabs(t1 - t0) > eps && i < imax) {
    // loop unrolling
    while ( i < imax ) {
      i++;
      t = F1B2 * (t0 + t1);
      MFloat f0 = (t + esqr[0]) * (t + esqr[0]);
      MFloat f1 = (t + esqr[1]) * (t + esqr[1]);
      MFloat f2 = (t + esqr[2]) * (t + esqr[2]);
      MFloat fs = f0 * f1 * f2;
      // avoid division
      MFloat f = ey[0] * ey[0] * f1 * f2 + ey[1] * ey[1] * f0 * f2 + ey[2] * ey[2] * f0 * f1;
      if(f > fs) {
        t0 = t;
      } else {
        t1 = t;
      }
      if( fabs(t1 - t0) < eps || i >= imax ) break;

      i++;
      t = F1B2 * (t0 + t1);
      f0 = (t + esqr[0])*(t + esqr[0]);
      f1 = (t + esqr[1])*(t + esqr[1]);
      f2 = (t + esqr[2])*(t + esqr[2]);
      fs = f0*f1*f2;
      f = ey[0] * ey[0] * f1 * f2 + ey[1] * ey[1] * f0 * f2 + ey[2] * ey[2] * f0 * f1;
      if(f > fs) {
        t0 = t;
      } else {
        t1 = t;
      }
      if(fabs(t1 - t0) < eps || i >= imax) break;

      i++;
      t = F1B2 * (t0 + t1);
      f0 = (t + esqr[0])*(t + esqr[0]);
      f1 = (t + esqr[1])*(t + esqr[1]);
      f2 = (t + esqr[2])*(t + esqr[2]);
      fs = f0 * f1 * f2;
      f = ey[0] * ey[0] * f1 * f2 + ey[1] * ey[1] * f0 * f2 + ey[2] * ey[2] * f0 * f1;
      if(f > fs) {
        t0 = t;
      } else {
        t1 = t;
      }
      if(fabs(t1 - t0) < eps || i >= imax) break;

      i++;
      t = F1B2 * (t0 + t1);
      f0 = (t + esqr[0])*(t + esqr[0]);
      f1 = (t + esqr[1])*(t + esqr[1]);
      f2 = (t + esqr[2])*(t + esqr[2]);
      fs = f0*f1*f2;
      f = ey[0] * ey[0] * f1 * f2 + ey[1] * ey[1] * f0 * f2 + ey[2] * ey[2] * f0 * f1;
      if(f > fs) {
        t0 = t;
      } else {
        t1 = t;
      }
      if(fabs(t1 - t0) < eps || i >= imax) break;
    }
    x[0] = esqr[0] * y[0] / (t + esqr[0]);
    x[1] = esqr[1] * y[1] / (t + esqr[1]);
    x[2] = esqr[2] * y[2] / (t + esqr[2]);
    distance = sqrt(POW2(x[0] - y[0]) + POW2(x[1] - y[1]) + POW2(x[2] - y[2]));
    // adjust eps: small close to surface, larger further away from surface
    eps = eps0 + mMin(F1, mMax(F0, (distance - dist0) / (dist1 - dist0))) * (eps1 - eps0);
  }
  if(fabs(t0 - t1) > eps) cerr << setprecision(16) << "ellipsoid dist not converged! " << i << " " << t1 - t0 << endl;
  return distance;
}


// The ellipsoid is (x0/e0)^2 + (x1/e1)^2 + (x2/e2)^2 = 1. The query point is
// (y0,y1,y2). The function returns the distance from the query point to the
// ellipsoid. It also computes the ellipsoid point (x0,x1,x2) that is
// closest to (y0,y1,y2).
// author: David Eberly, Geometric Tools, LLC
// http://www.geometrictools.com/
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::distancePointEllipsoid(const MFloat e[3], const MFloat y[3], MFloat x[3]) {
  // Determine reflections for y to the first octant.
  MBool reflect[3];
  MInt i, j;
  for(i = 0; i < 3; ++i) {
    reflect[i] = (y[i] < (MFloat)0);
  }

  // Determine the axis order for decreasing extents.
  MInt permute[3];
  if(e[0] < e[1]) {
    if(e[2] < e[0]) {
      permute[0] = 1;
      permute[1] = 0;
      permute[2] = 2;
    } else if(e[2] < e[1]) {
      permute[0] = 1;
      permute[1] = 2;
      permute[2] = 0;
    } else {
      permute[0] = 2;
      permute[1] = 1;
      permute[2] = 0;
    }
  } else {
    if(e[2] < e[1]) {
      permute[0] = 0;
      permute[1] = 1;
      permute[2] = 2;
    } else if(e[2] < e[0]) {
      permute[0] = 0;
      permute[1] = 2;
      permute[2] = 1;
    } else {
      permute[0] = 2;
      permute[1] = 0;
      permute[2] = 1;
    }
  }
  MInt invpermute[3];
  for(i = 0; i < 3; ++i) {
    invpermute[permute[i]] = i;
  }
  MFloat locE[3], locY[3];
  for(i = 0; i < 3; ++i) {
    j = permute[i];
    locE[i] = e[j];
    locY[i] = y[j];
    if(reflect[j]) {
      locY[i] = -locY[i];
    }
  }
  MFloat locX[3];
#define IMPROVEDDISTELLIPSOID
#ifdef IMPROVEDDISTELLIPSOID
  for(i = 0; i < 3; ++i) {
    ASSERT(!(locY[i] < F0), "");
    locY[i] = mMax(1e-15, locY[i]); // guarantee non-zero entries
  }
  MFloat distance = distancePointEllipsoidSpecial2(locE, locY, locX);
#else
  MFloat distance = distancePointEllipsoidSpecial(locE, locY, locX);
#endif
  // Restore the axis order and reflections.
  for(i = 0; i < 3; ++i) {
    j = invpermute[i];
    if(reflect[i]) {
      locX[j] = -locX[j];
    }
    x[i] = locX[j];
  }
  return distance;
}


// The ellipse is (x0/e0)^2 + (x1/e1)^2 = 1 with e0 >= e1. The query point is
// (y0,y1) with y0 >= 0 and y1 >= 0. The function returns the distance from
// the query point to the ellipse. It also computes the ellipse point (x0,x1)
// in the first quadrant that is closest to (y0,y1).
// author: David Eberly, Geometric Tools, LLC
// http://www.geometrictools.com/
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::distancePointEllipseSpecial(const MFloat e[2], const MFloat y[2],
                                                                        MFloat x[2]) {
  constexpr MFloat eps = 1e-14;
  MFloat distance;

  if(y[1] > (MFloat)0) {
    if(y[0] > (MFloat)0) {
      // Bisect to compute the root of F(t) for t >= -e1*e1.
      MFloat esqr[2] = {e[0] * e[0], e[1] * e[1]};
      MFloat ey[2] = {e[0] * y[0], e[1] * y[1]};
      MFloat t0 = -esqr[1] + ey[1];
      MFloat t1 = -esqr[1] + sqrt(ey[0] * ey[0] + ey[1] * ey[1]);
      MFloat t = t0;
      const MInt imax = 2 * std::numeric_limits<MFloat>::max_exponent;
      for(MInt i = 0; i < imax; ++i) {
        t = ((MFloat)0.5) * (t0 + t1);
        if(fabs(t - t0) < eps || fabs(t - t1) < eps) {
          break;
        }
        MFloat r[2] = {ey[0] / (t + esqr[0]), ey[1] / (t + esqr[1])};
        MFloat f = r[0] * r[0] + r[1] * r[1] - (MFloat)1;
        if(f > (MFloat)0) {
          t0 = t;
        } else if(f < (MFloat)0) {
          t1 = t;
        } else {
          break;
        }
      }
      if(fabs(t0 - t1) > eps) cerr << "ellipse dist not converged!" << endl;
      x[0] = esqr[0] * y[0] / (t + esqr[0]);
      x[1] = esqr[1] * y[1] / (t + esqr[1]);
      MFloat d[2] = {x[0] - y[0], x[1] - y[1]};
      distance = sqrt(d[0] * d[0] + d[1] * d[1]);
    } else // y0 == 0
    {
      x[0] = (MFloat)0;
      x[1] = e[1];
      distance = fabs(y[1] - e[1]);
    }
  } else // y1 == 0
  {
    MFloat denom0 = e[0] * e[0] - e[1] * e[1];
    MFloat e0y0 = e[0] * y[0];
    if(e0y0 < denom0) {
      // y0 is inside the subinterval.
      MFloat x0de0 = e0y0 / denom0;
      MFloat x0de0sqr = x0de0 * x0de0;
      x[0] = e[0] * x0de0;
      x[1] = e[1] * sqrt(fabs((MFloat)1 - x0de0sqr));
      MFloat d0 = x[0] - y[0];
      distance = sqrt(d0 * d0 + x[1] * x[1]);
    } else {
      // y0 is outside the subinterval. The closest ellipse point has
      // x1 == 0 and is on the domain-boundary interval (x0/e0)^2 = 1.
      x[0] = e[0];
      x[1] = (MFloat)0;
      distance = fabs(y[0] - e[0]);
    }
  }
  return distance;
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::getDistanceTetrahedron(const MFloat* const coordinates, const MInt bodyId) {
  ASSERT(bodyId > -1 && bodyId < m_noEmbeddedBodies + m_noPeriodicGhostBodies, "");

  constexpr MFloat eps = 5e-3;
  const MFloat fac0 = F1 / sqrt(F3);
  const MFloat fac1 = F1B6 * pow(PI / F2, F1B3);
  const MFloat fac = fac1 * m_bodyDiameter[bodyId];
  constexpr MFloat dirs[4][3] = {{F1, F1, -F1}, {F1, -F1, F1}, {-F1, F1, F1}, {-F1, -F1, -F1}};

  MFloat innerDist = std::numeric_limits<MFloat>::lowest();
  MFloat outerDist = F0;

  MFloatScratchSpace R(3, 3, AT_, "R");
  MFloat xw[3];
  MFloat xb[3];
  computeRotationMatrix(R, &(m_bodyQuaternion[4 * bodyId]));
  MFloat x = coordinates[0] - m_bodyCenter[bodyId * nDim + 0];
  MFloat y = coordinates[1] - m_bodyCenter[bodyId * nDim + 1];
  MFloat z = F0;
  IF_CONSTEXPR(nDim == 3) { z = coordinates[2] - m_bodyCenter[bodyId * nDim + 2]; }
  xw[0] = x;
  xw[1] = y;
  IF_CONSTEXPR(nDim == 3) { xw[2] = z; }
  matrixVectorProduct(xb, R, xw);
  x = xb[0];
  y = xb[1];
  IF_CONSTEXPR(nDim == 3) { z = xb[2]; }

  MFloat dists[4];

  for(MInt face = 0; face < 4; face++) {
    MFloat dist = F0;
    IF_CONSTEXPR(nDim == 2) {
      dist = dirs[face][0] * fac0 * (x - fac * dirs[face][0]) + dirs[face][1] * fac0 * (y - fac * dirs[face][1]);
    }
    else IF_CONSTEXPR(nDim == 3) {
      dist = dirs[face][0] * fac0 * (x - fac * dirs[face][0]) + dirs[face][1] * fac0 * (y - fac * dirs[face][1])
             + dirs[face][2] * fac0 * (z - fac * dirs[face][2]);
    }
    innerDist = mMax(innerDist, dist);
    outerDist += POW2(mMax(F0, dist));

    dists[face] = dist;
  }
  std::sort(dists, dists + 4, [](const MFloat& a, const MFloat& b) { return fabs(a) < fabs(b); });

  if(innerDist < F0) {
    if(fabs(dists[1]) < eps * m_bodyDiameter[bodyId]) {
      innerDist = F0;
      for(MInt face = 0; face < 4; face++) {
        if(fabs(dists[face]) < eps * m_bodyDiameter[bodyId]) {
          innerDist = -sqrt(POW2(innerDist) + POW2(dists[face]));
        }
      }
    }
  } else {
    if(fabs(dists[1]) < eps * m_bodyDiameter[bodyId]) {
      outerDist = F0;
      for(MInt face = 0; face < 4; face++) {
        if(fabs(dists[face]) < eps * m_bodyDiameter[bodyId]) {
          outerDist += POW2(dists[face]);
        }
      }
    }
  }

  return (innerDist < F0) ? innerDist : sqrt(outerDist);
}


/**
 * \brief rotation matrix co-rotating(~inertial) frame -> body-fixed frame
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
inline void FvMbCartesianSolverXD<nDim, SysEqn>::computeRotationMatrix(MFloatScratchSpace& R, MFloat* q) {
  R(0, 0) = q[0] * q[0] + q[1] * q[1] - q[2] * q[2] - q[3] * q[3];
  R(1, 1) = q[0] * q[0] - q[1] * q[1] + q[2] * q[2] - q[3] * q[3];
  R(2, 2) = q[0] * q[0] - q[1] * q[1] - q[2] * q[2] + q[3] * q[3];

  R(0, 1) = F2 * (q[1] * q[2] + q[0] * q[3]);
  R(0, 2) = F2 * (q[1] * q[3] - q[0] * q[2]);
  R(1, 0) = F2 * (q[1] * q[2] - q[0] * q[3]);
  R(1, 2) = F2 * (q[2] * q[3] + q[0] * q[1]);
  R(2, 0) = F2 * (q[1] * q[3] + q[0] * q[2]);
  R(2, 1) = F2 * (q[2] * q[3] - q[0] * q[1]);
}


/**
 * \brief C=A*B
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
inline void FvMbCartesianSolverXD<nDim, SysEqn>::matrixProduct(MFloatScratchSpace& C, MFloatScratchSpace& A,
                                                               MFloatScratchSpace& B) {
  ASSERT(A.size1() == B.size0(), "");
  C.fill(F0);
  for(MInt i = 0; i < C.size0(); i++) {
    for(MInt k = 0; k < C.size1(); k++) {
      for(MInt j = 0; j < A.size1(); j++) {
        C(i, k) += A(i, j) * B(j, k);
      }
    }
  }
}


/**
 * \brief C=A*B^t
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
inline void FvMbCartesianSolverXD<nDim, SysEqn>::matrixProductTranspose(MFloatScratchSpace& C, MFloatScratchSpace& A,
                                                                        MFloatScratchSpace& B) {
  ASSERT(A.size1() == B.size1(), "");
  C.fill(F0);
  for(MInt i = 0; i < C.size0(); i++) {
    for(MInt k = 0; k < C.size1(); k++) {
      for(MInt j = 0; j < A.size1(); j++) {
        C(i, k) += A(i, j) * B(k, j);
      }
    }
  }
}


/**
 * \brief C=A^t*B
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
inline void FvMbCartesianSolverXD<nDim, SysEqn>::matrixProductTranspose2(MFloatScratchSpace& C, MFloatScratchSpace& A,
                                                                         MFloatScratchSpace& B) {
  ASSERT(A.size0() == B.size0(), "");
  C.fill(F0);
  for(MInt i = 0; i < C.size0(); i++) {
    for(MInt k = 0; k < C.size1(); k++) {
      for(MInt j = 0; j < A.size0(); j++) {
        C(i, k) += A(j, i) * B(j, k);
      }
    }
  }
}


/**
 * \brief c=A*b
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
inline void FvMbCartesianSolverXD<nDim, SysEqn>::matrixVectorProduct(MFloat* c, MFloatScratchSpace& A, MFloat* b) {
  for(MInt i = 0; i < A.size0(); i++) {
    c[i] = F0;
    for(MInt j = 0; j < A.size1(); j++) {
      c[i] += A(i, j) * b[j];
    }
  }
}


/**
 * \brief c=A^t*b
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
inline void FvMbCartesianSolverXD<nDim, SysEqn>::matrixVectorProductTranspose(MFloat* c, MFloatScratchSpace& A,
                                                                              MFloat* b) {
  for(MInt i = 0; i < A.size1(); i++) {
    c[i] = F0;
    for(MInt j = 0; j < A.size0(); j++) {
      c[i] += A(j, i) * b[j];
    }
  }
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::integrateBodyRotation() {
  if(m_fixedBodyComponentsRotation[0] && m_fixedBodyComponentsRotation[1] && m_fixedBodyComponentsRotation[2]) return;

  MFloatScratchSpace R0(3, 3, AT_, "R0");
  MFloatScratchSpace R(3, 3, AT_, "R");
  MFloatScratchSpace W(4, 4, AT_, "W");
  MFloatScratchSpace iW(4, 4, AT_, "iW");
  MFloatScratchSpace iI(3, 3, AT_, "iI");
  MFloatScratchSpace tmpM(3, 3, AT_, "tmpM");
  MFloatScratchSpace rhs(4, AT_, "rhs");

  MFloat tmp[3];
  MFloat tmp2[3];
  MFloat q0[3];
  MFloat q[3];
  MFloat tq0[3];
  MFloat tq[3];
  const MFloat dt2 = F1B2 * timeStep();

  MIntScratchSpace recvCnt(noDomains(), AT_, "recvCnt");
  MIntScratchSpace recvDispl(noDomains() + 1, AT_, "recvDispl");
  MIntScratchSpace bodyOffsets(noDomains() + 1, AT_, "bodyOffsets");
  bodyOffsets(0) = 0;
  for(MLong i = 0; i < noDomains(); i++) {
    MLong tmpv = (((MLong)m_noEmbeddedBodies) * (i + 1)) / ((MLong)noDomains());
    if(tmpv > numeric_limits<MInt>::max()) mTerm(1, "MInt overflow");
    bodyOffsets(i + 1) = (MInt)tmpv;
  }

  for(MInt k = bodyOffsets(domainId()); k < bodyOffsets(domainId() + 1); k++) {
    ASSERT(k > -1 && k < m_noEmbeddedBodies, "");
    computeRotationMatrix(R0, &(m_bodyQuaternionDt1[4 * k]));
    computeRotationMatrix(R, &(m_bodyQuaternion[4 * k]));
    const MFloat w = m_bodyQuaternionDt1[4 * k + 0];
    const MFloat x = m_bodyQuaternionDt1[4 * k + 1];
    const MFloat y = m_bodyQuaternionDt1[4 * k + 2];
    const MFloat z = m_bodyQuaternionDt1[4 * k + 3];
    for(MInt i = 0; i < 3; i++)
      tmp[i] = m_bodyAngularVelocityDt1[k * 3 + i];
    matrixVectorProduct(q0, R0, tmp);
    for(MInt i = 0; i < 3; i++)
      tmp[i] = m_bodyTorqueDt1[k * 3 + i];
    matrixVectorProduct(tq0, R0, tmp);

    for(MInt i = 0; i < 3; i++)
      tmp[i] = m_bodyTorque[k * 3 + i];
    matrixVectorProduct(tq, R, tmp);

    const MFloat* momi = &(m_bodyMomentOfInertia[3 * k]);
    const MFloat f0 = (momi[2] - momi[1]) / momi[0];
    const MFloat f1 = (momi[0] - momi[2]) / momi[1];
    const MFloat f2 = (momi[1] - momi[0]) / momi[2];

    for(MInt i = 0; i < 3; i++)
      tmp[i] = m_bodyAngularVelocity[k * 3 + i];
    matrixVectorProduct(&(q[0]), R, tmp);

    for(MInt i = 0; i < 3; i++) {
      if(std::isnan(tq[i]) || std::isnan(tq0[i]) || std::isnan(q[i])) {
        if(domainId() == 0) {
          cerr << "error rotation omega " << k << " " << i << " " << tq0[i] << " " << tq[i] << " " << q[i] << " ("
               << m_bodyTorque[k * 3 + 0] << "," << m_bodyTorque[k * 3 + 1] << "," << m_bodyTorque[k * 3 + 2] << ")"
               << endl;
        }
        if(std::isnan(tq0[i])) tq0[i] = F0;
        tq[i] = tq0[i];
        q[i] = q0[i];
        // mTerm(1,AT_, "Solution diverged at body rotational integration (omega).");
      }
    }

    const MInt maxit = 100;
    MFloat delta = F1;
    MInt it = 0;

    // Newton iterations
    while(delta > 1e-10 && it < maxit) {
      W(0, 0) = F1;
      W(0, 1) = dt2 * q[2] * f0;
      W(0, 2) = dt2 * q[1] * f0;
      W(1, 0) = dt2 * q[2] * f1;
      W(1, 1) = F1;
      W(1, 2) = dt2 * q[0] * f1;
      W(2, 0) = dt2 * q[1] * f2;
      W(2, 1) = dt2 * q[0] * f2;
      W(2, 2) = F1;

      maia::math::invert(W, iW, 3, 3);

      for(MInt i = 0; i < 3; i++)
        rhs[i] = q[i] - q0[i] - dt2 * (tq0[i] + tq[i]) / momi[i];
      rhs[0] += dt2 * f0 * (q0[1] * q0[2] + q[1] * q[2]);
      rhs[1] += dt2 * f1 * (q0[0] * q0[2] + q[0] * q[2]);
      rhs[2] += dt2 * f2 * (q0[0] * q0[1] + q[0] * q[1]);
      delta = F0;
      for(MInt i = 0; i < 3; i++) {
        const MFloat qq = q[i];
        for(MInt j = 0; j < 3; j++) {
          q[i] -= iW(i, j) * rhs(j);
        }
        delta = mMax(delta, fabs(q[i] - qq));
      }
      it++;
    }
    if(it >= maxit && domainId() == 0) {
      cerr << "Newton iterations did not converge " << k << endl;
    }

    for(MInt i = 0; i < 3; i++) {
      if(std::isnan(q[i])) {
        if(domainId() == 0) {
          cerr << "error rotation quaternion " << k << " " << i << " " << q[i] << endl;
          cerr << q[0] << " " << q[1] << " " << q[2] << " " << endl;
          cerr << tq0[0] << " " << tq0[1] << " " << tq0[2] << endl;
          cerr << tq[0] << " " << tq[1] << " " << tq[2] << endl;
        }
        // MPI_Barrier(mpiComm(), AT_ );
        // mTerm(1,AT_, "Solution diverged at body rotational integration (quaternion)" + to_string(q[i]) );
        q[i] = q0[i];
      }
    }


    W(0, 0) = F0;
    W(0, 1) = -q[0];
    W(0, 2) = -q[1];
    W(0, 3) = -q[2];
    W(1, 0) = q[0];
    W(1, 1) = F0;
    W(1, 2) = q[2];
    W(1, 3) = -q[1];
    W(2, 0) = q[1];
    W(2, 1) = -q[2];
    W(2, 2) = F0;
    W(2, 3) = q[0];
    W(3, 0) = q[2];
    W(3, 1) = q[1];
    W(3, 2) = -q[0];
    W(3, 3) = F0;
    for(MInt i = 0; i < 4; i++)
      for(MInt j = 0; j < 4; j++)
        W(i, j) = -F1B2 * dt2 * W(i, j);
    for(MInt i = 0; i < 4; i++)
      W(i, i) = F1;

    rhs(0) = w + F1B2 * dt2 * (-x * q0[0] - y * q0[1] - z * q0[2]);
    rhs(1) = x + F1B2 * dt2 * (w * q0[0] - z * q0[1] + y * q0[2]);
    rhs(2) = y + F1B2 * dt2 * (z * q0[0] + w * q0[1] - x * q0[2]);
    rhs(3) = z + F1B2 * dt2 * (-y * q0[0] + x * q0[1] + w * q0[2]);

    maia::math::invert(W, iW, 4, 4);

    for(MInt i = 0; i < 4; i++) {
      m_bodyQuaternion[4 * k + i] = F0;
      for(MInt j = 0; j < 4; j++) {
        m_bodyQuaternion[4 * k + i] += iW(i, j) * rhs(j);
      }
    }

    MFloat abs = F0;
    for(MInt i = 0; i < 4; i++)
      abs += POW2(m_bodyQuaternion[4 * k + i]);
    for(MInt i = 0; i < 4; i++)
      m_bodyQuaternion[4 * k + i] /= sqrt(abs);


    computeRotationMatrix(R, &(m_bodyQuaternion[4 * k]));
    matrixVectorProductTranspose(tmp, R, &(q[0]));

    for(MInt i = 0; i < 3; i++) {
      if(m_fixedBodyComponentsRotation[i]) continue;
      m_bodyAngularVelocity[k * 3 + i] = tmp[i];
    }
    for(MInt i = 0; i < 3; i++) {
      tmp[i] = (q[i] - q0[i]) / timeStep();
    }
    matrixVectorProductTranspose(tmp2, R, &(tmp[0]));
    for(MInt i = 0; i < 3; i++) {
      if(m_fixedBodyComponentsRotation[i]) continue;
      m_bodyAngularAcceleration[k * 3 + i] = tmp2[i];
    }
  }

  recvDispl(0) = 0;
  for(MInt i = 0; i < noDomains(); i++) {
    recvDispl(i + 1) = 4 * bodyOffsets(i + 1);
    recvCnt(i) = recvDispl(i + 1) - recvDispl(i);
  }
  MPI_Allgatherv(MPI_IN_PLACE, 0, MPI_DATATYPE_NULL, m_bodyQuaternion, &recvCnt[0], &recvDispl[0], MPI_DOUBLE,
                 mpiComm(), AT_, "MPI_IN_PLACE", "m_bodyQuaternion");

  recvDispl(0) = 0;
  for(MInt i = 0; i < noDomains(); i++) {
    recvDispl(i + 1) = 3 * bodyOffsets(i + 1);
    recvCnt(i) = recvDispl(i + 1) - recvDispl(i);
  }
  MPI_Allgatherv(MPI_IN_PLACE, 0, MPI_DATATYPE_NULL, m_bodyAngularVelocity, &recvCnt[0], &recvDispl[0], MPI_DOUBLE,
                 mpiComm(), AT_, "MPI_IN_PLACE", "m_bodyAngularVelocity");
  MPI_Allgatherv(MPI_IN_PLACE, 0, MPI_DATATYPE_NULL, m_bodyAngularAcceleration, &recvCnt[0], &recvDispl[0], MPI_DOUBLE,
                 mpiComm(), AT_, "MPI_IN_PLACE", "m_bodyAngularAcceleration");
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::getBodyRotation(const MInt bodyId, MFloat* bodyRotation) {
  TRACE();

  if(!m_constructGField) return;

  const MFloat qw = m_bodyQuaternion[4 * bodyId + 0];
  const MFloat qx = m_bodyQuaternion[4 * bodyId + 1];
  const MFloat qy = m_bodyQuaternion[4 * bodyId + 2];
  const MFloat qz = m_bodyQuaternion[4 * bodyId + 3];
  bodyRotation[0] = atan2(F2 * qw * qx + 2 * qy * qz, F1 - F2 * qw * qw - F2 * qz * qz);
  bodyRotation[1] = asin(F2 * qx * qz - F2 * qw * qy);
  bodyRotation[2] = atan2(F2 * qx * qy + F2 * qw * qz, F1 - F2 * qy * qy - F2 * qz * qz);
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::getBodyRotationDt1(const MInt bodyId, MFloat* bodyRotation) {
  TRACE();

  if(!m_constructGField) return;

  const MFloat qw = m_bodyQuaternionDt1[4 * bodyId + 0];
  const MFloat qx = m_bodyQuaternionDt1[4 * bodyId + 1];
  const MFloat qy = m_bodyQuaternionDt1[4 * bodyId + 2];
  const MFloat qz = m_bodyQuaternionDt1[4 * bodyId + 3];
  bodyRotation[0] = atan2(F2 * qw * qx + 2 * qy * qz, F1 - F2 * qw * qw - F2 * qz * qz);
  bodyRotation[1] = asin(F2 * qx * qz - F2 * qw * qy);
  bodyRotation[2] = atan2(F2 * qx * qy + F2 * qw * qz, F1 - F2 * qy * qy - F2 * qz * qz);
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::setBodyQuaternions(const MInt bodyId, MFloat* bodyRotation) {
  TRACE();

  if(!m_constructGField) return;

  m_bodyQuaternion[bodyId * 4 + 0] = cos(F1B2 * bodyRotation[1]) * cos(F1B2 * (bodyRotation[2] + bodyRotation[0]));
  m_bodyQuaternion[bodyId * 4 + 1] = sin(F1B2 * bodyRotation[1]) * sin(F1B2 * (bodyRotation[2] - bodyRotation[0]));
  m_bodyQuaternion[bodyId * 4 + 2] = sin(F1B2 * bodyRotation[1]) * cos(F1B2 * (bodyRotation[2] - bodyRotation[0]));
  m_bodyQuaternion[bodyId * 4 + 3] = cos(F1B2 * bodyRotation[1]) * sin(F1B2 * (bodyRotation[2] + bodyRotation[0]));
}


/**
 * \fn void FvMbCartesianSolverXD<nDim, SysEqn>::constructGFieldPredictor()
 * \brief determine the displacement of the embedded body -- predictor step
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::constructGFieldPredictor() {
  TRACE();

  ASSERT(m_constructGField, "");

  NEW_TIMER_GROUP_STATIC(t_initTimer, "GFieldPredictor");
  NEW_TIMER_STATIC(t_timertotal, "GFieldPredictor", t_initTimer);
  NEW_SUB_TIMER_STATIC(t_init, "init", t_timertotal);
  NEW_SUB_TIMER_STATIC(t_advance, "advance", t_timertotal);
  NEW_SUB_TIMER_STATIC(t_transfer, "transfer", t_timertotal);

  m_structureStep = 0;

  if(!m_trackMovingBndry || globalTimeStep < m_trackMbStart || globalTimeStep >= m_trackMbEnd) return;

  RECORD_TIMER_START(t_timertotal);
  RECORD_TIMER_START(t_init);

  if(m_motionEquation == 0 || globalTimeStep < m_FSIStart) {
    // forced motion
    if(m_constructGField && m_bodyTypeMb > 0) {
      constructGField();
    } else if(m_motionEquation == 0) {
      updateBodyProperties();
    }
    if(m_bodyTypeMb != 0) {
      createPeriodicGhostBodies();
      createBodyTree();
    }
    RECORD_TIMER_STOP(t_init);
    RECORD_TIMER_STOP(t_timertotal);
    return;
  }

#if defined _MB_DEBUG_ || !defined NDEBUG
  m_solutionDiverged = false;
  for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
    for(MInt i = 0; i < nDim; i++) {
      m_solutionDiverged += std::isnan(m_bodyForce[k * nDim + i]);
    }
    for(MInt i = 0; i < 3; i++) {
      m_solutionDiverged += std::isnan(m_bodyTorque[k * 3 + i]);
    }
  }
  MPI_Allreduce(MPI_IN_PLACE, &m_solutionDiverged, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                "m_solutionDiverged");
  if(m_solutionDiverged) {
    for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
      for(MInt i = 0; i < nDim; i++) {
        m_log << m_bodyForce[k * nDim + i] << " ";
      }
      m_log << " / ";
      for(MInt i = 0; i < 3; i++) {
        m_log << m_bodyTorque[k * 3 + i] << " ";
      }
      m_log << endl;
    }
    const MInt writeHaloBack = m_haloCellOutput;
    m_haloCellOutput = true;
    writeVtkXmlFiles("QOUT", "GEOM", false, true);
    m_haloCellOutput = writeHaloBack;
    MPI_Barrier(mpiComm(), AT_);
    mTerm(1, AT_, "Solution diverged before structure predictor handling.");
  }
#endif

  RECORD_TIMER_STOP(t_init);
  RECORD_TIMER_START(t_advance);


  MBool& firstRun = m_static_constructGFieldPredictor_firstRun;
  MBool& adaptiveGravity = m_static_constructGFieldPredictor_adaptiveGravity;
  if(firstRun) {
    if(Context::propertyExists("adaptiveGravity", m_solverId)) {
      /*! \page propertiesFVMB
        \section adaptiveGravity
        <code>MBool FvMbCartesianSolverXD::constructGFieldPredictor::adaptiveGravity </code>\n
        default = <code>m_static_constructGFieldPredictor_adaptiveGravity(false)</code>\n
        Sets the gravity in z-direction to -F/m at the first call of constructGFieldPredictor.\n
        Possible values are:
        <ul>
          <li>true: do that </li>
          <li>false: don't do that </li>
        </ul>
        Keywords: <i>FINITE VOLUME, MOVING BOUNDARY, GRAVITY</i>
      */
      adaptiveGravity = Context::getSolverProperty<MBool>("adaptiveGravity", m_solverId, AT_, &adaptiveGravity);
    }
    firstRun = false;
  }
  if(adaptiveGravity && globalTimeStep == m_FSIStart) {
    m_gravity[2] = -m_bodyForce[2] / m_bodyMass[0];
    // m_gravity[2] = -F3B4*CdLaw(m_Re)*POW2(m_Ma)/(m_referenceLength*m_rhoInfinity);
    // m_gravity[2] = -CdLaw(m_Re) * m_rhoU2 * PI*POW2( F1B2*m_bodyDiameter[0] );
    m_log << "adaptive gravity: " << m_gravity[2] << " " << m_bodyForce[2] << " " << m_bodyForce[nDim + 2] << endl;
  }


  switch(m_motionEquation) {
    // free motion under gravity
    case 1: {
      for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
        for(MInt i = 0; i < nDim; i++) {
          if(m_fixedBodyComponents[i]) continue;

          m_bodyAcceleration[k * nDim + i] = m_bodyAccelerationDt1[k * nDim + i];
          m_bodyCenter[k * nDim + i] =
              m_bodyCenterDt1[k * nDim + i]
              + timeStep() * m_bodyVelocityDt1[k * nDim + i]
              + F1B4 * POW2(timeStep()) * (m_bodyAccelerationDt1[k * nDim + i] + m_bodyAcceleration[k * nDim + i]);
          m_bodyVelocity[k * nDim + i] =
              m_bodyVelocityDt1[k * nDim + i]
              + timeStep() * F1B2 * (m_bodyAccelerationDt1[k * nDim + i] + m_bodyAcceleration[k * nDim + i]);
          if(fabs(m_bodyCenter[k * nDim + i] - m_bodyCenterDt1[k * nDim + i])
             > c_cellLengthAtLevel(m_lsCutCellBaseLevel))
            cerr << "displ " << k << " " << i << " " << m_bodyCenter[k * nDim + i] << " "
                 << m_bodyCenterDt1[k * nDim + i] << endl;
        }
        m_bodyTemperature[k] =
            m_bodyTemperatureDt1[k] + timeStep() * m_bodyHeatFlux[k] / (m_capacityConstantVolumeRatio * m_bodyMass[k]);
      }
      integrateBodyRotation();

      break;
    }

    // elastically mounted (Ahn & Kallinderis, JCP(2006))
    case 2: {
      for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
        for(MInt i = 0; i < nDim; i++) {
          if(m_fixedBodyComponents[i]) continue;

          m_bodyCenterDt2[k * nDim + i] = m_bodyCenterDt1[k * nDim + i];
          m_bodyCenterDt1[k * nDim + i] = m_bodyCenter[k * nDim + i];
          m_bodyVelocityDt1[k * nDim + i] = m_bodyVelocity[k * nDim + i];

          const MFloat A = F4 * PI * m_bodyDampingCoefficient[k] * m_bodyReducedFrequency[k];
          const MFloat B = F4 * POW2(PI) * POW2(m_bodyReducedFrequency[k]);
          const MFloat C = m_bodyForce[k * nDim + i] / m_bodyReducedMass[k];
          m_bodyCenter[k * nDim + i] =
              m_bodyCenterDt1[k * nDim + i] + timeStep() * m_bodyVelocityDt1[k * nDim + i]
              + POW2(timeStep())
                    * (C - A * m_bodyVelocityDt1[k * nDim + i]
                       - B * (m_bodyCenterDt1[k * nDim + i] - m_bodyNeutralCenter[k * nDim + i]));
          m_bodyVelocity[k * nDim + i] = (m_bodyCenter[k * nDim + i] - m_bodyCenterDt1[k * nDim + i]) / timeStep();
          m_bodyAcceleration[k * nDim + i] =
              (m_bodyCenter[k * nDim + i] - F2 * m_bodyCenterDt1[k * nDim + i] + m_bodyCenterDt2[k * nDim + i])
              / POW2(timeStep());
        }
      }

      break;
    }

    // elastically mounted - implicit discretization (Borazjani, JCP(2008))
    case 3: {
      for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
        for(MInt i = 0; i < nDim; i++) {
          if(m_fixedBodyComponents[i]) continue;

          m_bodyCenterDt1[k * nDim + i] = m_bodyCenter[k * nDim + i];
          m_bodyVelocityDt1[k * nDim + i] = m_bodyVelocity[k * nDim + i];

          const MFloat A = F4 * PI * m_bodyDampingCoefficient[k] * m_bodyReducedFrequency[k];
          const MFloat B = F4 * POW2(PI) * POW2(m_bodyReducedFrequency[k]);
          const MFloat C = m_bodyForce[k * nDim + i] / m_bodyReducedMass[k];

          m_bodyVelocity[k * nDim + i] =
              (m_bodyVelocityDt1[k * nDim + i] * (F1 - F1B2 * POW2(timeStep()) * B) + timeStep() * C
               - timeStep() * B * (m_bodyCenterDt1[k * nDim + i] - m_bodyNeutralCenter[k * nDim + i]))
              / (F1 + timeStep() * A + F1B2 * POW2(timeStep()) * B);
          m_bodyCenter[k * nDim + i] =
              m_bodyCenterDt1[k * nDim + i]
              + timeStep() * F1B2 * (m_bodyVelocity[k * nDim + i] + m_bodyVelocityDt1[k * nDim + i]);
          m_bodyAcceleration[k * nDim + i] =
              (m_bodyVelocity[k * nDim + i] - m_bodyVelocityDt1[k * nDim + i]) / timeStep();
        }
      }

      break;
    }

    // elastically mounted - true Crank Nicolson ( Lennart's modification of Borazjani scheme )
    case 4: {
      for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
        for(MInt i = 0; i < nDim; i++) {
          if(m_fixedBodyComponents[i]) continue;

          m_bodyForceDt1[k * nDim + i] = m_bodyForce[k * nDim + i];
          m_bodyCenterDt1[k * nDim + i] = m_bodyCenter[k * nDim + i];
          m_bodyVelocityDt1[k * nDim + i] = m_bodyVelocity[k * nDim + i];

          const MFloat A = F4 * PI * m_bodyDampingCoefficient[k] * m_bodyReducedFrequency[k];
          const MFloat B = F4 * POW2(PI) * POW2(m_bodyReducedFrequency[k]);
          // the following yields essentially the old body force -> second order only recovered via the corrector steps!
          const MFloat C = F1B2 * (m_bodyForce[k * nDim + i] + m_bodyForceDt1[k * nDim + i]) / m_bodyReducedMass[k];
          const MFloat beta = F1B2 * timeStep() * (A + F1B2 * timeStep() * B);

          m_bodyVelocity[k * nDim + i] =
              (m_bodyVelocityDt1[k * nDim + i] * (F1 - beta) + timeStep() * C
               - timeStep() * B * (m_bodyCenterDt1[k * nDim + i] - m_bodyNeutralCenter[k * nDim + i]))
              / (F1 + beta);
          m_bodyCenter[k * nDim + i] =
              m_bodyCenterDt1[k * nDim + i]
              + timeStep() * F1B2 * (m_bodyVelocity[k * nDim + i] + m_bodyVelocityDt1[k * nDim + i]);
          m_bodyAcceleration[k * nDim + i] =
              (m_bodyVelocity[k * nDim + i] - m_bodyVelocityDt1[k * nDim + i]) / timeStep();
        }
      }

      break;
    }

    // Beeman scheme
    case 5: {
      for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
        for(MInt i = 0; i < nDim; i++) {
          if(m_fixedBodyComponents[i]) continue;

          m_bodyAcceleration[k * nDim + i] =
              m_bodyAccelerationDt1[k * nDim + i]
              + (timeStep() / m_previousTimeStep)
                    * (m_bodyAccelerationDt1[k * nDim + i] - m_bodyAccelerationDt2[k * nDim + i]);
          m_bodyCenter[k * nDim + i] =
              m_bodyCenterDt1[k * nDim + i] + timeStep() * m_bodyVelocityDt1[k * nDim + i]
              + F1B6 * POW2(timeStep()) * (m_bodyAcceleration[k * nDim + i] + F2 * m_bodyAccelerationDt1[k * nDim + i]);
          m_bodyVelocity[k * nDim + i] =
              m_bodyVelocityDt1[k * nDim + i]
              + timeStep() * F1B2 * (m_bodyAcceleration[k * nDim + i] + m_bodyAccelerationDt1[k * nDim + i]);
        }
      }
      integrateBodyRotation();

      break;
    }

    case 6: { // fourth-order Beeman scheme -> JCP 20 (1976)

      for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
        for(MInt i = 0; i < nDim; i++) {
          if(m_fixedBodyComponents[i]) continue;

          // initial guess
          m_bodyAcceleration[k * nDim + i] = F3 * m_bodyAccelerationDt1[k * nDim + i]
                                             - F3 * m_bodyAccelerationDt2[k * nDim + i]
                                             + m_bodyAccelerationDt3[k * nDim + i];
          m_bodyCenter[k * nDim + i] =
              m_bodyCenterDt1[k * nDim + i] + timeStep() * m_bodyVelocityDt1[k * nDim + i]
              + F1B24 * POW2(timeStep())
                    * (F3 * m_bodyAcceleration[k * nDim + i] + F10 * m_bodyAccelerationDt1[k * nDim + i]
                       - m_bodyAccelerationDt2[k * nDim + i]);
          m_bodyVelocity[k * nDim + i] =
              m_bodyVelocityDt1[k * nDim + i]
              + timeStep() * F1B12
                    * (F5 * m_bodyAcceleration[k * nDim + i] + F8 * m_bodyAccelerationDt1[k * nDim + i]
                       - m_bodyAccelerationDt2[k * nDim + i]);
        }
      }
      integrateBodyRotation();

      break;
    }

    default: {
      mTerm(1, AT_, "Invalid motion equation specified!");
    }
  }

  RECORD_TIMER_STOP(t_advance);
  RECORD_TIMER_START(t_transfer);

#if defined _MB_DEBUG_ || !defined NDEBUG
  MBool nan = false;
  for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
    for(MInt i = 0; i < nDim; i++) {
      if(std::isnan(m_bodyVelocity[k * nDim + i]) || std::isnan(m_bodyCenter[k * nDim + i])
         || std::isnan(m_bodyAcceleration[k * nDim + i])) {
        nan = true;
      }
    }
  }
  if(nan) {
    m_solutionDiverged = true;
    cerr << "Solution diverged (SPRED) at solver " << domainId() << endl;
  }
  MPI_Allreduce(MPI_IN_PLACE, &m_solutionDiverged, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                "m_solutionDiverged");
  if(m_solutionDiverged) {
    writeVtkXmlFiles("QOUT", "GEOM", false, true);
    MPI_Barrier(mpiComm(), AT_);
    mTerm(1, AT_, "Solution diverged after structure predictor handling.");
  }
#endif

  createPeriodicGhostBodies();
  createBodyTree();

  RECORD_TIMER_STOP(t_transfer);
  RECORD_TIMER_STOP(t_timertotal);
  DISPLAY_TIMER_OFFSET(t_timertotal, m_restartInterval);
}


/**
 * \brief determine the displacement of the embedded body -- corrector step
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
MBool FvMbCartesianSolverXD<nDim, SysEqn>::constructGFieldCorrector() {
  TRACE();

  m_structureStep++;

  if(!m_trackMovingBndry || globalTimeStep < m_trackMbStart || globalTimeStep >= m_trackMbEnd) return true;
  if(m_motionEquation == 0) return true;
  if(globalTimeStep < m_FSIStart) {
    return true;
  }

  ASSERT(m_constructGField, "");

  NEW_TIMER_GROUP_STATIC(t_initTimer, "GFieldCorrector");
  NEW_TIMER_STATIC(t_timertotal, "GFieldCorrector", t_initTimer);
  NEW_SUB_TIMER_STATIC(t_init, "init", t_timertotal);
  NEW_SUB_TIMER_STATIC(t_advance, "advance", t_timertotal);
  NEW_SUB_TIMER_STATIC(t_transfer, "transfer", t_timertotal);
  RECORD_TIMER_START(t_timertotal);
  RECORD_TIMER_START(t_init);

  MFloatScratchSpace oldX(m_noEmbeddedBodies, nDim, AT_, "oldX");
  MFloatScratchSpace oldV(m_noEmbeddedBodies, nDim, AT_, "oldV");
  MFloatScratchSpace oldQ(m_noEmbeddedBodies, 4, AT_, "oldQ");
  MFloatScratchSpace oldW(m_noEmbeddedBodies, 3, AT_, "oldW");

  for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
    for(MInt i = 0; i < nDim; i++)
      oldX(k, i) = m_bodyCenter[k * nDim + i];
    for(MInt i = 0; i < nDim; i++)
      oldV(k, i) = m_bodyVelocity[k * nDim + i];
    for(MInt i = 0; i < 3; i++)
      oldW(k, i) = m_bodyAngularVelocity[k * 3 + i];
    for(MInt i = 0; i < 4; i++)
      oldQ(k, i) = m_bodyQuaternion[k * 4 + i];
  }

  RECORD_TIMER_STOP(t_init);
  RECORD_TIMER_START(t_advance);


  switch(m_motionEquation) {
    // free motion under gravity
    case 1: {
      for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
        for(MInt i = 0; i < nDim; i++) {
          if(m_fixedBodyComponents[i]) continue;

          m_bodyAcceleration[k * nDim + i] = (m_bodyForce[k * nDim + i]) / m_bodyMass[k] + m_gravity[i];
          m_bodyCenter[k * nDim + i] =
              m_bodyCenterDt1[k * nDim + i]
              + timeStep() * m_bodyVelocityDt1[k * nDim + i]
              + F1B4 * POW2(timeStep()) * (m_bodyAccelerationDt1[k * nDim + i] + m_bodyAcceleration[k * nDim + i]);
          m_bodyVelocity[k * nDim + i] =
              m_bodyVelocityDt1[k * nDim + i]
              + timeStep() * F1B2 * (m_bodyAccelerationDt1[k * nDim + i] + m_bodyAcceleration[k * nDim + i]);
          if(fabs(m_bodyCenter[k * nDim + i] - m_bodyCenterDt1[k * nDim + i])
             > c_cellLengthAtLevel(m_lsCutCellBaseLevel))
            cerr << "displ " << k << " " << i << " " << m_bodyCenter[k * nDim + i] << " "
                 << m_bodyCenterDt1[k * nDim + i] << endl;
        }
        m_bodyTemperature[k] = F1B2
                               * (m_bodyTemperature[k] + m_bodyTemperatureDt1[k]
                                  + timeStep() * (m_bodyHeatFlux[k] / (m_capacityConstantVolumeRatio * m_bodyMass[k])));
      }
      integrateBodyRotation();

      break;
    }

    case 2: {
      /*
          if ( m_initialCondition == 459 ) {
            const MFloat rhosbrhof = 1.05 / 1.0;
            const MFloat rhofbrhos = 1.0 / rhosbrhof;
            const MFloat Cd = 24.0 * POW2( 9.06/sqrt(m_Re) + 1.0 ) / POW2( 9.06 );
            const MFloat ut = sqrt( 4.0/3.0 * m_physicalReferenceLength * 9.81 * (rhosbrhof-1.0) / Cd );
            const MFloat Froude = ut / sqrt( 9.81 * m_physicalReferenceLength );
            const MFloat g[3] = { F0, F0, -POW2( m_Ma / Froude ) };

            dxmax = F0;
            dumax = F0;

            for ( MInt k = 0; k < m_noEmbeddedBodies; k++ ) {
              dx = F0;
              du = F0;
              for( MInt i=0; i<nDim; i++ ) {
                if( m_fixedBodyComponents[ i ] )
                  continue;

                tmpx = m_bodyCenter[ k*nDim+i ];
                tmpu = m_bodyVelocity[ k*nDim+i ];

                m_bodyAcceleration[ k*nDim+i ] =
                  ( F1 - rhofbrhos ) * g[ i ] + rhofbrhos * m_bodyForce[ k*nDim+i ] / m_bodyMass[ k ] ;

                m_bodyVelocity[ k*nDim+i ] =
                  m_bodyVelocityDt1[ k*nDim+i ] + timeStep() * 0.5 *
                  ( m_bodyAcceleration[ k*nDim+i ] + m_bodyAccelerationDt1[ k*nDim+i ] );

                m_bodyCenter[ k*nDim+i ] =
                  m_bodyCenterDt1[ k*nDim+i ] + timeStep() * 0.5 *
                  ( m_bodyVelocity[ k*nDim+i ] + m_bodyVelocityDt1[ k*nDim+i ] );

                  //   m_bodyVelocity[ k*nDim+i ]  =
                  // ( m_bodyCenter[ k*nDim+i ] - m_bodyCenterDt1[ k*nDim+i ] ) / timeStep();

                  dx += POW2( m_bodyCenter[ k*nDim+i ] - tmpx );
                  du += POW2( m_bodyVelocity[ k*nDim+i ] - tmpu );
                  }
                  du = sqrt( du );
                  dx = sqrt( dx );
                  dumax = mMax( dumax, du );
                  dxmax = mMax( dxmax, dx );
                  }

                  cerr << "corr: " << globalTimeStep << " " << m_structureStep << " " << dxmax << " " << dumax << endl;
                  }
      */

      break;
    }

    // elastically mounted - implicit discretization (Borazjani, JCP(2008))
    case 3: {
      for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
        for(MInt i = 0; i < nDim; i++) {
          if(m_fixedBodyComponents[i]) continue;

          const MFloat A = F4 * PI * m_bodyDampingCoefficient[k] * m_bodyReducedFrequency[k];
          const MFloat B = F4 * POW2(PI) * POW2(m_bodyReducedFrequency[k]);
          const MFloat C = m_bodyForce[k * nDim + i] / m_bodyReducedMass[k];

          m_bodyVelocity[k * nDim + i] =
              (m_bodyVelocityDt1[k * nDim + i] * (F1 - F1B2 * POW2(timeStep()) * B) + timeStep() * C
               - timeStep() * B * (m_bodyCenterDt1[k * nDim + i] - m_bodyNeutralCenter[k * nDim + i]))
              / (F1 + timeStep() * A + F1B2 * POW2(timeStep()) * B);
          m_bodyCenter[k * nDim + i] =
              m_bodyCenterDt1[k * nDim + i]
              + timeStep() * F1B2 * (m_bodyVelocity[k * nDim + i] + m_bodyVelocityDt1[k * nDim + i]);
          m_bodyAcceleration[k * nDim + i] =
              (m_bodyVelocity[k * nDim + i] - m_bodyVelocityDt1[k * nDim + i]) / timeStep();
        }
      }

      break;
    }

    // elastically mounted - true Crank Nicolson ( Lennart's modification of Borazjani scheme )
    case 4: {
      for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
        for(MInt i = 0; i < nDim; i++) {
          if(m_fixedBodyComponents[i]) continue;

          const MFloat A = F4 * PI * m_bodyDampingCoefficient[k] * m_bodyReducedFrequency[k];
          const MFloat B = F4 * POW2(PI) * POW2(m_bodyReducedFrequency[k]);
          const MFloat C = F1B2 * (m_bodyForce[k * nDim + i] + m_bodyForceDt1[k * nDim + i]) / m_bodyReducedMass[k];
          const MFloat beta = F1B2 * timeStep() * (A + F1B2 * timeStep() * B);

          m_bodyVelocity[k * nDim + i] =
              (m_bodyVelocityDt1[k * nDim + i] * (F1 - beta) + timeStep() * C
               - timeStep() * B * (m_bodyCenterDt1[k * nDim + i] - m_bodyNeutralCenter[k * nDim + i]))
              / (F1 + beta);
          m_bodyCenter[k * nDim + i] =
              m_bodyCenterDt1[k * nDim + i]
              + timeStep() * F1B2 * (m_bodyVelocity[k * nDim + i] + m_bodyVelocityDt1[k * nDim + i]);
          m_bodyAcceleration[k * nDim + i] =
              (m_bodyVelocity[k * nDim + i] - m_bodyVelocityDt1[k * nDim + i]) / timeStep();
        }
      }

      break;
    }

    // Beeman scheme
    case 5: {
      for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
        for(MInt i = 0; i < nDim; i++) {
          if(m_fixedBodyComponents[i]) continue;

          m_bodyAcceleration[k * nDim + i] = (m_bodyForce[k * nDim + i] + m_gravity[i]) / m_bodyMass[k];
          m_bodyCenter[k * nDim + i] =
              m_bodyCenterDt1[k * nDim + i] + timeStep() * m_bodyVelocityDt1[k * nDim + i]
              + F1B6 * POW2(timeStep()) * (m_bodyAcceleration[k * nDim + i] + F2 * m_bodyAccelerationDt1[k * nDim + i]);
          m_bodyVelocity[k * nDim + i] =
              m_bodyVelocityDt1[k * nDim + i]
              + timeStep() * F1B2 * (m_bodyAcceleration[k * nDim + i] + m_bodyAccelerationDt1[k * nDim + i]);
        }
      }
      integrateBodyRotation();

      break;
    }

    // fourth-order Beeman scheme -> JCP 20 (1976)
    case 6: {
      for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
        for(MInt i = 0; i < nDim; i++) {
          if(m_fixedBodyComponents[i]) continue;

          m_bodyAcceleration[k * nDim + i] = (m_bodyForce[k * nDim + i] + m_gravity[i]) / m_bodyMass[k];
          m_bodyCenter[k * nDim + i] =
              m_bodyCenterDt1[k * nDim + i] + timeStep() * m_bodyVelocityDt1[k * nDim + i]
              + F1B24 * POW2(timeStep())
                    * (F3 * m_bodyAcceleration[k * nDim + i] + F10 * m_bodyAccelerationDt1[k * nDim + i]
                       - m_bodyAccelerationDt2[k * nDim + i]);
          m_bodyVelocity[k * nDim + i] =
              m_bodyVelocityDt1[k * nDim + i]
              + timeStep() * F1B12
                    * (F5 * m_bodyAcceleration[k * nDim + i] + F8 * m_bodyAccelerationDt1[k * nDim + i]
                       - m_bodyAccelerationDt2[k * nDim + i]);
        }
      }
      integrateBodyRotation();

      break;
    }

    default: {
      mTerm(1, AT_, "Invalid motion equation specified!");
    }
  }

  RECORD_TIMER_STOP(t_advance);
  RECORD_TIMER_START(t_transfer);

#if defined _MB_DEBUG_ || !defined NDEBUG
  MBool nan = false;
  for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
    for(MInt i = 0; i < nDim; i++) {
      if(std::isnan(m_bodyVelocity[k * nDim + i]) || std::isnan(m_bodyCenter[k * nDim + i])
         || std::isnan(m_bodyAcceleration[k * nDim + i])) {
        nan = true;
      }
    }
  }
  if(nan) {
    m_solutionDiverged = true;
    cerr << "Solution diverged (SCORR) at solver " << domainId() << endl;
  }
  MPI_Allreduce(MPI_IN_PLACE, &m_solutionDiverged, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                "m_solutionDiverged");
  if(m_solutionDiverged) {
    writeVtkXmlFiles("QOUT", "GEOM", false, true);
    MPI_Barrier(mpiComm(), AT_);
    mTerm(1, AT_, "Solution diverged after structure corrector handling.");
  }
#endif

  createPeriodicGhostBodies();
  createBodyTree();

  MFloat dxmax = F0;
  MFloat dumax = F0;
  MFloat drmax = F0;
  MFloat dwmax = F0;
  MFloat dxavg = F0;
  MFloat duavg = F0;
  MFloat dravg = F0;
  MFloat dwavg = F0;

  for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
    for(MInt i = 0; i < nDim; i++) {
      if(m_fixedBodyComponents[i]) continue;
      MFloat dx = fabs(m_bodyCenter[k * nDim + i] - oldX(k, i));
      MFloat du = fabs(m_bodyVelocity[k * nDim + i] - oldV(k, i));
      dumax = mMax(dumax, du);
      dxmax = mMax(dxmax, dx);
      duavg += du;
      dxavg += dx;
    }
  }

  for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
    for(MInt i = 0; i < 3; i++) {
      if(m_fixedBodyComponentsRotation[i]) continue;
      MFloat dw = fabs(m_bodyAngularVelocity[k * 3 + i] - oldW(k, i));
      dwmax = mMax(dwmax, dw);
      dwavg += dw;
    }
    for(MInt i = 0; i < 4; i++) {
      MFloat dr = fabs(m_bodyQuaternion[k * 4 + i] - oldQ(k, i));
      drmax = mMax(drmax, dr);
      dravg += dr;
    }
  }

  dxavg /= ((MFloat)m_noEmbeddedBodies);
  duavg /= ((MFloat)m_noEmbeddedBodies);
  dravg /= ((MFloat)m_noEmbeddedBodies);
  dwavg /= ((MFloat)m_noEmbeddedBodies);

  if(globalTimeStep % 10 == 0 || m_structureStep > 1) {
    cerr0 << "corr: " << globalTimeStep << "   (" << m_structureStep << "): " << dxmax << " " << dumax << " / " << drmax
          << " " << dwmax << " (" << dxavg << " " << duavg << " / " << dravg << " " << dwavg << ")" << endl;
  }

  RECORD_TIMER_STOP(t_transfer);
  RECORD_TIMER_STOP(t_timertotal);
  DISPLAY_TIMER_OFFSET(t_timertotal, m_restartInterval);

  if((dxmax < m_FSIToleranceX) && (dumax < m_FSIToleranceU) && (drmax < m_FSIToleranceR) && (dwmax < m_FSIToleranceW)) {
    return true;
  } else {
    return false;
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::resetRHSNonInternalCells() {
#ifdef _MB_DEBUG_
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    for(MInt j = 0; j < noHaloCells(i); j++) {
      MInt cellId = haloCellId(i, j);

      if(c_noChildren(cellId) > 0) continue;
      if(!a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;

      for(MInt var = 0; var < m_noFVars; var++) {
        a_rightHandSide(cellId, var) = F0;
      }
    }
  }
#endif
}


/**
 * \brief advances the time and stores the flow variables
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::advanceSolution() {
  TRACE();

  const MInt noCBytes = a_noCells() * m_noCVars * sizeof(MFloat);
  const MInt noFBytes = a_noCells() * m_noFVars * sizeof(MFloat);
  MFloat* RESTRICT cVars = (MFloat*)(&(a_variable(0, 0)));
  MFloat* RESTRICT oCVars = (MFloat*)(&(a_oldVariable(0, 0)));

  memcpy(oCVars, cVars, noCBytes);
  memcpy(&(m_rhs0[0][0]), &(a_rightHandSide(0, 0)), noFBytes);

  if(m_dualTimeStepping) memcpy(&(m_cellVolumesDt2[0]), &(m_cellVolumesDt1[0]), a_noCells() * sizeof(MFloat));
  memcpy(&(m_cellVolumesDt1[0]), &(a_cellVolume(0)), a_noCells() * sizeof(MFloat));

  for(MInt cellId = 0; cellId < m_bndryGhostCellsOffset; cellId++) {
    a_hasProperty(cellId, SolverCell::WasInactive) = a_hasProperty(cellId, SolverCell::IsInactive);
  }

  advanceExternalSource();

  m_nearBoundaryBackup.clear();

  for(MUint c = 0; c < m_bndryLayerCells.size(); c++) {
    MInt cellId = m_bndryLayerCells[c];
    if(!m_constructGField) {
      ASSERT(a_hasProperty(cellId, SolverCell::NearWall),
             to_string(m_solverId) + " " + to_string(globalDomainId()) + " " + to_string(domainId()));
    }

    vector<MFloat> tmp(max(m_noCVars + m_noFVars, 0) + 1);
    tmp[0] = m_cellVolumesDt1[cellId];

    for(MInt v = 0; v < m_noCVars; v++) {
      tmp[1 + v] = a_oldVariable(cellId, v);
    }

    for(MInt v = 0; v < m_noFVars; v++) {
      tmp[1 + m_noCVars + v] = m_rhs0[cellId][v];
    }

    m_nearBoundaryBackup.insert(make_pair(cellId, tmp));
  }

  m_oldBndryCells.clear();
  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;

    ASSERT(!a_isBndryGhostCell(cellId), "");
    if(!m_constructGField) {
      ASSERT(a_hasProperty(cellId, SolverCell::IsMovingBnd), "");
    }

    if(a_hasProperty(cellId, SolverCell::IsSplitChild)) {
      a_hasProperty(cellId, SolverCell::IsMovingBnd) = false;
      a_hasProperty(cellId, SolverCell::NearWall) = false;
      continue;
    }
    m_oldBndryCells.insert(make_pair(cellId, m_sweptVolume[bndryId]));
  }
  m_reComputedBndry = false;

  for(MUint it = 0; it < m_temporarilyLinkedCells.size(); it++) {
    const MInt cellId = get<1>(m_temporarilyLinkedCells[it]);
    a_hasProperty(cellId, SolverCell::IsTempLinked) = false;
  }
  m_temporarilyLinkedCells.clear();
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    m_linkedWindowCells[i].clear();
    m_linkedHaloCells[i].clear();
  }
}


/**
 * \brief advances the time and stores the flow variables
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::advanceBodies() {
  TRACE();

  const size_t dim3 = 3 * m_noEmbeddedBodies * sizeof(MFloat);
  const size_t dim4 = 4 * m_noEmbeddedBodies * sizeof(MFloat);
  const size_t dimD = nDim * m_noEmbeddedBodies * sizeof(MFloat);

  if(m_motionEquation > 1) {
    memcpy(m_bodyVelocityDt2, m_bodyVelocityDt1, dimD);
    memcpy(m_bodyCenterDt2, m_bodyCenterDt1, dimD);
    memcpy(m_bodyAccelerationDt3, m_bodyAccelerationDt2, dimD);
    memcpy(m_bodyAccelerationDt2, m_bodyAccelerationDt1, dimD);
  }

  memcpy(m_bodyVelocityDt1, m_bodyVelocity, dimD);
  memcpy(m_bodyCenterDt1, m_bodyCenter, dimD);
  memcpy(m_bodyAccelerationDt1, m_bodyAcceleration, dimD);
  memcpy(m_bodyTorqueDt1, m_bodyTorque, dim3);
  memcpy(m_bodyAngularVelocityDt1, m_bodyAngularVelocity, dim3);
  memcpy(m_bodyAngularAccelerationDt1, m_bodyAngularAcceleration, dim3);
  memcpy(m_bodyQuaternionDt1, m_bodyQuaternion, dim4);
  memcpy(m_bodyTemperatureDt1, m_bodyTemperature, m_noEmbeddedBodies * sizeof(MFloat));

  if(!m_constructGField) return;

  if(m_noPointParticles > 0) {
    m_fvBndryCnd->recorrectCellCoordinates();

    const MInt heatRelated = 2;
    const MInt dataSize = 7 * 3 + 2 * 4 + heatRelated;

    MIntScratchSpace sendCount(noDomains(), AT_, "sendCount");
    MIntScratchSpace recvCount(noDomains(), AT_, "recvCount");
    ScratchSpace<MPI_Request> sendReq(noNeighborDomains(), AT_, "sendReq");
    ScratchSpace<vector<MFloat>> sendVars(noNeighborDomains(), AT_, "sendVars");
    ScratchSpace<vector<MFloat>> recvVars(noNeighborDomains(), AT_, "recvVars");
    ScratchSpace<vector<MLong>> sendIds(noNeighborDomains(), AT_, "sendIds");
    ScratchSpace<vector<MLong>> recvIds(noNeighborDomains(), AT_, "recvIds");
    ScratchSpace<vector<MInt>> sendParticleGlobalIds(noNeighborDomains(), AT_, "sendParticleGlobalIds");
    ScratchSpace<vector<MInt>> recvParticleGlobalIds(noNeighborDomains(), AT_, "recvParticleGlobalIds");
    map<MLong, MInt> globalToLocal;
    ScratchSpace<MLong> globalIds(a_noCells(), AT_, "globalId");
    sendCount.fill(0);
    recvCount.fill(0);

    for(MInt i = 0; i < noNeighborDomains(); ++i) {
      sendVars[i].clear();
      recvVars[i].clear();
      sendIds[i].clear();
      recvIds[i].clear();
    }

    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      if(!a_isHalo(cellId) && c_globalId(cellId) > -1) {
        globalToLocal[(MLong)c_globalId(cellId)] = cellId;
      }
      globalIds(cellId) = (MLong)c_globalId(cellId);
    }

    exchangeDataFV(&globalIds[0]);

    for(MUint p = 0; p < m_particleCellLink.size(); p++) {
      const MInt cellId = m_particleCellLink[p];
      const MFloat cellHalfLength = F1B2 * c_cellLengthAtCell(cellId);
      MInt dirCode[3] = {0, 0, 0};
      for(MInt i = 0; i < nDim; i++) {
        if(m_particleCoords[nDim * p + i] < a_coordinate(cellId, i) - cellHalfLength)
          dirCode[i] = -1;
        else if(m_particleCoords[nDim * p + i] > a_coordinate(cellId, i) + cellHalfLength)
          dirCode[i] = 1;
      }
      if(dirCode[0] != 0 || dirCode[1] != 0 || dirCode[2] != 0) {
        MInt nghbrId = cellId;
        for(MInt i = 0; i < nDim; i++) {
          if(dirCode[i] == 0) continue;
          MInt dir = (dirCode[i] > 0) ? 2 * i + 1 : 2 * i;
          if(dirCode[i] > 0 && a_hasNeighbor(nghbrId, dir) == 0) mTerm(1, AT_, "particle moved into void");
          nghbrId = c_neighborId(nghbrId, dir);
        }
        while(c_noChildren(nghbrId) > 0) {
          MInt child = 0;
          for(MUint i = 0; i < nDim; i++) {
            if(m_particleCoords[nDim * p + i] > a_coordinate(nghbrId, i)) child += IPOW2(i);
          }
          nghbrId = c_childId(nghbrId, child);
          if(nghbrId < 0 || nghbrId >= a_noCells()) mTerm(1, AT_, "Point particle linking failed.");
        }
        if(!a_isHalo(nghbrId)) {
          m_particleCellLink[p] = nghbrId;
        } else {
          MLong globalId = globalIds(nghbrId); // c_globalId(nghbrId); //since m_globalId not set in periodic cells...
          MInt nghbrDomain = -1;
          for(MInt i = 0; i < noNeighborDomains(); ++i) {
            if(globalId >= domainOffset(neighborDomain(i)) && globalId < domainOffset(neighborDomain(i) + 1)) {
              nghbrDomain = i;
              break;
            }
          }
          if(nghbrDomain < 0) mTerm(1, AT_, "Neighbor domain not found " + to_string(globalId));
          for(MInt i = 0; i < 3; i++) {
            sendVars[nghbrDomain].push_back(m_particleCoords[nDim * p + i] - a_coordinate(nghbrId, i));
          }
          for(MInt i = 0; i < 3; i++) {
            sendVars[nghbrDomain].push_back(m_particleVelocity[nDim * p + i]);
          }
          for(MInt i = 0; i < 3; i++) {
            sendVars[nghbrDomain].push_back(m_particleAcceleration[nDim * p + i]);
          }
          for(MInt i = 0; i < 4; i++) {
            sendVars[nghbrDomain].push_back(m_particleQuaternions[4 * p + i]);
          }
          for(MInt i = 0; i < 3; i++) {
            sendVars[nghbrDomain].push_back(m_particleAngularVelocity[3 * p + i]);
          }
          for(MInt i = 0; i < 3; i++) {
            sendVars[nghbrDomain].push_back(m_particleAngularAcceleration[3 * p + i]);
          }
          for(MInt i = 0; i < 4; i++) {
            sendVars[nghbrDomain].push_back(m_particleShapeParams[4 * p + i]);
          }
          for(MInt i = 0; i < 3; i++) {
            sendVars[nghbrDomain].push_back(m_particleRadii[3 * p + i]);
          }

          sendVars[nghbrDomain].push_back(m_particleTemperature[p]);
          sendVars[nghbrDomain].push_back(m_particleHeatFlux[p]);

          sendIds[nghbrDomain].push_back(globalId);
          m_particleCellLink[p] = -1;
          sendCount(neighborDomain(nghbrDomain))++;
          sendParticleGlobalIds[nghbrDomain].push_back(m_particleGlobalId[p]);
        }
      }
    }
    MPI_Alltoall(&sendCount[0], 1, MPI_INT, &recvCount[0], 1, MPI_INT, mpiComm(), AT_, "sendCount[0]", "recvCount[0]");
    for(MInt i = 0; i < noNeighborDomains(); ++i) {
      if(recvCount[neighborDomain(i)] > 0) {
        recvVars[i].resize(dataSize * recvCount[neighborDomain(i)]);
        recvIds[i].resize(recvCount[neighborDomain(i)]);
        recvParticleGlobalIds[i].resize(recvCount[neighborDomain(i)]);
      }
    }
    sendReq.fill(MPI_REQUEST_NULL);
    MInt cnt = 0;
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(sendCount[neighborDomain(i)] == 0) continue;
      MPI_Issend(&sendIds[i].front(), sendCount[neighborDomain(i)], MPI_LONG, neighborDomain(i), 78, mpiComm(),
                 &sendReq[cnt], AT_, "sendIds[i].front()");
      cnt++;
    }
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(recvCount[neighborDomain(i)] == 0) continue;
      MPI_Recv(&recvIds[i].front(), recvCount[neighborDomain(i)], MPI_LONG, neighborDomain(i), 78, mpiComm(),
               MPI_STATUS_IGNORE, AT_, "recvIds[i].front()");
    }
    if(cnt > 0) MPI_Waitall(cnt, &sendReq[0], MPI_STATUSES_IGNORE, AT_);
    sendReq.fill(MPI_REQUEST_NULL);
    cnt = 0;
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(sendCount[neighborDomain(i)] == 0) continue;
      MPI_Issend(&sendVars[i].front(), dataSize * sendCount[neighborDomain(i)], MPI_DOUBLE, neighborDomain(i), 79,
                 mpiComm(), &sendReq[cnt], AT_, "sendVars[i].front()");
      cnt++;
    }
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(recvCount[neighborDomain(i)] == 0) continue;
      MPI_Recv(&recvVars[i].front(), dataSize * recvCount[neighborDomain(i)], MPI_DOUBLE, neighborDomain(i), 79,
               mpiComm(), MPI_STATUS_IGNORE, AT_, "recvVars[i].front()");
    }
    if(cnt > 0) MPI_Waitall(cnt, &sendReq[0], MPI_STATUSES_IGNORE, AT_);
    sendReq.fill(MPI_REQUEST_NULL);
    cnt = 0;
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(sendCount[neighborDomain(i)] == 0) continue;
      MPI_Issend(&sendParticleGlobalIds[i].front(), sendCount[neighborDomain(i)], MPI_INT, neighborDomain(i), 80,
                 mpiComm(), &sendReq[cnt], AT_, "sendParticleGlobalIds[i].front()");
      cnt++;
    }
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(recvCount[neighborDomain(i)] == 0) continue;
      MPI_Recv(&recvParticleGlobalIds[i].front(), recvCount[neighborDomain(i)], MPI_INT, neighborDomain(i), 80,
               mpiComm(), MPI_STATUS_IGNORE, AT_, "recvParticleGlobalIds[i].front()");
    }

    if(cnt > 0) MPI_Waitall(cnt, &sendReq[0], MPI_STATUSES_IGNORE, AT_);

    vector<MFloat> tmpCoord;
    vector<MFloat> tmpVel;
    vector<MFloat> tmpTemp;
    vector<MFloat> tmpHeat;
    vector<MFloat> tmpAcc;
    vector<MFloat> tmpCoordsInitial;
    vector<MFloat> tmpQuat;
    vector<MFloat> tmpAngVel;
    vector<MFloat> tmpAngAcc;
    vector<MFloat> tmpShape;
    vector<MFloat> tmpRad;
    vector<MInt> tmpLink;
    vector<MInt> tmpParticleGlobalId;

    tmpCoord.clear();
    tmpVel.clear();
    tmpTemp.clear();
    tmpHeat.clear();
    tmpAcc.clear();
    tmpLink.clear();
    tmpQuat.clear();
    tmpAngVel.clear();
    tmpAngAcc.clear();
    tmpShape.clear();
    tmpRad.clear();
    tmpParticleGlobalId.clear();

    for(MInt p = 0; p < m_noPointParticlesLocal; p++) {
      if(m_particleCellLink[p] > -1) {
        tmpLink.push_back(m_particleCellLink[p]);
        for(MInt i = 0; i < 3; i++)
          tmpCoord.push_back(m_particleCoords[nDim * p + i]);
        for(MInt i = 0; i < 3; i++)
          tmpVel.push_back(m_particleVelocity[nDim * p + i]);
        for(MInt i = 0; i < 3; i++)
          tmpAcc.push_back(m_particleAcceleration[nDim * p + i]);
        for(MInt i = 0; i < 4; i++)
          tmpQuat.push_back(m_particleQuaternions[4 * p + i]);
        for(MInt i = 0; i < 3; i++)
          tmpAngVel.push_back(m_particleAngularVelocity[3 * p + i]);
        for(MInt i = 0; i < 3; i++)
          tmpAngAcc.push_back(m_particleAngularAcceleration[3 * p + i]);
        for(MInt i = 0; i < 4; i++)
          tmpShape.push_back(m_particleShapeParams[4 * p + i]);
        for(MInt i = 0; i < 3; i++)
          tmpRad.push_back(m_particleRadii[3 * p + i]);
        tmpTemp.push_back(m_particleTemperature[p]);
        tmpHeat.push_back(m_particleHeatFlux[p]);
        tmpParticleGlobalId.push_back(m_particleGlobalId[p]);
      }
    }

    m_particleCellLink = tmpLink;
    m_particleCoords = tmpCoord;
    m_particleVelocity = tmpVel;
    m_particleTemperature = tmpTemp;
    m_particleHeatFlux = tmpHeat;
    m_particleAcceleration = tmpAcc;
    m_particleQuaternions = tmpQuat;
    m_particleAngularVelocity = tmpAngVel;
    m_particleAngularAcceleration = tmpAngAcc;
    m_particleShapeParams = tmpShape;
    m_particleRadii = tmpRad;
    m_particleGlobalId = tmpParticleGlobalId;

    for(MInt i = 0; i < noNeighborDomains(); i++) {
      for(MInt k = 0; k < recvCount[neighborDomain(i)]; k++) {
        if(globalToLocal.count(recvIds[i][k]) == 0) mTerm(1, AT_, "Global id invalid " + to_string(recvIds[i][k]));
        MInt cellId = globalToLocal[recvIds[i][k]];
        if(cellId < 0 || cellId >= a_noCells() || c_globalId(cellId) != recvIds[i][k]) {
          cerr << cellId << " " << c_globalId(cellId) << " " << recvIds[i][k] << endl;
          mTerm(1, AT_,
                "Global id mismatch " + to_string(cellId) + " " + to_string(c_globalId(cellId)) + " "
                    + to_string(recvIds[i][k]));
        }
        m_particleCellLink.push_back(cellId);
        MInt id = 0;

        for(MInt j = 0; j < 3; j++) {
          m_particleCoords.push_back(a_coordinate(cellId, j) + recvVars[i][dataSize * k + id]);
          id++;
        }
        for(MInt j = 0; j < 3; j++) {
          m_particleVelocity.push_back(recvVars[i][dataSize * k + id]);
          id++;
        }
        for(MInt j = 0; j < 3; j++) {
          m_particleAcceleration.push_back(recvVars[i][dataSize * k + id]);
          id++;
        }
        for(MInt j = 0; j < 4; j++) {
          m_particleQuaternions.push_back(recvVars[i][dataSize * k + id]);
          id++;
        }
        for(MInt j = 0; j < 3; j++) {
          m_particleAngularVelocity.push_back(recvVars[i][dataSize * k + id]);
          id++;
        }
        for(MInt j = 0; j < 3; j++) {
          m_particleAngularAcceleration.push_back(recvVars[i][dataSize * k + id]);
          id++;
        }
        for(MInt j = 0; j < 4; j++) {
          m_particleShapeParams.push_back(recvVars[i][dataSize * k + id]);
          id++;
        }
        for(MInt j = 0; j < 3; j++) {
          m_particleRadii.push_back(recvVars[i][dataSize * k + id]);
          id++;
        }
        m_particleTemperature.push_back(recvVars[i][dataSize * k + id]);
        id++;
        m_particleHeatFlux.push_back(recvVars[i][dataSize * k + id]);
        id++;
        m_particleGlobalId.push_back(recvParticleGlobalIds[i][k]);
      }
    }

    m_fvBndryCnd->rerecorrectCellCoordinates();

    m_noPointParticlesLocal = (signed)m_particleCellLink.size();
    m_particleAccelerationDt1 = m_particleAcceleration;
    m_particleVelocityDt1 = m_particleVelocity;
    m_particleTemperatureDt1 = m_particleTemperature;
    m_particleCoordsDt1 = m_particleCoords;
    m_particleAngularAccelerationDt1 = m_particleAngularAcceleration;
    m_particleAngularVelocityDt1 = m_particleAngularVelocity;
    m_particleQuaternionsDt1 = m_particleQuaternions;
    m_particleVelocityFluid.resize(m_particleVelocity.size());
    m_particleFluidTemperature.resize(m_particleTemperature.size());
    m_particleVelocityGradientFluid.resize(nDim * m_particleVelocityFluid.size());

    if(m_noPointParticles == 1) {
      for(MInt p = 0; p < m_noPointParticlesLocal; p++) {
        cerr << domainId() << ": particle " << globalTimeStep << " / " << m_particleCoords[nDim * p] << " "
             << m_particleCoords[nDim * p + 1] << " " << m_particleCoords[nDim * p + 2] << " / "
             << m_particleVelocity[nDim * p] << " " << m_particleVelocity[nDim * p + 1] << " "
             << m_particleVelocity[nDim * p + 2] << "/ " << m_particleTemperature[p] << "/ " << m_particleHeatFlux[p]
             << endl;
      }
    }
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::advanceTimeStep() {
  TRACE();

  if(!m_dualTimeStepping) {
    m_physicalTimeDt1 = m_physicalTime;
    m_physicalTime += timeStep();
  }

  m_time += timeStep() * m_timeRef;
  m_RKStep = 0;
}

/**
 * \brief determine all possible fluid boundary cells for a spherical embedded body
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::setupBoundaryCandidatesAnalytical() {
  TRACE();

  MFloat dummyCoord[3];
  const MFloat cellHalfLength = F1B2 * c_cellLengthAtLevel(m_lsCutCellBaseLevel);
  const MFloat limitDistance = F2 * c_cellLengthAtLevel(m_lsCutCellBaseLevel);
  const MFloat nodeStencil[3][8] = {
      {-F1, F1, -F1, F1, -F1, F1, -F1, F1}, {-F1, -F1, F1, F1, -F1, -F1, F1, F1}, {-F1, -F1, -F1, -F1, F1, F1, F1, F1}};
  const MInt dirStencil[8][3] = {{0, 0, 0}, {1, 0, 0}, {0, 1, 0}, {1, 1, 0},
                                 {0, 0, 1}, {1, 0, 1}, {0, 1, 1}, {1, 1, 1}};

  m_bndryCandidateIds.resize(a_noCells());
  for(MInt c = 0; c < a_noCells(); c++)
    m_bndryCandidateIds[c] = -1;
  m_bndryCandidates.clear();
  m_candidateNodeSet.clear();
  m_candidateNodeValues.clear();
  m_noBndryCandidates = 0;

  for(MUint c = 0; c < m_bndryLayerCells.size(); c++) {
    const MInt cellId = m_bndryLayerCells[c];

    if(a_level(cellId) < m_lsCutCellMinLevel || !c_isLeafCell(cellId)) continue;

    ASSERT(m_bodyTypeMb > 0, "");
    MFloat phi = a_levelSetValuesMb(cellId, 0);

    m_bndryCandidateIds[cellId] = -1;
    MInt candidate = -1;
    if(fabs(phi) < limitDistance) {
      candidate = m_noBndryCandidates;
      m_bndryCandidates.push_back(cellId);
      m_bndryCandidateIds[cellId] = candidate;
      m_noBndryCandidates++;
    }
  }
  m_candidateNodeSet.resize(m_noBndryCandidates * m_noCellNodes);
  m_candidateNodeValues.resize(m_noLevelSetsUsedForMb * m_noBndryCandidates * m_noCellNodes);
  for(MInt candidate = 0; candidate < m_noBndryCandidates; candidate++) {
    for(MInt node = 0; node < m_noCellNodes; node++) {
      m_candidateNodeSet[candidate * m_noCellNodes + node] = false;
    }
  }

  for(MInt candidate = 0; candidate < m_noBndryCandidates; candidate++) {
    MInt cellId = m_bndryCandidates[candidate];

    for(MInt node = 0; node < m_noCellNodes; node++) {
      if(m_candidateNodeSet[candidate * m_noCellNodes + node]) continue;
      for(MInt i = 0; i < nDim; i++) {
        dummyCoord[i] = a_coordinate(cellId, i) + nodeStencil[i][node] * cellHalfLength;
      }
      for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
        const MInt b = a_associatedBodyIds(cellId, set);
        MFloat phi = m_bodyDistThreshold + 1e-14;
        if(b > -1) {
          phi = getDistance(&dummyCoord[0], b);
        }
        m_candidateNodeValues[IDX_LSSETNODES(candidate, node, set)] = phi;
      }
      m_candidateNodeSet[candidate * m_noCellNodes + node] = true;

      // update neighbor candidates
      for(MInt i = 0; i < nDim; i++) {
        MInt dir0 = 2 * i + dirStencil[node][i];
        if(a_hasNeighbor(cellId, dir0) == 0) continue;
        MInt nghbrId0 = c_neighborId(cellId, dir0);
        MInt n0 = (dirStencil[node][i] == 0) ? node + IPOW2(i) : node - IPOW2(i);
        MInt cand0 = m_bndryCandidateIds[nghbrId0];
        if(cand0 > -1) {
          MBool match = true;
          for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
            if(a_associatedBodyIds(nghbrId0, set) == a_associatedBodyIds(cellId, set)) {
              m_candidateNodeValues[IDX_LSSETNODES(cand0, n0, set)] =
                  m_candidateNodeValues[IDX_LSSETNODES(candidate, node, set)];
            } else
              match = false;
          }
          if(match) m_candidateNodeSet[cand0 * m_noCellNodes + n0] = true;
        }
        for(MInt j = i + 1; j < nDim; j++) {
          MInt dir1 = 2 * j + dirStencil[node][j];
          if(a_hasNeighbor(nghbrId0, dir1) == 0) continue;
          MInt nghbrId1 = c_neighborId(nghbrId0, dir1);
          MInt n1 = (dirStencil[node][j] == 0) ? n0 + IPOW2(j) : n0 - IPOW2(j);
          MInt cand1 = m_bndryCandidateIds[nghbrId1];
          if(cand1 > -1) {
            MBool match = true;
            for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
              if(a_associatedBodyIds(nghbrId1, set) == a_associatedBodyIds(cellId, set)) {
                m_candidateNodeValues[IDX_LSSETNODES(cand1, n1, set)] =
                    m_candidateNodeValues[IDX_LSSETNODES(candidate, node, set)];
              } else
                match = false;
            }
            if(match) m_candidateNodeSet[cand1 * m_noCellNodes + n1] = true;
          }
          for(MInt k = j + 1; k < nDim; k++) {
            MInt dir2 = 2 * k + dirStencil[node][k];
            if(a_hasNeighbor(nghbrId1, dir2) == 0) continue;
            MInt nghbrId2 = c_neighborId(nghbrId1, dir2);
            MInt n2 = (dirStencil[node][k] == 0) ? n1 + IPOW2(k) : n1 - IPOW2(k);
            MInt cand2 = m_bndryCandidateIds[nghbrId2];
            if(cand2 > -1) {
              MBool match = true;
              for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
                if(a_associatedBodyIds(nghbrId2, set) == a_associatedBodyIds(cellId, set)) {
                  m_candidateNodeValues[IDX_LSSETNODES(cand2, n2, set)] =
                      m_candidateNodeValues[IDX_LSSETNODES(candidate, node, set)];
                } else
                  match = false;
              }
              if(match) m_candidateNodeSet[cand2 * m_noCellNodes + n2] = true;
            }
          }
        }
      }
    }
  }
}


/**
 * \brief determine all possible fluid boundary cells for a generic embedded body
 * \author Lennart Schneiders
 *
 * m_noBndryCandidates : count of boundary-Candidate-cellIds
 * m_bndryCandidates   : mapping m_bndryCandidates[candidateId] = cellId
 * m_bndryCandidateIds : mapping m_bndryCandidateIds[ cellId ] = candidateId
 *
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::determineBndryCandidates() {
  TRACE();

  ASSERT(!m_constructGField, "");

  for(MInt cnd = 0; cnd < m_noBndryCandidates; cnd++) {
    m_bndryCandidateIds[m_bndryCandidates[cnd]] = -1;
  }

  m_bndryCandidateIds.resize(a_noCells());
  m_bndryCandidates.clear();
  m_noBndryCandidates = 0;

  const MFloat limitDistance = F2 * c_cellLengthAtLevel(m_lsCutCellBaseLevel);

  for(MUint c = 0; c < m_bndryLayerCells.size(); c++) {
    const MInt cellId = m_bndryLayerCells[c];
    if(a_bndryId(cellId) < -1) continue;
    if(cellId >= a_noCells()) continue;
    if(fabs(a_levelSetValuesMb(cellId, 0)) < limitDistance
       && a_level(cellId) >= m_lsCutCellMinLevel && c_noChildren(cellId) == 0 && !a_isHalo(cellId)) {
      m_bndryCandidates.push_back(cellId);
      m_bndryCandidateIds[cellId] = m_noBndryCandidates;
      m_noBndryCandidates++;
    } else {
      m_bndryCandidateIds[cellId] = -1;
      // instead of candidates take g0 cells --> no,  g0 cells can exlude bndry cell!
      // solution: make sure g0 neighbour cell stores cutpoint for those cells !
    }
  }

  ASSERT(m_bndryCandidates.size() <= m_bndryLayerCells.size(), "");
  ASSERT(m_noBndryCandidates == (signed)m_bndryCandidates.size(), "");

  for(MInt cnd = 0; cnd < m_noBndryCandidates; cnd++) {
    ASSERT(cnd == m_bndryCandidateIds[m_bndryCandidates[cnd]],
           to_string(cnd) + " " + to_string(m_bndryCandidates[cnd]) + " "
               + to_string(m_bndryCandidateIds[m_bndryCandidates[cnd]]) + " "
               + to_string(a_isHalo(m_bndryCandidates[cnd])));
  }
}


/**
 * \brief compute the level-set values at the mesh vertices
 * \author Lennart Schneiders, Update Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::computeNodalLSValues() {
  TRACE();

  MBool gapClosure = false;
  if(m_levelSet && m_closeGaps && (m_gapInitMethod > 0 || nDim == 3)) {
    gapClosure = true;
  }

  // fill cutCandidates-Information!
  m_cutCandidates.clear();

  for(MInt cnd = 0; cnd < m_noBndryCandidates; cnd++) {
    const MInt cellId = m_bndryCandidates[cnd];
    ASSERT(!a_isHalo(cellId), "");
    m_cutCandidates.emplace_back();
    m_cutCandidates[cnd].cellId = cellId;
  }


  MBoolScratchSpace isGapCell(a_noCells(), AT_, "isGapCell");
  isGapCell.fill(false);
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    if(a_isGapCell(cellId)) isGapCell[cellId] = true;
  }

  m_geometryIntersection->computeNodalValues(m_cutCandidates, &m_bndryCandidateIds[0], &a_levelSetValuesMb(0, 0),
                                             &a_associatedBodyIds(0, 0), &isGapCell(0), gapClosure);

  ASSERT((signed)m_cutCandidates.size() == m_noBndryCandidates, "");

  ScratchSpace<const MInt*> p_maxLevelWindowCells(noNeighborDomains(), AT_, "p_maxLevelWindowCells");
  ScratchSpace<const MInt*> p_maxLevelHaloCells(noNeighborDomains(), AT_, "p_maxLevelHaloCells");

  for(MInt d = 0; d < noNeighborDomains(); d++) {
    p_maxLevelWindowCells[d] = m_maxLevelWindowCells[d];
    p_maxLevelHaloCells[d] = m_maxLevelHaloCells[d];
  }

  m_geometryIntersection->exchangeNodalValues(p_maxLevelWindowCells.data(), &m_noMaxLevelWindowCells[0],
                                              p_maxLevelHaloCells.data(), m_cutCandidates, &m_bndryCandidateIds[0]);

  // Azimuthal periodicity
  if(grid().azimuthalPeriodicity()) {
    computeAzimuthalHaloNodalValues();
  }

  ASSERT((signed)m_cutCandidates.size() >= m_noBndryCandidates, "");

  // fill fv-solver-structre
  m_noBndryCandidates = (signed)m_cutCandidates.size();
  m_bndryCandidates.clear();

  m_candidateNodeSet.resize(m_noBndryCandidates * m_noCellNodes);
  m_candidateNodeValues.resize(m_noLevelSetsUsedForMb * m_noBndryCandidates * m_noCellNodes);

  for(MInt cnd = 0; cnd < m_noBndryCandidates; cnd++) {
    const MInt cellId = m_cutCandidates[cnd].cellId;
    ASSERT(!m_cutCandidates[cnd].isbndryLvlJumpParent, "");

    m_bndryCandidates.push_back(cellId);

    for(MInt node = 0; node < m_noCellNodes; node++) {
      m_candidateNodeSet[cnd * m_noCellNodes + node] = m_cutCandidates[cnd].nodeValueSet[node];
      for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
        m_candidateNodeValues[IDX_LSSETNODES(cnd, node, set)] = m_cutCandidates[cnd].nodalValues[set][node];
      }
    }
    m_bndryCandidateIds[cellId] = cnd;
  }
}

/**
 * \brief init exchange of nodal values of azimuthal periodic halo cells
 * \author Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::computeAzimuthalHaloNodalValues() {
  TRACE();

  MBool gapClosure = false;
  if(m_levelSet && m_closeGaps && (m_gapInitMethod > 0 || nDim == 3)) {
    gapClosure = true;
  }
  if(gapClosure) ASSERT(false, "Are you sure? AzimuthalPer with gapClosing is untested!");

  const MFloat limitDistance = F2 * c_cellLengthAtLevel(m_lsCutCellBaseLevel);

  std::vector<MInt> azimuthalCandidateIds;
  std::vector<CutCandidate<nDim>> azimuthalCandidates;
  MInt noAzimuthalCandidates = 0;

  azimuthalCandidateIds.assign(a_noCells(), -1);
  azimuthalCandidates.clear();

  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MUint j = 0; j < m_azimuthalMaxLevelHaloCells[i].size(); j++) {
      const MInt cellId = m_azimuthalMaxLevelHaloCells[i][j];
      if(a_bndryId(cellId) < -1) continue;
      if(cellId >= a_noCells()) continue;
      if(fabs(a_levelSetValuesMb(cellId, 0)) < limitDistance && a_level(cellId) >= m_lsCutCellMinLevel) {
        azimuthalCandidates.emplace_back();
        azimuthalCandidates[noAzimuthalCandidates].cellId = cellId;
        azimuthalCandidateIds[cellId] = noAzimuthalCandidates;
        noAzimuthalCandidates++;
      } else {
        azimuthalCandidateIds[cellId] = -1;
      }
    }
  }

  MBoolScratchSpace isGapCell(a_noCells(), AT_, "isGapCell");
  isGapCell.fill(false);
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    if(a_isGapCell(cellId)) isGapCell[cellId] = true;
  }

  m_geometryIntersection->computeNodalValues(azimuthalCandidates, &azimuthalCandidateIds[0], &a_levelSetValuesMb(0, 0),
                                             &a_associatedBodyIds(0, 0), &isGapCell(0), gapClosure);

  exchangeAzimuthalOuterNodalValues(azimuthalCandidates, azimuthalCandidateIds);

  for(MUint i = 0; i < azimuthalCandidates.size(); i++) {
    // add halo-cutCandidate
    MInt cellId = azimuthalCandidates[i].cellId;
    const MInt candId = m_cutCandidates.size();
    m_cutCandidates.emplace_back();
    m_cutCandidates[candId].cellId = cellId;

    // add infomation from computeNodalvalues:
    for(MInt node = 0; node < m_noCorners; node++) {
      m_cutCandidates[candId].nodeValueSet[node] = true;
      for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
        m_cutCandidates[candId].nodalValues[set][node] = azimuthalCandidates[i].nodalValues[set][node];
      }
    }
    m_cutCandidates[candId].isGapCell = azimuthalCandidates[i].isGapCell;

    for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
      m_cutCandidates[candId].associatedBodyIds[set] = azimuthalCandidates[i].associatedBodyIds[set];
    }

    m_bndryCandidateIds[cellId] = candId;
  }
}

/**
 * \brief Exchange of nodal values of azimuthal periodic halo cells
 * \author Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::exchangeAzimuthalOuterNodalValues(std::vector<CutCandidate<nDim>>& candidates,
                                                                            std::vector<MInt>& candidateIds) {
  TRACE();

  const MFloat signStencil[8][3] = {{-F1, -F1, -F1}, {F1, -F1, -F1}, {-F1, F1, -F1}, {F1, F1, -F1},
                                    {-F1, -F1, F1},  {F1, -F1, F1},  {-F1, F1, F1},  {F1, F1, F1}};
  const MInt nodeStencil[3][8] = {{0, 1, 0, 1, 0, 1, 0, 1}, {2, 2, 3, 3, 2, 2, 3, 3}, {4, 4, 4, 4, 5, 5, 5, 5}};
  const MInt reverseNode[3][8] = {{1, 0, 3, 2, 5, 4, 7, 6}, {2, 3, 0, 1, 6, 7, 4, 5}, {4, 5, 6, 7, 0, 1, 2, 3}};


  MIntScratchSpace notGradientIds(a_noCells(), AT_, "notGradientIds");
  notGradientIds.fill(-1);
  MUint noAzimuthalHalos = maia::mpi::getBufferSize(m_azimuthalMaxLevelHaloCells);
  MIntScratchSpace notGradientCells(noAzimuthalHalos, AT_, "notGradientCells");
  MIntScratchSpace notGradientDomain(noAzimuthalHalos, AT_, "notGradientDomain");
  MIntScratchSpace notGradientOffset(noAzimuthalHalos, AT_, "notGradientOffset");
  MInt notGradientCntr = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MUint j = 0; j < m_azimuthalMaxLevelHaloCells[i].size(); j++) {
      MInt cellId = m_azimuthalMaxLevelHaloCells[i][j];
      if(candidateIds[cellId] < 0) continue;
      notGradientCells[notGradientCntr] = cellId;
      notGradientDomain[notGradientCntr] = i;
      notGradientOffset[notGradientCntr] = j;
      notGradientIds[cellId] = notGradientCntr;
      notGradientCntr++;
    }
  }

  MIntScratchSpace notGradientCorners(notGradientCntr * m_noCorners, AT_, "notGradientCorners");
  notGradientCorners.fill(-2);

  MInt outerCnt = notGradientCntr * m_noCorners * (nDim + 1);
  MFloatScratchSpace outerNodes(outerCnt, AT_, "outerNodes");
  outerNodes.fill(F0);
  outerCnt = 0;

  MIntScratchSpace sndSize(grid().noAzimuthalNeighborDomains(), AT_, "sndSize");
  sndSize.fill(0);

  MFloat angle = grid().azimuthalAngle();

  const MInt maxNoNghbrs = 56; // IPOW3[nDim];
  MIntScratchSpace nghbrList(maxNoNghbrs, AT_, "nghbrList");
  MIntScratchSpace nghbrNodes(maxNoNghbrs, AT_, "nghbrNodes");
  // MIntScratchSpace layerId(maxNoNghbrs, AT_, "layerList");
  nghbrList.fill(-1);
  nghbrNodes.fill(-1);
  MFloatScratchSpace nodalValue(m_noLevelSetsUsedForMb, AT_, "nodalValue");
  MFloat corner[nDim];
  for(MInt i = 0; i < notGradientCntr; i++) {
    MInt cellId = notGradientCells[i];

    MFloat cellHalfLength = F1B2 * c_cellLengthAtCell(cellId);
    MInt counter;
    for(MInt node = 0; node < m_noCorners; node++) {
      counter = 0;
      if(notGradientCorners[i * m_noCorners + node] > -2) continue;
      MBool isOuter = true;
      nghbrList[counter] = cellId;
      nghbrNodes[counter] = node;
      counter++;

      for(MInt d0 = 0; d0 < nDim; d0++) {
        MInt dir0 = nodeStencil[d0][node];
        MInt nghbrId0 = c_neighborId(cellId, dir0);
        if(nghbrId0 < 0) {
          MInt parentId = c_parentId(cellId);
          if(parentId > -1) nghbrId0 = c_neighborId(parentId, dir0);
        }
        if(nghbrId0 < 0) continue;
        nghbrList[counter] = nghbrId0;
        nghbrNodes[counter] = reverseNode[d0][node];
        counter++;
        for(MInt d1 = 0; d1 < nDim; d1++) {
          if(d1 == d0) continue;
          MInt dir1 = nodeStencil[d1][node];
          MInt nghbrId1 = c_neighborId(nghbrId0, dir1);
          if(nghbrId1 < 0) {
            MInt parentId = c_parentId(nghbrId0);
            if(parentId > -1) nghbrId1 = c_neighborId(parentId, dir1);
          }
          if(nghbrId1 < 0) continue;
          nghbrList[counter] = nghbrId1;
          nghbrNodes[counter] = reverseNode[d1][reverseNode[d0][node]];
          counter++;
          for(MInt d2 = 0; d2 < nDim; d2++) {
            if((d2 == d0) || (d2 == d1)) continue;
            MInt dir2 = nodeStencil[d2][node];
            MInt nghbrId2 = c_neighborId(nghbrId1, dir2);
            if(nghbrId2 < 0) {
              MInt parentId = c_parentId(nghbrId1);
              if(parentId > -1) nghbrId2 = c_neighborId(parentId, dir2);
            }
            if(nghbrId2 < 0) continue;
            nghbrList[counter] = nghbrId2;
            nghbrNodes[counter] = reverseNode[d2][reverseNode[d1][reverseNode[d0][node]]];
            counter++;
          }
        }
      }

      for(MInt n = 0; n < counter; n++) {
        MInt nghbrId = nghbrList[n];
        if(!a_isPeriodic(nghbrId) && m_bndryCandidateIds[nghbrId] > 1) {
          isOuter = false;
          MInt nghbrNode = nghbrNodes[n];
          for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
            nodalValue[set] = m_cutCandidates[m_bndryCandidateIds[nghbrId]].nodalValues[set][nghbrNode];
          }
          break;
        }
      }

      if(isOuter) {
        outerNodes[outerCnt * (nDim + 1)] = (MFloat)notGradientOffset[i];
        for(MInt d = 0; d < nDim; d++) {
          corner[d] = c_coordinate(cellId, d) + signStencil[node][d] * cellHalfLength;
        }
        MInt side = grid().determineAzimuthalBoundarySide(corner);
        grid().rotateCartesianCoordinates(corner, (side * angle));
        std::copy_n(&corner[0], nDim, &outerNodes[outerCnt * (nDim + 1) + 1]);
        sndSize[notGradientDomain[i]]++;

        for(MInt n = 0; n < counter; n++) {
          MInt nghbrId = nghbrList[n];
          MInt nId = notGradientIds[nghbrId];
          if(nId > -1) {
            MInt nghbrNode = nghbrNodes[n];
            notGradientCorners[nId * m_noCorners + nghbrNode] = outerCnt;
          }
        }
        outerCnt++;
      } else {
        for(MInt n = 0; n < counter; n++) {
          MInt nghbrId = nghbrList[n];
          MInt cndId = candidateIds[nghbrId];
          MInt nghbrNode = nghbrNodes[n];
          MInt nId = notGradientIds[nghbrId];
          if(cndId > -1) {
            for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
              candidates[cndId].nodalValues[set][nghbrNode] = nodalValue[set];
            }
          }
          if(nId > -1) {
            notGradientCorners[nId * m_noCorners + nghbrNode] = -1;
          }
        }
      }
    }
  }

  ScratchSpace<MPI_Request> mpi_send_req(grid().noAzimuthalNeighborDomains(), AT_, "mpi_send_req");
  ScratchSpace<MPI_Request> mpi_recv_req(grid().noAzimuthalNeighborDomains(), AT_, "mpi_recv_req");
  MIntScratchSpace rcvSize(grid().noAzimuthalNeighborDomains(), AT_, "rcvBuffSize");

  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    MPI_Irecv(&rcvSize[i], 1, MPI_INT, grid().azimuthalNeighborDomain(i), 2, grid().mpiComm(), &mpi_recv_req[i], AT_,
              "rcvSize[i]");
  }
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    MPI_Isend(&sndSize[i], 1, MPI_INT, grid().azimuthalNeighborDomain(i), 2, grid().mpiComm(), &mpi_send_req[i], AT_,
              "sndSize[i]");
  }
  MPI_Waitall(grid().noAzimuthalNeighborDomains(), &mpi_recv_req[0], MPI_STATUSES_IGNORE, AT_);
  MPI_Waitall(grid().noAzimuthalNeighborDomains(), &mpi_send_req[0], MPI_STATUSES_IGNORE, AT_);

  MInt sndNodeCnt = 0;
  MInt rcvNodeCnt = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    sndNodeCnt += sndSize[i];
    rcvNodeCnt += rcvSize[i];
  }

  MInt fac = mMax((nDim + 1), m_noLevelSetsUsedForMb);
  MFloatScratchSpace rcvBuffers(mMax(sndNodeCnt, rcvNodeCnt) * fac, AT_, "rcvBuffers");
  MFloatScratchSpace sndBuffers(rcvNodeCnt * m_noLevelSetsUsedForMb, AT_, "sndBuffers");

  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    mpi_send_req[i] = MPI_REQUEST_NULL;
    mpi_recv_req[i] = MPI_REQUEST_NULL;
  }

  MInt offset = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    if(rcvSize[i] > 0) {
      MInt bufSize = (nDim + 1) * rcvSize[i];
      MPI_Irecv(&rcvBuffers[offset], bufSize, MPI_DOUBLE, grid().azimuthalNeighborDomain(i), 2, grid().mpiComm(),
                &mpi_recv_req[i], AT_, "rcvBuffers[offset]");
      offset += bufSize;
    }
  }

  offset = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    if(sndSize[i] > 0) {
      MInt bufSize = (nDim + 1) * sndSize[i];
      MPI_Isend(&outerNodes[offset], bufSize, MPI_DOUBLE, grid().azimuthalNeighborDomain(i), 2, grid().mpiComm(),
                &mpi_send_req[i], AT_, "outerNodes[offset]");
      offset += bufSize;
    }
  }

  MPI_Waitall(grid().noAzimuthalNeighborDomains(), &mpi_recv_req[0], MPI_STATUSES_IGNORE, AT_);
  MPI_Waitall(grid().noAzimuthalNeighborDomains(), &mpi_send_req[0], MPI_STATUSES_IGNORE, AT_);

  std::function<MBool(const MInt, const MInt)> neighborCheck = [&](const MInt cellId, const MInt id) {
    return static_cast<MBool>(grid().tree().hasNeighbor(cellId, id));
  };
  std::function<MFloat(const MInt, const MInt)> coordinate = [&](const MInt cellId, const MInt id) {
    return static_cast<MFloat>(c_coordinate(cellId, id));
  };

  offset = 0;
  MFloat eps = F1 + pow(10, -12);
  MInt interpolationCells[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MInt j = 0; j < rcvSize[i]; j++) {
      MInt cellId = m_azimuthalMaxLevelWindowCells[i][(MInt)rcvBuffers[(offset + j) * (nDim + 1)]];
      for(MInt d = 0; d < nDim; d++) {
        corner[d] = rcvBuffers[(offset + j) * (nDim + 1) + 1 + d];
      }
      if(!this->inCell(cellId, corner, eps)) {
        MInt counter = grid().getAdjacentGridCells(cellId, 1, nghbrList, a_level(cellId), 2);
        for(MInt n = 0; n < counter; n++) {
          MInt nghbrId = nghbrList[n];
          if(this->inCell(nghbrId, corner, eps)) {
            cellId = nghbrId;
            break;
          }
        }
      }
      ASSERT(this->inCell(cellId, corner, eps), "Coordindate not in cell!");
      MInt position = -1;
      position = this->setUpInterpolationStencil(cellId, interpolationCells, corner, neighborCheck, false);
      for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
        if(position > -1) {
          MFloat phi = interpolateLevelSet(interpolationCells, corner, set);
          sndBuffers[(offset + j) * m_noLevelSetsUsedForMb + set] = phi;
        } else {
          sndBuffers[(offset + j) * m_noLevelSetsUsedForMb + set] = a_levelSetValuesMb(cellId, set);
        }
      }
    }
    offset += rcvSize[i];
  }

  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    mpi_send_req[i] = MPI_REQUEST_NULL;
    mpi_recv_req[i] = MPI_REQUEST_NULL;
  }


  offset = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    if(sndSize[i] > 0) {
      MInt bufSize = m_noLevelSetsUsedForMb * sndSize[i];
      MPI_Irecv(&rcvBuffers[offset], bufSize, MPI_DOUBLE, grid().azimuthalNeighborDomain(i), 2, grid().mpiComm(),
                &mpi_recv_req[i], AT_, "rcvBuffers[offset]");
      offset += bufSize;
    }
  }

  offset = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    if(rcvSize[i] > 0) {
      MInt bufSize = m_noLevelSetsUsedForMb * rcvSize[i];
      MPI_Isend(&sndBuffers[offset], bufSize, MPI_DOUBLE, grid().azimuthalNeighborDomain(i), 2, grid().mpiComm(),
                &mpi_send_req[i], AT_, "sndBuffers[offset]");
      offset += bufSize;
    }
  }

  MPI_Waitall(grid().noAzimuthalNeighborDomains(), &mpi_recv_req[0], MPI_STATUSES_IGNORE, AT_);
  MPI_Waitall(grid().noAzimuthalNeighborDomains(), &mpi_send_req[0], MPI_STATUSES_IGNORE, AT_);

  for(MInt i = 0; i < notGradientCntr; i++) {
    MInt cellId = notGradientCells[i];
    MInt cndId = candidateIds[cellId];
    for(MInt node = 0; node < m_noCorners; node++) {
      if(notGradientCorners[i * m_noCorners + node] < 0) continue;
      offset = notGradientCorners[i * m_noCorners + node];
      for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
        candidates[cndId].nodalValues[set][node] = rcvBuffers[offset * m_noLevelSetsUsedForMb + set];
      }
    }
  }
}


template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::initPointParticleProperties() {
  cerr0 << "initialize " << m_noPointParticles << " point particles." << endl;

  MIntScratchSpace particleCheck(m_noPointParticles, AT_, "particleCheck");
  MFloat diameter = F1;
  MFloat beta = F1;
  /*! \page propertiesFVMB
    \section pointParticleDiameter
    <code>MFloat FvMbCartesianSolverXD::initPointParticleProperties::diameter</code>\n
    default = <code>F1</code>\n
    Diameter of a point particle. \n
    Possible values are:
    <ul>
      <li>Floating point number > 0.0</li>
    </ul>
    Keywords: <i>FINITE VOLUME, MOVING BOUNDARY, PARTICLE</i>
  */
  diameter = Context::getSolverProperty<MFloat>("pointParticleDiameter", m_solverId, AT_);
  if(m_pointParticleType == 3) {
    /*! \page propertiesFVMB
      \section pointParticleAspectRatio
      <code>MFloat FvMbCartesianSolverXD::initPointParticleProperties::beta</code>\n
      default = <code>F1</code>\n
      Aspect ratio of a point particle. \n
      Possible values are:
      <ul>
      <li>Floating point number > 0.0</li>
      </ul>
      Keywords: <i>FINITE VOLUME, MOVING BOUNDARY, PARTICLE</i>
    */
    beta = Context::getSolverProperty<MFloat>("pointParticleAspectRatio", m_solverId, AT_);
  }
  /*! \page propertiesFVMB
  \section randomDeviceSeed
  <code>int64_t FvMbCartesianSolverXD::seed0</code>\n
  default = <code>-1</code>\n
  Float number used as a seed for a random number generator. \n
  If seed is not set, uses std::random_device() to generate a seed. \n
  Keywords: <i>FINITE VOLUME, MOVING BOUNDARY, PARTICLE, RANDOM NUMBER GENERATOR</i>
*/
  const int64_t seed0 = (int64_t)((Context::propertyExists("randomDeviceSeed", m_solverId))
                                      ? Context::getSolverProperty<MFloat>("randomDeviceSeed", m_solverId, AT_)
                                      : -1);
  const MUlong seed = (MUlong)((seed0 > -1) ? seed0 : std::random_device()());
  MUlong seed1 = seed;
  MPI_Bcast(&seed1, 1, MPI_UNSIGNED_LONG, 0, mpiComm(), AT_, "seed1");
  std::mt19937_64 gen(seed1);
  std::mt19937_64 gen2(seed1);
  // std::mt19937 gen(seed1);
  std::uniform_real_distribution<> distr(-F1B2, F1B2);
  std::uniform_real_distribution<> distr2(F0, F1);
  m_noPointParticlesLocal = 0;
  particleCheck.fill(0);
  unordered_map<MLong, MInt> hilbertToLocal;
  hilbertToLocal.reserve(noMinCells());
  MFloat sr = F0;
  MFloat tt1 = F0;
  MFloat tt2 = F0;
  MFloat coords[3] = {F0, F0, F0};
  for(MInt c = 0; c < noMinCells(); c++) {
    const MInt cellId = minCell(c);
    if(a_isHalo(cellId)) continue;
    MLong hilbertId = grid().raw().generateHilbertIndex(cellId);
    hilbertToLocal[hilbertId] = cellId;
  }
  for(MInt p = 0; p < m_noPointParticles; p++) {
    MBool outside = false;
    sr = distr2(gen2);
    tt1 = F2 * PI * distr2(gen2);
    tt2 = F2 * PI * distr2(gen2);
    for(MInt i = 0; i < nDim; i++) {
      coords[i] = distr(gen) * (m_bbox[nDim + i] - m_bbox[i]);
      if(coords[i] < m_bboxLocal[i] || coords[i] > m_bboxLocal[nDim + i]) outside = true;
    }
    if(outside) continue;
    const MFloat delta = c_cellLengthAtLevel(minLevel());
    MFloat projCords[3] = {F0, F0, F0};
    for(MInt i = 0; i < nDim; i++) {
      MInt div = (MInt)(coords[i] / delta);
      projCords[i] = (div > 0) ? (F1B2 + ((MFloat)div)) * delta : (-F1B2 + ((MFloat)div)) * delta;
    }
    MLong hilbertId = grid().raw().hilbertIndexGeneric(&projCords[0]);
    MInt linkedCell = -1;
    if(hilbertToLocal.count(hilbertId) > 0) {
      MInt cellId = hilbertToLocal[hilbertId];
      const MFloat cellHalfLength = F1B2 * c_cellLengthAtCell(cellId);
      MBool found = true;
      for(MInt i = 0; i < nDim; i++) {
        if((coords[i] < a_coordinate(cellId, i) - cellHalfLength)
           || (coords[i] > a_coordinate(cellId, i) + cellHalfLength)) {
          found = false;
        }
      }
      if(found) {
        linkedCell = cellId;
      }
    }
    if(linkedCell < 0) {
      for(MInt c = 0; c < noMinCells(); c++) {
        const MInt cellId = minCell(c);
        if(a_isHalo(cellId)) continue;
        const MFloat cellHalfLength = F1B2 * c_cellLengthAtCell(cellId);
        MBool found = true;
        for(MInt i = 0; i < nDim; i++) {
          if((coords[i] < a_coordinate(cellId, i) - cellHalfLength)
             || (coords[i] > a_coordinate(cellId, i) + cellHalfLength)) {
            found = false;
          }
        }
        if(found) {
          linkedCell = cellId;
          break;
        }
      }
    }
    if(linkedCell > -1) {
      for(MInt i = 0; i < 3; i++)
        m_particleCoords.push_back(coords[i]);
      for(MInt i = 0; i < 3; i++)
        m_particleVelocity.push_back(F0);
      for(MInt i = 0; i < 3; i++)
        m_particleVelocityFluid.push_back(F0);
      m_particleTemperature.push_back(F0);
      m_particleFluidTemperature.push_back(F0);
      m_particleHeatFlux.push_back(F0);
      for(MInt i = 0; i < 3; i++)
        m_particleAcceleration.push_back(F0);
      for(MInt i = 0; i < 3; i++)
        m_particleAngularVelocity.push_back(F0);
      for(MInt i = 0; i < 3; i++)
        m_particleAngularAcceleration.push_back(F0);
      for(MInt i = 0; i < 9; i++)
        m_particleVelocityGradientFluid.push_back(F0);

      // use this for a truly uniform distribution!!!!!!!!!!!!!!!
      MFloat ew = cos(tt2) * sqrt(sr);
      MFloat ex = sin(tt1) * sqrt(F1 - sr);
      MFloat ey = cos(tt1) * sqrt(F1 - sr);
      MFloat ez = sin(tt2) * sqrt(sr);

      m_particleQuaternions.push_back(ew / sqrt(ew * ew + ex * ex + ey * ey + ez * ez));
      m_particleQuaternions.push_back(ex / sqrt(ew * ew + ex * ex + ey * ey + ez * ez));
      m_particleQuaternions.push_back(ey / sqrt(ew * ew + ex * ex + ey * ey + ez * ez));
      m_particleQuaternions.push_back(ez / sqrt(ew * ew + ex * ex + ey * ey + ez * ez));

      if(m_pointParticleType == 1) {
        for(MInt i = 0; i < 3; i++)
          m_particleRadii.push_back(F1B2 * diameter);
        for(MInt i = 0; i < 4; i++)
          m_particleShapeParams.push_back(F0);
      } else if(m_pointParticleType == 3) {
        MFloat a = F1B2 * diameter * pow(beta, -F1B3);
        MFloat beta2 = POW2(beta);
        m_particleRadii.push_back(a);
        m_particleRadii.push_back(a);
        m_particleRadii.push_back(beta * a);
        if(fabs(beta - F1) < 1e-14) {
          m_particleShapeParams.push_back(F2 * POW2(a));
          m_particleShapeParams.push_back(F2B3);
          m_particleShapeParams.push_back(F2B3);
          m_particleShapeParams.push_back(F2B3);
        } else if(beta < F0) {
          // general triaxial ellipsoid
        } else if(beta > F1) {
          MFloat kappa = log((beta - sqrt(beta2 - F1)) / (beta + sqrt(beta2 - F1)));
          m_particleShapeParams.push_back(-beta * POW2(a) * kappa / sqrt(beta2 - F1));
          m_particleShapeParams.push_back(beta2 / (beta2 - F1) + beta * kappa / (F2 * pow(beta2 - F1, F3B2)));
          m_particleShapeParams.push_back(beta2 / (beta2 - F1) + beta * kappa / (F2 * pow(beta2 - F1, F3B2)));
          m_particleShapeParams.push_back(-F2 / (beta2 - F1) - beta * kappa / (pow(beta2 - F1, F3B2)));
        } else if(beta < F1) {
          // MFloat kappa = F2*atan( beta/sqrt(F1-beta2) );
          MFloat kappa = F2 * atan2(beta, sqrt(F1 - beta2));
          m_particleShapeParams.push_back(beta * POW2(a) * (PI - kappa) / sqrt(F1 - beta2));
          m_particleShapeParams.push_back(-beta * (kappa - PI + F2 * beta * sqrt(F1 - beta2))
                                          / (F2 * pow(F1 - beta2, F3B2)));
          m_particleShapeParams.push_back(-beta * (kappa - PI + F2 * beta * sqrt(F1 - beta2))
                                          / (F2 * pow(F1 - beta2, F3B2)));
          m_particleShapeParams.push_back((beta * kappa - beta * PI + F2 * sqrt(F1 - beta2)) / (pow(F1 - beta2, F3B2)));
        }
        if(domainId() == 0 && m_noPointParticlesLocal == 0) {
          cerr << "ellipsoid: " << diameter << " " << beta << " / " << a << " " << a << " " << beta * a << " ("
               << pow(a * a * a * beta, F1B3) << ")" << endl;
          MFloat tst0 = F0;
          MFloat tst1 = F0;
          MFloat tst2 = F0;
          MFloat tst3 = F0;
          MFloat dlt = F1;
          const MFloat dx = 1e-6;
          const MFloat b = a;
          const MFloat c = beta * a;
          MFloat x = F1B2 * dx;
          while(fabs(dlt) > 1e-8) {
            dlt = a * b * c / sqrt((a * a + x) * (b * b + x) * (c * c + x));
            tst0 += dx * dlt;
            tst1 += dx * dlt / (a * a + x);
            tst2 += dx * dlt / (b * b + x);
            tst3 += dx * dlt / (c * c + x);
            x += dx;
          }
          cerr << "value 0: " << tst0 << " " << m_particleShapeParams[0] << endl;
          cerr << "value 1: " << tst1 << " " << m_particleShapeParams[1] << endl;
          cerr << "value 2: " << tst2 << " " << m_particleShapeParams[2] << endl;
          cerr << "value 3: " << tst3 << " " << m_particleShapeParams[3] << endl;
        }
      } else {
        mTerm(1, AT_, "point particle type");
      }
      m_particleCellLink.push_back(linkedCell);
      particleCheck(p)++;
      m_noPointParticlesLocal++;
      m_particleGlobalId.push_back(p);
    }
  }
  MPI_Allreduce(MPI_IN_PLACE, &(particleCheck[0]), m_noPointParticles, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "(particleCheck[0])");
  if(domainId() == 0) {
    for(MInt p = 0; p < m_noPointParticles; p++) {
      if(particleCheck[p] != 1)
        mTerm(1, AT_, "Point particle init failed " + to_string(p) + " " + to_string(particleCheck[p]));
    }
  }
  m_particleCoordsDt1 = m_particleCoords;
  m_particleVelocityDt1 = m_particleVelocity;
  m_particleTemperatureDt1 = m_particleTemperature;
  m_particleAccelerationDt1 = m_particleAcceleration;
  m_particleQuaternionsDt1 = m_particleQuaternions;
  m_particleAngularVelocityDt1 = m_particleAngularVelocity;
  m_particleAngularAccelerationDt1 = m_particleAngularAcceleration;
  for(MUint p = 0; p < m_particleCellLink.size(); p++) {
    MInt cellId = m_particleCellLink[p];
    while(c_noChildren(cellId) > 0) {
      MInt child = 0;
      for(MUint i = 0; i < nDim; i++) {
        if(m_particleCoords[nDim * p + i] > a_coordinate(cellId, i)) child += IPOW2(i);
      }
      cellId = c_childId(cellId, child);
      if(cellId < 0 || cellId >= a_noCells()) mTerm(1, AT_, "Point particle linking failed.");
    }
    m_particleCellLink[p] = cellId;
  }
}


/**
 * \fn void FvMbCartesianSolverXD<nDim, SysEqn>::initBodyProperties()
 * \brief initialize properties of the embedded body at startup
 * \author Lennart Schneiders
 * \note extended to multiple bodies (Lennart Schneiders)
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::initBodyProperties() {
  TRACE();

  cerr0 << "Init body properties...";

  if(m_noEmbeddedBodies == 0) {
    cerr0 << " m_noEmbeddedBodies = 0. Body properties will not be initialized." << endl;
    if(m_noPointParticles > 0 && noMinCells() > 0) {
      initPointParticleProperties();
    }
    return;
  }

  if(m_constructGField) updateInfinityVariables();

  /*! \page propertiesFVMB
    \section bodyTemperatureRatio
    <code>MInt FvMbCartesianSolverXD</code>\n
    default = <code>1</code>\n \n
    Sets the body temperature of the embedded body based on m_TInfinity.
    Possible values are:
    <ul>
      <li>Any positive float value.</li>
    </ul>
    Keywords: <i>MOVING BOUNDARY, TEMPERATURE</i>
  */
  MFloat bodyTemperatureRatio = 1;
  bodyTemperatureRatio =
      Context::getSolverProperty<MFloat>("bodyTemperatureRatio", m_solverId, AT_, &bodyTemperatureRatio);

  for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
    for(MInt i = 0; i < nDim; i++) {
      m_bodyCenter[k * nDim + i] = F0;
      m_bodyVelocity[k * nDim + i] = F0;
      m_bodyForce[k * nDim + i] = F0;
      m_bodyAcceleration[k * nDim + i] = F0;
      if(m_motionEquation > 1) {
        m_bodyNeutralCenter[k * nDim + i] = F0;
      }
    }
    for(MInt i = 0; i < 3; i++) {
      m_bodyAngularVelocity[k * 3 + i] = F0;
      m_bodyAngularAcceleration[k * 3 + i] = F0;
      m_bodyTorque[k * 3 + i] = F0;
    }
    for(MInt i = 0; i < 4; i++) {
      m_bodyQuaternion[k * 4 + i] = F0;
    }
    m_bodyTemperature[k] = bodyTemperatureRatio * m_TInfinity;
    m_bodyTemperatureDt1[k] = bodyTemperatureRatio * m_TInfinity;
    if(m_motionEquation > 1) {
      m_bodyReducedVelocity[k] = 9.0;
      m_bodyReducedFrequency[k] = m_Ma / m_bodyReducedVelocity[k];
      m_bodyReducedMass[k] = F2;
      m_bodyDampingCoefficient[k] = F0;
    }
    m_bodyInCollision[k] = 0;
  }

  m_log << "Inititial body temperature of body 0 " << m_bodyTemperature[0] << endl;
  if(Context::propertyExists("bodyTemperatureRatio", m_solverId) && m_motionEquation == 0 && domainId() == 0) {
    cerr << "Warning: Body temperature will not be updated" << endl;
  }

  // bndryCnd-velocity should resemble body-velocity!
  if(m_motionEquation == 0 && !m_constructGField && m_LsMovement) {
    for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
      m_bodyEquation[k] = 4520;
    }
  } else if(m_motionEquation == 0) {
    for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
      m_bodyEquation[k] = m_initialCondition;
    }
  }

  m_U2 = F0;
  for(MInt i = 0; i < nDim; i++) {
    m_U2 += POW2(m_VVInfinity[i]);
  }
  m_rhoU2 = m_U2 * m_rhoInfinity;

  /*! \page propertiesFVMB
    \section fixedBodyComponents
    <code>MInt fvmbcartesiansolverxd::*m_fixedBodyComponents</code>\n
    default = <code>0.0</code>\n \n
    decide  in which direction the body motion is fixed(restricted)
    Possible values are:
    <ul>
      <li> 1 or 0 </li>
    </ul>
    Keywords: <i>moving</i>
  */
  for(MInt i = 0; i < nDim; i++) {
    m_fixedBodyComponents[i] = 0;
  }
  for(MInt i = 0; i < nDim; i++) {
    m_fixedBodyComponents[i] =
        Context::getSolverProperty<MInt>("fixedBodyComponents", m_solverId, AT_, &m_fixedBodyComponents[i], i);
  }
  /*! \page propertiesFVMB
      \section fixedBodyComponentsRotation
      <code>MInt fvmbcartesiansolverxd::*m_fixedBodyComponentsRotation</code>\n
      default = <code>0.0</code>\n \n
      decide  in which direction the body rotation is fixed(restricted)
      Possible values are:
      <ul>
        <li> 1 or 0 </li>
      </ul>
      Keywords: <i>moving</i>
    */
  for(MInt i = 0; i < 3; i++) {
    m_fixedBodyComponentsRotation[i] = Context::getSolverProperty<MInt>("fixedBodyComponentsRotation", m_solverId, AT_,
                                                                        &m_fixedBodyComponentsRotation[i], i);
  }

  if(m_motionEquation > 1 && m_noEmbeddedBodies > 0) {
    /*! \page propertiesFVMB
      \section reducedMass
      <code>MFloat reducedMass</code>\n
      Ratio between the mass of the solid $$m_s$$
      and the mass of the fluid $$m_{f,0}$ that would
      otherwise occupy the solid volume in
      stagnation conditions: $$m_{red} = m_s / m_{f, 0}$$.
      default = <code>0</code>\n \n
      Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, BODY_MOTION</i>
    */
    MFloat reducedMass = Context::getSolverProperty<MFloat>("reducedMass", m_solverId, AT_, &m_bodyReducedMass[0]);
    MFloat dampCoeff =
        Context::getSolverProperty<MFloat>("dampingCoefficient", m_solverId, AT_, &m_bodyDampingCoefficient[0]);
    for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
      m_bodyReducedMass[k] = reducedMass;
      m_bodyDampingCoefficient[k] = dampCoeff;
      if(Context::propertyExists("reducedVelocity", m_solverId)) {
        m_bodyReducedVelocity[k] =
            Context::getSolverProperty<MFloat>("reducedVelocity", m_solverId, AT_, &m_bodyReducedVelocity[0]);
        m_bodyReducedFrequency[k] = m_Ma / m_bodyReducedVelocity[k];
      }
      if(fabs(m_bodyReducedVelocity[k]) < m_eps) {
        mTerm(1, AT_, "Division by zero in FvMbCartesianSolverXD::initBodyProperties(). Quit.");
      }
    }
  }

  /*! \page propertiesFVMB
    \section bodyRadius
    <code>MFloat FvMbCartesianSolverXD::m_bodyRadius </code>\n
    default = <code>None</code>\n \n
    Sets the radius of all moving bodies to the same value \n
    Possible values are:
    <ul>
    <li>Single positive floating-point numbers greater than zero</li>
    </ul>
    Keywords: <i>MOVING BOUNDARY, BODY PARAMETERS</i>
  */
  MFloat bodyRadius = F1B2;
  bodyRadius = Context::getSolverProperty<MFloat>("bodyRadius", m_solverId, AT_, &bodyRadius);
  for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
    m_bodyRadius[k] = bodyRadius;
    m_bodyDiameter[k] = F2 * bodyRadius;
  }

  /*! \page propertiesFVMB
    \section bodyDiameters
    <code>MFloat FvMbCartesianSolverXD::m_bodyDiameter </code>\n
    default = <code>None</code>\n \n
    Sets the diameter of each moving body \n
    Possible values are:
    <ul>
    <li>Positive floating-point numbers greater than zero - one number per body</li>
    </ul>
    Keywords: <i>MOVING BOUNDARY, BODY PARAMETERS</i>
  */
  if(Context::propertyExists("bodyDiameters", m_solverId)) {
    if(Context::propertyLength("bodyDiameters", m_solverId) == m_noEmbeddedBodies) {
      for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
        m_bodyDiameter[k] = Context::getSolverProperty<MFloat>("bodyDiameters", m_solverId, AT_, k);
        m_bodyRadius[k] = F1B2 * m_bodyDiameter[k];
      }
    } else
      mTerm(1, AT_, "bodyDiameters wrong dimension " + to_string(m_noEmbeddedBodies));
  }

  /*! \page propertiesFVMB
     \section bodyRadii
     <code>MFloat FvMbPar::m_bodyRadii </code>\n
     default = <code>""</code>\n \n
     Defines the three radii for an elliptical body implemented in the analytical levelset.
     Only necessary if elliptical bodies are used in that sense.
     <ul>
     <li>any positive float </li>
     </ul>
     Keywords: <i>LEVELSET, ANALYTICAL, G0, </i>
   */

  if(m_noEmbeddedBodies > 0) {
    if(m_bodyTypeMb == 3) {
      if(Context::propertyLength("bodyRadii", m_solverId) == 3) {
        for(MInt i = 0; i < 3; i++) {
          m_bodyRadii[i] = Context::getSolverProperty<MFloat>("bodyRadii", m_solverId, AT_, i);
        }
        for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
          for(MInt i = 0; i < 3; i++) {
            m_bodyRadii[k * 3 + i] = m_bodyRadii[i];
          }
        }
      } else {
        for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
          for(MInt i = 0; i < 3; i++) {
            m_bodyRadii[k * 3 + i] = Context::getSolverProperty<MFloat>("bodyRadii", m_solverId, AT_, k * 3 + i);
          }
        }
      }
      for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
        m_bodyRadius[k] = F0;
        for(MInt i = 0; i < 3; i++) {
          //        m_bodyRadius[ k ] = mMax( m_bodyRadius[ k ], m_bodyRadii[ k*3+i ] );
        }
        m_bodyRadius[k] = pow(m_bodyRadii[k * 3 + 0] * m_bodyRadii[k * 3 + 1] * m_bodyRadii[k * 3 + 2], F1B3);
        m_bodyDiameter[k] = F2 * m_bodyRadius[k];
      }
    } else {
      for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
        for(MInt i = 0; i < 3; i++) {
          m_bodyRadii[k * 3 + i] = m_bodyRadius[k];
        }
      }
    }
  }


  if(m_motionEquation > 1) {
    for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
      m_bodyReducedVelocity[k] *= m_bodyDiameter[k];
      m_bodyReducedFrequency[k] /= m_bodyDiameter[k];
      for(MInt i = 0; i < nDim; i++) {
        m_bodyReducedMass[k] *= m_bodyDiameter[k];
      }
    }
  }

  /*! \page propertiesFVMB
\section densityRatio
<code>MFloat FvMbSolver::m_desitiyRatio </code>\n
default = <code> 1.0 </code>\n
Sets the density of a moving body based on m_rhoInfinity.
Possible values are:
<ul>
<li> Any positive float value</li>
</ul>
Keywords: <i>FINITE_VOLUME, MOVING BOUNDARY, DENSITY</i>
*/
  m_densityRatio = F1;
  m_densityRatio = Context::getSolverProperty<MFloat>("densityRatio", m_solverId, AT_, &m_densityRatio);
  m_log << "density ratio: " << m_densityRatio << endl;


  /*! \page propertiesFVMB
 \section capacityConstantVolumeRatio
 <code>MFloat FvMbSolver::m_capacityConstantVolumeRatio </code>\n
 default = <code> no default </code>\n
 Heat capacity at constant volume Cv_particle/Cv_fluid
 Keywords: <i>FINITE_VOLUME, HEAT_CAPACITY </i>
 */
  m_capacityConstantVolumeRatio =
      (Context::propertyExists("capacityConstantVolumeRatio", m_solverId))
          ? Context::getSolverProperty<MFloat>("capacityConstantVolumeRatio", m_solverId, AT_)
          : F1;

  if(domainId() == 0) {
    m_log << "Heat capacity at constant volume Cv_particle/Cv_fluid: " << m_capacityConstantVolumeRatio << endl;
  }

  for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
    m_bodyDensity[k] = m_densityRatio * m_rhoInfinity;
    m_bodyVolume[k] = F4B3 * PI;
    m_projectedArea[k] = PI;
    MFloat tmp = F0;
    for(MInt i = 0; i < nDim; i++) {
      m_bodyVolume[k] *= m_bodyRadii[k * nDim + i];
      m_projectedArea[k] *= m_bodyRadii[k * nDim + i];
      tmp += m_bodyRadii[k * nDim + i] * fabs(m_VVInfinity[i]) / sqrt(m_U2);
    }
    m_projectedArea[k] /= tmp;
    m_bodyMass[k] = m_bodyDensity[k] * m_bodyVolume[k];
  }


  IF_CONSTEXPR(nDim == 2) {
    m_addedMassCoefficient = F1;
    for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
      m_projectedArea[k] = F2 * m_bodyRadius[k];
    }
  }
  IF_CONSTEXPR(nDim == 3) {
    MFloat F2B5 = 2.0 / 5.0;
    if(m_bodyTypeMb == 1) {
      for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
        for(MInt i = 0; i < 3; i++) {
          m_bodyMomentOfInertia[3 * k + i] = F2B5 * m_bodyMass[k] * POW2(m_bodyRadius[k]);
        }
      }
    } else if(m_bodyTypeMb == 3) {
      for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
        const MFloat a = m_bodyRadii[k * nDim + 0];
        const MFloat b = m_bodyRadii[k * nDim + 1];
        const MFloat c = m_bodyRadii[k * nDim + 2];
        m_bodyMomentOfInertia[3 * k + 0] = (4.0 / 15.0) * (b * b + c * c) * PI * m_bodyDensity[k] * a * b * c;
        m_bodyMomentOfInertia[3 * k + 1] = (4.0 / 15.0) * (a * a + c * c) * PI * m_bodyDensity[k] * a * b * c;
        m_bodyMomentOfInertia[3 * k + 2] = (4.0 / 15.0) * (a * a + b * b) * PI * m_bodyDensity[k] * a * b * c;
      }
    }
    m_addedMassCoefficient = F1B2;
  }

  if(m_noEmbeddedBodies > 1 || m_initialCondition == 471) {
    MFloat VVInf = F0;
    for(MInt i = 0; i < nDim; i++) {
      VVInf += POW2(m_VVInfinity[i]);
    }
    VVInf = sqrt(VVInf);
    for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
      m_bodyDensity[k] = m_densityRatio * m_rhoInfinity;
      m_bodyVolume[k] = F4B3 * PI;
      m_projectedArea[k] = PI;
      MFloat tmp = F0;
      for(MInt i = 0; i < nDim; i++) {
        m_bodyVolume[k] *= m_bodyRadii[k * nDim + i];
        m_projectedArea[k] *= m_bodyRadii[k * nDim + i];
        tmp += m_bodyRadii[k * nDim + i] * fabs(m_VVInfinity[i]) / VVInf;
      }
      m_projectedArea[k] /= tmp;
      m_bodyMass[k] = m_bodyDensity[k] * m_bodyVolume[k];
    }

    if(m_initialCondition == 471) {
      // m_g = F3B4*POW2(m_Ma)*m_TInfinity*26.7644/m_densityRatio;
      m_g = F3B4 * CdLaw(m_Re) * POW2(m_Ma) / (m_referenceLength * m_densityRatio);
      m_log << "g=" << m_g << ", Fr=" << m_Ma / sqrt(m_g) << endl;
    }
  }

  m_minBodyRadius = numeric_limits<MFloat>::max();
  m_maxBodyRadius = F0;
  for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
    m_maxBodyRadius = mMax(m_maxBodyRadius, m_bodyRadius[k]);
    m_minBodyRadius = mMin(m_minBodyRadius, m_bodyRadius[k]);
    for(MInt i = 0; i < 3; i++) {
      m_maxBodyRadius = mMax(m_maxBodyRadius, m_bodyRadii[k * 3 + i]);
      m_minBodyRadius = mMin(m_minBodyRadius, m_bodyRadii[k * 3 + i]);
    }
  }

  if(!m_restart) {
    MFloat VVInf = F0;
    for(MInt i = 0; i < nDim; i++) {
      VVInf += POW2(m_VVInfinity[i]);
    }
    VVInf = sqrt(VVInf);

    if(m_initialCondition != 45299 && m_initialCondition != 45300 && m_initialCondition != 45301
       && m_initialCondition != 45302 && m_initialCondition != 4520
       && (m_noEmbeddedBodies > 1 || m_initialCondition == 471)) {
      for(MInt i = 0; i < nDim; i++) {
        m_bodyVelocity[i] = F0;

        /*! \page propertiesFVMB
          \section initialBodyVelocity
          <code>MFloat Lssolver::m_bodyVelocity</code>\n
          default = <code>0.0</code>\n \n
          This property defines the components of the intial velocity vector of a moving object.
          Possible values are:
          <ul>
          <li>Any float values</li>
          </ul>
          Keywords: <i> FINITE-VOLUME, MOVING BOUNDARY</i>
        */
        if(Context::propertyExists("initialBodyVelocity", m_solverId)) {
          m_bodyVelocity[i] = Context::getSolverProperty<MFloat>("initialBodyVelocity", m_solverId, AT_, i);
        }
      }
      for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
        if(Context::propertyExists("initialBodyVelocity", m_solverId)) {
          for(MInt i = 0; i < nDim; i++) {
            m_bodyVelocity[k * nDim + i] = m_bodyVelocity[i];
          }
          for(MInt i = 0; i < nDim; i++) {
            m_bodyVelocity[k * nDim + i] *= m_UInfinity;
          }
        }

        /*! \page propertiesFVMB
          \section xBodyCenter
          <code>MFloat m_bodyCenter</code>\n
          default = <code>0</code>\n \n
          Initial value of the x-component of the center of mass of each body. That is,
          for N bodies this is an N-element array.
          Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, INITIAL_CONDITION</i>
        */

        /*! \page propertiesFVMB
          \section yBodyCenter
          <code>MFloat m_bodyCenter</code>\n
          default = <code>0</code>\n \n
          Initial value of the y-component of the center of mass of each body. That is,
          for N bodies this is an N-element array.
          Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, INITIAL_CONDITION</i>
        */

        /*! \page propertiesFVMB
          \section zBodyCenter
          <code>MFloat m_bodyCenter</code>\n
          default = <code>0</code>\n \n
          Initial value of the z-component of the center of mass of each body. That is,
          for N bodies this is an N-element array.
          Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, INITIAL_CONDITION</i>
        */

        /*! \page propertiesFVMB
          \section xBodyVelocity
          <code>MFloat m_bodyVelocity</code>\n
          default = <code>0</code>\n \n
          Initial value of the x-component of the velocity of each body. That is,
          for N bodies this is an N-element array.
          Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, INITIAL_CONDITION</i>
        */

        /*! \page propertiesFVMB
          \section yBodyVelocity
          <code>MFloat m_bodyVelocity</code>\n
          default = <code>0</code>\n \n
          Initial value of the y-component of the velocity of each body. That is,
          for N bodies this is an N-element array.
          Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, INITIAL_CONDITION</i>
        */

        /*! \page propertiesFVMB
          \section zBodyVelocity
          <code>MFloat m_bodyVelocity</code>\n
          default = <code>0</code>\n \n
          Initial value of the z-component of the velocity of each body. That is,
          for N bodies this is an N-element array.
          Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, INITIAL_CONDITION</i>
        */

        /*! \page propertiesFVMB
         \section xBodyNeutralCenter
         <code>MFloat m_bodyNeutralCenter</code>\n
         default = <code>0</code>\n \n
         x-Coordinate of the neutral position for elastically mounted bodies
         Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, INITIAL_CONDITION</i>
       */

        /*! \page propertiesFVMB
          \section yBodyNeutralCenter
          <code>MFloat m_bodyNeutralCenter</code>\n
          default = <code>0</code>\n \n
          y-Coordinate of the neutral position for elastically mounted bodies
          Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, INITIAL_CONDITION</i>
        */

        /*! \page propertiesFVMB
            \section zBodyNeutralCenter
            <code>MFloat m_bodyNeutralCenter</code>\n
            default = <code>0</code>\n \n
            z-Coordinate of the neutral position for elastically mounted bodies
            Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, INITIAL_CONDITION</i>
          */


        if(!Context::propertyExists("xBodyCenter", m_solverId)) continue;

        m_bodyCenter[k * nDim] = Context::getSolverProperty<MFloat>("xBodyCenter", m_solverId, AT_, k);
        m_bodyCenter[k * nDim + 1] = Context::getSolverProperty<MFloat>("yBodyCenter", m_solverId, AT_, k);
        if(Context::propertyExists("xBodyVelocity", m_solverId))
          m_bodyVelocity[k * nDim] = Context::getSolverProperty<MFloat>("xBodyVelocity", m_solverId, AT_, k) * VVInf;
        if(Context::propertyExists("yBodyVelocity", m_solverId))
          m_bodyVelocity[k * nDim + 1] =
              Context::getSolverProperty<MFloat>("yBodyVelocity", m_solverId, AT_, k) * VVInf;
        if(m_initialCondition == 450) {
          if(m_motionEquation > 1) {
            if(m_restart) cerr << "consider" << endl;
            m_bodyNeutralCenter[k * nDim] =
                Context::getSolverProperty<MFloat>("xBodyNeutralCenter", m_solverId, AT_, k);
            m_bodyNeutralCenter[k * nDim + 1] =
                Context::getSolverProperty<MFloat>("yBodyNeutralCenter", m_solverId, AT_, k);
          }
        }
        IF_CONSTEXPR(nDim == 3) {
          m_bodyCenter[k * nDim + 2] = Context::getSolverProperty<MFloat>("zBodyCenter", m_solverId, AT_, k);
          if(Context::propertyExists("zBodyVelocity", m_solverId))
            m_bodyVelocity[k * nDim + 2] =
                Context::getSolverProperty<MFloat>("zBodyVelocity", m_solverId, AT_, k) * VVInf;
          if(m_initialCondition == 450) {
            if(m_motionEquation > 1) {
              if(m_restart) cerr << "consider" << endl;
              m_bodyNeutralCenter[k * nDim + 2] =
                  Context::getSolverProperty<MFloat>("zBodyNeutralCenter", m_solverId, AT_, k);
            }
          }
        }
        if(m_initialCondition == 450) {
          if(m_motionEquation > 1) {
            if(Context::propertyExists("bodyReducedVelocity", m_solverId)) {
              m_bodyReducedVelocity[k] = Context::getSolverProperty<MFloat>("bodyReducedVelocity", m_solverId, AT_, k);
              m_bodyReducedFrequency[k] = m_Ma / m_bodyReducedVelocity[k];
            }
          }
        }
      }
    } else {
      /*! \page propertiesFVMB
      \section initialBodyCenter
      <code>MFloat Lssolver::initialBodyCenter </code>\n
      default = <code>no default value</code>\n \n
      The property is intial position of moving object, reads in during initialization or restart.
      possible values are:
      <ul>
      <li> Any float value</li>
      </ul>
      Keywords: <i> moving boundaries  </i>
      */
      if(m_noEmbeddedBodies > 0) {
        if(Context::propertyExists("initialBodyCenter", m_solverId)) {
          for(MInt i = 0; i < nDim; i++) {
            m_bodyCenter[i] =
                Context::getSolverProperty<MFloat>("initialBodyCenter", m_solverId, AT_, i) * m_bodyDiameter[0];
          }
        }
        if(Context::propertyExists("initialBodyVelocity", m_solverId)) {
          for(MInt i = 0; i < nDim; i++) {
            m_bodyVelocity[i] = Context::getSolverProperty<MFloat>("initialBodyVelocity", m_solverId, AT_, i);
          }
          for(MInt i = 0; i < nDim; i++) {
            m_bodyVelocity[i] *= m_UInfinity;
          }
        }
      }
    }

    // reset intial orientation, different initial values below
    for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
      m_bodyQuaternion[k * 4 + 0] = F1;
      m_bodyQuaternion[k * 4 + 1] = F0;
      m_bodyQuaternion[k * 4 + 2] = F0;
      m_bodyQuaternion[k * 4 + 3] = F0;
    }

    if((m_initialCondition == 15 || m_initialCondition == 16) && m_noEmbeddedBodies > 0) {
      MString fileName = "out/bodyData_init.Netcdf";
      MBool foundFile = false;
      cerr0 << endl;
      if(!m_restart && ParallelIo::fileExists(fileName, mpiComm())) {
        cerr0 << "Loading initial body distribution from file " << fileName << endl;
        using namespace maia::parallel_io;
        ParallelIo parallelIo(fileName, PIO_READ, mpiComm());

        ParallelIo::size_type start = 0;
        ParallelIo::size_type count = 0;

        const MLong DOF = m_noEmbeddedBodies;
        const MLong DOF_TRANS = nDim * m_noEmbeddedBodies;
        const MLong DOF_ROT = 3 * m_noEmbeddedBodies;
        const MLong DOF_QUAT = 4 * m_noEmbeddedBodies;
        MInt noBodies = -1;
        MFloat radii[3];
        parallelIo.getAttribute(&noBodies, "noBodies");
        parallelIo.getAttribute(radii, "bodyRadii", 3);

        foundFile = true;
        if(noBodies < DOF) {
          foundFile = false;
          cerr0 << "Not enough embedded bodies in file " << fileName << endl;
        }
        if(fabs(m_bodyRadii[0] - radii[0]) > 1e-12 || fabs(m_bodyRadii[1] - radii[1]) > 1e-12
           || fabs(m_bodyRadii[2] - radii[2]) > 1e-12) {
          foundFile = false;
          cerr0 << "Body radii mismatch in file " << fileName << endl;
        }
        if(foundFile) {
          count = DOF;
          parallelIo.setOffset(count, start);
          parallelIo.readArray(m_bodyTemperature, "bodyTemperature");

          count = DOF_TRANS;
          parallelIo.setOffset(count, start);
          parallelIo.readArray(m_bodyCenter, "bodyCenter");
          if(parallelIo.hasDataset("bodyVelocity")) {
            parallelIo.readArray(m_bodyVelocity, "bodyVelocity");
          }

          count = DOF_ROT;
          parallelIo.setOffset(count, start);
          if(parallelIo.hasDataset("bodyAngularVelocity")) {
            parallelIo.readArray(m_bodyAngularVelocity, "bodyAngularVelocity");
          }

          count = DOF_QUAT;
          parallelIo.setOffset(count, start);
          parallelIo.readArray(m_bodyQuaternion, "bodyQuaternion");
        }
      }
      if(!foundFile) {
        const MFloat dist0 = 3.0 * c_cellLengthAtLevel(maxRefinementLevel());
        const MFloat dist1 = F2 * m_maxBodyRadius + dist0;
        const MBool storeBodyDistribution =
            (Context::propertyExists("storeBodyDistribution", m_solverId))
                ? Context::getSolverProperty<MBool>("storeBodyDistribution", m_solverId, AT_)
                : 1;

        if(domainId() == 0) {
          /*! \page propertiesFVMB
            \section randomDeviceSeed
            <code>int64_t FvMbCartesianSolverXD::seed0</code>\n
            default = <code>-1</code>\n
            Float number used as a seed for a random number generator. \n
            If seed is not set, uses std::random_device() to generate a seed. \n
            Keywords: <i>FINITE VOLUME, MOVING BOUNDARY, PARTICLE, RANDOM NUMBER GENERATOR</i>
          */
          const int64_t seed0 = (int64_t)((Context::propertyExists("randomDeviceSeed", m_solverId))
                                              ? Context::getSolverProperty<MFloat>("randomDeviceSeed", m_solverId, AT_)
                                              : -1);
          const MUlong seed = (MUlong)((seed0 > -1) ? seed0 : std::random_device()());
          const MUlong seed1 = seed;

          std::mt19937_64 gen(seed);
          std::mt19937_64 gen2(seed1);
          std::mt19937_64 gen3(seed1);

          std::uniform_real_distribution<> distr(-F1B2, F1B2);
          std::uniform_real_distribution<> distr2(F0, F1);
          std::uniform_real_distribution<> distr3(0.25, 1.75);

          for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
            for(MInt i = 0; i < nDim; i++) {
              m_bodyCenter[k * nDim + i] = m_bbox[nDim + i] + 1000000.0 * (m_bbox[nDim + i] - m_bbox[i]);
            }
          }

          MFloatScratchSpace maxRadius(m_noEmbeddedBodies, AT_, "maxRadius");
          MFloat dx[3]{};
          MFloat bboxThreshold[6]{};
          MFloat bboxThreshold2[6]{};
          for(MInt i = 0; i < nDim; i++) {
            dx[i] = m_bbox[nDim + i] - m_bbox[i];
            bboxThreshold[i] = m_bbox[i] + dist1;
            bboxThreshold2[i] = m_bbox[i] - dist1;
            bboxThreshold[nDim + i] = m_bbox[nDim + i] - dist1;
            bboxThreshold2[nDim + i] = m_bbox[nDim + i] + dist1;
          }
          for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
            maxRadius[k] = mMax(m_bodyRadii[k * 3 + 0], mMax(m_bodyRadii[k * 3 + 1], m_bodyRadii[k * 3 + 2]));
          }
          const MInt statFac = (m_noEmbeddedBodies > 100000) ? 100 : ((m_noEmbeddedBodies > 10000) ? 10 : -1);
          const MFloat time0 = MPI_Wtime();
          cerr << "No body distribution file found. Creating new distribution for " << m_noEmbeddedBodies << " bodies."
               << endl;

          for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
            if(statFac > -1
               && (MInt)(k / (m_noEmbeddedBodies / statFac)) < (MInt)((k + 1) / (m_noEmbeddedBodies / statFac))) {
              cerr << "body init completed: " << (MInt)(100 * (k + 1) / (m_noEmbeddedBodies)) << "%" << endl;
            }
            MBool keep = false;
            while(!keep) {
              for(MInt i = 0; i < nDim; i++) {
                m_bodyCenter[k * nDim + i] = distr(gen) * (m_bbox[nDim + i] - m_bbox[i]);
              }
              keep = true;

              for(MInt s = 0; s < 4; s++) {
                distr2(gen2); // throw away some random numbers (for whatever reason required to get uniform
                              // distribution below)
              }

              for(MInt p = 0; p < k; p++) {
                const MFloat dkp = maxRadius[k] + maxRadius[p];
                if(
                    (POW2(m_bodyCenter[k * nDim] - m_bodyCenter[p * nDim])
                     + POW2(m_bodyCenter[k * nDim + 1] - m_bodyCenter[p * nDim + 1])
                     + POW2(m_bodyCenter[k * nDim + 2] - m_bodyCenter[p * nDim + 2]))
                    < POW2(dist0 + dkp)) {
                  keep = false;
                  break;
                }
                if(!keep) break;

                MBool isOutsideThreshold = false;
                IF_CONSTEXPR(nDim == 2) {
                  if(m_bodyCenter[p * nDim] < bboxThreshold[0] || m_bodyCenter[p * nDim] > bboxThreshold[3]
                     || m_bodyCenter[p * nDim + 1] < bboxThreshold[1]
                     || m_bodyCenter[p * nDim + 1] > bboxThreshold[4]) {
                    isOutsideThreshold = true;
                  }
                }
                IF_CONSTEXPR(nDim == 3) {
                  if(m_bodyCenter[p * nDim] < bboxThreshold[0] || m_bodyCenter[p * nDim] > bboxThreshold[3]
                     || m_bodyCenter[p * nDim + 1] < bboxThreshold[1] || m_bodyCenter[p * nDim + 1] > bboxThreshold[4]
                     || m_bodyCenter[p * nDim + 2] < bboxThreshold[2]
                     || m_bodyCenter[p * nDim + 2] > bboxThreshold[5]) {
                    isOutsideThreshold = true;
                  }
                }

                if(isOutsideThreshold) {
                  MFloat coords[3][3]{};
                  for(MInt i = 0; i < nDim; i++) {
                    coords[1][i] = m_bodyCenter[p * nDim + i];
                    coords[0][i] = coords[1][i] - dx[i];
                    coords[2][i] = coords[1][i] + dx[i];
                  }
                  for(MInt s0 = -1; s0 <= 1; s0++) {
                    if(s0 != 0 && !grid().periodicCartesianDir(0)) continue;
                    for(MInt s1 = -1; s1 <= 1; s1++) {
                      if(s1 != 0 && !grid().periodicCartesianDir(1)) continue;
                      for(MInt s2 = -1; s2 <= 1; s2++) {
                        if(s0 == 0 && s1 == 0 && s2 == 0) continue;
                        if(s2 != 0 && !grid().periodicCartesianDir(2)) continue;

                        if(coords[1 + s0][0] < bboxThreshold2[0] || coords[1 + s0][0] > bboxThreshold2[3]) continue;
                        if(coords[1 + s1][1] < bboxThreshold2[1] || coords[1 + s1][1] > bboxThreshold2[4]) continue;
                        if(coords[1 + s2][2] < bboxThreshold2[2] || coords[1 + s2][2] > bboxThreshold2[5]) continue;

                        if(
                            (POW2(m_bodyCenter[k * nDim] - coords[1 + s0][0])
                             + POW2(m_bodyCenter[k * nDim + 1] - coords[1 + s1][1])
                             + POW2(m_bodyCenter[k * nDim + 2] - coords[1 + s2][2]))
                            < POW2(dist0 + dkp)) {
                          keep = false;
                          break;
                        }
                      }
                      if(!keep) break;
                    }
                    if(!keep) break;
                  }
                }
                if(!keep) break;
              }
            }

            if(m_bodyTypeMb == 3 || m_bodyTypeMb == 1 || m_bodyTypeMb == 7) {
              MFloat sr = distr2(gen2);
              MFloat tt1 = F2 * PI * distr2(gen2);
              MFloat tt2 = F2 * PI * distr2(gen2);
              MFloat ew = cos(tt2) * sqrt(sr);
              MFloat ex = sin(tt1) * sqrt(F1 - sr);
              MFloat ey = cos(tt1) * sqrt(F1 - sr);
              MFloat ez = sin(tt2) * sqrt(sr);
              m_bodyQuaternion[4 * k + 0] = ew / sqrt(ew * ew + ex * ex + ey * ey + ez * ez);
              m_bodyQuaternion[4 * k + 1] = ex / sqrt(ew * ew + ex * ex + ey * ey + ez * ez);
              m_bodyQuaternion[4 * k + 2] = ey / sqrt(ew * ew + ex * ex + ey * ey + ez * ez);
              m_bodyQuaternion[4 * k + 3] = ez / sqrt(ew * ew + ex * ex + ey * ey + ez * ez);
            }

            if(m_movingBndryCndId == 3008) {
              m_bodyTemperature[k] = distr3(gen3) * m_TInfinity;
            }
          }
          const MFloat time1 = MPI_Wtime();
          cerr << "body init time: " << time1 - time0 << "s." << endl;
        }

        MPI_Bcast(&m_bodyCenter[0], nDim * m_noEmbeddedBodies, MPI_DOUBLE, 0, mpiComm(), AT_, "m_bodyCenter[0]");
        MPI_Bcast(&m_bodyQuaternion[0], 4 * m_noEmbeddedBodies, MPI_DOUBLE, 0, mpiComm(), AT_, "m_bodyQuaternion[0]");
        MPI_Bcast(&m_bodyTemperature[0], m_noEmbeddedBodies, MPI_DOUBLE, 0, mpiComm(), AT_, "m_bodyTemperature[0]");

        if(storeBodyDistribution) {
          cerr0 << "Storing initial body distribution to file " << fileName << endl;
          const MLong DOF = m_noEmbeddedBodies;
          const MLong DOF_TRANS = nDim * m_noEmbeddedBodies;
          const MLong DOF_QUAT = 4 * m_noEmbeddedBodies;

          ParallelIo::size_type start = 0;
          ParallelIo::size_type count = 0;
          using namespace maia::parallel_io;
          ParallelIo parallelIo(fileName, PIO_REPLACE, mpiComm());

          // Creating file header.
          parallelIo.setAttributes(&m_noEmbeddedBodies, "noBodies", 1);
          parallelIo.setAttributes(m_bodyRadii, "bodyRadii", 3);
          count = DOF;
          parallelIo.defineArray(PIO_FLOAT, "bodyTemperature", count);
          count = DOF_TRANS;
          parallelIo.defineArray(PIO_FLOAT, "bodyCenter", count);
          count = DOF_QUAT;
          parallelIo.defineArray(PIO_FLOAT, "bodyQuaternion", count);
          start = 0;
          count = DOF;
          parallelIo.setOffset(count, start);
          parallelIo.writeArray(m_bodyTemperature, "bodyTemperature");
          count = DOF_TRANS;
          parallelIo.setOffset(count, start);
          parallelIo.writeArray(m_bodyCenter, "bodyCenter");
          count = DOF_QUAT;
          parallelIo.setOffset(count, start);
          parallelIo.writeArray(m_bodyQuaternion, "bodyQuaternion");
        }
      }

      createPeriodicGhostBodies();
      memset(m_bodyVelocity, 0, m_noEmbeddedBodies * nDim * sizeof(MFloat));
    }


    /*! \page propertiesFVMB
      \section initialBodyQuaternion
      <code>MFloat[4] FvMbCartesianSolverXD::m_bodyQuaternion </code>\n
      default = <code>[0.,0.,0.,0.]</code>\n \n
      Initializes the quaternion storing the position and rotation of each body \n
      Possible values are:
      <ul>
      <li>Four floating-point numbers per body</li>
      </ul>
      Keywords: <i>MOVING BOUNDARY, BODY INITIALIZATION</i>
    */
    if(Context::propertyExists("initialBodyQuaternion", m_solverId)) {
      for(MInt i = 0; i < m_noEmbeddedBodies * 4; i++) {
        m_bodyQuaternion[i] = Context::getSolverProperty<MFloat>("initialBodyQuaternion", m_solverId, AT_, i);
      }
    }

    /*! \page propertiesFVMB
      \section initialBodyRotation
      <code>MFloat* FvMbSolver2/3D::m_bodyRotation</code>\n
      default = <code>0.0</code> or set by initialBodyQuaternion\n \n
      Initial rotation of all embedded bodies. If three values are given these are used for all
      bodies, alternatively provide nDim values per body. \n \n
      Possible values are:
      <ul>
        <li>list of floating point values</li>
      </ul>
      Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, BODY_MOTION, INITIAL_CONDITION</i>
    */
    if(Context::propertyExists("initialBodyRotation", m_solverId)) {
      MFloatScratchSpace bodyRotation(m_noEmbeddedBodies, 3, AT_, "bodyRotation");
      if(Context::propertyLength("initialBodyRotation", m_solverId) == 3) {
        for(MInt i = 0; i < m_noEmbeddedBodies; i++) {
          for(MInt j = 0; j < 3; j++) {
            bodyRotation[3 * i + j] =
                Context::getSolverProperty<MFloat>("initialBodyRotation", m_solverId, AT_, j) * PI / 180.0;
          }
        }
      } else {
        for(MInt i = 0; i < m_noEmbeddedBodies * nDim; i++) {
          bodyRotation[i] = Context::getSolverProperty<MFloat>("initialBodyRotation", m_solverId, AT_, i) * PI / 180.0;
        }
      }
      for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
        setBodyQuaternions(k, &bodyRotation[k * 3]);
      }
    }

  } //! restart

  /*! \page propertiesFVMB
    \section bodyTerminalVelocity
    <code>MFloat FvMbPar::m_bodyTerminalVelocity </code>\n
    default = <code>""</code>\n \n
    Specifies the terminal velocity of all embedded analytical moving levelset functions in each dimension.
    <ul>
    <li>any positive float </li>
    </ul>
    One velocity value per Dimension
    Keywords: <i>LEVELSET, ANALYTICAL, G0, </i>
  */

  if(Context::propertyExists("bodyTerminalVelocity", m_solverId) && m_noEmbeddedBodies > 0) {
    const MFloat radius = pow(m_bodyRadii[0] * m_bodyRadii[1] * m_bodyRadii[2], F1B3);
    const MFloat FAC0 =
        (9.0 / 2.0) * sysEqn().m_muInfinity / (sysEqn().m_Re0 * m_densityRatio * m_rhoInfinity * POW2(radius));
    for(MInt dir = 0; dir < nDim; dir++) {
      m_bodyTerminalVelocity[dir] = Context::getSolverProperty<MFloat>("bodyTerminalVelocity", m_solverId, AT_,
                                                                       &m_bodyTerminalVelocity[dir], dir);
    }
    for(MInt dir = 0; dir < nDim; dir++) {
      m_gravity[dir] = FAC0 * m_bodyTerminalVelocity[dir];
    }
    for(MInt k = 0; k < m_noEmbeddedBodies + m_noPeriodicGhostBodies; k++) {
      for(MInt dir = 0; dir < nDim; dir++) {
        m_bodyVelocity[nDim * k + dir] += m_bodyTerminalVelocity[dir];
      }
    }
  }


  if(m_trackMovingBndry && !m_restart && (m_motionEquation == 0)) {
    for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
      for(MInt i = 0; i < nDim; i++) {
        m_bodyCenterDt1[k * nDim + i] = m_bodyCenter[k * nDim + i];
      }
    }
    if(!m_LsMovement) {
      updateBodyProperties();
    }
  }

  if(m_restart) {
    loadBodyRestartFile(0);
  }


  for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
    for(MInt i = 0; i < nDim; i++) {
      m_bodyVelocityDt1[k * nDim + i] = m_bodyVelocity[k * nDim + i];
      m_bodyCenterDt1[k * nDim + i] = m_bodyCenter[k * nDim + i];
      m_bodyAccelerationDt1[k * nDim + i] = m_bodyAcceleration[k * nDim + i];
      if(m_motionEquation > 1) {
        m_bodyVelocityDt2[k * nDim + i] = m_bodyVelocity[k * nDim + i];
        m_bodyCenterDt2[k * nDim + i] = m_bodyCenter[k * nDim + i];
        m_bodyAccelerationDt2[k * nDim + i] = m_bodyAcceleration[k * nDim + i];
        m_bodyAccelerationDt3[k * nDim + i] = m_bodyAcceleration[k * nDim + i];
      }
    }
    for(MInt i = 0; i < 3; i++) {
      m_bodyTorqueDt1[k * 3 + i] = m_bodyTorque[k * 3 + i];
      m_bodyAngularVelocityDt1[k * 3 + i] = m_bodyAngularVelocity[k * 3 + i];
      m_bodyAngularAccelerationDt1[k * 3 + i] = m_bodyAngularAcceleration[k * 3 + i];
    }
    for(MInt i = 0; i < 4; i++) {
      m_bodyQuaternionDt1[k * 4 + i] = m_bodyQuaternion[k * 4 + i];
    }
  }

  if(m_initialCondition == 466) {
    MFloat* bbox;
    bbox = new MFloat[6];
    m_geometry->getBoundingBox(bbox);
    const MFloat delta = F2 * m_UInfinity / (bbox[1 + nDim] - bbox[1]);
    for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
      m_log << "Reynolds number "
            << F4 * delta
                   * POW2(mMax(m_bodyRadii[k * nDim + 0], mMax(m_bodyRadii[k * nDim + 1], m_bodyRadii[k * nDim + 2])))
            << "  "
            << sysEqn().m_Re0 * F4 * delta
                   * POW2(mMax(m_bodyRadii[k * nDim + 0], mMax(m_bodyRadii[k * nDim + 1], m_bodyRadii[k * nDim + 2])))
            << endl;
    }
    delete[] bbox;
  }

  if(m_adaptation) {
    m_periodicGhostBodyDist = 1.1
                              * (m_outerBandWidth[mMin(maxUniformRefinementLevel(), maxRefinementLevel() - 1)]
                                 + ((MFloat)noHaloLayers()) * c_cellLengthAtLevel(minLevel()) + m_maxBodyRadius);
    m_adaptationDampingDistance = m_bodyDiameter[0];
  } else {
    m_periodicGhostBodyDist = 1.1 * ((MFloat)noHaloLayers()) * c_cellLengthAtLevel(minLevel()) + m_maxBodyRadius;
  }

  if(grid().periodicCartesianDir(0) + grid().periodicCartesianDir(1) + grid().periodicCartesianDir(2) > 0) {
    createPeriodicGhostBodies();
  }
  IF_CONSTEXPR(nDim == 3) { createBodyTree(); }

  cerr0 << "done." << endl;
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::advancePointParticles() {
  const MBool saffmanLift = false;

  if(m_pointParticleType == 1) {
    MFloat vrel[3];
    MFloat vort[3];
    MFloat lift[3];

    const MFloat dt = timeStep();
    const MFloat Cvp = m_capacityConstantVolumeRatio;

    // 1. prediction step
    for(MInt p = 0; p < m_noPointParticlesLocal; p++) {
      for(MInt i = 0; i < nDim; i++) {
        m_particleCoords[nDim * p + i] =
            m_particleCoordsDt1[nDim * p + i]
            + F1B2 * dt * (m_particleVelocity[nDim * p + i] + m_particleVelocityDt1[nDim * p + i])
            + F1B4 * POW2(dt) * (m_particleAcceleration[nDim * p + i] + m_particleAccelerationDt1[nDim * p + i]);
        m_particleVelocity[nDim * p + i] =
            m_particleVelocityDt1[nDim * p + i] + dt * m_particleAcceleration[nDim * p + i];
      }
      m_particleTemperature[p] = m_particleTemperatureDt1[p] + dt * m_particleHeatFlux[p];
    }

    // 2. compute fluid velocity
    setParticleFluidVelocities();

    // 3. correction step
    for(MInt p = 0; p < m_noPointParticlesLocal; p++) {
      const MInt cellId = m_particleCellLink[p];
      const MFloat diameter =
          F2 * pow(m_particleRadii[3 * p] * m_particleRadii[3 * p + 1] * m_particleRadii[3 * p + 2], F1B3);
      const MFloat T = sysEqn().temperature_ES(a_pvariable(cellId, PV->RHO), a_pvariable(cellId, PV->P));
      const MFloat mue = SUTHERLANDLAW(T);
      const MFloat FAC = 18.0 * mue / (sysEqn().m_Re0 * m_densityRatio * m_rhoInfinity * POW2(diameter));
      MFloat Rep = F0;
      for(MInt i = 0; i < nDim; i++) {
        vrel[i] = m_particleVelocityFluid[nDim * p + i] - m_particleVelocity[nDim * p + i];
        Rep += POW2(vrel[i]);
      }
      Rep = sqrt(Rep) * diameter * a_pvariable(cellId, PV->RHO) * sysEqn().m_Re0 / mue;
      vort[0] = a_slope(cellId, PV->VV[2], 1) - a_slope(cellId, PV->VV[1], 2);
      vort[1] = a_slope(cellId, PV->VV[0], 2) - a_slope(cellId, PV->VV[2], 0);
      vort[2] = a_slope(cellId, PV->VV[1], 0) - a_slope(cellId, PV->VV[0], 1);
      lift[0] = vort[2] * vrel[1] - vort[1] * vrel[2];
      lift[1] = vort[0] * vrel[2] - vort[2] * vrel[0];
      lift[2] = vort[1] * vrel[0] - vort[0] * vrel[1];
      MFloat Res = a_pvariable(cellId, PV->RHO) * POW2(diameter) * sqrt(POW2(vort[0]) + POW2(vort[1]) + POW2(vort[2]))
                   * sysEqn().m_Re0 / mue;
      MFloat beta = F1B2 * Res / Rep;
      MFloat CLS = 4.1126 * ((F1 - 0.3314 * sqrt(beta)) * exp(-0.1 * Rep) + 0.3314 * sqrt(beta)) / sqrt(Res);
      if(Rep > 40.0) CLS = 0.0524 * sqrt(beta * Rep);
      for(MInt i = 0; i < nDim; i++) {
        m_particleAcceleration[nDim * p + i] =
            FAC * (F1 + 0.15 * pow(Rep, 0.687)) * vrel[i] + FAC * m_particleTerminalVelocity[i];
        if(saffmanLift) m_particleAcceleration[nDim * p + i] += F3B4 * CLS * lift[i] / (m_densityRatio * diameter);
        m_particleVelocity[nDim * p + i] =
            m_particleVelocityDt1[nDim * p + i]
            + dt * F1B2 * (m_particleAcceleration[nDim * p + i] + m_particleAccelerationDt1[nDim * p + i]);
        m_particleCoords[nDim * p + i] =
            m_particleCoordsDt1[nDim * p + i]
            + dt * F1B2 * (m_particleVelocity[nDim * p + i] + m_particleVelocityDt1[nDim * p + i]);
      }

      // Temperature update
      const MFloat particleSurface = PI * POW2(diameter);
      const MFloat mass = F1B6 * PI * POW3(diameter) * m_densityRatio * m_rhoInfinity;
      // See Whitaker 1972, AIChE Journal, Attention: not validated for Re < 4,
      // Nu = 2 for Re -> 0 is a solution of Stokes flow
      const MFloat mueParticle = SUTHERLANDLAW(m_particleTemperature[p]);
      const MFloat nusselt =
          F2
          + pow(m_Pr, 2.0 / 5.0) * (2.0 / 5.0 * pow(Rep, F1B2) + 0.06 * pow(Rep, F2B3)) * pow(mue / mueParticle, 0.25);
      const MFloat lambdaFluid = (T * sqrt(T) * m_sutherlandPlusOneThermal) / (T + m_sutherlandConstantThermal);
      const MFloat alpha = nusselt * lambdaFluid / diameter;
      const MFloat deltaT = m_particleFluidTemperature[p] - m_particleTemperature[p];
      m_particleHeatFlux[p] = (particleSurface * alpha * m_gamma) / (mass * Cvp * m_Pr * sysEqn().m_Re0) * deltaT;
      m_particleTemperature[p] =
          F1B2 * (m_particleTemperature[p] + m_particleTemperatureDt1[p] + dt * m_particleHeatFlux[p]);
    }
    //}
  } else if(m_pointParticleType == 3) {
    const MFloat dt = timeStep();
    const MFloat dt2 = F1B2 * timeStep();
    MFloatScratchSpace K(3, 3, AT_, "K");
    MFloatScratchSpace R(3, 3, AT_, "R");
    MFloatScratchSpace W(4, 4, AT_, "W");
    MFloatScratchSpace rhs(4, AT_, "rhs");

    MFloat q[3];
    MFloat q0[3];
    MFloat tq[3];
    MFloat tq0[3];
    MFloat vrel[3];
    MFloat vrelhat[3];
    MFloat tmp[3];
    MFloat vort[3];
    MFloat strain[3];

    // 1. predictor step
    for(MInt p = 0; p < m_noPointParticlesLocal; p++) {
      const MFloat w = m_particleQuaternionsDt1[4 * p + 0];
      const MFloat x = m_particleQuaternionsDt1[4 * p + 1];
      const MFloat y = m_particleQuaternionsDt1[4 * p + 2];
      const MFloat z = m_particleQuaternionsDt1[4 * p + 3];
      for(MInt i = 0; i < 3; i++) {
        q0[i] = m_particleAngularVelocityDt1[3 * p + i];
      }
      m_particleQuaternions[4 * p + 0] = w + F1B2 * dt * (-x * q0[0] - y * q0[1] - z * q0[2]);
      m_particleQuaternions[4 * p + 1] = x + F1B2 * dt * (w * q0[0] - z * q0[1] + y * q0[2]);
      m_particleQuaternions[4 * p + 2] = y + F1B2 * dt * (z * q0[0] + w * q0[1] - x * q0[2]);
      m_particleQuaternions[4 * p + 3] = z + F1B2 * dt * (-y * q0[0] + x * q0[1] + w * q0[2]);
      for(MInt i = 0; i < 3; i++) {
        m_particleAngularVelocity[3 * p + i] =
            m_particleAngularVelocityDt1[3 * p + i] + dt * m_particleAngularAccelerationDt1[3 * p + i];
      }
      for(MInt i = 0; i < nDim; i++) {
        m_particleCoords[nDim * p + i] =
            m_particleCoordsDt1[nDim * p + i]
            + F1B2 * dt * (m_particleVelocity[nDim * p + i] + m_particleVelocityDt1[nDim * p + i])
            + F1B4 * POW2(dt) * (m_particleAcceleration[nDim * p + i] + m_particleAccelerationDt1[nDim * p + i]);
        m_particleVelocity[nDim * p + i] =
            m_particleVelocityDt1[nDim * p + i] + dt * m_particleAcceleration[nDim * p + i];
      }

      m_particleTemperature[p] = m_particleTemperatureDt1[p] + dt * m_particleHeatFlux[p];
    }

    // 2. compute fluid velocity
    setParticleFluidVelocities();

    // 3. correction step
    for(MInt p = 0; p < m_noPointParticlesLocal; p++) {
      const MInt cellId = m_particleCellLink[p];
      const MFloat beta = m_particleRadii[3 * p + 2] / m_particleRadii[3 * p];
      const MFloat beta2 = POW2(beta);
      const MFloat radius = pow(m_particleRadii[3 * p] * m_particleRadii[3 * p + 1] * m_particleRadii[3 * p + 2], F1B3);
      const MFloat diameter = F2 * radius;
      const MFloat T = sysEqn().temperature_ES(a_pvariable(cellId, PV->RHO), a_pvariable(cellId, PV->P));
      const MFloat mue = SUTHERLANDLAW(T);
      const MFloat taup = F2 * m_densityRatio * POW2(radius) / (9.0 * mue / sysEqn().m_Re0);
      const MFloat FAC = (8.0 / 3.0) * pow(beta, F2B3) / taup;
      const MFloat FAC2 = (40.0 / 9.0) * pow(beta, F2B3) / taup;
      const MFloat FAC0 = (9.0 / 2.0) * mue / (sysEqn().m_Re0 * m_densityRatio * m_rhoInfinity * POW2(radius));

      // integrate angular velocity
      const MInt maxit = 100;
      MFloat delta = F1;
      MInt it = 0;

      W(0, 0) = F1 + dt2 * FAC2 / (m_particleShapeParams[4 * p + 1] + beta2 * m_particleShapeParams[4 * p + 3]);
      W(1, 1) = F1 + dt2 * FAC2 / (m_particleShapeParams[4 * p + 1] + beta2 * m_particleShapeParams[4 * p + 3]);
      W(2, 2) = F1 + dt2 * FAC2 / (F2 * m_particleShapeParams[4 * p + 1]);
      W(2, 0) = F0;
      W(2, 1) = F0;
      for(MInt i = 0; i < 3; i++) {
        tq0[i] = m_particleAngularAccelerationDt1[3 * p + i];
        q0[i] = m_particleAngularVelocityDt1[3 * p + i];
        tq[i] = tq0[i];
        q[i] = q0[i];
      }

      for(MInt i = 0; i < 3; i++) {
        MInt id0 = (i + 1) % 3;
        MInt id1 = (id0 + 1) % 3;
        strain[i] = F1B2
                    * (m_particleVelocityGradientFluid[9 * p + 3 * id1 + id0]
                       + m_particleVelocityGradientFluid[9 * p + 3 * id0 + id1]);
        vort[i] = F1B2
                  * (m_particleVelocityGradientFluid[9 * p + 3 * id1 + id0]
                     - m_particleVelocityGradientFluid[9 * p + 3 * id0 + id1]);
      }

      // Newton iterations
      while(delta > 1e-10 && it < maxit) {
        W(0, 1) = -dt2 * q[2] * (beta2 - F1) / (beta2 + F1);
        W(0, 2) = -dt2 * q[1] * (beta2 - F1) / (beta2 + F1);
        W(1, 0) = -dt2 * q[2] * (F1 - beta2) / (beta2 + F1);
        W(1, 2) = -dt2 * q[0] * (F1 - beta2) / (beta2 + F1);

        maia::math::invert(&W(0, 0), 3, 3);

        tq[0] = q[1] * q[2] * (beta2 - F1) / (beta2 + F1)
                + FAC2 * (((F1 - beta2) / (F1 + beta2)) * strain[0] + vort[0] - q[0])
                      / (m_particleShapeParams[4 * p + 1] + beta2 * m_particleShapeParams[4 * p + 3]);
        tq[1] = q[0] * q[2] * (F1 - beta2) / (beta2 + F1)
                + FAC2 * (((beta2 - F1) / (F1 + beta2)) * strain[1] + vort[1] - q[1])
                      / (m_particleShapeParams[4 * p + 1] + beta2 * m_particleShapeParams[4 * p + 3]);
        tq[2] = FAC2 * (vort[2] - q[2]) / (F2 * m_particleShapeParams[4 * p + 1]);

        for(MInt i = 0; i < 3; i++)
          rhs[i] = q[i] - q0[i] - dt2 * (tq0[i] + tq[i]);

        delta = F0;
        for(MInt i = 0; i < 3; i++) {
          const MFloat qq = q[i];
          for(MInt j = 0; j < 3; j++) {
            q[i] -= W(i, j) * rhs(j);
          }
          delta = mMax(delta, fabs(q[i] - qq));
        }
        it++;
      }
      if(it >= maxit || it <= 0) {
        cerr << "Newton iterations did not converge " << p << endl;
      }

      m_particleAngularVelocity[3 * p + 0] = q[0];
      m_particleAngularVelocity[3 * p + 1] = q[1];
      m_particleAngularVelocity[3 * p + 2] = q[2];
      m_particleAngularAcceleration[3 * p + 0] = tq[0];
      m_particleAngularAcceleration[3 * p + 1] = tq[1];
      m_particleAngularAcceleration[3 * p + 2] = tq[2];

      // integrate quaternions
      const MFloat w = m_particleQuaternionsDt1[4 * p + 0];
      const MFloat x = m_particleQuaternionsDt1[4 * p + 1];
      const MFloat y = m_particleQuaternionsDt1[4 * p + 2];
      const MFloat z = m_particleQuaternionsDt1[4 * p + 3];

      W(0, 0) = F0;
      W(0, 1) = -q[0];
      W(0, 2) = -q[1];
      W(0, 3) = -q[2];
      W(1, 0) = q[0];
      W(1, 1) = F0;
      W(1, 2) = q[2];
      W(1, 3) = -q[1];
      W(2, 0) = q[1];
      W(2, 1) = -q[2];
      W(2, 2) = F0;
      W(2, 3) = q[0];
      W(3, 0) = q[2];
      W(3, 1) = q[1];
      W(3, 2) = -q[0];
      W(3, 3) = F0;

      for(MInt i = 0; i < 4; i++)
        for(MInt j = 0; j < 4; j++)
          W(i, j) = -F1B2 * dt2 * W(i, j);
      for(MInt i = 0; i < 4; i++)
        W(i, i) = F1;

      rhs(0) = w + F1B2 * dt2 * (-x * q0[0] - y * q0[1] - z * q0[2]);
      rhs(1) = x + F1B2 * dt2 * (w * q0[0] - z * q0[1] + y * q0[2]);
      rhs(2) = y + F1B2 * dt2 * (z * q0[0] + w * q0[1] - x * q0[2]);
      rhs(3) = z + F1B2 * dt2 * (-y * q0[0] + x * q0[1] + w * q0[2]);

      maia::math::invert(&W(0, 0), 4, 4);

      for(MInt i = 0; i < 4; i++) {
        m_particleQuaternions[4 * p + i] = F0;
        for(MInt j = 0; j < 4; j++) {
          m_particleQuaternions[4 * p + i] += W(i, j) * rhs(j);
        }
      }

      MFloat abs = F0;
      for(MInt i = 0; i < 4; i++)
        abs += POW2(m_particleQuaternions[4 * p + i]);
      for(MInt i = 0; i < 4; i++)
        m_particleQuaternions[4 * p + i] /= sqrt(abs);

      // integrate linear motion
      K.fill(F0);
      K(0, 0) = F1 / (m_particleShapeParams[4 * p] / POW2(m_particleRadii[3 * p]) + m_particleShapeParams[4 * p + 1]);
      K(1, 1) = K(0, 0);
      K(2, 2) =
          F1 / (m_particleShapeParams[4 * p] / POW2(m_particleRadii[3 * p]) + beta2 * m_particleShapeParams[4 * p + 3]);
      computeRotationMatrix(R, &(m_particleQuaternions[4 * p]));
      for(MInt i = 0; i < nDim; i++) {
        vrel[i] = m_particleVelocityFluid[nDim * p + i] - m_particleVelocity[nDim * p + i];
      }
      matrixVectorProduct(vrelhat, R, vrel); // principal axes frame relative velocity
      matrixVectorProduct(tmp, K, vrelhat);
      matrixVectorProductTranspose(vrel, R, tmp);

      for(MInt i = 0; i < nDim; i++) {
        m_particleAcceleration[nDim * p + i] = FAC * vrel[i] + FAC0 * m_particleTerminalVelocity[i];
        m_particleVelocity[nDim * p + i] =
            m_particleVelocityDt1[nDim * p + i]
            + dt * F1B2 * (m_particleAcceleration[nDim * p + i] + m_particleAccelerationDt1[nDim * p + i]);
        m_particleCoords[nDim * p + i] =
            m_particleCoordsDt1[nDim * p + i]
            + dt * F1B2 * (m_particleVelocity[nDim * p + i] + m_particleVelocityDt1[nDim * p + i])
            + F1B4 * POW2(dt) * (m_particleAcceleration[nDim * p + i] + m_particleAccelerationDt1[nDim * p + i]);
      }

      // temperature update
      const MFloat mass = F4B3 * PI * m_particleRadii[3 * p] * m_particleRadii[3 * p + 1] * m_particleRadii[3 * p + 2]
                          * m_densityRatio * m_rhoInfinity;
      const MFloat Cvp = m_capacityConstantVolumeRatio;

      MFloat particleSurface = 0;
      if(fabs(beta - F1) < 1e-14)
        particleSurface = 4 * PI * POW2(m_particleRadii[3 * p]);
      else {
        if(beta < 1) {
          const MFloat factor = sqrt(1 - beta2);
          particleSurface =
              2 * PI * m_particleRadii[3 * p] * m_particleRadii[3 * p + 1] * (1 + (beta2 / factor * atanh(factor)));
        } else {
          const MFloat factor = sqrt(1 - 1 / beta2);
          particleSurface = 2 * PI * m_particleRadii[3 * p] * m_particleRadii[3 * p + 1]
                            * (1 + m_particleRadii[3 * p + 2] / (m_particleRadii[3 * p] * factor) * asin(factor));
        }
      }

      // nusselt correlation for sphere in Stokesian flow
      const MFloat nusselt = 2;
      const MFloat lambdaFluid = (T * sqrt(T) * m_sutherlandPlusOneThermal) / (T + m_sutherlandConstantThermal);
      const MFloat alpha = nusselt * lambdaFluid / diameter;
      const MFloat deltaT = m_particleFluidTemperature[p] - m_particleTemperature[p];
      m_particleHeatFlux[p] = (particleSurface * alpha * m_gamma) / (mass * Cvp * m_Pr * sysEqn().m_Re0) * deltaT;
      m_particleTemperature[p] =
          F1B2 * (m_particleTemperature[p] + m_particleTemperatureDt1[p] + dt * m_particleHeatFlux[p]);
    }
  } else {
    mTerm(1, AT_, "part type.");
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::setParticleFluidVelocities(MFloat* pressure) {
  IF_CONSTEXPR(nDim == 2) mTerm(1, AT_, "Go for 3D.");

  const MBool fourthOrder = false;
  const MInt maxNoNghbrs = 150;
  const MInt recDim = fourthOrder ? 19 : 10;

  MIntScratchSpace nghbrList(maxNoNghbrs, AT_, "nghbrList");
  MIntScratchSpace layerId(maxNoNghbrs, AT_, "layerList");
  MFloatScratchSpace mat(maxNoNghbrs, recDim, AT_, "mat");

  nghbrList.fill(-1);
  for(MUint p = 0; p < m_particleCellLink.size(); p++) {
    const MInt cellId = m_particleCellLink[p];
    const MFloat normalizationFactor =
        F1 / c_cellLengthAtCell(cellId); // scaling factor to reduce the condition number of the resulting eq. sys.
    const MInt counter = 1 + this->template getAdjacentLeafCells<2>(cellId, 1, nghbrList, layerId);
    for(MInt i = counter - 1; i > 0; i--)
      nghbrList[i] = nghbrList[i - 1];
    nghbrList[0] = cellId;
    mat.fill(F0);
    for(MInt c = 0; c < counter; c++) {
      const MInt nghbrId = nghbrList(c);
      MFloat deltaX[3];

      for(MInt i = 0; i < nDim; i++) {
        deltaX[i] = (a_coordinate(nghbrId, i) - m_particleCoords[nDim * p + i]) * normalizationFactor;
      }

      MInt cnt = 0;
      mat(c, cnt) = F1;
      cnt++;
      for(MInt i = 0; i < nDim; i++) {
        mat(c, cnt) = deltaX[i];
        cnt++;
      }
      for(MInt i = 0; i < nDim; i++) {
        for(MInt j = i; j < nDim; j++) {
          const MFloat fac = (i == j) ? F1B2 : F1;
          mat(c, cnt) = fac * deltaX[i] * deltaX[j];
          cnt++;
        }
      }
      if(fourthOrder) {
        for(MInt i = 0; i < nDim; i++) {
          for(MInt j = i; j < nDim; j++) {
            for(MInt k = j; k < nDim; k++) {
              const MFloat fac = (i == j && i == k) ? F1B6 : ((i == j || i == k || j == k) ? F1B2 : F1);
              mat(c, cnt) = fac * deltaX[i] * deltaX[j] * deltaX[k];
              cnt++;
            }
          }
        }
      }
    }
    maia::math::invert(&mat(0, 0), counter, recDim);

    for(MInt c = 0; c < counter; c++) {
      MInt cnt = 1;
      for(MInt i = 0; i < nDim; i++) {
        mat(cnt, c) *= normalizationFactor;
        cnt++;
      }
      for(MInt i = 0; i < nDim; i++) {
        for(MInt j = i; j < nDim; j++) {
          mat(cnt, c) *= POW2(normalizationFactor);
          cnt++;
        }
      }
      if(fourthOrder) {
        for(MInt i = 0; i < nDim; i++) {
          for(MInt j = i; j < nDim; j++) {
            for(MInt k = j; k < nDim; k++) {
              mat(cnt, c) *= POW3(normalizationFactor);
              cnt++;
            }
          }
        }
      }
    }

    MFloatScratchSpace R(3, 3, AT_, "R");
    computeRotationMatrix(R, &(m_particleQuaternions[4 * p]));

    for(MInt i = 0; i < nDim; i++) {
      m_particleVelocityFluid[nDim * p + i] = F0;
    }
    m_particleFluidTemperature[p] = F0;
    for(MInt c = 0; c < counter; c++) {
      for(MInt i = 0; i < nDim; i++) {
        m_particleVelocityFluid[nDim * p + i] += mat(0, c) * a_pvariable(nghbrList[c], PV->VV[i]);
      }
      m_particleFluidTemperature[p] +=
          mat(0, c) * sysEqn().temperature_ES(a_pvariable(nghbrList[c], PV->RHO), a_pvariable(nghbrList[c], PV->P));
    }

    MFloat velGrad[3][3] = {{F0, F0, F0}, {F0, F0, F0}, {F0, F0, F0}};
    for(MInt c = 0; c < counter; c++) {
      MFloat coeffs0[3] = {mat(1, c), mat(2, c), mat(3, c)};
      MFloat vel0[3] = {a_pvariable(nghbrList[c], PV->U), a_pvariable(nghbrList[c], PV->V),
                        a_pvariable(nghbrList[c], PV->W)};
      MFloat coeffs[3];
      MFloat vel[3];
      matrixVectorProduct(coeffs, R, coeffs0);
      matrixVectorProduct(vel, R, vel0);
      for(MInt i = 0; i < nDim; i++) {
        for(MInt j = 0; j < nDim; j++) {
          velGrad[i][j] += coeffs[j] * vel[i];
        }
      }
    }

    for(MInt i = 0; i < nDim; i++) {
      for(MInt j = 0; j < nDim; j++) {
        m_particleVelocityGradientFluid[9 * p + 3 * i + j] = velGrad[i][j];
      }
    }

    if(pressure != nullptr) {
      pressure[p] = F0;
      for(MInt c = 0; c < counter; c++) {
        pressure[p] += mat(0, c) * a_pvariable(nghbrList[c], PV->P);
      }
    }
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvMbCartesianSolverXD<nDim, SysEqn>::createBodyTree() {
  rebuildKDTree();

  if(m_noLevelSetsUsedForMb > 1 && m_buildCollectedLevelSetFunction) {
    const MFloat delta0 = F2 * c_cellLengthAtLevel(maxRefinementLevel());
    const MFloat deltaMax = F2 * m_maxBodyRadius + delta0;
    MIntScratchSpace nearBodies(m_noEmbeddedBodies, AT_, "nearBodies");
    MFloatScratchSpace minDist(m_noLevelSetsUsedForMb, AT_, "minDist");

    for(MInt i = 0; i < m_noLevelSetsUsedForMb; i++) {
      for(MInt j = 0; j < m_maxNoEmbeddedBodiesPeriodic; j++) {
        m_setToBodiesTable[i][j] = -1;
      }
      m_noBodiesInSet[i] = 0;
    }
    for(MInt i = 0; i < m_maxNoEmbeddedBodiesPeriodic; i++) {
      m_bodyToSetTable[i] = -1;
    }
    if(m_startSet > 0) {
      m_noBodiesInSet[0] = 0;
      for(MInt i = 0; i < m_noEmbeddedBodies + m_noPeriodicGhostBodies; i++) {
        m_setToBodiesTable[0][m_noBodiesInSet[0]] = i;
        m_noBodiesInSet[0]++;
      }
    }
    m_noSets = m_startSet;


    for(MInt p = 0; p < m_noEmbeddedBodies + m_noPeriodicGhostBodies; p++) {
      MInt id = m_startSet;

      if(m_noEmbeddedBodies > (m_noLevelSetsUsedForMb - m_startSet)) {
        Point<3> pt(m_bodyCenter[p * nDim], m_bodyCenter[p * nDim + 1], m_bodyCenter[p * nDim + 2]);
        MInt noNearBodies = locatenear(pt, deltaMax, &nearBodies[0], m_noEmbeddedBodies);
        MBool overlap = true;
        minDist.fill(c_cellLengthAtLevel(0));

        while(overlap && id < m_noLevelSetsUsedForMb) {
          overlap = false;
          for(MInt b = 0; b < noNearBodies; b++) {
            const MInt q = nearBodies[b];
            if(p == q) continue;
            if(m_bodyToSetTable[q] == id) {
              overlap = true;
              MFloat dist = sqrt(POW2(m_bodyCenter[p * nDim] - m_bodyCenter[q * nDim])
                                 + POW2(m_bodyCenter[p * nDim + 1] - m_bodyCenter[q * nDim + 1])
                                 + POW2(m_bodyCenter[p * nDim + 2] - m_bodyCenter[q * nDim + 2]))
                            - F2 * m_maxBodyRadius;
              minDist(id) = mMin(minDist(id), dist);
              ASSERT(dist < delta0 + m_eps, "");
              break;
            }
          }
          if(overlap) id++;
        }

        if(overlap) {
          id = m_startSet;
          for(MInt i = m_startSet; i < m_noLevelSetsUsedForMb; i++) {
            if(minDist(i) > minDist(id)) id = i;
          }

          cerr0 << domainId() << ": Not enough level sets to prevent overlap: " << p << " " << id << " "
                << minDist(id) / c_cellLengthAtLevel(m_lsCutCellMinLevel) << " " << m_maxBodyRadius << endl;
        }

        m_bodyToSetTable[p] = id;
        m_setToBodiesTable[id][m_noBodiesInSet[id]] = p;
        m_noBodiesInSet[id]++;
      } else {
        id = m_startSet + p % (m_noLevelSetsUsedForMb - 1);
        if(id >= m_noLevelSetsUsedForMb) mTerm(1, AT_, "Wrong set handling");
        m_bodyToSetTable[p] = id;
        m_setToBodiesTable[id][m_noBodiesInSet[id]] = p;
        m_noBodiesInSet[id]++;
      }
      m_noSets = mMax(m_noSets, id + 1);
    }
  }

  updateGeometry();
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 2, _*>>
void FvMbCartesianSolverXD<nDim, SysEqn>::createBodyTree() {}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::createPeriodicGhostBodies() {
  TRACE();

  m_noPeriodicGhostBodies = 0;
  if(grid().periodicCartesianDir(0) + grid().periodicCartesianDir(1) + grid().periodicCartesianDir(2) == 0) return;
  if(m_bodyTypeMb == 2) return;
  if(grid().azimuthalPeriodicity()) {
    return;
  }

  MFloat dx[3];
  for(MInt i = 0; i < nDim; i++) {
    dx[i] = m_bbox[nDim + i] - m_bbox[i];
  }

  for(MInt b = 0; b < m_noEmbeddedBodies; b++) {
    // 1. periodic correction of internal body
    m_internalBodyId[b] = b;
    for(MInt i = 0; i < nDim; i++) {
      const MFloat displ = m_bodyCenter[b * nDim + i] - m_bodyCenterDt1[b * nDim + i];
      const MFloat displ2 = (m_motionEquation > 1) ? m_bodyCenter[b * nDim + i] - m_bodyCenterDt2[b * nDim + i] : F0;
      if(m_bodyCenter[b * nDim + i] < m_bbox[i]) {
        m_bodyCenter[b * nDim + i] += dx[i];
      } else if(m_bodyCenter[b * nDim + i] > m_bbox[nDim + i]) {
        m_bodyCenter[b * nDim + i] -= dx[i];
      }
      m_bodyCenterDt1[b * nDim + i] = m_bodyCenter[b * nDim + i] - displ;
      if(m_motionEquation > 1) {
        m_bodyCenterDt2[b * nDim + i] = m_bodyCenter[b * nDim + i] - displ2;
      }
    }

    // 2. add periodic ghost bodies if needed
    m_periodicGhostBodies[b].clear();
    IF_CONSTEXPR(nDim == 2) {
      if(m_bodyCenter[b * nDim] > m_bbox[0] + m_periodicGhostBodyDist
         && m_bodyCenter[b * nDim] < m_bbox[3] - m_periodicGhostBodyDist
         && m_bodyCenter[b * nDim + 1] > m_bbox[1] + m_periodicGhostBodyDist
         && m_bodyCenter[b * nDim + 1] < m_bbox[4] - m_periodicGhostBodyDist) {
        continue;
      }
    }
    else IF_CONSTEXPR(nDim == 3) {
      if(m_bodyCenter[b * nDim] > m_bbox[0] + m_periodicGhostBodyDist
         && m_bodyCenter[b * nDim] < m_bbox[3] - m_periodicGhostBodyDist
         && m_bodyCenter[b * nDim + 1] > m_bbox[1] + m_periodicGhostBodyDist
         && m_bodyCenter[b * nDim + 1] < m_bbox[4] - m_periodicGhostBodyDist
         && m_bodyCenter[b * nDim + 2] > m_bbox[2] + m_periodicGhostBodyDist
         && m_bodyCenter[b * nDim + 2] < m_bbox[5] - m_periodicGhostBodyDist) {
        continue;
      }
    }
    for(MInt s0 = -1; s0 <= 1; s0++) {
      if(s0 != 0 && !grid().periodicCartesianDir(0)) continue;
      for(MInt s1 = -1; s1 <= 1; s1++) {
        if(s1 != 0 && !grid().periodicCartesianDir(1)) continue;
        for(MInt s2 = -1; s2 <= 1; s2++) {
          if(s2 != 0 && !grid().periodicCartesianDir(2)) continue;
          if(s0 == 0 && s1 == 0 && s2 == 0) continue;
          MFloat sign[3] = {((MFloat)s0), ((MFloat)s1), ((MFloat)s2)};
          MFloat coords[3] = {F0, F0, F0};
          MBool tooFar = false;
          for(MInt i = 0; i < nDim; i++) {
            coords[i] = m_bodyCenter[b * nDim + i] + sign[i] * dx[i];
            if(coords[i] < m_bbox[i] - m_periodicGhostBodyDist
               || coords[i] > m_bbox[nDim + i] + m_periodicGhostBodyDist)
              tooFar = true;
          }
          if(tooFar) continue;
          const MInt k = m_noEmbeddedBodies + m_noPeriodicGhostBodies;
          if(k >= m_maxNoEmbeddedBodiesPeriodic)
            mTerm(1, AT_,
                  "Increase m_maxNoEmbeddedBodiesPeriodic " + to_string(m_noEmbeddedBodies) + " "
                      + to_string(m_noPeriodicGhostBodies));
          transferBodyState(k, b);
          for(MInt i = 0; i < nDim; i++) {
            m_bodyCenter[k * nDim + i] = coords[i];
          }
          m_internalBodyId[k] = b;
          m_periodicGhostBodies[b].push_back(k);
          m_noPeriodicGhostBodies++;
        }
      }
    }
  }

  if(globalTimeStep > m_restartTimeStep && globalTimeStep % m_restartInterval == 0) {
    m_log << "No periodic ghost bodies: " << m_noPeriodicGhostBodies << " ("
          << 100.0 * ((MFloat)m_noPeriodicGhostBodies) / ((MFloat)m_noEmbeddedBodies) << "%)" << endl;
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::transferBodyState(MInt k, MInt b) {
  // TRACE();

  m_bodyRadius[k] = m_bodyRadius[b];
  m_bodyDiameter[k] = m_bodyDiameter[b];
  for(MInt i = 0; i < nDim; i++) {
    m_bodyVelocity[k * nDim + i] = m_bodyVelocity[b * nDim + i];
    m_bodyAcceleration[k * nDim + i] = m_bodyAcceleration[b * nDim + i];
  }
  for(MInt i = 0; i < 3; i++) {
    m_bodyRadii[k * 3 + i] = m_bodyRadii[b * 3 + i];
    m_bodyAngularVelocity[k * 3 + i] = m_bodyAngularVelocity[b * 3 + i];
    m_bodyAngularAcceleration[k * 3 + i] = m_bodyAngularAcceleration[b * 3 + i];
  }
  for(MInt i = 0; i < 4; i++) {
    m_bodyQuaternion[k * 4 + i] = m_bodyQuaternion[b * 4 + i];
  }
}


/**
 * \fn void FvMbCartesianSolverXD<nDim, SysEqn>::updateBodyProperties()
 * \brief update properties of the embedded body (mainly forced structural motion)
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::updateBodyProperties() {
  TRACE();

  ASSERT(!m_LsMovement, "");

  for(MInt body = 0; body < m_noEmbeddedBodies; body++) {
    MFloat bodyRotation[3] = {0};
    getBodyRotation(body, bodyRotation);

    switch(m_bodyEquation[body]) {
        // for motionEquation == 0 && !m_constructGField:  m_bodyEquation = 4520 !!

      // vortex pair-cylinder interaction
      case 120: {
        MFloat timeOffset = F0;
        timeOffset = Context::getSolverProperty<MFloat>("timeOffset", m_solverId, AT_, &timeOffset);
        MFloat targetBodyVelocity = F0;
        targetBodyVelocity =
            Context::getSolverProperty<MFloat>("targetBodyVelocity", m_solverId, AT_, &targetBodyVelocity);

        m_bodyCenter[0] += m_bodyVelocity[0] * timeStep();
        m_bodyVelocity[0] = targetBodyVelocity * m_UInfinity * F1B2 * (tanh(100.0 * (m_time - timeOffset)) + F1);
        m_bodyAcceleration[0] =
            targetBodyVelocity * m_UInfinity * F1B2
            * (tanh(100.0 * (m_time + 0.0001 - timeOffset)) - tanh(100.0 * (m_time - 0.0001 - timeOffset))) / 0.0002;
        cerr << "DEBUG DANIEL " << globalTimeStep << " " << m_time << " " << m_bodyCenter[0] << " " << m_bodyVelocity[0]
             << " " << m_bodyAcceleration[0] << endl;

        break;
      }
      case 401: {
        // temporal offset
        MFloat timeOffset = F0; // 100.;

        // transversely oscillating cylinder
        // MFloat deltaT = timeStep();
        // if ( m_dualTimeStepping ) deltaT = m_physicalTimeStep;
        MFloat elapsedTime = m_physicalTime - timeOffset;

        const MFloat D = F2 * m_bodyRadius[0];
        /*! \page propertiesFVMB
         \section amplitudeFactor
         <code>MFloat FvMbCartesianSolverXD::updateBodyProperties()::amplitudeFactor</code>\n
         default = 0.1\n \n
         Set the amplitude factor (in terms of body diameters) for prescribing body motion. \n \n
         Possible values are:
         <ul>
           <li>any positive floating point number</li>
         </ul>
         Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, BODY, BODY_MOTION</i>
       */
        MFloat amplitudeFactor = 0.1;
        amplitudeFactor = Context::getSolverProperty<MFloat>("amplitudeFactor", m_solverId, AT_, &amplitudeFactor);

        /*! \page propertiesFVMB
          \section freqFactor
          <code>MFloat FvMbCartesianSolverXD::updateBodyProperties()::freqFactor</code>\n
          default = depending on body equation for current body\n \n
          Set the frequency factor for prescribing body motion. \n \n
          Possible values are:
          <ul>
            <li>any positive floating point number</li>
          </ul>
          Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, BODY, BODY_MOTION</i>
        */
        MFloat freqFactor = F1;
        freqFactor = Context::getSolverProperty<MFloat>("freqFactor", m_solverId, AT_, &freqFactor);
        MFloat Strouhal = 0.194;
        Strouhal = Context::getSolverProperty<MFloat>("Strouhal", m_solverId, AT_, &Strouhal);
        const MFloat A = amplitudeFactor * D;
        const MFloat freq0 =
            Strouhal * m_UInfinity / m_referenceLength; // if integrating with m_timestep*m_timeRef only take Strouhal
        const MFloat mu = freqFactor * freq0 * F2 * PI;

        if(elapsedTime > F0) {
          m_bodyCenter[1] = -A * cos(mu * elapsedTime);
          m_bodyVelocity[1] = mu * A * sin(mu * elapsedTime);
          m_bodyAcceleration[1] = mu * mu * A * cos(mu * elapsedTime);
        } else {
          m_bodyCenter[1] = -A;
          m_bodyVelocity[1] = F0;
          m_bodyAcceleration[1] = F0;
        }

        break;
      }

      // startup of a cylinder
      case 402: {
        MFloat deltaT = timeStep();
        if(m_dualTimeStepping) forceTimeStep(m_physicalTimeStep);
        for(MInt i = 0; i < nDim; i++) {
          m_bodyVelocity[i] = m_VVInfinity[i];
          m_bodyCenter[i] += deltaT * m_bodyVelocity[i];
        }
        break;
      }

      // inline oscillating cylinder
      case 403: {
        const MFloat KC = 5.0;
        const MFloat frequency = m_UInfinity / KC;

        m_bodyVelocity[0] = KC * frequency * cos(F2 * PI * frequency * m_time);
        m_bodyVelocity[1] = F0;
        m_bodyCenter[0] = KC / (F2 * PI) * sin(F2 * PI * frequency * m_time);
        m_bodyCenter[1] = F0;

        break;
      }


      case 466: {
        break;
      }

      default: {
        // const MFloat deltaT = m_dualTimeStepping ? m_physicalTimeStep : timeStep();
        const MFloat deltaT = m_physicalTime - m_physicalTimeDt1;
        for(MInt i = 0; i < nDim; i++) {
          m_bodyCenter[nDim * body + i] = m_bodyCenterDt1[nDim * body + i] + deltaT * m_bodyVelocity[nDim * body + i];
        }

        break;
      }

      // cylinder drifiting in uniform flow
      case 474: {
        for(MInt i = 0; i < nDim; i++) {
          m_bodyCenter[i] = F0;
          m_bodyVelocity[i] = F0;
          m_bodyAcceleration[i] = F0;
        }
        m_bodyCenter[0] = m_UInfinity * m_physicalTime;
        m_bodyVelocity[0] = m_UInfinity;
        break;
      }

      // cylinder towed through quiescent fluid
      case 475: {
        for(MInt i = 0; i < nDim; i++) {
          m_bodyCenter[i] = F0;
          m_bodyVelocity[i] = F0;
          m_bodyAcceleration[i] = F0;
        }
        const MFloat T1 = 20.0;
        const MFloat t = m_physicalTime / T1;
        if(t > F1) {
          m_bodyCenter[0] = m_UInfinity * (m_physicalTime - F1B2 * T1);
          m_bodyVelocity[0] = m_UInfinity;
          m_bodyAcceleration[0] = F0;
        } else {
          m_bodyCenter[0] = m_UInfinity * POW3(t) * T1 * (F1 - F1B2 * t);
          m_bodyVelocity[0] = m_UInfinity * POW2(t) * (F3 - F2 * t);
          m_bodyAcceleration[0] = m_UInfinity * F6 * t * (F1 - t) / T1;
        }
        break;
      }

      case 450: {
        // transversely oscillating cylinder
        MFloat ddt = F0;
        MFloat elapsedTime = m_physicalTime + ddt;
        const MFloat D = F2 * m_bodyRadius[0];
        MFloat amplitudeFactor = 0.1;
        amplitudeFactor = Context::getSolverProperty<MFloat>("amplitudeFactor", m_solverId, AT_, &amplitudeFactor);
        MFloat freqFactor = F1;
        freqFactor = Context::getSolverProperty<MFloat>("freqFactor", m_solverId, AT_, &freqFactor);
        MFloat Strouhal = 0.2;
        Strouhal = Context::getSolverProperty<MFloat>("Strouhal", m_solverId, AT_, &Strouhal);
        const MFloat A = amplitudeFactor * D;
        const MFloat freq0 = Strouhal * m_UInfinity / m_referenceLength;
        const MFloat mu = freqFactor * freq0 * F2 * PI;

        /*
          m_bodyCenter[1]       = A *             sin( mu * elapsedTime );
          m_bodyVelocity[1]     = mu * A *        cos( mu * elapsedTime );
          m_bodyAcceleration[1] = -mu * mu * A *  sin( mu * elapsedTime );
        */

        MFloat dt = timeStep() * ((MFloat)Context::getSolverProperty<MInt>("outputOffset", m_solverId, AT_));
        dt = F0;

        elapsedTime -= dt;

        m_bodyVelocityDt1[1] = m_bodyVelocity[1];
        m_bodyCenterDt1[1] = m_bodyCenter[1];

        if(elapsedTime > F0) {
          m_bodyCenter[1] =
              -A * cos(mu * elapsedTime); // cerr << globalTimeStep<< " " << m_RKStep << " " << m_bodyCenter[1] << endl;
          m_bodyVelocity[1] = mu * A * sin(mu * elapsedTime);
          m_bodyAcceleration[1] = mu * mu * A * cos(mu * elapsedTime);
        } else {
          m_bodyCenter[1] = -A;
          m_bodyVelocity[1] = F0;
          m_bodyAcceleration[1] = F0;
        }

        break;
      }

      case 451:
      case 470:
      case 471: {
        ScratchSpace<MFloat> globalMI(3 * m_noEmbeddedBodies, AT_, "globalMI");
        // for ( MInt k = 0; k < m_noEmbeddedBodies; k++ ) {
        const MInt k = body;
        for(MInt i = 0; i < 3; i++) {
          globalMI[3 * k + i] = F0;
          m_bodyMomentOfInertia[3 * k + i] = F0;
        }
        for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
          MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
          if(a_associatedBodyIds(cellId, 0) != k) continue;
          if(a_isHalo(cellId)) continue;
          if(a_isBndryGhostCell(cellId)) continue;
          MFloat dx[3] = {F0, F0, F0};
          MFloat normal[3] = {F0, F0, F0};
          MFloat fac[3] = {F0, F0, F0};
          for(MInt i = 0; i < nDim; i++) {
            dx[i] = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[i] - m_bodyCenter[nDim * k + i];
            normal[i] = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i];
          }
          IF_CONSTEXPR(nDim == 3) {
            fac[0] = normal[1] * POW3(dx[1]) + normal[2] * POW3(dx[2]);
            fac[1] = normal[0] * POW3(dx[0]) + normal[2] * POW3(dx[2]);
          }
          fac[2] = normal[0] * POW3(dx[0]) + normal[1] * POW3(dx[1]);
          MFloat area = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_area;
          for(MInt i = 0; i < 3; i++) {
            m_bodyMomentOfInertia[3 * k + i] += area * fac[i];
          }
        }
        for(MInt i = 0; i < 3; i++) {
          m_bodyMomentOfInertia[3 * k + i] *= F1B3 * m_bodyDensity[k];
          m_log << "BMI " << k << " " << i << " " << m_bodyMomentOfInertia[3 * k + i] << endl;
          /*      MFloat momi = F2/F5*POW2(0.5)*m_rhoInfinity*PI*F1B6;
          cerr << "MOMI: " << k << " " << i << " " << m_bodyMomentOfInertia[ 3*k+i ] << " " << momi << " " <<
          m_bodyMomentOfInertia[ 3*k+i ]/momi
            //<< " " << m_fvBndryCnd->m_bndryCells->size() << " " << F1B3*test << " " << F1B6*PI
               << endl;
  */
        }
        //}
        // MPI_Allreduce( m_bodyMomentOfInertia, globalMI.begin(), 3*m_noEmbeddedBodies, MPI_DOUBLE, MPI_SUM, mpiComm(),
        // AT_, "m_bodyMomentOfInertia", "globalMI.begin()" ); for ( MInt k = 0; k < m_noEmbeddedBodies; k++ ) {
        //  for( MInt i = 0; i < 3; i++ ) {
        //    m_bodyMomentOfInertia[ 3*k+i ] = globalMI[ 3*k+i ];
        //  }
        MPI_Allreduce(MPI_IN_PLACE, &(m_bodyMomentOfInertia[3 * k]), 3, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_,
                      "MPI_IN_PLACE", "(m_bodyMomentOfInertia[3*k])");

        break;
      }


      case 452: {
        // inline oscillating sphere in stratified fluid

        MFloat KC = F0;
        /*! \page propertiesFVMB
          \section KeuleganCarpenter
          <code>MFloat FvMbCartesianSolverXD::updateBodyProperties::KC</code>\n
          default = <code>0</code>\n
          Keulegan Carpenter number (period number) of a sinusoidally oscillating sphere in stratified fluid in case
          452.\n Describes relative importance of drag forces over inertia forces in oscillatory flow. Possible values
          are: <ul> <li>non-negative values </li> !!
          </ul>
          Keywords: <i>FINITE VOLUME, MOVING BOUNDARY, OSCILLATING SPHERE, KEULEGAN CARPENTER</i>
        */
        KC = Context::getSolverProperty<MFloat>("KeuleganCarpenter", m_solverId, AT_, &KC);

        /*! \page propertiesFVMB
          \section nonDimensionalFreq
          <code>MFloat FvMbCartesianSolverXD::updateBodyProperties::Sf</code>\n
          default = <code>0</code>\n
          Strouhal number of a sinusoidally oscillating sphere in stratified fluid in case 452.\n
          Possible values are:
          <ul>
            <li>values > 0 and < O(referenceLength/(timeStep*UInfinity)) </li>
          </ul>
          Keywords: <i>FINITE VOLUME, MOVING BOUNDARY, OSCILLATING SPHERE, STROUHAL NUMBER</i>
        */
        MFloat Sf = F0;
        Sf = Context::getSolverProperty<MFloat>("nonDimensionalFreq", m_solverId, AT_, &Sf);

        const MFloat elapsedTime = m_physicalTime;
        const MFloat freq = Sf * m_UInfinity / m_referenceLength;
        const MFloat mu = F2 * PI * freq;
        const MFloat A = m_referenceLength * KC;

        m_bodyCenter[0] = A * sin(mu * elapsedTime);
        m_bodyVelocity[0] = mu * A * cos(mu * elapsedTime);
        m_bodyAcceleration[0] = -mu * mu * A * sin(mu * elapsedTime);

        break;
      }


      case 453: {
        IF_CONSTEXPR(nDim == 2) {
          const MFloat t = m_time + timeStep() * m_timeRef;
          m_bodyCenter[0] = -0.125 * cos(F2 * PI * t);
          m_bodyVelocity[0] = m_timeRef * 0.25 * PI * sin(F2 * PI * t);
          m_bodyAcceleration[0] = m_timeRef * m_timeRef * 0.5 * PI * PI * cos(F2 * PI * t);
          /*
                  const MFloat          A               = amplitudeFactor * D;
              const MFloat          freq0           = Strouhal * m_UInfinity / m_referenceLength;
              const MFloat          mu              = freqFactor * freq0 * F2 * PI;
                m_bodyCenter[1]                                     = -A *            cos( mu * elapsedTime );
                m_bodyVelocity[1]                                   = mu * A *        sin( mu * elapsedTime );
                m_bodyAcceleration[1]                               = mu * mu * A *   cos( mu * elapsedTime );
          */
          break;
        }

        // inline oscillating   sphere, quiescent flow
        /*! \page propertiesFVMB
          \section StokesNumber
          <code>MFloat fvmbcartesiansolverxd::StokesNumber </code>\n
          default = <code>F4</code>\n \n
          The Stokes number is a dimensionless number characterising the behavior of particles suspended in a fluid
        flow. The Stokes number is defined as the ratio of the characteristic time of a particle (or droplet) to a
        characteristic time of the flow or of an obstacle StokesNumber in fvmbcartesiansolverxd.h updateBodyProperties
        for oscillating sphere, quiescent flow
        1. used to compute Strouhal number
        2. used to compute one constant velocity
          possible values are:
          <ul>
          <li> Any non-negative float value</li>
          </ul>
          Keywords: <i> oscillating sphere, quiescent flow  </i>
        */
        MFloat StokesNumber = F4;
        StokesNumber = Context::getSolverProperty<MFloat>("StokesNumber", m_solverId, AT_, &StokesNumber);

        const MFloat Strouhal = F4 * POW2(StokesNumber) / m_Re;

        // const MFloat elapsedTime = m_physicalTime+timeStep();
        const MFloat elapsedTime = m_physicalTime;
        const MFloat freq = F2 * Strouhal * m_UInfinity / m_referenceLength;

        MBool& firstRun = m_static_updateBodyProperties_c453_firstRun;
        if(firstRun) {
          cerr << StokesNumber << " " << Strouhal << " " << m_Re << " " << sysEqn().m_Re0 << endl;
          firstRun = false;
        }

        m_bodyCenter[0] = -m_UInfinity * cos(freq * elapsedTime) / freq;
        m_bodyVelocity[0] = m_UInfinity * sin(freq * elapsedTime);
        m_bodyAcceleration[0] = freq * m_UInfinity * cos(freq * elapsedTime);

        const MFloat t = m_physicalTime;
        const MFloat w = F2 * m_Ma * F4 * POW2(StokesNumber) / m_Re;
        m_bodyCenter[0] = -m_Ma * cos(w * t) / w;
        m_bodyVelocity[0] = m_Ma * sin(w * t);
        m_bodyAcceleration[0] = m_Ma * w * cos(w * t);

        /*
        //m_bodyCenter[0] = 0.5 - m_UInfinity * sin( freq * elapsedTime ) / freq;
        m_bodyCenter[0] = - m_UInfinity * sin( freq * elapsedTime ) / freq;
        m_bodyVelocity[0] = - m_UInfinity * cos( freq * elapsedTime );
        m_bodyAcceleration[0] = freq * m_UInfinity *  sin( freq * elapsedTime );
        */
        break;
      }


      case 458: {
        // instantaneously accelerated sphere, inviscid flow
        const MFloat speedOfSoundInf = sysEqn().speedOfSound(m_rhoInfinity, m_PInfinity);
        const MFloat T0 = 100;
        const MFloat T1 = T0 + 20.0 * m_bodyRadius[0] / speedOfSoundInf;
        const MFloat elapsedTime = m_physicalTime + timeStep();
        const MFloat alpha = 6e-4;
        const MFloat accel = -alpha * POW2(speedOfSoundInf) / m_bodyRadius[0];

        if(elapsedTime < T0) {
          m_bodyCenter[0] = F0;
          m_bodyVelocity[0] = F0;
          m_bodyAcceleration[0] = F0;
        } else if(elapsedTime < T1) {
          m_bodyAcceleration[0] = accel;
          m_bodyVelocity[0] = accel * (elapsedTime - T0);
          m_bodyCenter[0] = F1B2 * accel * POW2(elapsedTime - T0);
        } else {
          m_bodyAcceleration[0] = F0;
          m_bodyCenter[0] = F1B2 * accel * POW2(T1 - T0) + m_bodyVelocity[0] * (elapsedTime - T1);
        }

        break;
      }


      case 460: {
        // instantaneously accelerated sphere in quiescent flow

        const MFloat elapsedTime = m_physicalTime + timeStep();
        m_bodyAcceleration[0] = F0;
        m_bodyVelocity[0] = m_Ma;
        m_bodyCenter[0] = elapsedTime * m_Ma;

        break;
      }

      case 461: {
        MBool oscil = false;

        // pitching NACA0012

        // const MFloat t = m_physicalTime + timeStep();
        if(m_euler) {
          /*
          const MFloat t0 = F0;
          const MFloat t = mMax( F0, m_time + (timeStep()*m_timeRef) - t0 );
          MFloat f = 0.0814*m_UInfinity/PI; //62.5
          MFloat w = F2*PI*f;
          m_bodyAngularVelocity[2] = -m_timeRef*( 2.51*w*cos(w*t) )*PI/180.0;
          m_bodyAngularAcceleration[2] = -m_timeRef*m_timeRef*( -2.51*w*w*sin(w*t) )*PI/180.0;
          */
          const MFloat degToRad = -PI / 180.0;
          const MFloat t = m_physicalTime + timeStep();
          // const MFloat ainf = sqrt( m_TInfinity );
          MFloat f = 0.0814;
          // MFloat w = F2*f*m_Ma;
          MFloat w = F2 * f * m_UInfinity;
          MFloat a0 = 0.016;
          MFloat a1 = 2.51;
          /*
          a0 = 2.0;
          a1 = 2.5;
          w = F2*PI*0.05*ainf;
          */
          bodyRotation[2] = (a0 + a1 * sin(w * t)) * degToRad;
          m_bodyAngularVelocity[2] = (a1 * w * cos(w * t)) * degToRad;
          m_bodyAngularAcceleration[2] = (-a1 * w * w * sin(w * t)) * degToRad;
        } else if(oscil) {
          /*
          const MFloat t0 = 2.5;
          const MFloat t = mMax( F0, m_time + (timeStep()*m_timeRef) - t0 );
          const MFloat f = 0.25;
          const MFloat a0 = 10.0;
          const MFloat a1 = 10.0;
          const MFloat w = F2*f*m_UInfinity/m_referenceLength;
          m_bodyAngularVelocity[2] = -m_timeRef*( w*a1*sin(w*t) )*PI/180.0;
          m_bodyAngularAcceleration[2] = -m_timeRef*m_timeRef*( w*w*a1*cos(w*t) )*PI/180.0;
          */
          const MFloat degToRad = -PI / 180.0;
          const MFloat t0 = 12.5;
          const MFloat t = mMax(F0, m_physicalTime + timeStep() - t0);
          const MFloat f = 0.25;
          const MFloat a0 = 10.0;
          // const MFloat a1 = 10.0;
          const MFloat w = F2 * m_UInfinity * f;
          /*
          m_bodyAngularVelocity[2] = -( w*a1*sin(w*t) )*PI/180.0;
          m_bodyAngularAcceleration[2] = -( w*w*a1*cos(w*t) )*PI/180.0;
          */
          bodyRotation[2] = (a0 * (F1 - cos(w * t))) * degToRad;
          m_bodyAngularVelocity[2] = (a0 * w * sin(w * t)) * degToRad;
          m_bodyAngularAcceleration[2] = (a0 * w * w * cos(w * t)) * degToRad;
        } else {
          const MFloat degToRad = -PI / 180.0;
          const MFloat fac = m_UInfinity / m_Ma;
          const MFloat b = 2.2918312 * fac;
          const MFloat c = 1.84 * fac;
          const MFloat a = -b / c;
          const MFloat t0 = 15.0; // 20.12;//15.0;//20.0;//15.32;//62.8;//25.0;
          const MFloat t = mMax(F0, m_physicalTime + timeStep() - t0);

          // see Visbal and Shang 1989.
          MFloat factor = 0.2;
          factor = Context::getSolverProperty<MFloat>("freqFactor", m_solverId, AT_, &factor);
          MFloat t0p = 0.5;
          t0p = Context::getSolverProperty<MFloat>("amplitudeFactor", m_solverId, AT_, &t0p);

          if((t < m_eps) || (fabs(factor) < m_eps)) {
            bodyRotation[2] = F0;
            m_bodyAngularVelocity[2] = F0;
            m_bodyAngularAcceleration[2] = F0;
            break;
          }

          bodyRotation[2] = (b * t + a * (F1 - exp(-c * t))) * degToRad;
          m_bodyAngularVelocity[2] = (b + a * c * exp(-c * t)) * degToRad;
          m_bodyAngularAcceleration[2] = (-a * c * c * exp(-c * t)) * degToRad;

          const MFloat omega0 = -factor * m_UInfinity;
          const MFloat it0 = 4.6 * m_UInfinity / t0p;
          const MFloat et = exp(-it0 * t);

          bodyRotation[2] = omega0 * (t + (et - F1) / it0);
          m_bodyAngularVelocity[2] = omega0 * (F1 - et);
          m_bodyAngularAcceleration[2] = omega0 * it0 * et;
        }

        if(globalTimeStep % 100 == 0)
          cerr << globalTimeStep << " alpha " << -bodyRotation[2] * 180 / PI
               << " deg, TE:" << cos(bodyRotation[2]) * 0.75 << "/" << sin(bodyRotation[2]) * 0.75 << endl;

        break;
      }


      case 455: {
        MFloat A = 0.1 * (F2 * m_bodyRadius[0]);
        MFloat f = 1.0;
        MFloat C = f * F2 * PI * m_UInfinity;
        // const MFloat t = m_time + timeStep()*m_timeRef;
        const MFloat t = m_physicalTime + timeStep();
        m_bodyCenter[0] = -A * cos(C * t);
        m_bodyVelocity[0] = A * C * sin(C * t);
        m_bodyAcceleration[0] = A * POW2(C) * cos(C * t);
        break;


        // inline oscillating   cylinder,       quiescent flow
        MFloat elapsedTime = m_physicalTime;
        //     const MFloat          D           = F2 * m_bodyRadius;
        //   const MFloat          A           = m_UInfinity;//0.05 * D;
        MFloat freq0 = F2 * PI * m_UInfinity; // F1;// * m_UInfinity / m_referenceLength;
        // const MFloat          mu          = F1;//freq0 * F2 * PI;

        /*
          m_bodyCenter[0]       = A *             sin( mu * elapsedTime );
          m_bodyVelocity[0]     = mu * A *        cos( mu * elapsedTime );
          m_bodyAcceleration[0] = -mu * mu * A *  sin( mu * elapsedTime );
        */
        /*
          m_bodyCenter[0]       = -A *            cos( mu * elapsedTime );
          m_bodyVelocity[0]     = mu * A *        sin( mu * elapsedTime );
          m_bodyAcceleration[0] = mu * mu * A *   cos( mu * elapsedTime );
        */

        freq0 = m_UInfinity / 0.1;
        m_bodyCenter[0] = -m_UInfinity * cos(freq0 * elapsedTime) / freq0;
        m_bodyVelocity[0] = m_UInfinity * sin(freq0 * elapsedTime);
        m_bodyAcceleration[0] = freq0 * m_UInfinity * cos(freq0 * elapsedTime);


        MFloat a = F1 / (F2 * PI);
        MFloat w = F2 * PI * m_Ma;
        m_bodyCenter[0] = -a * cos(w * m_physicalTime);
        m_bodyVelocity[0] = a * w * sin(w * m_physicalTime);
        m_bodyAcceleration[0] = a * w * w * cos(w * m_physicalTime);
        // cerr << m_physicalTime * m_UInfinity<< " " << m_time << endl;


        MFloat factor = 1.0;
        factor = Context::getSolverProperty<MFloat>("freqFactor", m_solverId, AT_, &factor);

        freq0 = factor * F2 * PI * m_Ma;
        MBool& firstRun = m_static_updateBodyProperties_c455_firstRun;
        if(firstRun) {
          cerr << "maximum cylinder offset: " << m_Ma / freq0 << endl;
          cerr << "maximum drag coeff: " << F1B2 * PI * freq0 / m_Ma << endl;
          cerr << m_globalUpwindCoefficient << " " << m_Ma << endl;
          firstRun = false;
        }
        m_bodyCenter[0] = -m_Ma / freq0 * cos(freq0 * m_physicalTime);
        m_bodyVelocity[0] = m_Ma * sin(freq0 * m_physicalTime);
        m_bodyAcceleration[0] = freq0 * m_Ma * cos(freq0 * m_physicalTime);


        const MFloat t0 = m_physicalTime + timeStep();
        MFloat f0 = 1.0;
        MFloat w0 = F2 * PI * f0 * m_Ma / m_referenceLength;
        MFloat a0 = 0.1 * m_referenceLength;
        m_bodyCenter[0] = -a0 * cos(w0 * t0);
        m_bodyVelocity[0] = a0 * w0 * sin(w0 * t0);
        m_bodyAcceleration[0] = a0 * w0 * w0 * cos(w0 * t0);


        break;
      }


      case 456: {
        // translating cylinder, quiescent flow

        MFloat deltaT = 10.0;

        m_bodyCenter[0] = F1B2 * m_Ma / deltaT * POW2(m_physicalTime);
        m_bodyVelocity[0] = m_Ma * mMin(F1, m_physicalTime / deltaT);
        m_bodyAcceleration[0] = m_Ma / deltaT;

        if(m_physicalTime / deltaT >= F1) {
          m_bodyCenter[0] = (F1B2 * m_Ma * deltaT) + m_Ma * (m_physicalTime - deltaT);
          m_bodyVelocity[0] = m_Ma;
          m_bodyAcceleration[0] = F0;
        }
        /*
          m_bodyCenter[0] = - m_Ma * sin( PI * mMin( F1, m_physicalTime/deltaT ) );
          m_bodyVelocity[0] =  - m_Ma * cos( PI * mMin( F1, m_physicalTime/deltaT ) );
          m_bodyAcceleration[0] = m_Ma / deltaT;
        */

        m_bodyCenter[0] = m_Ma * m_physicalTime;
        m_bodyVelocity[0] = m_Ma;
        m_bodyAcceleration[0] = F0;

        break;
      }


      case 457: {
        // translating cylinder, quiescent flow

        MFloat deltaT = 250.0;

        // const MFloat x0 = -0.001430000000000000000;//-0.001429640000000000000;
        // const MFloat x1 = -0.001429600000000000000;

        // small<->regular cell
        // 1e-12
        const MFloat x0 = 0.002332491063; // 0.002332491; //regular 31366
        const MFloat x1 = 0.002332491064; // 0.002332492; //small

        // emerging/submerging cell
        // const MFloat x0 = -0.00168832 ; //cell 31502 present;
        // const MFloat x1 = -0.00168826 ; // cell absent


        m_bodyVelocity[0] = F0;
        m_bodyAcceleration[0] = F0;
        m_bodyCenter[0] = x0;

        if(m_time / deltaT >= F1) {
          m_bodyCenter[0] = x1;

          MBool& firstTime = m_static_updateBodyProperties_firstTime;
          if(firstTime) {
            cerr << "switch applied now (delta_x=" << x1 - x0 << ", u/u_0=" << (x1 - x0) / (timeStep() * m_UInfinity)
                 << ", delta_x/h=" << (x1 - x0) / (c_cellLengthAtLevel(m_lsCutCellBaseLevel))
                 << ", accel=" << (x1 - x0) * m_referenceLength / POW2(timeStep() * m_UInfinity) << ")" << endl;
            m_bodyVelocity[0] = (x1 - x0) / timeStep();
            m_bodyAcceleration[0] = (m_bodyVelocity[0] - m_bodyVelocityDt1[0]) / timeStep();

            MFloat Cd = F1B4 * PI * m_referenceLength * (x1 - x0) / POW2(timeStep() * m_UInfinity);
            cerr << "C_d: " << Cd << endl;
            firstTime = false;
          }
        }


        break;
      }
    }

    // update rotation
    setBodyQuaternions(body, bodyRotation);
  }
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::computeBodyMomentOfInertia() {
  TRACE();

  ScratchSpace<MFloat> globalMI(3 * m_noEmbeddedBodies, AT_, "globalMI");

  for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
    for(MInt i = 0; i < 3; i++) {
      globalMI[3 * k + i] = F0;
      m_bodyMomentOfInertia[3 * k + i] = F0;
    }

    for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
      MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
      if(a_associatedBodyIds(cellId, 0) != k) continue;
      if(a_isHalo(cellId)) continue;
      if(a_isBndryGhostCell(cellId)) continue;
      for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        MFloat dx[3] = {F0, F0, F0};
        MFloat normal[3] = {F0, F0, F0};
        MFloat fac[3] = {F0, F0, F0};
        for(MInt i = 0; i < nDim; i++) {
          dx[i] = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i] - m_bodyCenter[nDim * k + i];
          normal[i] = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
        }
        IF_CONSTEXPR(nDim == 3) {
          fac[0] = normal[1] * POW3(dx[1]) + normal[2] * POW3(dx[2]);
          fac[1] = normal[0] * POW3(dx[0]) + normal[2] * POW3(dx[2]);
        }
        fac[2] = normal[0] * POW3(dx[0]) + normal[1] * POW3(dx[1]);
        MFloat area = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;

        for(MInt i = 0; i < 3; i++) {
          m_bodyMomentOfInertia[3 * k + i] += area * fac[i];
        }
      }

      for(MInt i = 0; i < 3; i++) {
        m_bodyMomentOfInertia[3 * k + i] *= F1B3 * m_bodyDensity[k];
      }
    }
  }
  MPI_Allreduce(m_bodyMomentOfInertia, globalMI.begin(), 3 * m_noEmbeddedBodies, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_,
                "m_bodyMomentOfInertia", "globalMI.begin()");

  for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
    for(MInt i = 0; i < 3; i++) {
      m_bodyMomentOfInertia[3 * k + i] = globalMI[3 * k + i];
    }
  }
}


/**
 * \brief computes the time step
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::adaptTimeStep() {
  TRACE();

  if(m_timeStepAdaptationStart < 0 || m_timeStepAdaptationEnd < 0) return;

  if(globalTimeStep > m_timeStepAdaptationEnd) {
    m_cfl = m_cflTarget;
  } else if(globalTimeStep < m_timeStepAdaptationStart) {
    m_cfl = m_cflInitial;
  } else {
    const MFloat t = (MFloat)globalTimeStep;
    const MFloat t0 = (MFloat)m_timeStepAdaptationStart;
    const MFloat t1 = (MFloat)m_timeStepAdaptationEnd;
    m_cfl = m_cflInitial + (t - t0) * (m_cflTarget - m_cflInitial) / (t1 - t0);
    m_log << "Adapted CFL number: " << m_cfl << " at time step " << globalTimeStep << ";" << endl;
  }
}


/**
 * \brief computes the cross product c <- (a x b) for a, b, c in R^3
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
inline void FvMbCartesianSolverXD<nDim, SysEqn>::crossProduct(MFloat* c, MFloat* a, MFloat* b) {
  c[0] = a[1] * b[2] - a[2] * b[1];
  c[1] = a[2] * b[0] - a[0] * b[2];
  c[2] = a[0] * b[1] - a[1] * b[0];
}


/**
 * \fn void FvMbCartesianSolverXD<nDim, SysEqn>::generateBndryCellsMb(MInt mode)
 * \brief call all routines necessary for the generation of boundary cells
 * mode = -1: default argument, regular call (each time step)
 * mode =  0: reinit after mesh adaptation
 * mode =  1: initial call before first time step
 * mode =  2: reinit after load balancing (depricated)
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::generateBndryCellsMb(const MInt mode) {
  TRACE();

  ASSERT(a_noCells() == c_noCells(), "");
  ASSERT(m_fvBndryCnd->m_bndryCells->size() == m_noOuterBndryCells, "");

  NEW_SUB_TIMER_STATIC(tInit, "init", m_tCutGroup);
  NEW_SUB_TIMER_STATIC(tCutFaceNew, "cutFaceNew", m_tCutGroup);
  NEW_SUB_TIMER_STATIC(tCutPointNew, "cutPoint", m_tCutGroup);
  NEW_SUB_TIMER_STATIC(tReinit, "reinit", m_tCutGroup);
  NEW_SUB_TIMER_STATIC(tMassRedist, "massRedist", m_tCutGroup);
  RECORD_TIMER_START(tInit);

  // reset the states if we are doing FSI iterations
  if(m_structureStep > 0 && mode != 2) {
    for(map<MInt, vector<MFloat>>::iterator it = m_nearBoundaryBackup.begin(); it != m_nearBoundaryBackup.end(); it++) {
      const MInt cellId = it->first;
      a_cellVolume(cellId) = (it->second)[0];
      m_cellVolumesDt1[cellId] = (it->second)[0];
      for(MInt v = 0; v < m_noCVars; v++) {
        a_oldVariable(cellId, v) = (it->second)[1 + v];
      }
      for(MInt v = 0; v < m_noFVars; v++) {
        m_rhs0[cellId][v] = (it->second)[1 + m_noCVars + v];
      }
    }
  }

  if(m_bodyTypeMb && m_constructGField) {
    setupBoundaryCandidatesAnalytical();
  } else {
    determineBndryCandidates();
    computeNodalLSValues();
    checkCellState(); // sets isInactice property correctly based on nodal Ls-values:
  }
  RECORD_TIMER_STOP(tInit);

  // add moving-bndry bndry-Cells
  RECORD_TIMER_START(tCutPointNew);
  computeCutPointsMb_MGC();
  RECORD_TIMER_STOP(tCutPointNew);

  // check CutPoints and remove cutCells with less than 3 CutPoints
  m_fvBndryCnd->checkCutPointsValidity();

  // check bndryCells and candidateNodeSet
  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    const MInt cndId = m_bndryCandidateIds[cellId];
    ASSERT(cndId >= 0, "ERROR: cutCell is not a bndryCandidate? ");
    for(MInt p = 0; p < m_noCellNodes; p++) {
      ASSERT(m_candidateNodeSet[cndId * m_noCellNodes + p], "ERROR: nodeValue not set for bndryCel!");
    }
  }

  // set pointIsInside based on the corner levelSet values for all mb-bndry-Cells and
  // set/correct CellProperties for all mb-bndryCells
  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    const MInt cndId = m_bndryCandidateIds[cellId];
    ASSERT(cndId >= 0, "ERROR: cutCell is not a bndryCandidate? ");
    ASSERT(a_hasProperty(cellId, SolverCell::IsMovingBnd), "");
    MInt startSet = 0;
    MInt endSet = 1;
    if(m_noLevelSetsUsedForMb > 1 && m_complexBoundary && !a_isGapCell(cellId)) {
      startSet = 1;
      endSet = m_noLevelSetsUsedForMb;
    }

    // For all bndryCells IsInactive is set to false!
    if(a_hasProperty(cellId, SolverCell::IsInactive)) {
      cerr << "Unusual, mb-bndryCell was inactive: react " << c_globalId(cellId) << endl;
    }
    a_hasProperty(cellId, SolverCell::IsInactive) = false;

    if(c_noChildren(cellId) == 0 && (a_hasProperty(cellId, SolverCell::IsSplitChild) || c_isLeafCell(cellId))) {
      if(!a_hasProperty(cellId, SolverCell::IsNotGradient)) {
        a_hasProperty(cellId, SolverCell::IsFlux) = true;
        a_hasProperty(cellId, SolverCell::IsActive) = true;
      }
      a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = true;
    }
    a_isBndryGhostCell(cellId) = false;

    for(MInt p = 0; p < m_noCellNodes; p++) {
      m_pointIsInside[bndryId][IDX_LSSETMB(p, 0)] = false;

      for(MInt set = startSet; set < endSet; set++) {
        m_pointIsInside[bndryId][IDX_LSSETMB(p, set)] = (m_candidateNodeValues[IDX_LSSETNODES(cndId, p, set)] < F0);
        m_pointIsInside[bndryId][IDX_LSSETMB(p, 0)] =
            (m_pointIsInside[bndryId][IDX_LSSETMB(p, 0)] || m_pointIsInside[bndryId][IDX_LSSETMB(p, set)]);
      }
    }
  }

  m_gapOpened = false;
  if(m_levelSet && m_closeGaps && m_gapInitMethod == 0) setGapOpened();


  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    restoreSurfaces(m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId);
  }

  // add split-childs if necessary!
  RECORD_TIMER_START(tCutFaceNew);
  createCutFaceMb_MGC();
  RECORD_TIMER_STOP(tCutFaceNew);

#if defined _MB_DEBUG_ || !defined NDEBUG
  MInt noSplitChilds = m_totalnosplitchilds;
  MPI_Allreduce(MPI_IN_PLACE, &noSplitChilds, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "noSplitChilds");

  if(noSplitChilds > 0 && domainId() == 0) {
    cerr << "Global-Number of Split-Childs are " << noSplitChilds << endl;
  }
#endif

  // set cutFaceArea and wasInactive for splitChilds
  for(MUint sc = 0; sc < m_splitCells.size(); sc++) {
    const MInt cellId = m_splitCells[sc];
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      m_cutFaceArea[a_bndryId(cellId)][dir] = F0;
    }
    for(MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) {
      const MInt splitChildId = m_splitChilds[sc][ssc];
      for(MInt dir = 0; dir < m_noDirs; dir++) {
        m_cutFaceArea[a_bndryId(cellId)][dir] += m_cutFaceArea[a_bndryId(splitChildId)][dir];
      }
      a_hasProperty(splitChildId, SolverCell::WasInactive) = a_hasProperty(cellId, SolverCell::WasInactive);
    }
  }


  // ensure the same cutFaceArea at neighboring boundary-Cells
  for(MInt bndryId = 0; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      if(a_hasNeighbor(cellId, dir) == 0) continue;
      const MInt nghbrId = c_neighborId(cellId, dir);
      if(a_bndryId(nghbrId) > -1) {
        const MFloat a0 = m_cutFaceArea[a_bndryId(cellId)][dir];
        const MFloat a1 = m_cutFaceArea[a_bndryId(nghbrId)][m_revDir[dir]];
        m_cutFaceArea[a_bndryId(cellId)][dir] = mMax(a0, a1);
        m_cutFaceArea[a_bndryId(nghbrId)][m_revDir[dir]] = mMax(a0, a1);
      }
    }
  }

  {
    ASSERT(!m_fvBndryCnd->m_cellCoordinatesCorrected, "");
    for(MInt bndryId = 0; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
      const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
      for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance = F0;
        for(MInt i = 0; i < nDim; i++) {
          m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVectorCentroid[i] =
              m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
          m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance +=
              m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i]
              * (a_coordinate(cellId, i) + m_bndryCells->a[bndryId].m_coordinates[i]
                 - m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i]);
        }
        m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance =
            mMax(F0, m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance);
      }
    }

    constexpr MFloat dirStencil[8][3] = {{-F1, -F1, -F1}, {F1, -F1, -F1}, {-F1, F1, -F1}, {F1, F1, -F1},
                                         {-F1, -F1, F1},  {F1, -F1, F1},  {-F1, F1, F1},  {F1, F1, F1}};

    MFloatScratchSpace levelSets(m_noLevelSetsUsedForMb, AT_, "levelSets");
    for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
      // set m_gapDistance, m_centroidDistance and m_normalVectorCentroid for bndry-Cells
      const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
      levelSets.fill(std::numeric_limits<MFloat>::max());
      std::array<MFloat, nDim> coordsBak{};
      if(m_constructGField) {
        std::copy_n(&a_coordinate(cellId, 0), nDim, coordsBak.data());
        std::transform(&a_coordinate(cellId, 0), &a_coordinate(cellId, 0) + nDim,
                       &m_fvBndryCnd->m_bndryCells->a[bndryId].m_coordinates[0], &a_coordinate(cellId, 0),
                       std::plus<MFloat>());
      }
      const MInt startSet = 0;
      const MInt endSet = (m_complexBoundary && m_noLevelSetsUsedForMb > 1) ? m_noLevelSetsUsedForMb : 1;
      for(MInt set = startSet; set < endSet; set++) {
        if(a_associatedBodyIds(cellId, set) < 0) continue;
        if(m_constructGField && (m_bodyTypeMb == 1 || m_bodyTypeMb == 3)) {
          levelSets(set) = getDistance(cellId, a_associatedBodyIds(cellId, set));
        } else {
          MFloat coord[3] = {F0, F0, F0};
          for(MInt i = 0; i < nDim; i++) {
            coord[i] = m_fvBndryCnd->m_bndryCells->a[bndryId].m_coordinates[i] / c_cellLengthAtCell(cellId);
          }
          MInt cndId = (a_hasProperty(cellId, SolverCell::IsSplitChild))
                           ? m_bndryCandidateIds[getAssociatedInternalCell(cellId)]
                           : m_bndryCandidateIds[cellId];
          if(cndId < 0) mTerm(1, AT_, "candidate not found");
          for(MInt node = 0; node < m_noCellNodes; node++) {
            if(!m_candidateNodeSet[cndId * m_noCellNodes + node]) {
              mTerm(1, AT_, "candidate node not set");
            }
          }
          MFloat phi = F0;
          for(MInt node = 0; node < m_noCellNodes; node++) {
            IF_CONSTEXPR(nDim == 2) {
              phi += (F1B2 + dirStencil[node][0] * coord[0]) * (F1B2 + dirStencil[node][1] * coord[1])
                     * m_candidateNodeValues[IDX_LSSETNODES(cndId, node, set)];
            }
            else IF_CONSTEXPR(nDim == 3) {
              phi += (F1B2 + dirStencil[node][0] * coord[0]) * (F1B2 + dirStencil[node][1] * coord[1])
                     * (F1B2 + dirStencil[node][2] * coord[2])
                     * m_candidateNodeValues[IDX_LSSETNODES(cndId, node, set)];
            }
          }
          levelSets(set) = phi;
        }
        levelSets(set) = mMax(F0, levelSets(set));
      }

      MFloat phiSum = m_bndryCells->a[bndryId].m_gapDistance = std::numeric_limits<MFloat>::max();
      for(MInt p = 1; p < m_noLevelSetsUsedForMb - 1; p++) {
        for(MInt q = p + 1; q < m_noLevelSetsUsedForMb; q++) {
          phiSum = mMin(phiSum, levelSets(p) + levelSets(q));
        }
      }
      m_bndryCells->a[bndryId].m_gapDistance = phiSum;


      for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        MInt set = -1;
        for(MInt s = m_startSet; s < m_noSets; s++) {
          if(a_associatedBodyIds(cellId, s) == m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bodyId[0]) {
            set = s;
            break;
          }
        }
        if(set < 0) mTerm(1, AT_, "set not found.");

        m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance = levelSets(set);

        MFloat normal[3];
        getNormal(cellId, set, normal);

        if(bndryId > -1 && srfc > -1) {
          const MFloat vfrac = mMax(m_volumeThreshold, m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume)
                               / grid().gridCellVolume(a_level(cellId));
          const MFloat fac = maia::math::deltaFun(vfrac, 0.0, 1.0);
          MFloat cnt = F0;
          for(MInt i = 0; i < nDim; i++) {
            normal[i] = fac * normal[i] + (F1 - fac) * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
            cnt += POW2(normal[i]);
          }
          cnt = sqrt(cnt);
          for(MInt i = 0; i < nDim; i++) {
            normal[i] /= cnt;
          }
          for(MInt i = 0; i < nDim; i++) {
            m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVectorCentroid[i] = normal[i];
          }
        }
      }
      if(m_constructGField) {
        std::copy_n(coordsBak.data(), nDim, &a_coordinate(cellId, 0));
      }
    }
  }

  // read the cellVolume of bndry-Cells from the body-restart-File
  if((mode > 0) && m_restart) {
    RECORD_TIMER_STOP(m_tCutGroup);
    RECORD_TIMER_STOP(m_tCutGroupTotal);
    const MFloat time0 = MPI_Wtime();
    if(m_geometryChange == nullptr) {
      loadBodyRestartFile(1);
    } else {
      setOldGeomBndryCellVolume();
    }
    const MFloat time1 = MPI_Wtime();
    if(domainId() == 0) m_log << "loadBodyRestartFile time " << time1 - time0 << endl;
    RECORD_TIMER_START(m_tCutGroupTotal);
    RECORD_TIMER_START(m_tCutGroup);
  }

  RECORD_TIMER_START(tReinit);

  // update oldBndryCells after adaptation if they are no longer leaf cells
  // this needs to be done before deleteNeighbourLinks and after computeCutPoints
  if(mode == 0) {
    correctRefinedBndryCell();
  }

  // NOTE: the new gapInitMethod uses the minimum velocity of the two bodies which
  //      is zero for current applications!
  if(m_closeGaps && m_gapInitMethod == 0) {
    setGapCellId();
    interpolateGapBodyVelocity();
  }

  deleteNeighbourLinks();
  computeVolumeFraction();

  // determines gap-Cell-Types
  // needs the nodalLsValues to determine GapCell-States
  // at this point isactive is set correctly and neighborLinks are deleted :)
  // all cell volumes are initialised und must be updated
  //(a_cellVolume, a_FcellVolume, m_volumeFraction)
  // but split-cells are already included
  if(m_levelSet && m_closeGaps && m_gapInitMethod > 0) {
    gapHandling();
  }

  m_fvBndryCnd->createSortedBndryCellList(); // TODO labels:FVMB only update

  // Call initCutOffBC because MB bndryCells are not set in initSolutionStep
  if(mode >= 0) {
    initCutOffBoundaryCondition();
  }
  if(m_fvBndryCnd->m_createBoundaryAtCutoff && m_alwaysResetCutOff) {
    resetCutOffCells();
    m_fvBndryCnd->createBoundaryAtCutoff();
    m_fvBndryCnd->initBndryCommunications();
  }

  m_fvBndryCnd->setBCTypes(m_movingBndryCndId);
  determineNearBndryCells();
  initSpongeLayer();

  IF_CONSTEXPR(nDim == 3) {
    const MFloat deltaDomain = mMin(F1B2 * (m_bbox[nDim + 1] - m_bbox[1]), F1B2 * (m_bbox[nDim + 2] - m_bbox[2]));
    const MFloat deltaSpongePart = (Context::propertyExists("deltaSpongePart", m_solverId))
                                       ? Context::getSolverProperty<MFloat>("deltaSpongePart", m_solverId, AT_)
                                       : F0;
    const MFloat deltaSponge = mMax(F0, deltaDomain - deltaSpongePart);
    if(deltaSpongePart > F0 && deltaSponge > F0) {
      for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
        if(a_isBndryGhostCell(cellId)) continue;
        if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
        // MFloat dist = sqrt( POW2(a_coordinate( cellId , 1)-m_bodyCenter[1]) + POW2(a_coordinate( cellId ,
        // 2)-m_bodyCenter[2]) );
        MFloat dist =
            mMax(fabs(a_coordinate(cellId, 1) - m_bodyCenter[1]), fabs(a_coordinate(cellId, 2) - m_bodyCenter[2]));
        for(MUint i = 0; i < m_periodicGhostBodies[0].size(); i++) {
          MInt l = m_periodicGhostBodies[0][i];
          dist = mMin(dist, mMax(fabs(a_coordinate(cellId, 1) - m_bodyCenter[nDim * l + 1]),
                                 fabs(a_coordinate(cellId, 2) - m_bodyCenter[nDim * l + 2])));
        }
        MFloat constant = m_sigmaSponge * mMin(F1, mMax(F0, (dist - deltaSponge) / (deltaDomain - deltaSponge)));
        if(a_hasProperty(cellId, SolverCell::IsInSpongeLayer)) {
          a_spongeFactor(cellId) = mMax(a_spongeFactor(cellId), constant);
        } else if(constant > 1e-12) {
          m_cellsInsideSpongeLayer[m_noCellsInsideSpongeLayer] = cellId;
          m_noCellsInsideSpongeLayer++;
          a_hasProperty(cellId, SolverCell::IsInSpongeLayer) = true;
          a_spongeFactor(cellId) = constant;
        }
      }
    }
  }

  if(m_createSpongeBoundary) m_fvBndryCnd->createSpongeAtSpongeBndryCnds();

#ifdef _MB_DEBUG_
  checkBoundaryCells();

  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    const MFloat cellHalfLength = F1B2 * c_cellLengthAtCell(cellId);
    const MFloat deltaMax = (sqrt((MFloat)nDim) + 0.1) * cellHalfLength;
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bodyId[0] < 0) {
        cerr << ": " << domainId() << " " << srfc << " " << m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bodyId[0] << " "
             << a_associatedBodyIds(cellId, srfc) << " " << cellId << " " << c_globalId(cellId) << endl;
        mTerm(1, AT_, "body id mismatch.");
      } else if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bodyId[0]
                != a_associatedBodyIds(cellId, m_bodyToSetTable[m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bodyId[0]])) {
        cerr << ": " << domainId() << " " << srfc << " " << m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bodyId[0] << " "
             << " " << cellId << " " << c_globalId(cellId) << endl;
        mTerm(1, AT_, "body id mismatch2.");
      }
      if(m_bodyTypeMb == 1) {
        MInt k = m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bodyId[0];
        MFloat dist = F0;
        for(MInt i = 0; i < nDim; i++) {
          dist += POW2(a_coordinate(cellId, i) - m_bodyCenter[nDim * k + i]);
        }
        dist = sqrt(dist) - m_bodyRadius[k];
        if(dist > deltaMax) {
          cerr << "distance check: " << domainId() << " " << srfc << " "
               << m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bodyId[0] << " "
               << " " << cellId << " " << c_globalId(cellId) << " / " << dist << " " << deltaMax << " / "
               << a_coordinate(cellId, 0) << " " << a_coordinate(cellId, 1) << " " << a_coordinate(cellId, 2) << " / "
               << m_bodyCenter[nDim * k + 0] << " " << m_bodyCenter[nDim * k + 1] << " " << m_bodyCenter[nDim * k + 2]
               << endl;
          cerr << "body too far away, body id might be wrong." << endl;
          // mTerm(1,AT_,"body too far away, body id might be wrong.");
        }
      }
    }
  }
#endif

  // set factor and deltaX for bndry-Surfaces
  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      MInt srfcId = m_cellSurfaceMapping[cellId][dir];
      if(srfcId > -1) {
        MInt nghbrId0 = a_surfaceNghbrCellId(srfcId, 0);
        MInt nghbrId1 = a_surfaceNghbrCellId(srfcId, 1);
        ASSERT(nghbrId0 > -1 && nghbrId1 > -1, "");
        a_surfaceFactor(srfcId, 0) = F0;
        MFloat tmp = F0;
        for(MInt i = 0; i < nDim; i++) {
          a_surfaceFactor(srfcId, 0) += POW2(a_surfaceCoordinate(srfcId, i) - a_coordinate(nghbrId0, i));
          tmp += POW2(a_surfaceCoordinate(srfcId, i) - a_coordinate(nghbrId1, i));
        }
        a_surfaceFactor(srfcId, 0) = sqrt(a_surfaceFactor(srfcId, 0));
        tmp = sqrt(tmp);
        a_surfaceFactor(srfcId, 0) = tmp / (a_surfaceFactor(srfcId, 0) + tmp);
        a_surfaceFactor(srfcId, 1) = F1 - a_surfaceFactor(srfcId, 0);
        for(MInt i = 0; i < nDim; i++) {
          a_surfaceDeltaX(srfcId, i) =
              a_surfaceCoordinate(srfcId, i) - a_coordinate(a_surfaceNghbrCellId(srfcId, 0), i);
          a_surfaceDeltaX(srfcId, nDim + i) =
              a_surfaceCoordinate(srfcId, i) - a_coordinate(a_surfaceNghbrCellId(srfcId, 1), i);
        }
      }
    }
  }
  RECORD_TIMER_STOP(tReinit);


  RECORD_TIMER_START(tMassRedist);

  m_temporarilyLinkedCells.clear();
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    m_linkedWindowCells[i].clear();
    m_linkedHaloCells[i].clear();
  }

  const MInt noBCells = m_fvBndryCnd->m_bndryCells->size();
  // NOTE: first right Hand side specialty:
  if(mode == 1) { // firstRun => first right hand side
    // set wasInactive just as isInactive as no information of previous timestep is available
    for(MUint c = 0; c < m_bndryLayerCells.size(); c++) {
      MInt cellId = m_bndryLayerCells[c];
      a_hasProperty(cellId, SolverCell::WasInactive) = a_hasProperty(cellId, SolverCell::IsInactive);
    }

    // set volume purely based on bndryCell-volume which was previously set from file the restartFile!
    for(MInt bndryId = 0; bndryId < noBCells; bndryId++) {
      const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
      a_cellVolume(cellId) = mMax(m_volumeThreshold, m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume);
      a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
      m_cellVolumesDt1[cellId] = a_cellVolume(cellId);
      if(m_dualTimeStepping) m_cellVolumesDt2[cellId] = a_cellVolume(cellId);
    }

  } else if(mode == 2) {
    for(MUint c = 0; c < m_bndryLayerCells.size(); c++) {
      MInt cellId = m_bndryLayerCells[c];
      a_hasProperty(cellId, SolverCell::WasInactive) = a_hasProperty(cellId, SolverCell::IsInactive);
    }
    for(MInt bndryId = 0; bndryId < noBCells; bndryId++) {
      MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
      a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
    }
  } else { // mode == 0 || mode == -1

#if defined _MB_DEBUG_ || !defined NDEBUG
    checkHaloBndryCells(false);
    // m_sweptVolume is beeing updated and checked below!
#endif

    linkBndryCells();

    // initialize bndry-Cells
    for(MInt bndryId = m_noOuterBndryCells; bndryId < noBCells; bndryId++) {
      const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
      if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
      if(a_hasProperty(cellId, SolverCell::WasInactive)) {
        // a) new boundary cell: was inactive before and is active now:

        // no mass at the previous time step, this is conservative
        m_cellVolumesDt1[cellId] = F0;
        if(m_dualTimeStepping) m_cellVolumesDt2[cellId] = F0;
        m_sweptVolumeDt1[bndryId] = F0;
        for(MInt v = 0; v < m_noFVars; v++) {
          a_rightHandSide(cellId, v) = F0;
          m_rhs0[cellId][v] = F0;
        }

      } else { // was-active
        if(m_oldBndryCells.count(cellId)) continue;
        // b) cell which was an internal-Cell before

        if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
        // if ( a_isHalo( cellId ) ) continue;
        if(m_cellVolumesDt1[cellId] < grid().gridCellVolume(a_level(cellId))) {
          // if the cell wasn't a boundary-cell before,
          // it can't have been a cut cell and its volume
          // should equal the grid-volume!


          cerr << endl
               << "*************** Strange behavior " << domainId() << " " << globalTimeStep << " " << cellId << " "
               << c_globalId(cellId) << " /wi " << a_hasProperty(cellId, SolverCell::WasInactive) << " /ii "
               << a_hasProperty(cellId, SolverCell::IsInactive) << " /l " << a_level(cellId) << " /v "
               << m_cellVolumesDt1[cellId] / grid().gridCellVolume(a_level(cellId)) << " "
               << (grid().gridCellVolume(a_level(cellId)) - m_cellVolumesDt1[cellId])
                      / grid().gridCellVolume(a_level(cellId))
               << " " << m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume / grid().gridCellVolume(a_level(cellId))
               << " /h " << a_hasProperty(cellId, Cell::IsHalo) << " /sl "
               << a_hasProperty(cellId, SolverCell::IsSplitCell) << " /sd "
               << a_hasProperty(cellId, SolverCell::IsSplitChild) << " " << m_sweptVolumeDt1[bndryId] << " "
               << a_bndryId(cellId) << " " << globalTimeStep << " " << a_levelSetValuesMb(cellId, 0) << " "
               << m_oldBndryCells.size() << " " << m_oldBndryCells.count(cellId) << " "
               << m_nearBoundaryBackup.count(cellId) << endl
               << endl;
          if(m_cellVolumesDt1[cellId] < 0.9 * grid().gridCellVolume(a_level(cellId))) {
            mTerm(1, AT_, "strange behavior.");
          }
        }
        m_sweptVolumeDt1[bndryId] = F0;
        // cellVolumeDt1 should be gridCellVolume
      }
    }
  }

#if defined _MB_DEBUG_ || !defined NDEBUG
  if(noNeighborDomains() > 0) {
    ScratchSpace<MLong> gid(a_noCells(), AT_, "gid");
    gid.fill((MLong)-2);
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      for(MInt j = 0; j < (signed)m_linkedHaloCells[i].size(); j++) {
        MInt cellId = m_linkedHaloCells[i][j];
        gid(cellId) = c_globalId(cellId);
      }
    }
    MUint recvSize = maia::mpi::getBufferSize(grid().windowCells());
    ScratchSpace<MLong> recvBuffer(mMax(1u, recvSize), AT_, "recvBuffer");
    maia::mpi::reverseExchangeData(grid().neighborDomains(), grid().haloCells(), grid().windowCells(), mpiComm(),
                                   &gid(0), &recvBuffer[0]);
    recvSize = 0;

    for(MInt i = 0; i < noNeighborDomains(); i++) {
      MUint commCnt = 0;
      for(MInt j = 0; j < noWindowCells(i); j++) {
        MInt cellId = windowCellId(i, j);
        if(recvBuffer(recvSize) != -2 && c_globalId(cellId) != recvBuffer(recvSize))
          cerr << c_globalId(cellId) << " " << recvBuffer(recvSize) << endl;
        if(recvBuffer(recvSize) != -2 && c_globalId(cellId) != recvBuffer(recvSize))
          mTerm(1, AT_, "linked halo cell connection failed.");
        if(recvBuffer(recvSize) != -2) {
          ASSERT(recvBuffer(recvSize) > -1, "");
          // Same window can be used as master more than once
          for(MInt p = 0; p < (signed)m_linkedWindowCells[i].size(); p++) {
            if(c_globalId(m_linkedWindowCells[i][p]) == recvBuffer(recvSize)) commCnt++;
          }
        }
        recvSize++;
      }
      if(commCnt != m_linkedWindowCells[i].size()) {
        cerr << domainId() << ": ERR LINK " << neighborDomain(i) << " " << commCnt << " "
             << m_linkedWindowCells[i].size() << endl;
        for(MInt j = 0; j < (signed)m_linkedWindowCells[i].size(); j++) {
          cerr << domainId() << " LW " << j << " " << m_linkedWindowCells[i][j] << " "
               << c_globalId(m_linkedWindowCells[i][j]) << endl;
        }
        for(MInt j = 0; j < (signed)m_linkedHaloCells[i].size(); j++) {
          cerr << domainId() << " LH " << j << " " << m_linkedHaloCells[i][j] << " "
               << c_globalId(m_linkedHaloCells[i][j]) << endl;
        }
        // mTerm(1,AT_, "linked halo cell connection failed (2).");
      }
    }
  }

#endif

  // a) initialise swetVolumeDt for all bndryCells with 0
  for(MInt bndryId = m_noOuterBndryCells; bndryId < noBCells; bndryId++) {
    m_sweptVolumeDt1[bndryId] = F0;
  }

  // b) restore swetVolumeDt from oldBndryCells
  for(map<MInt, MFloat>::iterator it = m_oldBndryCells.begin(); it != m_oldBndryCells.end(); it++) {
    if(a_bndryId(it->first) > -1) {
      m_sweptVolumeDt1[a_bndryId(it->first)] = it->second;
    }
  }

  // c) initialise swetVolume for all bndryCells with 0
  for(MInt bndryId = m_noOuterBndryCells; bndryId < noBCells; bndryId++) {
    m_sweptVolume[bndryId] = F0;
  }

  // d) initialise CellVolumes for splitChilds, based on split-Cell Volumes
  for(MUint sc = 0; sc < m_splitCells.size(); sc++) {
    const MInt cellId = m_splitCells[sc];
    MFloat cvol = F0;
    for(MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) {
      const MInt splitChildId = m_splitChilds[sc][ssc];
      MFloat vol = m_fvBndryCnd->m_bndryCells->a[a_bndryId(splitChildId)].m_volume;
      cvol += vol;
      a_cellVolume(splitChildId) = vol * a_cellVolume(cellId);
      m_cellVolumesDt1[splitChildId] = vol * m_cellVolumesDt1[cellId];
      m_sweptVolume[a_bndryId(splitChildId)] = vol * m_sweptVolume[a_bndryId(cellId)];
      m_sweptVolumeDt1[a_bndryId(splitChildId)] = vol * m_sweptVolumeDt1[a_bndryId(cellId)];
      for(MInt v = 0; v < m_noFVars; v++) {
        m_rhs0[splitChildId][v] = vol * m_rhs0[cellId][v];
      }
    }
    cvol = mMax(1e-15, cvol);
    for(MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) {
      const MInt splitChildId = m_splitChilds[sc][ssc];
      a_cellVolume(splitChildId) /= cvol;
      m_cellVolumesDt1[splitChildId] /= cvol;
      m_sweptVolume[a_bndryId(splitChildId)] /= cvol;
      m_sweptVolumeDt1[a_bndryId(splitChildId)] /= cvol;
      for(MInt v = 0; v < m_noFVars; v++) {
        m_rhs0[splitChildId][v] /= cvol;
      }
    }
  }


#ifdef GEOM_CONS_LAW

  setBoundaryVelocity();
  if(m_levelSet && m_closeGaps && m_gapInitMethod > 0) {
    updateGapBoundaryCells();
  }

  if(mode == 0) {
    correctRefinedBndryCellVolume();
    correctCoarsenedBndryCellVolume();
  }

  // e) update CellVolume of bndryCells (mode-dependand!)
  //   default(-1): update according to the GCL-Function
  //   firt-step  : initialise Dt-Variables using dV
  for(MInt bndryId = m_noOuterBndryCells; bndryId < noBCells; bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    const MFloat vol0 = a_cellVolume(cellId);
    const MFloat deltaVol = updateCellVolumeGCL(bndryId); // dV

    // old gapInitMethod: change cellVolume of all Cells if gapOpened! (not mass-conservative!)
    if((mode == 1) || (m_gapInitMethod == 0 && m_gapOpened)) {
      // call before first right Hand Side (or old gap-opening method)
      a_cellVolume(cellId) = mMax(m_volumeThreshold, m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume);
      m_cellVolumesDt1[cellId] = a_cellVolume(cellId) - deltaVol;
      m_sweptVolumeDt1[bndryId] = m_sweptVolume[bndryId];

      // set static volume for geometry-change in cells with large volume dif
      // from the original geometry cell volume!
      if(m_geometryChange != nullptr) {
        auto it0 = m_oldGeomBndryCells.find(cellId);
        if(it0 != m_oldGeomBndryCells.end()) {
          m_sweptVolumeDt1[bndryId] = 0;
          m_sweptVolume[bndryId] = 0;
          a_cellVolume(cellId) = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume;
          m_cellVolumesDt1[cellId] = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume;
        }
      }

    } else if(mode == 2) {
      /*m_sweptVolumeDt1[bndryId] = F2*dV0 - m_sweptVolume[bndryId];
      MFloat deltaVol = F0;
      if ( m_gclIntermediate ) {
      if ( m_levelSetMb ) {
          deltaVol = ( m_RKStep == 0 ) ? m_sweptVolumeDt1[ bndryId ] : m_RKalpha[ m_RKStep-1 ] * m_sweptVolume[ bndryId
      ] + (F1-m_RKalpha[ m_RKStep-1 ]) * m_sweptVolumeDt1[ bndryId ] ;
        }
      } else {
      deltaVol = ( m_levelSetMb ) ? F1B2 * ( m_sweptVolume[ bndryId ] + m_sweptVolumeDt1[ bndryId ] ) : m_sweptVolume[
      bndryId ];
      }
      a_cellVolume( cellId ) = m_cellVolumesDt1[ cellId ] + deltaVol;*/
      m_sweptVolumeDt1[bndryId] = m_sweptVolume[bndryId]; // F0;
      a_cellVolume(cellId) = vol0;
      m_cellVolumesDt1[cellId] = vol0 - m_sweptVolume[bndryId];
    } else if(a_cellVolume(cellId) < m_volumeThreshold && !a_isPeriodic(cellId) && !a_isHalo(cellId)) {
      /*     //const MFloat deltaVol = m_cellVolumesDt1[cellId] - (a_cellVolume( cellId ) - dV);
      const MFloat deltaVol = m_cellVolumesDt1[cellId] - (m_volumeThreshold - dV);
      const MFloat fac = deltaVol / m_cellVolumesDt1[cellId];
      m_cellVolumesDt1[ cellId ] = a_cellVolume( cellId ) - dV;
      if ( fabs(deltaVol) > 1e-16 ) {
        cerr << globalTimeStep << setprecision(16) << " cell vol dropped below zero " << cellId << " " << a_cellVolume(
      cellId ) << " (" << m_cellVolumesDt1[ cellId ] << " / " << dV << ")" << endl;
        m_massRedistributionIds.push_back(cellId);
        m_massRedistributionVariables.resize(m_massRedistributionIds.size()*noVars);
        m_massRedistributionRhs.resize(m_massRedistributionIds.size()*noVars);
        m_massRedistributionVolume.resize(m_massRedistributionIds.size());
        m_massRedistributionSweptVol.resize(m_massRedistributionIds.size());
        for ( MUint v = 0; v < noVars; v++ ) {
          m_massRedistributionVariables[(m_massRedistributionIds.size()-1)*noVars + v ] = a_oldVariable( cellId ,  v );
          m_massRedistributionRhs[(m_massRedistributionIds.size()-1)*noVars + v ] = fac * m_rhs0[ cellId ][ v ];
          m_rhs0[ cellId ][ v ] *= (F1-fac);
        }
        m_massRedistributionVolume[m_massRedistributionIds.size()-1] = deltaVol;
        m_massRedistributionSweptVol[m_massRedistributionIds.size()-1] = fac * m_sweptVolumeDt1[ bndryId ];
        m_sweptVolumeDt1[ bndryId ] *= (F1-fac);
        //cerr << "exceed " << a_oldVariable( cellId ,  CV->RHO ) *deltaVol << endl;
      }*/
      // if ( !a_hasProperty(cellId, SolverCell::WasInactive ) ) cerr << domainId() << ": cell volume below threshold "
      // << c_globalId(cellId) << " " << a_cellVolume( cellId ) << " " << m_volumeThreshold << " " << m_cellVolumesDt1[
      // cellId ] << endl;
    }
    if(a_cellVolume(cellId) < F0 && !a_isPeriodic(cellId) && !a_isHalo(cellId)) {
      // cerr << domainId() << ": " << globalTimeStep << " cell vol dropped below zero " << cellId << " " <<
      // a_cellVolume( cellId ) << " (" << m_cellVolumesDt1[ cellId ] << " / " << dV << ")" << endl;
    }

    a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
    m_volumeFraction[bndryId] = a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId));
  }
#else
  for(MInt bndryId = m_noOuterBndryCells; bndryId < noBCells; bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    a_cellVolume(cellId) = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume;
    a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
    m_volumeFraction[bndryId] = a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId));
  }
#endif

#if defined _MB_DEBUG_ || !defined NDEBUG
  MFloatScratchSpace testvol(m_noEmbeddedBodies + 1, 4, AT_, "testvol");
  testvol.fill(F0);
  for(MInt bndryId = m_noOuterBndryCells; bndryId < noBCells; bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_isHalo(cellId)) continue;
    if(a_hasProperty(cellId, SolverCell::IsSplitCell)) {
      ASSERT(m_bndryCells->a[bndryId].m_noSrfcs == 0, "");
      continue;
    }
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      MInt body = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bodyId[0];
      MInt bodyId = m_internalBodyId[body];
      MFloat dV = F0;
      MFloat dt = timeStep(true);
      MFloat area = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
      for(MInt i = 0; i < nDim; i++) {
        MFloat nml = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
        dV -= dt * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] * nml * area;
        testvol(bodyId, i) += nml * area;
      }
      testvol(bodyId, nDim) += dV;
    }
    testvol(m_noEmbeddedBodies, 0) += m_sweptVolume[bndryId];
    testvol(m_noEmbeddedBodies, 1) += m_sweptVolumeDt1[bndryId];
  }
  MPI_Allreduce(MPI_IN_PLACE, &testvol(0), testvol.size(), MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "testvol(0)");
  if(domainId() == 0) {
    for(MInt b = 0; b < mMin(4, m_noEmbeddedBodies); b++) {
      cerr << b << " " << testvol(b, 0) << " " << testvol(b, 1) << " " << testvol(b, 2) << " " << testvol(b, 3) << endl;
    }
    cerr << "VOL CHECK -- " << testvol(m_noEmbeddedBodies, 0) << " " << testvol(m_noEmbeddedBodies, 1) << endl << endl;
  }
#endif

  // f) set massRedistribution-Info for oldBndryCells
  for(map<MInt, MFloat>::iterator it = m_oldBndryCells.begin(); it != m_oldBndryCells.end(); it++) {
    // ASSERT(mode != 2, "");
    MInt cellId = it->first;

    // skip old Bndry-Cells which are still a bndry-Cell!
    if(a_bndryId(cellId) > -1) continue;


    MBool conserveMass1 = true;
    MBool conserveMass2 = true;
    if(m_levelSet && m_closeGaps && m_gapInitMethod == 0) {
      MBool isGapCell = (a_hasProperty(cellId, SolverCell::IsGapCell));
      MBool wasGapCell = (a_hasProperty(cellId, SolverCell::WasGapCell));

      if(isGapCell || wasGapCell) conserveMass1 = false;
      if(wasGapCell) conserveMass2 = false;

      // The conserveMass-triggers are used to prevent the
      // direct-mass conservation of the 2 types of cut-Cell changes (submerging && becoming internal)
      // only used in the old Methode, in the new method the mass is conserved during gap-Widening
      // and -shrinking. And for initGapOpeing and initGapClosure the conservation is handeled in
      // in gapHandling()

    } else if(m_levelSet && m_closeGaps && m_gapInitMethod > 0 && (a_isGapCell(cellId) || a_wasGapCell(cellId))
              && !a_isHalo(cellId) && !a_isPeriodic(cellId)) {
      // this should now already been done in gapHandling-where these cells are either
      // removed from the oldBndryCell-List or the mass is truely conserved!
      const MInt regionId = m_gapCells[m_gapCellId[cellId]].region;
      if(regionId <= m_noGapRegions) {
        /*
        if(m_gapState[regionId] == -2) {
           cerr << "Stopped massRedistribution of Cell " << c_globalId(cellId)
                << " Type: " << m_gapCells[m_gapCellId[cellId]].status << endl;
           conserveMass1 = false;
        } else if (m_gapState[regionId] == 2) {
          cerr << "Stopped massRedistribution of Cell " << c_globalId(cellId)
               << " Type: " << m_gapCells[m_gapCellId[cellId]].status << endl;
          conserveMass1 = false;
          //this part should not be necessary for gap-Opening:
          // there shouldn't be a any submerging gap-Cells. Change to always set true and a check
          // in the according if-statement below!

          //only for GapOpening!
          if(a_wasGapCell(cellId)) {
            conserveMass2 = false;
            cerr << "Stopped massRedistribution-2 of Cell " << c_globalId(cellId)
                 << m_gapCells[m_gapCellId[cellId]].status << endl;
          }

        }
        */

        if(m_gapState[regionId] == 2) {
          // only for GapOpening!
          if(a_wasGapCell(cellId)) {
            // should be of Type 23, change to ASSERT!
            cerr << "Trying massRedistribution-2 of Cell " << c_globalId(cellId) << " "
                 << m_gapCells[m_gapCellId[cellId]].status << endl;
            //}
          }
        }
      }
    }

    for(MInt v = 0; v < m_noFVars; v++) {
      a_rightHandSide(cellId, v) = F0;
    }
    //! case 1: submerging old-Bndry-Cell
    if(a_hasProperty(cellId, SolverCell::IsInactive) && a_bndryId(cellId) < 0
       && !a_hasProperty(cellId, SolverCell::WasInactive)) {
      if(!a_isPeriodic(cellId) && !a_isHalo(cellId) && conserveMass1) {
        if(m_levelSet && m_closeGaps && m_gapInitMethod > 0 && (a_isGapCell(cellId) || a_wasGapCell(cellId))) {
          MInt regionId = m_gapCells[m_gapCellId[cellId]].region;
          if(regionId < m_noGapRegions && (m_gapState[regionId] == -2 || m_gapState[regionId] == 2)) {
            cerr << "Trying massRedistribution of GapCell" << c_globalId(cellId)
                 << " Type: " << m_gapCells[m_gapCellId[cellId]].status
                 << " This should not happen during Opening or Closing!" << endl;
          }
        }

        m_massRedistributionIds.push_back(cellId);
        m_massRedistributionVariables.resize(m_massRedistributionIds.size() * m_noCVars);
        m_massRedistributionRhs.resize(m_massRedistributionIds.size() * m_noFVars);
        m_massRedistributionVolume.resize(m_massRedistributionIds.size());
        m_massRedistributionSweptVol.resize(m_massRedistributionIds.size());
        for(MInt v = 0; v < m_noCVars; v++) {
          m_massRedistributionVariables[(m_massRedistributionIds.size() - 1) * m_noCVars + v] =
              a_oldVariable(cellId, v);
        }
        for(MInt v = 0; v < m_noFVars; v++) {
          m_massRedistributionRhs[(m_massRedistributionIds.size() - 1) * m_noFVars + v] = m_rhs0[cellId][v];
          m_rhs0[cellId][v] = F0;
        }
        m_massRedistributionVolume[m_massRedistributionIds.size() - 1] = m_cellVolumesDt1[cellId];
        m_massRedistributionSweptVol[m_massRedistributionIds.size() - 1] = it->second;
      }
      removeSurfaces(cellId);
      a_cellVolume(cellId) = grid().gridCellVolume(a_level(cellId));                            // F0;
      m_cellVolumesDt1[cellId] = grid().gridCellVolume(a_level(cellId));                        // F0;
      if(m_dualTimeStepping) m_cellVolumesDt2[cellId] = grid().gridCellVolume(a_level(cellId)); // F0;
      a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
    }
    //! case 2: emerging cell
    else if(a_hasProperty(cellId, SolverCell::WasInactive) && a_bndryId(cellId) > -1) {
      m_cellVolumesDt1[cellId] = F0; // had no mass at the previous time step, this is conservative
      if(m_dualTimeStepping)
        m_cellVolumesDt2[cellId] = F0; // had no mass at the previous time step, this is conservative
      for(MInt v = 0; v < m_noFVars; v++) {
        m_rhs0[cellId][v] = F0;
      }
      cerr << "case should not appear " << domainId() << " " << globalTimeStep << " " << cellId << endl;
    }
    //! case 3: cut cell became an internal cell
    if(!a_hasProperty(cellId, SolverCell::IsInactive) && a_bndryId(cellId) < 0) {
      if(!a_isPeriodic(cellId) && !a_isHalo(cellId)) {
        // all old-bndry-Cells which are still active, but are not a bndryCell anymore!
        const MFloat deltaVol = m_cellVolumesDt1[cellId] - grid().gridCellVolume(a_level(cellId));
        if(fabs(deltaVol) > 1e-16 && conserveMass2) {
          m_massRedistributionIds.push_back(cellId);
          m_massRedistributionVariables.resize(m_massRedistributionIds.size() * m_noCVars);
          m_massRedistributionRhs.resize(m_massRedistributionIds.size() * m_noFVars);
          m_massRedistributionVolume.resize(m_massRedistributionIds.size());
          m_massRedistributionSweptVol.resize(m_massRedistributionIds.size());
          for(MInt v = 0; v < m_noCVars; v++) {
            m_massRedistributionVariables[(m_massRedistributionIds.size() - 1) * m_noCVars + v] =
                a_oldVariable(cellId, v);
          }
          for(MInt v = 0; v < m_noFVars; v++) {
            m_massRedistributionRhs[(m_massRedistributionIds.size() - 1) * m_noFVars + v] =
                -it->second * a_oldVariable(cellId, v) / timeStep();
            m_rhs0[cellId][v] += it->second * a_oldVariable(cellId, v) / timeStep();
          }
          m_massRedistributionVolume[m_massRedistributionIds.size() - 1] = deltaVol;
          m_massRedistributionSweptVol[m_massRedistributionIds.size() - 1] = it->second;
        }
      }
      {
        a_cellVolume(cellId) = grid().gridCellVolume(a_level(cellId));
        m_cellVolumesDt1[cellId] = grid().gridCellVolume(a_level(cellId));
        if(m_dualTimeStepping) m_cellVolumesDt2[cellId] = grid().gridCellVolume(a_level(cellId));
        a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
      }
    }
  }


  // g) update CellVolume for splitCells
  for(MUint sc = 0; sc < m_splitCells.size(); sc++) {
    const MInt cellId = m_splitCells[sc];
    MFloat vol = F0;
    MFloat vol1 = F0;
    MFloat svol = F0;
    MFloat svol1 = F0;
    for(MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) {
      const MInt splitChildId = m_splitChilds[sc][ssc];
      // a_cellVolume( splitChildId ) = m_fvBndryCnd->m_bndryCells->a[ a_bndryId(splitChildId) ].m_volume;
      vol += a_cellVolume(splitChildId);
      vol1 += m_cellVolumesDt1[splitChildId];
      svol += m_sweptVolume[a_bndryId(splitChildId)];
      svol1 += m_sweptVolumeDt1[a_bndryId(splitChildId)];
    }
    for(MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) {
      // const MInt splitChildId = m_splitChilds[sc][ssc];
      // m_cellVolumesDt1[splitChildId] = a_cellVolume(splitChildId)*m_cellVolumesDt1[cellId]/mMax(1e-15,vol);
    }
    a_cellVolume(cellId) = vol;
    m_cellVolumesDt1[cellId] = vol1;
    m_sweptVolume[a_bndryId(cellId)] = svol;
    m_sweptVolumeDt1[a_bndryId(cellId)] = svol1;
  }


#if defined _MB_DEBUG_ || !defined NDEBUG

  checkHaloBndryCells(true);
  checkHaloCells();

  if(m_levelSet && m_closeGaps && m_gapInitMethod > 0) {
    checkGapCells();
  }

  // check-cell-Volumes
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    if(a_cellVolume(cellId) < 0) {
      cerr << "Negative cell-Volume " << c_globalId(cellId) << endl;
    }
    if(m_cellVolumesDt1[cellId] < 0 && mode != 1) {
      MInt status = -1;
      if(m_closeGaps && m_gapInitMethod > 0 && m_gapCellId[cellId] > 1) {
        status = m_gapCells[m_gapCellId[cellId]].status;
      }
      cerr << "Negative cell-Volume-Dt1 " << c_globalId(cellId) << " " << m_cellVolumesDt1[cellId] << " " << status
           << endl;
    }
  }

#endif

  MInt noSplitFaces = 0;
  MInt noSplitFacesHalo = 0;
  MInt noSplitCells = 0;
  MInt noSplitCellsHalo = 0;
  for(MInt bndryId = 0; bndryId < noBCells; bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_hasProperty(cellId, SolverCell::HasSplitFace)) noSplitFaces++;
    if(a_hasProperty(cellId, SolverCell::HasSplitFace) && a_isHalo(cellId)) noSplitFacesHalo++;
#ifdef _MB_DEBUG_
    if(a_hasProperty(cellId, SolverCell::HasSplitFace) && a_isHalo(cellId))
      cerr << domainId() << ": halo split face!" << endl;
    if(a_hasProperty(cellId, SolverCell::HasSplitFace) && a_isWindow(cellId))
      cerr << domainId() << ": window split face!" << endl;
#endif
    const MInt noSrfcs = m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs;
    for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
      ASSERT(m_fvBndryCnd->m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId > -1, "");
    }
  }
  for(MUint sc = 0; sc < m_splitCells.size(); sc++) {
    const MInt cellId = m_splitCells[sc];
    // cerr << domainId() << ": split cell " << cellId << " (";
    // for( MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) cerr << m_splitChilds[sc][ssc] << ","; cerr << ")"
    // << endl; cerr << domainId() << ": vol " << a_cellVolume( cellId ) / grid().gridCellVolume( a_level(cellId) ) << "
    // ("; for( MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) cerr <<
    // a_cellVolume(m_splitChilds[sc)[ssc]]/grid().gridCellVolume(a_level(m_splitChilds[sc][ssc])) << ","; cerr << ")"
    // << endl; cerr << domainId() << ": vol1 " << m_cellVolumesDt1[ cellId ] / grid().gridCellVolume( a_level(cellId) )
    // << "
    // ("; for( MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) cerr <<
    // m_cellVolumesDt1[m_splitChilds[sc][ssc]]/grid().gridCellVolume(a_level(m_splitChilds[sc][ssc])) << ","; cerr <<
    // ")" << endl;
    noSplitCells++;
    if(a_isHalo(cellId)) noSplitCellsHalo++;
#ifdef _MB_DEBUG_
    if(a_isHalo(cellId)) cerr << domainId() << ": halo split cell!" << endl;
    if(a_isWindow(cellId)) cerr << domainId() << ": window split cell!" << endl;
#endif
    for(MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) {
      if(a_hasProperty(m_splitChilds[sc][ssc], SolverCell::IsTempLinked))
        cerr << domainId() << ": linked split child " << m_splitChilds[sc][ssc] << " (" << cellId << ")" << endl;
    }
    for(MUint it = 0; it < m_temporarilyLinkedCells.size(); it++) {
      if(cellId == get<1>(m_temporarilyLinkedCells[it])) cerr << domainId() << ": master split cell " << cellId << endl;
    }
    /*
    for ( map<MInt,MInt>::iterator it = m_temporarilyLinkedCells.begin(); it != m_temporarilyLinkedCells.end(); it++
    ) { if ( cellId == it->second) cerr << domainId() << ": master split cell " << cellId << endl;
    }
    */
  }
#ifdef _MB_DEBUG_
  if(m_splitCells.size() > 0 || noSplitFaces > 0) {
    cerr << domainId() << ": " << noSplitCells << "(" << noSplitCellsHalo << ")"
         << " split cells and " << noSplitFaces << "(" << noSplitFacesHalo << ")"
         << " split faces at time step " << globalTimeStep << endl;
  }
#endif

  // if ( firstRun ) {
  //  firstRun = false;
  //}

  if(mode > 0 && m_massRedistributionIds.size() > 0) {
    mTerm(1, AT_, "Not supposed to happen.");
  }

  if(mode == 1 && m_initialCondition == 16 && !m_restart) {
    initBodyVelocities();
  }
  /*! \page propertiesFVMB
    \section particleTemperatureRatio
    <code>MFloat particleTemperatureRatio</code>\n
    default = <code>1.0</code>\n \n
    Set ratio of particle temperature relativ to fluid temperature. \n \n
    Possible values are:
    <ul>
      <li>any positive floating point number</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, PARTICLES, TEMPERATURE</i>
  */
  const MFloat ratio = (Context::propertyExists("particleTemperatureRatio", m_solverId))
                           ? Context::getSolverProperty<MFloat>("particleTemperatureRatio", m_solverId, AT_)
                           : F1;
  /*! \page propertiesFVMB
    \section initPPVelocitiesFactor
    <code>MFloat initPPVelocitiesFactor</code>\n
    default = <code>1.0</code>\n \n
    Sets a factor for the initial m_particleVelocityFluid \n \n
    Possible values are:
    <ul>
      <li>any positive floating point number</li>
    </ul>
    Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, PARTICLES, VELOCITY</i>
  */
  const MFloat initPPVelocitiesFactor =
      (Context::propertyExists("initPPVelocitiesFactor", m_solverId))
          ? Context::getSolverProperty<MFloat>("initPPVelocitiesFactor", m_solverId, AT_)
          : F1;
  if(mode == 1 && m_noPointParticles > 0) {
    setParticleFluidVelocities();
    for(MUint p = 0; p < m_particleCellLink.size(); p++) {
      for(MInt i = 0; i < nDim; i++) {
        m_particleVelocity[nDim * p + i] =
            initPPVelocitiesFactor * m_particleVelocityFluid[nDim * p + i] + m_particleTerminalVelocity[i];
        m_particleVelocityDt1[nDim * p + i] = m_particleVelocity[nDim * p + i];
      }
      m_particleTemperature[p] = ratio * m_particleFluidTemperature[p];
      m_particleTemperatureDt1[p] = m_particleTemperature[p];
    }
  }

#ifdef _MB_DEBUG_
  MInt noLinked = (signed)m_temporarilyLinkedCells.size();
  MPI_Allreduce(MPI_IN_PLACE, &noLinked, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "noLinked");
  m_log << "no linked cells " << globalTimeStep << ": " << noLinked << endl;
#endif

  RECORD_TIMER_STOP(tMassRedist);
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::checkHaloBndryCells(MBool sweptVol) {
  TRACE();

  constexpr MFloat eps0 = 1e-12;
  constexpr MFloat eps1 = 1e-11;

  MFloatScratchSpace cellCheck(a_noCells(), 14, AT_, "cellCheck");
  cellCheck.fill(std::numeric_limits<MFloat>::max());

  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    cellCheck(cellId, 0) = (MFloat)a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel);
    cellCheck(cellId, 1) = a_bndryId(cellId) > -1 ? (MFloat)m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_noSrfcs
                                                  : std::numeric_limits<MFloat>::max();
    cellCheck(cellId, 2) = a_levelSetValuesMb(cellId, 0);
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    cellCheck(cellId, 3) = (MFloat)a_hasProperty(cellId, SolverCell::IsInactive);
    cellCheck(cellId, 4) = (MFloat)a_hasProperty(cellId, SolverCell::WasInactive);
    cellCheck(cellId, 5) = (MFloat)a_hasProperty(cellId, SolverCell::IsSplitCell);
    cellCheck(cellId, 6) = (MFloat)a_hasProperty(cellId, SolverCell::IsSplitChild);
    cellCheck(cellId, 7) = (MFloat)a_hasProperty(cellId, SolverCell::IsGapCell);
    cellCheck(cellId, 8) = (MFloat)a_hasProperty(cellId, SolverCell::WasGapCell);
    cellCheck(cellId, 9) = a_cellVolume(cellId);
    cellCheck(cellId, 10) = m_cellVolumesDt1[cellId];
    cellCheck(cellId, 11) =
        a_bndryId(cellId) > -1 ? m_sweptVolume[a_bndryId(cellId)] : std::numeric_limits<MFloat>::max();
    cellCheck(cellId, 12) =
        a_bndryId(cellId) > -1 ? m_sweptVolumeDt1[a_bndryId(cellId)] : std::numeric_limits<MFloat>::max();
    cellCheck(cellId, 13) = F1;
  }
  for(MUint sc = 0; sc < m_splitCells.size(); sc++) {
    const MInt cellId = m_splitCells[sc];
    for(MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) {
      cellCheck(cellId, 9) += a_cellVolume(m_splitChilds[sc][ssc]);
      cellCheck(cellId, 10) += m_cellVolumesDt1[m_splitChilds[sc][ssc]];
      cellCheck(cellId, 11) += m_sweptVolume[a_bndryId(m_splitChilds[sc][ssc])];
      cellCheck(cellId, 12) += m_sweptVolumeDt1[a_bndryId(m_splitChilds[sc][ssc])];
      cellCheck(cellId, 13) += F1;
    }
  }

  // exchangeData( &cellCheck(0), (MInt)cellCheck.size1() );
  exchangeData(&cellCheck(0), 14);

  for(MInt cellId = noInternalCells(); cellId < a_noCells(); cellId++) {
    if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
    // Azimuthal periodic window/halo cells are not identical in the sense of the cartesian grid!
    if(grid().azimuthalPeriodicity() && a_isPeriodic(cellId)) continue;

    if((MInt)cellCheck(cellId, 0) != a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel))
      cerr << domainId() << ": ERR0 generateBndryCellsMb " << globalTimeStep << " " << cellId << " "
           << c_globalId(cellId) << " " << cellCheck(cellId, 0) << " "
           << a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) << " "
           << (((a_hasProperty(cellId, SolverCell::IsSplitChild)) ? getAssociatedInternalCell(cellId) : cellId)) << " "
           << a_hasProperty(cellId, SolverCell::IsSplitCell) << " " << a_hasProperty(cellId, SolverCell::IsSplitChild)
           << " " << a_isHalo(cellId) << " " << a_isWindow(cellId) << " "
           << a_levelSetValuesMb(cellId, 0) / c_cellLengthAtCell(cellId) << " " << a_bndryId(cellId) << " "
           << a_level(((a_hasProperty(cellId, SolverCell::IsSplitChild)) ? getAssociatedInternalCell(cellId) : cellId))
           << endl;
    if((MInt)cellCheck(cellId, 1)
       != (MInt)(a_bndryId(cellId) > -1 ? (MFloat)m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_noSrfcs
                                        : std::numeric_limits<MFloat>::max())) {
      MFloat noSurfaces = std::numeric_limits<MFloat>::max();
      if(a_bndryId(cellId) > -1) {
        noSurfaces = (MFloat)m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_noSrfcs;
      }
      cerr << domainId() << ": ERR1 generateBndryCellsMb " << globalTimeStep << " " << cellId << " "
           << m_noOuterBndryCells << " " << a_bndryId(cellId) << " " << noSurfaces << " " << c_globalId(cellId) << endl;
    }
    if(fabs(cellCheck(cellId, 2) - a_levelSetValuesMb(cellId, 0)) > eps1)
      if(!m_adaptation
         || mMin(cellCheck(cellId, 2), a_levelSetValuesMb(cellId, 0)) < m_outerBandWidth[maxUniformRefinementLevel()])
        cerr << domainId() << ": ERR2 generateBndryCellsMb " << globalTimeStep << " " << cellId << " "
             << cellCheck(cellId, 2) << " " << a_levelSetValuesMb(cellId, 0) << " "
             << cellCheck(cellId, 2) - a_levelSetValuesMb(cellId, 0) << " " << c_globalId(cellId) << " "
             << m_bodyDistThreshold << endl;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(!a_isHalo(cellId)) continue;
    if((MInt)cellCheck(cellId, 3) != a_hasProperty(cellId, SolverCell::IsInactive))
      cerr << domainId() << ": ERR3 generateBndryCellsMb " << globalTimeStep << " " << cellId << " "
           << a_hasProperty(cellId, SolverCell::IsSplitCell) << " " << a_hasProperty(cellId, SolverCell::IsSplitChild)
           << " " << a_isHalo(cellId) << " " << a_isWindow(cellId) << " " << a_levelSetValuesMb(cellId, 0) << endl;
    if((MInt)cellCheck(cellId, 4) != a_hasProperty(cellId, SolverCell::WasInactive))
      cerr << domainId() << ": ERR4 generateBndryCellsMb " << globalTimeStep << " " << cellId << endl;
    if((MInt)cellCheck(cellId, 5) != a_hasProperty(cellId, SolverCell::IsSplitCell))
      cerr << domainId() << ": ERR5 generateBndryCellsMb " << globalTimeStep << " " << cellId << endl;
    if((MInt)cellCheck(cellId, 6) != a_hasProperty(cellId, SolverCell::IsSplitChild))
      cerr << domainId() << ": ERR6 generateBndryCellsMb " << globalTimeStep << " " << cellId << endl;
    if((MInt)cellCheck(cellId, 7) != a_hasProperty(cellId, SolverCell::IsGapCell))
      cerr << domainId() << ": ERR7 generateBndryCellsMb " << globalTimeStep << " " << cellId << endl;
    if((MInt)cellCheck(cellId, 8) != a_hasProperty(cellId, SolverCell::WasGapCell))
      cerr << domainId() << ": ERR8 generateBndryCellsMb " << globalTimeStep << " " << c_globalId(cellId) << endl;
    if(!a_hasProperty(cellId, SolverCell::IsSplitCell) && !a_hasProperty(cellId, SolverCell::IsSplitCell)) {
      if(fabs(cellCheck(cellId, 9) - a_cellVolume(cellId)) > eps0)
        cerr << domainId() << ": ERR9 generateBndryCellsMb " << cellId << " " << c_globalId(cellId) << " "
             << a_hasProperty(cellId, SolverCell::IsSplitCell) << " " << a_hasProperty(cellId, SolverCell::IsSplitChild)
             << " " << a_isHalo(cellId) << " " << a_isWindow(cellId) << " ls " << a_levelSetValuesMb(cellId, 0) << " "
             << a_isGapCell(cellId) << " " << a_wasGapCell(cellId) << " " << a_bndryId(cellId) << " " << a_level(cellId)
             << " " << a_cellVolume(cellId) << " "
             << (cellCheck(cellId, 9) - grid().gridCellVolume(a_level(cellId))) / grid().gridCellVolume(a_level(cellId))
             << " "
             << (a_cellVolume(cellId) - grid().gridCellVolume(a_level(cellId))) / grid().gridCellVolume(a_level(cellId))
             << " " << fabs(cellCheck(cellId, 9) - a_cellVolume(cellId)) / grid().gridCellVolume(a_level(cellId))
             << endl;

      if(fabs(cellCheck(cellId, 10) - m_cellVolumesDt1[cellId]) > eps0)
        cerr << domainId() << ": ERR10 generateBndryCellsMb " << globalTimeStep << " " << cellId << " "
             << c_globalId(cellId) << " " << a_isGapCell(cellId) << a_wasGapCell(cellId) << endl;
      if(sweptVol) {
        if(a_bndryId(cellId) > -1 && fabs(cellCheck(cellId, 11) - m_sweptVolume[a_bndryId(cellId)]) > eps0)
          cerr << domainId() << ": ERR11 generateBndryCellsMb " << globalTimeStep << " " << cellId << " "
               << c_globalId(cellId) << " " << cellCheck(cellId, 11) << " " << m_sweptVolume[a_bndryId(cellId)] << " "
               << a_bndryId(cellId) << " " << m_noOuterBndryCells << " "
               << a_hasProperty(cellId, SolverCell::IsSplitCell) << " "
               << a_hasProperty(cellId, SolverCell::IsSplitChild) << " " << a_isGapCell(cellId) << " "
               << a_wasGapCell(cellId) << endl;
        if(a_bndryId(cellId) > -1 && fabs(cellCheck(cellId, 12) - m_sweptVolumeDt1[a_bndryId(cellId)]) > eps0)
          cerr << domainId() << ": ERR12 generateBndryCellsMb " << globalTimeStep << " " << cellId << " "
               << a_isGapCell(cellId) << " " << a_wasGapCell(cellId) << endl;
      }
    }
  }
  for(MUint sc = 0; sc < m_splitCells.size(); sc++) {
    const MInt cellId = m_splitCells[sc];
    if(a_isHalo(cellId)) {
      // Azimuthal periodic window/halo cells are not identical in the sense of the cartesian grid!
      if(grid().azimuthalPeriodicity() && a_isPeriodic(cellId)) continue;
      MFloat test0 = F1;
      MFloat test1 = a_cellVolume(cellId);
      MFloat test2 = m_cellVolumesDt1[cellId];
      MFloat test33 = m_sweptVolume[a_bndryId(cellId)];
      MFloat test4 = m_sweptVolumeDt1[a_bndryId(cellId)];
      for(MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) {
        test0 += F1;
        test1 += a_cellVolume(m_splitChilds[sc][ssc]);
        test2 += m_cellVolumesDt1[m_splitChilds[sc][ssc]];
        test33 += m_sweptVolume[a_bndryId(m_splitChilds[sc][ssc])];
        test4 += m_sweptVolumeDt1[a_bndryId(m_splitChilds[sc][ssc])];
      }
      if((MInt)test0 != (MInt)cellCheck(cellId, 13))
        cerr << domainId() << ": ERR13 generateBndryCellsMb " << globalTimeStep << " " << cellId << endl;
      if(fabs(test1 - cellCheck(cellId, 9)) > eps0)
        cerr << domainId() << ": ERR14 generateBndryCellsMb " << globalTimeStep << " " << cellId << endl;
      if(fabs(test2 - cellCheck(cellId, 10)) > eps0)
        cerr << domainId() << ": ERR15 generateBndryCellsMb " << globalTimeStep << " " << cellId << endl;
      if(sweptVol) {
        if(fabs(test33 - cellCheck(cellId, 11)) > eps0)
          cerr << domainId() << ": ERR16 generateBndryCellsMb " << globalTimeStep << " " << cellId << endl;
        if(fabs(test4 - cellCheck(cellId, 12)) > eps0)
          cerr << domainId() << ": ERR17 generateBndryCellsMb " << globalTimeStep << " " << cellId << endl;
      }
    }
  }
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::redistributeMass() {
  TRACE();

  MIntScratchSpace haloBufferCnts(mMax(1, noNeighborDomains()), AT_, "haloBufferCnts");
  MIntScratchSpace windowBufferCnts(mMax(1, noNeighborDomains()), AT_, "windowBufferCnts");
  MIntScratchSpace haloBufferOffsets(noNeighborDomains() + 1, AT_, "haloBufferOffsets");
  MIntScratchSpace windowBufferOffsets(noNeighborDomains() + 1, AT_, "windowBufferOffsets");
  ScratchSpace<MPI_Request> haloReq(mMax(1, noNeighborDomains()), AT_, "haloReq");
  ScratchSpace<MPI_Request> windowReq(mMax(1, noNeighborDomains()), AT_, "windowReq");

  MInt haloSize = 0;
  MInt windowSize = 0;
  haloBufferCnts.fill(0);
  windowBufferCnts.fill(0);
  haloBufferOffsets.fill(0);
  windowBufferOffsets.fill(0);

  for(MInt i = 0; i < noNeighborDomains(); i++) {
    haloBufferCnts(i) = (m_noCVars + m_noFVars + 3) * (signed)m_fvBndryCnd->m_nearBoundaryHaloCells[i].size();
    windowBufferCnts(i) = (m_noCVars + m_noFVars + 3) * (signed)m_fvBndryCnd->m_nearBoundaryWindowCells[i].size();
    haloBufferOffsets(i + 1) = haloBufferOffsets(i) + haloBufferCnts(i);
    windowBufferOffsets(i + 1) = windowBufferOffsets(i) + windowBufferCnts(i);
    haloSize += haloBufferCnts(i);
    windowSize += windowBufferCnts(i);
  }

  MFloatScratchSpace redistVol(a_noCells(), AT_, "redistVol");
  MFloatScratchSpace redistSweptVol(a_noCells(), AT_, "redistSweptVol");
  MFloatScratchSpace haloBuffer(haloSize, AT_, "haloBuffer");
  MFloatScratchSpace windowBuffer(windowSize, AT_, "windowBuffer");
  MIntScratchSpace nghbrList(150, AT_, "nghbrList");
  MIntScratchSpace layerId(150, AT_, "layerList");
  MFloatScratchSpace weights(150, AT_, "layerList");

  const MUint noCVars = (MUint)m_noCVars;
  const MUint noFVars = (MUint)m_noFVars;
  const MUint noPVars = (MUint)m_noPVars;

  // redistribute lost mass
  // for ( MInt c = 0; c < m_noNearBndryCells; c++ ) {
  //  MInt cellId = m_nearBndryCells->a[ c ];
  for(MUint c = 0; c < m_bndryLayerCells.size(); c++) {
    const MInt cellId = m_bndryLayerCells[c];
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    for(MUint v = 0; v < noPVars; v++) {
      a_slope(cellId, v, 0) = F0;
      a_slope(cellId, v, 1) = F0;
    }
    redistVol(cellId) = F0;
    redistSweptVol(cellId) = F0;
  }

  {
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      for(MInt j = 0; j < (signed)m_fvBndryCnd->m_nearBoundaryHaloCells[i].size(); j++) {
        MInt cellId = m_fvBndryCnd->m_nearBoundaryHaloCells[i][j];
        for(MUint v = 0; v < noPVars; v++) {
          a_slope(cellId, v, 0) = F0;
          a_slope(cellId, v, 1) = F0;
        }
        redistVol(cellId) = F0;
        redistSweptVol(cellId) = F0;
        const MInt offset = haloBufferOffsets(i) + (noCVars + noFVars + 3) * j;
        haloBuffer(offset + 2) = -F1;
      }
      for(MInt j = 0; j < (signed)m_fvBndryCnd->m_nearBoundaryWindowCells[i].size(); j++) {
        MInt cellId = m_fvBndryCnd->m_nearBoundaryWindowCells[i][j];
        for(MUint v = 0; v < noPVars; v++) {
          a_slope(cellId, v, 0) = F0;
          a_slope(cellId, v, 1) = F0;
        }
        redistVol(cellId) = F0;
        redistSweptVol(cellId) = F0;
      }
    }
  }

  for(MUint i = 0; i < m_massRedistributionIds.size(); ++i) {
    const MInt cellId = m_massRedistributionIds[i];
    ASSERT(!(a_isPeriodic(cellId)), "");
    ASSERT(!(a_isHalo(cellId)), "");
    if(a_isHalo(cellId)) continue;

    if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;
    if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;

    MInt counter = 0;
    MFloat volCnt = F0;
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      if(!checkNeighborActive(cellId, dir) || a_hasNeighbor(cellId, dir) == 0) continue;
      const MInt nghbrId = c_neighborId(cellId, dir);
      if(nghbrId < 0) continue;
      if(!a_hasProperty(nghbrId, SolverCell::IsOnCurrentMGLevel)) continue;
      if(a_bndryId(nghbrId) < 0) continue;
      if(a_hasProperty(nghbrId, SolverCell::IsInactive)) continue;
      // if ( a_hasProperty( nghbrId , SolverCell::WasInactive ) ) continue;
      // Do not redistribute into azimuthal periodic cells. This is not handled
      if(grid().azimuthalPeriodicity() && a_isPeriodic(nghbrId)) continue;

      MInt bndryId = (a_bndryId(cellId) > -1) ? a_bndryId(cellId) : a_bndryId(nghbrId);
      if(bndryId < 0) mTerm(1, AT_, "not expected");
      // const MFloat nml = m_fvBndryCnd->m_bndryCells->a[ bndryId ].m_srfcs[0]->m_normalVector[dir/2];
      MFloat normal[3];
      for(MInt k = 0; k < nDim; k++) {
        normal[k] = m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVectorCentroid[k];
      }
      const MFloat nml = normal[dir / 2];
      const MFloat ncut = 0.01;

      weights[counter] = mMax(F0, (POW2(nml) - ncut) / (F1 - ncut))
                         * mMin(F1, mMax(F0, mMin(a_cellVolume(nghbrId), m_cellVolumesDt1[nghbrId]))
                                        / mMax(0.5 * m_volumeThreshold, fabs(m_massRedistributionVolume[i])));

      volCnt += weights[counter];
      nghbrList[counter] = nghbrId;
      counter++;
    }
    for(MInt n = 0; n < counter; n++) {
      weights[n] /= mMax(1e-14, volCnt);
    }

    if(true || volCnt < 0.1) {
      counter = this->template getAdjacentLeafCells<2, true>(cellId, 1, nghbrList, layerId);
      volCnt = F0;
      for(MInt n = 0; n < counter; n++) {
        weights[n] = F0;
        MInt nghbrId = nghbrList[n];
        if(nghbrId < 0) continue;
        if(a_hasProperty(nghbrId, SolverCell::IsInactive)) continue;
        if(a_bndryId(nghbrId) < 0) continue;
        // Do not redistribute into azimuthal periodic cells. This is not handled
        if(grid().azimuthalPeriodicity() && a_isPeriodic(nghbrId)) continue;

        if(a_hasProperty(nghbrId, SolverCell::IsSplitCell)) continue;
        if(a_hasProperty(nghbrId, SolverCell::IsSplitChild)) continue;

        weights[n] = 1e-5
                     + mMax(F0, (a_cellVolume(nghbrId) + m_cellVolumesDt1[nghbrId]))
                           / (F2 * grid().gridCellVolume(a_level(cellId)));


        MInt bndryId = a_bndryId(nghbrId);
        if(bndryId < 0) mTerm(1, AT_, "not expected");
        weights[n] = grid().gridCellVolume(a_level(cellId))
                     / mMax(1e-10, fabs(a_cellVolume(nghbrId) + m_massRedistributionVolume[i]
                                        + m_RKalpha[m_noRKSteps - 2] * m_massRedistributionSweptVol[i]
                                        - m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume));

        volCnt += weights[n];
      }
      for(MInt n = 0; n < counter; n++) {
        weights[n] /= mMax(1e-14, volCnt);
      }
    }

    for(MInt n = 0; n < counter; n++) {
      MInt nghbrId = nghbrList[n];
      if(nghbrId < 0) continue;
      if(a_hasProperty(nghbrId, SolverCell::IsInactive)) continue;
      if(a_bndryId(nghbrId) < 0) continue;

      if(a_hasProperty(nghbrId, SolverCell::IsSplitCell)) continue;
      if(a_hasProperty(nghbrId, SolverCell::IsSplitChild)) continue;

      const MFloat fac = weights[n];

      if(!a_hasProperty(nghbrId, SolverCell::NearWall)) {
        cerr << "[" << domainId() << "]: "
             << " nghbr " << nghbrId << " of cell " << cellId << " does not lie in bndryLayer! " << endl;
        cerr << " nghbr is a split cell: " << a_hasProperty(nghbrId, SolverCell::IsSplitCell)
             << " is split child: " << a_hasProperty(nghbrId, SolverCell::IsSplitChild) << endl;
      }

      for(MUint v = 0; v < noPVars; v++) {
        a_slope(nghbrId, v, 0) += fac * m_massRedistributionVolume[i] * m_massRedistributionVariables[i * noPVars + v];
        a_slope(nghbrId, v, 1) += fac * m_massRedistributionRhs[i * noPVars + v];
      }

      redistVol(nghbrId) += fac * m_massRedistributionVolume[i];
      redistSweptVol(nghbrId) += fac * m_massRedistributionSweptVol[i];
    }
    m_massRedistributionVolume[i] = F0;
    m_massRedistributionSweptVol[i] = F0;
  }

  m_massRedistributionIds.clear();
  m_massRedistributionVolume.clear();
  m_massRedistributionSweptVol.clear();
  m_massRedistributionVariables.clear();
  m_massRedistributionRhs.clear();


  {
    // 1. send redistributed mass back to window cells
    haloReq.fill(MPI_REQUEST_NULL);
    windowReq.fill(MPI_REQUEST_NULL);
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_fvBndryCnd->m_nearBoundaryHaloCells[i].empty()) continue;
      for(MInt j = 0; j < (signed)m_fvBndryCnd->m_nearBoundaryHaloCells[i].size(); j++) {
        MInt cellId = m_fvBndryCnd->m_nearBoundaryHaloCells[i][j];
        MInt offset = haloBufferOffsets(i) + (noPVars + noFVars + 3) * j;
        // ASSERT( a_hasProperty( cellId , SolverCell::NearWall ), "" );
        haloBuffer(offset) = redistVol(cellId);
        haloBuffer(offset + 1) = redistSweptVol(cellId);
        for(MInt v = 0; v < (signed)noPVars; v++) {
          haloBuffer(offset + 3 + v) = a_slope(cellId, v, 0);
          haloBuffer(offset + 3 + noPVars + v) = a_slope(cellId, v, 1);
        }
      }
    }
    MInt haloCnt = 0;
    MInt windowCnt = 0;
    if(m_nonBlockingComm) {
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(windowBufferCnts(i) == 0) continue;
        MPI_Irecv(&windowBuffer[windowBufferOffsets[i]], windowBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 17,
                  mpiComm(), &windowReq[windowCnt], AT_, "windowBuffer[windowBufferOffsets[i]]");
        windowCnt++;
      }
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(haloBufferCnts(i) == 0) continue;
        MPI_Isend(&haloBuffer[haloBufferOffsets[i]], haloBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 17, mpiComm(),
                  &haloReq[haloCnt], AT_, "haloBuffer[haloBufferOffsets[i]]");
        haloCnt++;
      }
      if(windowCnt > 0) MPI_Waitall(windowCnt, &windowReq[0], MPI_STATUSES_IGNORE, AT_);
    } else {
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(haloBufferCnts(i) == 0) continue;
        MPI_Issend(&haloBuffer[haloBufferOffsets[i]], haloBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 17, mpiComm(),
                   &haloReq[haloCnt], AT_, "haloBuffer[haloBufferOffsets[i]]");
        haloCnt++;
      }
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(windowBufferCnts(i) == 0) continue;
        MPI_Recv(&windowBuffer[windowBufferOffsets[i]], windowBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 17,
                 mpiComm(), MPI_STATUS_IGNORE, AT_, "windowBuffer[windowBufferOffsets[i]]");
        windowCnt++;
      }
    }

    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_fvBndryCnd->m_nearBoundaryWindowCells[i].empty()) continue;
      for(MInt j = 0; j < (signed)m_fvBndryCnd->m_nearBoundaryWindowCells[i].size(); j++) {
        MInt cellId = m_fvBndryCnd->m_nearBoundaryWindowCells[i][j];
        MInt offset = windowBufferOffsets(i) + (noCVars + noFVars + 3) * j;
        // ASSERT( a_hasProperty( cellId , SolverCell::NearWall ), "" );
        redistVol(cellId) += windowBuffer(offset);
        redistSweptVol(cellId) += windowBuffer(offset + 1);

        for(MInt v = 0; v < (signed)noPVars; v++) {
          a_slope(cellId, v, 0) += windowBuffer(offset + 3 + v);
          a_slope(cellId, v, 1) += windowBuffer(offset + 3 + noPVars + v);
        }
      }
    }
    if(haloCnt > 0) MPI_Waitall(haloCnt, &haloReq[0], MPI_STATUSES_IGNORE, AT_);
  }

  for(MUint c = 0; c < m_bndryLayerCells.size(); c++) {
    MInt cellId = m_bndryLayerCells[c];
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(a_isPeriodic(cellId)) continue;
    if(a_isHalo(cellId)) continue;
    if(fabs(redistVol(cellId)) < 1e-12) continue;

    MFloat vol = m_cellVolumesDt1[cellId] + redistVol(cellId);
    if(fabs(vol) > 1e-14) {
      for(MUint v = 0; v < noCVars; v++) {
        a_oldVariable(cellId, v) = (a_oldVariable(cellId, v) * m_cellVolumesDt1[cellId] + a_slope(cellId, v, 0))
                                   / (m_cellVolumesDt1[cellId] + redistVol(cellId));
        m_rhs0[cellId][v] += a_slope(cellId, v, 1);
      }
    }
    m_cellVolumesDt1[cellId] = vol;
#ifdef GEOM_CONS_LAW
    if(a_bndryId(cellId) > -1) {
      a_cellVolume(cellId) += redistVol(cellId);
      m_sweptVolumeDt1[a_bndryId(cellId)] += redistSweptVol(cellId);
      if(m_gclIntermediate) {
        if(m_levelSetMb) a_cellVolume(cellId) += redistSweptVol(cellId);
      } else {
        if(m_levelSetMb) a_cellVolume(cellId) += F1B2 * redistSweptVol(cellId);
      }
      a_cellVolume(cellId) = mMax(m_volumeThreshold, a_cellVolume(cellId));
      a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
      m_volumeFraction[a_bndryId(cellId)] = a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId));
    } else {
      cerr << "not supposed to happen at redist" << endl;
    }
#endif
  }


#ifdef GEOM_CONS_LAW
  MBool& firstRun = m_static_redistributeMass_firstRun;

  MBool conserveMass = true;
  if(m_gapInitMethod == 0 && m_gapOpened) {
    conserveMass = false;
  } else if(m_gapInitMethod > 0) {
    conserveMass = true;
  }

  if(!firstRun && conserveMass) {
    if(m_gclIntermediate) {
      // init with the minium volume to increase stability of small cell treatment
      const MInt noBCells = m_fvBndryCnd->m_bndryCells->size();
      for(MInt bndryId = m_noOuterBndryCells; bndryId < noBCells; bndryId++) {
        MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
        MFloat dV0 = m_sweptVolumeDt1[bndryId];
        MFloat dV1 = m_sweptVolume[bndryId];
        MFloat vol = m_cellVolumesDt1[cellId] + dV0;
        for(MInt r = 1; r < m_noRKSteps; r++) {
          const MFloat deltaVol = m_RKalpha[r - 1] * dV1 + (F1 - m_RKalpha[r - 1]) * dV0;
          vol = mMin(m_cellVolumesDt1[cellId] + deltaVol, vol);
        }
        vol = mMax(F0, vol);
        a_cellVolume(cellId) = vol;
        a_cellVolume(cellId) = mMax(a_cellVolume(cellId), m_volumeThreshold);
        m_volumeFraction[bndryId] = a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId));
        a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
      }
    } else {
      const MInt noBCells = m_fvBndryCnd->m_bndryCells->size();
      for(MInt bndryId = m_noOuterBndryCells; bndryId < noBCells; bndryId++) {
        MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
        if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
        MFloat dV0 = m_sweptVolumeDt1[bndryId];
        MFloat dV1 = m_sweptVolume[bndryId];
        a_cellVolume(cellId) =
            m_cellVolumesDt1[cellId] + m_RKalpha[m_noRKSteps - 2] * dV1 + (F1 - m_RKalpha[m_noRKSteps - 2]) * dV0;
        a_cellVolume(cellId) = mMax(a_cellVolume(cellId), m_volumeThreshold);
        a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
      }
    }
  }
  firstRun = false;
#endif


  // truncate cell volumes for large deviations due to GCL
  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    const MFloat V0 = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume - 0.1 * grid().gridCellVolume(a_level(cellId));
    const MFloat V1 = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume + 0.1 * grid().gridCellVolume(a_level(cellId));
    a_cellVolume(cellId) = mMin(V1, mMax(V0, a_cellVolume(cellId)));
    a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
  }

  {
    // 2. synchronize cell volumes
    haloReq.fill(MPI_REQUEST_NULL);
    windowReq.fill(MPI_REQUEST_NULL);
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_fvBndryCnd->m_nearBoundaryWindowCells[i].empty()) continue;
      for(MInt j = 0; j < (signed)m_fvBndryCnd->m_nearBoundaryWindowCells[i].size(); j++) {
        MInt cellId = m_fvBndryCnd->m_nearBoundaryWindowCells[i][j];
        MInt offset = windowBufferOffsets(i) + (noCVars + noFVars + 3) * j;
        windowBuffer(offset) = a_cellVolume(cellId);
        windowBuffer(offset + 1) = m_cellVolumesDt1[cellId];
        windowBuffer(offset + 2) = (a_bndryId(cellId) > -1) ? m_sweptVolumeDt1[a_bndryId(cellId)] : F0;
        for(MInt v = 0; v < (signed)noCVars; v++) {
          windowBuffer(offset + 3 + v) = a_oldVariable(cellId, v);
        }
        for(MInt v = 0; v < (signed)noFVars; v++) {
          windowBuffer(offset + 3 + noCVars + v) = m_rhs0[cellId][v];
        }
      }
    }
    MInt windowCnt = 0;
    MInt haloCnt = 0;
    if(m_nonBlockingComm) {
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(haloBufferCnts(i) == 0) continue;
        MPI_Irecv(&haloBuffer[haloBufferOffsets[i]], haloBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 18, mpiComm(),
                  &haloReq[haloCnt], AT_, "haloBuffer[haloBufferOffsets[i]]");
        haloCnt++;
      }
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(windowBufferCnts(i) == 0) continue;
        MPI_Isend(&windowBuffer[windowBufferOffsets[i]], windowBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 18,
                  mpiComm(), &windowReq[windowCnt], AT_, "windowBuffer[windowBufferOffsets[i]]");
        windowCnt++;
      }
      if(haloCnt > 0) MPI_Waitall(haloCnt, &haloReq[0], MPI_STATUSES_IGNORE, AT_);
    } else {
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(windowBufferCnts(i) == 0) continue;
        MPI_Issend(&windowBuffer[windowBufferOffsets[i]], windowBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 18,
                   mpiComm(), &windowReq[windowCnt], AT_, "windowBuffer[windowBufferOffsets[i]]");
        windowCnt++;
      }
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(haloBufferCnts(i) == 0) continue;
        MPI_Recv(&haloBuffer[haloBufferOffsets[i]], haloBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 18, mpiComm(),
                 MPI_STATUS_IGNORE, AT_, "haloBuffer[haloBufferOffsets[i]]");
        haloCnt++;
      }
    }
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_fvBndryCnd->m_nearBoundaryHaloCells[i].empty()) continue;
      for(MInt j = 0; j < (signed)m_fvBndryCnd->m_nearBoundaryHaloCells[i].size(); j++) {
        MInt cellId = m_fvBndryCnd->m_nearBoundaryHaloCells[i][j];
        MInt offset = haloBufferOffsets(i) + (noCVars + noFVars + 3) * j;
        a_cellVolume(cellId) = haloBuffer(offset);
        m_cellVolumesDt1[cellId] = haloBuffer(offset + 1);
        for(MInt v = 0; v < (signed)noCVars; v++) {
          a_oldVariable(cellId, v) = haloBuffer(offset + 3 + v);
        }
        for(MInt v = 0; v < (signed)noFVars; v++) {
          m_rhs0[cellId][v] = haloBuffer(offset + 3 + noCVars + v);
        }
        a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
        if(a_bndryId(cellId) > -1) {
          m_volumeFraction[a_bndryId(cellId)] = a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId));
          m_sweptVolumeDt1[a_bndryId(cellId)] = haloBuffer(offset + 2);
        }
      }
    }
    if(windowCnt > 0) MPI_Waitall(windowCnt, &windowReq[0], MPI_STATUSES_IGNORE, AT_);
  }

#ifndef GEOM_CONS_LAW
  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    a_cellVolume(cellId) = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume;
    a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
    m_volumeFraction[a_bndryId(cellId)] = a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId));
  }
#endif


//#define LOG_DELTA_VOL
#ifdef LOG_DELTA_VOL
  MFloat maxdv = -99999.0;
  MFloat mindv = 99999.0;
  MFloat avgdv = F0;
  MFloat cnt = F0;
  MInt maxId = 0;
  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_isHalo(cellId)) continue;
    MFloat dv = (a_cellVolume(cellId) - m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume)
                / grid().gridCellVolume(a_level(cellId));
    if(dv > maxdv) maxId = cellId;
    maxdv = mMax(maxdv, dv);
    mindv = mMin(mindv, dv);
    avgdv += fabs(dv);
    cnt += F1;
  }
  MPI_Allreduce(MPI_IN_PLACE, &maxdv, 1, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "maxdv");
  MPI_Allreduce(MPI_IN_PLACE, &mindv, 1, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE", "mindv");
  MPI_Allreduce(MPI_IN_PLACE, &avgdv, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "avgdv");
  MPI_Allreduce(MPI_IN_PLACE, &cnt, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "cnt");
  avgdv /= cnt;
  if(domainId() == 0) {
    cerr << "dv: " << globalTimeStep << " " << avgdv << " " << maxdv << " " << mindv << " -- "
         << a_cellVolume(maxId) / grid().gridCellVolume(a_level(maxId)) << " "
         << m_fvBndryCnd->m_bndryCells->a[a_bndryId(maxId)].m_volume / grid().gridCellVolume(a_level(maxId)) << " ("
         << m_cellVolumesDt1[maxId] / grid().gridCellVolume(a_level(maxId)) << " "
         << m_sweptVolume[a_bndryId(maxId)] / grid().gridCellVolume(a_level(maxId)) << " "
         << m_sweptVolumeDt1[a_bndryId(maxId)] / grid().gridCellVolume(a_level(maxId)) << " " << maxId << ")" << endl;
    ofstream ofl;
    ofl.open("vol_err", ios_base::out | ios_base::app);
    if(ofl.is_open() && ofl.good()) {
      ofl << setprecision(12) << globalTimeStep << " " << avgdv << " " << maxdv << " " << mindv << " "
          << a_cellVolume(maxId) / grid().gridCellVolume(a_level(maxId)) << " "
          << m_fvBndryCnd->m_bndryCells->a[a_bndryId(maxId)].m_volume / grid().gridCellVolume(a_level(maxId)) << " "
          << m_cellVolumesDt1[maxId] / grid().gridCellVolume(a_level(maxId)) << " "
          << m_sweptVolume[a_bndryId(maxId)] / grid().gridCellVolume(a_level(maxId)) << " "
          << m_sweptVolumeDt1[a_bndryId(maxId)] / grid().gridCellVolume(a_level(maxId)) << " " << maxId << endl;
      ofl.close();
    }
  }
#endif

  // for ( MInt c = 0; c < m_noNearBndryCells; c++ ) {
  // setPrimitiveVariables(m_nearBndryCells->a[c]);
  for(MUint c = 0; c < m_bndryLayerCells.size(); c++) {
    const MInt cellId = m_bndryLayerCells[c];
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    setPrimitiveVariables(cellId);
  }


#if defined _MB_DEBUG_ || !defined NDEBUG
  m_solutionDiverged = false;
  MInt cnt = 0;
  for(MInt i = a_noCells(); i--;) {
    if(!a_hasProperty(i, SolverCell::IsActive)) continue;
    if(!a_hasProperty(i, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_isHalo(i)) continue;
    if(a_isBndryGhostCell(i)) continue;
    if(a_hasProperty(i, SolverCell::IsInactive)) continue;
    for(MInt v = 0; v < m_noCVars; v++) {
      if(!(a_variable(i, v) >= F0 || a_variable(i, v) < F0) || std::isnan(a_variable(i, v))) {
        if(cnt < 10)
          cerr << setprecision(12) << domainId() << ": MRED " << i << " " << a_bndryId(i) << " " << v << " "
               << a_variable(i, v) << " "
               << "cells[i].b_properties.to_string()"
               << " " << c_noChildren(i) << " " << a_hasProperty(i, SolverCell::IsInactive) << " "
               << a_hasProperty(i, SolverCell::IsSplitCell) << " " << a_hasProperty(i, SolverCell::IsSplitChild) << " "
               << a_cellVolume(i) / grid().gridCellVolume(a_level(i)) << " "
               << m_cellVolumesDt1[i] / grid().gridCellVolume(a_level(i));
        if(i < c_noCells()) cerr << " " << c_globalId(i) << endl;
        m_solutionDiverged = true;
        cnt++;
      }
    }
    MFloat pres = F0;
    IF_CONSTEXPR(nDim == 2) {
      pres =
          sysEqn().pressure(1.0, a_pvariable(i, PV->RHO) * (POW2(a_pvariable(i, PV->U)) + POW2(a_pvariable(i, PV->V))),
                            a_variable(i, CV->RHO_E));
    }
    else IF_CONSTEXPR(nDim == 3) {
      pres = sysEqn().pressure(
          1.0,
          a_pvariable(i, PV->RHO)
              * (POW2(a_pvariable(i, PV->U)) + POW2(a_pvariable(i, PV->V)) + POW2(a_pvariable(i, PV->W))),
          a_variable(i, CV->RHO_E));
    }
    if(a_cellVolume(i) / grid().gridCellVolume(a_level(i)) > m_fvBndryCnd->m_volumeLimitWall) {
      if(a_variable(i, CV->RHO) < F0 || pres < F0) {
        if(cnt < 10)
          cerr << domainId() << ": MRED " << i << " " << a_bndryId(i) << " " << a_level(i) << " /r "
               << a_variable(i, CV->RHO) << " /p " << pres << " /v "
               << a_cellVolume(i) / grid().gridCellVolume(a_level(i)) << " "
               << m_cellVolumesDt1[i] / grid().gridCellVolume(a_level(i)) << " "
               << "cells[i].b_properties.to_string()"
               << " " << a_hasProperty(i, SolverCell::IsSplitCell) << " " << a_hasProperty(i, SolverCell::IsSplitChild)
               << " " << a_isPeriodic(i) << " " << a_coordinate(i, 0) << " " << a_coordinate(i, 1) << " "
               << a_coordinate(i, mMin((MInt)FD, 2));
        if(i < c_noCells()) cerr << " " << c_globalId(i) << endl;
        m_solutionDiverged = true;
        cnt++;
      }
    }
  }
  if(m_solutionDiverged) {
    cerr << "Solution diverged after mass redistribution at solver " << domainId() << " " << globalTimeStep << " "
         << m_RKStep << endl;
  }
  MPI_Allreduce(MPI_IN_PLACE, &m_solutionDiverged, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                "m_solutionDiverged");
  if(m_solutionDiverged) {
    writeVtkXmlFiles("QOUT", "GEOM", false, true);
    MPI_Barrier(mpiComm(), AT_);
    mTerm(1, AT_, "Solution diverged after mass redistribution.");
  }
#endif
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::setAdditionalActiveFlag(MIntScratchSpace& activeFlag) {
  for(MUint it = 0; it < m_temporarilyLinkedCells.size(); it++) {
    activeFlag(get<0>(m_temporarilyLinkedCells[it])) = 1;
    activeFlag(get<1>(m_temporarilyLinkedCells[it])) = 1;
    if(get<2>(m_temporarilyLinkedCells[it]) > 0) {
      activeFlag(get<2>(m_temporarilyLinkedCells[it])) = 1;
    }
  }
}


/**
 * \brief performs an integrety check of the boundary cells
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::checkBoundaryCells() {
  TRACE();

  MInt errorId = 0;
  MInt globalErrorId = 0;


  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;

    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(a_hasProperty(cellId, SolverCell::IsCutOff)) continue;
    if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;
    errorId = 0;

    const MFloat faceArea = (nDim == 3) ? POW2(sqrt(F3) * c_cellLengthAtLevel(a_cutCellLevel(cellId)))
                                        : sqrt(F2) * c_cellLengthAtLevel(a_cutCellLevel(cellId));
    const MFloat faceArea0 =
        (nDim == 3) ? POW2(c_cellLengthAtLevel(a_cutCellLevel(cellId))) : c_cellLengthAtLevel(a_cutCellLevel(cellId));

    ASSERT(m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs > 0, "");

    if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume < F0)
      errorId = 1;
    else if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume > (grid().gridCellVolume(a_level(cellId)) + m_eps))
      errorId = 1;
    else if(std::isnan(m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume))
      errorId = 1;
    if(errorId == 1) m_log << "BC: " << bndryId << " " << cellId << " " << errorId << endl;

    if(m_volumeFraction[bndryId] < F0)
      errorId = 2;
    else if(m_volumeFraction[bndryId] > (F1 + m_eps))
      errorId = 2;
    else if(std::isnan(m_volumeFraction[bndryId]))
      errorId = 2;
    if(errorId == 2) {
      m_log << "BC: " << bndryId << " " << cellId << " " << errorId << " " << m_volumeFraction[bndryId] << endl;
      // if ( !a_isHalo(cellId) ) cerr << domainId() << ": BC " << bndryId << " " << cellId << " " << errorId << " " <<
      // m_volumeFraction[ bndryId ]
      //                                            << " " << a_cellVolume(cellId) << " " << m_cellVolumesDt1[cellId]
      //                                            << " " << c_globalId(cellId) << endl;
    }

    for(MInt i = 0; i < nDim; i++)
      if(std::isnan(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i])) errorId = 3;
    if(errorId == 3) {
      m_log << "BC: " << bndryId << " " << cellId << " " << errorId << endl;
    }

    for(MInt i = 0; i < nDim; i++)
      if(fabs(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i]) > (F1 + m_eps)) errorId = 4;
    if(errorId == 4) {
      IF_CONSTEXPR(nDim == 2) {
        m_log << "BC: " << bndryId << " " << cellId << " " << errorId << " "
              << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[0] << " "
              << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[1] << " " << scientific
              << setprecision(16) << m_volumeFraction[bndryId] << endl;
      }
      else IF_CONSTEXPR(nDim == 3) {
        m_log << "BC: " << bndryId << " " << cellId << " " << errorId << " "
              << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[0] << " "
              << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[1] << " "
              << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[2] << " " << scientific
              << setprecision(16) << m_volumeFraction[bndryId] << endl;
      }
    }

    if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_area < F0)
      errorId = 5;
    else if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_area > (faceArea + m_eps))
      errorId = 5;
    else if(std::isnan(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_area))
      errorId = 5;
    if(errorId == 5) m_log << "BC: " << bndryId << " " << cellId << " " << errorId << endl;

    if(a_hasProperty(cellId, SolverCell::IsInactive))
      errorId = 6;
    else if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel))
      errorId = 6;
    if(errorId == 6) m_log << "BC: " << bndryId << " " << cellId << " " << errorId << endl;

    for(MInt i = 0; i < nDim; i++)
      if(fabs(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[i] - a_coordinate(cellId, i))
         > (F1B2 * c_cellLengthAtLevel(a_cutCellLevel(cellId)) + m_eps))
        errorId = 7;
    for(MInt i = 0; i < nDim; i++)
      if(std::isnan(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[i])) errorId = 7;
    if(errorId == 7) {
      // cerr << "error7 " << domainId() << " " << globalTimeStep << " " << cellId << " "
      //     << m_fvBndryCnd->m_bndryCells->a[ bndryId ].m_noSrfcs << " "
      //     << fabs( m_fvBndryCnd->m_bndryCells->a[ bndryId ].m_srfcs[0]->m_coordinates[ 0 ] - a_coordinate(cellId, 0)
      //     ) - ( F1B2 * c_cellLengthAtLevel( a_cutCellLevel(cellId) ) ) << " "
      //     << fabs( m_fvBndryCnd->m_bndryCells->a[ bndryId ].m_srfcs[0]->m_coordinates[ 1 ] - a_coordinate(cellId, 1)
      //     ) - ( F1B2 * c_cellLengthAtLevel( a_cutCellLevel(cellId) ) )
      //     << endl;
      // errorId = -1;
      m_log << "BC: " << bndryId << " " << cellId << " " << errorId << endl;
    }

    MFloat ar = -F1;
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      MInt srfcId = m_cellSurfaceMapping[cellId][dir];
      if(srfcId > -1) {
        if(a_surfaceArea(srfcId) < F0)
          errorId = 8;
        else if(a_surfaceArea(srfcId) > (faceArea0 + 100 * m_eps))
          errorId = 8;
        else if(std::isnan(a_surfaceArea(srfcId)))
          errorId = 8;
        for(MInt i = 0; i < nDim; i++) {
          if(fabs(a_surfaceCoordinate(srfcId, i) - a_coordinate(cellId, i))
             > (F1B2 * c_cellLengthAtLevel(a_level(cellId)) + 100 * m_eps))
            errorId = 8;
          if(std::isnan(a_surfaceCoordinate(srfcId, i))) errorId = 8;
        }
        if(errorId == 8) m_log << a_surfaceCoordinate(srfcId, 0) << " " << a_surfaceCoordinate(srfcId, 1) << endl;
        if(errorId == 8) m_log << a_coordinate(cellId, 0) << " " << a_coordinate(cellId, 1) << endl;
        ar = a_surfaceArea(srfcId);
      }
    }
    if(errorId == 8) {
      m_log << "BC: " << bndryId << " " << cellId << " " << errorId << " " << ar << " " << ar - faceArea0 << endl;
      for(MInt i = 0; i < nDim; i++)
        m_log << a_coordinate(cellId, i) << " ";
      m_log << endl;
      MInt cndId = m_bndryCandidateIds[cellId];
      if(cndId > -1) {
        for(MInt node = 0; node < m_noCellNodes; node++) {
          m_log << node << " ";
          if(m_candidateNodeSet[cndId * m_noCellNodes + node])
            m_log << m_candidateNodeValues[IDX_LSSETNODES(cndId, node, 0)] << ", ";
          else
            m_log << " -1, ";
        }
        m_log << endl;
      }
      for(MInt dir = 0; dir < m_noDirs; dir++) {
        MInt srfcId = m_cellSurfaceMapping[cellId][dir];
        if(srfcId > -1) {
          m_log << setprecision(12) << dir << " " << srfcId << ": " << a_surfaceArea(srfcId) / faceArea0 << " ";
          for(MInt i = 0; i < nDim; i++)
            m_log << F1B2 * c_cellLengthAtLevel(a_level(cellId))
                         - fabs(a_surfaceCoordinate(srfcId, i) - a_coordinate(cellId, i))
                  << " ";
          m_log << endl;
        }
      }
    }

    for(MInt i = 0; i < nDim; i++) {
      if(fabs(m_fvBndryCnd->m_bndryCells->a[bndryId].m_coordinates[i])
         > (F1B2 * c_cellLengthAtLevel(a_cutCellLevel(cellId)) + m_eps)) {
        m_log << "check BC: " << bndryId << " " << errorId << " " << setprecision(16) << m_volumeFraction[bndryId]
              << setprecision(8) << " "
              << m_fvBndryCnd->m_bndryCells->a[bndryId].m_coordinates[i] / c_cellLengthAtLevel(a_cutCellLevel(cellId))
              << " " << F1B2 * c_cellLengthAtLevel(a_cutCellLevel(cellId)) << endl;
        errorId = 9 + i;
      }
      if(std::isnan(m_fvBndryCnd->m_bndryCells->a[bndryId].m_coordinates[i])) {
        m_log << "check BC: " << bndryId << " " << errorId << " " << setprecision(16) << m_volumeFraction[bndryId]
              << setprecision(8) << " "
              << m_fvBndryCnd->m_bndryCells->a[bndryId].m_coordinates[i] / c_cellLengthAtLevel(a_cutCellLevel(cellId))
              << " " << F1B2 * c_cellLengthAtLevel(a_cutCellLevel(cellId)) << endl;
        errorId = 9 + i;
      }
    }
    globalErrorId = mMax(globalErrorId, errorId);
  }

  if(globalErrorId > 0) {
    m_log << "Warning " << globalErrorId << " in FvMbCartesianSolverXD::checkBoundaryCells at timestep "
          << globalTimeStep << endl;
    cerr << "Warning " << globalErrorId << " in FvMbCartesianSolverXD::checkBoundaryCells at timestep "
         << globalTimeStep << endl;
    stringstream GName;
    GName.str("");
    GName << m_solutionOutput;
    GName << "solver_data/GEOM";
    GName << "_B" << domainId();
    GName << "_00" << globalTimeStep;
    GName << "_warning";
    GName << ".vtp";
    // writeGeometryToVtkXmlFile( GName.str() );
  }
}


template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::updateCellVolumeGCL(MInt bndryId) {
  TRACE();

  const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;

  MFloat dV = F0;
  if(m_dualTimeStepping) {
    mTerm(1, AT_, "TODO DTS");
    a_cellVolume(cellId) = F4B3 * m_cellVolumesDt1[cellId] - F1B3 * m_cellVolumesDt2[cellId];
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      MFloat area = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
      for(MInt i = 0; i < nDim; i++) {
        MFloat nml = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
        dV -= F2B3 * m_physicalTimeStep
              * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] * nml * area;
      }
    }
  } else {
    MFloat dt = timeStep(true);
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      MFloat area = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
      for(MInt i = 0; i < nDim; i++) {
        MFloat nml = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
        dV -= dt * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] * nml * area;
      }
    }
  }


  m_sweptVolume[bndryId] = dV;

  MFloat deltaVol = dV;
  if(m_gclIntermediate) {
    if(m_levelSetMb) {
      // deltaVol = ( m_RKStep == 0 ) ? m_sweptVolumeDt1[ bndryId ] : m_RKalpha[ m_RKStep-1 ] * m_sweptVolume[ bndryId ]
      // + (F1-m_RKalpha[ m_RKStep-1 ]) * m_sweptVolumeDt1[ bndryId ] ;
      deltaVol = m_RKalpha[m_noRKSteps - 2] * m_sweptVolume[bndryId]
                 + (F1 - m_RKalpha[m_noRKSteps - 2]) * m_sweptVolumeDt1[bndryId];
    }
  } else {
    // deltaVol = ( m_levelSetMb ) ? F1B2 * ( m_sweptVolume[ bndryId ] + m_sweptVolumeDt1[ bndryId ] ) : dV;
    deltaVol = (m_levelSetMb) ? m_RKalpha[m_noRKSteps - 2] * m_sweptVolume[bndryId]
                                    + (F1 - m_RKalpha[m_noRKSteps - 2]) * m_sweptVolumeDt1[bndryId]
                              : dV;
  }
  a_cellVolume(cellId) = m_cellVolumesDt1[cellId] + deltaVol;

  const MFloat V0 = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume - 0.1 * grid().gridCellVolume(a_level(cellId));
  const MFloat V1 = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume + 0.1 * grid().gridCellVolume(a_level(cellId));
  a_cellVolume(cellId) = mMin(V1, mMax(V0, a_cellVolume(cellId)));

  a_cellVolume(cellId) = mMax(a_cellVolume(cellId), m_volumeThreshold);
  a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));

  /*
    if ( a_hasProperty( cellId ,  SolverCell::IsSplitCell ) || a_hasProperty( cellId ,  SolverCell::IsSplitChild ) ) {
      a_cellVolume( cellId ) = m_fvBndryCnd->m_bndryCells->a[ bndryId ].m_volume;
      m_cellVolumesDt1[ cellId ] = a_cellVolume( cellId ) - deltaVol;
    }*/
  if(m_levelSet && m_closeGaps) {
    if(a_wasGapCell(cellId) || a_isGapCell(cellId)) {
      // TODO-Timw labels:FVMB set volume of new-Gap-Bndry-Cells!
      //           only change during initGapOpen
      if(m_gapInitMethod > 0) {
        MInt regionId = m_gapCells[m_gapCellId[cellId]].region;
        ASSERT(regionId > -1, "Negative region in Cell" << to_string(c_globalId(cellId)) << " " << m_gapCellId[cellId]);

        // labels:FVMB G0-hack
        if(regionId == m_noGapRegions) {
          // ASSERT(a_wasGapCell(cellId) == a_isGapCell(cellId ), "");
          // zero-volume change in G0-region cells:
          a_cellVolume(cellId) = m_cellVolumesDt1[cellId];
          m_sweptVolume[bndryId] = 0;
          m_sweptVolumeDt1[bndryId] = 0;

        } else {
          if(m_gapState[regionId] == -2 || m_gapState[regionId] == 3 || m_gapState[regionId] == -1) {
            // for gap-Closure, gap-Widening and gap-Shrinking, static initialisation!
            // handeled in updateGapBoundaryCells, just some checks here
            // for gapCells, not for old gapCells, which are handeled regularly!
            if(a_isGapCell(cellId)) {
              if(fabs(a_cellVolume(cellId) - m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume)
                 > m_volumeThreshold * 10) {
                // if(a_cellVolume( cellId ) > m_fvBndryCnd->m_bndryCells->a[ bndryId ].m_volume ||
                //   a_cellVolume( cellId ) < m_fvBndryCnd->m_bndryCells->a[ bndryId ].m_volume) {

                //  if(a_cellVolume( cellId ) > m_volumeThreshold * 10) {
                /*
                cerr << "Incorrect Volume-Initialisation " << a_cellVolume(cellId) << " "
                     << m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume << " "
                     << a_hasProperty(cellId, SolverCell::IsSplitCell) << " "
                     << a_hasProperty(cellId, SolverCell::IsSplitChild) << " " << a_isHalo(cellId) << " "
                     << m_gapCells[m_gapCellId[cellId]].status << endl;
                */
                //}
              }

              if(m_sweptVolume[bndryId] > 0 || m_sweptVolume[bndryId] < 0 || m_sweptVolumeDt1[bndryId] < 0
                 || m_sweptVolumeDt1[bndryId] < 0) {
                cerr << " Incorrect swetVolume-Innitialisation " << m_sweptVolume[bndryId] << m_sweptVolumeDt1[bndryId]
                     << endl;
              }
            }

          } else if(m_gapState[regionId] == 2) {
            ASSERT(a_wasGapCell(cellId) && !a_isGapCell(cellId), "");
            MInt status = m_gapCells[m_gapCellId[cellId]].status;
            // status 27: former internal, now bndry-Cell -> handeled regularly

            if(status != 27) {
              if(status != 22 && status != 24 && status != 28 && status != 29 && status != 99 && status != 98) {
                cerr << "UnExpected Status for Volume (1) " << c_globalId(cellId) << " " << status << endl;
              }

              // for gap-Opening, just as a restart!
              // THIS IS NOT FULLY WORKING YET!!!!

              if(deltaVol > m_sweptVolumeDt1[bndryId] || deltaVol < m_sweptVolumeDt1[bndryId]) {
                if(m_gapCells[m_gapCellId[cellId]].status != 98)
                  cerr << "Incorrect Initialisation " << c_globalId(cellId) << " "
                       << m_gapCells[m_gapCellId[cellId]].status << endl;
              }

              a_cellVolume(cellId) = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume;

              if(deltaVol > a_cellVolume(cellId)) {
                deltaVol = a_cellVolume(cellId);
                m_sweptVolume[bndryId] = deltaVol;
              }
              m_cellVolumesDt1[cellId] = a_cellVolume(cellId) - deltaVol;
              m_sweptVolumeDt1[bndryId] = m_sweptVolume[bndryId];
            }
          }
          // some additional and more generalised checks:

          if(a_cellVolume(cellId) < 0 || m_cellVolumesDt1[cellId] < 0) {
            cerr << "Negative Cell-Volume : " << c_globalId(cellId) << " " << a_cellVolume(cellId) << " "
                 << m_cellVolumesDt1[cellId] << " " << deltaVol << " " << dV << " " << m_sweptVolume[bndryId]
                 << " status " << m_gapCells[m_gapCellId[cellId]].status << endl;
          }

          if(a_cellVolume(cellId) > 1.03 * grid().gridCellVolume(a_level(cellId))) {
            cerr << "Volume exeeds Limit " << c_globalId(cellId) << " "
                 << a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) << " "
                 << a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId)) << " status "
                 << m_gapCells[m_gapCellId[cellId]].status << endl;
          }

          if(m_cellVolumesDt1[cellId] > 1.03 * grid().gridCellVolume(a_level(cellId))) {
            cerr << "Dt-Volume exeeds Limit " << c_globalId(cellId) << " "
                 << a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) << " "
                 << m_cellVolumesDt1[cellId] / grid().gridCellVolume(a_level(cellId)) << " " << deltaVol << " "
                 << m_gapCells[m_gapCellId[cellId]].status << endl;
          }
        }

      } else {
        a_cellVolume(cellId) = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume;
        m_cellVolumesDt1[cellId] = a_cellVolume(cellId) - deltaVol;
      }
    }
  }

  return deltaVol;
}


/**
 * \brief computes the volume fraction V/h^d and the level-set value in the volumetric center of all boundary   cells,
 * \note{includes extra treatment for extremely small 3D cut-cells}
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::computeVolumeFraction() {
  TRACE();

  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;

    a_cellVolume(cellId) = mMax(m_volumeThreshold, m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume);
    a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
    m_volumeFraction[bndryId] = mMax(m_volumeThreshold, m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume)
                                / grid().gridCellVolume(a_level(cellId));
  }
}


/**
 * \brief calls sets() and stores the time step for all cells
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::setTimeStep() {
  TRACE();

  if(m_timeStepAdaptationStart > -1 && m_timeStepAdaptationEnd > -1) {
    adaptTimeStep();
  }

  m_previousTimeStep = timeStep(true);
  FvCartesianSolverXD<nDim, SysEqn>::setTimeStep();
  const MFloat newTimeStep = timeStep(true);

  // update periodicGhostBody-Distance
  if(m_constructGField) {
    MFloat maxDispl = F2 * newTimeStep * m_UInfinity;
    if(m_adaptation) {
      m_periodicGhostBodyDist =
          1.1
          * (m_outerBandWidth[mMin(maxUniformRefinementLevel(), maxRefinementLevel() - 1)]
             + ((MFloat)noHaloLayers()) * c_cellLengthAtLevel(minLevel()) + m_maxBodyRadius + maxDispl);
    } else {
      m_periodicGhostBodyDist =
          1.1 * (((MFloat)noHaloLayers()) * c_cellLengthAtLevel(minLevel()) + m_maxBodyRadius + maxDispl);
    }
  }

  // log information for possible maximum cfl-number
  MFloat cflMax = F0;
  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_bndryId(cellId) < -1) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    const MFloat a = sysEqn().speedOfSound(a_pvariable(cellId, PV->RHO), a_pvariable(cellId, PV->P));
    for(MInt i = 0; i < nDim; i++) {
      cflMax = mMax(cflMax, newTimeStep * (fabs(a_pvariable(cellId, PV->VV[i])) + a) / c_cellLengthAtCell(cellId));
    }
  }

  MPI_Allreduce(MPI_IN_PLACE, &cflMax, 1, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "cflMax");
  m_log << "Maximum CFL number: " << cflMax << " (" << m_cfl << ")" << endl;

  // update swept volume after timeStep change:
  auto oldBndryCellsBak(m_oldBndryCells);
  m_oldBndryCells.clear();
  for(auto it = oldBndryCellsBak.begin(); it != oldBndryCellsBak.end(); ++it) {
    const MInt cellId = it->first;
    const MFloat sweptVol = it->second;
    const MFloat sweptVolUpdate = sweptVol * (newTimeStep / m_previousTimeStep);
    m_oldBndryCells.insert(make_pair(cellId, sweptVolUpdate));
  }

  // update external source terms after timeStep change for conservation!
  if(m_hasExternalSource) {
    for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
      if(!a_hasProperty(cellId, SolverCell::IsActive)) continue;
      for(MInt var = 0; var < CV->noVariables; var++) {
        a_externalSource(cellId, var) *= m_previousTimeStep / newTimeStep;
      }
    }
  }
}


/**
 * \brief retrieves all direct and diagonal fluid cell neighbours of the given cell
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
MInt FvMbCartesianSolverXD<nDim, SysEqn>::getAdjacentGridCells(MInt cellId, MInt* adjacentCells) {
  MInt cnt = 0;
  set<MInt> nghbrs;

  for(MInt dir0 = 0; dir0 < m_noDirs; dir0++) {
    MInt nghbrId0 = -1;

    if(a_hasNeighbor(cellId, dir0) > 0)
      nghbrId0 = c_neighborId(cellId, dir0);
    else if(c_parentId(cellId) > -1)
      if(a_hasNeighbor(c_parentId(cellId), dir0) > 0) nghbrId0 = c_neighborId(c_parentId(cellId), dir0);

    if(nghbrId0 < 0) continue;

    if(c_noChildren(nghbrId0) > 0) {
      for(MInt child = 0; child < m_noCellNodes; child++) {
        if(!childCode[dir0][child]) continue;
        if(c_childId(nghbrId0, child) > -1) nghbrs.insert(c_childId(nghbrId0, child));
      }
    } else
      nghbrs.insert(nghbrId0);

    for(MInt dir1 = 0; dir1 < m_noDirs; dir1++) {
      if((dir1 / 2) == (dir0 / 2)) continue;

      MInt nghbrId1 = -1;

      if(a_hasNeighbor(nghbrId0, dir1) > 0)
        nghbrId1 = c_neighborId(nghbrId0, dir1);
      else if(c_parentId(nghbrId0) > -1)
        if(a_hasNeighbor(c_parentId(nghbrId0), dir1) > 0) nghbrId1 = c_neighborId(c_parentId(nghbrId0), dir1);

      if(nghbrId1 < 0) continue;

      if(c_noChildren(nghbrId1) > 0) {
        for(MInt child = 0; child < m_noCellNodes; child++) {
          if(!childCode[dir0][child] || !childCode[dir1][child]) continue;
          if(c_childId(nghbrId1, child) > -1) nghbrs.insert(c_childId(nghbrId1, child));
        }
      } else
        nghbrs.insert(nghbrId1);
      IF_CONSTEXPR(nDim == 3) {
        for(MInt dir2 = 0; dir2 < m_noDirs; dir2++) {
          if(((dir2 / 2) == (dir0 / 2)) || ((dir2 / 2) == (dir1 / 2))) continue;
          MInt nghbrId2 = -1;
          if(a_hasNeighbor(nghbrId1, dir2) > 0)
            nghbrId2 = c_neighborId(nghbrId1, dir2);
          else if(c_parentId(nghbrId1) > -1)
            if(a_hasNeighbor(c_parentId(nghbrId1), dir2) > 0) nghbrId2 = c_neighborId(c_parentId(nghbrId1), dir2);
          if(nghbrId2 < 0) continue;
          // nghbrs.insert( nghbrId2 );
          if(c_noChildren(nghbrId2) > 0) {
            for(MInt child = 0; child < m_noCellNodes; child++) {
              if(!childCode[dir0][child] || !childCode[dir1][child] || !childCode[dir2][child]) continue;
              if(c_childId(nghbrId2, child) > -1) nghbrs.insert(c_childId(nghbrId2, child));
            }
          } else
            nghbrs.insert(nghbrId2);
        }
      }
    }
  }
  set<MInt>::iterator it = nghbrs.begin();
  for(it = nghbrs.begin(); it != nghbrs.end(); it++) {
    ASSERT(cnt < 27 * m_noCellNodes, "");
    adjacentCells[cnt] = *it;
    cnt++;
  }
  return cnt;
}


/**
 * \brief retrieves all direct and diagonal fluid cell neighbours of the given cell
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
MInt FvMbCartesianSolverXD<nDim, SysEqn>::getEqualLevelNeighbors(MInt cellId, MInt (&nghbrs)[27]) {
  constexpr MInt offs[3] = {1, 3, 9};
  auto nbIdx0 = [&]() { return 13; };
  auto nbIdx1 = [&](MInt dir0, MInt sign0) { return nbIdx0() + offs[dir0] * sign0; };
  auto nbIdx2 = [&](MInt dir0, MInt sign0, MInt dir1, MInt sign1) {
    return nbIdx0() + offs[dir0] * sign0 + offs[dir1] * sign1;
  };
  std::fill_n(nghbrs, 27, -1);
  nghbrs[nbIdx0()] = cellId;

  for(MInt dir0 = 0; dir0 < m_noDirs; dir0++) {
    MInt nghbrId0 = -1;

    if(a_hasNeighbor(cellId, dir0) > 0) {
      nghbrId0 = c_neighborId(cellId, dir0);
    }

    if(nghbrId0 < 0) continue;

    MInt sign0 = (dir0 % 2 == 0) ? -1 : 1;
    ASSERT(nghbrs[nbIdx1(dir0 / 2, sign0)] == -1 || nghbrs[nbIdx1(dir0 / 2, sign0)] == nghbrId0, "");
    nghbrs[nbIdx1(dir0 / 2, sign0)] = nghbrId0;

    for(MInt dir1 = 0; dir1 < m_noDirs; dir1++) {
      if((dir1 / 2) == (dir0 / 2)) continue;
      MInt nghbrId1 = -1;
      if(a_hasNeighbor(nghbrId0, dir1) > 0) {
        nghbrId1 = c_neighborId(nghbrId0, dir1);
      }
      if(nghbrId1 < 0) continue;
      MInt sign1 = (dir1 % 2 == 0) ? -1 : 1;
      ASSERT(nghbrs[nbIdx2(dir0 / 2, sign0, dir1 / 2, sign1)] == -1
                 || nghbrs[nbIdx2(dir0 / 2, sign0, dir1 / 2, sign1)] == nghbrId1,
             "");
      nghbrs[nbIdx2(dir0 / 2, sign0, dir1 / 2, sign1)] = nghbrId1;
      IF_CONSTEXPR(nDim == 3) {
        auto nbIdx3 = [&](MInt ldir0, MInt lsign0, MInt ldir1, MInt lsign1, MInt ldir2, MInt lsign2) {
          return nbIdx0() + offs[ldir0] * lsign0 + offs[ldir1] * lsign1 + offs[ldir2] * lsign2;
        };
        for(MInt dir2 = 0; dir2 < m_noDirs; dir2++) {
          if(((dir2 / 2) == (dir0 / 2)) || ((dir2 / 2) == (dir1 / 2))) continue;
          MInt nghbrId2 = -1;
          if(a_hasNeighbor(nghbrId1, dir2) > 0) {
            nghbrId2 = c_neighborId(nghbrId1, dir2);
          }
          if(nghbrId2 < 0) continue;
          MInt sign2 = (dir2 % 2 == 0) ? -1 : 1;
          ASSERT(nghbrs[nbIdx3(dir0 / 2, sign0, dir1 / 2, sign1, dir2 / 2, sign2)] == -1
                     || nghbrs[nbIdx3(dir0 / 2, sign0, dir1 / 2, sign1, dir2 / 2, sign2)] == nghbrId2,
                 "");
          nghbrs[nbIdx3(dir0 / 2, sign0, dir1 / 2, sign1, dir2 / 2, sign2)] = nghbrId2;
        }
      }
    }
  }

  return (std::count_if(nghbrs, nghbrs + 27, [](const MInt& a) { return (a > -1); }));
}


/**
 * \brief retrieves all direct and diagonal fluid cell neighbours of the given cell
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
MInt FvMbCartesianSolverXD<nDim, SysEqn>::getAdjacentCells(MInt cellId, MInt* adjacentCells) {
  MInt cnt = 0;
  set<MInt> nghbrs;

  for(MInt dir0 = 0; dir0 < m_noDirs; dir0++) {
    if(a_hasNeighbor(cellId, dir0) == 0) continue;

    const MInt nghbrId0 = c_neighborId(cellId, dir0);

    if(nghbrId0 < 0) continue;

    if(a_hasProperty(nghbrId0, SolverCell::IsOnCurrentMGLevel) && !a_hasProperty(nghbrId0, SolverCell::IsInactive)
       && !a_isBndryGhostCell(nghbrId0)) {
      adjacentCells[cnt] = nghbrId0;
      cnt++;
    }
    for(MInt dir1 = 0; dir1 < m_noDirs; dir1++) {
      if((dir1 / 2) == (dir0 / 2)) continue;
      if(a_hasNeighbor(nghbrId0, dir1) == 0) continue;
      const MInt nghbrId1 = c_neighborId(nghbrId0, dir1);
      if(nghbrId1 < 0) continue;
      if(a_hasProperty(nghbrId1, SolverCell::IsOnCurrentMGLevel) && !a_hasProperty(nghbrId1, SolverCell::IsInactive)
         && !a_isBndryGhostCell(nghbrId1))
        nghbrs.insert(nghbrId1);
#ifdef __REMOVE_TO_USE__
      IF_CONSTEXPR(nDim == 3) {
        for(MInt dir2 = 0; dir2 < m_noDirs; dir2++) {
          if(((dir2 / 2) == (dir0 / 2)) || ((dir2 / 2) == (dir1 / 2))) continue;
          if(a_hasNeighbor(nghbrId1, dir2) == 0) continue;
          const MInt nghbrId2 = c_neighborId(nghbrId1, dir2);
          if(nghbrId2 < 0) continue;
          if(a_hasProperty(nghbrId2, SolverCell::IsOnCurrentMGLevel) && !a_hasProperty(nghbrId2, SolverCell::IsInactive)
             && !a_isBndryGhostCell(nghbrId2))
            nghbrs.insert(nghbrId2);
        }
      }
#endif
    }
  }
  set<MInt>::iterator it = nghbrs.begin();
  for(it = nghbrs.begin(); it != nghbrs.end(); it++) {
    adjacentCells[cnt] = *it;
    cnt++;
  }
  return cnt;
}


/**
 * \brief retrieves all direct and diagonal fluid cell neighbours of the given cell
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
MInt FvMbCartesianSolverXD<nDim, SysEqn>::getAdjacentCellsAllLevels(MInt cellId, MInt* adjacentCells) {
  set<MInt> nghbrs;

  for(MInt dir0 = 0; dir0 < m_noDirs; dir0++) {
    MInt nghbrId0 = -1;

    if(a_hasNeighbor(cellId, dir0) > 0)
      nghbrId0 = c_neighborId(cellId, dir0);
    else if(c_parentId(cellId) > -1)
      if(a_hasNeighbor(c_parentId(cellId), dir0) > 0) nghbrId0 = c_neighborId(c_parentId(cellId), dir0);

    if(nghbrId0 < 0) continue;

    const MInt noC0 = c_noChildren(nghbrId0);

    for(MInt c0 = 0; c0 < mMax(1, noC0); c0++) {
      if(noC0 && !childCode[dir0][c0]) continue;
      MInt nghbrId00 = noC0 ? c_childId(nghbrId0, c0) : nghbrId0;
      if(nghbrId00 < 0) continue;
      if(a_hasProperty(nghbrId00, SolverCell::IsOnCurrentMGLevel) && !a_hasProperty(nghbrId00, SolverCell::IsInactive)
         && !a_isBndryGhostCell(nghbrId00)) {
        nghbrs.insert(nghbrId00);
      }
      for(MInt dir1 = 0; dir1 < m_noDirs; dir1++) {
        if((dir1 / 2) == (dir0 / 2)) continue;
        MInt nghbrId1 = -1;
        if(a_hasNeighbor(nghbrId00, dir1) > 0)
          nghbrId1 = c_neighborId(nghbrId00, dir1);
        else if(c_parentId(nghbrId00) > -1)
          if(a_hasNeighbor(c_parentId(nghbrId00), dir1) > 0) nghbrId1 = c_neighborId(c_parentId(nghbrId00), dir1);
        if(nghbrId1 < 0) continue;
        const MInt noC1 = c_noChildren(nghbrId1);
        for(MInt c1 = 0; c1 < mMax(1, noC1); c1++) {
          if(noC1 && !childCode[dir1][c1]) continue;
          MInt nghbrId11 = noC1 ? c_childId(nghbrId1, c1) : nghbrId1;
          if(nghbrId11 < 0) continue;
          MBool facing = true;
          for(MInt i = 0; i < nDim; i++) {
            if(fabs(a_coordinate(cellId, i) - a_coordinate(nghbrId00, i))
               > ((F1 + 1e-8) * c_cellLengthAtLevel(a_level(cellId))
                  + (F1 + 1e-8) * c_cellLengthAtLevel(a_level(nghbrId00))))
              facing = false;
          }
          if(!facing) continue;
          if(a_hasProperty(nghbrId11, SolverCell::IsOnCurrentMGLevel)
             && !a_hasProperty(nghbrId11, SolverCell::IsInactive) && !a_isBndryGhostCell(nghbrId11)) {
            nghbrs.insert(nghbrId11);
          }

#ifdef __REMOVE_TO_USE__
          IF_CONSTEXPR(nDim == 3) {
            mTerm(1, AT_, "TODO");
            for(MInt dir2 = 0; dir2 < m_noDirs; dir2++) {
              if(((dir2 / 2) == (dir0 / 2)) || ((dir2 / 2) == (dir1 / 2))) continue;
              if(a_hasNeighbor(nghbrId1, dir2) == 0) continue;
              const MInt nghbrId2 = c_neighborId(nghbrId1, dir2);
              if(nghbrId2 < 0) continue;
              if(a_hasProperty(nghbrId2, SolverCell::IsOnCurrentMGLevel)
                 && !a_hasProperty(nghbrId2, SolverCell::IsInactive) && !a_isBndryGhostCell(nghbrId2))
                nghbrs.insert(nghbrId2);
            }
          }
#endif
        }
      }
    }
  }

  MInt cnt = 0;
  for(set<MInt>::iterator it = nghbrs.begin(); it != nghbrs.end(); it++) {
    adjacentCells[cnt] = *it;
    cnt++;
  }
  return cnt;
}


/**
 * \brief retrieves the first two layers of direct and diagonal fluid cell neighbours of the given cell
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
MInt FvMbCartesianSolverXD<nDim, SysEqn>::getAdjacentCellsExtended(MInt cellId, MInt* adjacentCells) {
  MInt cnt = getAdjacentCells(cellId, adjacentCells);
  set<MInt> nghbrs;

  for(MInt dir0 = 0; dir0 < m_noDirs; dir0++) {
    if(a_hasNeighbor(cellId, dir0) == 0) continue;
    const MInt nghbrId00 = c_neighborId(cellId, dir0);
    if(a_hasNeighbor(nghbrId00, dir0) == 0) continue;
    const MInt nghbrId0 = c_neighborId(nghbrId00, dir0);
    if(nghbrId0 < 0) continue;
    if(a_hasProperty(nghbrId0, SolverCell::IsOnCurrentMGLevel) && !a_hasProperty(nghbrId0, SolverCell::IsInactive)
       && !a_isBndryGhostCell(nghbrId0)) {
      adjacentCells[cnt] = nghbrId0;
      cnt++;
    }

    for(MInt dir1 = 0; dir1 < m_noDirs; dir1++) {
      if((dir1 / 2) == (dir0 / 2)) continue;
      if(a_hasNeighbor(nghbrId0, dir1) == 0) continue;
      const MInt nghbrId1 = c_neighborId(nghbrId0, dir1);
      if(nghbrId1 < 0) continue;
      if(a_hasProperty(nghbrId1, SolverCell::IsOnCurrentMGLevel) && !a_hasProperty(nghbrId1, SolverCell::IsInactive)
         && !a_isBndryGhostCell(nghbrId1))
        nghbrs.insert(nghbrId1);
#ifdef __REMOVE_TO_USE__
      IF_CONSTEXPR(nDim == 3) {
        for(MInt dir2 = 0; dir2 < m_noDirs; dir2++) {
          if(((dir2 / 2) == (dir0 / 2)) || ((dir2 / 2) == (dir1 / 2))) continue;
          if(a_hasNeighbor(nghbrId1, dir2) == 0) continue;
          const MInt nghbrId2 = c_neighborId(nghbrId1, dir2);
          if(nghbrId2 < 0) continue;
          if(a_hasProperty(nghbrId2, SolverCell::IsOnCurrentMGLevel) && !a_hasProperty(nghbrId2, SolverCell::IsInactive)
             && !a_isBndryGhostCell(nghbrId2))
            nghbrs.insert(nghbrId2);
        }
      }
#endif
    }
  }
  set<MInt>::iterator it = nghbrs.begin();
  for(it = nghbrs.begin(); it != nghbrs.end(); it++) {
    adjacentCells[cnt] = *it;
    cnt++;
  }
  return cnt;
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::applyBoundaryConditionSlope() {
  TRACE();

  mTerm(1, AT_, "deprecated, ghost cells are not anticipated for memory efficiency.");

  for(MUint c = 0; c < m_bndryLayerCells.size(); c++) {
    const MInt cellId = m_bndryLayerCells[c];

    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    if(a_isBndryGhostCell(cellId)) continue;
    if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;
    if(a_bndryId(cellId) < -1) continue;
    if(c_noChildren(cellId) > 0) continue;

    const MInt bndryId = a_bndryId(cellId);
    MFloatScratchSpace dummyPvariables(m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs, PV->noVariables, AT_,
                                       "dummyPvariables");
    for(MInt set = m_startSet; set < m_noSets; set++) {
      if(a_associatedBodyIds(cellId, set) < 0) continue;

      const MInt ghostCellId = -1; // m_nearBndryGhostCells[c][set];

      if(ghostCellId < 0) continue;
      const MInt bodyId = a_associatedBodyIds(cellId, set);
      if(bodyId < 0) {
        cerr << "Warning: no associated body" << endl;
        continue;
      }
      const MFloat phi = a_levelSetValuesMb(cellId, set);
      ASSERT(bodyId > -1 && bodyId < m_noEmbeddedBodies + m_noPeriodicGhostBodies, "");
      MFloat vel[3] = {F0, F0, F0};
      MFloat xsurf[3] = {F0, F0, F0};
      MFloat normal[3] = {F0, F0, F0};
      MInt srfc = -1;
      if(bndryId >= m_noOuterBndryCells) {
        for(MInt s = 0; s < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs; s++) {
          if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[s]->m_bodyId[0] == bodyId) {
            srfc = s;
            break;
          }
        }
        if(srfc < 0 && m_noLevelSetsUsedForMb == 1) mTerm(1, AT_, "srfc not found.");
      }

      for(MInt i = 0; i < nDim; i++) {
        normal[i] = m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVectorCentroid[i];
      }

      for(MInt i = 0; i < nDim; i++) {
        vel[i] = m_bodyVelocity[bodyId * nDim + i];
        xsurf[i] = a_coordinate(cellId, i) - phi * normal[i];
      }

      MFloat dx[3] = {F0, F0, F0};
      MFloat omega[3] = {F0, F0, F0};

      for(MInt i = 0; i < nDim; i++) {
        dx[i] = xsurf[i] - m_bodyCenter[bodyId * nDim + i];
      }

      for(MInt i = 0; i < 3; i++) {
        omega[i] = m_bodyAngularVelocity[bodyId * 3 + i];
      }

      vel[0] += omega[1] * dx[2] - omega[2] * dx[1];
      vel[1] += omega[2] * dx[0] - omega[0] * dx[2];
      IF_CONSTEXPR(nDim == 3) { vel[2] += omega[0] * dx[1] - omega[1] * dx[0]; }

      if(m_euler) {
        MFloat vel2[3];
        for(MInt i = 0; i < nDim; i++) {
          vel2[i] = a_pvariable(cellId, PV->VV[i]);
          for(MInt j = 0; j < nDim; j++) {
            vel2[i] += m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i]
                       * (vel[i] - a_pvariable(cellId, PV->VV[j]))
                       * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[j];
          }
        }
        for(MInt i = 0; i < nDim; i++) {
          vel[i] = vel2[i];
        }
      }

      MFloat imageVel[3];
      for(MInt i = 0; i < nDim; i++) {
        imageVel[i] = a_pvariable(cellId, PV->VV[i]);
      }
      if(bndryId >= m_noOuterBndryCells && srfc > -1) {
        for(MInt s = 0; s < mMin((signed)m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.size(),
                                 m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs);
            s++) {
          for(MInt i = 0; i < nDim; i++) {
            dummyPvariables(s, PV->VV[i]) = vel[i];
          }
        }
        for(MInt i = 0; i < nDim; i++) {
          imageVel[i] = F0;
        }
        for(MInt n = 0; n < (signed)m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.size(); n++) {
          const MInt nghbrId = m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n];
          for(MInt i = 0; i < nDim; i++) {
            const MFloat nghbrPvariable = (n < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs)
                                              ? dummyPvariables(n, PV->VV[i])
                                              : a_pvariable(nghbrId, PV->VV[i]);
            imageVel[i] +=
                m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst[n] * nghbrPvariable;
          }
        }
        MFloat vf = a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId));
        MFloat fac = maia::math::deltaFun(vf, 0.95, F1);
        for(MInt i = 0; i < nDim; i++) {
          imageVel[i] = (fac * a_pvariable(cellId, PV->VV[i]) + (F1 - fac) * imageVel[i]);
        }
      }


      for(MInt i = 0; i < nDim; i++) {
        a_pvariable(ghostCellId, PV->VV[i]) = F2 * vel[i] - imageVel[i];
      }


      MFloat dn = F0;
      for(MInt i = 0; i < nDim; i++) {
        dn += (a_coordinate(cellId, i) - a_coordinate(ghostCellId, i)) * normal[i];
      }
      dn -= phi;
      if(dn + phi < 1e-8) {
        cerr << domainId() << ": warning very small distance " << c_globalId(cellId) << " " << phi << " " << dn << endl;
      }

      MFloat delta[3] = {F0, F0, F0};
      MFloat dr[3] = {F0, F0, F0};
      MFloat dw[3] = {F0, F0, F0};
      MFloat dg[3] = {F0, F0, F0};
      MFloat du[3] = {F0, F0, F0};
      MFloat dv[3] = {F0, F0, F0};
      for(MInt i = 0; i < nDim; i++) {
        dr[i] = a_coordinate(cellId, i) - phi * normal[i] - m_bodyCenter[bodyId * nDim + i];
        du[i] = m_bodyAcceleration[bodyId * nDim + i];
        dv[i] = vel[i] - m_bodyVelocity[bodyId * nDim + i];
      }
      for(MInt i = 0; i < 3; i++) {
        dw[i] = m_bodyAngularAcceleration[bodyId * 3 + i];
        dg[i] = m_bodyAngularVelocity[bodyId * 3 + i];
      }
      // assemble material acceleration
      delta[0] = du[0] + dw[1] * dr[2] - dw[2] * dr[1] + dg[1] * dv[2] - dg[2] * dv[1];
      delta[1] = du[1] + dw[2] * dr[0] - dw[0] * dr[2] + dg[2] * dv[0] - dg[0] * dv[2];
      delta[2] = du[2] + dw[0] * dr[1] - dw[1] * dr[0] + dg[0] * dv[1] - dg[1] * dv[0];

      MFloat an = F0;
      for(MInt i = 0; i < nDim; i++) {
        an += normal[i] * delta[i];
      }

      MFloat surfTemp = sysEqn().temperature_ES(a_pvariable(cellId, PV->RHO), a_pvariable(cellId, PV->P));
      const MFloat beta = sysEqn().density_ES(an, surfTemp);
      const MFloat fac = (F1 + F1B2 * beta * (dn + phi)) / (F1 - F1B2 * beta * (dn + phi));

      a_pvariable(ghostCellId, PV->P) = fac * a_pvariable(cellId, PV->P);
      a_pvariable(ghostCellId, PV->RHO) = fac * a_pvariable(cellId, PV->RHO);
    }
  }
}


/**
 * \brief correct reconstruction stencil for all cells near moving boundaries
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::buildAdditionalReconstructionStencil() {
  TRACE();

  const MInt recDim = (m_orderOfReconstruction == 2) ? (IPOW2(nDim) + 1) : nDim;

  MIntScratchSpace nghbrList(100, AT_, "nghbrList");
  MIntScratchSpace nghbrListTmp(100, AT_, "nghbrListTmp");
  MIntScratchSpace layerId(100, AT_, "layerList");
  MFloatScratchSpace tmpA(100, recDim, AT_, "tmpA");
  MFloatScratchSpace tmpC(recDim, 100, AT_, "tmpC");
  MFloatScratchSpace weights(100, AT_, "weights");
#if defined _MB_DEBUG_ || !defined NDEBUG
  MFloat cntCnd = F0;
  MFloat avgCnd = F0;
  MFloat maxCnd = F0;
#endif

  // reset noReconstruction neighbors for all bndryLayer Cells
  for(MUint c = 0; c < m_bndryLayerCells.size(); c++) {
    const MInt cellId = m_bndryLayerCells[c];
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    a_hasProperty(cellId, SolverCell::IsFlux) = true;
    a_noReconstructionNeighbors(cellId) = 0;
  }

  // recompute noReconstruction neighbors for all bndryLayeCells
  for(MUint c = 0; c < m_bndryLayerCells.size(); c++) {
    const MInt cellId = m_bndryLayerCells[c];
    if(a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_isBndryGhostCell(cellId)) continue;
    if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(a_bndryId(cellId) < -1) continue;
    if(!a_hasProperty(cellId, SolverCell::IsSplitChild) && c_noChildren(cellId) > 0) continue;
    ASSERT(a_noReconstructionNeighbors(cellId) == 0,
           to_string(cellId) + " " + to_string(c) + " " + to_string(a_noReconstructionNeighbors(cellId)));

    const MInt bndryId = a_bndryId(cellId);

    // add ghostCells as reconstruction neighbor for bndryCells, each bndrySurface has one ghostCell
    if(bndryId >= m_noOuterBndryCells) {
      for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        const MInt ghostCellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
        ASSERT(ghostCellId > -1, "");
        a_reconstructionNeighborId(cellId, a_noReconstructionNeighbors(cellId)) = ghostCellId;
        a_noReconstructionNeighbors(cellId)++;
      }
    }

    const MInt rootCell =
        (a_hasProperty(cellId, SolverCell::IsSplitChild)) ? getAssociatedInternalCell(cellId) : cellId;
    ASSERT(rootCell > -1 && rootCell < a_noCells(), "");

    // get all neighbors (also diagonal) with 1 layer
    // this causes problems at level jumps, as then
    // more than the allowed number of reconstruction neighbors may be found!!!!
    // the last entries are then randomly disregareded!
    MInt counter = -1;
    MInt noactiveNeighbors = 1;
    if(!m_bndryLevelJumps && !m_dynamicStencil) {
      counter = this->template getAdjacentLeafCells<2, true>(rootCell, 1, nghbrList, layerId);
    } else {
      // new faster version which only uses direct neighbors and not diagonal ones
      // counter = this->template getAdjacentLeafCells<0,true>( rootCell, 1, nghbrList, layerId );

      // new!
      // check the number of active neighbors,
      // reduce the stencil if the number is above the threshold!
      // TODO labels:FVMB,totest check if this is done consistently on window&halo cells!
      counter = this->template getAdjacentLeafCells<2, true>(rootCell, 1, nghbrList, layerId);
      // TODO labels:FVMB update testcases to correct value below!
      if(m_engineSetup) {
        noactiveNeighbors = a_noReconstructionNeighbors(cellId);
      }
      for(MInt n = 0; n < counter; n++) {
        const MInt nghbrId = nghbrList[n];
        if(nghbrId < 0) continue;
        if(a_hasProperty(nghbrId, SolverCell::IsInactive)) continue;
        noactiveNeighbors++;
      }
      if(noactiveNeighbors > m_cells.noRecNghbrs() - 1) {
        counter = this->template getAdjacentLeafCells<0, true>(rootCell, 1, nghbrList, layerId);
      }
    }

    // add reconstruction neighbors
    for(MInt n = 0; n < counter; n++) {
      const MInt nghbrId = nghbrList[n];
      if(nghbrId < 0) continue;
      if(a_hasProperty(nghbrId, SolverCell::IsInactive)) continue;
      if(a_noReconstructionNeighbors(cellId) < m_cells.noRecNghbrs()) {
        a_reconstructionNeighborId(cellId, a_noReconstructionNeighbors(cellId)) = nghbrId;
        a_noReconstructionNeighbors(cellId)++;
      } else {
        cerr << "Warning: too many reconstruction neighbors for cell " << cellId;
        if(a_hasProperty(cellId, SolverCell::IsSplitChild)) {
          cerr << "/-";
        } else {
          cerr << "/" << c_globalId(cellId);
        }
        cerr << " " << a_coordinate(cellId, 0) << " " << a_coordinate(cellId, 1) << " " << a_coordinate(cellId, 2)
             << " " << a_noReconstructionNeighbors(cellId) << "/" << counter << endl;
      }
    }


    const MInt offset = m_cells.noRecNghbrs() * cellId;

    // NOTE: cbc cutOff cells should only use direct neighbors for slope-interpolation!
    const MInt mode = (m_fvBndryCnd->m_cbcSmallCellCorrection && a_hasProperty(cellId, SolverCell::IsCutOff))
                          ? 1
                          : m_reConstSVDWeightMode;
    MFloat condNum = computeRecConstSVD(cellId, offset, tmpA, tmpC, weights, recDim, mode, 1);


    // if the condNum is invalid, the stencil is recomputed:
    if((condNum < F0 || condNum > 1e6 || std::isnan(condNum))) {
#if defined _MB_DEBUG_ || !defined NDEBUG

      const MFloat vf = (a_bndryId(cellId) > -1) ? m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_volume
                                                       / grid().gridCellVolume(a_level(cellId))
                                                 : F1;

      cerr << domainId() << " " << globalTimeStep << " recompute stencil for cell " << cellId << "/"
           << c_globalId(cellId) << " level " << a_level(cellId) << " vol "
           << a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId)) << " " << vf << " cond " << condNum << " "
           << endl;
#endif
    }


    if(a_noReconstructionNeighbors(cellId) > m_cells.noRecNghbrs()) {
      mTerm(1, AT_, "Error in buildAdditionalReconstructionStencil too many rec neighbors.");
    }

#if defined _MB_DEBUG_ || !defined NDEBUG
    avgCnd += condNum;
    maxCnd = mMax(maxCnd, condNum);
    cntCnd += F1;
#endif
  }

  m_reconstructionDataSize = 0;
  a_reconstructionData(a_noCells()) = -1;

#if defined _MB_DEBUG_ || !defined NDEBUG
  if(globalTimeStep % 100 == 0) {
    MPI_Allreduce(MPI_IN_PLACE, &maxCnd, 1, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "maxCnd");
    MPI_Allreduce(MPI_IN_PLACE, &avgCnd, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "avgCnd");
    MPI_Allreduce(MPI_IN_PLACE, &cntCnd, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "cntCnd");

    m_log << "Singular value decomposition: near-boundary maximum/average condition number: " << maxCnd << "/"
          << avgCnd / cntCnd << endl;
  }
#endif
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::updateMultiSolverInformation(MBool fullReset) {
  if(noNeighborDomains() == 0) {
    if(noDomains() > 1) mTerm(1, AT_, "Unexpected situation in updateMultiSolverInformation");
    return;
  }

  if(fullReset) {
    mDeallocate(g_mpiRequestMb);
    mDeallocate(m_linkedWindowCells);
    mDeallocate(m_linkedHaloCells);
    mDeallocate(m_gapHaloCells);
    mDeallocate(m_gapWindowCells);
    mAlloc(g_mpiRequestMb, noNeighborDomains(), "g_mpiRequestMb", MPI_REQ_NULL, AT_);
    mAlloc(m_linkedWindowCells, noNeighborDomains(), "m_linkedWindowCells", AT_);
    mAlloc(m_linkedHaloCells, noNeighborDomains(), "m_linkedHaloCells", AT_);
    mAlloc(m_gapWindowCells, noNeighborDomains(), "m_gapWindowCells", AT_);
    mAlloc(m_gapHaloCells, noNeighborDomains(), "m_gapHaloCells", AT_);
  }

  FvCartesianSolverXD<nDim, SysEqn>::updateMultiSolverInformation(fullReset);
}


/**
 * \brief Initializes the solution
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::initSolver() {
  TRACE();

  ASSERT(!m_onlineRestart, "");

  // Nothing further to be done if inactive
  if(!isActive()) return;

  const MFloat time0 = MPI_Wtime();

  // for STL levelset this is called in coupler init!
  if(m_constructGField) {
    if(m_initialCondition == 465) {
      m_initialCondition = -1;
      setInfinityState();
      m_initialCondition = 465;
    }
    initGField();
    initBndryLayer();
  } else {
    initBodyProperties();
  }

  // initialize the runge kutta integration scheme
  initializeRungeKutta();

  if(m_restart) {
    loadRestartFile();
    initBodyProperties();
    if(m_geometryChange == nullptr) {
      loadBodyRestartFile(0);
    } else {
      loadBodyRestartFile(2);
    }

  } else {
    applyInitialCondition();
    for(MInt cellId = a_noCells(); cellId--;) {
      setPrimitiveVariables(cellId);
    }
  }

  // THOMAS
  if(this->m_zonal) {
    resetZonalSolverData();
    if(this->m_STGSponge) this->initSTGSponge();

    if(this->m_resetInitialCondition && m_solverId == this->m_zonalRestartInterpolationSolverId) {
      if(domainId() == 0) cerr << "resetInitialCondition: loadRestartFile for solver " << m_solverId << endl;
      loadRestartFile();
    }
  }

  if(grid().azimuthalPeriodicity()) initAzimuthalCartesianHaloInterpolation();

  // set data on halo-cells
  if(noNeighborDomains() > 0) {
    exchangeDataFV(&a_variable(0, 0), m_noCVars, false, m_rotIndVarsCV);
    if(m_restartOldVariables) {
      exchangeDataFV(&a_oldVariable(0, 0), m_noCVars, false, m_rotIndVarsCV);
    }
    exchangeDataFV(&a_pvariable(0, 0), m_noPVars, false, m_rotIndVarsPV);
    exchangeData(&a_cellVolume(0), 1); // Exchanging cell volume for azimuthal periodicity would be incorrect!
  }

  const MFloat time1 = MPI_Wtime();

  if(domainId() == 0) m_log << "Init solution time " << time1 - time0 << endl;
}


/**
 * \brief Initializes the solver afer the initialRefinement!
 * \author Lennart Schneiders, Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::finalizeInitSolver() {
  TRACE();

  // Nothing to be done if solver is not active
  if(!isActive()) return;

  // initialize the solver
  ASSERT(!m_onlineRestart, "");
  initSolutionStep(-1);

  if(!Context::propertyExists("ReLambdaRestart", m_solverId)) {
    applyInitialCondition();
    computePV();
  }

  // Reallocate solver memory to arrays depending on a_noCells()
  reInitActiveCellIdsMemory();

  if(m_zonal) {
    determineLESAverageCells();
    resetZonalLESAverage();
  }

  writeListOfActiveFlowCells();
  setTimeStep();

  // First RHS
  // compute a first RHS (firstRHS) for the modified runge-kutta time step/solution step method:
  if(m_levelSetMb) {
    preSolutionStep(1);

    // Set cut-off boundary conditions - Moved behind preSolutionStep
    initCutOffBoundaryCondition();
    cutOffBoundaryCondition();
    if(grid().azimuthalPeriodicity()) {
      exchangeFloatDataAzimuthal(&a_pvariable(0, 0), PV->noVariables, m_rotIndVarsPV);
    }

    if(!m_levelSetRans && !m_standardRK) {
      this->rhs();
      this->rhsBnd();
      prepareNextTimeStep();
    }
  }
}


/**
 * \brief set the properties of cells and determines the state of halo cells
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::setCellProperties() {
  FvCartesianSolverXD<nDim, SysEqn>::setCellProperties();
  setAdditionalCellProperties();
}


/**
 * \brief set the properties of cells and determines the state of halo cells
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::setAdditionalCellProperties() {
  // dummy currently
}


/**
 * \brief computes the Gauss Jordan matrix inversion of the first DxD-solver of m_A. The inverse A^-1 is stored in
 * m_A[0:D-1][D:2D-1] \author Daniel Hartmann \note adapted to dxd system (Lennart Schneiders)
 */
template <MInt nDim, class SysEqn>
MInt FvMbCartesianSolverXD<nDim, SysEqn>::inverseGJ() {
  const MFloat epsilon = 1e-12;
  MBool error;
  MInt s, pRow; // pivot row
  MFloat f, h, maximum;

  // add the unity matrix
  for(MInt i = 0; i < nDim; i++) {
    for(MInt j = 0; j < nDim; j++) {
      m_A[i][nDim + j] = F0;
    }
    m_A[i][nDim + i] = F1;
  }

  // Gauss algorithm
  error = false;
  s = 0;
  while(s < nDim) {
    maximum = fabs(m_A[s][s]);
    pRow = s;
    for(MInt i = s + 1; i < nDim; i++) {
      if(fabs(m_A[i][s]) > maximum) {
        maximum = fabs(m_A[i][s]);
        pRow = i;
      }
    }

    if(maximum < epsilon) {
      error = true;
      break;
    }

    if(pRow != s) { // exchange rows if required
      for(MInt j = s; j < 2 * nDim; j++) {
        h = m_A[s][j];
        m_A[s][j] = m_A[pRow][j];
        m_A[pRow][j] = h;
      }
    }

    f = m_A[s][s];
    for(MInt j = s; j < 2 * nDim; j++)
      m_A[s][j] /= f;

    // elimination
    for(MInt i = 0; i < nDim; i++) {
      if(i != s) {
        f = -m_A[i][s];
        for(MInt j = s; j < 2 * nDim; j++)
          m_A[i][j] += f * m_A[s][j];
      }
    }
    s++;
  }

  if(error) {
    cerr << "Domain " << domainId() << endl;
    cerr << "Error in GJ matrix inverse computation " << s << " " << m_A[s][s] << endl;
    for(MInt i = 0; i < nDim; i++) {
      for(MInt j = 0; j < nDim; j++) {
        cerr << m_A[i][j] << " ";
      }
      cerr << endl;
    }
    cerr << endl;
    return -1;
  }
  return 0;
}


/**
 * \brief
 * \author Lennart Schneiders, Claudia Guenther
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::exchangeLevelSetData() {
  TRACE();

  exchangeDataFV(&(a_levelSetValuesMb(0, 0)), m_noLevelSetsUsedForMb);
  exchangeDataFV(&(a_associatedBodyIds(0, 0)), m_noLevelSetsUsedForMb);
}

/**
 * \brief Performs a substep of the 5-stage Runge-Kutta scheme
 * timeStepMethod 0: constant time step
 *                1: level based local time step
 * \author Lennart Schneiders, Tim Wegmann (template update for different timeStepping methods)
 * \date 28.10.2011
 */
template <MInt nDim, class SysEqn>
template <MInt timeStepMethod>
MBool FvMbCartesianSolverXD<nDim, SysEqn>::rungeKuttaStepStandard() {
  TRACE();

  MFloat dt = m_RKalpha[m_RKStep] * timeStep();
  const MInt xdim = a_noCells();
  const MInt ydim = m_noCVars;

  MFloat* RESTRICT cVars = (MFloat*)(&(a_variable(0, 0)));
  MFloat* RESTRICT oCVars = (MFloat*)(&(a_oldVariable(0, 0)));
  MFloat* RESTRICT RHS = (MFloat*)(&(a_rightHandSide(0, 0)));
  MFloat* RESTRICT vol1 = (MFloat*)(&(m_cellVolumesDt1[0]));
  MFloat* RESTRICT fVol = (MFloat*)(&(a_FcellVolume(0)));

  for(MUint it = 0; it < m_temporarilyLinkedCells.size(); it++) {
    const MInt cellId = get<0>(m_temporarilyLinkedCells[it]);
    const MInt masterId = get<1>(m_temporarilyLinkedCells[it]);
    const MInt tripleLink = get<2>(m_temporarilyLinkedCells[it]);

    if(tripleLink < 0) {
      MFloat fac0 = a_cellVolume(cellId) / (a_cellVolume(cellId) + a_cellVolume(masterId));
      MFloat fac1 = F1 - fac0;
      for(MInt v = 0; v < m_noCVars; v++) {
        MFloat delta =
            (fac1 * vol1[cellId] * oCVars[ydim * cellId + v] - fac0 * vol1[masterId] * oCVars[ydim * masterId + v])
                / timeStep()
            + fac0 * a_rightHandSide(masterId, v) - fac1 * a_rightHandSide(cellId, v);

        a_rightHandSide(cellId, v) += delta;
        a_rightHandSide(masterId, v) -= delta;
      }
    } else {
      mTerm(1, AT_, "Not implemented yet!");
      const MFloat fac0 =
          a_cellVolume(cellId) / (a_cellVolume(cellId) + a_cellVolume(tripleLink) + a_cellVolume(masterId));
      const MFloat fac1 =
          a_cellVolume(tripleLink) / (a_cellVolume(cellId) + a_cellVolume(tripleLink) + a_cellVolume(masterId));
      const MFloat fac2 = F1 - fac0 - fac1;
      for(MInt v = 0; v < m_noCVars; v++) {
        MFloat delta =
            (fac2 * vol1[cellId] * oCVars[ydim * cellId + v] - fac0 * vol1[masterId] * oCVars[ydim * masterId + v])
                / timeStep()
            + fac0 * a_rightHandSide(masterId, v) - fac1 * a_rightHandSide(cellId, v);

        a_rightHandSide(cellId, v) += delta;
        a_rightHandSide(masterId, v) -= delta;
      }
    }
  }

  for(MInt i = xdim; i--;) {
    if(!a_hasProperty(i, SolverCell::IsActive)) continue;
    if(a_isHalo(i)) {
      continue;
    }
    if(a_isBndryGhostCell(i)) {
      continue;
    }

    IF_CONSTEXPR(timeStepMethod == 1) {
      ASSERT(a_localTimeStep(i) < std::numeric_limits<MFloat>::max() && a_localTimeStep(i) > 0,
             "Invalid local time-step for " + to_string(i) + " " + to_string(xdim));
      dt = m_RKalpha[m_RKStep] * a_localTimeStep(i);
    }
#ifdef _ALE_FORM_
    cVars[ydim * i + 0] = fVol[i] * (vol1[i] * oCVars[ydim * i + 0] - dt * RHS[ydim * i + 0]);
    cVars[ydim * i + 1] = fVol[i] * (vol1[i] * oCVars[ydim * i + 1] - dt * RHS[ydim * i + 1]);
    cVars[ydim * i + 2] = fVol[i] * (vol1[i] * oCVars[ydim * i + 2] - dt * RHS[ydim * i + 2]);
    cVars[ydim * i + 3] = fVol[i] * (vol1[i] * oCVars[ydim * i + 3] - dt * RHS[ydim * i + 3]);
    IF_CONSTEXPR(nDim == 3) {
      cVars[ydim * i + 4] = fVol[i] * (vol1[i] * oCVars[ydim * i + 4] - dt * RHS[ydim * i + 4]);
    }

#else
    cVars[ydim * i + 0] = oCVars[ydim * i + 0] - dt * fVol[i] * RHS[ydim * i + 0];
    cVars[ydim * i + 1] = oCVars[ydim * i + 1] - dt * fVol[i] * RHS[ydim * i + 1];
    cVars[ydim * i + 2] = oCVars[ydim * i + 2] - dt * fVol[i] * RHS[ydim * i + 2];
    cVars[ydim * i + 3] = oCVars[ydim * i + 3] - dt * fVol[i] * RHS[ydim * i + 3];
    IF_CONSTEXPR(nDim == 3) { cVars[ydim * i + 4] = oCVars[ydim * i + 4] - dt * fVol[i] * RHS[ydim * i + 4]; }
#endif
  }

  m_RKStep++;

  updateSplitParentVariables();

  if(m_RKStep < m_noRKSteps) {
    return false;
  } else {
    m_RKStep = 0;
    return true;
  }
}


/**
 * \brief Performs a substep of the multi-stage Runge-Kutta scheme optimized for moving boundaries
 *
 * timeStepMethod 0: constant time step
 *                1: level based local time step
 *
 * \author Lennart Schneiders, Tim Wegmann (template update for different timeStepping methods)
 * \date 28.04.2014
 */
template <MInt nDim, class SysEqn>
template <MInt timeStepMethod>
MBool FvMbCartesianSolverXD<nDim, SysEqn>::rungeKuttaStepNew() {
  TRACE();

  NEW_TIMER_GROUP_STATIC(t_initTimer, "RK");
  NEW_TIMER_STATIC(t_timertotal, "RK", t_initTimer);
  NEW_SUB_TIMER_STATIC(t_init, "init", t_timertotal);
  NEW_SUB_TIMER_STATIC(t_exec, "exec", t_timertotal);
  NEW_SUB_TIMER_STATIC(t_finalize, "finalize", t_timertotal);
  RECORD_TIMER_START(t_timertotal);
  RECORD_TIMER_START(t_init);

  MFloat* RESTRICT cVars = (MFloat*)(&(a_variable(0, 0)));
  MFloat* RESTRICT oCVars = (MFloat*)(&(a_oldVariable(0, 0)));
  MFloat* RESTRICT RHS = (MFloat*)(&(a_rightHandSide(0, 0)));
  MFloat* RESTRICT RHS0 = (MFloat*)(&(m_rhs0[0][0]));
  MFloat* RESTRICT fVol = (MFloat*)(&(a_FcellVolume(0)));
  MFloat* RESTRICT vol1 = (MFloat*)(&(m_cellVolumesDt1[0]));
  const MInt xdim = noInternalCells(); // a_noCells();
  const MInt ydim = m_noCVars;
  MFloat dt = timeStep();

#ifdef _MB_DEBUG_
  const MInt gId = -1;
#endif

#ifdef GEOM_CONS_LAW
  if(m_gclIntermediate) {
    const MInt noBCells = m_fvBndryCnd->m_bndryCells->size();
    for(MInt bndryId = m_noOuterBndryCells; bndryId < noBCells; bndryId++) {
      const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
      if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;

      const MFloat deltaVol = (m_RKStep == 0) ? m_sweptVolumeDt1[bndryId]
                                              : m_RKalpha[m_RKStep - 1] * m_sweptVolume[bndryId]
                                                    + (F1 - m_RKalpha[m_RKStep - 1]) * m_sweptVolumeDt1[bndryId];
      a_cellVolume(cellId) = m_cellVolumesDt1[cellId] + deltaVol;

      const MFloat V0 = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume - 0.1 * grid().gridCellVolume(a_level(cellId));
      const MFloat V1 = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume + 0.1 * grid().gridCellVolume(a_level(cellId));
      a_cellVolume(cellId) = mMin(V1, mMax(V0, a_cellVolume(cellId)));

      a_cellVolume(cellId) = mMax(a_cellVolume(cellId), m_volumeThreshold);
      a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
    }
  }
#endif

  RECORD_TIMER_STOP(t_init);
  RECORD_TIMER_START(t_exec);

  if(m_RKStep > 0) {
    const MFloat beta1 = m_RKalpha[m_RKStep - 1];
    const MFloat beta0 = F1 - beta1;

    for(MInt i = xdim; i--;) {
      if(!a_hasProperty(i, SolverCell::IsActive)) continue;

      IF_CONSTEXPR(timeStepMethod == 1) { dt = timeStep() * FPOW2(maxLevel() - a_level(i)); }

      cVars[ydim * i + 0] =
          fVol[i] * (vol1[i] * oCVars[ydim * i + 0] - dt * (beta1 * RHS[ydim * i + 0] + beta0 * RHS0[ydim * i + 0]));
      cVars[ydim * i + 1] =
          fVol[i] * (vol1[i] * oCVars[ydim * i + 1] - dt * (beta1 * RHS[ydim * i + 1] + beta0 * RHS0[ydim * i + 1]));
      cVars[ydim * i + 2] =
          fVol[i] * (vol1[i] * oCVars[ydim * i + 2] - dt * (beta1 * RHS[ydim * i + 2] + beta0 * RHS0[ydim * i + 2]));
      cVars[ydim * i + 3] =
          fVol[i] * (vol1[i] * oCVars[ydim * i + 3] - dt * (beta1 * RHS[ydim * i + 3] + beta0 * RHS0[ydim * i + 3]));
      IF_CONSTEXPR(nDim == 3) {
        cVars[ydim * i + 4] =
            fVol[i] * (vol1[i] * oCVars[ydim * i + 4] - dt * (beta1 * RHS[ydim * i + 4] + beta0 * RHS0[ydim * i + 4]));

        IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
          for(MInt r = 0; r < m_noRansEquations; ++r) {
            cVars[ydim * i + 5 + r] = fVol[i]
                                      * (vol1[i] * oCVars[ydim * i + 5 + r]
                                         - dt * (beta1 * RHS[ydim * i + 5 + r] + beta0 * RHS0[ydim * i + 5 + r]));
          }
        }

        for(MInt s = 0; s < m_noSpecies; s++)
          cVars[ydim * i + 5 + s + m_noRansEquations] =
              fVol[i]
              * (vol1[i] * oCVars[ydim * i + 5 + s + m_noRansEquations]
                 - dt
                       * (beta1 * RHS[ydim * i + 5 + s + m_noRansEquations]
                          + beta0 * RHS0[ydim * i + 5 + s + m_noRansEquations]));
      }
      else {
        IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
          for(MInt r = 0; r < m_noRansEquations; ++r) {
            cVars[ydim * i + 4 + r] = fVol[i]
                                      * (vol1[i] * oCVars[ydim * i + 4 + r]
                                         - dt * (beta1 * RHS[ydim * i + 4 + r] + beta0 * RHS0[ydim * i + 4 + r]));
          }
        }

        for(MInt s = 0; s < m_noSpecies; s++)
          cVars[ydim * i + 4 + s + m_noRansEquations] =
              fVol[i]
              * (vol1[i] * oCVars[ydim * i + 4 + s + m_noRansEquations]
                 - dt
                       * (beta1 * RHS[ydim * i + 4 + s + m_noRansEquations]
                          + beta0 * RHS0[ydim * i + 4 + s + m_noRansEquations]));
      }


#ifdef _MB_DEBUG_
      if(gId > -1 && c_globalId(i) == gId)
        cerr << globalTimeStep << " " << m_RKStep << " RK update " << gId << " " << fVol[i] << " " << vol1[i] << " "
             << fVol[i] * vol1[i] << " / " << cVars[ydim * i + 0] << " " << cVars[ydim * i + 1] << " "
             << cVars[ydim * i + 2] << " " << cVars[ydim * i + 3] << " " << cVars[ydim * i + 4] << " / "
             << oCVars[ydim * i + 0] << " " << oCVars[ydim * i + 1] << " " << oCVars[ydim * i + 2] << " "
             << oCVars[ydim * i + 3] << " " << oCVars[ydim * i + 4] << endl;
#endif
    }

  } else {
    ASSERT(m_RKStep == 0, "");
    for(MInt i = xdim; i--;) {
      if(!a_hasProperty(i, SolverCell::IsActive)) continue;

      IF_CONSTEXPR(timeStepMethod == 1) { dt = timeStep() * FPOW2(maxLevel() - a_level(i)); }

      cVars[ydim * i + 0] = fVol[i] * (vol1[i] * oCVars[ydim * i + 0] - dt * RHS0[ydim * i + 0]);
      cVars[ydim * i + 1] = fVol[i] * (vol1[i] * oCVars[ydim * i + 1] - dt * RHS0[ydim * i + 1]);
      cVars[ydim * i + 2] = fVol[i] * (vol1[i] * oCVars[ydim * i + 2] - dt * RHS0[ydim * i + 2]);
      cVars[ydim * i + 3] = fVol[i] * (vol1[i] * oCVars[ydim * i + 3] - dt * RHS0[ydim * i + 3]);
      IF_CONSTEXPR(nDim == 3) {
        cVars[ydim * i + 4] = fVol[i] * (vol1[i] * oCVars[ydim * i + 4] - dt * RHS0[ydim * i + 4]);
        IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
          for(MInt r = 0; r < m_noRansEquations; ++r) {
            cVars[ydim * i + 5 + r] = fVol[i] * (vol1[i] * oCVars[ydim * i + 5 + r] - dt * RHS0[ydim * i + 5 + r]);
          }
        }

        for(MInt s = 0; s < m_noSpecies; s++)
          cVars[ydim * i + 5 + s + m_noRansEquations] = fVol[i]
                                                        * (vol1[i] * oCVars[ydim * i + 5 + s + m_noRansEquations]
                                                           - dt * RHS0[ydim * i + 5 + s + m_noRansEquations]);
      }
      else {
        IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
          for(MInt r = 0; r < m_noRansEquations; ++r) {
            cVars[ydim * i + 4 + r] = fVol[i] * (vol1[i] * oCVars[ydim * i + 4 + r] - dt * RHS0[ydim * i + 4 + r]);
          }
        }
        for(MInt s = 0; s < m_noSpecies; s++)
          cVars[ydim * i + 4 + s + m_noRansEquations] = fVol[i]
                                                        * (vol1[i] * oCVars[ydim * i + 4 + s + m_noRansEquations]
                                                           - dt * RHS0[ydim * i + 4 + s + m_noRansEquations]);
      }
#ifdef _MB_DEBUG_
      if(gId > -1 && c_globalId(i) == gId)
        cerr << globalTimeStep << " " << m_RKStep << " RK update " << gId << " " << fVol[i] << " " << vol1[i] << " "
             << fVol[i] * vol1[i] << " / " << cVars[ydim * i + 0] << " " << cVars[ydim * i + 1] << " "
             << cVars[ydim * i + 2] << " " << cVars[ydim * i + 3] << " " << cVars[ydim * i + 4] << " / "
             << oCVars[ydim * i + 0] << " " << oCVars[ydim * i + 1] << " " << oCVars[ydim * i + 2] << " "
             << oCVars[ydim * i + 3] << " " << oCVars[ydim * i + 4] << endl;
#endif
    }
  }
  RECORD_TIMER_STOP(t_exec);
  RECORD_TIMER_START(t_finalize);

  updateLinkedCells();
  m_RKStep++;

  RECORD_TIMER_STOP(t_finalize);
  RECORD_TIMER_STOP(t_timertotal);

  if(m_RKStep < m_noRKSteps) {
    return false;
  } else {
    m_RKStep = 0;
    return true;
  }
}


/**
 * \brief Performs a substep of the multi-stage Runge-Kutta scheme optimized for dynamic meshes
 * \author Lennart Schneiders
 * \date 28.04.2014
 */
template <MInt nDim, class SysEqn>
MBool FvMbCartesianSolverXD<nDim, SysEqn>::rungeKuttaStepNewLocalTimeStepping() {
  TRACE();

  MFloat* RESTRICT cVars = (MFloat*)(&(a_variable(0, 0)));
  MFloat* RESTRICT oCVars = (MFloat*)(&(a_oldVariable(0, 0)));
  MFloat* RESTRICT RHS = (MFloat*)(&(a_rightHandSide(0, 0)));
  MFloat* RESTRICT RHS0 = (MFloat*)(&(m_rhs0[0][0]));
  MFloat* RESTRICT fVol = (MFloat*)(&(a_FcellVolume(0)));
  MFloat* RESTRICT vol1 = (MFloat*)(&(m_cellVolumesDt1[0]));
  const MInt xdim = noInternalCells(); // a_noCells();
  const MInt ydim = m_noCVars;

#ifdef _MB_DEBUG_
  const MInt gId = -1;
#endif

#ifdef GEOM_CONS_LAW
  if(m_gclIntermediate) {
    const MInt noBCells = m_fvBndryCnd->m_bndryCells->size();
    for(MInt bndryId = m_noOuterBndryCells; bndryId < noBCells; bndryId++) {
      MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
      if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
      if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;
      if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;

      const MFloat deltaVol = (m_RKStep == 0) ? m_sweptVolumeDt1[bndryId]
                                              : m_RKalpha[m_RKStep - 1] * m_sweptVolume[bndryId]
                                                    + (F1 - m_RKalpha[m_RKStep - 1]) * m_sweptVolumeDt1[bndryId];
      a_cellVolume(cellId) = m_cellVolumesDt1[cellId] + deltaVol;

      const MFloat V0 = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume - 0.1 * grid().gridCellVolume(a_level(cellId));
      const MFloat V1 = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume + 0.1 * grid().gridCellVolume(a_level(cellId));
      a_cellVolume(cellId) = mMin(V1, mMax(V0, a_cellVolume(cellId)));

      a_cellVolume(cellId) = mMax(a_cellVolume(cellId), m_volumeThreshold);
      a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
    }
  }
#endif

  if(m_RKStep > 0) {
    const MFloat beta1 = m_RKalpha[m_RKStep - 1];
    const MFloat beta0 = F1 - beta1;

    for(MInt i = xdim; i--;) {
      if(!a_hasProperty(i, SolverCell::IsActive)) continue;
      const MFloat dt = timeStep() * FPOW2(maxRefinementLevel() - a_level(i));
      cVars[ydim * i + 0] =
          fVol[i] * (vol1[i] * oCVars[ydim * i + 0] - dt * (beta1 * RHS[ydim * i + 0] + beta0 * RHS0[ydim * i + 0]));
      cVars[ydim * i + 1] =
          fVol[i] * (vol1[i] * oCVars[ydim * i + 1] - dt * (beta1 * RHS[ydim * i + 1] + beta0 * RHS0[ydim * i + 1]));
      cVars[ydim * i + 2] =
          fVol[i] * (vol1[i] * oCVars[ydim * i + 2] - dt * (beta1 * RHS[ydim * i + 2] + beta0 * RHS0[ydim * i + 2]));
      cVars[ydim * i + 3] =
          fVol[i] * (vol1[i] * oCVars[ydim * i + 3] - dt * (beta1 * RHS[ydim * i + 3] + beta0 * RHS0[ydim * i + 3]));
      IF_CONSTEXPR(nDim == 3) {
        cVars[ydim * i + 4] =
            fVol[i] * (vol1[i] * oCVars[ydim * i + 4] - dt * (beta1 * RHS[ydim * i + 4] + beta0 * RHS0[ydim * i + 4]));
      }
#ifdef _MB_DEBUG_
      if(gId > -1 && c_globalId(i) == gId)
        cerr << globalTimeStep << " " << m_RKStep << " RK update " << gId << " " << cVars[ydim * i + 0] << " "
             << cVars[ydim * i + 1] << " " << cVars[ydim * i + 2] << " " << cVars[ydim * i + 3] << " "
             << cVars[ydim * i + 4] << endl;
#endif
    }

  } else {
    ASSERT(m_RKStep == 0, "");
    for(MInt i = xdim; i--;) {
      if(!a_hasProperty(i, SolverCell::IsActive)) continue;
      const MFloat dt = timeStep() * FPOW2(maxRefinementLevel() - a_level(i));
      cVars[ydim * i + 0] = fVol[i] * (vol1[i] * oCVars[ydim * i + 0] - dt * RHS0[ydim * i + 0]);
      cVars[ydim * i + 1] = fVol[i] * (vol1[i] * oCVars[ydim * i + 1] - dt * RHS0[ydim * i + 1]);
      cVars[ydim * i + 2] = fVol[i] * (vol1[i] * oCVars[ydim * i + 2] - dt * RHS0[ydim * i + 2]);
      cVars[ydim * i + 3] = fVol[i] * (vol1[i] * oCVars[ydim * i + 3] - dt * RHS0[ydim * i + 3]);
      IF_CONSTEXPR(nDim == 3) {
        cVars[ydim * i + 4] = fVol[i] * (vol1[i] * oCVars[ydim * i + 4] - dt * RHS0[ydim * i + 4]);
      }
#ifdef _MB_DEBUG_
      if(gId > -1 && c_globalId(i) == gId)
        cerr << globalTimeStep << " " << m_RKStep << " RK update " << gId << " " << cVars[ydim * i + 0] << " "
             << cVars[ydim * i + 1] << " " << cVars[ydim * i + 2] << " " << cVars[ydim * i + 3] << " "
             << cVars[ydim * i + 4] << endl;
#endif
    }
  }

  updateLinkedCells();

  m_RKStep++;

  if(m_RKStep < m_noRKSteps) {
    return false;
  } else {
    m_RKStep = 0;
    return true;
  }
}


/**
 * \brief update the temporarly-linked cells
 * \author Lennart Schneiders, extension to triple-linking Tim Wegmann
 * \date
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::updateLinkedCells() {
  MFloat* RESTRICT cVars = (MFloat*)(&(a_variable(0, 0)));
  const MInt ydim = m_noCVars;
  const MUint noCVars = (MUint)m_noCVars;

  MIntScratchSpace haloBufferCnts(mMax(1, noNeighborDomains()), AT_, "haloBufferCnts");
  MIntScratchSpace windowBufferCnts(mMax(1, noNeighborDomains()), AT_, "windowBufferCnts");
  MIntScratchSpace haloBufferOffsets(noNeighborDomains() + 1, AT_, "haloBufferOffsets");
  MIntScratchSpace windowBufferOffsets(noNeighborDomains() + 1, AT_, "windowBufferOffsets");
  ScratchSpace<MPI_Request> haloReq(mMax(1, noNeighborDomains()), AT_, "haloReq");
  ScratchSpace<MPI_Request> windowReq(mMax(1, noNeighborDomains()), AT_, "windowReq");

  MInt haloSize = 0;
  MInt windowSize = 0;
  haloBufferCnts.fill(0);
  windowBufferCnts.fill(0);
  haloBufferOffsets.fill(0);
  windowBufferOffsets.fill(0);

  for(MInt i = 0; i < noNeighborDomains(); i++) {
    haloBufferCnts(i) = m_noCVars * (signed)m_linkedHaloCells[i].size();
    windowBufferCnts(i) = m_noCVars * (signed)m_linkedWindowCells[i].size();
    haloBufferOffsets(i + 1) = haloBufferOffsets(i) + haloBufferCnts(i);
    windowBufferOffsets(i + 1) = windowBufferOffsets(i) + windowBufferCnts(i);
    haloSize += haloBufferCnts(i);
    windowSize += windowBufferCnts(i);
  }

  MFloatScratchSpace haloBuffer(haloSize, AT_, "haloBuffer");
  MFloatScratchSpace windowBuffer(windowSize, AT_, "windowBuffer");

  updateSplitParentVariables();

  haloReq.fill(MPI_REQUEST_NULL);
  windowReq.fill(MPI_REQUEST_NULL);
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    if(m_linkedWindowCells[i].empty()) continue;
    for(MInt j = 0; j < (signed)m_linkedWindowCells[i].size(); j++) {
      MInt cellId = m_linkedWindowCells[i][j];
      MInt offset = windowBufferOffsets(i) + noCVars * j;
      for(MInt v = 0; v < (signed)noCVars; v++) {
        windowBuffer(offset + v) = a_variable(cellId, v);
      }
    }
  }
  MInt windowCnt = 0;
  MInt haloCnt = 0;
  if(m_nonBlockingComm) {
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(haloBufferCnts(i) == 0) continue;
      MPI_Irecv(&haloBuffer[haloBufferOffsets[i]], haloBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 23, mpiComm(),
                &haloReq[haloCnt], AT_, "haloBuffer[haloBufferOffsets[i]]");
      haloCnt++;
    }
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(windowBufferCnts(i) == 0) continue;
      MPI_Isend(&windowBuffer[windowBufferOffsets[i]], windowBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 23,
                mpiComm(), &windowReq[windowCnt], AT_, "windowBuffer[windowBufferOffsets[i]]");
      windowCnt++;
    }
    if(haloCnt > 0) MPI_Waitall(haloCnt, &haloReq[0], MPI_STATUSES_IGNORE, AT_);
  } else {
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(windowBufferCnts(i) == 0) continue;
      MPI_Issend(&windowBuffer[windowBufferOffsets[i]], windowBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 23,
                 mpiComm(), &windowReq[windowCnt], AT_, "windowBuffer[windowBufferOffsets[i]]");
      windowCnt++;
    }
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(haloBufferCnts(i) == 0) continue;
      MPI_Recv(&haloBuffer[haloBufferOffsets[i]], haloBufferCnts(i), MPI_DOUBLE, neighborDomain(i), 23, mpiComm(),
               MPI_STATUS_IGNORE, AT_, "haloBuffer[haloBufferOffsets[i]]");
      haloCnt++;
    }
  }
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    if(m_linkedHaloCells[i].empty()) continue;
    for(MInt j = 0; j < (signed)m_linkedHaloCells[i].size(); j++) {
      MInt cellId = m_linkedHaloCells[i][j];
      MInt offset = haloBufferOffsets(i) + noCVars * j;
      for(MInt v = 0; v < (signed)noCVars; v++) {
        a_variable(cellId, v) = haloBuffer(offset + v);
      }
    }
  }
  if(windowCnt > 0) MPI_Waitall(windowCnt, &windowReq[0], MPI_STATUSES_IGNORE, AT_);

  if(grid().azimuthalPeriodicity()) {
    exchangeLinkedHaloCellsForAzimuthalReconstruction();
    azimuthalNearBoundaryExchange();
  }

  for(MUint it = 0; it < m_temporarilyLinkedCells.size(); it++) {
    const MInt cellId = get<0>(m_temporarilyLinkedCells[it]);
    const MInt masterId = get<1>(m_temporarilyLinkedCells[it]);
    const MInt tripleLink = get<2>(m_temporarilyLinkedCells[it]);
    if(tripleLink < 0) {
      const MFloat fac0 = a_cellVolume(cellId) / (a_cellVolume(cellId) + a_cellVolume(masterId));
      const MFloat fac1 = F1 - fac0;
      if(false && m_RKStep == 0) {
        for(MInt v = 0; v < m_noCVars; v++) {
          const MFloat var = fac1 * cVars[ydim * masterId + v];
          cVars[ydim * cellId + v] = var;
          cVars[ydim * masterId + v] = var;
        }
      } else {
        for(MInt v = 0; v < m_noCVars; v++) {
          // If two emerged cells share the same master cell, this formulation is incorrect!
          // If the order of the cells changes, e.g., when during DLB one of the cells becomes a halo cell, this even
          // results in different solutions.
          const MFloat var = fac0 * cVars[ydim * cellId + v] + fac1 * cVars[ydim * masterId + v];
          cVars[ydim * cellId + v] = var;
          cVars[ydim * masterId + v] = var;
        }

        if(a_hasProperty(cellId, SolverCell::IsSplitCell)) {
          vector<MInt>::iterator it0 = find(m_splitCells.begin(), m_splitCells.end(), cellId);
          if(it0 == m_splitCells.end()) mTerm(1, AT_, "split cells inconsistency.");
          const MInt pos = distance(m_splitCells.begin(), it0);
          ASSERT(m_splitCells[pos] == cellId, "");
          for(MUint s = 0; s < m_splitChilds[pos].size(); s++) {
            MInt splitChildId = m_splitChilds[pos][s];
            for(MInt v = 0; v < m_noCVars; v++) {
              cVars[ydim * splitChildId + v] = cVars[ydim * cellId + v];
            }
          }
        }
        if(a_hasProperty(masterId, SolverCell::IsSplitCell)) {
          vector<MInt>::iterator it0 = find(m_splitCells.begin(), m_splitCells.end(), masterId);
          if(it0 == m_splitCells.end()) mTerm(1, AT_, "split cells inconsistency.");
          const MInt pos = distance(m_splitCells.begin(), it0);
          ASSERT(m_splitCells[pos] == masterId, "");
          for(MUint s = 0; s < m_splitChilds[pos].size(); s++) {
            MInt splitChildId = m_splitChilds[pos][s];
            for(MInt v = 0; v < m_noCVars; v++) {
              cVars[ydim * splitChildId + v] = cVars[ydim * masterId + v];
            }
          }
        }
      }
    } else {
      // triple-Links
      const MFloat fac0 =
          a_cellVolume(cellId) / (a_cellVolume(cellId) + a_cellVolume(tripleLink) + a_cellVolume(masterId));
      const MFloat fac1 =
          a_cellVolume(tripleLink) / (a_cellVolume(cellId) + a_cellVolume(tripleLink) + a_cellVolume(masterId));
      const MFloat fac2 = F1 - fac0 - fac1;

      for(MInt v = 0; v < m_noCVars; v++) {
        const MFloat var =
            fac0 * cVars[ydim * cellId + v] + fac1 * cVars[ydim * tripleLink + v] + fac2 * cVars[ydim * tripleLink + v];
        cVars[ydim * cellId + v] = var;
        cVars[ydim * tripleLink + v] = var;
        cVars[ydim * masterId + v] = var;
      }

      if(a_hasProperty(cellId, SolverCell::IsSplitCell)) {
        vector<MInt>::iterator it0 = find(m_splitCells.begin(), m_splitCells.end(), cellId);
        if(it0 == m_splitCells.end()) mTerm(1, AT_, "split cells inconsistency.");
        const MInt pos = distance(m_splitCells.begin(), it0);
        ASSERT(m_splitCells[pos] == cellId, "");
        for(MUint s = 0; s < m_splitChilds[pos].size(); s++) {
          MInt splitChildId = m_splitChilds[pos][s];
          for(MInt v = 0; v < m_noCVars; v++) {
            cVars[ydim * splitChildId + v] = cVars[ydim * cellId + v];
          }
        }
      }
      if(a_hasProperty(masterId, SolverCell::IsSplitCell)) {
        vector<MInt>::iterator it0 = find(m_splitCells.begin(), m_splitCells.end(), masterId);
        if(it0 == m_splitCells.end()) mTerm(1, AT_, "split cells inconsistency.");
        const MInt pos = distance(m_splitCells.begin(), it0);
        ASSERT(m_splitCells[pos] == masterId, "");
        for(MUint s = 0; s < m_splitChilds[pos].size(); s++) {
          MInt splitChildId = m_splitChilds[pos][s];
          for(MInt v = 0; v < m_noCVars; v++) {
            cVars[ydim * splitChildId + v] = cVars[ydim * masterId + v];
          }
        }
      }
      if(a_hasProperty(tripleLink, SolverCell::IsSplitCell)) {
        vector<MInt>::iterator it0 = find(m_splitCells.begin(), m_splitCells.end(), tripleLink);
        if(it0 == m_splitCells.end()) mTerm(1, AT_, "split cells inconsistency.");
        const MInt pos = distance(m_splitCells.begin(), it0);
        ASSERT(m_splitCells[pos] == tripleLink, "");
        for(MUint s = 0; s < m_splitChilds[pos].size(); s++) {
          MInt splitChildId = m_splitChilds[pos][s];
          for(MInt v = 0; v < m_noCVars; v++) {
            cVars[ydim * splitChildId + v] = cVars[ydim * tripleLink + v];
          }
        }
      }
    }
  }
}


/**
 * \brief calls m_fvBndryCnd->copyVarsToSmallCells()
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::copyVarsToSmallCells() {
  TRACE();

  m_fvBndryCnd->copyVarsToSmallCells();
}


/**
 * \brief returns the name of the conservative variable at the given index i
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
string FvMbCartesianSolverXD<nDim, SysEqn>::getConservativeVarName(MInt i) {
  switch(i) {
    case 0:
      return "RHO_U";
    case 1:
      return "RHO_V";
    case 2:
      IF_CONSTEXPR(nDim == 2)
      return "RHO_E";
      else
        return "RHO_W";
    case 3:
      IF_CONSTEXPR(nDim == 2)
      return "RHO";
      else
        return "RHO_E";
    case 4:
      IF_CONSTEXPR(nDim == 2)
      return "<< INVALID INDEX FOR CONSERVATIVE VAR >>";
      else
        return "RHO";
    default:
      return "<< INVALID INDEX FOR CONSERVATIVE VAR >>";
  }
}


/**
 * \brief returns the name of the primitive variable at the given index i
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
string FvMbCartesianSolverXD<nDim, SysEqn>::getPrimitiveVarName(MInt i) {
  switch(i) {
    case 0:
      return "U";
    case 1:
      return "V";
    case 2:
      IF_CONSTEXPR(nDim == 2)
      return "RHO";
      else
        return "W";
    case 3:
      IF_CONSTEXPR(nDim == 2)
      return "P";
      else
        return "RHO";
    case 4:
      IF_CONSTEXPR(nDim == 2)
      return "<< INVALID INDEX FOR CONSERVATIVE VAR >>";
      else
        return "P";
    default:
      return "<< INVALID INDEX FOR CONSERVATIVE VAR >>";
  }
}


/**
 * \brief logs several boundary values to the given output file
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::logBoundaryData(const MChar* fileName, MBool forceOutput) {
  TRACE();

  if(!m_logBoundaryData && !forceOutput) return;
  if(m_noLsMbBndryCells == 0) return;
  IF_CONSTEXPR(nDim == 3) return;

  MInt cellId;
  const MFloat xOffset = m_bodyCenter[0];
  const MFloat yOffset = m_bodyCenter[1];
  const MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();
  const MFloat radToDeg = 360.0 / (2.0 * PI);
  MFloat dist;
  MFloat shear[nDim];
  MFloat gradV[nDim][nDim];
  MFloat gradP[nDim];
  MFloat angle, u, v, cp, ma, vorticity, tmp; //, angle2;
  MFloat rhoU2 = F0;
  for(MInt i = 0; i < nDim; i++) {
    rhoU2 += POW2(m_VVInfinity[i]);
  }
  rhoU2 *= m_rhoInfinity;

  MInt iTmp;
  MFloat fTmp;
  MInt noCells;
  MBool centerLine;
  ScratchSpace<MInt> sortedList(m_noLsMbBndryCells, AT_, "sortedList");
  ScratchSpace<MFloat> sortedAngle(m_noLsMbBndryCells, AT_, "sortedAngle");

  noCells = 0;

  for(MInt bndryId = m_noOuterBndryCells; bndryId < noBndryCells; bndryId++) {
    cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    centerLine = false;
    IF_CONSTEXPR(nDim == 3) {
      if(a_coordinate(cellId, 2) >= F0 && a_hasNeighbor(cellId, 4) > 0
         && a_coordinate(c_neighborId(cellId, 4), 2) < F0) {
        centerLine = true;
      }
    }
    IF_CONSTEXPR(nDim == 3) {
      if(!centerLine) continue;
    }

    angle = F0;
    if(a_coordinate(cellId, 1) - yOffset > 0 && a_coordinate(cellId, 0) - xOffset > 0) {
      angle = 180 - radToDeg * atan((a_coordinate(cellId, 1) - yOffset) / (a_coordinate(cellId, 0) - xOffset));
    } else if(a_coordinate(cellId, 1) - yOffset > 0 && a_coordinate(cellId, 0) - xOffset < 0) {
      angle = -radToDeg * atan((a_coordinate(cellId, 1) - yOffset) / (a_coordinate(cellId, 0) - xOffset));
    } else if(a_coordinate(cellId, 1) - yOffset < 0 && a_coordinate(cellId, 0) - xOffset > 0) {
      angle = 180.0 - radToDeg * atan((a_coordinate(cellId, 1) - yOffset) / (a_coordinate(cellId, 0) - xOffset));
    } else {
      angle = 360.0 - radToDeg * atan((a_coordinate(cellId, 1) - yOffset) / (a_coordinate(cellId, 0) - xOffset));
    }

    MFloat dx = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[0] - xOffset;
    MFloat dy = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[1] - yOffset;
    angle = 180.0 - (radToDeg * atan2(dy, dx));

    sortedAngle.p[noCells] = angle;
    sortedList.p[noCells] = cellId;
    noCells++;
  }

  for(MInt i = 0; i < noCells - 1; i++) {
    for(MInt j = i + 1; j < noCells; j++) {
      if(sortedAngle.p[j] < sortedAngle.p[i]) {
        iTmp = sortedList.p[i];
        sortedList.p[i] = sortedList.p[j];
        sortedList.p[j] = iTmp;
        fTmp = sortedAngle.p[i];
        sortedAngle.p[i] = sortedAngle.p[j];
        sortedAngle.p[j] = fTmp;
      }
    }
  }


  ofstream ofl2;
  ofl2.open(fileName);
  if(ofl2.is_open() && ofl2.good()) {
    for(MInt c = 0; c < noCells; c++) {
      cellId = sortedList.p[c];

      if(a_hasProperty(cellId, SolverCell::IsCutOff)) continue;
      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
      if(a_isHalo(cellId)) continue;
      if(a_isPeriodic(cellId)) continue;

      MInt bndryId = a_bndryId(cellId);
      angle = sortedAngle.p[c];
      MFloat rhoSurface = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->RHO];
      MFloat pSurface = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->P];
      MFloat T = sysEqn().temperature_ES(rhoSurface, pSurface);
      MFloat mue = SUTHERLANDLAW(T);

      dist = F0;
      for(MInt i = 0; i < nDim; i++) {
        dist += (a_coordinate(cellId, i) - m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[i])
                * m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i];
      }
      dist = fabs(dist);

      MFloat shear2[3] = {F0, F0, F0};
      for(MInt i = 0; i < nDim; i++) {
        MFloat grad = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_normalDeriv[PV->VV[i]];
        shear[i] = mue * grad;
      }

      MFloat cf = (m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[1] * shear[0]
                   - m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[0] * shear[1])
                  / (F1B2 * rhoU2 * m_referenceLength * sysEqn().m_Re0);

      u = a_pvariable(cellId, PV->VV[0]);
      v = a_pvariable(cellId, PV->VV[1]);
      ma = sqrt(u * u + v * v);
      ma /= sysEqn().speedOfSound(rhoSurface, pSurface);
      cp = (pSurface - m_PInfinity) / (F1B2 * rhoU2);

      MFloat dudn[nDim];
      MFloat nablaPhi[nDim];
      MFloat nablaAbs = F0;
      for(MInt i = 0; i < nDim; i++) {
        nablaPhi[i] = (a_levelSetValuesMb(c_neighborId(cellId, 2 * i + 1), 0)
                       - a_levelSetValuesMb(c_neighborId(cellId, 2 * i), 0))
                      / (F2 * c_cellLengthAtLevel(a_level(cellId)));
        nablaAbs += POW2(nablaPhi[i]);
      }
      nablaAbs = sqrt(nablaAbs);
      for(MInt i = 0; i < nDim; i++) {
        nablaPhi[i] /= nablaAbs;
      }

      for(MInt i = 0; i < nDim; i++) {
        for(MInt j = 0; j < nDim; j++) {
          gradV[i][j] = F0;
        }
        gradP[i] = F0;
        dudn[i] = F0;
      }

      MFloat dundn = F0;
      for(MInt i = 0; i < nDim; i++) {
        dudn[i] = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_normalDeriv[PV->VV[i]];
      }

      tmp = F0;
      for(MInt i = 0; i < nDim; i++) {
        tmp += m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[i] * gradP[i];
      }
      for(MInt i = 0; i < nDim; i++) {
        gradP[1] = -m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[0] * gradP[1]
                   + m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[1] * gradP[0];
      }
      gradP[0] = tmp;

      MFloat u2 = m_bodyVelocity[0];
      MFloat v2 = m_bodyVelocity[1];
      for(MInt j = 0; j < nDim; j++) {
        u2 += 0.5 * c_cellLengthAtLevel(maxRefinementLevel())
              * m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[j] * 0.5
              * (a_slope(cellId, PV->U, j) + gradV[PV->U][j]);
        v2 += 0.5 * c_cellLengthAtLevel(maxRefinementLevel())
              * m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[j] * 0.5
              * (a_slope(cellId, PV->V, j) + gradV[PV->V][j]);
      }


      vorticity = (gradV[1][0] - gradV[0][1]) / m_UInfinity;

      MFloat bodyRotation[3] = {0};
      getBodyRotation(0, bodyRotation);

      const MFloat p0 = a_coordinate(cellId, 0);
      const MFloat q0 = a_coordinate(cellId, 1);
      const MFloat p = cos(-bodyRotation[2]) * p0 - sin(-bodyRotation[2]) * q0 + F1B4;

      ofl2 << cellId << "  ";                                                               // 1
      ofl2 << angle << "  ";                                                                // 2
      ofl2 << m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume << "  ";                      // 3
      ofl2 << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_area << "  ";            // 4
      ofl2 << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[0] << "  "; // 5
      ofl2 << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[1] << "  "; // 6
      ofl2 << m_volumeFraction[bndryId] << "  ";                                            // 7
      ofl2 << dist << "  ";                                                                 // 8
      ofl2 << pSurface << "  ";                                                             // 9
      ofl2 << rhoSurface << "  ";                                                           // 10
      ofl2 << cp << "  ";                                                                   // 11
      ofl2 << shear[0] << "  ";                                                             // 12
      ofl2 << shear[1] << "  ";                                                             // 13
      ofl2 << a_pvariable(cellId, PV->P) << "  ";                                           // 14
      ofl2 << vorticity << "  ";                                                            // 15
      ofl2 << gradP[0] << "  ";                                                             // 18
      ofl2 << gradP[1] << "  ";                                                             // 19
      ofl2 << dudn[0] << "  ";                                                              // 20
      ofl2 << dudn[1] << "  ";                                                              // 21
      ofl2 << (u - m_bodyVelocity[0]) / dist << "  ";                                       // 22
      ofl2 << (v - m_bodyVelocity[1]) / dist << "  ";                                       // 23
      // ofl2 << (u-m_bodyVelocity[0])/getLevelSetValueSphere(cellId) << "  "; //24
      ofl2 << (u2 - m_bodyVelocity[0]) / (0.5 * c_cellLengthAtLevel(maxRefinementLevel())) << "  ";     // 25
      ofl2 << (v2 - m_bodyVelocity[1]) / (0.5 * c_cellLengthAtLevel(maxRefinementLevel())) << "  ";     // 26
      ofl2 << dundn << "  ";                                                                            // 27
      ofl2 << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[0] << "  ";              // 28
      ofl2 << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates[1] << "  ";              // 29
      ofl2 << shear2[0] << "  ";                                                                        // 30
      ofl2 << shear2[1] << "  ";                                                                        // 31
      ofl2 << m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->U] << "  ";         // 32
      ofl2 << m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->V] << "  ";         // 33
      ofl2 << a_coordinate(cellId, 0) << "  ";                                                          // 34
      ofl2 << a_coordinate(cellId, 1) << "  ";                                                          // 35
      ofl2 << cf << "  ";                                                                               // 36
      ofl2 << p << "  ";                                                                                // 37
      ofl2 << globalTimeStep << "  ";                                                                   // 38
      ofl2 << nablaPhi[0] << "  ";                                                                      // 39
      ofl2 << nablaPhi[1] << "  ";                                                                      // 40
      ofl2 << endl;
    }

    ofl2.close();
    ofl2.clear();
  } else {
    cerr << "ERROR! COULD NOT OPEN FILE " << fileName << " for writing!" << endl;
  }
}


/**
 * \brief computes relevant variables at the moving boundary surface and determines the resulting body force
 * \author Lennart Schneiders
 * If the pointers are set, the routine gathers the dynamic Coefficients
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::computeBodySurfaceData(MFloat* pressureForce) {
  TRACE();

  NEW_TIMER_GROUP_STATIC(t_bodyTimer, "computeBodySurfaceData");
  NEW_TIMER_STATIC(t_timertotal, "computeBodySurfaceData", t_bodyTimer);
  NEW_SUB_TIMER_STATIC(t_local, "localForce", t_timertotal);
  NEW_SUB_TIMER_STATIC(t_reduce, "reduce", t_timertotal);
  NEW_SUB_TIMER_STATIC(t_collision, "collision", t_timertotal);
  RECORD_TIMER_START(t_timertotal);
  RECORD_TIMER_START(t_local);

  // bodyForce:nDim, bodyTorque:3, bodyHeatFlux:1
  MBool returnCoeffs = false;
  MInt noValues = nDim + 3 + 1;
  MInt noReturnCoeffs = nDim;

  if(pressureForce != nullptr) {
    returnCoeffs = true;
    noValues += noReturnCoeffs;
  }

  const MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();
  const MFloat F1BRe = F1 / (m_referenceLength * sysEqn().m_Re0);
  const MFloat F1BPr = F1 / (m_Pr);

  MFloatScratchSpace bodyForce(mMax(1, m_noEmbeddedBodies), noValues, AT_, "bodyForce");
  bodyForce.fill(F0);
  MFloat coupling = F0;

  for(MInt bndryId = m_noOuterBndryCells; bndryId < noBndryCells; bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;

    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_isHalo(cellId)) continue;
    if(a_isPeriodic(cellId)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(a_isBndryGhostCell(cellId)) continue;
    if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;

    MFloatScratchSpace dummyPvariables(m_bndryCells->a[bndryId].m_noSrfcs, PV->noVariables, AT_, "dummyPvariables");
    for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area < 1e-14) continue;
      MInt k = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bodyId[0];
      ASSERT(m_internalBodyId[k] > -1 && m_internalBodyId[k] < m_noEmbeddedBodies + m_noPeriodicGhostBodies, "");
      MInt body = m_internalBodyId[k];
      ASSERT(body > -1 && body < m_noEmbeddedBodies, "");

      MFloat rhoSurface = F0;
      MFloat pSurface = F0;
      MInt surfVars = mMin((signed)m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.size(),
                           m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs);

      for(MInt s = 0; s < surfVars; s++) {
        dummyPvariables(s, PV->P) = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[s]->m_primVars[PV->P];
        dummyPvariables(s, PV->RHO) = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[s]->m_primVars[PV->RHO];
      }
      for(MInt n = 0; n < (signed)m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.size(); n++) {
        const MInt nghbrId = m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n];
        const MFloat nghbrPvariableP = (n < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs)
                                           ? dummyPvariables(n, PV->P)
                                           : a_pvariable(nghbrId, PV->P);
        const MFloat nghbrPvariableRho = (n < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs)
                                             ? dummyPvariables(n, PV->RHO)
                                             : a_pvariable(nghbrId, PV->RHO);
        rhoSurface +=
            m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst[n] * nghbrPvariableRho;
        pSurface += m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst[n] * nghbrPvariableP;
      }

      MFloat normal0[3] = {F0, F0, F0};
      MFloat normal[3] = {F0, F0, F0};
      for(MInt i = 0; i < nDim; i++) {
        normal0[i] = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
        normal[i] = m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVectorCentroid[i];
      }

      MFloat dn = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance;
      MFloat T = sysEqn().temperature_ES(rhoSurface, pSurface);
      MFloat mue = SUTHERLANDLAW(T);
      MFloat dx[3] = {F0, F0, F0};
      MFloat df[3] = {F0, F0, F0};
      MFloat area = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;

      for(MInt i = 0; i < nDim; i++) {
        const MFloat dp0 = -pSurface * normal0[i] * area;
        const MFloat dp = -pSurface * normal[i] * area;
        MFloat grad = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[PV->VV[i]];
        for(MInt j = 0; j < nDim; j++)
          grad += F1B3 * normal[i] * normal[j]
                  * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[PV->VV[j]];
        MFloat ds0 = F1BRe * mue * grad * area;
        // The following version was used for JFM2020 "Correlations based on highly resolved simulations".
        // TODO labels:FVMB Check the difference for 3D_ellipsoids_Couette for Re -> 0.
        // MFloat grad = m_fvBndryCnd->m_bndryCell[ bndryId].m_srfcVariables[srfc]->m_normalDeriv[ PV->VV[i] ];
        // for( MInt j = 0; j < nDim; j++ ) grad +=
        // F1B3*normal0[i]*normal0[j]*m_fvBndryCnd->m_bndryCell[ bndryId
        // ].m_srfcVariables[srfc]->m_normalDeriv[PV->VV[j]
        // ]; df[i] = dp0 + ds0; dx[i] = a_coordinate( cellId ,  i ) - dn * normal0[ i ] - m_bodyCenter[nDim*k+i ];
        df[i] = dp + ds0;
        dx[i] = a_coordinate(cellId, i) - dn * normal[i] - m_bodyCenter[nDim * k + i];
        bodyForce(body, i) += dp0 + ds0;
        if(returnCoeffs == true) {
          bodyForce(body, nDim + 3 + 1 + i) += dp0;
        }
        coupling -= (dp0 + ds0) * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]];

#if defined _MB_DEBUG_ || !defined NDEBUG
        if(std::isnan(dp0) || std::isnan(ds0)) {
          const MInt rootId =
              (a_hasProperty(cellId, SolverCell::IsSplitChild)) ? getAssociatedInternalCell(cellId) : cellId;
          cerr << domainId() << " local body force diverged " << globalTimeStep << " " << body << " " << i << " " << k
               << " / " << ds0 << " " << dp0 << " " << pSurface << " " << rhoSurface << " " << mue << " " << grad
               << " / " << area / m_gridCellArea[a_level(rootId)] << " " << normal0[i] << " " << normal[i] << " "
               << dn / c_cellLengthAtCell(rootId) << " / " << cellId << " " << c_globalId(rootId) << " "
               << a_level(rootId) << " " << a_hasProperty(cellId, SolverCell::IsSplitChild) << " "
               << m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs << endl;
        }
#endif
      }
#ifdef _MB_DEBUG_
      if(std::isnan(dx[1] * df[2] - dx[2] * df[1]) || std::isnan(dx[2] * df[0] - dx[0] * df[2])
         || std::isnan(dx[0] * df[1] - dx[1] * df[0]))
        cerr << domainId() << ": torque0 " << globalTimeStep << " " << c_globalId(cellId) << " " << bndryId << " "
             << srfc << " = " << pSurface << " " << rhoSurface << " / " << dx[0] << " " << dx[1] << " " << dx[2]
             << " / " << df[0] << " " << df[1] << " " << df[2] << " // " << area / m_gridCellArea[a_level(cellId)]
             << " " << pSurface << " " << mue << " "
             << m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[PV->VV[0]] << " "
             << m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[PV->VV[1]] << " "
             << m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[PV->VV[2]] << endl;
#endif
      IF_CONSTEXPR(nDim == 3) {
        bodyForce(body, nDim + 0) += dx[1] * df[2] - dx[2] * df[1];
        bodyForce(body, nDim + 1) += dx[2] * df[0] - dx[0] * df[2];
      }
      bodyForce(body, nDim + 2) += dx[0] * df[1] - dx[1] * df[0];

      MFloat gradP = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[PV->P];
      MFloat gradRho = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[PV->RHO];
      MFloat gradT = m_gamma * (rhoSurface * gradP - pSurface * gradRho) / POW2(rhoSurface);
      const MFloat lambdaFluid = (T * sqrt(T) * m_sutherlandPlusOneThermal) / (T + m_sutherlandConstantThermal);
      MFloat heatFlux = gradT * area * F1BRe * F1BPr * lambdaFluid * m_gamma;
      bodyForce(body, nDim + 3) += heatFlux;
    }
  }
  RECORD_TIMER_STOP(t_local);
  RECORD_TIMER_START(t_reduce);

  if(m_nonBlockingComm) {
#ifndef MAIA_MS_COMPILER
    MPI_Request redReq1 = MPI_REQUEST_NULL;
    MPI_Request redReq2 = MPI_REQUEST_NULL;
    MPI_Iallreduce(MPI_IN_PLACE, &bodyForce[0], bodyForce.size(), MPI_DOUBLE, MPI_SUM, mpiComm(), &redReq1, AT_,
                   "MPI_IN_PLACE", "bodyForce[0]");
    MPI_Iallreduce(MPI_IN_PLACE, &coupling, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), &redReq2, AT_, "MPI_IN_PLACE",
                   "coupling");
    MPI_Wait(&redReq1, MPI_STATUSES_IGNORE, AT_);
    MPI_Wait(&redReq2, MPI_STATUSES_IGNORE, AT_);
#else
    MPI_Allreduce(MPI_IN_PLACE, &bodyForce[0], bodyForce.size(), MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "bodyForce[0]");
    MPI_Allreduce(MPI_IN_PLACE, &coupling, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "coupling");
#endif
  } else {
    MPI_Allreduce(MPI_IN_PLACE, &bodyForce[0], bodyForce.size(), MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "bodyForce[0]");
    MPI_Allreduce(MPI_IN_PLACE, &coupling, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "coupling");
  }
  RECORD_TIMER_STOP(t_reduce);

  // If a pressureForce is requested, it is assumed that the bodyForces are gathered for statistics. To avoid
  // additional updates of the bodyForces and torques between the time steps, the function is returned here.
  // Updates of the bodyForces and torques after the time step will change the solution.
  m_couplingRate = coupling;
  if(pressureForce != nullptr) {
    for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
      for(MInt i = 0; i < nDim; i++) {
        pressureForce[k * nDim + i] = bodyForce(k, nDim + 3 + 1 + i);
      }
    }
    RECORD_TIMER_STOP(t_timertotal);
    return;
  }
  for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
    for(MInt i = 0; i < nDim; i++) {
      m_bodyForce[k * nDim + i] = bodyForce(k, i);
      m_hydroForce[k * nDim + i] = bodyForce(k, i);
    }
  }
  for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
    m_bodyHeatFlux[k] = bodyForce(k, nDim + 3);
    for(MInt i = 0; i < 3; i++) {
      m_bodyTorque[k * 3 + i] = bodyForce(k, nDim + i);
    }
  }

  // collision model, Glowinski et al
  RECORD_TIMER_START(t_collision);
  IF_CONSTEXPR(nDim == 3) {
    const MFloat S = (m_noLevelSetsUsedForMb > 1) ? F2 * c_cellLengthAtLevel(maxRefinementLevel())
                                                  : F3 * c_cellLengthAtLevel(maxRefinementLevel());
    const MFloat deltaMax = 1.5 * S + F2 * m_maxBodyRadius;

    if(m_noEmbeddedBodies > 1 && m_applyCollisionModel) {
      MIntScratchSpace nearBodies(m_noEmbeddedBodies, AT_, "nearBodies");

      for(MInt p = 0; p < m_noEmbeddedBodies; p++) {
        m_bodyInCollision[p] = 0;
      }

      for(MInt p = 0; p < m_noEmbeddedBodies; p++) {
        ASSERT(m_bodyTree != nullptr, "");

        Point<nDim> pt(m_bodyCenter[p * nDim], m_bodyCenter[p * nDim + 1], m_bodyCenter[p * nDim + 2]);
        MInt noNearBodies = m_bodyTree->locatenear(pt, deltaMax, &nearBodies[0], m_noEmbeddedBodies);

        for(MInt b = 0; b < noNearBodies; b++) {
          const MInt q = nearBodies[b];
          if(p == q) continue;

          m_bodyInCollision[p] = 1;

          const MFloat dp = F2 * mMax(m_bodyRadii[p * 3 + 0], mMax(m_bodyRadii[p * 3 + 1], m_bodyRadii[p * 3 + 2]));
          const MFloat dq = F2 * mMax(m_bodyRadii[q * 3 + 0], mMax(m_bodyRadii[q * 3 + 1], m_bodyRadii[q * 3 + 2]));
          const MFloat D = F1B2 * (dp + dq);
          const MFloat termv =
              sqrt(POW2(m_bodyTerminalVelocity[0]) + POW2(m_bodyTerminalVelocity[1]) + POW2(m_bodyTerminalVelocity[2]));
          const MFloat delta = sqrt(POW2(m_bodyCenter[p * nDim] - m_bodyCenter[q * nDim])
                                    + POW2(m_bodyCenter[p * nDim + 1] - m_bodyCenter[q * nDim + 1])
                                    + POW2(m_bodyCenter[p * nDim + 2] - m_bodyCenter[q * nDim + 2]));
          MFloat dist = delta - D;

          if(dist > S) continue;

          if(m_bodyTypeMb == 1) {
            if(dist < F0 && domainId() == 0) cerr << "Warning: potential overlap for bodies " << p << " " << q << endl;
            const MFloat eps = POW2(S / D);
            const MFloat C = CdLaw(m_Re * D) * F1B2 * m_rhoU2 * F1B4 * PI * POW2(D);
            const MFloat M = F1B2 * (m_bodyMass[m_internalBodyId[p]] + m_bodyMass[m_internalBodyId[q]]);
            const MFloat C0 = 8.0 * M * POW2(m_UInfinity + termv) / c_cellLengthAtLevel(maxRefinementLevel());
            if(dist < S) {
              m_bodyInCollision[p] = 2;
            }
            for(MInt i = 0; i < nDim; i++) {
              MFloat df = C0 * POW2(mMax(F0, -(dist - S) / S))
                          * (m_bodyCenter[p * nDim + i] - m_bodyCenter[q * nDim + i]) / dist;
              m_bodyForce[p * nDim + i] += df;
            }
            if(domainId() == 0 && dist / c_cellLengthAtLevel(maxRefinementLevel()) < 1.5)
              cerr << globalTimeStep << " ---- repulsive force " << m_internalBodyId[q] << " -> " << p << ": "
                   << C0 * POW2(mMax(F0, -(dist - S) / S)) << " / " << C * POW2(mMax(F0, -(dist - S) / S)) / eps << " ("
                   << C0 / (C / eps) << ") dist=" << dist / c_cellLengthAtLevel(maxRefinementLevel()) << endl;

          } else if(m_bodyTypeMb == 3) {
            const MFloat M = F1B2 * (m_bodyMass[m_internalBodyId[p]] + m_bodyMass[m_internalBodyId[q]]);
            const MFloat C0 = 16.0 * M * POW2(m_UInfinity + termv) / c_cellLengthAtLevel(maxRefinementLevel());

            MFloat xcp[3];
            MFloat xcq[3];
            MFloat df[3];
            dist = distEllipsoidEllipsoid(p, q, xcp, xcq);

            if(dist < S) {
              m_bodyInCollision[p] = 2;
            }

            for(MInt i = 0; i < nDim; i++) {
              df[i] = C0 * POW2(mMax(F0, -(dist - S) / S)) * (xcp[i] - xcq[i]) / dist;
              m_bodyForce[p * nDim + i] += df[i];
            }

            if(domainId() == 0 && dist / c_cellLengthAtLevel(maxRefinementLevel()) < 1.5)
              cerr << globalTimeStep << " ---- repulsive force " << m_internalBodyId[q] << " -> " << p << ": "
                   << C0 * POW2(mMax(F0, -(dist - S) / S))
                   << " dist=" << dist / c_cellLengthAtLevel(maxRefinementLevel()) << endl;
          }
        }
      }

      if(m_saveSlipInterval > 0) {
        MInt noParticlesLocal = m_particleOffsets[domainId() + 1] - m_particleOffsets[domainId()];
        MInt noTimeStepsSaved = m_slipDataTimeSteps.size();

        for(MInt p = 0; p < noParticlesLocal; p++) {
          m_slipDataParticleCollision[noParticlesLocal * noTimeStepsSaved + p] =
              m_bodyInCollision[p + m_particleOffsets[domainId()]];
        }
      }
    }
  }

#if defined _MB_DEBUG_ || !defined NDEBUG
  for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
    for(MInt i = 0; i < nDim; i++) {
      if(std::isnan(m_bodyForce[k * nDim + i]) && domainId() == 0) {
        cerr << "force " << setprecision(15) << k << " " << i << " " << m_bodyForce[k * nDim + i] << endl;
        m_log << "force " << setprecision(15) << k << " " << i << " " << m_bodyForce[k * nDim + i];
        for(MInt j = 0; j < nDim; j++)
          m_log << " " << m_bodyCenter[nDim * k + j];
        for(MInt j = 0; j < 4; j++)
          m_log << " " << m_bodyQuaternion[4 * k + j];
        m_log << endl;
      }
    }

    for(MInt i = 0; i < 3; i++) {
      if(std::isnan(m_bodyTorque[k * 3 + i]) && domainId() == 0) {
        cerr << "torque " << setprecision(15) << k << " " << i << " " << m_bodyTorque[k * 3 + i] << endl;
        m_log << "torque " << setprecision(15) << k << " " << i << " " << m_bodyTorque[k * 3 + i];
        for(MInt j = 0; j < nDim; j++)
          m_log << " " << m_bodyCenter[nDim * k + j];
        for(MInt j = 0; j < 4; j++)
          m_log << " " << m_bodyQuaternion[4 * k + j];
        m_log << endl;
      }
    }
  }
#endif
  RECORD_TIMER_STOP(t_collision);
  RECORD_TIMER_STOP(t_timertotal);
  DISPLAY_TIMER_OFFSET(t_timertotal, m_restartInterval);
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
template <typename T>
inline MBool FvMbCartesianSolverXD<nDim, SysEqn>::isNan(T val) {
  return (std::isnan(val) || std::isinf(val));
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::initBodyVelocities() {
  if(m_noEmbeddedBodies == 0) return;
  cerr0 << "Init body velocities" << endl;

  /*! \page propertiesFVMB
       \section initBodyRotation
       <code>MInt FvMbCartesianSolverXD::initBodyVelocities::initBodyRotation</code>\n
       default = <code>0</code>\n \n
       Initializes the body rotation. \n
       <ul>
         <li>0: initial body rotation set to 0 </li>
         <li>1: initial body rotation set to the mean rotation of former fluid cells inside the particles </li>
         <li>2: initial body rotation set to the rotation of a random former fluid cell inside the particle </li>
       </ul>
       Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, ROTATION </i>
     */
  const MInt initBodyRotation = (Context::propertyExists("initBodyRotation", m_solverId))
                                    ? Context::getSolverProperty<MInt>("initBodyRotation", m_solverId, AT_)
                                    : 0;

  memset(m_bodyVelocity, 0, m_noEmbeddedBodies * nDim * sizeof(MFloat));
  memset(m_bodyAngularVelocity, 0, m_noEmbeddedBodies * 3 * sizeof(MFloat));

  if(initBodyRotation == 1) {
    MFloatScratchSpace bodyVol(m_noEmbeddedBodies, AT_, "bodyVol");
    MFloatScratchSpace Ek(m_noEmbeddedBodies, AT_, "Ek");
    bodyVol.fill(F0);

    MFloat vol0 = F0;
    MFloat vol1 = F0;
    MFloat vol2 = F0;
    MFloat Ek0 = F0;
    MFloat EkB = F0;
    MFloat volm = F0;
    MFloat volB = F0;

    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      if(a_isHalo(cellId)) continue;
      ASSERT(!a_isPeriodic(cellId), "");
      if(a_isPeriodic(cellId)) continue;
      if(!a_hasProperty(cellId, SolverCell::IsSplitChild) && c_noChildren(cellId) > 0) continue;
      if(a_bndryId(cellId) < -1) continue;

      MFloat U2 = F0;
      for(MInt i = 0; i < nDim; i++) {
        U2 += POW2(a_variable(cellId, CV->RHO_VV[i]) / a_variable(cellId, CV->RHO));
      }

      Ek0 += F1B2 * a_cellVolume(cellId) * U2;
      volm += a_cellVolume(cellId);

      if(a_levelSetValuesMb(cellId, 0) < F0 || a_bndryId(cellId) >= m_noOuterBndryCells) {
        if(a_associatedBodyIds(cellId, 0) < 0) {
          cerr << domainId() << ": negative body id A" << endl;
          continue;
        }

        MInt bodyId = m_internalBodyId[a_associatedBodyIds(cellId, 0)];
        MFloat vol = grid().gridCellVolume(a_level(cellId));

        if(a_bndryId(cellId) > -1) vol -= a_cellVolume(cellId);

        for(MInt i = 0; i < nDim; i++)
          m_bodyVelocity[nDim * bodyId + i] += vol * a_pvariable(cellId, PV->VV[i]);

        MFloat r2 = F0;
        MFloat dx[3]{};

        for(MInt i = 0; i < nDim; i++) {
          dx[i] = a_coordinate(cellId, i) - m_bodyCenter[bodyId * nDim + i];
          r2 += POW2(dx[i]);
        }

        if(initBodyRotation) {
          m_bodyAngularVelocity[3 * bodyId + 0] +=
              vol * (dx[1] * a_pvariable(cellId, PV->VV[2]) - dx[2] * a_pvariable(cellId, PV->VV[1])) / r2;
          m_bodyAngularVelocity[3 * bodyId + 1] +=
              vol * (dx[2] * a_pvariable(cellId, PV->VV[0]) - dx[0] * a_pvariable(cellId, PV->VV[2])) / r2;
          m_bodyAngularVelocity[3 * bodyId + 2] +=
              vol * (dx[0] * a_pvariable(cellId, PV->VV[1]) - dx[1] * a_pvariable(cellId, PV->VV[0])) / r2;
        }
        for(MInt i = 0; i < nDim; i++)
          Ek[bodyId] += vol * POW2(a_pvariable(cellId, PV->VV[i]));
        bodyVol(bodyId) += vol;
        vol0 += vol;
        for(MInt i = 0; i < nDim; i++)
          EkB += vol * POW2(a_pvariable(cellId, PV->VV[i]));
        volB += vol;
      }
      if(a_levelSetValuesMb(cellId, 0) > F0 || a_bndryId(cellId) >= m_noOuterBndryCells) {
        MFloat vol = a_cellVolume(cellId);
        vol1 += vol;
      }

      if(a_bndryId(cellId) >= m_noOuterBndryCells) {
        MFloat vol = m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_srfcs[0]->m_area;
        vol2 += vol;
      }
    }
    MPI_Allreduce(MPI_IN_PLACE, m_bodyVelocity, m_noEmbeddedBodies * nDim, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_,
                  "MPI_IN_PLACE", "m_bodyVelocity");
    MPI_Allreduce(MPI_IN_PLACE, m_bodyAngularVelocity, m_noEmbeddedBodies * 3, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_,
                  "MPI_IN_PLACE", "m_bodyAngularVelocity");
    MPI_Allreduce(MPI_IN_PLACE, &bodyVol[0], m_noEmbeddedBodies, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "bodyVol[0]");
    MPI_Allreduce(MPI_IN_PLACE, &vol0, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "vol0");
    MPI_Allreduce(MPI_IN_PLACE, &vol1, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "vol1");
    MPI_Allreduce(MPI_IN_PLACE, &vol2, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "vol2");
    MPI_Allreduce(MPI_IN_PLACE, &Ek[0], m_noEmbeddedBodies, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "Ek[0]");
    MPI_Allreduce(MPI_IN_PLACE, &Ek0, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "Ek0");
    MPI_Allreduce(MPI_IN_PLACE, &volm, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "volm");
    MPI_Allreduce(MPI_IN_PLACE, &EkB, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "EkB");
    MPI_Allreduce(MPI_IN_PLACE, &volB, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "volB");
    Ek0 /= volm;
    EkB /= volB;

    MFloat EkB2 = 0;
    for(MInt b = 0; b < m_noEmbeddedBodies; b++) {
      if(domainId() == 0 && fabs(bodyVol[b] - m_bodyVolume[b]) / m_bodyVolume[b] > 0.1)
        cerr << "bad body volume " << b << " " << bodyVol[b] << " " << m_bodyVolume[b] << endl;
      Ek[b] /= mMax(1e-14, bodyVol[b]);

      for(MInt i = 0; i < nDim; i++) {
        m_bodyVelocity[nDim * b + i] /= mMax(1e-14, bodyVol[b]);
        m_bodyVelocityDt1[nDim * b + i] = m_bodyVelocity[nDim * b + i];
        if(domainId() == 0 && std::isnan(m_bodyVelocity[nDim * b + i]))
          cerr << "Warning: body velocity " << b << " " << i << " " << m_bodyVelocity[nDim * b + i] << endl;
        EkB2 += F1B2 * POW2(m_bodyVelocity[nDim * b + i]);
      }

      if(initBodyRotation) {
        for(MInt i = 0; i < 3; i++) {
          m_bodyAngularVelocity[3 * b + i] /= mMax(1e-14, bodyVol[b]);
          m_bodyAngularVelocityDt1[3 * b + i] = m_bodyAngularVelocity[3 * b + i];
          if(domainId() == 0 && std::isnan(m_bodyAngularVelocity[3 * b + i]))
            cerr << "Warning: body angular velocity " << b << " " << i << " " << m_bodyAngularVelocity[3 * b + i]
                 << endl;
        }
      }

      for(MUint j = 0; j < m_periodicGhostBodies[b].size(); j++) {
        MInt k = m_periodicGhostBodies[b][j];
        transferBodyState(k, b);
      }
    }

    for(MInt k = 0; k < m_noEmbeddedBodies + m_noPeriodicGhostBodies; k++) {
      for(MInt dir = 0; dir < nDim; dir++) {
        m_bodyVelocity[nDim * k + dir] += m_bodyTerminalVelocity[dir];
      }
    }

    if(domainId() == 0) {
      cerr << "domain volumes upon init: " << setprecision(12) << vol0 << " " << vol1 << " "
           << vol0 / POW3(m_bbox[3] - m_bbox[0]) << " " << (vol0 + vol1) / POW3(m_bbox[3] - m_bbox[0]) << " "
           << Ek0 / POW2(m_UInfinity) << " " << EkB / POW2(m_UInfinity) << " "
           << (Ek0 * volm + EkB * volB) / ((volm + volB) * POW2(m_UInfinity)) << " "
           << EkB2 / (POW2(m_UInfinity) * m_noEmbeddedBodies) << endl;
      m_log << "domain volumes upon init: " << setprecision(12) << vol0 << " " << vol1 << " "
            << vol0 / POW3(m_bbox[3] - m_bbox[0]) << " " << (vol0 + vol1) / POW3(m_bbox[3] - m_bbox[0]) << " "
            << Ek0 / POW2(m_UInfinity) << " " << EkB / POW2(m_UInfinity) << " "
            << (Ek0 * volm + EkB * volB) / ((volm + volB) * POW2(m_UInfinity)) << " "
            << EkB2 / (POW2(m_UInfinity) * m_noEmbeddedBodies) << endl;
    }
  } else {
    MIntScratchSpace nearestCellToCenter(m_noEmbeddedBodies, AT_, "nearestCellToCenter");
    MFloatScratchSpace nearestDist(m_noEmbeddedBodies, AT_, "nearestDist");
    nearestCellToCenter.fill(-1);
    nearestDist.fill(std::numeric_limits<MFloat>::max());

    MFloat volF = F0;
    MFloat volB = F0;
    MFloat EkFluid = F0;
    MFloat EkFluidInBodyVol = F0;
    MFloat dx[3] = {F0, F0, F0};

    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      if(a_isHalo(cellId)) continue;
      ASSERT(!a_isPeriodic(cellId), "");
      if(a_isPeriodic(cellId)) continue;
      if(!a_hasProperty(cellId, SolverCell::IsSplitChild) && c_noChildren(cellId) > 0) continue;
      if(a_bndryId(cellId) < -1) continue;

      MFloat U2 = F0;
      for(MInt i = 0; i < nDim; i++) {
        U2 += POW2(a_variable(cellId, CV->RHO_VV[i]) / a_variable(cellId, CV->RHO));
      }

      EkFluid += F1B2 * a_cellVolume(cellId) * U2;
      volF += a_cellVolume(cellId);

      if(a_levelSetValuesMb(cellId, 0) < F0 || a_bndryId(cellId) >= m_noOuterBndryCells) {
        MInt bodyId = a_associatedBodyIds(cellId, 0);
        if(bodyId < 0) continue;
        bodyId = m_internalBodyId[bodyId];
        MFloat vol = grid().gridCellVolume(a_level(cellId));
        if(a_bndryId(cellId) > -1) vol -= a_cellVolume(cellId);
        volB += vol;
        for(MInt i = 0; i < nDim; i++) {
          EkFluidInBodyVol += F1B2 * vol * POW2(a_variable(cellId, CV->RHO_VV[i]) / a_variable(cellId, CV->RHO));
        }
        MFloat r2 = F0;
        for(MInt i = 0; i < nDim; i++) {
          dx[i] = a_coordinate(cellId, i) - m_bodyCenter[bodyId * nDim + i];
          r2 += POW2(dx[i]);
        }
        if(sqrt(r2) < nearestDist(bodyId)) {
          nearestCellToCenter(bodyId) = cellId;
          nearestDist(bodyId) = sqrt(r2);
        }
      }
    }

    MPI_Allreduce(MPI_IN_PLACE, &EkFluid, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "EkFluid");
    MPI_Allreduce(MPI_IN_PLACE, &EkFluidInBodyVol, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "EkFluidInBodyVol");
    MPI_Allreduce(MPI_IN_PLACE, &volF, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "volF");
    MPI_Allreduce(MPI_IN_PLACE, &volB, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "volB");
    MPI_Allreduce(MPI_IN_PLACE, &nearestDist(0), m_noEmbeddedBodies, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_,
                  "MPI_IN_PLACE", "nearestDist(0)");

    if(initBodyRotation) exchangeAll();

    for(MInt bodyId = 0; bodyId < m_noEmbeddedBodies; bodyId++) {
      MInt cellId = nearestCellToCenter(bodyId);
      if(cellId < 0) continue;
      MFloat r2 = F0;
      for(MInt i = 0; i < nDim; i++) {
        dx[i] = a_coordinate(cellId, i) - m_bodyCenter[bodyId * nDim + i];
        r2 += POW2(dx[i]);
      }
      if(sqrt(r2) > (nearestDist(bodyId) + std::numeric_limits<MFloat>::epsilon())) continue;
      for(MInt i = 0; i < nDim; i++) {
        m_bodyVelocity[nDim * bodyId + i] = a_variable(cellId, CV->RHO_VV[i]) / a_variable(cellId, CV->RHO);
      }
      if(initBodyRotation) {
        while(a_level(cellId) > maxUniformRefinementLevel()) {
          cellId = c_parentId(cellId);
        }
        vector<vector<MFloat>> slope(nDim, vector<MFloat>(nDim));
        for(MInt dir = 0; dir < m_noDirs / 2; dir++) {
          MInt nghbrId1 = -1;
          MInt nghbrId2 = -1;
          if(a_hasNeighbor(cellId, dir) > 0)
            nghbrId1 = c_neighborId(cellId, 2 * dir);
          else
            mTerm(0, AT_, "neighbor not found. PartitionLevelShift?");
          if(a_hasNeighbor(cellId, dir + 1) > 0)
            nghbrId2 = c_neighborId(cellId, 2 * dir + 1);
          else
            mTerm(0, AT_, "neighbor not found. PartitionLevelShift?");
          for(MInt i = 0; i < nDim; i++) {
            slope[i][dir] = F1 / (F2 * grid().cellLengthAtCell(cellId))
                            * (a_pvariable(nghbrId2, PV->VV[i]) - a_pvariable(nghbrId1, PV->VV[i]));
          }
        }
        for(MInt i = 0; i < nDim; i++) {
          MInt id0 = (i + 1) % 3;
          MInt id1 = (id0 + 1) % 3;
          m_bodyAngularVelocity[3 * bodyId + i] += F1B2 * (slope[id1][id0] - slope[id0][id1]);
        }
      }
    }

    MPI_Allreduce(MPI_IN_PLACE, m_bodyVelocity, m_noEmbeddedBodies * nDim, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_,
                  "MPI_IN_PLACE", "m_bodyVelocity");
    if(initBodyRotation)
      MPI_Allreduce(MPI_IN_PLACE, m_bodyAngularVelocity, m_noEmbeddedBodies * 3, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_,
                    "MPI_IN_PLACE", "m_bodyAngularVelocity");

    MFloat EkBTot = F0;
    MFloat EkBLin = F0;
    MFloat EkBRot = F0;
    MFloat EkBTerm = F0;
    MFloat volBAnalytical = F0;
    for(MInt bodyId = 0; bodyId < m_noEmbeddedBodies; bodyId++) {
      for(MInt i = 0; i < nDim; i++) {
        m_bodyVelocityDt1[nDim * bodyId + i] = m_bodyVelocity[nDim * bodyId + i];
        EkBLin += F1B2 * POW2(m_bodyVelocity[nDim * bodyId + i]);
        EkBTot += F1B2 * POW2(m_bodyVelocity[nDim * bodyId + i]);
        EkBTerm += F1B2 * POW2(m_bodyVelocity[nDim * bodyId + i] + m_bodyTerminalVelocity[i]);
        if(domainId() == 0 && std::isnan(m_bodyVelocity[nDim * bodyId + i]))
          cerr << "Warning: body velocity " << bodyId << " " << i << " " << m_bodyVelocity[nDim * bodyId + i] << endl;
      }

      if(initBodyRotation) {
        MFloat q[3];
        MFloat tmp[3];
        MFloatScratchSpace R(3, 3, AT_, "R");
        computeRotationMatrix(R, &(m_bodyQuaternion[4 * bodyId]));
        for(MInt i = 0; i < 3; i++)
          tmp[i] = m_bodyAngularVelocity[bodyId * 3 + i];
        matrixVectorProduct(q, R, tmp); // principal axes angular velocity
        for(MInt i = 0; i < nDim; i++) {
          m_bodyAngularVelocityDt1[3 * bodyId + i] = m_bodyAngularVelocity[3 * bodyId + i];
          EkBRot += F1B2 * POW2(q[i]) * m_bodyMomentOfInertia[3 * bodyId + i] / m_bodyMass[bodyId];
          EkBTot += EkBRot;
          if(domainId() == 0 && std::isnan(m_bodyAngularVelocity[3 * bodyId + i]))
            cerr << "Warning: body angular velocity " << bodyId << " " << i << " "
                 << m_bodyAngularVelocity[3 * bodyId + i] << endl;
        }
      }

      for(MUint j = 0; j < m_periodicGhostBodies[bodyId].size(); j++) {
        MInt k = m_periodicGhostBodies[bodyId][j];
        transferBodyState(k, bodyId);
      }
      volBAnalytical += F4B3 * PI * m_bodyRadii[bodyId] * m_bodyRadii[bodyId + 1] * m_bodyRadii[bodyId + 2];
    }
    for(MInt k = 0; k < m_noEmbeddedBodies + m_noPeriodicGhostBodies; k++) {
      for(MInt dir = 0; dir < nDim; dir++) {
        m_bodyVelocity[nDim * k + dir] += m_bodyTerminalVelocity[dir];
      }
    }
    MFloat volFAnalytical = F1;
    for(MInt dim = 0; dim < nDim; dim++) {
      volFAnalytical *= (m_bbox[nDim + dim] - m_bbox[dim]);
    }
    volFAnalytical -= volBAnalytical;
    if(domainId() == 0) {
      cerr << "InitBodyFluidVelocities: mean kinetic Energy " << setprecision(12) << "fluid "
           << EkFluid / (POW2(m_UInfinity) * volF) << " fluid in bodies "
           << EkFluidInBodyVol / (POW2(m_UInfinity) * volB) << " bodies: total "
           << EkBTot / (POW2(m_UInfinity) * m_noEmbeddedBodies) << " linear "
           << EkBLin / (POW2(m_UInfinity) * m_noEmbeddedBodies) << " rotational "
           << EkBRot / (POW2(m_UInfinity * m_noEmbeddedBodies)) << " terminal "
           << EkBTerm / (POW2(m_UInfinity) * m_noEmbeddedBodies) << endl;
      cerr << "InitBodyFluidVelocities: volumes " << setprecision(12) << "fluid " << volF << " analytical "
           << volFAnalytical << " bodies " << volB << " volBAnalytical " << volBAnalytical << endl;
      m_log << "InitBodyFluidVelocities: mean kinetic Energy " << setprecision(12) << "fluid "
            << EkFluid / (POW2(m_UInfinity) * volF) << " fluid in bodies "
            << EkFluidInBodyVol / (POW2(m_UInfinity) * volB) << " bodies total "
            << EkBTot / (POW2(m_UInfinity) * m_noEmbeddedBodies) << " linear "
            << EkBLin / (POW2(m_UInfinity) * m_noEmbeddedBodies) << " rotational "
            << EkBRot / (POW2(m_UInfinity * m_noEmbeddedBodies)) << " terminal "
            << EkBTerm / (POW2(m_UInfinity) * m_noEmbeddedBodies) << endl;
      m_log << "InitBodyFluidVelocities: volumes " << setprecision(12) << "fluid " << volF << " analytical "
            << volFAnalytical << " bodies " << volB << " volBAnalytical " << volBAnalytical << endl;
    }
  }
}

/**
 * \brief determines cells at the boundary (i.e. boundary cells and their direct neighbors)
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::determineNearBndryCells() {
  /*
    TRACE();

    MInt cellId;

    // 1. find near boundary cells
    m_noNearBndryCells = 0;
    m_nearBndryCells->resetSize(0);

    for ( MUint c = 0; c < m_bndryLayerCells.size(); c++ ) {
      cellId = m_bndryLayerCells[ c ];
      if ( cellId < 0 ) continue;
      if ( !a_hasProperty( cellId , SolverCell::IsOnCurrentMGLevel) )
    continue; if ( a_hasProperty( cellId , SolverCell::IsInactive ) )
    continue; if ( a_isBndryGhostCell( cellId ) ) continue;
      //if ( a_level(cellId) != maxRefinementLevel() ) continue;

      m_nearBndryCells->append();
      m_nearBndryCells->a[ m_noNearBndryCells ] = cellId;
      m_noNearBndryCells++;
    }*/
}


/**
 * \fn void FvMbCartesianSolverXD<nDim, SysEqn>::setRungeKuttaFunctionPointer()
 * \brief This function sets the function pointers for rungeKutta (also used in splitBalance)
 * \author Jannik Borgelt
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::setRungeKuttaFunctionPointer() {
  TRACE();

  // set default
  execRungeKuttaStep = nullptr;
  /*! \page propertiesFVMB
  \section rungeKuttaStepMethod
  <code>MInt FvMbSolverXD::rungeKuttaStepMethod</code>\n
  default = <code> false </code>\n \n
  Switch to use new modified Runge Kutta Scheme optimized for moving boundaries
  Possible values are:
  <ul>
    <li> true/false  </li>
  </ul>
  Keywords: <i>FINITE VOLUME, MOVING BOUNDARY </i>
*/
  m_standardRK = (Context::propertyExists("rungeKuttaStandardMb", m_solverId))
                     ? Context::getSolverProperty<MBool>("rungeKuttaStandardMb", m_solverId, AT_)
                     : false;


  if(!m_standardRK && !m_dualTimeStepping) {
    execRungeKuttaStep = m_localTS ? &FvMbCartesianSolverXD<nDim, SysEqn>::rungeKuttaStepNew<1>
                                   : &FvMbCartesianSolverXD<nDim, SysEqn>::rungeKuttaStepNew<0>;
  } else if(m_standardRK && !m_dualTimeStepping) {
    execRungeKuttaStep = m_localTS ? &FvMbCartesianSolverXD<nDim, SysEqn>::rungeKuttaStepStandard<1>
                                   : &FvMbCartesianSolverXD<nDim, SysEqn>::rungeKuttaStepStandard<0>;
  } else if(m_dualTimeStepping) {
    execRungeKuttaStep = &FvCartesianSolverXD<nDim, SysEqn>::rungeKuttaStep;
  }

  // number of Runge-Kutta steps
  m_noRKSteps = Context::getSolverProperty<MInt>("noRKSteps", m_solverId, AT_);

  // alpha
  if(m_RKalpha != nullptr) {
    mDeallocate(m_RKalpha);
  }
  mAlloc(m_RKalpha, m_noRKSteps, "m_RKalpha", F0, AT_);

  for(MInt i = 0; i < m_noRKSteps; i++) {
    m_RKalpha[i] = Context::getSolverProperty<MFloat>("rkalpha-step", m_solverId, AT_, i);
  }

  m_RKStep = 0;
}

/**
 * \brief This function loads all terms used by Runge Kutta
 * \author Daniel Hartmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::initializeRungeKutta() {
  TRACE();

  setRungeKuttaFunctionPointer();

  if(!m_restart) {
    m_time = 0.0;
    m_physicalTimeDt1 = m_physicalTime;
  }

  for(MInt cellId = a_noCells() - 1; cellId >= 0; --cellId) {
    for(MInt varId = 0; varId < m_noCVars; varId++) {
      a_oldVariable(cellId, varId) = a_variable(cellId, varId);
    }
  }

  computeCellVolumes();
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::computeBoundarySurfaceForces() {
  TRACE();

  if(!m_levelSetMb) applyBoundaryConditionMb();
  if(m_trackBodySurfaceData) computeBodySurfaceData();
}


/**
 * \brief dummy, since applyBoundaryCondition() it is placed wrong for moving boundary problems, see
 * applyBoundaryConditionMb() \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::applyBoundaryCondition() {
  // dummy, see applyBoundaryConditionMb()

  for(MInt i = 0; i < noNeighborDomains(); i++) {
    for(MInt j = 0; j < m_noMaxLevelHaloCells[i]; j++) {
      MInt cellId = m_maxLevelHaloCells[i][j];
      setConservativeVariables(cellId);
    }
  }

  if(grid().azimuthalPeriodicity()) {
    for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
      for(MUint j = 0; j < m_azimuthalMaxLevelHaloCells[i].size(); j++) {
        MInt cellId = m_azimuthalMaxLevelHaloCells[i][j];
        setConservativeVariables(cellId);
      }
    }
  }

  // update split childs after exchange()
  for(MUint sc = 0; sc < m_splitCells.size(); sc++) {
    const MInt cellId = m_splitCells[sc];
    if(!a_isHalo(cellId)) continue;
    MFloat volCnt = F0;
    for(MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) {
      const MInt splitChildId = m_splitChilds[sc][ssc];
      for(MInt v = 0; v < m_noCVars; v++) {
        a_variable(splitChildId, v) = a_variable(cellId, v);
      }
      for(MInt v = 0; v < m_noFVars; v++) {
        a_rightHandSide(splitChildId, v) = a_rightHandSide(cellId, v);
        m_rhs0[splitChildId][v] = m_rhs0[cellId][v];
      }
      volCnt += a_cellVolume(splitChildId);
    }
    for(MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) {
      const MInt splitChildId = m_splitChilds[sc][ssc];
      volCnt = mMax(volCnt, 1e-15);
      for(MInt v = 0; v < m_noFVars; v++) {
        a_rightHandSide(splitChildId, v) *= a_cellVolume(splitChildId) / volCnt;
        m_rhs0[splitChildId][v] *= a_cellVolume(splitChildId) / volCnt;
      }
      setPrimitiveVariables(splitChildId);
    }
  }


  // if ( m_noPointParticles > 0 ) advancePointParticles();
  if(m_RKStep == 0 && m_noPointParticles > 0) advancePointParticles();

  if(m_RKStep != 0 || globalTimeStep == 0) return;
  if(m_conservationCheck) {
    MBool& firstRun = m_static_applyBoundaryCondition_firstRun;
    MFloat eRhoL1 = F0;
    MFloat eRhoL2 = F0;
    MFloat eRhoLoo = F0;
    MFloat eVelL1 = F0;
    MFloat eVelL2 = F0;
    MFloat eVelLoo = F0;
    MFloat counter = F0;
    MFloat mass = F0;
    MFloat vol = F0;
    MFloat oldVol = F0;
    MFloat rhs = F0;
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      if(a_isBndryGhostCell(cellId)) continue;
      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
      if(a_isPeriodic(cellId)) continue;
      if(a_isHalo(cellId)) continue;
      if(c_noChildren(cellId) > 0) continue;
      if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
      // if ( a_coordinate( cellId , 0) < m_bodyCenter[0]) continue;
      if(a_coordinate(cellId, 0) > m_bodyCenter[0]) continue;
      rhs += a_rightHandSide(cellId, CV->RHO);
      MFloat vel = F0;
      for(MInt i = 0; i < nDim; i++)
        vel += POW2(a_pvariable(cellId, PV->VV[i]) - m_VVInfinity[i]);
      vel = sqrt(vel);
      eRhoL1 += fabs(a_pvariable(cellId, PV->RHO) - m_rhoInfinity);
      eRhoL2 += POW2(a_pvariable(cellId, PV->RHO) - m_rhoInfinity);
      eRhoLoo = mMax(eRhoLoo, fabs(a_pvariable(cellId, PV->RHO) - m_rhoInfinity));
      eVelL1 += fabs(vel);
      eVelL2 += POW2(vel);
      eVelLoo = mMax(eVelLoo, fabs(vel));
      counter += F1;
      mass += a_cellVolume(cellId) * a_variable(cellId, CV->RHO);
      vol += a_cellVolume(cellId);
      oldVol += m_cellVolumesDt1[cellId];
    }
    MFloat delta = F0;
    MFloat area = F0;
    for(MInt bs = 0; bs < m_fvBndryCnd->m_noBoundarySurfaces; bs++) {
      MInt srfcId = m_fvBndryCnd->m_boundarySurfaces[bs];
      if(a_surfaceBndryCndId(srfcId) / 1000 == 3) {
        continue;
      }
      if(a_isBndryGhostCell(a_surfaceNghbrCellId(srfcId, 0)))
        delta -= a_surfaceFlux(srfcId, CV->RHO);
      else
        delta += a_surfaceFlux(srfcId, CV->RHO);
      area += a_surfaceArea(srfcId);
    }
    MPI_Allreduce(MPI_IN_PLACE, &mass, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "mass");
    MPI_Allreduce(MPI_IN_PLACE, &delta, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "delta");
    MPI_Allreduce(MPI_IN_PLACE, &vol, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "vol");
    MPI_Allreduce(MPI_IN_PLACE, &oldVol, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "oldVol");
    MFloat& ERhoL1 = m_static_applyBoundaryCondition_ERhoL1;
    MFloat& ERhoL2 = m_static_applyBoundaryCondition_ERhoL2;
    MFloat& ERhoLoo = m_static_applyBoundaryCondition_ERhoLoo;
    MFloat& EVelL1 = m_static_applyBoundaryCondition_EVelL1;
    MFloat& EVelL2 = m_static_applyBoundaryCondition_EVelL2;
    MFloat& EVelLoo = m_static_applyBoundaryCondition_EVelLoo;
    MFloat& refMass = m_static_applyBoundaryCondition_refMass;
    MFloat& oldMass = m_static_applyBoundaryCondition_oldMass;
    MFloat& oldVol2 = m_static_applyBoundaryCondition_oldVol2;
    if(firstRun) {
      ERhoL1 = F0;
      ERhoL2 = F0;
      ERhoLoo = F0;
      EVelL1 = F0;
      EVelL2 = F0;
      EVelLoo = F0;
      refMass = mass;
      oldMass = mass;
      oldVol2 = vol;
    }
    ERhoL1 += eRhoL1;
    ERhoL2 += eRhoL2;
    ERhoLoo = mMax(ERhoLoo, eRhoLoo);
    EVelL1 += eVelL1;
    EVelL2 += eVelL2;
    EVelLoo = mMax(EVelLoo, eVelLoo);
    refMass -= timeStep() * delta;
    oldMass -= timeStep() * delta;
    MFloat FTS = (MFloat)globalTimeStep;
    if(domainId() == 0) {
      ofstream ofl;
      if(firstRun)
        ofl.open("mass_loss", ios_base::out | ios_base::trunc);
      else
        ofl.open("mass_loss", ios_base::out | ios_base::app);
      cerr << "mass defect" << globalTimeStep << " (" << delta * timeStep() << ") " << refMass - mass << " "
           << oldMass - mass //<< " " << area
           << " //vol " << vol - oldVol << " (" << oldVol - oldVol2 << ") " << setprecision(16)
           << timeStep() * (rhs - delta);
      if(m_noCellsInsideSpongeLayer > 0) cerr << "     | Warning: sponge is on!";
      cerr << setprecision(6) << endl;
      if(ofl.is_open() && ofl.good()) {
        ofl << "mass defect" << setprecision(10) << globalTimeStep << " (" << delta * timeStep() << ") "
            << refMass - mass << " " << oldMass - mass //<< " " << area
            << " //vol " << vol - oldVol << " (" << oldVol - oldVol2 << ") " << timeStep() * (rhs - delta) << endl;
        ofl.close();
      }
    }
    if(m_initialCondition == 474) {
      cerr << domainId() << ": ERROR rho " << globalTimeStep << " " << m_bodyCenter[0] / m_bodyDiameter[0] << " // "
           << eRhoLoo << " " << eRhoL1 / counter << " " << sqrt(eRhoL2 / counter) << " // " << ERhoLoo << " "
           << ERhoL1 / (counter * FTS) << " " << sqrt(ERhoL2 / (counter * FTS));
      cerr << " ||| ERROR vel " << eVelLoo << " " << eVelL1 / counter << " " << sqrt(eVelL2 / counter) << " // "
           << EVelLoo << " " << EVelL1 / (counter * FTS) << " " << sqrt(EVelL2 / (counter * FTS)) << endl;
      if(domainId() == 0) {
        ofstream ofl;
        ofl.open("mass_error", ios_base::out | ios_base::app);
        if(ofl.is_open() && ofl.good()) {
          ofl << setprecision(16) << m_time << " " << fabs(refMass - mass) << " " << fabs(oldMass - mass) << " "
              << eRhoLoo << " " << eRhoL1 / counter << " " << eVelLoo << " " << eVelL1 / counter << endl;
          ofl.close();
        }
      }
      if(m_bodyCenter[0] > m_bodyDiameter[0]) mTerm(0, AT_, "one diameter traveled.");
    }
    oldMass = mass;
    oldVol2 = vol;
    firstRun = false;
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::applyALECorrection() {
  TRACE();

  if(m_dualTimeStepping) return;

  const MUint noFluxVars = FV->noVariables;
  const MUint noPVars = PV->noVariables;
  const MInt noBCells = m_fvBndryCnd->m_bndryCells->size();
  const MUint surfaceVarMemory = 2 * noPVars;
  MFloat* RESTRICT area = &a_surfaceArea(0);
  MFloat* const RESTRICT fluxes = ALIGNED_MF(&a_surfaceFlux(0, 0));
  MFloat* const RESTRICT surfaceVars = ALIGNED_F(&a_surfaceVariable(0, 0, 0));

  for(MInt bndryId = m_noOuterBndryCells; bndryId < noBCells; bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;

    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(a_isHalo(cellId)) continue;

#if defined _ALE_FORM_
    if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;
#else
    if(a_hasProperty(cellId, SolverCell::IsSplitCell) || a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
#endif

#ifdef _MB_DEBUG_
    MFloat totalArea = F0;
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      totalArea += m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
    }
#endif

    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      for(MInt i = 0; i < nDim; i++) {
        MInt srfcId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_srfcId[i];
        if(srfcId < 0) continue;

#if defined _MB_DEBUG_ || !defined NDEBUG
        MFloat area0 = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
        MFloat nml = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
        ASSERT(fabs(area[srfcId] - area0 * fabs(nml)) < 1e-12,
               to_string(area[srfcId]) + " " + to_string(area0 * fabs(nml)));
#endif


#if defined _ALE_FORM_
        const MUint fluxOffset = srfcId * noFluxVars;
        const MUint offset = srfcId * surfaceVarMemory;
        MFloat* const RESTRICT flux = ALIGNED_MF(fluxes + fluxOffset);
        MFloat* const RESTRICT leftSurface = ALIGNED_F(surfaceVars + offset);
        const MFloat* const bndrySurf = &m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_primVars[0];

        sysEqn().AusmALECorrection(i, area[srfcId], flux, leftSurface, bndrySurf);
#else

        const MFloat PLR = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_primVars[PV->P];
        const MFloat VLR = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]];


        MFloatScratchSpace work(m_noCVars, FUN_, "work");
        for(MInt v = 0; v < m_noCVars; v++) {
          work[v] = F0;
        }
        work[CV->RHO_VV[i]] = PLR * area[srfcId];
        work[CV->RHO_E] = PLR * VLR * area[srfcId];

        a_surfaceVariable(srfcId, 0, PV->VV[i]) = VLR;
        a_surfaceVariable(srfcId, 1, PV->VV[i]) = VLR;

        const MFloat sign = (nml > F0) ? -F1 : F1;
        const MFloat dVdt = (a_cellVolume(cellId) - m_cellVolumesDt1[cellId]) / timeStep();
        const MFloat fac = area0 * POW2(nml) / mMax(m_eps, totalArea);
#ifdef _MB_DEBUG_
        for(MInt v = 0; v < m_noCVars; v++) {
          if(std::isnan(work[v]) || std::isnan(sign * fac * a_oldVariable(cellId, v) * dVdt)) {
            cerr << domainId() << ": cell " << cellId << " diverged after ALE formulation at " << globalTimeStep << " "
                 << srfc << " " << i << " " << v << " " << a_hasProperty(cellId, SolverCell::WasInactive) << " /flx "
                 << work[v] << " " << sign << " " << fac << " " << a_oldVariable(cellId, v) << " /vol " << dVdt << " "
                 << a_cellVolume(cellId) << " " << m_cellVolumesDt1[cellId] << " /var " << PLR << " "
                 << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_primVars[v] << endl;
          }
        }
#endif
        for(MInt v = 0; v < m_noCVars; v++) {
          a_surfaceFlux(srfcId, v) = (sign * fac * a_oldVariable(cellId, v) * dVdt) + work[v];
        }
#endif
      }
    }
  }
}


/**
 * \fn void FvMbCartesianSolverXD<nDim, SysEqn>::updateSpongeLayer()
 * \brief computes the additional rhs of all cells lying inside the
 *        sponge layer to dissipate outgoing waves.
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::updateSpongeLayer() {
  TRACE();

  MBool& mbSpongeLayer = m_static_updateSpongeLayer_mbSpongeLayer;
  MBool& first = m_static_updateSpongeLayer_first;
  if(first) {
    /*! \page propertiesFVMB
      \section mbSpongeLayer
      <code>MBool FvMbSolver::m_static_updateSpongeLayer_mbSpongeLayer</code>\n
      default = <code>false</code>\n \n
      Enable the use of the moving boundary solver sponge layer instead of the default finite
      volume solver sponge layer. \n \n
      Possible values are:
      <ul>
        <li><code>0</code> (off)</li>
        <li><code>1</code> (on)</li>
      </ul>
      Keywords: <i>FINITE_VOLUME, MOVING_BOUNDARY, SPONGE, LAYER</i>
    */
    mbSpongeLayer = Context::getSolverProperty<MBool>("mbSpongeLayer", m_solverId, AT_, &mbSpongeLayer);
    first = false;
  }
  if(!mbSpongeLayer) {
    return FvCartesianSolverXD<nDim, SysEqn>::updateSpongeLayer();
  } else {
    if(m_spongeLayerThickness > F0) {
      MInt cellId;
      MFloat deltaP, deltaRho;
      MFloat FgammaMinusOne = F1 / (m_gamma - F1);
      MFloat fac = F1; // / ( m_RKalpha[ m_RKStep ] * timeStep() );


      for(MInt c = 0; c < m_noCellsInsideSpongeLayer; c++) {
        cellId = m_cellsInsideSpongeLayer[c];

        // compute the forcing terms
        deltaP = (a_pvariable(cellId, PV->P) - m_PInfinity) * FgammaMinusOne;
        deltaRho = a_pvariable(cellId, PV->RHO) - m_rhoInfinity * m_targetDensityFactor;

        if((m_initialCondition == 455) || (m_initialCondition == 456) || (m_initialCondition == 45300)) {
          a_rightHandSide(cellId, CV->RHO) +=
              a_spongeFactor(cellId) * fac * (a_variable(cellId, CV->RHO) - m_rhoInfinity) * a_cellVolume(cellId);
          a_rightHandSide(cellId, CV->RHO_E) +=
              a_spongeFactor(cellId) * fac * (a_variable(cellId, CV->RHO_E) - m_rhoEInfinity) * a_cellVolume(cellId);
          for(MInt i = 0; i < nDim; i++) {
            a_rightHandSide(cellId, CV->RHO_VV[i]) +=
                a_spongeFactor(cellId) * fac * (a_variable(cellId, CV->RHO_VV[i]) - F0) * a_cellVolume(cellId);
          }
        }

        else if(m_initialCondition == 45301) {
          a_rightHandSide(cellId, CV->RHO) +=
              a_spongeFactor(cellId) * fac * (a_variable(cellId, CV->RHO) - m_rhoInfinity) * a_cellVolume(cellId);
          a_rightHandSide(cellId, CV->RHO_E) +=
              a_spongeFactor(cellId) * fac * (a_variable(cellId, CV->RHO_E) - m_rhoEInfinity) * a_cellVolume(cellId);
          for(MInt i = 0; i < nDim; i++) {
            a_rightHandSide(cellId, CV->RHO_VV[i]) += a_spongeFactor(cellId) * fac
                                                      * (a_variable(cellId, CV->RHO_VV[i]) - m_rhoVVInfinity[i])
                                                      * a_cellVolume(cellId);
          }
        }

        else {
          a_rightHandSide(cellId, CV->RHO_E) += a_spongeFactor(cellId) * deltaP * fac * a_cellVolume(cellId);
          a_rightHandSide(cellId, CV->RHO) += a_spongeFactor(cellId) * deltaRho * fac * a_cellVolume(cellId);
        }

        IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
          for(MInt r = 0; r < m_noRansEquations; ++r) {
            a_rightHandSide(cellId, CV->RHO_NN[r]) +=
                a_spongeFactor(cellId) * deltaRho * a_pvariable(cellId, PV->NN[r]) * fac * a_cellVolume(cellId);
          }
        }
        // species
        for(MInt s = 0; s < m_noSpecies; s++)
          a_rightHandSide(cellId, CV->RHO_Y[s]) +=
              a_spongeFactor(cellId) * deltaRho * a_pvariable(cellId, PV->Y[s]) * fac * a_cellVolume(cellId);
      }
    }
  }
}


/** \brief Add external sources to the RHS for new-RungeKutta-scheme for moving boundaries
 *         differs from the base fv-version, as the runge-Kutta ordering is differently
 *         and otherwise the externalSource is not conservative!
   \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::applyExternalSource() {
  TRACE();

  if(m_RKStep == m_noRKSteps - 1) {
    // applying the complete source term at the last RK-step for conservation!
    // i.e. devide by RK-factor
    // this requires that the rhs0 is free of the old/current source term
    MFloat beta = 1 / m_RKalpha[m_RKStep - 1];
    for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
      if(!a_hasProperty(cellId, SolverCell::IsActive)) continue;
      for(MInt var = 0; var < CV->noVariables; var++) {
        a_rightHandSide(cellId, var) += beta * a_externalSource(cellId, var);
        if(std::isnan(a_externalSource(cellId, var))) {
          cerr << domainId() << " " << cellId << " " << var << " " << a_coordinate(cellId, 0) << " "
               << a_coordinate(cellId, 1) << " " << a_coordinate(cellId, nDim - 1) << " " << var << endl;
          mTerm(1, AT_, "External source is nan!");
        }
      }
    }
  } else {
    if(m_RKStep != 3) {
      // apply partial old/current source term to the rightHandSide
      // here a devision by the rk-Factor is not necessary as the same source term is
      // also applied to the rhs0
      for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
        if(!a_hasProperty(cellId, SolverCell::IsActive)) continue;
        for(MInt var = 0; var < CV->noVariables; var++) {
          a_rightHandSide(cellId, var) += a_externalSource(cellId, var);
        }
      }
    } else {
      // apply old external source
      for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
        if(!a_hasProperty(cellId, SolverCell::IsActive)) continue;
        for(MInt var = 0; var < CV->noVariables; var++) {
          a_rightHandSide(cellId, var) += m_externalSourceDt1[cellId][var];
        }
      }
    }
  }
}

/** \brief remove external sources from tho old RHS for new-RungeKutta-scheme for moving boundaries
   \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::applyExternalOldSource() {
  TRACE();

  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    if(!a_hasProperty(cellId, SolverCell::IsActive)) continue;
    for(MInt var = 0; var < CV->noVariables; var++) {
      m_rhs0[cellId][var] -= m_externalSourceDt1[cellId][var];
    }
  }
}

/** \brief advance external sources
   \author Tim Wegmann
 */

template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::advanceExternalSource() {
  if(!m_hasExternalSource) return;

  const MInt noCBytes = a_noCells() * m_noCVars * sizeof(MFloat);
  memcpy(&m_externalSourceDt1[0][0], &(a_externalSource(0, 0)), noCBytes);
}

/**
 * \brief update infinity state for certain testcases with constructed level-set field!
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::updateInfinityVariables() {
  TRACE();

  if(m_initialCondition == 22) { // If Pipe (case 22) change also IC in fvcartesiansolver
    MFloat noPeriodicDirs = 0;
    for(MInt dim = 0; dim < nDim; dim++) {
      if(grid().periodicCartesianDir(dim)) {
        m_volumeForcingDir = dim;
        noPeriodicDirs++;
      }
    }
    if(noPeriodicDirs > 1) mTerm(1, AT_, "Only one periodic direction is implemented for the pipe case");
    if(m_volumeForcingDir == -1) mTerm(-1, AT_, "IC 22 requires a volumeForcingDir");

    // Reynolds set in properties is based on unit length L=1
    MInt Re_r = Context::getSolverProperty<MFloat>("Re", m_solverId, AT_) * m_pipeRadius;
    m_pipeRadius = Context::getSolverProperty<MFloat>("pipeRadius", m_solverId, AT_);

    // Any other perpendicular direction indicates the pipe diameter
    const MInt rDir1 = ((m_volumeForcingDir + 1) % nDim);
    const MInt rDir2 = ((rDir1 + 1) % nDim);
    if(rDir1 == rDir2 || rDir1 == m_volumeForcingDir || rDir2 == m_volumeForcingDir)
      mTerm(-1, AT_, "Inconsistent dirs.");

    const MFloat pipeLength = computeDomainLength(m_volumeForcingDir);

    cerr0 << "Update infinity state for IC 22: found pipeRadius = " << m_pipeRadius
          << " and pipeLength = " << pipeLength << endl;

    MFloat lambda = F0;
    if(Re_r < 1500) {
      lambda = 32.0 / Re_r;
      if(domainId() == 0) cerr << "IC 22, using case Re<1500" << endl;
    } else {
      lambda = 0.316 / pow(Re_r * F2, 0.25);
      if(domainId() == 0) cerr << "IC 22, using case Re>=1500" << endl;
    }
    MFloat reTau = Re_r * sqrt(lambda / F8);
    MFloat uTau = reTau * m_Ma * sqrt(m_TInfinity) / Re_r;
    MFloat deltaP = F2 * m_rhoInfinity * POW2(uTau) * (pipeLength) / m_pipeRadius;
    m_volumeAcceleration[m_volumeForcingDir] = deltaP / (m_rhoInfinity * pipeLength);
  }

  // Not used in combination with the levelSet-solver!
  if(!m_constructGField) return;

  if(m_initialCondition == 15 || m_initialCondition == 16 || m_initialCondition == 467) {
    m_rhoInfinity = F1;
    m_TInfinity = F1;
    m_PInfinity = sysEqn().pressure_ES(m_TInfinity, m_rhoInfinity);
    m_UInfinity = m_Ma;
    m_VInfinity = F0;
    m_WInfinity = F0;

    m_rhoUInfinity = m_rhoInfinity * m_UInfinity;
    m_rhoVInfinity = m_rhoInfinity * m_VInfinity;
    m_rhoWInfinity = m_rhoInfinity * m_WInfinity;
    m_rhoEInfinity = sysEqn().internalEnergy(m_PInfinity, m_rhoInfinity, POW2(m_Ma));
    m_hInfinity = sysEqn().enthalpy(m_PInfinity, m_rhoInfinity);
    sysEqn().m_Re0 = m_Re * SUTHERLANDLAW(m_TInfinity) / (m_rhoInfinity * m_UInfinity);
    sysEqn().m_muInfinity = SUTHERLANDLAW(m_TInfinity);
    m_timeRef = m_Ma;
    m_VVInfinity[0] = m_UInfinity;
    m_VVInfinity[1] = m_VInfinity;
    m_VVInfinity[2] = m_WInfinity;
    m_rhoVVInfinity[0] = m_rhoUInfinity;
    m_rhoVVInfinity[1] = m_rhoVInfinity;
    m_rhoVVInfinity[2] = m_rhoWInfinity;

    if(m_restartFile) {
      m_log << "Restart Reynolds number: " << setprecision(15) << m_Re << " (Re_L=" << m_Re * (m_bbox[3] - m_bbox[0])
            << ")"
            << " " << sysEqn().m_Re0 << endl;
    }
  }

  if((m_initialCondition == 465 || m_initialCondition == 466) && m_constructGField) {
    m_rhoInfinity = F1;
    m_TInfinity = F1;
    m_PInfinity = sysEqn().pressure_ES(m_TInfinity, m_rhoInfinity);
    m_UInfinity = m_Ma;
    m_VInfinity = F0;
    m_WInfinity = F0;
    m_VVInfinity[0] = m_UInfinity;
    m_VVInfinity[1] = m_VInfinity;
    m_VVInfinity[2] = m_WInfinity;
    m_rhoUInfinity = m_rhoInfinity * m_UInfinity;
    m_rhoVInfinity = m_rhoInfinity * m_VInfinity;
    m_rhoWInfinity = m_rhoInfinity * m_WInfinity;
    m_rhoEInfinity = sysEqn().internalEnergy(m_PInfinity, m_rhoInfinity, POW2(m_Ma));
    m_hInfinity = sysEqn().enthalpy(m_PInfinity, m_rhoInfinity);
    sysEqn().m_Re0 = m_Re * SUTHERLANDLAW(m_TInfinity) / (m_rhoInfinity * m_UInfinity);
    m_timeRef = m_Ma;
  }


  m_U2 = F0;
  for(MInt i = 0; i < nDim; i++) {
    m_U2 += POW2(m_VVInfinity[i]);
  }
  m_rhoU2 = m_U2 * m_rhoInfinity;
}


/**
 * \brief temperature
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
inline MFloat FvMbCartesianSolverXD<nDim, SysEqn>::temperature(MInt cellId) {
  return sysEqn().temperature_ES(a_pvariable(cellId, PV->RHO), a_pvariable(cellId, PV->P));
}

/// \brief Reinitialize solver for DLB prior to setting solution data.
///
/// \author Jannik Borgelt
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::balancePre() {
  TRACE();

  FvCartesianSolverXD<nDim, SysEqn>::balancePre();
  // for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
  //   a_resetPropertiesSolver(cellId);
  // }


  // ToDo: currently untested
  if(isActive()) {
    IF_CONSTEXPR(SysEqn::m_noRansEquations == 0) {
      if(m_zonal) {
        mDeallocate(m_LESVarAverageBal);
        if(globalTimeStep >= m_zonalAveragingTimeStep) {
          mAlloc(m_LESVarAverageBal, m_LESNoVarAverage, "m_LESVarAverage", AT_);
          for(MInt var = 0; var < m_LESNoVarAverage; var++) {
            m_LESVarAverageBal[var].resize(noInternalCells());
          }
        }
      }
    }
  }

  // set only restart to true for the next initSolutionStep call!
  m_onlineRestart = true;

  if(!isActive()) {
    m_maxLevelBeforeAdaptation = -1;
  } else {
    m_maxLevelBeforeAdaptation = maxLevel();
  }

  mAlloc(m_sweptVolumeBal, c_noCells(), "m_sweptVolumeBal", -F1, AT_);
}


/// \brief Reinitialize solver after setting solution data in DLB.
///
/// \author Jannik Borgelt
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::balancePost() {
  TRACE();

  m_loadBalancingReinitStage = 1;

  // append the halo-cells
  m_cells.append(c_noCells() - m_cells.size());

  copyGridProperties();

  m_totalnoghostcells = 0;
  m_totalnosplitchilds = 0;
  ASSERT(m_cells.size() == c_noCells() && c_noCells() == a_noCells(), "");


  m_oldBndryCells.clear();
  std::map<MInt, std::vector<MFloat>>().swap(m_nearBoundaryBackup);
  std::vector<MInt>().swap(m_bndryLayerCells);
  std::vector<MInt>().swap(m_massRedistributionIds);
  std::vector<MFloat>().swap(m_massRedistributionVariables);
  std::vector<MFloat>().swap(m_massRedistributionRhs);
  std::vector<MFloat>().swap(m_massRedistributionVolume);
  std::vector<MFloat>().swap(m_massRedistributionSweptVol);
  std::vector<std::tuple<MInt, MInt, MInt>>().swap(m_temporarilyLinkedCells);
  mDeallocate(m_sendBufferSize);
  mDeallocate(m_receiveBufferSize);
  mDeallocate(g_mpiRequestMb);
  mDeallocate(m_linkedWindowCells);
  mDeallocate(m_linkedHaloCells);
  if(m_closeGaps) {
    mDeallocate(m_gapWindowCells);
    mDeallocate(m_gapHaloCells);
  }

  // Nothing to do if solver is not active
  if(!grid().isActive()) {
    return;
  }

  m_bndryGhostCellsOffset = a_noCells();
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    a_bndryId(cellId) = -1;
    a_isBndryGhostCell(cellId) = false;
    a_hasProperty(cellId, SolverCell::IsSplitChild) = false;
  }

  // this can only be done, after the halo property has been set above
  this->checkNoHaloLayers();

  // ### from c'tor ###
  // compute min and max coordinates in the grid
  computeDomainAndSpongeDimensions();
  // ###

  allocateCommunicationMemory();

  if(!m_fvBndryCnd->m_cellMerging) {
    mDeallocate(m_fvBndryCnd->m_nearBoundaryWindowCells);
    mDeallocate(m_fvBndryCnd->m_nearBoundaryHaloCells);
    mAlloc(m_fvBndryCnd->m_nearBoundaryWindowCells, noNeighborDomains(), "m_nearBoundaryWindowCells", AT_);
    mAlloc(m_fvBndryCnd->m_nearBoundaryHaloCells, noNeighborDomains(), "m_nearBoundaryHaloCells", AT_);
  }

  std::vector<MInt>().swap(m_splitCells);
  std::vector<std::vector<MInt>>().swap(m_splitChilds);
  std::map<MInt, MInt>().swap(m_splitChildToSplitCell);
  m_totalnosplitchilds = 0;

  // during the balance cells are sorted again
  if(this->m_adaptation) {
    for(MInt i = 0; i < maxNoGridCells(); i++)
      m_recalcIds[i] = i;
  }

  // Azimuthal Balance
  if(grid().azimuthalPeriodicity()) {
    m_azimuthalNearBoundaryBackup.clear();
    initAzimuthalCartesianHaloInterpolation();

    MInt noFloatData_ = nDim + m_noFloatDataBalance;
    MInt noLongData = m_azimuthalNearBoundaryBackupMaxCount * m_noLongDataBalance;
    MInt noFloatData = m_azimuthalNearBoundaryBackupMaxCount * noFloatData_;

    for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
      for(MInt cnt = 0; cnt < m_azimuthalNearBoundaryBackupMaxCount; cnt++) {
        MInt longIndex = cnt * m_noLongDataBalance;

        MLong gCellId = m_azimuthalNearBoundaryBackupBalLong[cellId * noLongData + longIndex];

        if(gCellId == -1) {
          continue;
        }

        ASSERT(gCellId == c_globalId(cellId), "Azimuthal balance, this is not correct. " + to_string(cellId) + " "
                                                  + to_string(c_globalId(cellId)) + " " + to_string(gCellId) + " "
                                                  + to_string(domainId()));

        MInt offset = cnt * noFloatData_;
        vector<MFloat> tmpF(noFloatData_);
        vector<MUlong> tmpI(m_noLongData);

        for(MInt d = offset; d < offset + noFloatData_; d++) {
          tmpF[d - offset] = m_azimuthalNearBoundaryBackupBalFloat[cellId * noFloatData + d];
        }

        tmpI[0] = (MUlong)m_azimuthalNearBoundaryBackupBalLong[cellId * noLongData + longIndex + 1];
        tmpI[1] = (MUlong)m_azimuthalNearBoundaryBackupBalLong[cellId * noLongData + longIndex + 2];

        m_azimuthalNearBoundaryBackup.insert(make_pair(gCellId, make_pair(tmpF, tmpI)));
      }
    }

    mDeallocate(m_azimuthalNearBoundaryBackupBalFloat);
    mDeallocate(m_azimuthalNearBoundaryBackupBalLong);

    m_wasBalanced = true;
  }

  exchangeData(&a_variable(0, 0), CV->noVariables);
  exchangeData(&a_cellVolume(0), 1);
  exchangeData(&a_rightHandSide(0, 0), m_noFVars);
  if(m_dualTimeStepping) {
    exchangeData(&m_cellVolumesDt1[0], 1);
  }
  // change this for proper splitBalance where only boundary data is exchanged
  exchangeData(&m_sweptVolumeBal[0], 1);

  // exchange properties that are of type MBool
  maia::mpi::exchangeBitset(grid().neighborDomains(), grid().haloCells(), grid().windowCells(), mpiComm(),
                            &a_properties(0), a_noCells());

  ScratchSpace<maia::fv::cell::BitsetType> propsBalance(a_noCells(), FUN_, "propsBalance");
  propsBalance.fill(maia::fv::cell::BitsetType());

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    setPrimitiveVariables(cellId);
    for(MInt v = 0; v < CV->noVariables; v++) {
      a_oldVariable(cellId, v) = a_variable(cellId, v);
    }
    a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
    propsBalance[cellId][maia::fv::cell::p(SolverCell::IsMovingBnd)] =
        a_properties(cellId)[maia::fv::cell::p(SolverCell::IsMovingBnd)];
    propsBalance[cellId][maia::fv::cell::p(SolverCell::NearWall)] =
        a_properties(cellId)[maia::fv::cell::p(SolverCell::NearWall)];
    propsBalance[cellId][maia::fv::cell::p(SolverCell::IsInactive)] =
        a_properties(cellId)[maia::fv::cell::p(SolverCell::IsInactive)];
    propsBalance[cellId][maia::fv::cell::p(SolverCell::WasInactive)] =
        a_properties(cellId)[maia::fv::cell::p(SolverCell::WasInactive)];
  }

  for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
    a_resetPropertiesSolver(cellId);
  }

  for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
    assertValidGridCellId(cellId);
    if(m_dualTimeStepping) {
      m_cellVolumesDt2[cellId] = m_cellVolumesDt1[cellId];
    }
    m_cellVolumesDt1[cellId] = a_cellVolume(cellId);
    for(MInt j = 0; j < m_noFVars; j++) {
      m_rhs0[cellId][j] = a_rightHandSide(cellId, j);
    }
    a_hasProperty(cellId, SolverCell::IsMovingBnd) = propsBalance[cellId][maia::fv::cell::p(SolverCell::IsMovingBnd)];
    a_hasProperty(cellId, SolverCell::NearWall) = propsBalance[cellId][maia::fv::cell::p(SolverCell::NearWall)];
    a_hasProperty(cellId, SolverCell::IsInactive) = propsBalance[cellId][maia::fv::cell::p(SolverCell::IsInactive)];
    a_hasProperty(cellId, SolverCell::WasInactive) = propsBalance[cellId][maia::fv::cell::p(SolverCell::IsInactive)];
  }

  for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
    if(a_hasProperty(cellId, SolverCell::NearWall)) {
      vector<MFloat> tmp(max(m_noCVars + m_noFVars, 0) + 1);
      tmp[0] = m_cellVolumesDt1[cellId];
      for(MInt v = 0; v < m_noCVars; v++) {
        tmp[1 + v] = a_oldVariable(cellId, v);
      }
      for(MInt v = 0; v < m_noFVars; v++) {
        tmp[1 + m_noCVars + v] = m_rhs0[cellId][v];
      }
      m_nearBoundaryBackup.insert(make_pair(cellId, tmp));
      m_bndryLayerCells.push_back(cellId);
    }
    // a_hasProperty(cellId, SolverCell::WasInactive) = a_hasProperty(cellId, SolverCell::IsInactive);
  }

  for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
    if(a_hasProperty(cellId, SolverCell::IsMovingBnd)) {
      // ASSERT( !a_hasProperty( cellId, SolverCell::IsInactive ), "" );
      ASSERT(m_sweptVolumeBal[cellId] > -1, "something is wrong with m_sweptVolumeBal");
      m_oldBndryCells.insert(make_pair(cellId, m_sweptVolumeBal[cellId]));
    }
  }

  if(grid().azimuthalPeriodicity()) {
    commAzimuthalPeriodicData(1);
  }


  // ToDo: currently untested
  if(m_zonal) {
    determineLESAverageCells();
    resetZonalLESAverage();
    resetZonalSolverData();

    IF_CONSTEXPR(SysEqn::m_noRansEquations == 0) {
      if(globalTimeStep >= m_zonalAveragingTimeStep) {
        for(MInt var = 0; var < m_LESNoVarAverage; var++) {
          // m_LESVarAverageBal[var].resize(c_noCells());
          MFloatScratchSpace exchangeLESVarAverageBal(c_noCells(), FUN_, "exchangeIsMovingBnd");
          for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
            exchangeLESVarAverageBal[cellId] = m_LESVarAverageBal[var][cellId];
          }
          exchangeData(&exchangeLESVarAverageBal[0], 1);
          for(MInt i = 0; i < (MInt)m_LESAverageCells.size(); i++) {
            MInt cellId = m_LESAverageCells[i];
            m_LESVarAverage[var][i] = exchangeLESVarAverageBal[cellId];
          }
        }
      }

      MInt cnt = (MInt)m_LESAverageCells.size();
      MPI_Allreduce(MPI_IN_PLACE, &cnt, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "cnt");
      if(domainId() == 0) cerr << "m_noLESAverageCells: " << cnt << endl;
    }
    // Deallocate memory again
    for(MInt var = 0; var < m_LESNoVarAverage; var++) {
      m_LESVarAverageBal[var].clear();
    }
    mDeallocate(m_LESVarAverageBal);
  }

  copyGridProperties();

#ifndef NDEBUG
  checkHaloCells();
#endif

  // reset additional data
  mAlloc(m_sendBufferSize, noNeighborDomains(), "m_sendBufferSize", 0, AT_);
  mAlloc(m_receiveBufferSize, noNeighborDomains(), "m_receiveBufferSize", 0, AT_);
  mAlloc(g_mpiRequestMb, noNeighborDomains(), "g_mpiRequestMb", MPI_REQ_NULL, AT_);
  mAlloc(m_linkedWindowCells, noNeighborDomains(), "m_linkedWindowCells", AT_);
  mAlloc(m_linkedHaloCells, noNeighborDomains(), "m_linkedHaloCells", AT_);

  for(MInt i = 0; i < noNeighborDomains(); i++) {
    m_linkedWindowCells[i].clear();
    m_linkedHaloCells[i].clear();
  }

  if(m_closeGaps) {
    mAlloc(m_gapWindowCells, noNeighborDomains(), "m_gapWindowCells", AT_);
    mAlloc(m_gapHaloCells, noNeighborDomains(), "m_gapHaloCells", AT_);
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      m_gapWindowCells[i].clear();
      m_gapHaloCells[i].clear();
    }
  }

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    m_cellVolumesDt1[cellId] = a_cellVolume(cellId);
  }

  computeLocalBoundingBox();

  ASSERT(m_cells.size() == c_noCells(), "");

  if(this->m_adaptation) {
    m_adaptationSinceLastRestart = true;
    m_adaptationSinceLastRestartBackup = true;
  }

  m_loadBalancingReinitStage = 2;

#if defined _MB_DEBUG_ || !defined NDEBUG
  if(domainId() == 0) {
    cerr << "Checking cells after balance... ";
  }
  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    for(MInt v = 0; v < CV->noVariables; v++) {
      if(std::isnan(a_variable(cellId, v)) && !a_hasProperty(cellId, SolverCell::IsInactive)) {
        cerr << "Nan in variable after balance " << cellId << " "
             << a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) << endl;
      }
    }
    if((a_variable(cellId, CV->RHO) < 0 || a_pvariable(cellId, PV->RHO) < 0)
       && !a_hasProperty(cellId, SolverCell::IsInactive)) {
      cerr << "Neg. density after balance" << cellId << endl;
    }
  }
  if(domainId() == 0) cerr << "finished. " << endl;
#endif
}


/**
 * \brief Balance the solver
 * \author Jerry Grimmen, Lennart Schneiders, Ansgar Niemoeller
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::balance(const MInt* const noCellsToReceiveByDomain,
                                                  const MInt* const noCellsToSendByDomain,
                                                  const MInt* const sortedCellId, const MInt oldNoCells) {
  TRACE();

  // set only restart to true for the next initSolutionStep call!
  m_onlineRestart = true;

  // additional data to the fv-solver to-be saved during the balancing:
  // if globalTimeStep < -1: nothing additionally
  // if globalTimeStep > -1:
  // - a_rightHandSide
  // - m_sweptVolume (in sweptVolBalance)
  // - a_properties (in propsBalance and later in propsBak)
  // if dualTimeStepping:
  // - m_cellVolumesDt1

  if(!isActive()) {
    grid().update();
    FvCartesianSolverXD<nDim, SysEqn>::updateDomainInfo(-1, -1, MPI_COMM_NULL, AT_);
    return;
  }

  MFloatScratchSpace RHS(noCellsToReceiveByDomain[noDomains()], CV->noVariables, FUN_, "RHS");
  MFloatScratchSpace cellVolumesDt1((m_dualTimeStepping ? noCellsToReceiveByDomain[noDomains()] : 1), FUN_,
                                    "cellVolumesDt1");
  ScratchSpace<maia::fv::cell::BitsetType> props(noCellsToReceiveByDomain[noDomains()], FUN_, "props");
  MFloatScratchSpace sweptVol(noCellsToReceiveByDomain[noDomains()], FUN_, "sweptVol");

  MBool azimuthal = grid().azimuthalPeriodicity();

  if(globalTimeStep > -1) {
    MFloatScratchSpace sweptVolBalance(oldNoCells, FUN_, "sweptVolBalance");
    ScratchSpace<maia::fv::cell::BitsetType> propsBalance(oldNoCells, FUN_, "propsBalance");
    MFloatScratchSpace rightHandSideBalance(oldNoCells, CV->noVariables, FUN_, "rightHandSideBalance");
    MFloatScratchSpace volumeDt1Balance(oldNoCells, FUN_, "volumeDt1Balance");

    sweptVolBalance.fill(std::numeric_limits<MFloat>::lowest());
    propsBalance.fill(maia::fv::cell::BitsetType());

    rightHandSideBalance.fill(-1);
    volumeDt1Balance.fill(-1);

    for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
      assertValidGridCellId(cellId);
      MInt gridCellId = grid().tree().solver2grid(cellId);

      propsBalance(gridCellId) = a_properties(cellId);

      for(MInt variable = 0; variable < CV->noVariables; variable++) {
        rightHandSideBalance(gridCellId, variable) = a_rightHandSide(cellId, variable);
      }
    }
    for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
      const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
      ASSERT(!a_isBndryGhostCell(cellId), "");
      if(a_isHalo(cellId)) continue;
      if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
      assertValidGridCellId(cellId);
      MInt gridCellId = grid().tree().solver2grid(cellId);
      // ASSERT( gridCellId < noCellsToSendByDomain[noDomains()], "" );
      ASSERT(a_hasProperty(cellId, SolverCell::IsMovingBnd), "");
      sweptVolBalance(gridCellId) = m_sweptVolume[bndryId];
    }

    if(m_dualTimeStepping) {
      for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
        MInt gridCellId = grid().tree().solver2grid(cellId);
        volumeDt1Balance(gridCellId) = m_cellVolumesDt1[cellId];
      }
    }


    // Azimuthal periodicity
    {
      MInt noAziDataToSend = 1;
      MInt noAziDataToReceive = 1;
      MIntScratchSpace sndSizeAzi(noDomains(), FUN_, "sndSizeAzi");
      sndSizeAzi.fill(0);
      MIntScratchSpace rcvSizeAzi(noDomains(), FUN_, "rcvSizeAzi");
      rcvSizeAzi.fill(0);
      MIntScratchSpace sortedIdMap(oldNoCells, FUN_, "sortedIdMap");
      sortedIdMap.fill(0);
      if(azimuthal) {
        m_wasBalanced = true;

        MIntScratchSpace sortedCntsAzi(oldNoCells, FUN_, "sortedCntsAzi");
        sortedCntsAzi.fill(0);
        for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
          MInt gridCellId = grid().tree().solver2grid(cellId);
          if(sortedCellId[gridCellId] < 0) continue;
          MLong gCellId = c_globalId(cellId);
          sortedCntsAzi[sortedCellId[gridCellId]] = m_azimuthalNearBoundaryBackup.count(gCellId);
        }
        MInt cnt = 0;
        for(MInt i = 0; i < oldNoCells; i++) {
          sortedIdMap[i] = cnt;
          cnt += sortedCntsAzi[i];
        }
        MInt offset = 0;
        for(MInt i = 0; i < noDomains(); i++) {
          for(MInt j = 0; j < noCellsToSendByDomain[i]; j++) {
            sndSizeAzi[i] += sortedCntsAzi[offset + j];
          }
          offset += noCellsToSendByDomain[i];
        }
        MIntScratchSpace dummyScratch(noDomains(), FUN_, "dummyScratch");
        dummyScratch.fill(1);
        maia::mpi::exchangeData(&sndSizeAzi[0], domainId(), noDomains(), mpiComm(), 1, &dummyScratch[0],
                                &dummyScratch[0], &rcvSizeAzi[0]);

        noAziDataToSend = mMax(1, std::accumulate(&sndSizeAzi[0], &sndSizeAzi[0] + noDomains(), 0));
        noAziDataToReceive = mMax(1, std::accumulate(&rcvSizeAzi[0], &rcvSizeAzi[0] + noDomains(), 0));
      }

      ScratchSpace<MLong> globalIdAzi(noAziDataToReceive, FUN_, "globalIdAzi");
      MFloatScratchSpace cellVolumesAzi(noAziDataToReceive, FUN_, "cellVolumesAzi");
      MFloatScratchSpace cellVolumesDt1Azi(noAziDataToReceive, FUN_, "cellVolumesDt1Azi");
      MFloatScratchSpace sweptVolAzi(noAziDataToReceive, FUN_, "sweptVolAzi");
      ScratchSpace<MUlong> bndryCntAzi(noAziDataToReceive, FUN_, "bndryCntAzi");
      ScratchSpace<MUlong> propsAzi(noAziDataToReceive, FUN_, "propsAzi");
      MFloatScratchSpace variablesAzi(noAziDataToReceive, CV->noVariables, FUN_, "variablesAzi");
      MFloatScratchSpace imageCoordsAzi(noAziDataToReceive, nDim, FUN_, "imageCoordsAzi");
      globalIdAzi.fill(-1);
      cellVolumesAzi.fill(-1.0);
      cellVolumesDt1Azi.fill(-1.0);
      sweptVolAzi.fill(std::numeric_limits<MFloat>::lowest());
      bndryCntAzi.fill(0);
      propsAzi.fill(0);
      variablesAzi.fill(-1.0);
      imageCoordsAzi.fill(-1.0);
      MLongScratchSpace globalIdAziBalance(noAziDataToSend, FUN_, "globalIdAziBalance");
      MFloatScratchSpace cellVolumesAziBalance(noAziDataToSend, FUN_, "cellVolumesAziBalance");
      MFloatScratchSpace cellVolumesDt1AziBalance(noAziDataToSend, FUN_, "cellVolumesDt1AziBalance");
      MFloatScratchSpace sweptVolAziBalance(noAziDataToSend, FUN_, "sweptVolAziBalance");
      ScratchSpace<MUlong> bndryCntAziBalance(noAziDataToSend, FUN_, "bndryCntAziBalance");
      ScratchSpace<MUlong> propsAziBalance(noAziDataToSend, FUN_, "propsAziBalance");
      MFloatScratchSpace variablesAziBalance(noAziDataToSend, CV->noVariables, FUN_, "variablesAziBalance");
      MFloatScratchSpace imageCoordsAziBalance(noAziDataToSend, nDim, FUN_, "imageCoordsAziAziBalance");
      globalIdAziBalance.fill(-1);
      cellVolumesAziBalance.fill(-1);
      cellVolumesDt1AziBalance.fill(-1);
      sweptVolAziBalance.fill(std::numeric_limits<MFloat>::lowest());
      bndryCntAziBalance.fill(0);
      propsAziBalance.fill(0);
      variablesAziBalance.fill(-1.0);
      imageCoordsAziBalance.fill(-1.0);

      if(azimuthal) {
        for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
          MInt gridCellId = grid().tree().solver2grid(cellId);
          if(sortedCellId[gridCellId] < 0) continue;
          MLong gCellId = c_globalId(cellId);
          if(m_azimuthalNearBoundaryBackup.count(gCellId) != 0) {
            MInt cnt = 0;
            auto range = m_azimuthalNearBoundaryBackup.equal_range(gCellId);
            for(auto it = range.first; it != range.second; ++it) {
              globalIdAziBalance(sortedIdMap[sortedCellId[gridCellId]] + cnt) = gCellId;
              cellVolumesAziBalance(sortedIdMap[sortedCellId[gridCellId]] + cnt) = (it->second).first[nDim];
              cellVolumesDt1AziBalance(sortedIdMap[sortedCellId[gridCellId]] + cnt) = (it->second).first[nDim + 1];
              sweptVolAziBalance(sortedIdMap[sortedCellId[gridCellId]] + cnt) = (it->second).first[nDim + 2];
              bndryCntAziBalance(sortedIdMap[sortedCellId[gridCellId]] + cnt) = (it->second).second[0];
              propsAziBalance(sortedIdMap[sortedCellId[gridCellId]] + cnt) = (it->second).second[1];
              for(MInt v = 0; v < CV->noVariables; v++) {
                variablesAziBalance(sortedIdMap[sortedCellId[gridCellId]] + cnt, v) = (it->second).first[nDim + 3 + v];
              }
              for(MInt d = 0; d < nDim; d++) {
                imageCoordsAziBalance(sortedIdMap[sortedCellId[gridCellId]] + cnt, d) = (it->second).first[d];
              }
              cnt++;
            }
          }
        }

        maia::mpi::exchangeData(&globalIdAziBalance[0], domainId(), noDomains(), mpiComm(), 1, &sndSizeAzi[0],
                                &rcvSizeAzi[0], &globalIdAzi[0]);
        maia::mpi::exchangeData(&cellVolumesAziBalance[0], domainId(), noDomains(), mpiComm(), 1, &sndSizeAzi[0],
                                &rcvSizeAzi[0], &cellVolumesAzi[0]);
        maia::mpi::exchangeData(&cellVolumesDt1AziBalance[0], domainId(), noDomains(), mpiComm(), 1, &sndSizeAzi[0],
                                &rcvSizeAzi[0], &cellVolumesDt1Azi[0]);
        maia::mpi::exchangeData(&sweptVolAziBalance[0], domainId(), noDomains(), mpiComm(), 1, &sndSizeAzi[0],
                                &rcvSizeAzi[0], &sweptVolAzi[0]);
        maia::mpi::exchangeData(&bndryCntAziBalance[0], domainId(), noDomains(), mpiComm(), 1, &sndSizeAzi[0],
                                &rcvSizeAzi[0], &bndryCntAzi[0]);
        maia::mpi::exchangeData(&propsAziBalance[0], domainId(), noDomains(), mpiComm(), 1, &sndSizeAzi[0],
                                &rcvSizeAzi[0], &propsAzi[0]);
        maia::mpi::exchangeData(&variablesAziBalance[0], domainId(), noDomains(), mpiComm(), CV->noVariables,
                                &sndSizeAzi[0], &rcvSizeAzi[0], &variablesAzi[0]);
        maia::mpi::exchangeData(&imageCoordsAziBalance[0], domainId(), noDomains(), mpiComm(), nDim, &sndSizeAzi[0],
                                &rcvSizeAzi[0], &imageCoordsAzi[0]);


        MInt offset = 0;
        m_azimuthalNearBoundaryBackup.clear();
        MInt noFloatData = nDim + sysEqn().CV->noVariables + 3;
        MInt noIntData = 2;
        for(MInt i = 0; i < noDomains(); i++) {
          for(MInt j = 0; j < rcvSizeAzi[i]; j++) {
            MInt ind = offset + j;
            MLong gCellId = globalIdAzi[ind];
            vector<MFloat> tmpF(mMax(noFloatData + nDim, nDim + 3));
            vector<MUlong> tmpI(noIntData);
            for(MInt d = 0; d < nDim; d++) {
              tmpF[d] = imageCoordsAzi(ind, d); // Image coordinate
            }
            tmpF[nDim] = cellVolumesAzi[ind];        // cellVol
            tmpF[nDim + 1] = cellVolumesDt1Azi[ind]; // cellVolDt1
            tmpF[nDim + 2] = sweptVolAzi[ind];       // sweptVol
            for(MInt v = 0; v < CV->noVariables; v++) {
              tmpF[nDim + 3 + v] = variablesAzi(ind, v);
            }

            tmpI[0] = bndryCntAzi[ind]; // oldBndryCnt
            tmpI[1] = propsAzi[ind];    // cell properties
            m_azimuthalNearBoundaryBackup.insert(make_pair(gCellId, make_pair(tmpF, tmpI)));
          }
          offset += rcvSizeAzi[i];
        }
      }
    }

    RHS.fill(-1.0);
    cellVolumesDt1.fill(-1.0);
    props.fill(maia::fv::cell::BitsetType());
    sweptVol.fill(std::numeric_limits<MFloat>::lowest());

    maia::mpi::communicateData(&rightHandSideBalance(0, 0), oldNoCells, sortedCellId, noDomains(), domainId(),
                               mpiComm(), noCellsToSendByDomain, noCellsToReceiveByDomain, CV->noVariables, &RHS[0]);
    if(m_dualTimeStepping) {
      maia::mpi::communicateData(&volumeDt1Balance[0], oldNoCells, sortedCellId, noDomains(), domainId(), mpiComm(),
                                 noCellsToSendByDomain, noCellsToReceiveByDomain, 1, &cellVolumesDt1[0]);
    }

    maia::mpi::communicateBitsetData(&propsBalance[0], oldNoCells, sortedCellId, noDomains(), domainId(), mpiComm(),
                                     noCellsToSendByDomain, noCellsToReceiveByDomain, 1, &props[0]);
    maia::mpi::communicateData(&sweptVolBalance[0], oldNoCells, sortedCellId, noDomains(), domainId(), mpiComm(),
                               noCellsToSendByDomain, noCellsToReceiveByDomain, 1, &sweptVol[0]);

#ifndef NDEBUG
    // Timw: avoided as bndryCells exist which are inactive and notMovingBand
    //      if during cutCell-computation no valid surfaces can be found!
    /*
    {
      MIntScratchSpace nbTest(m_cells.size(), 2, FUN_, "nbTest");
      nbTest.fill(0);
      for( MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++ ) {
        MInt cellId = m_fvBndryCnd->m_bndryCells->a[ bndryId ].m_cellId;
        //if ( a_isHalo(cellId) ) continue;
        if ( !a_hasProperty(cellId, SolverCell::IsSplitChild) ) {
          ASSERT( cellId > -1 && cellId < oldNoCells, "" );
        }
        ASSERT( a_hasProperty( cellId, SolverCell::IsMovingBnd ), "" );
        nbTest( cellId, 0 ) = 1;
      }
      for ( MUint c = 0; c < m_bndryLayerCells.size(); c++ ) {
        const MInt cellId = m_bndryLayerCells[ c ];
        //if ( a_isHalo(cellId) ) continue;
        //if ( a_hasProperty(cellId, SolverCell::IsSplitChild) ) continue;
        nbTest( cellId, 1 ) = 1;
      }
      for ( MInt cellId = 0; cellId < a_noCells(); cellId++ ) {
        //if ( a_isHalo(cellId) ) continue;
        //if ( a_hasProperty(cellId, SolverCell::IsSplitChild) ) continue;
        if ( nbTest(cellId, 0) != (MInt)a_hasProperty( cellId, SolverCell::IsMovingBnd ) )
          cerr << cellId << " " << oldNoCells << " " << a_hasProperty(cellId, SolverCell::IsSplitChild) << " " <<
    nbTest(cellId, 0) << " " << nbTest(cellId, 1)
               << " " << (MInt)a_hasProperty( cellId, SolverCell::IsMovingBnd ) << " " << a_isHalo( cellId) << endl;
        ASSERT( nbTest(cellId, 0) == (MInt)a_hasProperty( cellId, SolverCell::IsMovingBnd ), to_string(nbTest(cellId,
    0))+" "+to_string(nbTest(cellId, 1))
                +" "+to_string((MInt)a_hasProperty( cellId, SolverCell::IsMovingBnd )) );
        ASSERT( nbTest(cellId, 1) == (MInt)a_hasProperty( cellId, SolverCell::NearWall ), to_string(nbTest(cellId, 1))
                +" "+to_string((MInt)a_hasProperty( cellId, SolverCell::NearWall )) );
        if ( a_hasProperty( cellId, SolverCell::IsMovingBnd ) ) ASSERT( m_oldBndryCells.count(cellId) == 1, "" );
      }
    }
    */
#endif
  }

  FvCartesianSolverXD<nDim, SysEqn>::balance(noCellsToReceiveByDomain, noCellsToSendByDomain, sortedCellId, oldNoCells);

  ASSERT(m_cells.size() == c_noCells(), "");

  if(globalTimeStep > -1) {
    MFloatScratchSpace sweptVolBak(a_noCells(), FUN_, "sweptVolBak");
    ScratchSpace<maia::fv::cell::BitsetType> propsBak(a_noCells(), FUN_, "propsBak");

    sweptVolBak.fill(std::numeric_limits<MFloat>::lowest());
    propsBak.fill(maia::fv::cell::BitsetType());

    // Step 1: set properties for all Internal-Cells

    // Iterate over all received cells (already sorted by global id)
    MInt cnt = 0;
    for(MInt gridCellId = 0; gridCellId < noCellsToReceiveByDomain[noDomains()]; gridCellId++) {
      if(!grid().raw().treeb().solver(gridCellId, m_solverId)) continue;

      MInt cellId = cnt;

      if(!grid().raw().bitOffset()) {
        ASSERT(grid().tree().solver2grid(cellId) == gridCellId, "");
      }

      // Set solver data
      for(MInt j = 0; j < CV->noVariables; j++) {
        a_rightHandSide(cellId, j) = RHS(gridCellId, j);
      }
      if(m_dualTimeStepping) {
        m_cellVolumesDt1[cellId] = cellVolumesDt1(gridCellId);
      }
      assertValidGridCellId(cellId);

      sweptVolBak(cellId) = sweptVol(gridCellId);
      propsBak(cellId) = props(gridCellId);

      cnt++;
    }

    // Step 2: exchange additiondal properties

    maia::mpi::exchangeBitset(grid().neighborDomains(), grid().haloCells(), grid().windowCells(), mpiComm(),
                              &propsBak[0], m_cells.size());
    exchangeData(&a_rightHandSide(0, 0), CV->noVariables);
    exchangeData(&sweptVolBak[0], 1);
    if(m_dualTimeStepping) {
      exchangeData(&m_cellVolumesDt1[0], 1);
    }

    // Step 3: set additional properties for all cells (also for ghost-cells)

    for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
      assertValidGridCellId(cellId);
      if(m_dualTimeStepping) {
        m_cellVolumesDt2[cellId] = m_cellVolumesDt1[cellId];
      }
      m_cellVolumesDt1[cellId] = a_cellVolume(cellId);
      for(MInt j = 0; j < CV->noVariables; j++) {
        m_rhs0[cellId][j] = a_rightHandSide(cellId, j);
      }
      a_hasProperty(cellId, SolverCell::IsMovingBnd) = propsBak[cellId][maia::fv::cell::p(SolverCell::IsMovingBnd)];
      a_hasProperty(cellId, SolverCell::NearWall) = propsBak[cellId][maia::fv::cell::p(SolverCell::NearWall)];
      a_hasProperty(cellId, SolverCell::IsInactive) = propsBak[cellId][maia::fv::cell::p(SolverCell::IsInactive)];
      a_hasProperty(cellId, SolverCell::WasInactive) = a_hasProperty(cellId, SolverCell::IsInactive);
    }

#ifndef NDEBUG
    checkHaloCells();
#endif

    m_nearBoundaryBackup.clear();
    m_bndryLayerCells.clear();
    for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
      if(a_hasProperty(cellId, SolverCell::NearWall)) {
        vector<MFloat> tmp(max(m_noCVars + m_noFVars, 0) + 1);
        tmp[0] = m_cellVolumesDt1[cellId];
        for(MInt v = 0; v < m_noCVars; v++) {
          tmp[1 + v] = a_oldVariable(cellId, v);
        }
        for(MInt v = 0; v < m_noFVars; v++) {
          tmp[1 + m_noCVars + v] = m_rhs0[cellId][v];
        }
        m_nearBoundaryBackup.insert(make_pair(cellId, tmp));
        m_bndryLayerCells.push_back(cellId);
      }
    }

    m_oldBndryCells.clear();
    for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
      if(a_hasProperty(cellId, SolverCell::IsMovingBnd)) {
        // ASSERT( !a_hasProperty( cellId, SolverCell::IsInactive ), "" );
        m_oldBndryCells.insert(make_pair(cellId, sweptVolBak[cellId]));
      }
    }

    if(azimuthal) {
      initAzimuthalCartesianHaloInterpolation();
      commAzimuthalPeriodicData(1);
    }
  }

  mDeallocate(m_sendBufferSize);
  mDeallocate(m_receiveBufferSize);
  mDeallocate(g_mpiRequestMb);
  mDeallocate(m_linkedWindowCells);
  mDeallocate(m_linkedHaloCells);
  mAlloc(m_sendBufferSize, noNeighborDomains(), "m_sendBufferSize", 0, AT_);
  mAlloc(m_receiveBufferSize, noNeighborDomains(), "m_receiveBufferSize", 0, AT_);
  mAlloc(g_mpiRequestMb, noNeighborDomains(), "g_mpiRequestMb", MPI_REQ_NULL, AT_);
  mAlloc(m_linkedWindowCells, noNeighborDomains(), "m_linkedWindowCells", AT_);
  mAlloc(m_linkedHaloCells, noNeighborDomains(), "m_linkedHaloCells", AT_);


  for(MInt i = 0; i < noNeighborDomains(); i++) {
    m_linkedWindowCells[i].clear();
    m_linkedHaloCells[i].clear();
    // m_fvBndryCnd->m_nearBoundaryWindowCells[i].clear();
    // m_fvBndryCnd->m_nearBoundaryHaloCells[i].clear();
  }

  if(m_closeGaps) {
    mDeallocate(m_gapWindowCells);
    mDeallocate(m_gapHaloCells);
    mAlloc(m_gapWindowCells, noNeighborDomains(), "m_gapWindowCells", AT_);
    mAlloc(m_gapHaloCells, noNeighborDomains(), "m_gapHaloCells", AT_);
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      m_gapWindowCells[i].clear();
      m_gapHaloCells[i].clear();
    }
  }

  m_massRedistributionIds.clear();
  m_massRedistributionVariables.clear();
  m_massRedistributionRhs.clear();
  m_massRedistributionVolume.clear();
  m_massRedistributionSweptVol.clear();
  m_temporarilyLinkedCells.clear();

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    m_cellVolumesDt1[cellId] = a_cellVolume(cellId);
  }

  computeLocalBoundingBox();

  if(azimuthal) {
    initAzimuthalCartesianHaloInterpolation();
  }

  ASSERT(m_cells.size() == c_noCells(), "");

  // check-Cells:

#if defined _MB_DEBUG_ || !defined NDEBUG
  if(domainId() == 0) {
    cerr << "Checking cells after balance... ";
  }
  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    for(MInt v = 0; v < CV->noVariables; v++) {
      if(std::isnan(a_variable(cellId, v)) && !a_hasProperty(cellId, SolverCell::IsInactive)
         && a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        cerr << "Nan in variable after balance " << cellId << " "
             << a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) << endl;
      }
    }
    if((a_variable(cellId, CV->RHO) < 0 || a_pvariable(cellId, PV->RHO) < 0)
       && !a_hasProperty(cellId, SolverCell::IsInactive)) {
      cerr << "Neg. density after balance" << cellId << endl;
    }
  }
  cerr0 << "finished. " << endl;
#endif
}


/// \brief Reinitialize solver after all data structures have been recreated
/// \author Tim Wegmann
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::finalizeBalance() {
  TRACE();

  mDeallocate(m_sweptVolumeBal);

  FvCartesianSolverXD<nDim, SysEqn>::finalizeBalance();

  if(!grid().isActive()) {
    return;
  }

  setRungeKuttaFunctionPointer();

  if(globalTimeStep > 0) {
    if(!m_trackMovingBndry) {
      m_fvBndryCnd->m_cellCoordinatesCorrected = false;
      // necessary to recreate bndryCells after balance
      // if otherwise returning from reInitSolutionStep!!
      // TODO labels:FVMB,totest check mode 2, probably best to use mode 0 just after adaptation!
      preSolutionStep(0);
      // preSolutionStep(2);
    }
    leastSquaresReconstruction(); // Update slopes
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::refineCell(const MInt gridCellId) {
  FvCartesianSolverXD<nDim, SysEqn>::refineCell(gridCellId);

  ASSERT(grid().raw().a_hasProperty(gridCellId, Cell::WasRefined), "");

  const MInt childLevel = grid().raw().a_level(gridCellId) + 1;
  const MFloat childVolume = grid().cellVolumeAtLevel(childLevel);

  const MInt solverCellId = grid().tree().grid2solver(gridCellId);

  if(!g_multiSolverGrid) ASSERT(solverCellId == gridCellId, "");

  if(solverCellId < 0) return;

  // the fv-solver part has already added the cell to the solver!
  ASSERT(c_noChildren(solverCellId) > 0, "");

  MInt noAddedChilds = 0;

  for(MInt c = 0; c < grid().m_maxNoChilds; c++) {
    const MInt gridChildId = grid().raw().a_childId(gridCellId, c);

    if(gridChildId < 0) continue;

    // Skip if cell is a partition level ancestor and its child was not newly created
    if(!grid().raw().a_hasProperty(gridChildId, Cell::WasNewlyCreated)
       && grid().raw().a_hasProperty(gridCellId, Cell::IsPartLvlAncestor)) {
      continue;
    }

    const MInt solverChildId = grid().tree().grid2solver(gridChildId);

    if(solverChildId < 0) continue;

    ASSERT(solverChildId == c_childId(solverCellId, c), "");
    noAddedChilds++;

    for(MInt v = 0; v < m_noFVars; v++) {
      m_rhs0[solverChildId][v] = FFPOW2(nDim) * m_rhs0[solverCellId][v];
    }

    for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
      a_levelSetValuesMb(solverChildId, set) = a_levelSetValuesMb(solverCellId, set);
      a_associatedBodyIds(solverChildId, set) = a_associatedBodyIds(solverCellId, set);
    }
    m_cellVolumesDt1[solverChildId] = childVolume;
    if(m_dualTimeStepping) m_cellVolumesDt2[solverChildId] = childVolume;

    a_isGapCell(solverChildId) = a_isGapCell(solverCellId);
    a_wasGapCell(solverChildId) = a_wasGapCell(solverCellId);

    a_hasProperty(solverChildId, SolverCell::WasInactive) = a_hasProperty(solverCellId, SolverCell::WasInactive);

    // if a solverCell is oldBndryCell, all childs are set aswell
    // the childs will be corrected later!
    // parenta are remaining, to identify the just added cells after the adaptation
    auto it = m_oldBndryCells.find(solverCellId);
    if(it != m_oldBndryCells.end()) {
      const MFloat sweptVol = it->second;
      m_oldBndryCells.insert(make_pair(solverChildId, sweptVol));
      ASSERT(m_bndryLevelJumps, "");
    }

    if(grid().azimuthalPeriodicity()) {
      // TODO
    }
  }

  if(noAddedChilds > 0) {
    a_isGapCell(solverCellId) = false;
    a_wasGapCell(solverCellId) = false;
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::removeChilds(const MInt gridCellId) {
  const MInt solverCellId = grid().tree().grid2solver(gridCellId);
  ASSERT(solverCellId > -1 && solverCellId < m_cells.size(), "");

  if(!g_multiSolverGrid) {
    ASSERT(solverCellId == gridCellId, "");
    ASSERT((m_cells.size() - grid().raw().treeb().size()) <= grid().m_maxNoChilds, "");
  }

  ASSERT(grid().raw().a_noChildren(gridCellId) > 0, "");

  // reset the solverCell-properties for the new leaf-cell:
  //- cellVolumeDt1
  //- oldVariable  (this time with Dt1-volume!)
  //- rhs0
  m_cellVolumesDt1[solverCellId] = F0;
  for(MInt v = 0; v < m_noCVars; v++) {
    a_oldVariable(solverCellId, v) = F0;
  }
  for(MInt v = 0; v < m_noFVars; v++) {
    m_rhs0[solverCellId][v] = F0;
  }
  // reset solverCell-properties
  a_hasProperty(solverCellId, SolverCell::WasInactive) = false;

  MBool wasGapCell = false;
  MBool isGapCell = false;
  MBool hasBndryCell = false;
  MFloat sweptVol = 0;

  MInt wasInactive = 0;
  MInt noRemovedChilds = 0;

  for(MInt c = 0; c < grid().m_maxNoChilds; c++) {
    const MInt gridChildId = grid().raw().a_childId(gridCellId, c);
    const MInt childId = c_childId(solverCellId, c);
    if(childId < 0) continue;
    noRemovedChilds++;

    ASSERT(grid().tree().solver2grid(childId) == gridChildId, "");

    if(!g_multiSolverGrid) ASSERT(childId == gridChildId, "");

    if(a_wasGapCell(childId)) wasGapCell = true;
    if(a_isGapCell(childId)) isGapCell = true;

    if(a_hasProperty(childId, SolverCell::WasInactive)) {
      wasInactive++;
    } else {
      MFloat vol1 = m_cellVolumesDt1[childId];
      m_cellVolumesDt1[solverCellId] += vol1;
      for(MInt v = 0; v < m_noCVars; v++) {
        a_oldVariable(solverCellId, v) += vol1 * a_oldVariable(childId, v);
      }
      for(MInt v = 0; v < m_noFVars; v++) {
        m_rhs0[solverCellId][v] += m_rhs0[childId][v];
      }
    }

    {
      auto it = m_oldBndryCells.find(childId);
      if(it != m_oldBndryCells.end()) {
        hasBndryCell = true;
        sweptVol += it->second;
        ASSERT(!a_hasProperty(childId, SolverCell::WasInactive) || m_maxLevelDecrease, "");
        m_oldBndryCells.erase(it);
        ASSERT(m_bndryLevelJumps, "");
      }
    }
    {
      auto it = m_nearBoundaryBackup.find(childId);
      if(it != m_nearBoundaryBackup.end()) {
        m_nearBoundaryBackup.erase(it);
      }
    }

    if(grid().azimuthalPeriodicity()) {
      // TODO
    }
  }

  // update variables and properties for the new leaf-cell:
  if(wasInactive == noRemovedChilds) {
    a_hasProperty(solverCellId, SolverCell::WasInactive) = true;

    // if of all childs were inactive, default variables are set!
    m_cellVolumesDt1[solverCellId] = grid().gridCellVolume(a_level(solverCellId));
    for(MInt v = 0; v < m_noFVars; v++) {
      m_rhs0[solverCellId][v] = 0;
    }

    a_oldVariable(solverCellId, CV->RHO) = m_rhoInfinity;
    a_oldVariable(solverCellId, CV->RHO_E) = m_rhoEInfinity;
    for(MInt dir = 0; dir < nDim; dir++) {
      a_oldVariable(solverCellId, CV->RHO_VV[dir]) = m_rhoVVInfinity[dir];
    }

  } else {
    for(MInt v = 0; v < m_noCVars; v++) {
      a_oldVariable(solverCellId, v) /= mMax(m_volumeThreshold, m_cellVolumesDt1[solverCellId]);
    }
  }

  if(wasGapCell) a_wasGapCell(solverCellId) = true;
  if(isGapCell) a_isGapCell(solverCellId) = true;
  // NOTE: insert new bndryCells to coarseOldBndryCell sorted vector and
  // update according to current sweptVolume (see correctCoarseBndryCellVolume)
  // if they remain a bndryCell
  if(hasBndryCell) {
    m_coarseOldBndryCells.insert(solverCellId);
    m_oldBndryCells.insert(make_pair(solverCellId, sweptVol));
  }

  // call removeChilds at the end, otherwise link to children is already invalidated!
  FvCartesianSolverXD<nDim, SysEqn>::removeChilds(gridCellId);

  // only single-solver!
  if(!g_multiSolverGrid) ASSERT((m_cells.size() - grid().raw().treeb().size()) <= grid().m_maxNoChilds, "");
}


/**
 * \brief
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
MBool FvMbCartesianSolverXD<nDim, SysEqn>::adaptationTrigger() {
  TRACE();

  MBool forceAdaptation = false;

  if(m_engineSetup) {
    static const MInt cadInterval = 5;

    const MInt cad = this->crankAngle(m_physicalTime, 0);
    const MInt cad_dt1 = this->crankAngle(m_physicalTime - timeStep(), 0);

    if(cad % cadInterval == 0 && cad_dt1 % cadInterval != 0) {
      forceAdaptation = true;
      if(domainId() == 0) {
        cerr << " FvMb-Solver is forcing a mesh-adaptation at time step " << globalTimeStep << endl;
      }
    }
  }

  if(m_forceAdaptation) {
    forceAdaptation = true;
    m_forceAdaptation = false;
  }

  return forceAdaptation;
}


/**
 * \brief
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::prepareAdaptation() {
  TRACE();

  if(!isActive()) return;

  if(globalTimeStep > 0) {
    // update the time and construct new GField before the adaptation
    advanceTimeStep();
    if(m_constructGField) {
      constructGFieldPredictor();
    } else if(!m_LsMovement) {
      updateBodyProperties();
    }
    ASSERT(m_structureStep == 0, "");

    resetSolverMb();
    setLevelSetMbCellProperties();

    if(grid().azimuthalPeriodicity()) {
      storeAzimuthalPeriodicData();
    }

    {
      // does halo info need to be recovered after adaptation?
      auto oldBndryCellsBak(m_oldBndryCells);
      m_oldBndryCells.clear();
      for(auto it = oldBndryCellsBak.begin(); it != oldBndryCellsBak.end(); ++it) {
        if(it->first >= noInternalCells()) continue;
        ASSERT(!a_isHalo(it->first), "");
        m_oldBndryCells.insert(*it);
      }
    }

    {
      // does halo info need to be recovered after adaptation?
      auto nearBoundaryBackupBak(m_nearBoundaryBackup);
      m_nearBoundaryBackup.clear();
      for(auto it = nearBoundaryBackupBak.begin(); it != nearBoundaryBackupBak.end(); ++it) {
        if(it->first >= noInternalCells()) continue;
        ASSERT(!a_isHalo(it->first), "");
        m_nearBoundaryBackup.insert(*it);
      }
    }
  }

  m_coarseOldBndryCells.clear();

  FvCartesianSolverXD<nDim, SysEqn>::prepareAdaptation();
}


/**
 * \brief
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::setSensors(std::vector<std::vector<MFloat>>& sensors,
                                                     std::vector<MFloat>& sensorWeight,
                                                     std::vector<std::bitset<64>>& sensorCellFlag,
                                                     std::vector<MInt>& sensorSolverId) {
  if(globalTimeStep < 0 && m_constructGField && m_bodyTypeMb) {
    constructGField();
  }

  const auto sensorOffset = (signed)sensors.size();
  FvCartesianSolverXD<nDim, SysEqn>::setSensors(sensors, sensorWeight, sensorCellFlag, sensorSolverId);

  // ensure only a single-level change during an adaptation run at the bndry!
  // use an additional adaptation after some time steps to ensure smooth transition
  if(m_bndryLevelJumps && (maxRefinementLevel() - m_lsCutCellMinLevel > 1)) {
    // prevent coarsening of bndry-cells by more than 1 level
    for(auto it = m_coarseOldBndryCells.begin(); it != m_coarseOldBndryCells.end(); it++) {
      const MInt cellId = *it;
      const MInt gridId = grid().tree().solver2grid(cellId);
      for(MInt s = 0; s < this->m_noSensors; s++) {
        sensorCellFlag[gridId][sensorOffset + s] = false;
        sensors[sensorOffset + s][gridId] = 0.0;
      }
      const MInt parentId = c_parentId(cellId);
      if(parentId < 0) continue;
      const MInt gridParent = grid().tree().solver2grid(parentId);
      sensorCellFlag[gridParent][sensorOffset] = true;
      sensors[sensorOffset][gridParent] = 1.0;
    }
    // prevent refinement of bndry-cells by more than 1 level
    for(auto it = m_oldBndryCells.begin(); it != m_oldBndryCells.end(); it++) {
      const MInt cellId = it->first;
      if(c_isLeafCell(cellId)) continue;
      for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
        const MInt child = c_childId(cellId, childId);
        if(child < 0) continue;
        const MInt gridId = grid().tree().solver2grid(child);
        for(MInt s = 0; s < this->m_noSensors; s++) {
          sensorCellFlag[gridId][sensorOffset + s] = false;
          sensors[sensorOffset + s][gridId] = 0.0;
        }
      }
    }
  }
}


/**
 * \brief
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::postAdaptation() {
  FvCartesianSolverXD<nDim, SysEqn>::postAdaptation();

  if(grid().azimuthalPeriodicity()) {
    initAzimuthalCartesianHaloInterpolation();
    this->exchangeAzimuthalPer(&(a_levelSetValuesMb(0, 0)), m_noLevelSetsUsedForMb);
  }
}


/**
 * \brief
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::finalizeAdaptation() {
  // set onlineRestart to false for the next initSolutionStep call!
  m_onlineRestart = false;

  if(isActive()) {
    if(maxLevel() != maxRefinementLevel()) {
      if(domainId() == 0) {
        cerr << "MaxLevel is " << maxLevel() << " and maxRefinementLevel is " << maxRefinementLevel() << endl;
      }
    }

    if(m_maxLevelChange && maxLevel() == maxRefinementLevel()) {
      m_maxLevelChange = false;
      m_lsCutCellMinLevel = maxLevel();
      m_bndryLevelJumps = false;
      if(domainId() == 0) {
        cerr << "MaxLevel reached maxRefinementLevel! " << endl;
      }
    }
  }

  FvCartesianSolverXD<nDim, SysEqn>::finalizeAdaptation();

  if(globalTimeStep < 0) return;
  if(!isActive()) return;

  MFloatScratchSpace oldBCData(a_noCells(), 5, AT_, "oldBCData");
  oldBCData.fill(std::numeric_limits<MFloat>::lowest());

  exchangeData(&a_cellVolume(0), 1);
  exchangeData(&m_cellVolumesDt1[0], 1);

  // Correction for refined oldBndryCells:
  //- add oldBndryCells which are refined to refOldBndryCells and
  //- remove them from oldBndryCells!
  //- remove further entries (of cells which are uncut or inactive) in correctRefinedBndryCell!
  //- correct the swept/old Volume of the remaining bndryCells in correctRefinedBndryCellVolume
  // Correction for coarsened oldBndryCells:
  //- identify cells as they are marked with -99 sweptVolume
  //- correct the swept/old volume in correctCoarseBndryCellsVolume
  m_refOldBndryCells.clear();
  vector<MInt> deletedBndryCells;
  // const MInt noBndryLevelJumps = maxRefinementLevel() - m_lsCutCellMinLevel;
  for(auto it = m_oldBndryCells.begin(); it != m_oldBndryCells.end(); it++) {
    const MInt cellId = it->first;
    ASSERT(!a_isHalo(cellId), "");
    const MFloat sweptVol = it->second;
    if(!c_isLeafCell(cellId)) {
      deletedBndryCells.push_back(cellId);
      for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
        const MInt child = c_childId(cellId, childId);
        if(child < 0) continue;
        if(!c_isLeafCell(child)) {
          cerr << "Cell is " << c_globalId(child) << " " << c_coordinate(child, 0) << " " << c_coordinate(child, 1)
               << " " << c_coordinate(child, nDim - 1) << " parent " << c_globalId(cellId) << " "
               << c_coordinate(cellId, 0) << " " << c_coordinate(cellId, 1) << " " << c_coordinate(cellId, nDim - 1)
               << endl;
          mTerm(1, AT_, "Multiple-levell changes in a bndry-cells not supported yet!");
        }
        m_refOldBndryCells.push_back(child);
        oldBCData(child, 0) = 2;
      }
      /*} else {
        vector<MInt> leafChildIds;
        grid().getAllLeafChilds(cellId, leafChildIds);
        ASSERT(!leafChildIds.empty(), "");
        for(MUint i = 0; i < leafChildIds.size(); i++) {
          const MInt child = leafChildIds[i];
          ASSERT(c_isLeafCell(child), "");
          m_refOldBndryCells.push_back(child);
          oldBCData(child, 0) = 2;
        }

      } */
    } else {
      auto it1 = m_coarseOldBndryCells.find(cellId);
      if(it1 != m_coarseOldBndryCells.end()) {
        oldBCData(cellId, 0) = 3;
      }
      if(oldBCData(cellId, 0) < F0) {
        oldBCData(cellId, 0) = 1;
      }
      oldBCData(cellId, 1) = sweptVol;
    }
  }

  for(MInt i = 0; i < (signed)deletedBndryCells.size(); i++) {
    const MInt cellId = deletedBndryCells[i];
    auto it = m_oldBndryCells.find(cellId);
    m_oldBndryCells.erase(it);
    ASSERT(!c_isLeafCell(cellId), "");
    ASSERT(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel), "");
  }

  for(auto it = m_nearBoundaryBackup.begin(); it != m_nearBoundaryBackup.end(); it++) {
    const MInt cellId = it->first;
    ASSERT(!a_isHalo(cellId), to_string(a_isHalo(cellId)));
    oldBCData(cellId, 2) = F1;
  }

  // set wasInactive/wasGapCell for halo-Cells
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    for(MInt j = 0; j < noWindowCells(i); j++) {
      const MInt cellId = windowCellId(i, j);
      oldBCData(cellId, 3) = (MFloat)a_hasProperty(cellId, SolverCell::WasInactive);
      oldBCData(cellId, 4) = (MFloat)a_hasProperty(cellId, SolverCell::WasGapCell);
    }
  }

  exchangeData(&oldBCData[0], 5);

  // add halo-Cells to oldBndryCell and nearBoundaryBackup
  // and set wasInactive and wasGapCell
  for(MInt cellId = noInternalCells(); cellId < c_noCells(); cellId++) {
    ASSERT(a_isHalo(cellId), "");

    setConservativeVariables(cellId);
    for(MInt v = 0; v < m_noCVars; v++) {
      a_oldVariable(cellId, v) = a_variable(cellId, v);
    }
    if(oldBCData(cellId, 3) > -1) {
      a_hasProperty(cellId, SolverCell::WasInactive) = (MInt)oldBCData(cellId, 3);
    }
    if(oldBCData(cellId, 4) > -1) {
      a_hasProperty(cellId, SolverCell::WasGapCell) = (MInt)oldBCData(cellId, 4);
    }

    if((MInt)oldBCData(cellId, 0) > F0) {
      ASSERT(c_isLeafCell(cellId), "");
      m_oldBndryCells.insert(make_pair(cellId, oldBCData(cellId, 1)));
      if((MInt)oldBCData(cellId, 0) == 2) {
        m_refOldBndryCells.push_back(cellId);
      } else if((MInt)oldBCData(cellId, 0) == 3) {
        m_coarseOldBndryCells.insert(cellId);
      }
    }
    if(oldBCData(cellId, 2) > F0) {
      vector<MFloat> tmp(max(m_noCVars + m_noFVars, 0) + 1);
      tmp[0] = m_cellVolumesDt1[cellId];
      for(MInt v = 0; v < m_noCVars; v++) {
        tmp[1 + v] = std::numeric_limits<MFloat>::lowest();
      }
      for(MInt v = 0; v < m_noFVars; v++) {
        tmp[1 + m_noCVars + v] = std::numeric_limits<MFloat>::lowest();
      }
      m_nearBoundaryBackup.insert(make_pair(cellId, tmp));
    }
  }

  // Comm data back from window rank
  if(grid().azimuthalPeriodicity()) {
    commAzimuthalPeriodicData();
  }

  m_surfaces.size(m_initialSurfacesOffset); //!! undo addboundarysurfaces !!

  m_fvBndryCnd->recorrectCellCoordinates();

  m_cells.size(m_bndryGhostCellsOffset);
  m_totalnoghostcells = 0;
  m_totalnosplitchilds = 0;

  for(MInt bndryId = 0; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId = -1;
    }
  }

#if defined _MB_DEBUG_ || !defined NDEBUG

  MInt noRefBndryCells = m_refOldBndryCells.size();
  MInt noCoBndryCells = m_coarseOldBndryCells.size();

  MPI_Allreduce(MPI_IN_PLACE, &noRefBndryCells, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "noRefBndryCells");
  MPI_Allreduce(MPI_IN_PLACE, &noCoBndryCells, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "noCoBndryCells");

  if(noRefBndryCells > 0) {
    m_log << "Refining " << noRefBndryCells << " bndryCells in adaptation!" << endl;
  }

  if(noCoBndryCells > 0) {
    m_log << "Coarsening " << noCoBndryCells << " bndryCells in adaptation!" << endl;
  }

  checkHaloCells(1);
#endif
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::getBoundaryDistance(MFloatScratchSpace& distance) {
  if(m_constructGField || m_levelSetAdaptationScheme != 2) {
    distance.fill(std::numeric_limits<MFloat>::max());

    for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
      ASSERT(!a_isBndryGhostCell(cellId), "");
      ASSERT(!a_isHalo(cellId), "");
      ASSERT(!c_isToDelete(cellId), "");
      distance(cellId) = a_levelSetValuesMb(cellId, 0);
    }
  } else {
    // in this case, distance does not describe the distance to the interface!
    // instead it is rather used simular to the inList in the lssolver.

    MInt listCount = 0;
    distance.fill(0.0);

    // mark Interface cells based on the levelset-value!
    const MInt linerSet = 1;
    for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
      // for (MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
      // only refine around G0-set to avoid unnecessary fv-Cells!
      const MInt set = 0;
      if((MInt)distance(cellId) == 1) continue;
      MBool addParents = false;
      if(approx(a_levelSetValuesMb(cellId, set), F0, MFloatEps)) {
        if(c_isLeafCell(cellId)) {
          const MInt bodySet = m_bodyToSetTable[a_associatedBodyIds(cellId, set)];
          MInt maxLvl = m_lsCutCellLevel[bodySet];
          if(bodySet == linerSet && m_linerLvlJump && a_coordinate(cellId, 0) > -0.51
             && a_coordinate(cellId, 0) < 0.51) {
            maxLvl = m_lsCutCellLevel[bodySet] + 1;
          }
          if(a_level(cellId) < maxLvl) {
            distance(cellId) = 1.0;
            listCount++;
          }
        } else {
          distance(cellId) = 1.0;
          listCount++;
        }
        addParents = true;
      } else {
        for(MInt dir = 0; dir < m_noDirs; dir++) {
          if(a_hasNeighbor(cellId, dir, false) > 0) {
            const MInt nghbrId = c_neighborId(cellId, dir, false);
            if((a_levelSetValuesMb(nghbrId, set) * a_levelSetValuesMb(cellId, set) < F0)) {
              if(c_isLeafCell(cellId)) {
                const MInt bodySet = m_bodyToSetTable[a_associatedBodyIds(cellId, set)];
                MInt maxLvl = m_lsCutCellLevel[bodySet];
                if(bodySet == linerSet && m_linerLvlJump && a_coordinate(cellId, 0) > -0.51
                   && a_coordinate(cellId, 0) < 0.51) {
                  maxLvl = m_lsCutCellLevel[bodySet] + 1;
                }
                if(a_level(cellId) < maxLvl) {
                  distance(cellId) = 1.0;
                  listCount++;
                }
              } else {
                distance(cellId) = 1.0;
                listCount++;
              }
              addParents = true;
              dir = m_noDirs;
            }
          }
        }
      }
      if(addParents) {
        MInt parentId = c_parentId(cellId);
        while(parentId > -1 && parentId < a_noCells()) {
          distance(parentId) = 1.0;
          parentId = c_parentId(parentId);
        }
      }
    }

#if defined _MB_DEBUG_ || !defined NDEBUG
    MPI_Allreduce(MPI_IN_PLACE, &listCount, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "listCount");

    if(listCount == 0) mTerm(1, AT_, "No Cells found for fv-mb-refinement!");
#endif
  }

  exchangeDataFV(distance.data());
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::writeVtkDebug(const MString suffix) {
  TRACE();

  const MInt noCells = a_noCells();
  ScratchSpace<MBool> prop13(noCells, AT_, "prop13");
  ScratchSpace<MBool> inact(noCells, AT_, "inact");
  ScratchSpace<MBool> bghost(noCells, AT_, "bghost");
  for(MInt c = 0; c < noCells; c++) {
    prop13.p[c] = a_hasProperty(c, SolverCell::IsOnCurrentMGLevel);
    bghost.p[c] = a_isBndryGhostCell(c);
    inact.p[c] = a_hasProperty(c, SolverCell::IsInactive);
    if(c_isToDelete(c)) continue;
    a_hasProperty(c, SolverCell::IsOnCurrentMGLevel) = true;
    a_hasProperty(c, SolverCell::IsInactive) = false;
    if(a_isHalo(c)) {
      a_isBndryGhostCell(c) = false;
    }
  }
  const MInt haloCellOutput = m_haloCellOutput;
  const MInt vtuGeometryOutputExtended = m_vtuGeometryOutputExtended;
  const MInt vtuGlobalIdOutput = m_vtuGlobalIdOutput;
  const MInt vtuDomainIdOutput = m_vtuDomainIdOutput;
  const MInt vtuLevelSetOutput = m_vtuLevelSetOutput;
  const MInt vtuVelocityGradientOutput = m_vtuVelocityGradientOutput;

  m_haloCellOutput = true;
  m_vtuGeometryOutputExtended = true;
  m_vtuGlobalIdOutput = true;
  m_vtuDomainIdOutput = true;
  m_vtuLevelSetOutput = false;
  m_vtuVelocityGradientOutput = true;

  writeVtkXmlFiles("QOUT_" + suffix, "GEOM_" + suffix, 0, 0);

  m_haloCellOutput = haloCellOutput;
  m_vtuGeometryOutputExtended = vtuGeometryOutputExtended;
  m_vtuGlobalIdOutput = vtuGlobalIdOutput;
  m_vtuDomainIdOutput = vtuDomainIdOutput;
  m_vtuLevelSetOutput = vtuLevelSetOutput;
  m_vtuVelocityGradientOutput = vtuVelocityGradientOutput;

  for(MInt c = 0; c < noCells; c++) {
    a_hasProperty(c, SolverCell::IsOnCurrentMGLevel) = prop13.p[c];
    a_hasProperty(c, SolverCell::IsInactive) = inact.p[c];
    a_isBndryGhostCell(c) = bghost.p[c];
  }
  const MInt cellId = -1;
  if(domainId() == 0 && cellId > -1) {
    m_log << "CLOG " << globalTimeStep << " " << cellId << " " << a_level(cellId) << " " << c_noChildren(cellId)
          << " # " << a_isBndryGhostCell(cellId) << " " << a_isHalo(cellId) << " " << a_noCells() << " # "
          << a_coordinate(cellId, 0) << " " << a_coordinate(cellId, 1) << " " << a_coordinate(cellId, 2) << " # ";
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      MInt cId = (c_neighborId(cellId, dir) > -1) ? m_bndryCandidateIds[c_neighborId(cellId, dir)] : -1;
      MInt bId = (c_neighborId(cellId, dir) > -1) ? a_isBndryGhostCell(c_neighborId(cellId, dir)) : -1;
      m_log << " / (" << dir << ") " << a_hasNeighbor(cellId, dir) << " " << c_neighborId(cellId, dir) << " " << cId
            << " " << bId;
    }
    m_log << endl;
  }


  ScratchSpace<MInt> noLsMbCells(noDomains(), AT_, "noLsMbCells");
  if(noDomains() > 1)
    MPI_Gather(&m_noLsMbBndryCells, 1, MPI_INT, &(noLsMbCells[0]), 1, MPI_INT, 0, mpiComm(), AT_, "m_noLsMbBndryCells",
               "(noLsMbCells[0])");
  if(domainId() == 0) {
    ofstream ofile(("out/QOUT_" + suffix + ".pvd").c_str(), ios_base::out | ios_base::trunc);
    if(ofile.is_open() && ofile.good()) {
      ofile << "<VTKFile type=\"Collection\" version=\"0.1\" byte_order=\"LittleEndian\">" << endl;
      ofile << "<Collection>" << endl;
      for(MInt p = 0; p < noDomains(); p++) {
        ofile << "<DataSet part=\"" << p << "\" timestep=\"" << globalTimeStep << "\" file=\""
              << "./solver_data/"
              << "QOUT_" << suffix << "_B" << p << ".vtu\"/>" << endl;
      }
      ofile << "</Collection>" << endl;
      ofile << "</VTKFile>" << endl;
      ofile.close();
      ofile.clear();
    } else {
      cerr << "Error opening file out/QOUT_" << suffix << ".pvd" << endl;
    }
    ofstream ofile2(("out/GEOM_" + suffix + ".pvd").c_str(), ios_base::out | ios_base::trunc);
    if(ofile2.is_open() && ofile2.good()) {
      ofile2 << "<VTKFile type=\"Collection\" version=\"0.1\" byte_order=\"LittleEndian\">" << endl;
      ofile2 << "<Collection>" << endl;
      for(MInt p = 0; p < noDomains(); p++) {
        if(noLsMbCells(p) > 0) {
          ofile2 << "<DataSet part=\"" << p << "\" timestep=\"" << globalTimeStep << "\" file=\""
                 << "./solver_data/"
                 << "GEOM_" << suffix << "_B" << p << ".vtp\"/>" << endl;
        }
      }
      ofile2 << "</Collection>" << endl;
      ofile2 << "</VTKFile>" << endl;
      ofile2.close();
      ofile2.clear();
    } else {
      cerr << "Error opening file out/GEOM_" << suffix << ".pvd" << endl;
    }
  }
}


/**
 * \brief save a full solutionOutput at timeSteps closesed to a specified crankAngle Interval
 *        save a solution slice at timeSteps closesed to a specified slice Interval
 * \author Tim Wegmann
 *
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::crankAngleSolutionOutput() {
  TRACE();

  if(!m_engineSetup) return;

  static const MInt cadStart = -10;
  static const MInt cadEnd = 725;
  static const MInt cadEndSlice = 365;
  static const MInt cadInterval = 5;

  static const MInt sliceInterval = 1;

  const MFloat cad = this->crankAngle(m_physicalTime, 0);
  const MFloat cad_prev = this->crankAngle(m_physicalTime - timeStep(), 0);
  const MFloat cad_next = this->crankAngle(m_physicalTime + timeStep(), 0);

  if(cad > cadEnd) return;

  if(cad < cadStart - cadInterval) return;

  const MInt cadMaxIter = (cadEnd - cadStart) / cadInterval;
  const MInt sliceMaxIter = (cadEndSlice - cadStart) / sliceInterval;

  // iterate for full solution output
  for(MInt i = 0; i < cadMaxIter; i++) {
    const MFloat cadTarget = cadStart + i * cadInterval;

    if(cad < cadTarget && cad_next > cadTarget) {
      if(fabs(cad - cadTarget) <= fabs(cad_next - cadTarget)) {
        if(domainId() == 0) {
          cerr << "Saving output at crankAngle " << cad << endl;
        }

        // trigger full output:
        MFloat* backUpCoordinate = NULL;
        if(m_vtuCoordinatesThreshold != NULL) {
          mAlloc(backUpCoordinate, 6, "backUpCoordinate", F0, AT_);
          for(MInt j = 0; j < 2 * nDim; j++) {
            backUpCoordinate[j] = m_vtuCoordinatesThreshold[j];
          }
          mDeallocate(m_vtuCoordinatesThreshold);
          m_vtuCoordinatesThreshold = NULL;
        }
        MString fileName = "FieldData_" + to_string(solverId()) + "_" + to_string((MInt)round(cad));
        writeVtkXmlFiles(fileName, "GEO_", false, false);
        if(backUpCoordinate != NULL) {
          mAlloc(m_vtuCoordinatesThreshold, 6, "backUpCoordinate", F0, AT_);
          for(MInt j = 0; j < 2 * nDim; j++) {
            m_vtuCoordinatesThreshold[j] = backUpCoordinate[j];
          }
        }
        break;
      }
    } else if(cad > cadTarget && cad_prev < cadTarget) {
      if(abs(cad - cadTarget) < fabs(cad_prev - cadTarget)) {
        if(domainId() == 0) {
          cerr << "Saving output at crankAngle " << cad << endl;
        }
        // trigger full output:
        MFloat* backUpCoordinate = NULL;
        if(m_vtuCoordinatesThreshold != NULL) {
          mAlloc(backUpCoordinate, 6, "backUpCoordinate", F0, AT_);
          for(MInt j = 0; j < 2 * nDim; j++) {
            backUpCoordinate[j] = m_vtuCoordinatesThreshold[j];
          }
          mDeallocate(m_vtuCoordinatesThreshold);
          m_vtuCoordinatesThreshold = NULL;
        }
        MString fileName = "FieldData_" + to_string(solverId()) + "_" + to_string((MInt)round(cad));
        writeVtkXmlFiles(fileName, "GEO_", false, false);
        if(backUpCoordinate != NULL) {
          mAlloc(m_vtuCoordinatesThreshold, 6, "backUpCoordinate", F0, AT_);
          for(MInt j = 0; j < 2 * nDim; j++) {
            m_vtuCoordinatesThreshold[j] = backUpCoordinate[j];
          }
        }
        break;
      }
    }
  }

  if(cad > cadEndSlice) return;

  // iterate for slice output
  for(MInt i = 0; i < sliceMaxIter; i++) {
    const MFloat sliceTarget = cadStart + i * sliceInterval;

    if(cad < sliceTarget && cad_next > sliceTarget) {
      if(fabs(cad - sliceTarget) <= fabs(cad_next - sliceTarget)) {
        if(domainId() == 0) {
          cerr << "Saving output Slice at crankAngle " << cad << endl;
        }
        MString fileName = "Slice_" + to_string(solverId()) + "_" + to_string((MInt)round(cad));
        writeVtkXmlFiles(fileName, "SLICE_GEO", false, false);
        break;
      }
    } else if(cad > sliceTarget && cad_prev < sliceTarget) {
      if(abs(cad - sliceTarget) < fabs(cad_prev - sliceTarget)) {
        if(domainId() == 0) {
          cerr << "Saving output Slice at crankAngle " << cad << endl;
        }
        MString fileName = "Slice_" + to_string(solverId()) + "_" + to_string((MInt)round(cad));
        writeVtkXmlFiles(fileName, "SLICE_GEO", false, false);
        break;
      }
    }
  }
}


/**
 * \brief update window/halo cell collectors
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::initializeMaxLevelExchange() {
  TRACE();

  if(noNeighborDomains() == 0 && grid().noAzimuthalNeighborDomains() == 0) {
    if(noDomains() > 1) mTerm(1, AT_, "Unexpected situation in initializeMaxLevelExchange!");
    return;
  }

#ifndef NDEBUG
  MIntScratchSpace sndbuf(noDomains(), AT_, "sndbuf");
  MIntScratchSpace rcvbuf(noDomains(), AT_, "rcvbuf");
  sndbuf.fill(0);
  rcvbuf.fill(-1);
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    sndbuf[neighborDomain(i)] = 1;
  }
  MPI_Alltoall(sndbuf.getPointer(), 1, MPI_INT, rcvbuf.getPointer(), 1, MPI_INT, mpiComm(), AT_, "sndbuf.getPointer()",
               "rcvbuf.getPointer()");
  for(MInt i = 0; i < noDomains(); i++) {
    if(i == domainId()) continue;
    if(sndbuf[i] != rcvbuf[i]) {
      cerr << domainId() << ": warning exchange mismatch with domain " << i << " (" << sndbuf[i] << "/" << rcvbuf[i]
           << ") " << endl;
    }
  }
#endif

//#define NEW_INITMAXLVLEX
#ifdef NEW_INITMAXLVLEX
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    m_noMaxLevelHaloCells[i] = 0;
    for(MInt j = 0; j < noHaloCells(i); j++) {
      MInt cellId = haloCellId(i, j);
      ASSERT(cellId > -1, "");
      MBool structuredCell = a_hasProperty(cellId, SolverCell::AtStructuredRegion);
      for(MInt dir = 0; dir < m_noDirs; dir++) {
        if(a_hasNeighbor(cellId, dir)) {
          if(a_hasProperty(c_neighborId(cellId, dir), SolverCell::AtStructuredRegion)) {
            structuredCell = true;
          }
        }
      }
      if(c_isLeafCell(cellId) || structuredCell) {
        m_maxLevelHaloCells[i][m_noMaxLevelHaloCells[i]] = cellId;
        m_noMaxLevelHaloCells[i]++;
      }
    }
  }
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    m_noMaxLevelWindowCells[i] = 0;
    for(MInt j = 0; j < noWindowCells(i); j++) {
      MInt cellId = windowCellId(i, j);
      ASSERT(cellId > -1, "");
      MBool structuredCell = a_hasProperty(cellId, SolverCell::AtStructuredRegion);
      for(MInt dir = 0; dir < m_noDirs; dir++) {
        if(a_hasNeighbor(cellId, dir)) {
          if(a_hasProperty(c_neighborId(cellId, dir), SolverCell::AtStructuredRegion)) {
            if(a_isWindow(c_neighborId(cellId, dir))) structuredCell = true;
          }
        }
      }
      if(c_isLeafCell(cellId) || structuredCell) {
        m_maxLevelWindowCells[i][m_noMaxLevelWindowCells[i]] = cellId;
        m_noMaxLevelWindowCells[i]++;
      }
    }
  }

#ifndef NDEBUG
  exchange(); // test max level exchange
#endif

#else

  ScratchSpace<MInt> haloCellsCnt(noNeighborDomains(), AT_, "noHaloCells");
  ScratchSpace<MInt> windowCellsCnt(noNeighborDomains(), AT_, "noWindowCells");
  for(MInt d = 0; d < noNeighborDomains(); d++) {
    haloCellsCnt[d] = noHaloCells(d);
    windowCellsCnt[d] = noWindowCells(d);
  }

  if(noNeighborDomains() > 0) {
    mDeallocate(m_maxLevelHaloCells);
    mAlloc(m_maxLevelHaloCells, noNeighborDomains(), &haloCellsCnt[0], "m_maxLevelHaloCells", AT_);
    mDeallocate(m_maxLevelWindowCells);
    mAlloc(m_maxLevelWindowCells, noNeighborDomains(), &windowCellsCnt[0], "m_maxLevelWindowCells", AT_);
  }

  ScratchSpace<MPI_Request> sendReq(noNeighborDomains(), AT_, "sendReq");
  ScratchSpace<MPI_Request> recvReq(noNeighborDomains(), AT_, "recvReq");
  sendReq.fill(MPI_REQUEST_NULL);
  recvReq.fill(MPI_REQUEST_NULL);

  // halo cells
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    m_noMaxLevelHaloCells[i] = 0;
    for(MInt j = 0; j < noHaloCells(i); j++) {
      MInt cellId = haloCellId(i, j);
      m_receiveBuffers[i][j] = -F1;
      MBool structuredCell = a_hasProperty(cellId, SolverCell::AtStructuredRegion);
      for(MInt dir = 0; dir < m_noDirs; dir++) {
        if(a_hasNeighbor(cellId, dir)) {
          if(a_hasProperty(c_neighborId(cellId, dir), SolverCell::AtStructuredRegion)) {
            structuredCell = true;
          }
        }
      }
      if(!c_isLeafCell(cellId) && !structuredCell) continue;
      m_maxLevelHaloCells[i][m_noMaxLevelHaloCells[i]] = cellId;
      m_noMaxLevelHaloCells[i]++;
      ASSERT(cellId > -1, "");
      m_receiveBuffers[i][j] = (MFloat)cellId;
    }
  }

  // send halo cell information
  if(noNeighborDomains() > 0) {
    if(m_nonBlockingComm) {
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        MPI_Irecv(m_sendBuffers[i], noWindowCells(i), MPI_DOUBLE, neighborDomain(i), 5, mpiComm(), &recvReq[i], AT_,
                  "m_sendBuffers[i]");
      }
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        MPI_Isend(m_receiveBuffers[i], noHaloCells(i), MPI_DOUBLE, neighborDomain(i), 5, mpiComm(), &sendReq[i], AT_,
                  "m_receiveBuffers[i]");
      }
      MPI_Waitall(noNeighborDomains(), &recvReq[0], MPI_STATUSES_IGNORE, AT_);
      MPI_Waitall(noNeighborDomains(), &sendReq[0], MPI_STATUSES_IGNORE, AT_);
    } else {
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        MPI_Issend(m_receiveBuffers[i], noHaloCells(i), MPI_DOUBLE, neighborDomain(i), 5, mpiComm(), &sendReq[i], AT_,
                   "m_receiveBuffers[i]");
      }
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        MPI_Recv(m_sendBuffers[i], noWindowCells(i), MPI_DOUBLE, neighborDomain(i), 5, mpiComm(), MPI_STATUS_IGNORE,
                 AT_, "m_sendBuffers[i]");
      }
      MPI_Waitall(noNeighborDomains(), &sendReq[0], MPI_STATUSES_IGNORE, AT_);
    }
  }

  // write window cell information
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    m_noMaxLevelWindowCells[i] = 0;
    for(MInt j = 0; j < noWindowCells(i); j++) {
      if(m_sendBuffers[i][j] > -F1B2) {
        ASSERT(windowCellId(i, j) > -1, "");
        m_maxLevelWindowCells[i][m_noMaxLevelWindowCells[i]] = windowCellId(i, j);
        m_noMaxLevelWindowCells[i]++;
      }
    }
  }
#endif


  this->prepareMpiExchange();

  if(grid().azimuthalPeriodicity()) {
    initAzimuthalMaxLevelExchange();
  }
}


/**
 * \brief restores the surfaces of the given cell
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::createSurface(MInt srfcId, MInt nghbrId0, MInt nghbrId1, MInt orientation) {
  TRACE();

  ASSERT((srfcId > -1) && (nghbrId0 > -1) && (nghbrId1 > -1), "createSurface(..) error");
  ASSERT((srfcId < a_noSurfaces()) && (nghbrId0 < a_noCells()) && (nghbrId1 < a_noCells()),
         to_string(nghbrId0) + " " + to_string(nghbrId1) + " " + to_string(c_noCells()) + " " + to_string(a_noCells()));
  ASSERT(c_noChildren(nghbrId0) == 0 && c_noChildren(nghbrId1) == 0, "");

  a_surfaceOrientation(srfcId) = orientation;
  a_surfaceNghbrCellId(srfcId, 0) = nghbrId0;
  a_surfaceNghbrCellId(srfcId, 1) = nghbrId1;

  if(a_bndryId(nghbrId0) > -1) {
    m_bndryCells->a[a_bndryId(nghbrId0)].m_associatedSrfc[2 * orientation + 1] = srfcId;
  }
  if(a_bndryId(nghbrId1) > -1) {
    m_bndryCells->a[a_bndryId(nghbrId1)].m_associatedSrfc[2 * orientation] = srfcId;
  }

  if(a_level(nghbrId1) > a_level(nghbrId0)) {
    const MFloat cellLength = c_cellLengthAtLevel(a_level(nghbrId1));
    for(MInt i = 0; i < nDim; i++) {
      a_surfaceCoordinate(srfcId, i) = a_coordinate(nghbrId1, i);
    }
    a_surfaceCoordinate(srfcId, orientation) -= F1B2 * cellLength;
    a_surfaceArea(srfcId) = F1;
    for(MInt i = 0; i < nDim - 1; i++)
      a_surfaceArea(srfcId) *= cellLength;
    m_cellSurfaceMapping[nghbrId0][2 * orientation + 1] = -1;
    m_cellSurfaceMapping[nghbrId1][2 * orientation] = srfcId;
  } else {
    const MFloat cellLength = c_cellLengthAtLevel(a_level(nghbrId0));
    for(MInt i = 0; i < nDim; i++) {
      a_surfaceCoordinate(srfcId, i) = a_coordinate(nghbrId0, i);
    }
    a_surfaceCoordinate(srfcId, orientation) += F1B2 * cellLength;
    a_surfaceArea(srfcId) = F1;
    for(MInt i = 0; i < nDim - 1; i++)
      a_surfaceArea(srfcId) *= cellLength;
    m_cellSurfaceMapping[nghbrId0][2 * orientation + 1] = srfcId;
    m_cellSurfaceMapping[nghbrId1][2 * orientation] = -1;
  }

  if(a_level(nghbrId0) == a_level(nghbrId1)) {
    a_surfaceUpwindCoefficient(srfcId) = m_globalUpwindCoefficient;
    a_surfaceFactor(srfcId, 0) = F1B2;
    a_surfaceFactor(srfcId, 1) = F1B2;
    m_cellSurfaceMapping[nghbrId0][2 * orientation + 1] = srfcId;
    m_cellSurfaceMapping[nghbrId1][2 * orientation] = srfcId;
  } else {
    a_surfaceUpwindCoefficient(srfcId) = m_chi;
    MFloat tmp = F0;
    a_surfaceFactor(srfcId, 0) = F0;
    for(MInt i = 0; i < nDim; i++) {
      a_surfaceFactor(srfcId, 0) += POW2(a_surfaceCoordinate(srfcId, i) - a_coordinate(nghbrId0, i));
      tmp += POW2(a_surfaceCoordinate(srfcId, i) - a_coordinate(nghbrId1, i));
    }
    a_surfaceFactor(srfcId, 0) = sqrt(a_surfaceFactor(srfcId, 0));
    tmp = sqrt(tmp);
    a_surfaceFactor(srfcId, 0) = tmp / (a_surfaceFactor(srfcId, 0) + tmp);
    a_surfaceFactor(srfcId, 1) = F1 - a_surfaceFactor(srfcId, 0);
  }
  for(MInt i = 0; i < nDim; i++) {
    a_surfaceDeltaX(srfcId, i) = a_surfaceCoordinate(srfcId, i) - a_coordinate(a_surfaceNghbrCellId(srfcId, 0), i);
    a_surfaceDeltaX(srfcId, nDim + i) =
        a_surfaceCoordinate(srfcId, i) - a_coordinate(a_surfaceNghbrCellId(srfcId, 1), i);
  }
  MBool flag = false;
  for(MInt side = 0; side < 2; side++) {
    for(MInt d = 0; d < m_noDirs; d++) {
      if(a_hasNeighbor(a_surfaceNghbrCellId(srfcId, side), d) > 0) continue;
      if(c_parentId(a_surfaceNghbrCellId(srfcId, side)) == -1) continue;
      if(a_hasNeighbor(c_parentId(a_surfaceNghbrCellId(srfcId, side)), d) == 0) continue;
      if(c_noChildren(c_neighborId(c_parentId(a_surfaceNghbrCellId(srfcId, side)), d)) > 0) continue;
      flag = true;
      d = m_noDirs;
    }
  }

  if(flag) a_surfaceUpwindCoefficient(srfcId) = m_chi;
  a_surfaceBndryCndId(srfcId) = -1;
}


/**
 * \brief restores the surfaces of the given cell
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::createSurfaceSplit(MInt srfcId, MInt cellId, MInt splitChildId,
                                                             MInt direction) {
  ASSERT((srfcId > -1), "createSurface(..) error");
  ASSERT((srfcId < a_noSurfaces()) && (cellId < a_noCells()) && (splitChildId < a_noCells()),
         "createSurface(..) error");
  ASSERT(c_isLeafCell(cellId), "");

  MInt orientation = direction / 2;
  a_surfaceOrientation(srfcId) = orientation;
  MInt nghbr0 = splitChildId;
  MInt nghbr1 = -2;
  if(direction % 2 == 0) {
    nghbr0 = -2;
    nghbr1 = splitChildId;
  }
  a_surfaceNghbrCellId(srfcId, 0) = nghbr0;
  a_surfaceNghbrCellId(srfcId, 1) = nghbr1;

  MInt nghbrId = c_neighborId(cellId, direction);
  ASSERT(nghbrId > -1, "");

  if(nghbr0 == -2) {
    nghbr0 = nghbrId;
    nghbr1 = cellId;
  } else {
    nghbr0 = cellId;
    nghbr1 = nghbrId;
  }

  const MFloat cellLength = c_cellLengthAtLevel(a_level(cellId));
  for(MInt i = 0; i < nDim; i++) {
    a_surfaceCoordinate(srfcId, i) = a_coordinate(cellId, i);
  }
  a_surfaceCoordinate(srfcId, orientation) += F1B2 * cellLength;
  a_surfaceArea(srfcId) = F1;
  for(MInt i = 0; i < nDim - 1; i++)
    a_surfaceArea(srfcId) *= cellLength;
  a_surfaceUpwindCoefficient(srfcId) = m_globalUpwindCoefficient;

  a_surfaceFactor(srfcId, 0) = F1B2;
  a_surfaceFactor(srfcId, 1) = F1B2;

  for(MInt i = 0; i < nDim; i++) {
    a_surfaceDeltaX(srfcId, i) = a_surfaceCoordinate(srfcId, i) - a_coordinate(nghbr0, i);
    a_surfaceDeltaX(srfcId, nDim + i) = a_surfaceCoordinate(srfcId, i) - a_coordinate(nghbr1, i);
  }
  a_surfaceBndryCndId(srfcId) = -1;

  m_splitSurfaces.insert(srfcId);
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::moveSurface(MInt toSrfcId, MInt fromSrfcId) {
  ASSERT((fromSrfcId > -1) && (toSrfcId > -1) && (fromSrfcId < a_noSurfaces()) && (toSrfcId < a_noSurfaces()),
         "moveSurface(..) error");

  const MInt ori = a_surfaceOrientation(fromSrfcId);
  a_surfaceOrientation(toSrfcId) = ori;

  const MInt nghbrId0 = a_surfaceNghbrCellId(fromSrfcId, 0);
  const MInt nghbrId1 = a_surfaceNghbrCellId(fromSrfcId, 1);
  ASSERT(nghbrId0 > -1 && nghbrId1 > -1, "");
  ASSERT(nghbrId0 < a_noCells() && nghbrId1 < a_noCells(), "");

  // for split faces, m_cellSurfaceMapping[ cell ][ splitFace ] does not point to the surface, connection only
  // 1-sided...
  ASSERT(((m_cellSurfaceMapping[nghbrId0][2 * ori + 1] > -1) && (m_cellSurfaceMapping[nghbrId1][2 * ori] > -1))
             || (a_bndryId(nghbrId0) > -1 && a_bndryId(nghbrId1) > -1) || a_level(nghbrId0) != a_level(nghbrId1),
         "");

  if(nghbrId0 > -1) {
    if(m_cellSurfaceMapping[nghbrId0][2 * ori + 1] > -1) {
      ASSERT(m_cellSurfaceMapping[nghbrId0][2 * ori + 1] == fromSrfcId,
             to_string(m_cellSurfaceMapping[nghbrId1][2 * ori + 1]));
      m_cellSurfaceMapping[nghbrId0][2 * ori + 1] = toSrfcId;
    }
  }
  if(nghbrId1 > -1) {
    if(m_cellSurfaceMapping[nghbrId1][2 * ori] > -1) {
      ASSERT(m_cellSurfaceMapping[nghbrId1][2 * ori] == fromSrfcId, to_string(m_cellSurfaceMapping[nghbrId1][2 * ori]));
      m_cellSurfaceMapping[nghbrId1][2 * ori] = toSrfcId;
    }
  }

  if(a_bndryId(nghbrId0) > -1) {
    // for split faces, m_associatedSrfc[ splitFace ] does not point to the surface, connection only 1-sided...
    //       ASSERT( m_bndryCells->a[ a_bndryId( nghbrId0 ) ].m_associatedSrfc[ 2*ori + 1 ] == fromSrfcId,
    //                  a_bndryId( nghbrId0 ) << " " << m_bndryCells->a[ a_bndryId( nghbrId0 )
    //                  ].m_associatedSrfc[ 2*ori + 1 ] << " " << fromSrfcId  );
    if(m_bndryCells->a[a_bndryId(nghbrId0)].m_associatedSrfc[2 * ori + 1] == fromSrfcId)
      m_bndryCells->a[a_bndryId(nghbrId0)].m_associatedSrfc[2 * ori + 1] = toSrfcId;
    MInt bndryId = a_bndryId(nghbrId0);
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      for(MInt i = 0; i < nDim; i++) {
        if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_srfcId[i] == fromSrfcId) {
          m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_srfcId[i] = toSrfcId;
        }
      }
    }
  }
  if(a_bndryId(nghbrId1) > -1) {
    // for split faces, m_associatedSrfc[ splitFace ] does not point to the surface, connection only 1-sided...
    //       ASSERT( m_bndryCells->a[ a_bndryId( nghbrId1 ) ].m_associatedSrfc[ 2*ori ] == fromSrfcId,
    //                  a_bndryId( nghbrId1 ) << " " << m_bndryCells->a[ a_bndryId( nghbrId0 )
    //                  ].m_associatedSrfc[ 2*ori + 1 ] << " " << fromSrfcId );
    if(m_bndryCells->a[a_bndryId(nghbrId1)].m_associatedSrfc[2 * ori] == fromSrfcId)
      m_bndryCells->a[a_bndryId(nghbrId1)].m_associatedSrfc[2 * ori] = toSrfcId;
    MInt bndryId = a_bndryId(nghbrId1);
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      for(MInt i = 0; i < nDim; i++) {
        if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_srfcId[i] == fromSrfcId) {
          m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_srfcId[i] = toSrfcId;
        }
      }
    }
  }

  if(m_splitSurfaces.erase(fromSrfcId)) m_splitSurfaces.insert(toSrfcId);

  a_surfaceNghbrCellId(toSrfcId, 0) = nghbrId0;
  a_surfaceNghbrCellId(toSrfcId, 1) = nghbrId1;
  a_surfaceNghbrCellId(fromSrfcId, 0) = -1;
  a_surfaceNghbrCellId(fromSrfcId, 1) = -1;


  for(MInt i = 0; i < nDim; i++) {
    a_surfaceCoordinate(toSrfcId, i) = a_surfaceCoordinate(fromSrfcId, i);
  }
  a_surfaceArea(toSrfcId) = a_surfaceArea(fromSrfcId);

  a_surfaceUpwindCoefficient(toSrfcId) = a_surfaceUpwindCoefficient(fromSrfcId);
  a_surfaceFactor(toSrfcId, 0) = a_surfaceFactor(fromSrfcId, 0);
  a_surfaceFactor(toSrfcId, 1) = a_surfaceFactor(fromSrfcId, 1);

  for(MInt i = 0; i < nDim; i++) {
    a_surfaceDeltaX(toSrfcId, i) = a_surfaceDeltaX(fromSrfcId, i);
    a_surfaceDeltaX(toSrfcId, nDim + i) = a_surfaceDeltaX(fromSrfcId, nDim + i);
  }

  a_surfaceBndryCndId(toSrfcId) = a_surfaceBndryCndId(fromSrfcId);

  for(MInt v = 0; v < m_noCVars; v++) {
    a_surfaceVariable(toSrfcId, 0, v) = a_surfaceVariable(fromSrfcId, 0, v);
    a_surfaceVariable(toSrfcId, 1, v) = a_surfaceVariable(fromSrfcId, 1, v);
  }

  m_noSurfaces = a_noSurfaces();
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::compactSurfaces() {
  MInt delCnt = 0;
  MInt delCnt2 = 0;
  MInt lastSrfcId = a_noSurfaces() - 1;

  if(a_noSurfaces() > 0) {
    for(set<MInt>::iterator it = m_freeSurfaceIndices.begin(); it != m_freeSurfaceIndices.end(); ++it) {
      MInt srfcId = *it;
      if((a_surfaceNghbrCellId(srfcId, 0) > -1) || (a_surfaceNghbrCellId(srfcId, 1) > -1)) {
        cerr << "Warning: not expected in compactSurfaces()" << endl;
        continue;
      }
      while((a_surfaceNghbrCellId(lastSrfcId, 0) < 0) || (a_surfaceNghbrCellId(lastSrfcId, 1) < 0)) {
        if(lastSrfcId < a_noSurfaces()) {
          m_surfaces.erase(lastSrfcId);
          m_surfaces.size(lastSrfcId);
        }
        lastSrfcId = a_noSurfaces() - 1;
        if(lastSrfcId == -1) break;
      }
      if(lastSrfcId == -1 || srfcId >= a_noSurfaces()) {
        break;
      } else {
        lastSrfcId = a_noSurfaces() - 1;
        moveSurface(srfcId, lastSrfcId);
        m_surfaces.erase(lastSrfcId);
        m_surfaces.size(lastSrfcId);
        delCnt2++;
      }
      delCnt++;
    }
  }
  m_freeSurfaceIndices.clear();
  m_noSurfaces = a_noSurfaces();
}


/**
 * \brief resets the surfaces of the given cell to their original state
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::resetSurfaces(MInt cellId) {
  if(a_isBndryGhostCell(cellId)) return;
  if(c_noChildren(cellId) > 0) return;
  if(a_hasProperty(cellId, SolverCell::IsInactive)) return;

  // 1. restore state of existing surfaces on the uncut mesh
  for(MInt dir = 0; dir < m_noDirs; dir++) {
    MInt srfcId = m_cellSurfaceMapping[cellId][dir];
    if(srfcId > -1) {
      if((a_surfaceNghbrCellId(srfcId, 0) < 0) || (a_surfaceNghbrCellId(srfcId, 1) < 0)) {
        cerr << srfcId << " " << cellId << " " << dir << " " << a_coordinate(cellId, 0) << " "
             << a_coordinate(cellId, 1) << " " << c_neighborId(cellId, dir) << endl;
        cerr << a_isHalo(cellId) << " " << a_isHalo(c_neighborId(cellId, dir)) << " "
             << a_hasProperty(c_neighborId(cellId, dir), SolverCell::IsNotGradient) << endl;
      }
      createSurface(srfcId, a_surfaceNghbrCellId(srfcId, 0), a_surfaceNghbrCellId(srfcId, 1),
                    a_surfaceOrientation(srfcId));
    } else {
      if(a_hasNeighbor(cellId, dir) > 0) {
        MInt nghbrId = c_neighborId(cellId, dir);
        if(c_noChildren(nghbrId) > 0) {
          for(MInt child = 0; child < m_noCellNodes; child++) {
            if(!childCode[dir][child]) continue;
            MInt childId = c_childId(nghbrId, child);
            if(childId < 0) continue;
            srfcId = m_cellSurfaceMapping[childId][m_revDir[dir]];
            if(srfcId > -1) {
              createSurface(srfcId, a_surfaceNghbrCellId(srfcId, 0), a_surfaceNghbrCellId(srfcId, 1),
                            a_surfaceOrientation(srfcId));
            }
          }
        }
      }
    }
  }

  // 2. restore previously deleted surfaces
  restoreSurfaces(cellId);
}


/**
 * \brief restores the surfaces of the given cell
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::restoreSurfaces(const MInt cellId) {
  if(a_isBndryGhostCell(cellId)) mTerm(1, AT_, "Unexpected situation 0 in FvMbCartesianSolverXD::restoreSurfaces()");
  if(c_noChildren(cellId) > 0) return;
  if(a_hasProperty(cellId, SolverCell::IsNotGradient)) return;
  if(a_hasProperty(cellId, SolverCell::IsInactive)) return;

  for(MInt dir = 0; dir < m_noDirs; dir++) {
    MInt srfcId = m_cellSurfaceMapping[cellId][dir];

    if(srfcId < 0) {
      if(a_hasNeighbor(cellId, dir) > 0) {
        const MInt nghbrId = c_neighborId(cellId, dir);
        if(c_noChildren(nghbrId) > 0) {
          for(MInt child = 0; child < m_noCellNodes; child++) {
            if(!childCode[dir][child]) continue;
            const MInt childId = c_childId(nghbrId, child);
            if(childId < 0) continue;
            ASSERT(!a_isBndryGhostCell(childId), "");
            srfcId = m_cellSurfaceMapping[childId][m_revDir[dir]];
            if(srfcId > -1) {
              ASSERT(srfcId < a_noSurfaces(), to_string(srfcId) + " " + to_string(a_noSurfaces()));
              if(a_surfaceNghbrCellId(srfcId, m_revDir[dir] % 2) != cellId) {
                cerr << cellId << " " << nghbrId << " " << srfcId << " " << a_isHalo(cellId) << " " << a_level(cellId)
                     << " " << a_level(nghbrId) << endl;
                cerr << dir << " " << child << " " << childId << endl;
                cerr << a_surfaceNghbrCellId(srfcId, 0) << " " << a_surfaceNghbrCellId(srfcId, 1) << " " << endl;
                if(a_surfaceNghbrCellId(srfcId, 0) > -1 && a_surfaceNghbrCellId(srfcId, 1) > -1) {
                  cerr << a_level(a_surfaceNghbrCellId(srfcId, 0)) << " " << a_level(a_surfaceNghbrCellId(srfcId, 1))
                       << " " << endl;
                }
                cerr << c_parentId(cellId) << " " << c_noChildren(cellId) << endl;
                for(MInt d = 0; d < m_noDirs; d++) {
                  cerr << d << ": " << a_hasNeighbor(cellId, d) << "/" << c_neighborId(cellId, d);
                  if(c_parentId(cellId) > -1) {
                    cerr << " # " << a_hasNeighbor(c_parentId(cellId), d) << "/" << c_neighborId(c_parentId(cellId), d);
                  }
                  cerr << endl;
                }
                // writeVtkErrorFile();
                mTerm(1, AT_, "Unexpected situation in restoreSurfaces");
              }
            } else {
              if(a_hasProperty(childId, SolverCell::IsInactive)) continue;
              if(a_hasProperty(childId, SolverCell::IsNotGradient)) continue;
              if(a_isHalo(cellId) && a_isHalo(childId)) continue;
              srfcId = getNewSurfaceId();

              ASSERT(a_level(cellId) != a_level(childId), "");

              if(dir % 2 == 0)
                createSurface(srfcId, childId, cellId, dir / 2);
              else
                createSurface(srfcId, cellId, childId, dir / 2);
            }
          }
        } else {
          ASSERT(!a_isBndryGhostCell(nghbrId), "");
          if(a_hasProperty(nghbrId, SolverCell::IsInactive)) continue;
          if(a_hasProperty(nghbrId, SolverCell::IsNotGradient)) continue;
          if(a_isHalo(cellId) && a_isHalo(nghbrId)) continue;
          srfcId = getNewSurfaceId();
          if(dir % 2 == 0)
            createSurface(srfcId, nghbrId, cellId, dir / 2);
          else
            createSurface(srfcId, cellId, nghbrId, dir / 2);
        }
      } else {
        if(c_parentId(cellId) > -1) {
          if(a_hasNeighbor(c_parentId(cellId), dir) > 0) {
            const MInt nghbrId = c_neighborId(c_parentId(cellId), dir);
            ASSERT(!a_isBndryGhostCell(nghbrId), "");
            srfcId = m_cellSurfaceMapping[nghbrId][m_revDir[dir]];
            if(srfcId > -1) {
              m_log << "nghb surf " << globalTimeStep << " " << srfcId << " " << nghbrId << " " << cellId << " "
                    << a_noSurfaces() << " / " << c_isToDelete(cellId) << " "
                    << a_hasProperty(cellId, SolverCell::IsInactive) << " " << c_isToDelete(nghbrId) << " "
                    << a_hasProperty(nghbrId, SolverCell::IsInactive) << " " << a_surfaceNghbrCellId(srfcId, 0) << " "
                    << a_surfaceNghbrCellId(srfcId, 1) << endl;
            }
            ASSERT(srfcId < a_noSurfaces(), "");
            if(srfcId > -1) {
              cerr << domainId() << ": " << srfcId << " " << cellId << " " << nghbrId << " / "
                   << a_surfaceNghbrCellId(srfcId, 0) << " " << a_surfaceNghbrCellId(srfcId, 1) << " / "
                   << a_level(cellId) << " " << a_level(nghbrId) << " / " << a_coordinate(cellId, 0) << " "
                   << a_coordinate(cellId, 1) << " / " << a_coordinate(nghbrId, 0) << " " << a_coordinate(nghbrId, 1)
                   << endl;
            }
            ASSERT(srfcId < 0, "");
            if(a_hasProperty(nghbrId, SolverCell::IsInactive)) continue;
            if(a_hasProperty(nghbrId, SolverCell::IsNotGradient)) continue;
            if(a_isHalo(cellId) && a_isHalo(nghbrId)) continue;
            if(c_noChildren(nghbrId) > 0) {
              cerr << domainId() << ": error surf " << dir << " " << cellId << " " << nghbrId << " "
                   << c_globalId(cellId) << " " << c_globalId(nghbrId) << " " << c_neighborId(cellId, dir, false) << " "
                   << c_noChildren(nghbrId) << "  " << c_childId(nghbrId, 0) << " " << a_level(cellId) << " "
                   << a_level(nghbrId) << " " << a_isHalo(cellId) << " " << a_isHalo(nghbrId) << " "
                   << a_levelSetValuesMb(cellId, 0) / c_cellLengthAtCell(cellId) << " "
                   << a_levelSetValuesMb(nghbrId, 0) / c_cellLengthAtCell(nghbrId) << endl;
            }
            ASSERT(c_noChildren(nghbrId) == 0, "");
            if(srfcId < 0) srfcId = getNewSurfaceId();

            ASSERT(a_level(cellId) != a_level(nghbrId), "");
            if(dir % 2 == 0)
              createSurface(srfcId, nghbrId, cellId, dir / 2);
            else
              createSurface(srfcId, cellId, nghbrId, dir / 2);
          }
        }
      }
    } else {
      if(a_surfaceNghbrCellId(srfcId, 0) < 0 || a_surfaceNghbrCellId(srfcId, 1) < 0) {
        cerr << "srcf neighbors: " << srfcId << " " << cellId << " " << a_surfaceNghbrCellId(srfcId, 0) << " "
             << a_surfaceNghbrCellId(srfcId, 0) << endl;
      }
    }
  }
}


/**
 * \brief determines the neighbors sharing a face with the given cell
 * \author Lennart Schneiders
 * \date 06.11.2012
 */
template <MInt nDim, class SysEqn>
inline MInt FvMbCartesianSolverXD<nDim, SysEqn>::getFacingNghbrs(const MInt cellId, const MBool includeAllChilds) {
  MInt counter = 0;

  for(MInt dir = 0; dir < m_noDirs; dir++) {
    if(a_hasNeighbor(cellId, dir) > 0) {
      MInt nghbrId = c_neighborId(cellId, dir);
      if(c_noChildren(nghbrId) > 0) {
        for(MInt child = 0; child < m_noCellNodes; child++) {
          if(!includeAllChilds && !childCode[dir][child]) continue;
          MInt childId = c_childId(nghbrId, child);
          if(childId < 0) continue;
          if(a_isBndryGhostCell(childId)) continue;
          if(!childCode[dir][child] && c_noChildren(childId) > 0) continue;

          if(!((c_noChildren(childId) == 0) || (a_isHalo(cellId)))) {
            cerr << cellId << " " << nghbrId << " " << childId << " " << c_childId(childId, 0) << " " << dir << " "
                 << child << " / " << a_isHalo(cellId) << " " << a_isWindow(cellId) << " " << a_isHalo(childId) << " "
                 << a_isWindow(childId) << " " << a_isHalo(nghbrId) << " " << a_isWindow(nghbrId) << " // "
                 << c_noChildren(cellId) << " " << c_noChildren(childId) << " " << a_level(cellId) << " /// "
                 << (c_childId(childId, 0) > -1 ? c_noChildren(c_childId(childId, 0)) : -1) << " "
                 << (c_childId(childId, 1) > -1 ? c_noChildren(c_childId(childId, 1)) : -1) << " "
                 << (c_childId(childId, 2) > -1 ? c_noChildren(c_childId(childId, 2)) : -1) << " "
                 << (c_childId(childId, 3) > -1 ? c_noChildren(c_childId(childId, 3)) : -1) << " "
                 << (c_childId(childId, 4) > -1 ? c_noChildren(c_childId(childId, 4)) : -1) << " "
                 << (c_childId(childId, 5) > -1 ? c_noChildren(c_childId(childId, 5)) : -1) << " "
                 << (c_childId(childId, 6) > -1 ? c_noChildren(c_childId(childId, 6)) : -1) << " "
                 << (c_childId(childId, 7) > -1 ? c_noChildren(c_childId(childId, 7)) : -1) << endl;
          }
          ASSERT((c_noChildren(childId) == 0) || (a_isHalo(cellId)),
                 "(1) No children expected FvMbCartesianSolverXD::getFacingNghbrs(..) "
                     << cellId << " " << nghbrId << " " << childId << " " << c_childId(childId, 0) << " " << dir << " "
                     << child << " " << c_noChildren(childId));
          m_nghbrList[counter++] = childId;
        }
      } else {
        ASSERT(nghbrId > -1, "Invalid neighbor id in FvMbCartesianSolverXD::getFacingNghbrs(..)");
        if(a_isBndryGhostCell(nghbrId)) continue;
        m_nghbrList[counter++] = nghbrId;
      }
    } else {
      if(c_parentId(cellId) > -1) {
        if(a_hasNeighbor(c_parentId(cellId), dir) > 0) {
          MInt nghbrId = c_neighborId(c_parentId(cellId), dir);
          ASSERT(nghbrId > -1, "Invalid neighbor id in FvMbCartesianSolverXD::getFacingNghbrs(..)");
          if(a_isBndryGhostCell(nghbrId)) continue;
          if(c_noChildren(nghbrId) == 0) m_nghbrList[counter++] = nghbrId;
        }
      }
    }
  }
  return counter;
}


/**
 * \brief removes the surfaces of the given cell
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::deleteSurface(MInt srfcId) {
  const MInt dir = a_surfaceOrientation(srfcId);
  const MInt nghbr0 = a_surfaceNghbrCellId(srfcId, 0);
  const MInt nghbr1 = a_surfaceNghbrCellId(srfcId, 1);

  if(nghbr0 > -1) {
    ASSERT(m_cellSurfaceMapping[nghbr0][2 * dir + 1] < 0 || m_cellSurfaceMapping[nghbr0][2 * dir + 1] == srfcId,
           to_string(m_cellSurfaceMapping[nghbr0][2 * dir + 1]));
    m_cellSurfaceMapping[nghbr0][2 * dir + 1] = -1;
    if(a_bndryId(nghbr0) > -1) {
      m_bndryCells->a[a_bndryId(nghbr0)].m_associatedSrfc[2 * dir + 1] = -1;
      MInt bndryId = a_bndryId(nghbr0);
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        for(MInt i = 0; i < nDim; i++) {
          if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_srfcId[i] == srfcId) {
            m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_srfcId[i] = -1;
          }
        }
      }
    }
  }

  if(nghbr1 > -1) {
    ASSERT(m_cellSurfaceMapping[nghbr1][2 * dir] < 0 || m_cellSurfaceMapping[nghbr1][2 * dir] == srfcId,
           to_string(m_cellSurfaceMapping[nghbr1][2 * dir]));
    m_cellSurfaceMapping[nghbr1][2 * dir] = -1;
    if(a_bndryId(nghbr1) > -1) {
      m_bndryCells->a[a_bndryId(nghbr1)].m_associatedSrfc[2 * dir] = -1;
      MInt bndryId = a_bndryId(nghbr1);
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        for(MInt i = 0; i < nDim; i++) {
          if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_srfcId[i] == srfcId) {
            m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_srfcId[i] = -1;
          }
        }
      }
    }
  }

  a_surfaceNghbrCellId(srfcId, 0) = -1;
  a_surfaceNghbrCellId(srfcId, 1) = -1;
  a_surfaceBndryCndId(srfcId) = -1;
  m_splitSurfaces.erase(srfcId);

  if(srfcId >= a_noSurfaces()) {
    mTerm(1, AT_, "Invalid surface.");
  } else if(srfcId == (a_noSurfaces() - 1)) {
    m_surfaces.erase(a_noSurfaces() - 1);
    m_surfaces.size(a_noSurfaces() - 1);
    m_noSurfaces = a_noSurfaces();
  } else {
    m_freeSurfaceIndices.insert(srfcId);
  }
}


/**
 * \brief removes the surfaces of the given cell
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::removeSurfaces(MInt cellId) {
  for(MInt dir = 0; dir < m_noDirs; dir++) {
    MInt srfcId = m_cellSurfaceMapping[cellId][dir];

    if(srfcId > -1) {
      deleteSurface(srfcId);
    } else {
      if(!a_hasProperty(cellId, SolverCell::IsSplitChild) && checkNeighborActive(cellId, dir)
         && a_hasNeighbor(cellId, dir) > 0) {
        MInt nghbrId = c_neighborId(cellId, dir);
        if(c_noChildren(nghbrId) > 0) {
          for(MInt child = 0; child < m_noCellNodes; child++) {
            if(!childCode[dir][child]) continue;
            MInt childId = c_childId(nghbrId, child);
            if(childId < 0) continue;
            srfcId = m_cellSurfaceMapping[childId][m_revDir[dir]];
            if(srfcId > -1) {
              deleteSurface(srfcId);
            }
          }
        }
      }
    }
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::swapCells(const MInt cellId0, const MInt cellId1) {
  if(cellId1 == cellId0) return;

  FvCartesianSolverXD<nDim, SysEqn>::swapCells(cellId0, cellId1);

  for(MInt v = 0; v < m_noFVars; v++) {
    std::swap(m_rhs0[cellId1][v], m_rhs0[cellId0][v]);
  }

  for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
    std::swap(a_levelSetValuesMb(cellId1, set), a_levelSetValuesMb(cellId0, set));
    std::swap(a_associatedBodyIds(cellId1, set), a_associatedBodyIds(cellId0, set));
  }

  std::swap(m_cellVolumesDt1[cellId1], m_cellVolumesDt1[cellId0]);
  if(m_dualTimeStepping) std::swap(m_cellVolumesDt2[cellId1], m_cellVolumesDt2[cellId0]);

  if(!m_oldBndryCells.empty()) {
    auto it0 = m_oldBndryCells.find(cellId0);
    auto it1 = m_oldBndryCells.find(cellId1);
    if(it0 != m_oldBndryCells.end() && it1 != m_oldBndryCells.end()) {
      std::swap(it0->second, it1->second);
    } else if(it0 != m_oldBndryCells.end()) {
      MFloat val = it0->second;
      m_oldBndryCells.erase(it0);
      m_oldBndryCells.insert(make_pair(cellId1, val));
    } else if(it1 != m_oldBndryCells.end()) {
      MFloat val = it1->second;
      m_oldBndryCells.erase(it1);
      m_oldBndryCells.insert(make_pair(cellId0, val));
    }
  }

  if(!m_nearBoundaryBackup.empty()) {
    auto it0 = m_nearBoundaryBackup.find(cellId0);
    auto it1 = m_nearBoundaryBackup.find(cellId1);
    if(it0 != m_nearBoundaryBackup.end() && it1 != m_nearBoundaryBackup.end()) {
      std::swap(it0->second, it1->second);
    } else if(it0 != m_nearBoundaryBackup.end()) {
      vector<MFloat> val(it0->second);
      m_nearBoundaryBackup.erase(it0);
      m_nearBoundaryBackup.insert(make_pair(cellId1, val));
    } else if(it1 != m_nearBoundaryBackup.end()) {
      vector<MFloat> val(it1->second);
      m_nearBoundaryBackup.erase(it1);
      m_nearBoundaryBackup.insert(make_pair(cellId0, val));
    }
  }

  if(!m_coarseOldBndryCells.empty()) {
    auto it0 = m_coarseOldBndryCells.find(cellId0);
    auto it1 = m_coarseOldBndryCells.find(cellId1);
    if(it0 != m_coarseOldBndryCells.end() && it1 == m_coarseOldBndryCells.end()) {
      // nothing to be done
    } else if(it0 != m_coarseOldBndryCells.end()) {
      m_coarseOldBndryCells.erase(it0);
      m_coarseOldBndryCells.insert(cellId1);
    } else if(it1 != m_coarseOldBndryCells.end()) {
      m_coarseOldBndryCells.erase(it1);
      m_coarseOldBndryCells.insert(cellId0);
    }
  }

  if(!m_oldGeomBndryCells.empty()) {
    auto it0 = m_oldGeomBndryCells.find(cellId0);
    auto it1 = m_oldGeomBndryCells.find(cellId1);
    if(it0 != m_oldGeomBndryCells.end() && it1 == m_oldGeomBndryCells.end()) {
      std::swap(it0->second, it1->second);
    } else if(it0 != m_oldGeomBndryCells.end()) {
      const MFloat volume = it0->second;
      m_oldGeomBndryCells.erase(it0);
      m_oldGeomBndryCells.insert(make_pair(cellId1, volume));
    } else if(it1 != m_oldGeomBndryCells.end()) {
      const MFloat volume = it1->second;
      m_oldGeomBndryCells.erase(it1);
      m_oldGeomBndryCells.insert(make_pair(cellId0, volume));
    }
  }

  // Swap stored azimuthal near boundary data
  if(grid().azimuthalPeriodicity()) {
    MInt cnt0 = m_azimuthalNearBoundaryBackup.count(cellId0);
    MInt cnt1 = m_azimuthalNearBoundaryBackup.count(cellId1);
    ASSERT(cnt0 < 3 && cnt1 < 3, "cnt should not exceed 2");
    if(cnt0 == 2) {
      auto range = m_azimuthalNearBoundaryBackup.equal_range(cellId0);
      auto it00 = range.first;
      auto it01 = it00++;
      if(cnt1 == 0) {
        {
          pair<vector<MFloat>, vector<MUlong>> tmp(it00->second.first, it00->second.second);
          m_azimuthalNearBoundaryBackup.erase(it00);
          m_azimuthalNearBoundaryBackup.insert(make_pair(cellId1, tmp));
        }
        {
          pair<vector<MFloat>, vector<MUlong>> tmp(it01->second.first, it01->second.second);
          m_azimuthalNearBoundaryBackup.erase(it01);
          m_azimuthalNearBoundaryBackup.insert(make_pair(cellId1, tmp));
        }
      } else if(cnt1 == 1) {
        {
          auto it10 = m_azimuthalNearBoundaryBackup.find(cellId1);
          std::swap(it00->second, it10->second);
        }
        {
          pair<vector<MFloat>, vector<MUlong>> tmp(it01->second.first, it01->second.second);
          m_azimuthalNearBoundaryBackup.erase(it01);
          m_azimuthalNearBoundaryBackup.insert(make_pair(cellId1, tmp));
        }
      } else { // cnt1 == 2
        auto range2 = m_azimuthalNearBoundaryBackup.equal_range(cellId1);
        auto it10 = range2.first;
        auto it11 = it10++;
        std::swap(it00->second, it10->second);
        std::swap(it01->second, it11->second);
      }
    } else if(cnt0 == 1) {
      auto it00 = m_azimuthalNearBoundaryBackup.find(cellId0);
      if(cnt1 == 0) {
        pair<vector<MFloat>, vector<MUlong>> tmp(it00->second.first, it00->second.second);
        m_azimuthalNearBoundaryBackup.erase(it00);
        m_azimuthalNearBoundaryBackup.insert(make_pair(cellId1, tmp));
      } else if(cnt1 == 1) {
        auto it10 = m_azimuthalNearBoundaryBackup.find(cellId1);
        std::swap(it00->second, it10->second);
      } else { // cnt1 == 2
        auto range = m_azimuthalNearBoundaryBackup.equal_range(cellId1);
        auto it10 = range.first;
        auto it11 = it10++;
        std::swap(it00->second, it10->second);
        pair<vector<MFloat>, vector<MUlong>> tmp(it11->second.first, it11->second.second);
        m_azimuthalNearBoundaryBackup.erase(it11);
        m_azimuthalNearBoundaryBackup.insert(make_pair(cellId0, tmp));
      }
    } else { // cnt0 == 0
      if(cnt1 == 0) {
        // Nothing to be done
      } else if(cnt1 == 1) {
        auto it10 = m_azimuthalNearBoundaryBackup.find(cellId1);
        pair<vector<MFloat>, vector<MUlong>> tmp(it10->second.first, it10->second.second);
        m_azimuthalNearBoundaryBackup.erase(it10);
        m_azimuthalNearBoundaryBackup.insert(make_pair(cellId0, tmp));
      } else { // cnt1 == 2
        auto range = m_azimuthalNearBoundaryBackup.equal_range(cellId1);
        auto it10 = range.first;
        auto it11 = it10++;
        {
          pair<vector<MFloat>, vector<MUlong>> tmp(it10->second.first, it10->second.second);
          m_azimuthalNearBoundaryBackup.erase(it10);
          m_azimuthalNearBoundaryBackup.insert(make_pair(cellId0, tmp));
        }
        {
          pair<vector<MFloat>, vector<MUlong>> tmp(it11->second.first, it11->second.second);
          m_azimuthalNearBoundaryBackup.erase(it11);
          m_azimuthalNearBoundaryBackup.insert(make_pair(cellId0, tmp));
        }
      }
    }
  }
}


/**
 * \brief returns a new surface id
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
MInt FvMbCartesianSolverXD<nDim, SysEqn>::getNewSurfaceId() {
  MInt srfcId = -1;

  if(m_freeSurfaceIndices.size() > 0) {
    set<MInt>::iterator it = m_freeSurfaceIndices.begin();
    srfcId = *(it);
    m_freeSurfaceIndices.erase(it);
    if(srfcId >= a_noSurfaces()) {
      srfcId = -1;
      m_freeSurfaceIndices.clear();
    }
  }
  if(srfcId < 0) {
    srfcId = a_noSurfaces();
    m_surfaces.append();
    m_noSurfaces = a_noSurfaces();
  }

  return srfcId;
}


/**
 * \brief computes initial set of internal grid surfaces
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::createInitialSrfcs() {
  TRACE();

  m_log << "Creating initial surfaces..." << endl;

  const MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();
  MFloatScratchSpace surfArea(noBndryCells, m_noDirs, AT_, "surfArea");
  MFloatScratchSpace surfCentroid(noBndryCells, m_noDirs, nDim, AT_, "surfCentroid");
  surfArea.fill(sqrt(-F1));
  surfCentroid.fill(sqrt(-F1));
  for(MInt srfcId = 0; srfcId < a_noSurfaces(); srfcId++) {
    for(MInt side = 0; side < 2; side++) {
      MInt ori = a_surfaceOrientation(srfcId);
      MInt cellId = a_surfaceNghbrCellId(srfcId, side);
      if(cellId > -1) {
        MInt bndryId = a_bndryId(cellId);
        if(bndryId > -1) {
          MInt dir = (side == 0) ? 2 * ori + 1 : 2 * ori;
          surfArea(bndryId, dir) = a_surfaceArea(srfcId);

          for(MInt i = 0; i < nDim; i++) {
            surfCentroid(bndryId, dir, i) = a_surfaceCoordinate(srfcId, i);
          }
        }
      }
    }
  }

  // store all surfaces that have been generated so far (Cartesian cut surfaces)
  //  const MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();

  // delete the surfaces that won't be required later
  // 1) store the relevant surfaces
  MInt counter = 0;
  MInt otherDir[] = {1, 0, 3, 2, 5, 4};
  for(MInt bndryId = 0; bndryId < noBndryCells; bndryId++) {
    MInt cell = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;

    if(!a_hasProperty(cell, SolverCell::IsOnCurrentMGLevel)) continue;
    MInt nghbrId = -1;
    for(MInt dirId = 0; dirId < m_noDirs; dirId++) {
      if(a_hasNeighbor(cell, dirId) > 0) {
        nghbrId = c_neighborId(cell, dirId);
      } else {
        if(c_parentId(cell) > -1) {
          if(a_hasNeighbor(c_parentId(cell), dirId) > 0) {
            nghbrId = c_neighborId(c_parentId(cell), dirId);
          } else {
            continue;
          }
        } else {
          continue;
        }
      }

      if(a_bndryId(nghbrId) < 0) continue;
      MBool createSrfc = true;
      // check conditions for surface generation
      // (1) no master-slave interface
      // (2) no slave-slave interface if both slave cells have the same master
      // (3) no periodic-periodic interface
      if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId > -1) {
        if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId == nghbrId
           || m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId
                  == m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId) {
          createSrfc = false;
        }
      }
      if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId > -1) {
        if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId == (MInt)cell
           || m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId
                  == m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId) {
          createSrfc = false;
        }
      }
      if(a_isPeriodic(cell) && a_isPeriodic(nghbrId)) createSrfc = false;

      // do not create a surface between two halo cells
      // create a surface if slave-neighbor are both halo cells but the master is not
      if(a_isHalo(cell) && a_isHalo(nghbrId)) {
        if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId == -1
           && m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_linkedCellId == -1) {
          createSrfc = false;
        }
      }

      // this is valid for isotropical refinement only!!
      if(!createSrfc) continue;

      if((a_level(cell) > a_level(nghbrId)) || ((a_level(cell) == a_level(nghbrId)) && dirId % 2 == 0)) {
        MInt oldSrfcId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_associatedSrfc[dirId];

        if(oldSrfcId < 0) continue;

        if(oldSrfcId != counter) {
          m_surfaces.copy(oldSrfcId, counter);
          m_surfaces.erase(oldSrfcId);
          if(a_level(cell) == a_level(nghbrId))
            m_fvBndryCnd->m_bndryCells->a[a_bndryId(nghbrId)].m_associatedSrfc[otherDir[dirId]] = counter;
        }
        counter++;
      }
    }
  }

  // delete all other surfaces created in createCutFace
  while(a_noSurfaces() > counter) {
    MInt size = a_noSurfaces();
    m_surfaces.erase(size - 1);
    m_surfaces.size(size - 1);
  }

  // store relevant surface information in scratch space
  MInt noSurfaces = a_noSurfaces();
  MIntScratchSpace surfaceOrientation(noSurfaces, AT_, "surfaceOrientation");
  MFloatScratchSpace surfaceArea(noSurfaces, AT_, "surfaceArea");
  MIntScratchSpace surfaceNeighbors(noSurfaces, 2, AT_, "surfaceNeighbors");
  MFloatScratchSpace surfaceCentroid(noSurfaces, nDim, AT_, "surfaceCentroid");
  for(MInt s = 0; s < noSurfaces; s++) {
    surfaceOrientation[s] = a_surfaceOrientation(s);
    surfaceArea[s] = a_surfaceArea(s);
    surfaceNeighbors(s, 0) = a_surfaceNghbrCellId(s, 0);
    surfaceNeighbors(s, 1) = a_surfaceNghbrCellId(s, 1);
    for(MInt i = 0; i < nDim; i++) {
      surfaceCentroid(s, i) = a_surfaceCoordinate(s, i);
    }
  }

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    if(a_isBndryGhostCell(cellId)) continue;
    if(c_noChildren(cellId) > 0) continue;
    removeSurfaces(cellId);
  }
  m_surfaces.clear();

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    if(a_bndryId(cellId) < -1) continue;
    if(a_isBndryGhostCell(cellId)) continue;
    if(c_noChildren(cellId) > 0) continue;
    if(a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    restoreSurfaces(cellId);
  }

  m_log << a_noSurfaces() << endl;

  // correct cut surfaces of outer boundary cells with the previously generated surface information
  // first set the associatedSrfc pointers correctly
  for(MInt bndryId = 0; bndryId < m_bndryCells->size(); bndryId++)
    for(MInt dir = 0; dir < m_noDirs; dir++)
      m_fvBndryCnd->m_bndryCells->a[bndryId].m_associatedSrfc[dir] = -1;

  for(MInt srfcId = 0; srfcId < a_noSurfaces(); srfcId++) {
    MInt nghbr0 = a_surfaceNghbrCellId(srfcId, 0);
    MInt nghbr1 = a_surfaceNghbrCellId(srfcId, 1);
    ASSERT(nghbr0 > -1 && nghbr1 > -1 && nghbr0 < a_noCells() && nghbr1 < a_noCells(), "");
    MInt bndryIdN0 = a_bndryId(nghbr0);
    MInt bndryIdN1 = a_bndryId(nghbr1);
    if(bndryIdN0 > -1 && bndryIdN1 > -1) {
      MInt dirN0 = 2 * a_surfaceOrientation(srfcId) + 1;
      MInt dirN1 = 2 * a_surfaceOrientation(srfcId) + 0;
      MInt level0 = a_level(nghbr0);
      MInt level1 = a_level(nghbr1);
      if(level0 >= level1) m_fvBndryCnd->m_bndryCells->a[bndryIdN0].m_associatedSrfc[dirN0] = srfcId;
      if(level1 >= level0) m_fvBndryCnd->m_bndryCells->a[bndryIdN1].m_associatedSrfc[dirN1] = srfcId;


      a_surfaceArea(srfcId) = surfArea(bndryIdN0, dirN0);
      for(MInt i = 0; i < nDim; i++) {
        a_surfaceCoordinate(srfcId, i) = surfCentroid(bndryIdN0, dirN0, i);
      }
    }
  }

  // then run over the previously created surfaces and correct the information of the newly created surfaces
  for(MInt s = 0; s < noSurfaces; s++) {
    MInt nghbr0 = surfaceNeighbors(s, 0);
    MInt nghbr1 = surfaceNeighbors(s, 1);
    if(nghbr0 < 0 || nghbr1 < 0) continue;
    ASSERT(nghbr0 > -1 && nghbr1 > -1 && nghbr0 < a_noCells() && nghbr1 < a_noCells(), "");
    MInt bndryIdN0 = a_bndryId(nghbr0);
    MInt bndryIdN1 = a_bndryId(nghbr1);
    if(bndryIdN0 > -1 && bndryIdN1 > -1) {
      MInt dirN0 = 2 * surfaceOrientation(s) + 1;
      MInt dirN1 = 2 * surfaceOrientation(s) + 0;
      MInt level0 = a_level(nghbr0);
      MInt level1 = a_level(nghbr1);
      if(level0 == level1) {
        MInt associatedSrfc0 = m_fvBndryCnd->m_bndryCells->a[bndryIdN0].m_associatedSrfc[dirN0];
        MInt associatedSrfc1 = m_fvBndryCnd->m_bndryCells->a[bndryIdN1].m_associatedSrfc[dirN1];
        ASSERT(associatedSrfc0 == associatedSrfc1, "");
      }
      MInt associatedSrfc = (level0 > level1) ? m_fvBndryCnd->m_bndryCells->a[bndryIdN0].m_associatedSrfc[dirN0]
                                              : m_fvBndryCnd->m_bndryCells->a[bndryIdN1].m_associatedSrfc[dirN1];
      if(associatedSrfc < 0)
        cerr << "surface info " << nghbr0 << " " << nghbr1 << " " << c_globalId(nghbr0) << " " << c_globalId(nghbr1)
             << " / " << level0 << " " << level1 << " " << dirN0 << " " << dirN1 << " / "
             << m_fvBndryCnd->m_bndryCells->a[bndryIdN0].m_associatedSrfc[dirN0] << " "
             << m_fvBndryCnd->m_bndryCells->a[bndryIdN1].m_associatedSrfc[dirN1] << " / "
             << a_hasProperty(nghbr0, SolverCell::IsInactive) << " " << a_hasProperty(nghbr1, SolverCell::IsInactive)
             << " / " << a_hasProperty(nghbr0, SolverCell::IsNotGradient) << " "
             << a_hasProperty(nghbr1, SolverCell::IsNotGradient) << " / " << surfaceCentroid(s, 0) << " "
             << surfaceCentroid(s, 1) << " " << surfaceCentroid(s, nDim - 1) << endl;
      // ASSERT( associatedSrfc > -1 && associatedSrfc < a_noSurfaces(), to_string(associatedSrfc));
      if(associatedSrfc > -1) {
        ASSERT(associatedSrfc > -1 && associatedSrfc < a_noSurfaces(), to_string(associatedSrfc));
        ASSERT(a_surfaceOrientation(associatedSrfc) == surfaceOrientation(s), "");
        ASSERT(a_surfaceNghbrCellId(associatedSrfc, 0) == surfaceNeighbors(s, 0), "");
        ASSERT(a_surfaceNghbrCellId(associatedSrfc, 1) == surfaceNeighbors(s, 1), "");
      }
    }
  }

  m_log << "...done." << endl;
  m_log << a_noSurfaces() << " surfaces created." << endl;
}


/**
 * \brief computes the reconstruction constants using inverse distance weighted least squares
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::computeReconstructionConstants() {
  TRACE();

  m_reconstructionConstants.clear();
  m_reconstructionCellIds.clear();
  m_reconstructionNghbrIds.clear();

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {

    // reset number of reconstruction Neighbors for all cells!
    a_noReconstructionNeighbors(cellId) = 0;

    if(a_isBndryGhostCell(cellId)) continue;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(!a_hasProperty(cellId, SolverCell::IsFlux)) continue;
    if(a_bndryId(cellId) == -2) continue;
    if(a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    if(c_noChildren(cellId) > 0) continue;
    if(a_bndryId(cellId) > -1) {
      if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_linkedCellId > -1) continue;
    }
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    // recompute number of reconstruction constants for relevant cells
    rebuildReconstructionConstants(cellId);
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::exchange() {
  TRACE();

#if defined _MB_DEBUG_ || !defined NDEBUG

  for(MInt i = 0; i < noNeighborDomains(); i++) {
    for(MInt j = 0; j < m_noMaxLevelWindowCells[i]; j++) {
      MInt cellId = m_maxLevelWindowCells[i][j];
      for(MInt v = 0; v < m_noPVars; v++) {
        if(std::isnan(a_pvariable(cellId, v))) {
          cerr << domainId() << ": nan send " << cellId << " " << a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)
               << " " << a_hasProperty(cellId, SolverCell::IsInactive) << " " << c_noChildren(cellId) << " "
               << a_levelSetValuesMb(cellId, 0) << endl;
        }
      }
    }
  }
#endif

  FvCartesianSolverXD<nDim, SysEqn>::exchange();

  // temporary split cell fix: all split childs receive the variables of their parents!
  for(MInt sc = 0; (unsigned)sc < m_splitCells.size(); sc++) {
    MInt scId = m_splitCells[sc];
    for(MInt ssc = 0; (unsigned)ssc < m_splitChilds[sc].size(); ssc++) {
      MInt splitChildId = m_splitChilds[sc][ssc];
      for(MInt v = 0; v < m_noCVars; v++) {
        a_variable(splitChildId, v) = a_variable(scId, v);
      }
      for(MInt v = 0; v < m_noPVars; v++) {
        a_pvariable(splitChildId, v) = a_pvariable(scId, v);
      }
    }
  }


#ifdef _MB_DEBUG_

  if(!isMultilevel() || isMultilevelPrimary()) {
    m_solutionDiverged = false;
    MInt cnt = 0;
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      for(MInt j = 0; j < m_noMaxLevelHaloCells[i]; j++) {
        MInt cellId = m_maxLevelHaloCells[i][j];
        if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
        ASSERT(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel), "");
        for(MInt v = 0; v < m_noPVars; v++) {
          if(!(a_pvariable(cellId, v) >= F0 || a_pvariable(cellId, v) < F0) || std::isnan(a_pvariable(cellId, v))) {
            cerr << domainId() << ": EXC " << i << " " << j << " " << c_globalId(cellId) << " " << a_bndryId(cellId)
                 << " " << a_level(cellId) << " /v " << a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId))
                 << " " << m_cellVolumesDt1[cellId] / grid().gridCellVolume(a_level(cellId)) << " " << v << " "
                 << a_variable(cellId, v) << " /l " << a_levelSetValuesMb(cellId, 0) / c_cellLengthAtCell(cellId) << " "
                 << a_coordinate(cellId, 0) << " " << a_coordinate(cellId, 1) << " "
                 << a_coordinate(cellId, mMin((MInt)FD, 2)) << " "
                 << a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) << endl;
            m_solutionDiverged = true;
            cnt++;
          }
        }
        // if ( a_cellVolume(cellId)/grid().gridCellVolume(a_level(cellId)) > m_fvBndryCnd->m_volumeLimitWall ) {
        if(a_pvariable(cellId, PV->RHO) < F0 || a_pvariable(cellId, PV->P) < F0) {
          cerr << domainId() << ": EXC2 " << i << " " << j << " " << neighborDomain(i) << " / " << c_globalId(cellId)
               << " " << a_bndryId(cellId) << " " << a_level(cellId) << " /r " << a_pvariable(cellId, PV->RHO) << " /p "
               << a_pvariable(cellId, PV->P) << " /v " << a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId))
               << " " << m_cellVolumesDt1[cellId] / grid().gridCellVolume(a_level(cellId)) << " /l "
               << a_levelSetValuesMb(cellId, 0) / c_cellLengthAtCell(cellId) << " " << a_coordinate(cellId, 0) << " "
               << a_coordinate(cellId, 1) << " " << a_coordinate(cellId, mMin((MInt)FD, 2)) << " "
               << a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) << endl;
          m_solutionDiverged = true;
          cnt++;
        }
        //}
        if(cnt >= 10) break;
      }
      if(cnt >= 10) break;
    }
    if(cnt >= 10) cerr << "More than 10 errors. Not reporting any more." << endl;
    if(m_solutionDiverged) {
      cerr << "Solution diverged (EXC) at solver " << domainId() << " " << globalTimeStep << " " << m_RKStep << endl;
    }
    MPI_Allreduce(MPI_IN_PLACE, &m_solutionDiverged, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                  "m_solutionDiverged");

    if(m_solutionDiverged) {
      writeVtkXmlFiles("QOUT", "GEOM", false, true);
      MPI_Barrier(mpiComm(), AT_);
      mTerm(1, AT_, "Solution diverged after exchange.");
    }
  }
#endif

  // only at leaf-level should be sufficient!
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    for(MInt j = 0; j < m_noMaxLevelHaloCells[i]; j++) {
      const MInt cellId = m_maxLevelHaloCells[i][j];
      setConservativeVariables(cellId);
    }
  }
}


/**
 * \brief computes the reconstruction constants using inverse distance weighted least squares
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::rebuildReconstructionConstants(MInt cellId) {
  const MInt recDim = (m_orderOfReconstruction == 2) ? (IPOW2(nDim) + 1) : nDim;
  const MInt maxNoNghbrs = 150;

  MIntScratchSpace nghbrList(maxNoNghbrs, AT_, "nghbrList");
  MIntScratchSpace layerId(maxNoNghbrs, AT_, "layerList");

  if(c_noChildren(cellId) > 0 || a_hasProperty(cellId, SolverCell::IsNotGradient)
     || !a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
    cerr << domainId() << " Warning: trying to rebuild stencil of cell " << cellId << " with " << c_noChildren(cellId)
         << " children and prop-7=" << a_hasProperty(cellId, SolverCell::IsNotGradient)
         << ", prop-13=" << a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) << ", level=" << a_level(cellId)
         << ", inact=" << a_hasProperty(cellId, SolverCell::IsInactive) << ". Skipped." << endl;
    a_noReconstructionNeighbors(cellId) = 0;
    return;
  }

  const MInt counter = this->template getAdjacentLeafCells<0, true>(cellId, 1, nghbrList, layerId);

  if(counter > maxNoNghbrs) {
    mTerm(1, AT_, "too many nghbrs " + to_string(counter));
  }
  a_noReconstructionNeighbors(cellId) = 0;

  if(a_bndryId(cellId) > -1) {
    for(MInt srfc = 0; srfc < m_bndryCells->a[a_bndryId(cellId)].m_noSrfcs; srfc++) {
      MInt ghostCellId = m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_srfcVariables[srfc]->m_ghostCellId;
      if(ghostCellId < 0) cerr << a_coordinate(cellId, 0) << " " << a_coordinate(cellId, 1) << endl;
      if(ghostCellId < 0)
        mTerm(1, AT_,
              "ghostCellId not set! " + to_string(cellId) + " " + to_string(a_bndryId(cellId)) + " "
                  + to_string(ghostCellId) + " " + to_string(srfc) + " " + to_string(a_isHalo(cellId)) + " "
                  + to_string(a_isBndryGhostCell(cellId)));
      a_reconstructionNeighborId(cellId, a_noReconstructionNeighbors(cellId)) = ghostCellId;
      a_noReconstructionNeighbors(cellId)++;
    }
  }

  MBool atInterface = false;
  for(MInt k = 0; k < counter; k++) {
    MInt nghbrId = nghbrList[k];
    if(nghbrId < 0) continue;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    a_reconstructionNeighborId(cellId, a_noReconstructionNeighbors(cellId)) = nghbrId;
    a_noReconstructionNeighbors(cellId)++;
    if(a_noReconstructionNeighbors(cellId) > m_cells.noRecNghbrs()) {
      mTerm(1, AT_, "too many rec nghbrs " + to_string(cellId));
    }
    if(a_level(nghbrId) < a_level(cellId)) {
      atInterface = true;
    }
  }

  // use a different stencil at level-jumps for local-time stepping
  //(more stable, i.e. larger CFL!)
  if(m_localTS && atInterface) {
    const MInt counter2 = this->template getAdjacentLeafCells<2, true>(cellId, 1, nghbrList, layerId);
    for(MInt k = 0; k < counter2; k++) {
      MInt nghbrId = nghbrList[k];
      if(nghbrId < 0) {
        continue;
      }
      if(a_hasProperty(nghbrId, SolverCell::IsInvalid)) {
        continue;
      }
      if(a_level(nghbrId) >= a_level(cellId)) {
        continue;
      }
      MBool exist = false;
      for(MInt i = 0; i < a_noReconstructionNeighbors(cellId); i++) {
        if(a_reconstructionNeighborId(cellId, i) == nghbrId) {
          exist = true;
          break;
        }
      }
      if(!exist) {
        a_reconstructionNeighborId(cellId, a_noReconstructionNeighbors(cellId)) = nghbrId;
        a_noReconstructionNeighbors(cellId)++;
      }
      if(a_noReconstructionNeighbors(cellId) > m_cells.noRecNghbrs()) {
        mTerm(1, AT_, "too many rec nghbrs " + to_string(cellId) + " " + to_string(counter));
      }
    }
  }


  const MInt noNghbrIds = a_noReconstructionNeighbors(cellId);

  MFloatScratchSpace tmpA(noNghbrIds, recDim, AT_, "tmpA");
  MFloatScratchSpace tmpC(recDim, noNghbrIds, AT_, "tmpC");
  MFloatScratchSpace weights(noNghbrIds, AT_, "weights");

  ASSERT(!a_hasProperty(cellId, SolverCell::IsNotGradient) && c_isLeafCell(cellId),
         "a_hasProperty(cellId, SolverCell::IsNotGradient) "
             + std::to_string(a_hasProperty(cellId, SolverCell::IsNotGradient)) + " c_isLeafCell(cellId) "
             + std::to_string(c_isLeafCell(cellId)));

  const MInt offset = m_cells.noRecNghbrs() * cellId;
  computeRecConstSVD(cellId, offset, tmpA, tmpC, weights, recDim, 0, -1);
}


/**
 * \brief Least squares reconstruction
 * \author Lennart Schneiders
 * \date 28.10.2011
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::leastSquaresReconstruction() {
  TRACE();
  TERMM_IF_COND(m_reConstSVDWeightMode == 3 || m_reConstSVDWeightMode == 4, "Not yet implemented!");

  MFloat* RESTRICT slope = (MFloat*)(&(a_slope(0, 0, 0)));
  MFloat* RESTRICT vars = (MFloat*)(&(a_pvariable(0, 0)));
  const MInt noCells = a_noCells();

  std::fill_n(slope, noCells * m_noSlopes, 0.0);

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt cellId = 0; cellId < noCells; cellId++) {
    if(a_hasProperty(cellId, SolverCell::IsNotGradient)) {
      continue;
    }
    if(a_isBndryGhostCell(cellId)) {
      continue;
    }
    if(a_hasProperty(cellId, SolverCell::IsInactive)) {
      continue;
    }

    const MInt k = m_noSlopes * cellId;
    const MInt offset = nDim * a_reconstructionData(cellId);
    for(MInt n = a_noReconstructionNeighbors(cellId); n--;) {
      for(MInt v = 0; v < m_noPVars; v++) {
        IF_CONSTEXPR(nDim == 3) {
#ifdef _OPENMP
#pragma omp atomic
#endif
          slope[k + nDim * v + 2] +=
              m_reconstructionConstants[offset + n * nDim + 2]
              * (vars[m_noPVars * a_reconstructionNeighborId(cellId, n) + v] - vars[m_noPVars * cellId + v]);
        }
#ifdef _OPENMP
#pragma omp atomic
#endif
        slope[k + nDim * v + 1] +=
            m_reconstructionConstants[offset + n * nDim + 1]
            * (vars[m_noPVars * a_reconstructionNeighborId(cellId, n) + v] - vars[m_noPVars * cellId + v]);
#ifdef _OPENMP
#pragma omp atomic
#endif
        slope[k + nDim * v] +=
            m_reconstructionConstants[offset + n * nDim]
            * (vars[m_noPVars * a_reconstructionNeighborId(cellId, n) + v] - vars[m_noPVars * cellId + v]);
      }
    }
  }

  if(!m_useCentralDifferencingSlopes) {
    return;
  }

  MBoolScratchSpace atBnd(noCells, AT_, "atBnd");
  MBoolScratchSpace nearBnd(noCells, AT_, "nearBnd");
  atBnd.fill(false);
  nearBnd.fill(false);
  array<MFloat, 20> centralDiffConst;
  std::vector<std::vector<MInt>> structuredCells(maxLevel() - minLevel() + 1);
  std::vector<MInt> nearBoundaryCells;

  for(MInt level = minLevel(); level <= maxLevel(); level++) {
    structuredCells[level - minLevel()].clear();
  }

  for(MInt level = minLevel(); level <= maxRefinementLevel(); level++) {
    centralDiffConst[level] = 1.0 / (2.0 * c_cellLengthAtLevel(level));
  }

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt bndryId = 0; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      continue;
    }

    atBnd(cellId) = true;
    MInt parentId = a_hasProperty(cellId, SolverCell::IsSplitChild) ? c_parentId(getAssociatedInternalCell(cellId))
                                                                    : c_parentId(cellId);
    while(parentId > -1) {
      atBnd(parentId) = true;
      parentId = c_parentId(parentId);
    }
  }

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt cellId = 0; cellId < noCells; cellId++) {
    if(a_bndryId(cellId) < -1) continue;
    if(a_hasProperty(cellId, SolverCell::IsCutOff)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;

    if(atBnd(cellId)) {
      nearBoundaryCells.push_back(cellId);
      nearBnd(cellId) = true;
      continue;
    }
    MBool nearb = false;
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      if(!a_hasNeighbor(cellId, dir)) {
        MInt parentId = c_parentId(cellId);
        while(parentId > -1) {
          if(a_hasNeighbor(parentId, dir)) {
            if(atBnd(c_neighborId(parentId, dir))) {
              nearb = true;
            }
            break;
          }
          parentId = c_parentId(parentId);
        }
      } else if(atBnd(c_neighborId(cellId, dir))) {
        nearb = true;
        break;
      }
    }
    if(nearb) {
      nearBoundaryCells.push_back(cellId);
      nearBnd(cellId) = true;
      continue;
    }
  }

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt cellId = 0; cellId < noCells; cellId++) {
    if(a_bndryId(cellId) != -1) continue;
    if(a_hasProperty(cellId, SolverCell::IsCutOff)) continue;
    if(nearBnd(cellId)) continue;
    if(!c_isLeafCell(cellId)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) {
      nearBnd(cellId) = true;
      MInt parentId = c_parentId(cellId);
      while(parentId > -1) {
        nearBnd(parentId) = true;
        parentId = c_parentId(parentId);
      }
    }
  }

  for(MInt level = minLevel(); level <= maxLevel(); level++) {
    structuredCells[level - minLevel()].clear();
  }
#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt cellId = 0; cellId < noCells; cellId++) {
    if(a_bndryId(cellId) < -1) continue;
    if(a_hasProperty(cellId, SolverCell::IsCutOff)) continue;
    if(nearBnd(cellId)) continue;
    if(a_hasProperty(cellId, SolverCell::AtStructuredRegion)) {
      structuredCells[c_level(cellId) - minLevel()].push_back(cellId);
    }
  }

#ifdef _OPENMP
#pragma omp parallel for
#endif
  // TODO labels:FVMB this is just debug and should only be applied for debug-compilation
  for(MInt cellId = 0; cellId < noCells; cellId++) {
    if(a_bndryId(cellId) < -1) continue;
    if(a_hasProperty(cellId, SolverCell::IsCutOff)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(!a_hasProperty(cellId, SolverCell::AtStructuredRegion) && !nearBnd(cellId)
       && !(c_parentId(cellId) > -1 && a_hasProperty(c_parentId(cellId), SolverCell::AtStructuredRegion)))
      cerr << "strng " << c_globalId(cellId) << " " << a_coordinate(cellId, 0) << " " << a_coordinate(cellId, 1) << " "
           << a_hasProperty(cellId, Cell::IsHalo) << " " << c_neighborId(cellId, 0) << " " << c_neighborId(cellId, 1)
           << " " << c_neighborId(cellId, 2) << " " << c_neighborId(cellId, 3) << endl;
    ASSERT(a_hasProperty(cellId, SolverCell::AtStructuredRegion) || nearBnd(cellId)
               || (c_parentId(cellId) > -1 && a_hasProperty(c_parentId(cellId), SolverCell::AtStructuredRegion)),
           to_string(c_globalId(cellId)));
  }


  for(MInt level = minLevel(); level <= maxRefinementLevel(); level++) {
    const MFloat fdx = centralDiffConst[level];
    for(MUint c = 0; c < structuredCells[level - minLevel()].size(); c++) {
      MInt cellId = structuredCells[level - minLevel()][c];
      const MInt k = m_noSlopes * cellId;
      for(MInt i = 0; i < nDim; i++) {
        MInt n0 = c_neighborId(cellId, 2 * i);
        MInt n1 = c_neighborId(cellId, 2 * i + 1);
        ASSERT(!atBnd(n0) && !atBnd(n1) && !nearBnd(cellId), "");
        for(MInt v = 0; v < m_noPVars; v++) {
          slope[k + nDim * v + i] = fdx * (a_pvariable(n1, v) - a_pvariable(n0, v));
        }
      }
      if(!c_isLeafCell(cellId)) {
        for(MInt child = 0; child < m_noCellNodes; child++) {
          const MInt childId = c_childId(cellId, child);
          if(childId < 0) continue;
          if(a_hasProperty(childId, SolverCell::AtStructuredRegion)) continue;
          for(MInt i = 0; i < nDim; i++) {
            for(MInt v = 0; v < m_noPVars; v++) {
              a_slope(childId, v, i) = a_slope(cellId, v, i);
            }
          }
        }
      }
    }
  }

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(MInt cellId = noCells; cellId > 0; cellId--) {
    if(!nearBnd(cellId)) continue;

    const MInt k = m_noSlopes * cellId;
    const MInt offset = nDim * a_reconstructionData(cellId);
    std::fill_n(&slope[k], m_noPVars * nDim, F0);
    for(MInt n = a_noReconstructionNeighbors(cellId); n--;) {
      for(MInt v = m_noPVars; v--;) {
        IF_CONSTEXPR(nDim == 3) {
#ifdef _OPENMP
#pragma omp atomic
#endif
          slope[k + nDim * v + 2] +=
              m_reconstructionConstants[offset + n * nDim + 2]
              * (vars[m_noPVars * a_reconstructionNeighborId(cellId, n) + v] - vars[m_noPVars * cellId + v]);
        }
#ifdef _OPENMP
#pragma omp atomic
#endif
        slope[k + nDim * v + 1] +=
            m_reconstructionConstants[offset + n * nDim + 1]
            * (vars[m_noPVars * a_reconstructionNeighborId(cellId, n) + v] - vars[m_noPVars * cellId + v]);
#ifdef _OPENMP
#pragma omp atomic
#endif
        slope[k + nDim * v] +=
            m_reconstructionConstants[offset + n * nDim]
            * (vars[m_noPVars * a_reconstructionNeighborId(cellId, n) + v] - vars[m_noPVars * cellId + v]);
      }
    }
  }

#ifndef NDEBUG
  static constexpr MBool test1 = false;
  static constexpr MBool test2 = false;

  // TEST1
  if(test1) {
    // also central differences when only possible in single direction
    for(MInt level = minLevel(); level <= maxRefinementLevel(); level++) {
      for(MInt cellId = noCells; cellId--;) {
        if(atBnd(cellId)) continue;
        if(nearBnd(cellId)) continue;
        if(a_bndryId(cellId) < -1) continue;
        if(a_hasProperty(cellId, SolverCell::AtStructuredRegion)) continue;
        // MInt level = c_level(cellId);
        if(level != c_level(cellId)) continue;
        const MFloat fdx = centralDiffConst[level];
        const MInt k = m_noSlopes * cellId;
        for(MInt i = 0; i < nDim; i++) {
          MInt n0 = c_neighborId(cellId, 2 * i);
          MInt n1 = c_neighborId(cellId, 2 * i + 1);
          if(n0 > -1 && n1 > -1) {
            if(!atBnd(n0) && !atBnd(n1)) {
              ASSERT(!atBnd(n0) && !atBnd(n1) && !nearBnd(cellId), "");
              for(MInt v = 0; v < m_noPVars; v++) {
                slope[k + nDim * v + i] = fdx * (a_pvariable(n1, v) - a_pvariable(n0, v));
                // a_slope( cellId, v, i ) = fdx * ( a_pvariable(n1,v) - a_pvariable(n0,v) );
              }

              if(!c_isLeafCell(cellId)) {
                for(MInt child = 0; child < m_noCellNodes; child++) {
                  MInt childId = c_childId(cellId, child);
                  if(childId < 0) continue;
                  if(a_hasProperty(childId, SolverCell::AtStructuredRegion)) continue;
                  for(MInt v = 0; v < m_noPVars; v++) {
                    a_slope(childId, v, i) = a_slope(cellId, v, i);
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // TEST2
  if(test2) {
    // fine to coarse interace use least squares
    for(MInt cellId = noCells; cellId--;) {
      if(atBnd(cellId)) continue;
      if(nearBnd(cellId)) continue;
      if(a_bndryId(cellId) < -1) continue;
      if(!a_hasProperty(cellId, SolverCell::AtStructuredRegion)) continue;
      if(!c_isLeafCell(cellId)) {
        for(MInt child = 0; child < m_noCellNodes; child++) {
          MInt childId = c_childId(cellId, child);
          if(childId < 0) continue;
          if(a_hasProperty(childId, SolverCell::AtStructuredRegion)) continue;

          const MInt k = m_noSlopes * childId;
          // const MInt offset = nDim * m_cells.noRecNghbrs() * childId;
          const MInt offset = nDim * a_reconstructionData(childId);
          std::fill_n(&slope[k], m_noPVars * nDim, F0);
          for(MInt n = a_noReconstructionNeighbors(childId); n--;) {
            for(MInt v = m_noPVars; v--;) {
              IF_CONSTEXPR(nDim == 3) {
                slope[k + nDim * v + 2] +=
                    m_reconstructionConstants[offset + n * nDim + 2]
                    * (vars[m_noPVars * a_reconstructionNeighborId(childId, n) + v] - vars[m_noPVars * childId + v]);
              }
              slope[k + nDim * v + 1] +=
                  m_reconstructionConstants[offset + n * nDim + 1]
                  * (vars[m_noPVars * a_reconstructionNeighborId(childId, n) + v] - vars[m_noPVars * childId + v]);
              slope[k + nDim * v] +=
                  m_reconstructionConstants[offset + n * nDim]
                  * (vars[m_noPVars * a_reconstructionNeighborId(childId, n) + v] - vars[m_noPVars * childId + v]);
            }
          }
        }
      }
    }
  }
#endif
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::applyDirichletCondition() {
#ifndef NDEBUG
  const MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();
  for(MInt bndryId = m_noOuterBndryCells; bndryId < noBndryCells; bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    ASSERT(a_associatedBodyIds(cellId, 0) > -1
               && a_associatedBodyIds(cellId, 0) < m_noEmbeddedBodies + m_noPeriodicGhostBodies,
           "associated body is invalid: " + to_string(0) + "/" + to_string(a_associatedBodyIds(cellId, 0)) + " "
               + to_string(c_globalId(cellId)));
  }
#endif

  m_fvBndryCnd->updateGhostCellVariables();
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::applyNeumannCondition() {
#ifndef NDEBUG
  const MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();
  for(MInt bndryId = m_noOuterBndryCells; bndryId < noBndryCells; bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    ASSERT(a_associatedBodyIds(cellId, 0) > -1
               && a_associatedBodyIds(cellId, 0) < m_noEmbeddedBodies + m_noPeriodicGhostBodies,
           "associated body is invalid: " + to_string(0) + "/" + to_string(a_associatedBodyIds(cellId, 0)));
  }
#endif

  m_fvBndryCnd->applyNeumannBoundaryCondition();
}


/**
 * \brief Sets the boundry velocity at the moving cut-cells.
 *        sets: m_primVars[PV->VV[i]] to m_bodyVelocity[i] for all bodies
 * \author Lennart Schneiders, Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::setBoundaryVelocity() {
  TRACE();

  if(!m_constructGField) {
    // levelset forced motion

    const MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();
    for(MInt bndryId = m_noOuterBndryCells; bndryId < noBndryCells; bndryId++) {
      const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;

      if(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
        for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
          const MInt bodyId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bodyId[0];
          ASSERT(bodyId > -1 && bodyId < m_noEmbeddedBodies + m_noPeriodicGhostBodies, "");
          for(MInt i = 0; i < nDim; i++) {
            m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] =
                m_bodyVelocity[bodyId * nDim + i];
          }

          if(m_LsRotate) {
            MFloat vrad[3] = {F0, F0, F0};
            MFloat dx[3] = {F0, F0, F0};
            MFloat omega[3] = {F0, F0, F0};
            for(MInt i = 0; i < nDim; i++) {
              dx[i] = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i]
                      - m_bodyCenter[bodyId * nDim + i];
            }

            for(MInt i = 0; i < 3; i++) {
              omega[i] = m_bodyAngularVelocity[bodyId * 3 + i];
            }

            vrad[0] = omega[1] * dx[2] - omega[2] * dx[1];
            vrad[1] = omega[2] * dx[0] - omega[0] * dx[2];

            IF_CONSTEXPR(nDim == 3) { vrad[2] = omega[0] * dx[1] - omega[1] * dx[0]; }
            else {
              mTerm(1, AT_, "TODO");
            }

            for(MInt i = 0; i < nDim; i++) {
              m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] += vrad[i];
            }
          }

          if(m_closeGaps && m_gapInitMethod == 0 && a_isGapCell(cellId)) {
            const MInt gapCellId = m_gapCellId[cellId];
            ASSERT(gapCellId > -1, "");
            for(MInt i = 0; i < nDim; i++) {
              m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] =
                  m_gapCells[gapCellId].surfaceVelocity[i];
            }
          }
        }
      }
    }
  } else {
    // translation and rotational body based on the fv-solver!
    const MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();
    for(MInt bndryId = m_noOuterBndryCells; bndryId < noBndryCells; bndryId++) {
      for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        const MInt bodyId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bodyId[0];
        ASSERT(bodyId > -1 && bodyId < m_noEmbeddedBodies + m_noPeriodicGhostBodies, "");
        for(MInt i = 0; i < nDim; i++) {
          m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] =
              m_bodyVelocity[bodyId * nDim + i];
        }
        MFloat dx[3] = {F0, F0, F0};
        MFloat omega[3] = {F0, F0, F0};
        MFloat vrad[3] = {F0, F0, F0};
        for(MInt i = 0; i < nDim; i++) {
          dx[i] =
              m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[i] - m_bodyCenter[bodyId * nDim + i];
        }
        for(MInt i = 0; i < 3; i++) {
          omega[i] = m_bodyAngularVelocity[bodyId * 3 + i];
        }
        vrad[0] = omega[1] * dx[2] - omega[2] * dx[1];
        vrad[1] = omega[2] * dx[0] - omega[0] * dx[2];
        IF_CONSTEXPR(nDim == 3) { vrad[2] = omega[0] * dx[1] - omega[1] * dx[0]; }
        for(MInt i = 0; i < nDim; i++) {
          m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] += vrad[i];
        }

        if(m_euler) {
          MFloat vel[3];
          MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
          for(MInt i = 0; i < nDim; i++) {
            vel[i] = a_pvariable(cellId, PV->VV[i]);
            for(MInt j = 0; j < nDim; j++) {
              vel[i] += m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i]
                        * (m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]]
                           - a_pvariable(cellId, PV->VV[j]))
                        * m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[j];
            }
          }
          for(MInt i = 0; i < nDim; i++) {
            m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] = vel[i];
          }
        }
      }
    }
  }
}


/** \brief sets the interpolated velocity for a bndryCell
 *         NOTE: all neighbors need to be available for levelset-interpolation!
 *  \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::interpolateGapBodyVelocity() {
  ASSERT(!m_deleteNeighbour, "");

  std::function<MBool(const MInt, const MInt)> alwaysTrue = [&](const MInt, const MInt) { return true; };

  for(MUint it = 0; it < m_gapCells.size(); it++) {
    const MInt cellId = m_gapCells[it].cellId;
    const MInt bndryId = a_bndryId(cellId);
    if(bndryId < 0) continue;

    MInt gridCellId = cellId;
    if(a_hasProperty(cellId, SolverCell::IsSplitChild)) {
      gridCellId = getAssociatedInternalCell(cellId);
    }
    const MInt regionId = m_gapCells[it].region;
    if(m_gapInitMethod > 0 && regionId != m_noGapRegions) continue;

    const MInt body1 = a_associatedBodyIds(gridCellId, 0);

    for(MInt i = 0; i < nDim; i++) {
      m_gapCells[it].surfaceVelocity[i] = m_bodyVelocity[body1 * nDim + i];
    }

    const MInt body2 = m_gapCells[it].bodyIds[1];
    ASSERT(m_gapCells[it].bodyIds[0] == body1, "");
    if(body2 == -1) continue;

    MFloat vel1 = F0;
    MFloat vel2 = F0;
    MInt interpolationCells[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    this->setUpInterpolationStencil(gridCellId, interpolationCells, m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates,
                                    alwaysTrue, false);

    const MFloat dist1 = interpolateLevelSet(interpolationCells, m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates,
                                             m_bodyToSetTable[body1]);

    const MFloat dist2 = interpolateLevelSet(interpolationCells, m_bndryCells->a[bndryId].m_srfcs[0]->m_coordinates,
                                             m_bodyToSetTable[body2]);

    for(MInt i = 0; i < nDim; i++) {
      vel1 += m_bodyVelocity[body1 * nDim + i] * m_bodyVelocity[body1 * nDim + i];
      vel2 += m_bodyVelocity[body2 * nDim + i] * m_bodyVelocity[body2 * nDim + i];
    }

    MInt fixedBody = body1;
    MInt movingBody = body2;
    MFloat distFixed = dist1;

    // use the more stationary velocity!
    if(m_gapInitMethod > 0 && vel1 < vel2) {
      continue;
    } else if(m_gapInitMethod > 0) {
      for(MInt i = 0; i < nDim; i++) {
        m_gapCells[it].surfaceVelocity[i] = m_bodyVelocity[body2 * nDim + i];
      }
      continue;
    }

    if(vel1 > vel2) {
      fixedBody = body2;
      movingBody = body1;
      distFixed = dist2;
    }

    MFloat F = distFixed / (2.0 * c_cellLengthAtLevel(m_lsCutCellBaseLevel));
    if(F < F0) F = F0;
    if(F > 1.0) F = 1.0;

    // velocity interpolation in the cells close to both boundaries
    for(MInt i = 0; i < nDim; i++) {
      m_gapCells[it].surfaceVelocity[i] =
          (F * m_bodyVelocity[movingBody * nDim + i] + (1 - F) * m_bodyVelocity[fixedBody * nDim + i]);
    }
  }
}


/**
 * \brief interpolates levelset function to a given coordinate
 * \author Claudia Guenther
 * \date 03/2012
 */
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::interpolateLevelSet(MInt* interpolationCells, MFloat* point,
                                                                MInt referenceSet) {
  TRACE();

  std::function<MFloat(const MInt, const MInt)> scalarField = [&](const MInt cellId, const MInt set) {
    return static_cast<MFloat>(a_levelSetValuesMb(cellId, set));
  };

  std::function<MFloat(const MInt, const MInt)> coordinate = [&](const MInt cellId, const MInt id) {
    return static_cast<MFloat>(c_coordinate(cellId, id));
  };

  return this->template interpolateFieldData<true>(&interpolationCells[0], &point[0], referenceSet, scalarField,
                                                   coordinate);
}


/**
 * \brief applies the boundary condition at all boundaries
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::applyBoundaryConditionMb() {
  TRACE();

  applyDirichletCondition(); // apply Dirichlet boundary conditions
  applyNeumannCondition();   // apply Neumann boundary conditions

#if defined _MB_DEBUG_ || !defined NDEBUG
  m_solutionDiverged = false;
  const MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();
  for(MInt bndryId = m_noOuterBndryCells; bndryId < noBndryCells; bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCell[bndryId].m_cellId;
    if(a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    const MInt noSrfcs = m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs;
    for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
      for(MInt v = 0; v < m_noPVars; v++) {
        const MFloat val = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[v];
        const MFloat val2 = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_normalDeriv[v];
        if(std::isnan(val) || std::isinf(val)) {
          cerr << setprecision(16) << domainId() << ": bnd surf var div after BC: " << globalTimeStep << "/" << m_RKStep
               << " " << cellId << " " << c_globalId(cellId) << " "
               << m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume / grid().gridCellVolume(a_level(cellId)) << " "
               << c_noChildren(cellId) << " " << a_isHalo(cellId) << " "
               << a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) << " "
               << m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.size() << " "
               << a_hasProperty(cellId, SolverCell::IsInactive) << ", " << srfc << " " << getPrimitiveVarName(v) << " "
               << val << " " << a_pvariable(cellId, v) << endl;
          m_solutionDiverged = true;
        }
        if(std::isnan(val2) || std::isinf(val2)) {
          cerr << domainId() << ": bnd surf grad div after BC: " << globalTimeStep << "/" << m_RKStep << " " << cellId
               << " " << c_globalId(cellId) << " " << m_volumeFraction[bndryId] << " " << c_noChildren(cellId) << " "
               << a_isHalo(cellId) << " " << a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) << " "
               << m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.size() << " "
               << a_hasProperty(cellId, SolverCell::IsInactive) << " / " << srfc << " " << getPrimitiveVarName(v) << " "
               << val2 << endl;
          m_solutionDiverged = true;
        }
      }
      if(m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->P] < F0
         || m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->RHO] < F0) {
        MInt ghostCellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
        cerr << domainId() << ": bnd surf var negative after BC: " << globalTimeStep << "/" << m_RKStep << " " << cellId
             << " " << c_globalId(cellId) << " " << m_volumeFraction[bndryId] << " " << a_level(cellId) << " "
             << c_noChildren(cellId) << " " << a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) << " "
             << a_isHalo(cellId) << " " << a_hasProperty(cellId, SolverCell::IsNotGradient) << " "
             << m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.size() << " "
             << a_hasProperty(cellId, SolverCell::IsInactive) << " / " << srfc << " " << a_pvariable(cellId, PV->P)
             << " " << a_pvariable(cellId, PV->RHO) << " / "
             << m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->P] << " "
             << m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->RHO] << " / "
             << a_pvariable(ghostCellId, PV->P) << " " << a_pvariable(ghostCellId, PV->RHO) << " v "
             << m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[0]] << " "
             << m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[1]] << " "
             << m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[2]] << " "
             << c_coordinate(cellId, 0) << " " << c_coordinate(cellId, 1) << " " << c_coordinate(cellId, nDim - 1)
             << endl;
        m_solutionDiverged = true;
      }
    }
  }
  if(m_solutionDiverged) {
    cerr << "Solution diverged (BC) at solver " << domainId() << " " << globalTimeStep << " " << m_RKStep << endl;
  }
  MPI_Allreduce(MPI_IN_PLACE, &m_solutionDiverged, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                "m_solutionDiverged");

  if(m_solutionDiverged) {
    writeVtkXmlFiles("QOUT", "GEOM", false, true);
    MPI_Barrier(mpiComm(), AT_);
    mTerm(1, AT_, "Solution diverged after BC handling.");
  }
#endif
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::updateGhostCellSlopesInviscid() {
  m_fvBndryCnd->updateGhostCellSlopesInviscid();
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::updateGhostCellSlopesViscous() {
  if(m_euler) return;
  m_fvBndryCnd->updateGhostCellSlopesViscous();
}


/**
 * \brief sets boundary surface variables to their correct values
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::correctBoundarySurfaceVariablesMb() {
  TRACE();

  m_fvBndryCnd->correctBoundarySurfaceVariables();
}


template <MInt nDim, class SysEqn>
inline MBool FvMbCartesianSolverXD<nDim, SysEqn>::inside(MFloat x, MFloat a, MFloat b) {
  return (!(x < a) && !(x > b));
}


/**
 * \brief corrects the cell-surface distances at the boundary needed for the viscous flux computation
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::updateViscousFluxComputation() {
  TRACE();

  const MInt noSrfcs = a_noSurfaces();
  MInt nghbrCells[2];
  MFloat eps = 1e-10;
  MFloat totalDistance, distance;
  MFloat factor0, factor1;
  MFloat coords[2][nDim];
  MInt srfcId;

  // compute the factors 0 and 1 for all surfaces
  // for( srfcId = m_initialSurfacesOffset; srfcId < noSrfcs; srfcId++ ) {
  for(srfcId = m_bndrySurfacesOffset; srfcId < noSrfcs; srfcId++) {
    nghbrCells[0] = a_surfaceNghbrCellId(srfcId, 0);
    nghbrCells[1] = a_surfaceNghbrCellId(srfcId, 1);
    distance = F0;
    totalDistance = F0;

    for(MInt i = 0; i < nDim; i++) {
      coords[0][i] = a_coordinate(nghbrCells[0], i);
      coords[1][i] = a_coordinate(nghbrCells[1], i);
    }

    for(MInt i = 0; i < nDim; i++) {
      distance += POW2(a_surfaceCoordinate(srfcId, i) - coords[0][i]);
      totalDistance += POW2(a_surfaceCoordinate(srfcId, i) - coords[1][i]);
    }
    distance = sqrt(distance);
    totalDistance = sqrt(totalDistance) + distance;
    factor1 = distance / mMax(eps, totalDistance);
    factor0 = F1 - factor1;
    a_surfaceFactor(srfcId, 0) = factor0;
    a_surfaceFactor(srfcId, 1) = factor1;
  }


  for(MInt bs = 0; bs < m_fvBndryCnd->m_noBoundarySurfaces; bs++) {
    srfcId = m_fvBndryCnd->m_boundarySurfaces[bs];
    if(a_surfaceBndryCndId(srfcId) != m_movingBndryCndId) continue;

    a_surfaceFactor(srfcId, 0) = F1B2;
    a_surfaceFactor(srfcId, 1) = F1B2;
  }
}


/**
 * \brief Computes cutpoints of zero level-set with grid edges and creates boundary cells for cut-cells
 * \note can handle complex geometries with sub-cell resolution, needs multi LVS method
 * \author Claudia Guenther, Update Tim Wegmann
 * \date 30.07.2013
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::computeCutPointsMb_MGC() {
  TRACE();

  const MInt DOFStencil[12] = {1, 1, 0, 0, 1, 1, 0, 0, 2, 2, 2, 2};

  const MInt signStencil[3][12] = {{-1, 1, 0, 0, -1, 1, 0, 0, -1, 1, -1, 1},
                                   {0, 0, -1, 1, 0, 0, -1, 1, -1, -1, 1, 1},
                                   {-1, -1, -1, -1, 1, 1, 1, 1, 0, 0, 0, 0}};

  const MBool redirect = true;
  if(redirect && !m_constructGField) {
    vector<MInt> candidatesOrder;

    m_geometryIntersection->computeCutPoints(m_cutCandidates, &m_bndryCandidateIds[0], candidatesOrder);

    // rescale cutPoints to cell-size:
    if(m_geometryIntersection->m_scaledCutCell) {
      for(MInt cnd = 0; cnd < (signed)m_cutCandidates.size(); cnd++) {
        const MInt cellId = m_cutCandidates[cnd].cellId;
        const MFloat cellLength = c_cellLengthAtLevel(a_cutCellLevel(cellId));
        const MFloat cellHalfLength = F1B2 * cellLength;


        for(MInt cpId = 0; cpId < m_cutCandidates[cnd].noCutPoints; cpId++) {
          const MInt cutEdge = m_cutCandidates[cnd].cutEdges[cpId];

          for(MInt i = 0; i < nDim; i++) {
            MFloat cutCoordinate = m_cutCandidates[cnd].cutPoints[cpId][i];
            const MInt sign = signStencil[i][cutEdge];

            if(sign == 0) {
              cutCoordinate = a_coordinate(cellId, i) + cellHalfLength * m_cutCandidates[cnd].cutPoints[cpId][i];
            } else {
              cutCoordinate = a_coordinate(cellId, i) + signStencil[i][cutEdge] * cellHalfLength;
            }
            m_cutCandidates[cnd].cutPoints[cpId][i] = cutCoordinate;
          }
        }
      }
    }

    // generate BndryCells based on the cutCandidates!
    // TODO labels:FVMB this should then be moved to the end of createCutFaceMb_MGC()
    //      and instead the cutCells should be set!

    // NOTE: bndryCell ordering appears to change the result for gapClosure!
    for(MInt i = 0; i < (signed)candidatesOrder.size(); i++) {
      const MInt cndt = candidatesOrder[i];
      const MInt cellId = m_cutCandidates[cndt].cellId;
      ASSERT(m_cutCandidates[cndt].noCutPoints > 0, "");
      MInt bndryId = -1;
      if(!a_isBndryCell(cellId)) {
        ASSERT(a_bndryId(cellId) == -1, to_string(a_bndryId(cellId)));
        bndryId = createBndryCellMb(cellId);
      } else {
        bndryId = a_bndryId(cellId);
        ASSERT(bndryId > -1, "");
      }
      m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints = m_cutCandidates[cndt].noCutPoints;

      for(MInt noCPs = 0; noCPs < m_cutCandidates[cndt].noCutPoints; noCPs++) {
        for(MInt dim = 0; dim < nDim; dim++) {
          m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[noCPs][dim] =
              m_cutCandidates[cndt].cutPoints[noCPs][dim];
        }
        m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[noCPs] = m_cutCandidates[cndt].cutBodyIds[noCPs];
        m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[noCPs] = m_cutCandidates[cndt].cutEdges[noCPs];
      }
    }

    return;
  }

  const MInt edgesPerDim = IPOW2(nDim - 1);

  const MInt faceStencil[2][12] = {{0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 0, 1}, {4, 4, 4, 4, 5, 5, 5, 5, 2, 2, 3, 3}};

  // edege -> opposing edge
  // 1: oppsing edge on the same higher face count
  // 2: opposing edge on the same lower face count
  // 3: oppsong edge accros the cube
  //                                         0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11
  const MInt reverseEdgeStencil[3][12] = {{1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10},
                                          {4, 5, 6, 7, 0, 1, 2, 3, 10, 11, 8, 9},
                                          {5, 4, 7, 6, 1, 0, 3, 2, 11, 10, 9, 8}};


  // edeg -> corner: returns the two corners for any edge
  //                                  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11
  const MInt nodeStencil[2][12] = {{0, 1, 0, 2, 4, 5, 4, 6, 0, 1, 2, 3}, {2, 3, 1, 3, 6, 7, 5, 7, 4, 5, 6, 7}};


  const MBool multiCutCell = false;
  const MFloat eps = multiCutCell ? 10 * m_eps : m_eps;
  MInt errorFlag = 0;


  ASSERT(m_noBndryCandidates == (signed)m_bndryCandidates.size(), "");
  ScratchSpace<MBool> edgeChecked(m_noBndryCandidates * m_noEdges, AT_, "edgeChecked");
  edgeChecked.fill(false);

  for(MInt i = 0; i < m_noBndryCandidates; i++) {
    for(MInt e = 0; e < m_noEdges; e++) {
      edgeChecked.p[i * m_noEdges + e] = false;
    }
  }
  MIntScratchSpace noCutPointsOnEdge(m_fvBndryCnd->m_maxNoBndryCells, m_noEdges, AT_, "noCutPointsOnEdge");
  noCutPointsOnEdge.fill(0);

  for(MInt i = 0; i < m_fvBndryCnd->m_maxNoBndryCells; i++)
    for(MInt e = 0; e < m_noEdges; e++)
      noCutPointsOnEdge(i, e) = 0;


  // loop over       candidates,     determine cutpoints,    store bndryCell properties
  for(MInt cndt = 0; cndt < m_noBndryCandidates; cndt++) {
    MInt cellId = m_bndryCandidates[cndt];

    const MFloat cellLength = c_cellLengthAtLevel(a_cutCellLevel(cellId));
    const MFloat cellHalfLength = F1B2 * cellLength;

    MInt face[2];
    for(MInt edge = 0; edge < m_noEdges; edge++) {
      if(edgeChecked.p[cndt * m_noEdges + edge]) continue;

      // first do some data structure related stuff
      face[0] = faceStencil[0][edge]; // in 2D: face == edge
      IF_CONSTEXPR(nDim == 3) {
        face[1] = faceStencil[1][edge]; // in 3D: each edge is connected to two faces
      }
      MInt edgeDOF = DOFStencil[edge]; // edge's degree of freedom

      MInt directNeighbourIds[4]{-1, -1, -1, -1}; // direct neighbours of each edge -> requires that neighboring cells
                                                  // are on same level!
      directNeighbourIds[0] = cellId;
      directNeighbourIds[1] = -1;
      if(a_hasNeighbor(cellId, face[0]) > 0) directNeighbourIds[1] = c_neighborId(cellId, face[0]);

      MInt reverseEdge[4] = {0, 0, 0, 0};
      reverseEdge[0] = edge;
      reverseEdge[1] = reverseEdgeStencil[0][edge];
      IF_CONSTEXPR(nDim == 3) {
        directNeighbourIds[2] = -1;
        if(a_hasNeighbor(cellId, face[1]) > 0) {
          directNeighbourIds[2] = c_neighborId(cellId, face[1]);
        }
        directNeighbourIds[3] = -1;
        if(a_hasNeighbor(cellId, face[0]) > 0) {
          if(a_hasNeighbor(c_neighborId(cellId, face[0]), face[1]) > 0) {
            directNeighbourIds[3] = c_neighborId(c_neighborId(cellId, face[0]), face[1]);
          }
        }
        if(directNeighbourIds[3] < 0) {
          if(a_hasNeighbor(cellId, face[1]) > 0) {
            if(a_hasNeighbor(c_neighborId(cellId, face[1]), face[0]) > 0) {
              directNeighbourIds[3] = c_neighborId(c_neighborId(cellId, face[1]), face[0]);
            }
          }
        }
        reverseEdge[2] = reverseEdgeStencil[1][edge];
        reverseEdge[3] = reverseEdgeStencil[2][edge];
      }

      // here, the real cut point computation begins
      MInt startSet = 0;
      MInt endSet = 1;
      MBool isGapCell = false;
      if(m_levelSet && m_closeGaps) {
        isGapCell = (a_hasProperty(cellId, SolverCell::IsGapCell));
      }
      if(m_complexBoundary && m_noLevelSetsUsedForMb > 1 && (!isGapCell)) {
        startSet = 1;
        endSet = m_noLevelSetsUsedForMb;
      } else if(m_complexBoundary && m_noLevelSetsUsedForMb > 1 && (isGapCell)) {
        startSet = 0;
        endSet = 1;
      }


      for(MInt set = startSet; set < endSet; set++) {
        MFloat phi[2]; // signed-distance value on both vertices defining an edge
        phi[0] = m_candidateNodeValues[IDX_LSSETNODES(cndt, nodeStencil[0][edge], set)];
        phi[1] = m_candidateNodeValues[IDX_LSSETNODES(cndt, nodeStencil[1][edge], set)];
        if(!m_candidateNodeSet[cndt * m_noCellNodes + nodeStencil[0][edge]])
          cerr << domainId() << ": warning node value 0 not set at " << globalTimeStep << ", " << cellId << " " << cndt
               << " " << edge << " " << nodeStencil[0][edge] << " " << set << " " << a_isHalo(cellId) << endl;
        if(!m_candidateNodeSet[cndt * m_noCellNodes + nodeStencil[1][edge]])
          cerr << domainId() << ": warning node value 1 not set at " << globalTimeStep << ", " << cellId << " " << cndt
               << " " << edge << " " << nodeStencil[1][edge] << " " << set << " " << a_isHalo(cellId) << endl;

        // added by Claudia to prevent zero-volume cells
        if(fabs(phi[0]) < eps) {
          if(phi[0] < F0)
            phi[0] = -eps;
          else
            phi[0] = eps;
        }
        if(fabs(phi[1]) < eps) {
          if(phi[1] < F0)
            phi[1] = -eps;
          else
            phi[1] = eps;
        }

        // limit the distance of a cutPoint to any corner:
        // together with the above, this ensure that the CP
        // is always 2 eps appart from the corner!
        // necessary for multiCutCell but not included in the trunk!
        if(multiCutCell) {
          if(approx(fabs(phi[0]), cellHalfLength, eps)) {
            if(phi[0] > F0)
              phi[0] = cellHalfLength - eps;
            else
              phi[0] = -cellHalfLength + eps;
          }
          if(approx(fabs(phi[1]), cellHalfLength, eps)) {
            if(phi[1] > F0)
              phi[1] = cellHalfLength - eps;
            else
              phi[1] = -cellHalfLength + eps;
          }
        }

        // found a cutpoint if sign differs
        if(phi[0] * phi[1] < 0) {
          MFloat cutpoint[nDim];
          // determine cutpoint coordinates
          MFloat deltaCutpoint = cellHalfLength * (phi[0] + phi[1]) / (phi[0] - phi[1]);
          ASSERT((phi[0] + phi[1]) / (phi[0] - phi[1]) < 1 && (phi[0] + phi[1]) / (phi[0] - phi[1]) > -1, "");
          for(MInt dim = 0; dim < nDim; dim++) {
            if(dim == edgeDOF) continue;
            cutpoint[dim] = a_coordinate(cellId, dim) + signStencil[dim][edge] * cellHalfLength;
          }
          cutpoint[edgeDOF] = a_coordinate(cellId, edgeDOF) + deltaCutpoint;

          // store this cutpoint at all direct neighbours
          for(MInt nb = 0; nb < edgesPerDim; nb++) {
            MInt nbCell = directNeighbourIds[nb];
            if(nbCell < 0) continue;
            if(m_bndryCandidateIds[nbCell] < 0) {
              continue;
            }
            // may occur in multi-domain computations
            if(edgeChecked.p[m_bndryCandidateIds[nbCell] * m_noEdges + reverseEdge[nb]]) {
              cerr << "Strange behaviour! " << endl;
              continue;
            }
            // if neighbour isn't already moving boundary cell create a new one
            MInt nbBndryCell = -1;
            if(!a_isBndryCell(nbCell)) {
              if(a_bndryId(nbCell) != -1) {
                cerr << domainId() << "Missing boundary cell: " << cellId << " " << nbCell << " " << a_level(cellId)
                     << " " << a_level(nbCell) << " " << c_neighborId(cellId, face[0]) << " " << face[0] << " "
                     << a_isHalo(cellId) << " " << a_isHalo(nbCell) << endl;
              }
              ASSERT(a_bndryId(nbCell) == -1, to_string(a_bndryId(nbCell)));
              nbBndryCell = createBndryCellMb(nbCell);
            } else {
              nbBndryCell = a_bndryId(nbCell);
              if(nbBndryCell < 0) {
                errorFlag = 1;
                cerr << "Critical error in at " << globalTimeStep << ". Quit.";
              }
            }

            // store relevant information
            MInt noCPs = m_fvBndryCnd->m_bndryCells->a[nbBndryCell].m_srfcs[0]->m_noCutPoints;
            if(noCPs == 2 * m_noEdges) {
              mTerm(1, AT_, "Error: Too many cut points, can't store more... Please check!");
            }
            if(noCutPointsOnEdge(nbBndryCell, reverseEdge[nb]) == 2) {
              mTerm(1, AT_, "Error: Already two cut points on edge, can't store more... Please check!");
            }

            ASSERT(a_associatedBodyIds(cellId, set) > -1
                       && a_associatedBodyIds(cellId, set) < m_noEmbeddedBodies + m_noPeriodicGhostBodies,
                   "");

            if(set >= m_startSet && a_associatedBodyIds(cellId, set) != a_associatedBodyIds(nbCell, set)) {
              cerr << domainId() << ": warning associated body mismatch! " << globalTimeStep << " " << set << " "
                   << isGapCell << ", " << c_globalId(cellId) << " " << c_globalId(nbCell) << ", "
                   << a_isPeriodic(cellId) << " " << a_isPeriodic(nbCell) << "/ " << a_associatedBodyIds(cellId, set)
                   << " " << a_associatedBodyIds(nbCell, set) << ", " << a_associatedBodyIds(cellId, 0) << " "
                   << a_associatedBodyIds(nbCell, 0) << "/ " << a_levelSetValuesMb(cellId, set) << " "
                   << a_levelSetValuesMb(nbCell, set) << ", " << a_levelSetValuesMb(cellId, 0) << " "
                   << a_levelSetValuesMb(nbCell, 0) << "/ " << a_hasProperty(cellId, Cell::IsHalo) << " "
                   << a_hasProperty(nbCell, Cell::IsHalo) << ", " << a_hasProperty(cellId, SolverCell::IsGapCell) << " "
                   << a_hasProperty(nbCell, SolverCell::IsGapCell) << endl;
              directNeighbourIds[nb] = -1;
              continue;
            }

            for(MInt dim = 0; dim < nDim; dim++)
              m_fvBndryCnd->m_bndryCells->a[nbBndryCell].m_srfcs[0]->m_cutCoordinates[noCPs][dim] = cutpoint[dim];

            m_fvBndryCnd->m_bndryCells->a[nbBndryCell].m_srfcs[0]->m_bodyId[noCPs] = a_associatedBodyIds(nbCell, set);
            m_fvBndryCnd->m_bndryCells->a[nbBndryCell].m_srfcs[0]->m_cutEdge[noCPs] = reverseEdge[nb];
            m_fvBndryCnd->m_bndryCells->a[nbBndryCell].m_srfcs[0]->m_noCutPoints++;
            noCutPointsOnEdge(nbBndryCell, reverseEdge[nb])++;
          } // for nb
        }   // phi1*phi2<0
      }     // for sets

      // flag direct neighbours so that this edge is only checked once
      for(MInt nb = 0; nb < edgesPerDim; nb++) {
        if(directNeighbourIds[nb] < 0) continue;
        MInt nbCndt = m_bndryCandidateIds[directNeighbourIds[nb]];
        if(nbCndt < 0) continue;
        edgeChecked.p[nbCndt * m_noEdges + reverseEdge[nb]] = true;
      }
    } // for edge
  }   // for cndt

  /*
  //     // debug: plot cut points:
  //   const char* fileName = "AllCutPoints_";
  //   stringstream fileName2;
  //   fileName2 << fileName << domainId() << ".vtk";
  //   ofstream ofl;
  //   ofl.open((fileName2.str()).c_str(), ofstream::trunc );
  //
  //   MInt noCutPoints = 0;
  //   MInt noCells = m_bndryCells->size();
  //
  //
  //
  //   // count the total number of cut points
  //   for(MInt bndryId = 0; bndryId < noCells; bndryId++){
  //     noCutPoints += m_bndryCells->a[ bndryId ].m_srfcs[0]->m_noCutPoints;
  //   }
  //
  //   if(ofl){
  //
  //     ofl.setf(ios::fixed);
  //     ofl.precision(7);
  //
  //     ofl << "# vtk DataFile Version 3.0" << endl
  //     << "MAIAD intersectionPoints file" << endl
  //     << "ASCII" << endl
  //     << "DATASET POLYDATA" << endl
  //     << "POINTS " <<  noCutPoints << " float" << endl;
  //
  //     // write each cut point in the data file
  //     for(MInt bndryId = 0; bndryId < noCells; bndryId++){
  //       if(m_bndryCells->a[ bndryId ].m_srfcs[0]->m_noCutPoints > 0){
  //         for(MInt n = 0; n < m_bndryCells->a[ bndryId ].m_srfcs[0]->m_noCutPoints; n++){
  //           for(MInt i = 0; i < nDim; i++){
  //             ofl << m_bndryCells->a[ bndryId ].m_srfcs[0]->m_cutCoordinates[ n ][ i ] << " ";
  //           }
  //           IF_CONSTEXPR(nDim == 2)
  //             ofl << F0 << " ";
  //           ofl << endl;
  //         }
  //       }
  //     }
  //
  //     ofl << "VERTICES " << noCutPoints << " " << noCutPoints * 2 << endl;
  //     for(MInt i = 0; i < noCutPoints; i++){
  //       ofl << "1 " << i << endl;
  //     }
  //
  //     ofl << "POINT_DATA " << noCutPoints << endl;
  //     ofl << "SCALARS bodyId int" << endl;
  //     ofl << "LOOKUP_TABLE default" << endl;
  //     for(MInt bndryId = 0; bndryId < noCells; bndryId++){
  //       if(m_bndryCells->a[ bndryId ].m_srfcs[0]->m_noCutPoints > 0){
  //         for(MInt n = 0; n < m_bndryCells->a[ bndryId ].m_srfcs[0]->m_noCutPoints; n++){
  //           ofl << m_bndryCells->a[ bndryId ].m_srfcs[0]->m_bodyId[ n ] << " ";
  //         }
  //       }
  //     }
  //     ofl << endl;
  //   }
  //
  //   ofl.close();
  */

#ifdef _MB_DEBUG_
  MPI_Allreduce(MPI_IN_PLACE, &errorFlag, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "errorFlag");
#endif
  if(errorFlag) {
    writeVtkDebug("error" + getIdentifier(false, "_", "_"));
    mTerm(1, AT_, "Critical error in computeCutPointsMb_MGC! Quit.");
  }
}


/**
 * \brief does what it says
 * \author Lennart Schneiders
 * \date 31.10.2011
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::resetRHS() {
  TRACE();

  MFloat* RESTRICT RHS = (MFloat*)(&(a_rightHandSide(0, 0)));
  fill(RHS, RHS + (a_noCells() * m_noFVars), F0);
}


/**
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::viscousFlux() {
  TRACE();

#ifdef VISCOUS_FLUX_FREEZING
  MFloat* RESTRICT RHS = (MFloat*)(&(a_rightHandSide(0, 0)));
  MFloat* RESTRICT RHSV = (MFloat*)(&(m_rhsViscous[0][0]));
  MFloat* RESTRICT flux = (MFloat*)(&(a_surfaceFlux(0, 0)));
  const MInt xdim = m_noSurfaces;
  const MInt ydim = m_noFVars;
  const MInt size0 = m_noSurfaces * m_noFVars * sizeof(MFloat);
  const MInt size1 = a_noCells() * m_noFVars * sizeof(MFloat);

  for(MInt srfcId = xdim; srfcId--;) {
    RHS[a_surfaceNghbrCellId(srfcId, 0) * ydim + 0] += flux[srfcId * ydim + 0];
    RHS[a_surfaceNghbrCellId(srfcId, 1) * ydim + 0] -= flux[srfcId * ydim + 0];
    RHS[a_surfaceNghbrCellId(srfcId, 0) * ydim + 1] += flux[srfcId * ydim + 1];
    RHS[a_surfaceNghbrCellId(srfcId, 1) * ydim + 1] -= flux[srfcId * ydim + 1];
    RHS[a_surfaceNghbrCellId(srfcId, 0) * ydim + 2] += flux[srfcId * ydim + 2];
    RHS[a_surfaceNghbrCellId(srfcId, 1) * ydim + 2] -= flux[srfcId * ydim + 2];
    RHS[a_surfaceNghbrCellId(srfcId, 0) * ydim + 3] += flux[srfcId * ydim + 3];
    RHS[a_surfaceNghbrCellId(srfcId, 1) * ydim + 3] -= flux[srfcId * ydim + 3];
    IF_CONSTEXPR(nDim == 3) {
      RHS[a_surfaceNghbrCellId(srfcId, 0) * ydim + 4] += flux[srfcId * ydim + 4];
      RHS[a_surfaceNghbrCellId(srfcId, 1) * ydim + 4] -= flux[srfcId * ydim + 4];
      IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
        for(MInt r = 0; r < m_noRansEquations; r++) {
          RHS[a_surfaceNghbrCellId(srfcId, 0) * ydim + 5 + r] += flux[srfcId * ydim + 5 + r];
          RHS[a_surfaceNghbrCellId(srfcId, 1) * ydim + 5 + r] -= flux[srfcId * ydim + 5 + r];
        }
      }
      for(MUint s = 0; s < noSpecies; ++s) {
        RHS[a_surfaceNghbrCellId(srfcId, 0) * ydim + 5 + m_noRansEquations + s] +=
            flux[srfcId * ydim + 5 + m_noRansEquations + s];
        RHS[a_surfaceNghbrCellId(srfcId, 1) * ydim + 5 + m_noRansEquations + s] -=
            flux[srfcId * ydim + 5 + m_noRansEquations + s];
      }
    }
    else {
      IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
        for(MInt r = 0; r < m_noRansEquations; r++) {
          RHS[a_surfaceNghbrCellId(srfcId, 0) * ydim + 4 + r] += flux[srfcId * ydim + 4 + r];
          RHS[a_surfaceNghbrCellId(srfcId, 1) * ydim + 4 + r] -= flux[srfcId * ydim + 4 + r];
        }
      }
      for(MUint s = 0; s < noSpecies; ++s) {
        RHS[a_surfaceNghbrCellId(srfcId, 0) * ydim + 4 + m_noRansEquations + s] +=
            flux[srfcId * ydim + 4 + m_noRansEquations + s] RHS[a_surfaceNghbrCellId(srfcId, 1) * ydim + 4
                                                                + m_noRansEquations + s] -=
            flux[srfcId * ydim + 4 + m_noRansEquations + s];
      }
    }
  }

  if(m_RKStep == 1) { // freeze after first stage
    memset(flux, 0, size0);
    memset(RHSV, 0, size1);
    (this->*computeViscousFlux)();

    for(MInt srfcId = xdim; srfcId--;) {
      RHSV[a_surfaceNghbrCellId(srfcId, 0) * ydim + 0] += flux[srfcId * ydim + 0];
      RHSV[a_surfaceNghbrCellId(srfcId, 1) * ydim + 0] -= flux[srfcId * ydim + 0];
      RHSV[a_surfaceNghbrCellId(srfcId, 0) * ydim + 1] += flux[srfcId * ydim + 1];
      RHSV[a_surfaceNghbrCellId(srfcId, 1) * ydim + 1] -= flux[srfcId * ydim + 1];
      RHSV[a_surfaceNghbrCellId(srfcId, 0) * ydim + 2] += flux[srfcId * ydim + 2];
      RHSV[a_surfaceNghbrCellId(srfcId, 1) * ydim + 2] -= flux[srfcId * ydim + 2];
      RHSV[a_surfaceNghbrCellId(srfcId, 0) * ydim + 3] += flux[srfcId * ydim + 3];
      RHSV[a_surfaceNghbrCellId(srfcId, 1) * ydim + 3] -= flux[srfcId * ydim + 3];
      IF_CONSTEXPR(nDim == 3) {
        RHSV[a_surfaceNghbrCellId(srfcId, 0) * ydim + 4] += flux[srfcId * ydim + 4];
        RHSV[a_surfaceNghbrCellId(srfcId, 1) * ydim + 4] -= flux[srfcId * ydim + 4];
      }
    }
  }
#else
  Base::viscousFlux();
#endif
}


/**
 * \brief distributes the surface flux to the RHS of the fluid cells
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::distributeFluxToCells() {
  TRACE();

  MFloat* RESTRICT RHS = (MFloat*)(&(a_rightHandSide(0, 0)));
  MFloat* RESTRICT flux = (MFloat*)(&(a_surfaceFlux(0, 0)));
  const MInt xdim = m_noSurfaces;
  const MInt ydim = m_noFVars;

#ifdef VISCOUS_FLUX_FREEZING
  MFloat* RESTRICT RHSV = (MFloat*)(&(m_rhsViscous[0][0]));
  const MInt xdim0 = a_noCells();

  for(MInt i = xdim0; i--;) {
    if(!a_hasProperty(i, SolverCell::IsActive)) continue;
    RHS[ydim * i + 0] += RHSV[ydim * i + 0];
    RHS[ydim * i + 1] += RHSV[ydim * i + 1];
    RHS[ydim * i + 2] += RHSV[ydim * i + 2];
    RHS[ydim * i + 3] += RHSV[ydim * i + 3];
    IF_CONSTEXPR(nDim == 3) {
      RHS[ydim * i + 4] += RHSV[ydim * i + 4];
      IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
        for(MInt r = 0; r < m_noRansEquations; ++r) {
          RHS[ydim * i + 5 + r] += RHSV[ydim * i + 5 + r];
        }
      }
      for(MInt s = 0; s < m_noSpecies; s++)
        RHS[ydim * i + 5 + s + m_noRansEquations] += RHSV[ydim * i + 5 + m_noRansEquations];
    }
    else {
      IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
        for(MInt r = 0; r < m_noRansEquations; ++r) {
          RHS[ydim * i + 4 + r] += RHSV[ydim * i + 4 + r];
        }
      }
      for(MInt s = 0; s < m_noSpecies; s++)
        RHS[ydim * i + 4 + s + m_noRansEquations] += RHSV[ydim * i + 4 + m_noRansEquations];
    }
  }
  return;
#endif

//
#ifdef _MB_DEBUG_
  const MInt blk = -1;
  MInt cll = -1;
  const MInt gId = -1;
  const MInt varId = CV->RHO;
  const MInt pvarId = PV->RHO;
  MFloat area_check[3] = {F0, F0, F0};
  MFloat flux_check[3] = {F0, F0, F0};
#endif
  for(MInt srfcId = xdim; srfcId--;) {
#ifdef _MB_DEBUG_
    if((blk > -1 && domainId() == blk && a_surfaceNghbrCellId(srfcId, 0) == cll)
       || (gId > -1 && c_globalId(a_surfaceNghbrCellId(srfcId, 0)) == gId
           && !a_isHalo(a_surfaceNghbrCellId(srfcId, 0)))) {
      if(gId > -1) cll = a_surfaceNghbrCellId(srfcId, 0);
      MInt n0 = a_surfaceNghbrCellId(srfcId, 0);
      MInt n1 = a_surfaceNghbrCellId(srfcId, 1);
      cerr << domainId() << ": flux " << globalTimeStep << " " << m_RKStep << " " << srfcId << " "
           << /*m_isActiveSurface[ srfcId ]<< " " <<*/ flux[srfcId * ydim + varId] << " " << a_rightHandSide(cll, varId)
           << " /srf " << a_surfaceArea(srfcId) << " " << a_surfaceOrientation(srfcId) << " "
           << a_surfaceBndryCndId(srfcId) << " /ict "
           << a_hasProperty(a_surfaceNghbrCellId(srfcId, 0), SolverCell::IsInactive) << " "
           << a_hasProperty(a_surfaceNghbrCellId(srfcId, 1), SolverCell::IsInactive) << " /vol "
           << a_cellVolume(n0) / grid().gridCellVolume(a_level(n0)) << " "
           << a_cellVolume(n1) / grid().gridCellVolume(a_level(n1)) << " /vol0 " << a_cellVolume(n0) * a_FcellVolume(n0)
           << " " << a_cellVolume(n1) * a_FcellVolume(n1) << " /vol1 " << m_cellVolumesDt1[n0] * a_FcellVolume(n0)
           << " " << m_cellVolumesDt1[n1] * a_FcellVolume(n1) << " /ngb " << a_surfaceNghbrCellId(srfcId, 0) << " "
           << a_surfaceNghbrCellId(srfcId, 1) << " /ngbg " << c_globalId(a_surfaceNghbrCellId(srfcId, 0)) << " "
           << c_globalId(a_surfaceNghbrCellId(srfcId, 1)) << " /var "
           << a_variable(a_surfaceNghbrCellId(srfcId, 0), pvarId) << " "
           << a_variable(a_surfaceNghbrCellId(srfcId, 1), pvarId) << endl;
      area_check[a_surfaceOrientation(srfcId)] += a_surfaceArea(srfcId);
      flux_check[a_surfaceOrientation(srfcId)] += flux[srfcId * ydim + varId];
    }
    if((blk > -1 && domainId() == blk && a_surfaceNghbrCellId(srfcId, 1) == cll)
       || (gId > -1 && c_globalId(a_surfaceNghbrCellId(srfcId, 1)) == gId
           && !a_isHalo(a_surfaceNghbrCellId(srfcId, 1)))) {
      if(gId > -1) cll = a_surfaceNghbrCellId(srfcId, 1);
      MInt n0 = a_surfaceNghbrCellId(srfcId, 0);
      MInt n1 = a_surfaceNghbrCellId(srfcId, 1);
      cerr << domainId() << ": flux " << globalTimeStep << " " << m_RKStep << " " << srfcId << " "
           << /*m_isActiveSurface[ srfcId ] << " " <<*/ -flux[srfcId * ydim + varId] << " "
           << a_rightHandSide(cll, varId) << " /srf " << a_surfaceArea(srfcId) << " " << a_surfaceOrientation(srfcId)
           << " " << a_surfaceBndryCndId(srfcId) << " /ict "
           << a_hasProperty(a_surfaceNghbrCellId(srfcId, 0), SolverCell::IsInactive) << " "
           << a_hasProperty(a_surfaceNghbrCellId(srfcId, 1), SolverCell::IsInactive) << " /vol "
           << a_cellVolume(n0) / grid().gridCellVolume(a_level(n0)) << " "
           << a_cellVolume(n1) / grid().gridCellVolume(a_level(n1)) << " /vol0 " << a_cellVolume(n0) * a_FcellVolume(n0)
           << " " << a_cellVolume(n1) * a_FcellVolume(n1) << " /vol1 " << m_cellVolumesDt1[n0] * a_FcellVolume(n0)
           << " " << m_cellVolumesDt1[n1] * a_FcellVolume(n1) << " /ngb " << a_surfaceNghbrCellId(srfcId, 0) << " "
           << a_surfaceNghbrCellId(srfcId, 1) << " /var " << a_variable(a_surfaceNghbrCellId(srfcId, 0), pvarId) << " "
           << a_variable(a_surfaceNghbrCellId(srfcId, 1), pvarId);
      if(!a_isBndryGhostCell(a_surfaceNghbrCellId(srfcId, 0))) {
        cerr << " /ngbg " << c_globalId(a_surfaceNghbrCellId(srfcId, 0)) << " "
             << c_globalId(a_surfaceNghbrCellId(srfcId, 1));
      }
      cerr << endl;
      area_check[a_surfaceOrientation(srfcId)] -= a_surfaceArea(srfcId);
      flux_check[a_surfaceOrientation(srfcId)] -= flux[srfcId * ydim + varId];
    }
#endif

    RHS[a_surfaceNghbrCellId(srfcId, 0) * ydim] += flux[srfcId * ydim];
    RHS[a_surfaceNghbrCellId(srfcId, 1) * ydim] -= flux[srfcId * ydim];
    RHS[a_surfaceNghbrCellId(srfcId, 0) * ydim + 1] += flux[srfcId * ydim + 1];
    RHS[a_surfaceNghbrCellId(srfcId, 1) * ydim + 1] -= flux[srfcId * ydim + 1];
    RHS[a_surfaceNghbrCellId(srfcId, 0) * ydim + 2] += flux[srfcId * ydim + 2];
    RHS[a_surfaceNghbrCellId(srfcId, 1) * ydim + 2] -= flux[srfcId * ydim + 2];
    RHS[a_surfaceNghbrCellId(srfcId, 0) * ydim + 3] += flux[srfcId * ydim + 3];
    RHS[a_surfaceNghbrCellId(srfcId, 1) * ydim + 3] -= flux[srfcId * ydim + 3];
    IF_CONSTEXPR(nDim == 3) {
      RHS[a_surfaceNghbrCellId(srfcId, 0) * ydim + 4] += flux[srfcId * ydim + 4];
      RHS[a_surfaceNghbrCellId(srfcId, 1) * ydim + 4] -= flux[srfcId * ydim + 4];
      IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
        for(MInt r = 0; r < m_noRansEquations; ++r) {
          RHS[a_surfaceNghbrCellId(srfcId, 0) * ydim + 5 + r] += flux[srfcId * ydim + 5 + r];
          RHS[a_surfaceNghbrCellId(srfcId, 1) * ydim + 5 + r] -= flux[srfcId * ydim + 5 + r];
        }
      }
      for(MInt s = 0; s < m_noSpecies; s++) {
        RHS[a_surfaceNghbrCellId(srfcId, 0) * ydim + 5 + s + m_noRansEquations] +=
            flux[srfcId * ydim + 5 + s + m_noRansEquations];
        RHS[a_surfaceNghbrCellId(srfcId, 1) * ydim + 5 + s + m_noRansEquations] -=
            flux[srfcId * ydim + 5 + s + m_noRansEquations];
      }
    }
    else {
      IF_CONSTEXPR(SysEqn::m_noRansEquations > 0) {
        for(MInt r = 0; r < m_noRansEquations; ++r) {
          RHS[a_surfaceNghbrCellId(srfcId, 0) * ydim + 4 + r] += flux[srfcId * ydim + 4 + r];
          RHS[a_surfaceNghbrCellId(srfcId, 1) * ydim + 4 + r] -= flux[srfcId * ydim + 4 + r];
        }
      }
      for(MInt s = 0; s < m_noSpecies; s++) {
        RHS[a_surfaceNghbrCellId(srfcId, 0) * ydim + 4 + s + m_noRansEquations] +=
            flux[srfcId * ydim + 4 + s + m_noRansEquations];
        RHS[a_surfaceNghbrCellId(srfcId, 1) * ydim + 4 + s + m_noRansEquations] -=
            flux[srfcId * ydim + 4 + s + m_noRansEquations];
      }
    }


#ifdef _MB_DEBUG_
    for(MInt v = 0; v < m_noFVars; v++) {
      if(std::isnan(flux[srfcId * ydim + v])) {
        cerr << domainId() << ": flux is nan " << globalTimeStep << " " << m_RKStep << " " << srfcId << " "
             << getPrimitiveVarName(v) << " /n " << a_surfaceNghbrCellId(srfcId, 0) << " "
             << a_surfaceNghbrCellId(srfcId, 1) << " /v " << a_pvariable(a_surfaceNghbrCellId(srfcId, 0), v) << " "
             << a_pvariable(a_surfaceNghbrCellId(srfcId, 1), v) << " /b " << a_bndryId(a_surfaceNghbrCellId(srfcId, 0))
             << " " << a_bndryId(a_surfaceNghbrCellId(srfcId, 1)) << " /p " << a_isHalo(a_surfaceNghbrCellId(srfcId, 0))
             << " " << a_isHalo(a_surfaceNghbrCellId(srfcId, 1)) << " " << a_isWindow(a_surfaceNghbrCellId(srfcId, 0))
             << " " << a_isWindow(a_surfaceNghbrCellId(srfcId, 1)) << " /s "
             << a_slope(a_surfaceNghbrCellId(srfcId, 0), v, 0) << " " << a_slope(a_surfaceNghbrCellId(srfcId, 0), v, 1)
             << " " << a_slope(a_surfaceNghbrCellId(srfcId, 1), v, 0) << " "
             << a_slope(a_surfaceNghbrCellId(srfcId, 1), v, 1) << endl;
        // break;
      }
    }
#endif
  }

#ifdef _MB_DEBUG_
  if((gId > -1 && cll > -1) && (blk > -1 && domainId() == blk)) {
    if(!a_hasProperty(cll, SolverCell::IsInactive)) {
      MInt bcll = a_bndryId(cll);
      cerr << domainId() << ": area check " << cll << ": " << area_check[0] << " " << area_check[1] << " "
           << area_check[2] << " / " << a_rightHandSide(cll, varId) << " /vols "
           << a_cellVolume(cll) / grid().gridCellVolume(a_level(cll)) << " "
           << m_cellVolumesDt1[cll] / grid().gridCellVolume(a_level(cll)) << " "
           << ((bcll > -1) ? m_fvBndryCnd->m_bndryCells->a[bcll].m_volume / grid().gridCellVolume(a_level(cll)) : -1)
           << " / " << a_isHalo(cll) << endl;
      cerr << domainId() << ": flux check " << cll << ": " << flux_check[0] << " " << flux_check[1] << " "
           << flux_check[2] << " / " << a_variable(cll, pvarId) << " "
           << a_variable(cll, pvarId) / a_variable(cll, CV->RHO) << endl;
      cerr << domainId() << ": rhs " << cll << " ";
      for(MInt v = 0; v < m_noFVars; v++) {
        cerr << a_rightHandSide(cll, v) << "  ";
      }
      cerr << endl;
      for(MInt v = 0; v < m_noCVars; v++) {
        cerr << a_oldVariable(cll, v) << "  ";
      }
      cerr << endl;
      for(MInt v = 0; v < m_noFVars; v++) {
        cerr << timeStep() * a_FcellVolume(cll) * a_rightHandSide(cll, v) << "  ";
      }
      cerr << endl;
      for(MInt v = 0; v < m_noCVars; v++) {
        cerr << a_FcellVolume(cll)
                    * (m_cellVolumesDt1[cll] * a_oldVariable(cll, v) - timeStep() * a_rightHandSide(cll, v))
             << "  ";
      }
      cerr << endl;
    }
  }
#endif

  if(m_pointParticleTwoWayCoupling && m_noPointParticles > 0) {
    for(MInt cellId = 0; cellId < maxNoGridCells(); cellId++) {
      for(MInt dim = 0; dim < nDim; dim++) {
        m_coupling[cellId][dim] = F0;
      }
    }
    const MInt noCouplingLayers = 2;
    const MInt maxNoNghbrs = 150;
    MIntScratchSpace nghbrList(maxNoNghbrs, AT_, "nghbrList");
    MIntScratchSpace layerId(maxNoNghbrs, AT_, "layerList");
    MFloatScratchSpace weights(maxNoNghbrs, AT_, "weights");
    nghbrList.fill(-1);
    m_couplingRate = F0;
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      for(MInt j = 0; j < m_noMaxLevelHaloCells[i]; j++) {
        MInt cellId = m_maxLevelHaloCells[i][j];
        for(MInt v = 0; v < m_noFVars; v++) {
          a_rightHandSide(cellId, v) = F0;
        }
      }
    }
    MFloat expFac = F1B8;
    for(MUint p = 0; p < m_particleCellLink.size(); p++) {
      const MInt cellId = m_particleCellLink[p];
      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) cerr << "Warning: not a leaf cell!" << endl;
      const MFloat mass = F4B3 * PI * m_particleRadii[3 * p] * m_particleRadii[3 * p + 1] * m_particleRadii[3 * p + 2]
                          * m_densityRatio * m_rhoInfinity;
      const MFloat diameter =
          F2 * pow(m_particleRadii[3 * p] * m_particleRadii[3 * p + 1] * m_particleRadii[3 * p + 2], F1B3);
      const MFloat T = sysEqn().temperature_ES(a_pvariable(cellId, PV->RHO), a_pvariable(cellId, PV->P));
      const MFloat mue = SUTHERLANDLAW(T);
      const MFloat FAC = 18.0 * mue / (sysEqn().m_Re0 * m_densityRatio * m_rhoInfinity * POW2(diameter));
      const MInt counter =
          (noCouplingLayers > 0)
              ? 1 + this->template getAdjacentLeafCells<2>(cellId, noCouplingLayers, nghbrList, layerId)
              : 1;

      const MFloat heatFlux =
          m_particleHeatFlux[p] * 1 / m_gamma * 1 / (m_gamma - 1) * mass * m_capacityConstantVolumeRatio;

      if(noCouplingLayers > 0) nghbrList[counter - 1] = nghbrList[0];
      nghbrList[0] = cellId;
      MFloat sum = F0;
      for(MInt c = 0; c < counter; c++) {
        MFloat dx = F0;
        MInt nghbrId = nghbrList(c);
        for(MInt i = 0; i < nDim; i++) {
          dx += POW2(a_coordinate(nghbrId, i) - m_particleCoords[nDim * p + i]);
        }
        weights(c) = exp(-expFac * dx / POW2(c_cellLengthAtLevel(a_level(cellId))));
        sum += weights(c);
      }
      for(MInt c = 0; c < counter; c++) {
        weights(c) /= sum;
      }
      for(MInt c = 0; c < counter; c++) {
        MInt nghbrId = nghbrList(c);
        for(MInt i = 0; i < nDim; i++) {
          MFloat acc = m_particleAcceleration[nDim * p + i] - FAC * m_particleTerminalVelocity[i];
          a_rightHandSide(nghbrId, CV->RHO_VV[i]) += weights(c) * mass * acc;
          a_rightHandSide(nghbrId, CV->RHO_E) += weights(c) * a_pvariable(nghbrId, PV->VV[i]) * mass * acc;
          m_couplingRate -= weights(c) * mass * acc * a_pvariable(nghbrId, PV->VV[i]);
          m_coupling[nghbrId][i] -= weights(c) * mass * acc;
        }
        a_rightHandSide(nghbrId, CV->RHO_E) += weights(c) * heatFlux;
      }
    }
    MPI_Allreduce(MPI_IN_PLACE, &m_couplingRate, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "m_couplingRate");
    MIntScratchSpace haloBufferOffsets(noNeighborDomains() + 1, AT_, "haloBufferOffsets");
    MIntScratchSpace windowBufferOffsets(noNeighborDomains() + 1, AT_, "windowBufferOffsets");
    ScratchSpace<MPI_Request> sendReq(mMax(1, noNeighborDomains()), AT_, "sendReq");
    haloBufferOffsets.fill(0);
    windowBufferOffsets.fill(0);
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      haloBufferOffsets(i + 1) = haloBufferOffsets(i) + m_noFVars * m_noMaxLevelHaloCells[i];
      windowBufferOffsets(i + 1) = windowBufferOffsets(i) + m_noFVars * m_noMaxLevelWindowCells[i];
    }
    MFloatScratchSpace haloBuffer(haloBufferOffsets(noNeighborDomains()), AT_, "haloBuffer");
    MFloatScratchSpace windowBuffer(windowBufferOffsets(noNeighborDomains()), AT_, "windowBuffer");
    haloBuffer.fill(F0);
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      for(MInt j = 0; j < m_noMaxLevelHaloCells[i]; j++) {
        MInt cellId = m_maxLevelHaloCells[i][j];
        for(MInt v = 0; v < m_noFVars; v++) {
          haloBuffer(haloBufferOffsets(i) + m_noFVars * j + v) += a_rightHandSide(cellId, v);
        }
      }
    }
    sendReq.fill(MPI_REQUEST_NULL);
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      MPI_Issend(&haloBuffer[haloBufferOffsets(i)], m_noFVars * m_noMaxLevelHaloCells[i], MPI_DOUBLE, neighborDomain(i),
                 81, mpiComm(), &sendReq[i], AT_, "haloBuffer[haloBufferOffsets(i)]");
    }
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      MPI_Recv(&windowBuffer[windowBufferOffsets(i)], m_noFVars * m_noMaxLevelWindowCells[i], MPI_DOUBLE,
               neighborDomain(i), 81, mpiComm(), MPI_STATUS_IGNORE, AT_, "windowBuffer[windowBufferOffsets(i)]");
    }
    MPI_Waitall(noNeighborDomains(), &sendReq[0], MPI_STATUSES_IGNORE, AT_);
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      for(MInt j = 0; j < m_noMaxLevelWindowCells[i]; j++) {
        MInt cellId = m_maxLevelWindowCells[i][j];
        for(MInt v = 0; v < m_noFVars; v++) {
          a_rightHandSide(cellId, v) += windowBuffer(windowBufferOffsets(i) + m_noFVars * j + v);
        }
        for(MInt v = 0; v < nDim; v++) {
          m_coupling[cellId][v] -= windowBuffer(windowBufferOffsets(i) + m_noFVars * j + CV->RHO_VV[v]);
        }
      }
    }
  }


#ifdef _MB_DEBUG_
  m_solutionDiverged = false;
  for(MInt i = a_noCells(); i--;) {
    if(!a_hasProperty(i, SolverCell::IsActive)) continue;
    if(!a_hasProperty(i, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_isHalo(i)) continue;
    if(a_isBndryGhostCell(i)) continue;
    for(MInt v = 0; v < m_noFVars; v++) {
      if(!(a_rightHandSide(i, v) >= F0 || a_rightHandSide(i, v) < F0) || std::isnan(a_rightHandSide(i, v))) {
        cerr << "RHS0 " << i << " " << a_bndryId(i) << " " << v << " " << a_rightHandSide(i, v) << " "
             << "cells[i].b_properties.to_string()" << endl;
        m_solutionDiverged = true;
      }
    }
  }
  if(m_solutionDiverged) {
    cerr << "Solution diverged (RHS0) at solver " << domainId() << " " << globalTimeStep << " " << m_RKStep << endl;
    // writeVtkErrorFile();
  }
  MPI_Allreduce(MPI_IN_PLACE, &m_solutionDiverged, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                "m_solutionDiverged");
  if(m_solutionDiverged) {
    writeVtkXmlFiles("QOUT", "GEOM", false, true);
    MPI_Barrier(mpiComm(), AT_);
    mTerm(1, AT_, "Solution diverged after RHS0 handling.");
  }
#endif

  if(m_initialCondition == 452) {
    computeVolumeForces();
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::resetRHSCutOffCells() {
  FvCartesianSolverXD<nDim, SysEqn>::resetRHSCutOffCells();
}


/**
 * \brief calls a Runge Kutta substep
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
MBool FvMbCartesianSolverXD<nDim, SysEqn>::rungeKuttaStep() {
  return (this->*execRungeKuttaStep)();
}


/**
 * \brief
 * mode=0: total
 * mode=1: min
 * mode=2: max
 * mode=3: average
 * \author
 */
template <MInt nDim, class SysEqn>
MLong FvMbCartesianSolverXD<nDim, SysEqn>::getNumberOfCells(MInt mode) {
  MLong noCells = 0;
  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    if(!a_isHalo(cellId) && c_isLeafCell(cellId)) noCells++;
  }

  if(mode > -1) {
    switch(mode) {
      case 0:
        MPI_Allreduce(MPI_IN_PLACE, &noCells, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "noCells");
        break;
      case 1:
        MPI_Allreduce(MPI_IN_PLACE, &noCells, 1, MPI_LONG, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE", "noCells");
        break;
      case 2:
        MPI_Allreduce(MPI_IN_PLACE, &noCells, 1, MPI_LONG, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "noCells");
        break;
      case 3:
        MPI_Allreduce(MPI_IN_PLACE, &noCells, 1, MPI_LONG, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "noCells");
        noCells = (MLong)(((MFloat)noCells) / ((MFloat)noDomains()));
        break;
      default:
        mTerm(1, AT_, "Unknown case.");
    }
  }

  return noCells;
}


//! Computes the maxResiduum for all cells
/** This function computes the maxResidual using
 * Res = deltaT/(CFL*VolOfCell) * |RHS|
 *
 * checks if the computed max density residual
 * is below the convergence criterion and returns
 * boolean variable
 *
 */
template <MInt nDim, class SysEqn>
MBool FvMbCartesianSolverXD<nDim, SysEqn>::maxResidual(MInt mode) {
  TRACE();

  if(globalTimeStep % m_residualInterval != 0) {
    return true;
  }

  if(mode == 0 && (!m_trackMovingBndry || globalTimeStep < m_trackMbStart || globalTimeStep > m_trackMbEnd)) {
    // NOTE: calling the original Fv residual function for stationary problems where the residual
    //      can be used/outputted for convergence studies
    FvCartesianSolverXD<nDim, SysEqn>::maxResidual();
  }

  ScratchSpace<MFloat> bbox(m_noDirs, AT_, "bbox");
  for(MInt i = 0; i < nDim; i++) {
    bbox[i] = std::numeric_limits<MFloat>::max();
    bbox[nDim + i] = -std::numeric_limits<MFloat>::max();
  }

  const MInt oldRKStep[5] = {4, 0, 1, 2, 3};
  MBool nan = false;
  MInt counter = 0;
  MFloat maxR = -F1;
  MInt maxRC = -1;
  MInt nanC = -1;

  const MInt size = a_noCells();
  for(MInt cellId = size; cellId--;) {
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(a_isBndryGhostCell(cellId)) continue;
    if(a_isHalo(cellId)) continue;
    if(a_hasProperty(cellId, SolverCell::IsCutOff)) continue;
    if(a_bndryId(cellId) == -2) continue;

    if(fabs(a_rightHandSide(cellId, CV->RHO)) > maxR) {
      maxR = fabs(a_rightHandSide(cellId, CV->RHO));
      maxRC = cellId;
    }

    if((!(a_rightHandSide(cellId, CV->RHO) >= F0 || a_rightHandSide(cellId, CV->RHO) < F0))) {
      m_log << "RHS[rho] is " << a_rightHandSide(cellId, CV->RHO) << " in cell " << cellId << "(" << a_bndryId(cellId)
            << ") "
               " "
            << a_hasProperty(cellId, SolverCell::IsInactive) << " " << a_levelSetValuesMb(cellId, 0)
            << " vol:" << a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId)) << " / ";
      for(MInt i = 0; i < nDim; i++)
        m_log << " " << a_coordinate(cellId, i);
      m_log << " " << a_hasProperty(cellId, SolverCell::NearWall);
      m_log << " / " << a_noReconstructionNeighbors(cellId);
      m_log << " " << a_isHalo(cellId);
      m_log << " " << a_hasProperty(cellId, SolverCell::IsNotGradient);
      IF_CONSTEXPR(nDim == 2) {
        m_log << " p7: " << a_isHalo(c_neighborId(cellId, 0)) << " " << a_isHalo(c_neighborId(cellId, 1)) << " "
              << a_isHalo(c_neighborId(cellId, 2)) << " " << a_isHalo(c_neighborId(cellId, 3));
      }
      else IF_CONSTEXPR(nDim == 3) {
        m_log << " p7: " << a_isHalo(c_neighborId(cellId, 0)) << " " << a_isHalo(c_neighborId(cellId, 1)) << " "
              << a_isHalo(c_neighborId(cellId, 2)) << " " << a_isHalo(c_neighborId(cellId, 3)) << " "
              << a_isHalo(c_neighborId(cellId, 4)) << " " << a_isHalo(c_neighborId(cellId, 5));
      }
      m_log << endl;
      for(MInt i = 0; i < nDim; i++) {
        bbox[i] = mMin(bbox[i], a_coordinate(cellId, i));
        bbox[nDim + i] = mMax(bbox[nDim + i], a_coordinate(cellId, i));
      }
      nan = true;
      nanC = cellId;
      counter++;
    }

    if(counter > 1000) {
      m_log << "More than 1000 nan's; output suspended." << endl;
      break;
    }
  }

#ifdef _MB_DEBUG_
  MPI_Allreduce(MPI_IN_PLACE, &bbox[0], nDim, MPI_DOUBLE, MPI_MIN, mpiComm(), AT_, "MPI_IN_PLACE", "bbox[0]");
  MPI_Allreduce(MPI_IN_PLACE, &bbox[nDim], nDim, MPI_DOUBLE, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "bbox[nDim]");
#endif

  if(nan) {
    if(maxRC > -1) {
      m_log << "Maximum residual at time step " << globalTimeStep << " is " << maxR << " in cell " << maxRC << " at";
      for(MInt i = 0; i < nDim; i++)
        m_log << " " << a_coordinate(maxRC, i);
      m_log << ", res: " << scientific;
      for(MInt v = 0; v < m_noFVars; v++)
        m_log << " " << a_rightHandSide(maxRC, v);
      m_log << ", vol.: " << a_cellVolume(maxRC);
      m_log << ", vol.frac.: " << a_cellVolume(maxRC) / c_cellLengthAtLevel(a_level(maxRC));
      m_log << endl;
    }

    MFloat minVol = std::numeric_limits<MFloat>::max();
    MFloat minVolFrac = std::numeric_limits<MFloat>::max();
    MInt partitionCell = -1;
    for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
      MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
      if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume < minVol) {
        minVolFrac = m_volumeFraction[bndryId];
        minVol = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume;
        partitionCell = cellId;
      }
    }
    if(partitionCell > -1) {
      IF_CONSTEXPR(nDim == 2) {
        m_log << "Smallest cell: " << partitionCell << " " << minVol << " " << minVolFrac << " / "
              << m_fvBndryCnd->m_bndryCells->a[a_bndryId(partitionCell)].m_srfcs[0]->m_normalVector[0] << " "
              << m_fvBndryCnd->m_bndryCells->a[a_bndryId(partitionCell)].m_srfcs[0]->m_normalVector[1] << " "
              << " / " << a_rightHandSide(partitionCell, CV->RHO) << " " << a_rightHandSide(partitionCell, CV->RHO_U)
              << endl;
      }
      else IF_CONSTEXPR(nDim == 3) {
        m_log << "Smallest cell: " << partitionCell << " " << minVol << " " << minVolFrac << " / "
              << m_fvBndryCnd->m_bndryCells->a[a_bndryId(partitionCell)].m_srfcs[0]->m_normalVector[0] << " "
              << m_fvBndryCnd->m_bndryCells->a[a_bndryId(partitionCell)].m_srfcs[0]->m_normalVector[1] << " "
              << m_fvBndryCnd->m_bndryCells->a[a_bndryId(partitionCell)].m_srfcs[0]->m_normalVector[2] << " "
              << " / " << a_rightHandSide(partitionCell, CV->RHO) << " " << a_rightHandSide(partitionCell, CV->RHO_U)
              << endl;
      }
    }
    cerr << "========================" << endl;
    cerr << "time step " << globalTimeStep << ", Runge Kutta step " << oldRKStep[m_RKStep] << ", solver " << solverId()
         << endl;
    cerr << domainId() << ": Solution diverged (e.g. " << c_globalId(nanC) << ") in region ";
    for(MInt i = 0; i < nDim; i++) {
      cerr << "[" << bbox[i] << "," << bbox[nDim + i] << "]";
      if(i < nDim - 1) cerr << "x";
    }
    cerr << ". Quit." << endl;
    m_solutionDiverged = true;
  }

  MPI_Allreduce(MPI_IN_PLACE, &m_solutionDiverged, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                "m_solutionDiverged");

  if(m_solutionDiverged) {
#ifdef _MB_DEBUG_
    m_log << "=========== BOUNDARY LOG ================" << endl;
    const MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();
    for(MInt bndryId = m_noOuterBndryCells; bndryId < noBndryCells; bndryId++) {
      MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
      m_log << bndryId << " " << cellId;
      for(MInt dir = 0; dir < m_noDirs; dir++) {
        MInt cId = (c_neighborId(cellId, dir) > -1) ? m_bndryCandidateIds[c_neighborId(cellId, dir)] : -1;
        m_log << " / " << dir << " " << a_hasNeighbor(cellId, dir) << " " << c_neighborId(cellId, dir) << " " << cId;
      }
      m_log << endl;
    }
#endif
    saveSolverSolution(1);
    /*
    #ifdef _MB_DEBUG_
          for ( MInt cellId = 0; cellId < a_noCells(); cellId++ ) {
            a_hasProperty( cellId , SolverCell::IsOnCurrentMGLevel) = true;
          }
          stringstream filen;
          filen << "out/QDIV_" << domainId() << ".vtk";
          m_fvBndryCnd->recorrectCellCoordinates();
          extractPointIdsFromGrid( m_extractedCells, m_gridPoints, true, m_splitChildToSplitCell);
          for( MInt c = 0; c < m_extractedCells->size(); c++ ) {
     a_pvariable(m_extractedCells->a[ c ].m_cellId, PV->RHO) = a_levelSetValuesMb(m_extractedCells->a[ c
    ].m_cellId, 0);
          }
          writeVtkOutput( (filen.str()).c_str() );
          m_fvBndryCnd->rerecorrectCellCoordinates();
          if ( m_extractedCells ) { delete m_extractedCells; m_extractedCells = nullptr; }
          if ( m_gridPoints ) { delete m_gridPoints; m_gridPoints = nullptr; }
    #endif
    */
    MPI_Barrier(mpiComm(), AT_);
    mTerm(1, AT_, "Solution diverged.");
  } else {
    // saveSolverSolution(1); MPI_Barrier(mpiComm(), AT_ ); mTerm(0,AT_, "test");
    if(nan) mTerm(1, AT_, "Solution diverged.");

    return true;
  }

  return false;
}


/**
 * \brief filter nan's
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
inline MFloat FvMbCartesianSolverXD<nDim, SysEqn>::filterFloat(MFloat number) {
  // if ( std::isnan( number ) ) return (-1e33);
  // else return number;
  return number;
}


/**
 * \brief creates a moving boundary cell for the given cell
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
MInt FvMbCartesianSolverXD<nDim, SysEqn>::createBndryCellMb(MInt cellId) {
  if(cellId < 0) {
    cerr << "Critical error in createBndryCellMb: "
         << ", cell: " << cellId << endl;
    saveSolverSolution(1);
    mTerm(1, AT_, "Critical error in createBndryCellMb");
  }

  ASSERT(!a_isBndryCell(cellId), "");

  MInt bCellId = m_fvBndryCnd->m_bndryCells->size();
  m_fvBndryCnd->m_bndryCells->append();

#if defined _MB_DEBUG_ || !defined NDEBUG
  if(globalTimeStep > m_restartTimeStep) {
    if(a_levelSetValuesMb(cellId, 0) < F0 && !a_hasProperty(cellId, SolverCell::IsSplitChild)) {
      // not surprising during Gap-Closure!
      if(!a_isGapCell(cellId)) {
        if(!a_hasProperty(cellId, SolverCell::IsInactive)) {
          cerr << "not inact " << c_globalId(cellId) << endl;
        }
        if(m_oldBndryCells.size() > 0 && !m_oldBndryCells.count(cellId)) {
          if(!a_hasProperty(cellId, SolverCell::WasInactive)) {
            auto it = std::find(m_refOldBndryCells.begin(), m_refOldBndryCells.end(), c_parentId(cellId));
            if(it == m_refOldBndryCells.end()) {
              cerr << "CellId " << cellId << " " << c_globalId(cellId) << " isHalo " << a_isHalo(cellId)
                   << " is GapCell " << a_isGapCell(cellId) << " was GapCell " << a_wasGapCell(cellId)
                   << " was not inactive before and is a new bndryCell with Id " << bCellId << " ls-value "
                   << a_levelSetValuesMb(cellId, 0) << " at timeStep " << globalTimeStep << endl;
            }
          }
        }
      }
    }
  }
#endif

  for(MInt face = 0; face < m_noDirs; face++)
    m_fvBndryCnd->m_bndryCells->a[bCellId].m_associatedSrfc[face] = -1;

  a_bndryId(cellId) = bCellId;
  m_fvBndryCnd->m_bndryCells->a[bCellId].m_cellId = cellId;

  for(MInt srfc = 0; srfc < FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces; srfc++) {
    m_fvBndryCnd->m_bndryCells->a[bCellId].m_srfcs[srfc]->m_noCutPoints = 0;
    m_fvBndryCnd->m_bndryCells->a[bCellId].m_srfcVariables[srfc]->m_ghostCellId = -1;
    for(MInt i = 0; i < nDim; i++)
      m_fvBndryCnd->m_bndryCells->a[bCellId].m_srfcVariables[srfc]->m_srfcId[i] = -1;
    m_fvBndryCnd->m_bndryCells->a[bCellId].m_srfcs[srfc]->m_bndryCndId = -1; // m_movingBndryCndId;
    for(MInt v = 0; v < m_noCVars; v++) {
      m_fvBndryCnd->m_bndryCell[bCellId].m_srfcVariables[srfc]->m_variablesType[v] = BC_UNSET;
    }
    m_fvBndryCnd->m_bndryCells->a[bCellId].m_srfcs[srfc]->m_area = F0;
  }
  m_fvBndryCnd->m_bndryCell[bCellId].m_recNghbrIds.clear();
  m_fvBndryCnd->m_bndryCell[bCellId].m_faceVertices.clear();
  m_fvBndryCnd->m_bndryCell[bCellId].m_faceStream.resize(0);

  m_fvBndryCnd->m_bndryCells->a[bCellId].m_linkedCellId = -1;
  m_fvBndryCnd->m_bndryCells->a[bCellId].m_noSrfcs = 1;
  m_fvBndryCnd->m_bndryCells->a[bCellId].m_volume = F0;

  m_sweptVolume[bCellId] = F0;
  m_sweptVolumeDt1[bCellId] = F0;

  a_hasProperty(cellId, SolverCell::IsInactive) = false;
  a_hasProperty(cellId, SolverCell::IsFlux) = true;
  a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = true;
  a_hasProperty(cellId, SolverCell::IsMovingBnd) = true;

  for(MInt i = 0; i < nDim; i++) {
    m_fvBndryCnd->m_bndryCells->a[bCellId].m_coordinates[i] = F0;
  }

  for(MInt dir = 0; dir < m_noDirs; dir++) {
    m_cutFaceArea[bCellId][dir] = F0;
    MInt srfcId = m_cellSurfaceMapping[cellId][dir];
    if(srfcId > -1) {
      m_bndryCells->a[bCellId].m_associatedSrfc[dir] = m_cellSurfaceMapping[cellId][dir];
    }
  }

  m_noLsMbBndryCells++;

  return bCellId;
}


/**
 * \brief
 * \author Lennart Schneiders, Update Tim Wegmann
 */
template <MInt nDim, class SysEqn>
MInt FvMbCartesianSolverXD<nDim, SysEqn>::createSplitCell(MInt cellId, MInt noSplitChilds) {
  TRACE();

  const MInt splitId = m_splitCells.size();
  m_splitCells.push_back(cellId);
  m_splitChilds.resize(m_splitCells.size());
  m_splitChilds[splitId].resize(noSplitChilds);
  a_hasProperty(cellId, SolverCell::IsSplitCell) = false;

  for(MInt n = 0; n < noSplitChilds; n++) {
    const MInt splitChildId = a_noCells();

    m_cells.append();
    m_totalnosplitchilds++;

    ASSERT(splitChildId == a_noCells() - 1, "Error in the cell-count, for splitchilds!");

    for(MInt dir = 0; dir < m_noDirs; dir++) {
      m_cellSurfaceMapping[splitChildId][dir] = -1;
    }
    a_cellVolume(splitChildId) = a_cellVolume(cellId);
    m_cellVolumesDt1[splitChildId] = m_cellVolumesDt1[cellId];
    for(MInt k = 0; k < nDim; k++) {
      a_coordinate(splitChildId, k) = a_coordinate(cellId, k);
    }
    a_level(splitChildId) = a_level(cellId);

    a_isBndryGhostCell(splitChildId) = false;
    a_noReconstructionNeighbors(splitChildId) = 0;

    for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
      a_associatedBodyIds(splitChildId, set) = a_associatedBodyIds(cellId, set);
      a_levelSetValuesMb(splitChildId, set) = a_levelSetValuesMb(cellId, set);
    }

    a_copyPropertiesSolver(cellId, splitChildId);

    a_hasProperty(splitChildId, SolverCell::IsSplitCell) = false;
    a_hasProperty(splitChildId, SolverCell::IsSplitChild) = true;
    a_hasProperty(splitChildId, SolverCell::IsInactive) = false;
    a_hasProperty(splitChildId, SolverCell::WasInactive) = a_hasProperty(cellId, SolverCell::WasInactive);

    for(MInt var = 0; var < CV->noVariables; var++) {
      a_variable(splitChildId, var) = a_variable(cellId, var);
      a_oldVariable(splitChildId, var) = a_variable(cellId, var);
      a_pvariable(splitChildId, var) = a_pvariable(cellId, var);
    }

    a_bndryId(splitChildId) = createBndryCellMb(splitChildId);
    ASSERT(a_bndryId(splitChildId) > -1, "");
    MInt splitChildBndryId = a_bndryId(splitChildId);
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      m_bndryCells->a[splitChildBndryId].m_associatedSrfc[dir] = -1;
      m_bndryCells->a[splitChildBndryId].m_externalFaces[dir] = false;
    }
    m_splitChilds[splitId][n] = splitChildId;
    m_splitChildToSplitCell.insert(pair<MInt, MInt>(splitChildId, cellId));

    m_bndryLayerCells.push_back(splitChildId);
    a_hasProperty(splitChildId, SolverCell::NearWall) = true;

    ASSERT(a_level(splitChildId) == a_level(m_splitChildToSplitCell.find(splitChildId)->second), "");
  }

  a_hasProperty(cellId, SolverCell::IsSplitCell) = true;

  ASSERT(splitId > -1, "");
  return splitId;
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::setOuterBoundaryGhostCells() {
  TRACE();

  m_bndryGhostCellsOffset = a_noCells();
  m_fvBndryCnd->computeGhostCells();

  for(MInt bndryId = 0; bndryId < m_noOuterBndryCells; bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    const MInt noSrfcs = m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs;
    for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
      a_reconstructionNeighborId(cellId, srfc) =
          m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
    }
    for(MInt srfc = 0; srfc < noSrfcs; srfc++) {
      const MInt ghostCellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
      for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
        a_associatedBodyIds(ghostCellId, set) = -1;
      }
    }
  }
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::setOuterBoundarySurfaces() {
  TRACE();

  correctMasterSlaveSurfaces();
  m_bndrySurfacesOffset = a_noSurfaces();
  m_fvBndryCnd->addBoundarySurfaces();

  for(MInt srfcId = m_bndrySurfacesOffset; srfcId < a_noSurfaces(); srfcId++) {
    a_surfaceUpwindCoefficient(srfcId) = m_globalUpwindCoefficient;
    a_surfaceFactor(srfcId, 0) = F1B2;
    a_surfaceFactor(srfcId, 1) = F1B2;
    for(MInt i = 0; i < nDim; i++) {
      a_surfaceDeltaX(srfcId, i) = a_surfaceCoordinate(srfcId, i) - a_coordinate(a_surfaceNghbrCellId(srfcId, 0), i);
      a_surfaceDeltaX(srfcId, nDim + i) =
          a_surfaceCoordinate(srfcId, i) - a_coordinate(a_surfaceNghbrCellId(srfcId, 1), i);
    }
  }
  m_noOuterBoundarySurfaces = m_fvBndryCnd->m_noBoundarySurfaces;
}


/**
 * \brief creates a ghost cell for all cells near(!) the moving boundary
 * \author Lennart Schneiders
 * 1. determine ghost cells for normal boundary cells and predicted boundary cells
 * 2. sets m_predictedGhostCellsOffset
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::computeGhostCellsMb() {
  TRACE();

  MInt noOuterBndryGhostCells = 0;
  for(MInt bndryId = 0; bndryId < m_noOuterBndryCells; bndryId++) {
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      noOuterBndryGhostCells++;
    }
  }
  m_associatedInternalCells.resize(noOuterBndryGhostCells);

  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId = -1;
    }
  }

  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;

    if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      // append a cell to the fv-cell collectors
      m_cells.append();
      m_totalnoghostcells++;

      MInt ghostCellId = a_noCells() - 1;
      m_associatedInternalCells.push_back(cellId);

      m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId = ghostCellId;

      a_cellVolume(ghostCellId) = grid().gridCellVolume(a_level(cellId));
      m_cellVolumesDt1[ghostCellId] = grid().gridCellVolume(a_level(cellId));
      a_FcellVolume(ghostCellId) = F1 / a_cellVolume(ghostCellId);

      const MFloat cellLength = c_cellLengthAtLevel(a_level(cellId));
      const MFloat cellHalfLength = F1B2 * cellLength;

      MFloat dn = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_centroidDistance;

      for(MInt i = 0; i < nDim; i++) {
        a_coordinate(ghostCellId, i) =
            a_coordinate(cellId, i)
            - mMax(F2 * dn, dn + cellHalfLength) * m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVectorCentroid[i];
      }

      for(MInt set0 = 0; set0 < m_noLevelSetsUsedForMb; set0++) {
        a_associatedBodyIds(ghostCellId, set0) = -1;
      }
      a_resetPropertiesSolver(ghostCellId);
      a_noReconstructionNeighbors(ghostCellId) = 0;
      a_level(ghostCellId) = a_level(cellId);

      for(MInt var = 0; var < CV->noVariables; var++) {
        a_variable(ghostCellId, var) = a_variable(cellId, var);
        a_oldVariable(ghostCellId, var) = a_variable(cellId, var);
        a_pvariable(ghostCellId, var) = a_pvariable(cellId, var);
        for(MInt i = 0; i < nDim; i++)
          a_slope(ghostCellId, var, i) = F0;
      }

      a_bndryId(ghostCellId) = -2;
      a_isBndryGhostCell(ghostCellId) = 1;
      ASSERT(a_level(ghostCellId) == a_level(getAssociatedInternalCell(ghostCellId)), "");
    }
  }

  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;
    // if ( a_hasProperty(cellId, SolverCell::IsNotGradient) ) continue;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId < 0)
        mTerm(1, AT_, "Ghost cell missing.");
    }
    for(MInt srfc = 1; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId
         == m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc - 1]->m_ghostCellId)
        mTerm(1, AT_, "Ghost cell duplicate.");
    }
  }
}


/**
 * \brief writes the velocity at the center line of the domain
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::writeCenterLineVel(const MChar* fileName) {
  TRACE();

  if(noDomains() > 1) {
    const MFloat Y0 = F1B2 * (m_bbox[4] + m_bbox[1]);
    const MFloat DX = c_cellLengthAtLevel(maxRefinementLevel());
    const MInt bodyId = 0;
    const MInt noPoints = (MInt)((m_bbox[3] - m_bbox[0]) / DX);
    const MInt noAngles = (MInt)(m_bodyDiameter[bodyId] / DX);
    const MFloat DA = PI / ((MFloat)noAngles);

    ScratchSpace<MFloat> lineData(noPoints, m_noPVars, AT_, "lineData");
    ScratchSpace<MFloat> lineCoords(noPoints, nDim, AT_, "lineCoords");
    ScratchSpace<MFloat> lineCnt(noPoints, AT_, "lineCnt");
    ScratchSpace<MFloat> angleData(noAngles, 3, AT_, "angleData");
    ScratchSpace<MFloat> angleCnt(noAngles, AT_, "angleCnt");

    lineData.fill(F0);
    lineCoords.fill(F0);
    lineCnt.fill(F0);
    angleData.fill(F0);
    angleCnt.fill(F0);
    MFloat TfluidMean = F0;
    MFloat meanBodyTemp = F0;

    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      if(a_isBndryGhostCell(cellId)) continue;
      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
      if(a_isHalo(cellId)) continue;
      if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;

      MBool isInside = false;
      IF_CONSTEXPR(nDim == 2) {
        if(fabs(a_coordinate(cellId, 1) - Y0) < c_cellLengthAtCell(cellId)) {
          isInside = true;
        }
      }
      IF_CONSTEXPR(nDim == 3) {
        const MFloat Z0 = F1B2 * (m_bbox[5] + m_bbox[2]);
        if(fabs(a_coordinate(cellId, 1) - Y0) < c_cellLengthAtCell(cellId)
           && fabs(a_coordinate(cellId, 2) - Z0) < c_cellLengthAtCell(cellId)) {
          isInside = true;
        }
      }

      if(isInside) {
        if(fabs(a_coordinate(cellId, 1) - Y0) < c_cellLengthAtCell(cellId)) {
          MInt id = (MInt)((a_coordinate(cellId, 0) - m_bbox[0]) / DX);
          if(id < 0 || id >= noPoints) {
            continue;
            // mTerm(1,AT_, "index out of range (line data).");
          }
          for(MInt i = 0; i < nDim; i++)
            lineCoords(id, i) += a_coordinate(cellId, i);
          for(MInt i = 0; i < nDim; i++)
            lineData(id, i) += a_pvariable(cellId, PV->VV[i]) / m_UInfinity;
          lineData(id, nDim) += a_pvariable(cellId, PV->P) / m_PInfinity;
          lineData(id, nDim + 1) += a_pvariable(cellId, PV->RHO) / m_rhoInfinity;
          lineCnt(id) += F1;
        }
      }
    }

    for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
      MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
      if(a_isHalo(cellId)) continue;
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        if(m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bodyId[0] != bodyId) continue;
        MFloat dx =
            m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[0] - m_bodyCenter[bodyId * nDim];
        // if ( fabs(m_fvBndryCnd->m_bndryCells->a[ bndryId ].m_srfcs[srfc]->m_coordinates[2]) > 0.8*DX ) continue;
        if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area < 0.001 * m_gridCellArea[maxRefinementLevel()])
          continue;
        MFloat dr = F0;
        IF_CONSTEXPR(nDim == 2) {
          dr = sqrt(POW2(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[1]
                         - m_bodyCenter[bodyId * nDim + 1]));
        }
        else IF_CONSTEXPR(nDim == 3) {
          dr = sqrt(POW2(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[1]
                         - m_bodyCenter[bodyId * nDim + 1])
                    + POW2(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[2]
                           - m_bodyCenter[bodyId * nDim + 2]));
        }
        MFloat angle = atan2(dr, dx);
        MInt id = (MInt)(angle / DA);
        if(id < 0 || id >= noAngles) mTerm(1, AT_, "index out of range (angle data): " + to_string(id));
        MFloat rhoU2 = F0;
        for(MInt i = 0; i < nDim; i++) {
          rhoU2 += POW2(m_VVInfinity[i]);
        }
        rhoU2 *= m_rhoInfinity;
        MFloat rhoSurface = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->RHO];
        MFloat pSurface = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->P];
        MFloat T = sysEqn().temperature_ES(rhoSurface, pSurface);
        MFloat cp = (pSurface - m_PInfinity) / (F1B2 * rhoU2);

        MFloat shear[3]{};
        MFloat mue = SUTHERLANDLAW(T) / sysEqn().m_Re0;
        for(MInt i = 0; i < nDim; i++) {
          MFloat grad = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[PV->VV[i]];
          shear[i] = mue * grad;
        }

        MFloat cf = sqrt(POW2(shear[0]) + POW2(shear[1]) + POW2(shear[2])) / (F1B2 * rhoU2);
        if(m_euler) cf = (a_pvariable(cellId, PV->P) - m_PInfinity) / (F1B2 * rhoU2);

        MFloat weight = F1;
        angleData(id, 0) += weight * cp;
        angleData(id, 1) += weight * cf;
        angleData(id, 2) += weight * m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
        angleCnt(id) += weight;
      }
    }

    MPI_Allreduce(MPI_IN_PLACE, &lineCoords[0], noPoints * nDim, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "lineCoords[0]");
    MPI_Allreduce(MPI_IN_PLACE, &lineData[0], noPoints * m_noPVars, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "lineData[0]");
    MPI_Allreduce(MPI_IN_PLACE, &lineCnt[0], noPoints, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "lineCnt[0]");
    MPI_Allreduce(MPI_IN_PLACE, &angleData[0], noAngles * 3, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "angleData[0]");
    MPI_Allreduce(MPI_IN_PLACE, &angleCnt[0], noAngles, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "angleCnt[0]");

    if(domainId() == 0) {
      ofstream ofl;
      ofl.open(fileName);
      if(ofl.is_open() && ofl.good()) {
        const MInt maxSkipCnt = IPOW2(maxRefinementLevel() - maxUniformRefinementLevel());
        MInt skipCnt = 0;
        for(MInt p = 0; p < noPoints; p++) {
          if(lineCnt(p) < F1) {
            skipCnt++;
            if(skipCnt == maxSkipCnt) ofl << endl;
            continue;
          }
          skipCnt = 0;
          // ofl << m_bbox[0] + ((MFloat)p)*DX + F1B2*DX;
          for(MInt i = 0; i < nDim; i++) {
            ofl << " " << lineCoords(p, i) / lineCnt(p);
          }
          for(MInt i = 0; i < m_noPVars; i++) {
            ofl << " " << lineData(p, i) / lineCnt(p);
          }
          ofl << " " << lineCnt(p) << endl;
        }
        ofl.close();
        ofl.clear();
      } else {
        cerr << "ERROR! COULD NOT OPEN FILE " << fileName << " for writing!" << endl;
      }
    }
    if(domainId() == 1) {
      ofstream ofl;
      ofl.open("surfaceData");
      if(ofl.is_open() && ofl.good()) {
        for(MInt p = 0; p < noAngles; p++) {
          if(angleCnt(p) < 1e-10) continue;
          MFloat angle = PI - (((MFloat)p) * DA + F1B2 * DA);
          ofl << angle;
          ofl << " " << angleData(p, 0) / angleCnt(p);
          ofl << " " << angleData(p, 1) / angleCnt(p);
          ofl << " " << angleData(p, 2) / (angleCnt(p) * m_gridCellArea[maxRefinementLevel()]);
          ofl << " " << angleCnt(p) << endl;
        }
        ofl.close();
        ofl.clear();
      }
      if(globalTimeStep == 0) {
        ofl.open("surfaceTemp", ios_base::out | ios_base::trunc);
        ofl << "# 1:ts 2:t 3:tf 4:Tf 5:Tp" << endl;
      } else
        ofl.open("surfaceTemp", ios_base::out | ios_base::app);
      if(ofl.is_open() && ofl.good()) {
        ofl << globalTimeStep << " " << m_time << " " << m_physicalTime // <-- time (1-3)
            << " " << setprecision(12) << TfluidMean / m_TInfinity << " " << setprecision(12)
            << meanBodyTemp / m_TInfinity // (69-70)
            << endl;
        ofl.close();
      } else {
        cerr << "ERROR! COULD NOT OPEN FILE " << fileName << " for writing!" << endl;
      }
    }
  } else {
    MInt noCells = a_noCells();
    // MInt         cellId,         counter,        nghbrId;
    ofstream ofl;
    MBool centerLine, centerLine2;
    MFloat u, v;
    ScratchSpace<MFloat> cellIdList(2, noCells, AT_, "cellIdList");
    MFloat tmpCellId, tmpCellCoordinate;

    MInt counter = 0;
    for(MInt cellId = 0; cellId < noCells; cellId++) {
      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
      if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
      if(a_isBndryGhostCell(cellId)) continue;
      centerLine = false;
      centerLine2 = false;

      if(a_coordinate(cellId, 1) >= F0 && a_hasNeighbor(cellId, 2) > 0
         && a_coordinate(c_neighborId(cellId, 2), 1) < F0) {
        centerLine = true;
        // nghbrId                            = c_neighborId( cellId ,  2 );
      }
      IF_CONSTEXPR(nDim == 2) { centerLine2 = true; }
      IF_CONSTEXPR(nDim == 3) {
        if(a_coordinate(cellId, 2) >= F0 && a_hasNeighbor(cellId, 4) > 0
           && a_coordinate(c_neighborId(cellId, 4), 2) < F0) {
          centerLine2 = true;
        }
      }
      if(!centerLine || !centerLine2) continue;

      cellIdList(0, counter) = (MFloat)cellId;
      cellIdList(1, counter) = a_coordinate(cellId, 0);
      counter++;
    }

    for(MInt c = 0; c < counter; c++) {
      for(MInt d = c + 1; d < counter; d++) {
        if(cellIdList(1, d) < cellIdList(1, c)) {
          tmpCellId = cellIdList(0, c);
          tmpCellCoordinate = cellIdList(1, c);
          cellIdList(0, c) = cellIdList(0, d);
          cellIdList(1, c) = cellIdList(1, d);
          cellIdList(0, d) = tmpCellId;
          cellIdList(1, d) = tmpCellCoordinate;
        }
      }
    }

    ofl.open(fileName);
    if(ofl.is_open() && ofl.good()) {
      for(MInt c = 0; c < counter; c++) {
        MInt cellId = (MInt)cellIdList(0, c);

        u = a_variable(cellId, 0) / a_variable(cellId, CV->RHO) - a_coordinate(cellId, 1) * a_slope(cellId, PV->U, 1);
        v = a_variable(cellId, 1) / a_variable(cellId, CV->RHO) - a_coordinate(cellId, 1) * a_slope(cellId, PV->V, 1);

        IF_CONSTEXPR(nDim == 3) {
          u -= a_coordinate(cellId, 2) * a_slope(cellId, PV->U, 2);
          v -= a_coordinate(cellId, 2) * a_slope(cellId, PV->V, 2);
        }

        ofl << a_coordinate(cellId, 0) << "  ";
        ofl << u / m_UInfinity << "  ";
        ofl << v / m_UInfinity << "  ";
        ofl << a_variable(cellId, CV->RHO) << "  ";
        ofl << a_pvariable(cellId, PV->P) << "  ";
        ofl << a_variable(cellId, CV->RHO) / m_rhoInfinity << "  ";
        ofl << a_pvariable(cellId, PV->P) / m_PInfinity << "  ";
        ofl << endl;
      }
      ofl.close();
      ofl.clear();
    } else {
      cerr << "ERROR! COULD NOT OPEN FILE " << fileName << " for writing!" << endl;
    }

    MFloat pavg = F0;
    MFloat rhoavg = F0;
    MFloat uavg = F0;
    MFloat cnt = F0;
    MFloat pavg2 = F0;
    MFloat rhoavg2 = F0;
    MFloat uavg2 = F0;
    MFloat vol = F0;
    MFloat vel = F0;
    MFloat temp = F0;
    MFloat xsa = F0;
    MFloat p0 = F0;
    MFloat p00 = F0;
    MFloat p00cnt = F0;
    const MFloat vs = m_Ma * (m_gamma + F1) / F4 + sqrt(POW2(m_Ma * (m_gamma + F1) / F4) + F1);
    const MFloat xs = F1B2 + vs * (m_physicalTime - timeStep());
    const MFloat xp = m_Ma * (m_physicalTime - timeStep());

    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
      if(a_hasProperty(cellId, SolverCell::IsCutOff)) continue;
      if(a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
      if(a_isPeriodic(cellId)) continue;
      if(a_isBndryGhostCell(cellId)) continue;
      if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
      if(a_coordinate(cellId, 0) > xp) {
        xsa += a_pvariable(cellId, PV->U) * a_cellVolume(cellId);
      }
      if(a_coordinate(cellId, 0) < xp) {
        p0 += a_pvariable(cellId, PV->P) * a_cellVolume(cellId);
        if(!checkNeighborActive(cellId, 1) || a_hasNeighbor(cellId, 1) == 0) {
          p00 += a_pvariable(cellId, PV->P);
          p00cnt += F1;
        }
      }
      if(a_coordinate(cellId, 0) > xp && a_coordinate(cellId, 0) < xs) {
        vel += a_cellVolume(cellId) * a_pvariable(cellId, PV->U);
        temp +=
            a_cellVolume(cellId) * sysEqn().temperature_ES(a_pvariable(cellId, PV->RHO), a_pvariable(cellId, PV->P));
        vol += a_cellVolume(cellId);
      }
      if(a_coordinate(cellId, 0) < xp || a_coordinate(cellId, 0) > xp + 5.0) continue;
      pavg += a_pvariable(cellId, PV->P);
      rhoavg += a_pvariable(cellId, PV->RHO);
      uavg += a_pvariable(cellId, PV->U);
      cnt += F1;
      if(a_coordinate(cellId, 0) < xp || a_coordinate(cellId, 0) > xp + 2.5) continue;
      pavg2 += a_pvariable(cellId, PV->P);
      rhoavg2 += a_pvariable(cellId, PV->RHO);
      uavg2 += a_pvariable(cellId, PV->U);
    }
    cerr << "piston front vars: " << setprecision(14) << xp << " " << xs << " "
         << timeStep() * m_Ma / c_cellLengthAtLevel(maxRefinementLevel()) << " " << pavg / cnt << " " << rhoavg / cnt
         << " "
         << uavg / cnt
         << " " << vel / mMax(1e-14, vol) << " " << temp / mMax(1e-14, vol) << " " << xp + F1B2 + xsa / (m_Ma * 16.0)
         << " " << p0 / 16.0 << " " << p00 / p00cnt << endl;
  }
}


/**
 * \brief resets the solver
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::resetSolverFull() {
  TRACE();

  FvCartesianSolverXD<nDim, SysEqn>::resetSolverFull();

  for(MInt cellId = 0; cellId < maxNoGridCells(); cellId++) {
    for(MInt v = 0; v < m_noFVars; v++) {
      m_rhs0[cellId][v] = F0;
    }
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      m_cellSurfaceMapping[cellId][dir] = -1;
    }
    m_cellVolumesDt1[cellId] = F0;
    a_levelSetValuesMb(cellId, 0) = c_cellLengthAtLevel(0);
  }

  m_initialSurfacesOffset = 0;
  m_nearBoundaryBackup.clear();
  m_oldBndryCells.clear();

  std::map<MInt, std::vector<MFloat>>().swap(m_nearBoundaryBackup);
  std::map<MInt, MFloat>().swap(m_oldBndryCells);
  std::vector<MInt>().swap(m_bndryCandidateIds);
  std::vector<MInt>().swap(m_bndryCandidates);
  std::vector<MFloat>().swap(m_candidateNodeValues);
  std::vector<MInt>().swap(m_candidateNodeSet);
  std::set<MInt>().swap(m_splitSurfaces);
  std::vector<CutCandidate<nDim>>().swap(m_cutCandidates);
}


/**
 * \brief Reset the solver prior to load balancing.
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::resetSolver() {
  if(m_fvBndryCnd->m_cellCoordinatesCorrected) m_fvBndryCnd->recorrectCellCoordinates();

  restoreNeighbourLinks();
  FvCartesianSolverXD<nDim, SysEqn>::resetSolver();
}


/**
 * \brief resets the solver to an empty domain without moving boundary
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::resetSolverMb() {
  TRACE();

  if(m_deleteNeighbour) {
    restoreNeighbourLinks();
  }

  for(MInt bs = 0; bs < m_fvBndryCnd->m_noBoundarySurfaces; bs++) {
    MInt srfcId = m_fvBndryCnd->m_boundarySurfaces[bs];
    a_surfaceNghbrCellId(srfcId, 0) = -1;
    a_surfaceNghbrCellId(srfcId, 1) = -1;
  }
  m_fvBndryCnd->m_noBoundarySurfaces = 0;

  m_surfaces.size(m_bndrySurfacesOffset);

  if(m_fvBndryCnd->m_cellCoordinatesCorrected) m_fvBndryCnd->recorrectCellCoordinates();

  set<MInt> tmpSplitSurf(m_splitSurfaces);
  m_splitSurfaces.clear();
  for(set<MInt>::iterator it = tmpSplitSurf.begin(); it != tmpSplitSurf.end(); ++it) {
    MInt srfcId = *it;
    deleteSurface(srfcId);
  }

  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_isBndryGhostCell(cellId) || a_hasProperty(cellId, SolverCell::IsSplitChild)) {
      removeSurfaces(cellId);
      continue;
    }
    resetSurfaces(cellId);
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      m_cutFaceArea[bndryId][dir] = F0;
    }
  }

  FvCartesianSolverXD<nDim, SysEqn>::resetBoundaryCells(m_noOuterBndryCells);
  m_noLsMbBndryCells = 0;
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::resetSurfaces() {
  TRACE();

  FvCartesianSolverXD<nDim, SysEqn>::resetSurfaces();

  for(MInt cellId = 0; cellId < maxNoGridCells(); cellId++) {
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      m_cellSurfaceMapping[cellId][dir] = -1;
    }
  }
  m_freeSurfaceIndices.clear();
  m_noSurfaces = 0;
}


/**
 * \brief resets all moving boundary cells - STL boundary remains intact
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::resetMbBoundaryCells() {
  TRACE();

  MInt size;
  MInt noCells = m_fvBndryCnd->m_bndryCells->size();

  // delete previous moving boundary cells
  for(MInt bndryId = noCells - 1; bndryId >= m_noOuterBndryCells; bndryId--) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;

    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      MInt ghostCellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
      if(ghostCellId > -1) {
        ASSERT(a_bndryId(ghostCellId) == -2, "");
        a_bndryId(ghostCellId) = -1;
      }
      m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId = -1;
    }

    a_bndryId(cellId) = -1;

    size = m_fvBndryCnd->m_bndryCells->size();
    m_fvBndryCnd->m_bndryCells->resetSize(size - 1);

    a_hasProperty(cellId, SolverCell::IsSplitCell) = false;
    a_hasProperty(cellId, SolverCell::IsSplitChild) = false;
    a_hasProperty(cellId, SolverCell::HasSplitFace) = false;
    a_hasProperty(cellId, SolverCell::IsTempLinked) = false;
    a_hasProperty(cellId, SolverCell::IsMovingBnd) = false;

    a_noReconstructionNeighbors(cellId) = 0;
    m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.resize(0);
    m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst.resize(0);
    m_fvBndryCnd->m_bndryCell[bndryId].m_faceVertices.clear();
    for(MUint i = 0; i < m_fvBndryCnd->m_bndryCell[bndryId].m_faceStream.size(); i++) {
      m_fvBndryCnd->m_bndryCell[bndryId].m_faceStream[i].resize(0);
    }
    m_fvBndryCnd->m_bndryCell[bndryId].m_faceStream.resize(0);
    for(MInt srfc = 0; srfc < FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces; srfc++) {
      m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst.resize(0);
      for(MInt v = 0; v < m_noCVars; v++) {
        m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_variablesType[v] = BC_UNSET;
      }
    }

    for(MInt dir = 0; dir < m_noDirs; dir++) {
      m_cutFaceArea[bndryId][dir] = F0;
    }

    if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId > -1) {
      cerr << "linking not expected" << endl;
      MInt pm = m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId;
      a_cellVolume(pm) = grid().gridCellVolume(a_level(pm));
      a_FcellVolume(pm) = F1 / mMax(m_volumeThreshold, a_cellVolume(pm));
      m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId = -1;
    }
  }
  m_noLsMbBndryCells = 0;

  for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
    ASSERT(!a_hasProperty(cellId, SolverCell::IsMovingBnd), "");
  }
}


/**
 * \brief deletes links to neighbours tagged inactive
 * \author Lennart Schneiders, Update Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::deleteNeighbourLinks() {
  TRACE();

  // 1. delete neighbour links towards inactive levelset region
  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;

    // check all directions for neighbours in inactive levelset region
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      if(!a_hasProperty(cellId, SolverCell::IsSplitChild) && a_hasNeighbor(cellId, dir) > 0) {
        const MInt nghbrId = c_neighborId(cellId, dir);
        if(a_hasProperty(nghbrId, SolverCell::IsInactive)) {
          a_hasProperty(cellId, SolverCell::IsBndryActive) = true;
          break;
        }
      }
    }
  }
  m_deleteNeighbour = true;
}


/**
 * \brief  restores previously deleted neighbour information and reactivates cells
 * \author Lennart Schneiders, Update Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::restoreNeighbourLinks() {
  TRACE();

  m_deleteNeighbour = false;
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    a_hasProperty(cellId, SolverCell::IsBndryActive) = false;
  }
}


/**
 * \brief initializes variables of cells which recently became active
 *        and therefore have no up-to-date history in the fluid phase
 *        (for MAIA_FV_MB_NEW_RK only for m_gapOpened )
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::initializeEmergedCells() {
  TRACE();

  cerr << globalTimeStep << " Calling initializeEmergedCells(), due to Gap-opening " << endl;

  MIntScratchSpace nghbrList(150, AT_, "nghbrList");
  MIntScratchSpace layerId(150, AT_, "layerList");
  MBoolScratchSpace gapCell(a_noCells(), AT_, "gapCell");

  // a) mark all cells which were an inactive GapCell
  //   and are now an active and are not a GapCell anymore!
  //   CAUTION: this includes BndryGhostCells!
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    gapCell[cellId] = false;
    if(m_levelSet && m_closeGaps) {
      if(a_hasProperty(cellId, SolverCell::WasGapCell) && !a_hasProperty(cellId, SolverCell::IsGapCell)
         && a_hasProperty(cellId, SolverCell::WasInactive) && !a_hasProperty(cellId, SolverCell::IsInactive)) {
        gapCell[cellId] = true;

        cerr << "initializeEmergedCells:  GapCells are " << cellId << " " << c_globalId(cellId) << " bndry-ghostCell "
             << a_isBndryGhostCell(cellId) << endl;
      }
    }
  }

  // b) labels:FVMB claudia temporary bugfix for initialization of nan outside cells...

  //    All cells that are active, but were inactive before are initialized!
  //    Also non-Gap-Cells!
  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;

    if(a_isHalo(cellId)) continue;
    if(a_isPeriodic(cellId)) continue;
    if(!a_hasProperty(cellId, SolverCell::WasInactive)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;

    // resetting all emerging Cells!
    cerr << "initializeEmergedCell: resetting Gap-Cells  " << cellId << " " << c_globalId(cellId) << endl;

    a_variable(cellId, CV->RHO) = m_rhoInfinity;
    a_variable(cellId, CV->RHO_E) = m_rhoEInfinity;
    a_pvariable(cellId, PV->RHO) = m_rhoInfinity;
    a_pvariable(cellId, PV->P) = m_PInfinity;

    for(MInt v = 0; v < nDim; v++) {
      a_variable(cellId, CV->RHO_VV[v]) = F0;
      a_pvariable(cellId, PV->VV[v]) = F0;
    }
  }

  // Initialize all cells newly created in the valve gap
  if(m_gapOpened) {
    initEmergingGapCells();
  }

  m_noEmergedCells = 0;
  m_noEmergedWindowCells = 0;

  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    ASSERT(cellId < a_noCells(), "");
    if(a_isHalo(cellId)) continue;
    if(a_isPeriodic(cellId)) continue;
    if(!a_hasProperty(cellId, SolverCell::WasInactive)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    m_noEmergedCells++;
    if(a_isWindow(cellId)) m_noEmergedWindowCells++;

    if(a_hasProperty(cellId, SolverCell::IsSplitCell)) {
      for(MInt v = 0; v < m_noCVars; v++) {
        a_variable(cellId, v) = F0;
      }
      for(MInt v = 0; v < m_noPVars; v++) {
        a_pvariable(cellId, v) = F0;
      }
      continue;
    }

    cerr << "initializeEmergedCell: init Cells " << cellId << " " << c_globalId(cellId) << endl;


    if(!gapCell[cellId]) {
      MFloatScratchSpace vars(m_noCVars, AT_, "vars");
      const MInt counter = this->template getAdjacentLeafCells<2>(cellId, 1, nghbrList, layerId);
      MFloat facCnt = F0;
      for(MInt v = 0; v < m_noCVars; v++)
        vars[v] = F0;

      for(MInt n = 0; n < counter; n++) {
        MInt nghbrId = nghbrList[n];
        if(nghbrId < 0) continue;
        if(a_hasProperty(nghbrId, SolverCell::WasInactive)) continue;
        MFloat fac = m_cellVolumesDt1[nghbrId];
        for(MInt v = 0; v < m_noCVars; v++) {
          vars[v] += fac * a_oldVariable(nghbrId, v);
        }
        facCnt += fac;
      }
      if(fabs(facCnt) / c_cellLengthAtCell(cellId) > 0.1) {
        for(MInt v = 0; v < m_noCVars; v++) {
          vars[v] /= facCnt;
          a_variable(cellId, v) = vars[v];
        }
        setPrimitiveVariables(cellId);
      } else {
        cerr << "Warning cell init " << fabs(facCnt) / c_cellLengthAtCell(cellId) << endl;
        if(m_levelSet && m_closeGaps) {
          cerr << m_closeGaps << " " << a_hasProperty(cellId, SolverCell::WasGapCell) << " "
               << a_hasProperty(cellId, SolverCell::IsGapCell) << " " << a_hasProperty(cellId, SolverCell::WasInactive)
               << " " << a_hasProperty(cellId, SolverCell::IsInactive) << endl;
        }
        a_variable(cellId, CV->RHO) = m_rhoInfinity;
        a_variable(cellId, CV->RHO_E) = m_rhoEInfinity;
        a_pvariable(cellId, PV->RHO) = m_rhoInfinity;
        a_pvariable(cellId, PV->P) = m_PInfinity;
        for(MInt v = 0; v < nDim; v++) {
          a_variable(cellId, CV->RHO_VV[v]) = F0;
          a_pvariable(cellId, PV->VV[v]) = F0;
        }
      }
      MFloat delta = maia::math::deltaFun(m_volumeFraction[bndryId], F0, F1);
      for(MInt i = 0; i < nDim; i++) {
        a_pvariable(cellId, PV->VV[i]) =
            delta * a_pvariable(cellId, PV->VV[i])
            + (F1 - delta) * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->VV[i]];
      }
    }

    setConservativeVariables(cellId);

    if(a_hasProperty(cellId, SolverCell::IsSplitChild)) {
      MInt splitParent = getAssociatedInternalCell(cellId);
      MInt splitParentBndryId = a_bndryId(splitParent);
      ASSERT(splitParentBndryId > -1, " this is too bad...  split cells inconsistency");
      MFloat factor = m_bndryCells->a[bndryId].m_volume / mMax(m_eps, m_bndryCells->a[splitParentBndryId].m_volume);
      for(MInt v = 0; v < m_noCVars; v++) {
        a_variable(splitParent, v) += factor * a_variable(cellId, v);
      }
      for(MInt v = 0; v < m_noPVars; v++) {
        a_pvariable(splitParent, v) += factor * a_pvariable(cellId, v);
      }
    }

    // CAUTION: this renders the scheme nonconservative!
    for(MInt varId = 0; varId < CV->noVariables; varId++) {
      a_oldVariable(cellId, varId) = a_variable(cellId, varId);
    }
    if(m_dualTimeStepping) {
      for(MInt varId = 0; varId < CV->noVariables; varId++) {
        // a_dt2Variable( cellId ,  varId ) = a_variable( cellId ,  varId );
        // a_dt1Variable( cellId ,  varId ) = a_variable( cellId ,  varId );
      }
    }
  }

  if(globalTimeStep > 0) {
    MInt globalNoEmerged = m_noEmergedWindowCells + m_gapOpened;
    MPI_Allreduce(MPI_IN_PLACE, &globalNoEmerged, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "globalNoEmerged");
    if(globalNoEmerged > 0) {
      exchange();
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        for(MInt j = 0; j < noHaloCells(i); j++) {
          setConservativeVariables(haloCellId(i, j));
        }
      }
    }
  }

  cerr << "initializeEmergedCell: noEmergedCells " << m_noEmergedCells << endl;
}


/**
 * \brief initializes variables of cells which occur in a freshly opened gap (valve gap etc.)
 * \author Claudia Guenther
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::initEmergingGapCells() {
  TRACE();

  ASSERT(m_gapOpened, "");

  MIntScratchSpace gapCells(m_fvBndryCnd->m_maxNoBndryCells, AT_, "gapCells");
  MIntScratchSpace DCells(m_fvBndryCnd->m_maxNoBndryCells, AT_, "DCells");
  MIntScratchSpace NCells(m_fvBndryCnd->m_maxNoBndryCells, AT_, "NCells");
  MIntScratchSpace NNghbrs(m_fvBndryCnd->m_maxNoBndryCells, AT_, "NNghbrs");
  MIntScratchSpace NNghbrs2(m_fvBndryCnd->m_maxNoBndryCells * nDim, AT_, "NNghbrs2");
  MFloatScratchSpace NFactors(m_fvBndryCnd->m_maxNoBndryCells * nDim, AT_, "NFactors");
  MBoolScratchSpace isGapCell(a_noCells(), AT_, "isGapCell");
  MBoolScratchSpace isDCell(a_noCells(), AT_, "isDCell");
  MBoolScratchSpace isNCell(a_noCells(), AT_, "isNCell");
  MInt noGapCells = 0;
  MInt noDCells = 0;
  MInt noNCells = 0;
  MFloat maxNormal = F0;
  MInt normalDir = 0;
  MInt noSteps = 100;
  MBool NeumannVariante = true;
  MFloatScratchSpace tmpVars(m_fvBndryCnd->m_maxNoBndryCells * 2, AT_, "tmpVars");

  const MFloat eps = sqrt(nDim) * c_cellLengthAtLevel(m_lsCutCellBaseLevel);

  if(domainId() == 0) {
    cerr << "Initializing emerging gap cells at time step " << globalTimeStep << endl;
  }


  // neighbor links are used for FD iteration
  restoreNeighbourLinks();

  // a) initialisation
  for(MInt c = 0; c < a_noCells(); c++) {
    isGapCell.p[c] = false;
    isDCell.p[c] = false;
    isNCell.p[c] = false;
  }

  // b) Identify gap cells
  //    in this sense all cells with wasGapCell, !IsGapCell, WasInactive, !IsInactive
  //    and Ls-value above eps
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    if(a_isBndryGhostCell(cellId)) continue;
    if(!a_hasProperty(cellId, SolverCell::WasGapCell)) continue;
    if(a_levelSetValuesMb(cellId, 0) < -eps) continue;
    if(!a_hasProperty(cellId, SolverCell::IsGapCell) && !a_hasProperty(cellId, SolverCell::IsInactive)
       && a_hasProperty(cellId, SolverCell::WasInactive)) {
      gapCells.p[noGapCells++] = cellId;
      isGapCell.p[cellId] = true;
      cerr << "initEmergingGapCell: Gap-CellId" << cellId << " " << c_globalId(cellId) << endl;
    }
  }

  // 2.) Identify neighbor cells, of the Gap-Cells and which hold a boundary conditions
  for(MInt c = 0; c < noGapCells; c++) {
    MInt cellId = gapCells.p[c];
    if(a_isHalo(cellId)) continue;
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      if(!a_hasNeighbor(cellId, dir)) {
        cerr << " [" << domainId() << "]:  Error in FvMbCartesianSolverXD::initEmergingGapCells(): no nghbr in dir "
             << dir << " found for cell " << cellId << ". Please check! " << endl;
        continue;
      }
      MInt nghbrId = c_neighborId(cellId, dir);
      if(isGapCell.p[nghbrId]) continue;
      if(isDCell.p[nghbrId]) continue;
      if(isNCell.p[nghbrId]) continue;
      if(a_hasProperty(nghbrId, SolverCell::IsInactive)) continue;
      if(a_bndryId(nghbrId) > -1) {
        if(!a_hasProperty(nghbrId, SolverCell::WasInactive)) {
          // a) cell is a bndryCell and has a valid value from previous time step
          //    -> dirichlet cell!
          isDCell.p[nghbrId] = true;
          DCells.p[noDCells++] = nghbrId;
          cerr << "initEmergingGapCell: D-CellId" << nghbrId << " " << c_globalId(nghbrId) << endl;


          continue;
        } else if(a_levelSetValuesMb(nghbrId, 0) < F0) {
          // b) cell is a bndryCell and has no valid value from previous time step
          //    -> neumann cell!
          isNCell.p[nghbrId] = true;
          NCells.p[noNCells++] = nghbrId;
          cerr << "initEmergingGapCell: N-CellId" << nghbrId << " " << c_globalId(nghbrId) << endl;

          continue;
        } else {
          cerr << " [" << domainId() << "]: Warning in FvMbCartesianSolverXD::initEmergingGapCells(): nghbr in dir "
               << dir << " with id " << nghbrId << " of cell " << cellId
               << " is no Gap cell, no D and no N cell (was inactive, is bndryCell, has levelset >= 0 but is no gap "
                  "cell)! Please check! "
               << endl;
          mTerm(1, AT_, "Error 1");
        }
      } else {
        if(a_hasProperty(nghbrId, SolverCell::IsInactive)) {
          // c) cell is not a bndryCell but is inactive -> neumann cell!
          isNCell.p[nghbrId] = true;
          NCells.p[noNCells++] = nghbrId;
          cerr << "initEmergingGapCell: N-CellId" << nghbrId << " " << c_globalId(nghbrId) << endl;
          continue;
        } else {
          if(!a_hasProperty(nghbrId, SolverCell::WasInactive)) {
            // d) cell is not a bndryCell and is/was active before -> dirichlet cell!
            isDCell.p[nghbrId] = true;
            DCells.p[noDCells++] = nghbrId;
            cerr << "initEmergingGapCell: D-CellId" << nghbrId << " " << c_globalId(nghbrId) << endl;
            continue;
          } else {
            cerr << " [" << domainId() << "]:  Warning in FvMbCartesianSolverXD::initEmergingGapCells(): nghbr in dir "
                 << dir << " with id " << nghbrId << " of cell " << cellId
                 << " is no Gap cell, no D and no N cell (is active, was inactive, but is no gap cell and no bndry "
                    "cell! Please check! "
                 << endl;
            mTerm(1, AT_, "Error 2");
          }
        }
      }
    }
  }


  // 3) set up Gap-exchange:
  //    exchangeWindowCells holds all windowCells that are either a Gap-Cell,
  //    a Dirichlet Cell or a Neumann-Cell
  MIntScratchSpace noExchangeWindowCells(noNeighborDomains(), AT_, "noExchangeWindowCells");
  MIntScratchSpace noExchangeHaloCells(noNeighborDomains(), AT_, "noExchangeHaloCells");
  MIntScratchSpace exchangeWindowCells(noNeighborDomains(), noGapCells + noDCells + noNCells, AT_,
                                       "exchangeWindowCells");

  // a) set noExchangeWindowCells and exchangeWindowCells
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    noExchangeWindowCells[i] = 0;
    for(MInt j = 0; j < noWindowCells(i); j++) {
      MInt cellId = windowCellId(i, j);
      if(isDCell[cellId] || isNCell[cellId] || isGapCell[cellId]) {
        exchangeWindowCells(i, noExchangeWindowCells[i]++) = j;
      }
    }
  }
  // b) exchange noExchangeWindowCells to determine maxNoExchangeHaloCells
  MPI_Status status;
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    MPI_Issend(&noExchangeWindowCells.p[i], 1, MPI_INT, neighborDomain(i), 0, mpiComm(), &g_mpiRequestMb[i], AT_,
               "noExchangeWindowCells.p[i]");
  }
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    MPI_Recv(&noExchangeHaloCells.p[i], 1, MPI_INT, neighborDomain(i), 0, mpiComm(), &status, AT_,
             "noExchangeHaloCells.p[i]");
  }
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    MPI_Wait(&g_mpiRequestMb[i], &status, AT_);
  }

  MInt maxNoExchangeHaloCells = 0;
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    if(noExchangeHaloCells[i] > maxNoExchangeHaloCells) maxNoExchangeHaloCells = noExchangeHaloCells[i];
  }
  MIntScratchSpace exchangeHaloCells(noNeighborDomains(), maxNoExchangeHaloCells, AT_, "exchangeHaloCells");

  // c) exchange exchangeWindowCells to determine exchangeHaloCells
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    for(MInt j = 0; j < noExchangeWindowCells[i]; j++) {
      m_sendBuffers[i][j] = exchangeWindowCells(i, j);
    }
  }
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    MPI_Issend(m_sendBuffers[i], noExchangeWindowCells[i], MPI_DOUBLE, neighborDomain(i), 0, mpiComm(),
               &g_mpiRequestMb[i], AT_, "m_sendBuffers[i]");
  }
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    MPI_Recv(m_receiveBuffers[i], noExchangeHaloCells[i], MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &status, AT_,
             "m_receiveBuffers[i]");
  }
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    MPI_Wait(&g_mpiRequestMb[i], &status, AT_);
  }
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    for(MInt j = 0; j < noExchangeHaloCells[i]; j++) {
      exchangeHaloCells(i, j) = m_receiveBuffers[i][j];
    }
  }

  // 4.) Setup Boundary conditions with 2 options
  // default is NeumannVariante = true;
  if(!NeumannVariante) {
    for(MInt nc = 0; nc < noNCells; nc++) {
      MInt cellId = NCells.p[nc];
      if(a_bndryId(cellId) > -1) {
        MInt bndryId = a_bndryId(cellId);
        maxNormal = F0;
        normalDir = -1;
        for(MInt d = 0; d < nDim; d++) {
          if(abs(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[d]) > maxNormal) {
            maxNormal = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[d];
            normalDir = 2 * d;
            if(maxNormal > F0) normalDir += 1;
            maxNormal = abs(maxNormal);
          }
        }
        if(!a_hasNeighbor(cellId, normalDir)) {
          cerr << " [" << domainId() << "]:"
               << " Error in FvMbCartesianSolverXD::initEmergingGapCells(): no nghbr in primary dir " << normalDir
               << " found for cell " << cellId << ". Please check! " << endl;
          mTerm(1, AT_, "Error 3");
        }
        NNghbrs.p[nc] = c_neighborId(cellId, normalDir);
      } else {
        normalDir = -1;
        maxNormal = F0;
        for(MInt dir = 0; dir < m_noDirs; dir++) {
          if(!a_hasNeighbor(cellId, dir)) {
            continue;
          }
          MInt nghbrId = c_neighborId(cellId, dir);
          MInt bndryId = a_bndryId(nghbrId);
          if(!isGapCell.p[nghbrId] && !isDCell.p[nghbrId]) continue;
          if(bndryId < 0) continue;
          for(MInt d = 0; d < nDim; d++) {
            if(abs(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[d]) > maxNormal) {
              maxNormal = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[d];
              normalDir = 2 * d;
              if(maxNormal > F0) normalDir += 1;
              maxNormal = abs(maxNormal);
            }
          }
        }
        NNghbrs.p[nc] = c_neighborId(cellId, normalDir);
        if(!a_hasNeighbor(cellId, normalDir)) {
          cerr << " [" << domainId() << "]:"
               << " Error in FvMbCartesianSolverXD::initEmergingGapCells(): no nghbr in primary dir " << normalDir
               << " found for cell " << cellId << ". Please check! " << endl;
          mTerm(1, AT_, "Error 4");
        }
      }
    }
  } else {
    // 4.1) NeumannVariante:
    //     setUp NNghbrs2 and NFactors
    //     NNghbrs2 are neighbors of N-Cells
    for(MInt nc = 0; nc < noNCells; nc++) {
      MInt cellId = NCells.p[nc];
      if(a_bndryId(cellId) > -1) {
        // a) Neumann-Cells which are boundary-Cells
        //  (cells which used to be inactive and have a negative Ls-value)
        MInt bndryId = a_bndryId(cellId);
        for(MInt d = 0; d < nDim; d++) {
          normalDir = 2 * d;
          if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[d] > F0) {
            normalDir += 1;
          }
          ASSERT(a_hasNeighbor(cellId, normalDir), "NCell has no neighbor in normalDir!");
          NNghbrs2.p[nc * nDim + d] = c_neighborId(cellId, normalDir);
          NFactors.p[nc * nDim + d] = POW2(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_normalVector[d]);
        }
      } else {
        // b) Neumann-Cells which are non boundary-Cells and are inactive
        MFloat nablaAbs = F0;
        MFloat nablaPhi[nDim];
        for(MInt i = 0; i < nDim; i++) {
          nablaPhi[i] = (a_levelSetValuesMb(c_neighborId(cellId, 2 * i), 0)
                         - a_levelSetValuesMb(c_neighborId(cellId, 2 * i + 1), 0))
                        / (F2 * c_cellLengthAtLevel(a_level(cellId)));
          nablaAbs += POW2(nablaPhi[i]);
        }
        nablaAbs = sqrt(nablaAbs);
        for(MInt i = 0; i < nDim; i++) {
          nablaPhi[i] /= nablaAbs;
        }
        for(MInt d = 0; d < nDim; d++) {
          normalDir = 2 * d;
          if(nablaPhi[d] > F0) {
            normalDir += 1;
          }
          ASSERT(a_hasNeighbor(cellId, normalDir), "NCell has no neighbor in normalDir!");
          NNghbrs2.p[nc * nDim + d] = c_neighborId(cellId, normalDir);
          NFactors.p[nc * nDim + d] = POW2(nablaPhi[d]);
        }
      }
    }
  }

  // 5) check all NNghbrs for NCells in all directions
  //    these neighbors should be either a NCell, DCell or GapCell
  for(MInt nc = 0; nc < noNCells; nc++) {
    if(!NeumannVariante) {
      MInt cellId = NCells.p[nc];
      MInt nghbrId = NNghbrs.p[nc];
      if(isNCell.p[nghbrId] || (a_hasProperty(nghbrId, SolverCell::WasInactive) && !isGapCell.p[nghbrId])) {
        cerr << " [" << domainId() << "]:"
             << " Error in FvMbCartesianSolverXD::initEmergingGapCells(): nghbr " << nghbrId << " found for cell "
             << cellId << " is no gap cell and no dirichlet cell. Please check! " << endl;
        mTerm(1, AT_, "Error 7");
      }
    } else if(NeumannVariante) {
      MInt cellId = NCells.p[nc];
      for(MInt d = 0; d < nDim; d++) {
        MInt nghbrId = NNghbrs2.p[nc * nDim + d];
        if(!isNCell.p[nghbrId] && !isDCell.p[nghbrId] && !isGapCell.p[nghbrId] && a_levelSetValuesMb(nghbrId, 0) < F0) {
          cerr << domainId() << ": Warning NNghbrs2 " << nghbrId << " found for cell " << cellId
               << " is no gap cell and no dirichlet cell! " << endl;
          if(!a_hasProperty(nghbrId, SolverCell::WasInactive)) {
            cerr << " Nghbr was not inactive, so has a valid time history. Setting as Dirichlet cell... " << endl;
            isDCell.p[nghbrId] = true;
            DCells.p[noDCells++] = nghbrId;
          } else {
            cerr << " Nghbr was inactive, so problem can not be resolved.. try nevertheless..." << endl;
          }
        }
      }
    }
  }

  // 6) Set velocity in Neumann cells as the bodyVelocity!
  for(MInt nc = 0; nc < noNCells; nc++) {
    const MInt cellId = NCells.p[nc];
    const MInt bodyId = a_associatedBodyIds(cellId, 0);
    ASSERT(bodyId >= 0, "associated body Id not matching!");
    for(MInt dir = 0; dir < nDim; dir++) {
      a_pvariable(cellId, PV->VV[dir]) = m_bodyVelocity[bodyId * nDim + dir];
    }
  }

  MFloatScratchSpace resL2(m_noPVars, FUN_, "resL2");
  MFloatScratchSpace resMax(m_noPVars, FUN_, "resMax");
  MFloatScratchSpace tmp(m_noPVars, FUN_, "tmp");
  MFloat lambdaRelax = 1.2;
  MInt backupSteps = noSteps;

  // 7) Gauss Seidel over-relaxated and neumann boundary conditions
  //    loop- so that all Gap-Cells will be reached!
  for(MInt step = noSteps; step > 0; step--) {
    // a) exchange of pvariables in all Gap-, N-, or D-Cells
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      MInt sendBufferCounter = 0;
      for(MInt j = 0; j < noExchangeWindowCells[i]; j++) {
        MInt cellId = windowCellId(i, exchangeWindowCells(i, j));
        memcpy((void*)&m_sendBuffers[i][sendBufferCounter], (void*)&a_pvariable(cellId, 0),
               m_dataBlockSize * sizeof(MFloat));
        sendBufferCounter += m_dataBlockSize;
      }
    }

    for(MInt i = 0; i < noNeighborDomains(); i++) {
      MInt bufSize = noExchangeWindowCells[i] * m_dataBlockSize;
      MPI_Issend(m_sendBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &g_mpiRequestMb[i], AT_,
                 "m_sendBuffers[i]");
    }

    for(MInt i = 0; i < noNeighborDomains(); i++) {
      MInt bufSize = noExchangeHaloCells[i] * m_dataBlockSize;
      MPI_Recv(m_receiveBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &status, AT_,
               "m_receiveBuffers[i]");
    }
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      MPI_Wait(&g_mpiRequestMb[i], &status, AT_);
    }

    for(MInt i = 0; i < noNeighborDomains(); i++) {
      MInt receiveBufferCounter = 0;
      for(MInt j = 0; j < noExchangeHaloCells[i]; j++) {
        MInt cellId = haloCellId(i, exchangeHaloCells(i, j));
        memcpy((void*)&a_pvariable(cellId, 0), (void*)&m_receiveBuffers[i][receiveBufferCounter],
               m_dataBlockSize * sizeof(MFloat));
        receiveBufferCounter += m_dataBlockSize;
      }
    }

    for(MInt var = 0; var < m_noPVars; var++) {
      resL2[var] = F0;
      resMax[var] = F0;
    }


    // b) update variables in alle N-Cells based on the variables in NNghbrs2
    if(!NeumannVariante) {
      for(MInt n = 0; n < noNCells; n++) {
        MInt cellId = NCells.p[n];
        MInt nghbrId = NNghbrs.p[n];
        a_pvariable(cellId, PV->RHO) = a_pvariable(nghbrId, PV->RHO);
        a_pvariable(cellId, PV->P) = a_pvariable(nghbrId, PV->P);
      }
    } else {
      // NeumannVariante
      for(MInt n = 0; n < noNCells; n++) {
        tmpVars.p[n * 2 + 0] = F0;
        tmpVars.p[n * 2 + 1] = F0;
        for(MInt d = 0; d < nDim; d++) {
          MInt nghbrId = NNghbrs2.p[n * nDim + d];
          tmpVars.p[n * 2 + 0] += a_pvariable(nghbrId, PV->RHO) * NFactors.p[n * nDim + d];
          tmpVars.p[n * 2 + 1] += a_pvariable(nghbrId, PV->P) * NFactors.p[n * nDim + d];
        }
      }
      for(MInt n = 0; n < noNCells; n++) {
        MInt cellId = NCells.p[n];
        a_pvariable(cellId, PV->RHO) = tmpVars.p[n * 2 + 0];
        a_pvariable(cellId, PV->P) = tmpVars.p[n * 2 + 1];
      }
    }


    // c) update variables for all gap cells
    for(MInt g = 0; g < noGapCells; g++) {
      MInt cellId = gapCells.p[g];
      if(a_isHalo(cellId)) continue;
      for(MInt var = 0; var < m_noPVars; var++) {
        tmp[var] = a_pvariable(cellId, var);
        a_pvariable(cellId, var) = F0;
      }
      for(MInt dir = 0; dir < m_noDirs; dir++) {
        MInt nghbrId = c_neighborId(cellId, dir);
        for(MInt var = 0; var < m_noPVars; var++) {
          a_pvariable(cellId, var) += a_pvariable(nghbrId, var) / m_noDirs;
        }
      }
      for(MInt var = 0; var < m_noPVars; var++) {
        a_pvariable(cellId, var) = (F1 - lambdaRelax) * tmp[var] + lambdaRelax * a_pvariable(cellId, var);
        resL2[var] += POW2(a_pvariable(cellId, var) - tmp[var]);
        resMax[var] = mMax(resMax[var], fabs(a_pvariable(cellId, var) - tmp[var]));
      }
    }

    for(MInt var = 0; var < m_noPVars; var++) {
      resL2[var] = sqrt(resL2[var]);
    }

    if((backupSteps - step) % (backupSteps / 10) == 0) {
      m_log << "     *  " << 100 * (backupSteps - step) / backupSteps << " %  -  residual (L2) rho: " << resL2[PV->RHO]
            << "  -  residual (max) rho: " << resMax[PV->RHO] << endl;
    }
  }

  m_log << "     * "
        << "100"
        << " %  -  residual (L2) rho: " << resL2[PV->RHO] << "  -  residual (max) rho: " << resMax[PV->RHO] << endl;

  for(MInt i = 0; i < noNeighborDomains(); i++) {
    MInt sendBufferCounter = 0;
    for(MInt j = 0; j < noExchangeWindowCells[i]; j++) {
      MInt cellId = windowCellId(i, exchangeWindowCells(i, j));
      memcpy((void*)&m_sendBuffers[i][sendBufferCounter], (void*)&a_pvariable(cellId, 0),
             m_dataBlockSize * sizeof(MFloat));
      sendBufferCounter += m_dataBlockSize;
    }
  }

  for(MInt i = 0; i < noNeighborDomains(); i++) {
    MInt bufSize = noExchangeWindowCells[i] * m_dataBlockSize;
    MPI_Issend(m_sendBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &g_mpiRequestMb[i], AT_,
               "m_sendBuffers[i]");
  }

  for(MInt i = 0; i < noNeighborDomains(); i++) {
    MInt bufSize = noExchangeHaloCells[i] * m_dataBlockSize;
    MPI_Recv(m_receiveBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &status, AT_,
             "m_receiveBuffers[i]");
  }
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    MPI_Wait(&g_mpiRequestMb[i], &status, AT_);
  }

  for(MInt i = 0; i < noNeighborDomains(); i++) {
    MInt receiveBufferCounter = 0;
    for(MInt j = 0; j < noExchangeHaloCells[i]; j++) {
      MInt cellId = haloCellId(i, exchangeHaloCells(i, j));
      memcpy((void*)&a_pvariable(cellId, 0), (void*)&m_receiveBuffers[i][receiveBufferCounter],
             m_dataBlockSize * sizeof(MFloat));
      receiveBufferCounter += m_dataBlockSize;
    }
  }

  // restore the correct neighboring information for further MB computation
  deleteNeighbourLinks();

  for(MInt g = 0; g < noGapCells; g++) {
    MInt cellId = gapCells.p[g];

    setConservativeVariables(cellId);

    for(MInt varId = 0; varId < CV->noVariables; varId++) {
      a_oldVariable(cellId, varId) = a_variable(cellId, varId);
    }

    if(m_dualTimeStepping) {
      for(MInt varId = 0; varId < CV->noVariables; varId++) {
        a_dt2Variable(cellId, varId) = a_variable(cellId, varId);
        a_dt1Variable(cellId, varId) = a_variable(cellId, varId);
      }
    }

    if(c_isLeafCell(cellId)) {
      a_hasProperty(cellId, SolverCell::IsFlux) = true;
      a_hasProperty(cellId, SolverCell::IsActive) = true;
      a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = true;
    }
  }
}


/*
 * \brief generates finite-volume (not-moving) boundary cells
 *
 * \author Lennart Schneiders
 * \date 01/2012
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::generateBndryCells() {
  TRACE();

  m_log << "Generating FV boundary cells..." << endl;

  if(m_generateOuterBndryCells) {
    // reset isActive/isInactive and isOnCurrentMGLevel for outerBndryCells:
    // if the lsValue is in the range of (-limitDistance , 0] and the cell has at least
    // one active corner
    if(!m_constructGField) {
      for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
        const MFloat limitDistance = c_cellLengthAtLevel(a_level(cellId) + 1) * sqrt(nDim) + 0.0001;
        if(a_levelSetValuesMb(cellId, 0) < F0 && a_levelSetValuesMb(cellId, 0) > -limitDistance) {
          // check that it is a cell at the outer-domainBoundary
          // which means that neither the cell nor its parent has a neighbor in a certain direction!
          // and the cell is not a halo cell!
          MBool needsCheck = false;
          for(MInt dir = 0; dir < m_noDirs; dir++) {
            if(a_hasNeighbor(cellId, dir, false)) continue;
            if(c_parentId(cellId) > -1 && a_hasNeighbor(c_parentId(cellId), dir, false)) continue;
            needsCheck = true;
            break;
          }
          if(!needsCheck) continue;
          MInt noActiveCorners = returnNoActiveCorners(cellId);
          if(noActiveCorners > 0) {
            a_hasProperty(cellId, SolverCell::IsInactive) = false;
            if(c_noChildren(cellId) == 0 && c_isLeafCell(cellId)) {
              a_hasProperty(cellId, SolverCell::IsActive) = true;
              a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = true;
            }
          }
        }
      }

      // exchange the properties to ensure the correct values at all haloCells!
      MIntScratchSpace exchangeD(a_noCells(), 3, AT_, "cellCheck");
      exchangeD.fill(-1);
      for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
        exchangeD(cellId, 0) = (MInt)a_hasProperty(cellId, SolverCell::IsInactive);
        exchangeD(cellId, 1) = (MInt)a_hasProperty(cellId, SolverCell::IsActive);
        exchangeD(cellId, 2) = (MInt)a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel);
      }

      exchangeDataFV(&exchangeD(0), 3, false);

      for(MInt cellId = noInternalCells(); cellId < c_noCells(); cellId++) {
        a_hasProperty(cellId, SolverCell::IsInactive) = (MBool)exchangeD(cellId, 0);
        a_hasProperty(cellId, SolverCell::IsActive) = (MBool)exchangeD(cellId, 1);
        a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = (MBool)exchangeD(cellId, 2);
      }

      if(grid().azimuthalPeriodicity()) {
        // Correct azimuthal near boundary cells. Azimuthal window/halos are no exact copy
        for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
          for(MInt j = 0; j < grid().noAzimuthalHaloCells(i); j++) {
            MInt cellId = grid().azimuthalHaloCell(i, j);
            const MFloat limitDistance = c_cellLengthAtLevel(a_level(cellId) + 1) * sqrt(nDim) + 0.0001;
            if(a_levelSetValuesMb(cellId, 0) < F0 && a_levelSetValuesMb(cellId, 0) > -limitDistance) {
              // check that it is a cell at the outer-domainBoundary
              // which means that neither the cell nor its parent has a neighbor in a certain direction!
              // and the cell is not a halo cell!
              MBool needsCheck = false;
              for(MInt dir = 0; dir < m_noDirs; dir++) {
                if(a_hasNeighbor(cellId, dir, false)) continue;
                if(c_parentId(cellId) > -1 && a_hasNeighbor(c_parentId(cellId), dir, false)) continue;
                needsCheck = true;
                break;
              }
              if(!needsCheck) continue;
              MInt noActiveCorners = returnNoActiveCorners(cellId);
              if(noActiveCorners > 0) {
                a_hasProperty(cellId, SolverCell::IsInactive) = false;
                if(c_noChildren(cellId) == 0 && c_isLeafCell(cellId)) {
                  a_hasProperty(cellId, SolverCell::IsActive) = true;
                  a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = true;
                }
              }
            }
          }
        }
        // What about unmapped halos?
        // They are irrelevant in fvMb if level-set boundaries are used!
      }
    }

    createBoundaryCells();

    m_fvBndryCnd->generateBndryCells();

    ASSERT(a_noCells() == c_noCells(), "");
  }

#if defined _MB_DEBUG_ || !defined NDEBUG
  MInt noOuterBoundaryCells = m_fvBndryCnd->m_bndryCells->size();
  m_log << noOuterBoundaryCells << " boundary cells created" << endl;
  MPI_Allreduce(MPI_IN_PLACE, &noOuterBoundaryCells, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "noOuterBoundaryCells");
  cerr0 << "No of outer-boundary-Cells: " << noOuterBoundaryCells << endl;

#endif
}


/** \brief returns the numer of active Corners for an arbitrary cell
 *         (the cell is not a bndryCandidate yet and the nodal-Ls-values have not been computed yet)
 *         just as in computeNodalLsValues, so that the same results are retrieved
 * \author Tim Wegmann
 * \date 02/2019
 */
template <MInt nDim, class SysEqn>
MInt FvMbCartesianSolverXD<nDim, SysEqn>::returnNoActiveCorners(MInt cellId) {
  TRACE();

  MInt nghbrIds[m_noCorners];
  MFloat lsValues[m_noCorners];
  MInt noActiveCorners = 0;
  const MInt nodeStencil[3][8] = {{0, 1, 0, 1, 0, 1, 0, 1}, {2, 2, 3, 3, 2, 2, 3, 3}, {4, 4, 4, 4, 5, 5, 5, 5}};
  std::set<std::pair<MInt, MInt>> nghbrSet;

  for(MInt node = 0; node < m_noCorners; node++) {
    // a) Add all neighbors and the corresponding nodes from the node-loop to the list
    nghbrSet.clear();
    nghbrSet.insert(std::make_pair(cellId, node));

    for(MInt i = 0; i < nDim; i++) {
      MInt firstDir = nodeStencil[i][node];
      MInt firstNghbrId = c_neighborId(cellId, firstDir);
      if(firstNghbrId > -1) {
        nghbrSet.insert(make_pair(firstNghbrId, node));
        for(MInt j = 0; j < nDim; j++) {
          MInt secondDir = nodeStencil[j][node];
          if(secondDir == firstDir) continue;
          MInt secondNghbrId = c_neighborId(firstNghbrId, secondDir);
          if(secondNghbrId > -1) {
            nghbrSet.insert(make_pair(secondNghbrId, node));
            IF_CONSTEXPR(nDim == 3) {
              for(MInt k = 0; k < nDim; k++) {
                MInt thirdDir = nodeStencil[k][node];
                if(thirdDir == firstDir || thirdDir == secondDir) continue;
                MInt thirdNghbrId = c_neighborId(secondNghbrId, thirdDir);
                if(thirdNghbrId > -1) {
                  nghbrSet.insert(make_pair(thirdNghbrId, node));
                }
              }
            }
          }
        }
      }
    }

    // b) reorder list by nodes, and calculate noNeighborsPerNode
    // note: previously determined neighbors might be added multiple-times to the map
    // and overwrite existing and identical information...
    MInt noNeighborsPerNode = 0;
    for(const auto& it : nghbrSet) {
      nghbrIds[noNeighborsPerNode] = it.first;
      noNeighborsPerNode++;
    }

    // c) interpolate the levelSet value at the node, based on the levelSet values at
    //   the neighboring cell-centers
    MFloat phi = F0;
    for(MInt nghbrNode = 0; nghbrNode < noNeighborsPerNode; nghbrNode++) {
      phi += a_levelSetValuesMb(nghbrIds[nghbrNode], 0);
    }
    phi /= noNeighborsPerNode;
    lsValues[node] = phi;
  }

  // d) return the number of active notes
  for(MInt node = 0; node < m_noCorners; node++) {
    if(lsValues[node] > F0) {
      noActiveCorners++;
    }
  }
  ASSERT(noActiveCorners >= 0 && noActiveCorners <= m_noCorners, " ");

  return noActiveCorners;
}


/**
 * \brief correct the cell-surface distance vectors for cells near the moving boundary
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::updateCellSurfaceDistanceVectors() {
  TRACE();

  const MInt noSrfcs = a_noSurfaces();

  for(MInt s = m_bndrySurfacesOffset; s < noSrfcs; s++) {
    for(MInt i = 0; i < nDim; i++) {
      a_surfaceDeltaX(s, i) = a_surfaceCoordinate(s, i) - a_coordinate(a_surfaceNghbrCellId(s, 0), i);
      a_surfaceDeltaX(s, nDim + i) = a_surfaceCoordinate(s, i) - a_coordinate(a_surfaceNghbrCellId(s, 1), i);
    }
  }
}


/**
 * \brief correct the cell-surface distance vectors for cells near the moving boundary
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::updateCellSurfaceDistanceVector(MInt srfcId) {
  MFloat fac0 = F0;
  MFloat fac1 = F0;

  for(MInt i = 0; i < nDim; i++) {
    a_surfaceDeltaX(srfcId, i) = a_surfaceCoordinate(srfcId, i) - a_coordinate(a_surfaceNghbrCellId(srfcId, 0), i);
    a_surfaceDeltaX(srfcId, nDim + i) =
        a_surfaceCoordinate(srfcId, i) - a_coordinate(a_surfaceNghbrCellId(srfcId, 1), i);
    fac0 += POW2(a_surfaceDeltaX(srfcId, i));
    fac1 += POW2(a_surfaceDeltaX(srfcId, nDim + i));
  }
  fac0 = sqrt(fac0);
  fac1 = sqrt(fac1);
  IF_CONSTEXPR(nDim == 3) { // TODO_rmxd labels:FVMB
    a_surfaceFactor(srfcId, 0) = fac1 / (fac0 + fac1);
    a_surfaceFactor(srfcId, 1) = F1 - a_surfaceFactor(srfcId, 0);
  }
}


template <MInt nDim, class SysEqn>
inline MBool FvMbCartesianSolverXD<nDim, SysEqn>::gridPointIsInside(MInt exId, MInt node) {
  ASSERT(exId > -1 && exId < m_extractedCells->size() && node > -1 && node < IPOW2(nDim), "");

  MInt cellId = m_extractedCells->a[exId].m_cellId;
  MInt bndryId = a_bndryId(cellId);
  if(bndryId < 0) return false;

  if(bndryId < m_noOuterBndryCells) {
    return FvCartesianSolverXD<nDim, SysEqn>::gridPointIsInside(exId, node);
  } else {
    return m_pointIsInside[bndryId][IDX_LSSETMB(node, 0)];
  }
}


/**
 * \brief dummy
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::computeForceCoefficients(MFloat*& forceCoefficients) {
  cerr << "FvMbCartesianSolverXD::computeForceCoefficients(..) is empty. " << forceCoefficients[0] << endl;
}


/** \brief adds a surface for the ghost-boundary cell intersections
 *
 *   @author Daniel    Hartmann,       January 10,     2007
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::addBoundarySurfacesMb() {
  TRACE();

  MInt noCells = m_fvBndryCnd->m_bndryCells->size();
  MFloat epsilon = pow(10.0, -13.0);
  m_fvBndryCnd->m_noBoundarySurfaces = m_noOuterBoundarySurfaces;

  for(MInt bndryId = m_noOuterBndryCells; bndryId < noCells; bndryId++) {
    for(MInt srfc = 0; srfc < FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces; srfc++) {
      for(MInt i = 0; i < nDim; i++) {
        m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_srfcId[i] = -1;
      }
    }
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;

    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    if(a_isHalo(cellId)) continue;
    if(a_isPeriodic(cellId)) continue;

    if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId > -1) {
      cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_linkedCellId;
    }

    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      const MInt ghostCellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
      if(a_hasProperty(cellId, SolverCell::IsSplitChild)
         || (c_noChildren(cellId) == 0 && a_level(cellId) <= maxRefinementLevel())
         || (c_noChildren(cellId) > 0 && a_level(cellId) == maxRefinementLevel())) {
        // create one surface per space direction
        for(MInt i = 0; i < nDim; i++) {
          // if the surface is inclined, replace it by its projections
          // into the Cartesian frame of reference
          if(fabs(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i]) > epsilon) {
            m_surfaces.append();
            const MInt srfcId = a_noSurfaces() - 1;

            // add the boundary surface
            m_fvBndryCnd->m_boundarySurfaces[m_fvBndryCnd->m_noBoundarySurfaces] = srfcId;
            m_fvBndryCnd->m_noBoundarySurfaces++;

            // set the boundary condition
            a_surfaceBndryCndId(srfcId) = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId;

            // the coordinates of the new surface are shifted...
            for(MInt j = 0; j < nDim; j++) {
              a_surfaceCoordinate(srfcId, j) = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[j];
            }

            // projection to compute the area of the surface
            a_surfaceArea(srfcId) = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area
                                    * fabs(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i]);

            m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_srfcId[i] = srfcId;

            if(a_surfaceArea(srfcId) < F0) {
              cerr << "Warning: negative surface area of surface " << srfcId << " at time step " << globalTimeStep
                   << " !!!!!!" << endl;
            }

            // set the surface orientation
            a_surfaceOrientation(srfcId) = i;
            a_surfaceUpwindCoefficient(srfcId) = m_globalUpwindCoefficient;

            MFloat dn = F0;
            for(MInt k = 0; k < nDim; k++) {
              dn +=
                  m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[k]
                  * (a_coordinate(cellId, k) - m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[k]);
            }

            if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i] > F0) {
              a_surfaceNghbrCellId(srfcId, 0) = ghostCellId;
              a_surfaceNghbrCellId(srfcId, 1) = cellId;
              a_surfaceFactor(srfcId, 0) = F1B2; // don't modify, crucial for accurate fluid-structure coupling!
              a_surfaceFactor(srfcId, 1) = F1B2;
            } else {
              a_surfaceNghbrCellId(srfcId, 1) = ghostCellId;
              a_surfaceNghbrCellId(srfcId, 0) = cellId;
              a_surfaceFactor(srfcId, 1) = F1B2;
              a_surfaceFactor(srfcId, 0) = F1B2;
            }

            for(MInt k = 0; k < nDim; k++) {
              a_surfaceDeltaX(srfcId, k) =
                  a_surfaceCoordinate(srfcId, k) - a_coordinate(a_surfaceNghbrCellId(srfcId, 0), k);
              a_surfaceDeltaX(srfcId, nDim + k) =
                  a_surfaceCoordinate(srfcId, k) - a_coordinate(a_surfaceNghbrCellId(srfcId, 1), k);
            }
          }
        }
      }
    }
  }
}


/**
 * \brief does what it says
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::resetSlopes() {
  TRACE();

  std::fill(&a_slope(0, 0, 0), &a_slope(0, 0, 0) + a_noCells() * m_noPVars * nDim, F0);
}


/**
 * \brief hijacked function to compute gradients in intial condition 122 for pressure poisson equation
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::LSReconstructCellCenter() {
  TRACE();

  leastSquaresReconstruction();
}


/**
 * \brief hijacked function to compute gradients in intial condition 122 for pressure poisson equation
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
MInt FvMbCartesianSolverXD<nDim, SysEqn>::broadcastSignal(const MInt sender, const MInt signal) {
  TRACE();

  ScratchSpace<MInt> globalSignal(1, AT_, "globalSignal");
  globalSignal.p[0] = signal;
  MPI_Bcast(globalSignal.getPointer(), 1, MPI_INT, sender, mpiComm(), AT_, "globalSignal.getPointer()");

  return globalSignal.p[0];
}


/**
 * \brief Manages solver-specific output
 * \author Daniel Hartmann
 * \comment edited by Lennart Schneiders (04.11.2011)
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::saveSolverSolution(MBool forceOutput, const MBool NotUsed(finalTimeStep)) {
  TRACE();


  if(m_engineSetup && m_solutionInterval > 0) {
    crankAngleSolutionOutput();
  }

  MBool& firstRun = m_static_saveSolverSolutionxd_firstRun;
  if(m_restartFile) firstRun = false;

  if(m_bodySamplingInterval > 0 && globalTimeStep % m_bodySamplingInterval == 0) {
    saveBodySamples();
  }
  if(m_particleSamplingInterval > 0 && globalTimeStep % m_particleSamplingInterval == 0) {
    saveParticleSamples();
  }

  // Taylor Green vortex or DHIT
  if(m_initialCondition == 15 || m_initialCondition == 16) {
    computeFlowStatistics(false);
  }

  if((m_dragOutputInterval > 0) && (globalTimeStep % m_dragOutputInterval) == 0 && m_noEmbeddedBodies > 0) {
    if(m_writeCenterLineData) {
      MString fileName = "centerLineData_" + to_string(globalTimeStep);
      writeCenterLineVel(fileName.c_str());
    }

    MFloat bodyRotation[3] = {F0, F0, F0};
    MFloatScratchSpace pressureForce(mMax(1, nDim * m_noEmbeddedBodies), AT_, "pressureForce");
    getBodyRotation(0, bodyRotation);
    computeBodySurfaceData(&pressureForce[0]);
    printDynamicCoefficients(firstRun, &pressureForce[0]);
    if(m_recordBodyData) recordBodyData(firstRun);
  }
  // solution output
  MInt noComputedTimeSteps = globalTimeStep - m_solutionOffset;
  if(((noComputedTimeSteps % m_solutionInterval) == 0 && globalTimeStep >= m_solutionOffset && m_solutionInterval > -1)
     || forceOutput || (m_solutionTimeSteps.count(globalTimeStep) > 0)) {
    writeVtkXmlFiles("QOUT", "GEOM", !forceOutput, m_solutionDiverged);
    if(string2enum(m_outputFormat) == NETCDF) {
      mTerm(1, AT_, "NETCDF output not defined, see FvMbCartesianSolverXD::saveGridFlowVariablesMB");
    }
  }

  firstRun = false;
}


template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::printDynamicCoefficients(MBool firstRun, MFloat* pressureForce) {
  TRACE();

  // only the coefficient of the first body will be printed here.
  MInt bodyId = 0;
  MFloat forceCoeffs[3] = {F0, F0, F0};
  MFloat pressureForceCoeffs[3] = {F0, F0, F0};
  MFloat momentCoeffs[3] = {F0, F0, F0};
  for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
    forceCoeffs[spaceId] = m_hydroForce[bodyId * nDim + spaceId] / (F1B2 * m_rhoU2);
    IF_CONSTEXPR(nDim == 2) {
      forceCoeffs[spaceId] /= m_bodyDiameter[bodyId];
      pressureForceCoeffs[spaceId] = pressureForce[bodyId * nDim + spaceId] / m_bodyDiameter[bodyId];
    }
    else IF_CONSTEXPR(nDim == 3) {
      forceCoeffs[spaceId] /= PI * POW2(F1B2 * m_bodyDiameter[bodyId]);
      pressureForceCoeffs[spaceId] =
          pressureForce[bodyId * nDim + spaceId] / (PI * POW2(F1B2 * m_bodyDiameter[bodyId]));
    }
  }
  for(MInt i = 0; i < 3; i++) {
    momentCoeffs[i] = m_bodyTorque[bodyId * 3 + i] / (F1B2 * m_rhoU2);
    IF_CONSTEXPR(nDim == 2) { momentCoeffs[i] /= m_bodyDiameter[bodyId]; }
    else IF_CONSTEXPR(nDim == 3) {
      momentCoeffs[i] /= PI * POW3(F1B2 * m_bodyDiameter[bodyId]);
    }
  }

  MString surname;
  if(!m_multipleFvSolver) {
    surname = "forceCoef";
  } else {
    surname = "forceCoef_s" + to_string(solverId());
  }

  ofstream ofl;
  if(domainId() == 0) {
    if(firstRun && globalTimeStep <= m_dragOutputInterval) {
      MString surnameBAK = surname + "_BAK";
      MString surnameBAK0 = surname + "_BAK0";
      MString surnameBAK1 = surname + "_BAK1";
      MString surnameBAK2 = surname + "_BAK2";
      rename(surnameBAK1.c_str(), surnameBAK2.c_str());
      rename(surnameBAK0.c_str(), surnameBAK1.c_str());
      rename(surnameBAK.c_str(), surnameBAK0.c_str());
      rename(surname.c_str(), surnameBAK.c_str());
      ofl.open(surname.c_str(), ios_base::out | ios_base::trunc);
      ofl << "# Header valid for nDim = 3" << endl;
      ofl << "#1:ts 2:tf 3:t 4-6:forceCoeffs 7-9:momentCoeffs 10-12:pressureForceCoeffs";
      ofl << endl;
    } else {
      ofl.open(surname.c_str(), ios_base::out | ios_base::app);
    }
    if(ofl.is_open() && ofl.good()) {
      ofl << setprecision(8) << globalTimeStep << " " << m_physicalTime << " " << m_time << " ";
      for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
        ofl << forceCoeffs[spaceId] << " ";
      }
      for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
        ofl << momentCoeffs[spaceId] << " ";
      }
      for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
        ofl << pressureForceCoeffs[spaceId] << " ";
      }
      ofl << endl;
      ofl.close();
    }
  }
}

template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::recordBodyData(const MBool& firstRun) {
  TRACE();
  ofstream ofl;

  MString surname;
  if(!m_multipleFvSolver) {
    surname = "bodyPosition";
  } else {
    surname = "bodyPosition_s" + to_string(solverId());
  }

  if(domainId() == 0) {
    if(firstRun && globalTimeStep <= m_dragOutputInterval) {
      MString surnameBAK = surname + "_BAK";
      MString surnameBAK0 = surname + "_BAK0";
      MString surnameBAK1 = surname + "_BAK1";
      MString surnameBAK2 = surname + "_BAK2";
      rename(surnameBAK1.c_str(), surnameBAK2.c_str());
      rename(surnameBAK0.c_str(), surnameBAK1.c_str());
      rename(surnameBAK.c_str(), surnameBAK0.c_str());
      rename(surname.c_str(), surnameBAK.c_str());
      ofl.open(surname.c_str(), ios_base::out | ios_base::trunc);
      ofl << "# 1:ts 2:tf 3:t 4-6:bodyCenter 7-9:bodyVelocity 10-12:bodyOrientation 13-15: bodyAngularVelocity";
      ofl << endl;
      ofl << "# For more than 2 bodies, the output is performed for the first two bodies" << endl;
      ofl << "# (>2bodies) 16-18:bodyCenter 19-21:bodyVelocity 22-24:bodyOrientation 25-27: bodyAngularVelocity";
      ofl << endl;
    } else {
      ofl.open(surname.c_str(), ios_base::out | ios_base::app);
    }
    if(ofl.is_open() && ofl.good()) {
      ofl << setprecision(8) << globalTimeStep << " " << m_physicalTime << " " << m_time << " ";
      MFloatScratchSpace R(3, 3, AT_, "R");
      MFloat tmp[3] = {F0, F0, F1};
      MFloat zHat[3];
      for(MInt k = 0; k < mMin(2, m_noEmbeddedBodies); k++) {
        computeRotationMatrix(R, &(m_bodyQuaternion[4 * k]));
        matrixVectorProductTranspose(zHat, R, tmp); // orientation of z-principal axis
        for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
          ofl << m_bodyCenter[k * nDim + spaceId] << " ";
        }
        for(MInt spaceId = 0; spaceId < nDim; spaceId++) {
          ofl << m_bodyVelocity[k * nDim + spaceId] << " ";
        }
        for(MInt spaceId = 0; spaceId < 3; spaceId++) {
          ofl << zHat[spaceId] << " ";
        }
        for(MInt spaceId = 0; spaceId < 3; spaceId++) {
          ofl << m_bodyAngularVelocity[k * 3 + spaceId] << " ";
        }
      }
      ofl << endl;
      ofl.close();
    }
  }
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::computeFlowStatistics(MBool force) {
  TRACE();
  NEW_TIMER_GROUP(t_statistics, "statistics");
  NEW_TIMER(t_timertotal, "statistics", t_statistics);
  NEW_SUB_TIMER(t_slip, "slip", t_timertotal);
  NEW_SUB_TIMER(t_states, "states", t_timertotal);
  NEW_SUB_TIMER(t_odf, "odf", t_timertotal);
  NEW_SUB_TIMER(t_pdf, "pdf", t_timertotal);
  NEW_SUB_TIMER(t_near, "near", t_timertotal);
  NEW_SUB_TIMER(t_near_bodydat, "near_bodydat", t_near);
  NEW_SUB_TIMER(t_near_bodydat2, "near_bodydat2", t_near);
  NEW_SUB_TIMER(t_near_output, "near_output", t_near);
  NEW_SUB_TIMER(t_fft, "fft", t_timertotal);

  TERMM_IF_COND(m_reConstSVDWeightMode == 3 || m_reConstSVDWeightMode == 4, "Not yet implemented!");

  // short-cut for property input with defaultValue
  auto getIntProp = [&](const char* name, const MInt defaultValue) {
    return (Context::propertyExists(name, 0)) ? Context::getSolverProperty<MInt>(name, m_solverId, AT_) : defaultValue;
  };

  // regular output intervals with default values
  const MInt statsInterval = getIntProp("statsInterval", m_dragOutputInterval);
  const MInt pdfInterval = getIntProp("pdfInterval", 0);
  const MInt angleInterval = getIntProp("angleInterval", 0);
  const MInt nearBodyInterval = getIntProp("nearBodyInterval", 0);
  const MInt scatterInterval = getIntProp("scatterInterval", 0);
  const MInt fftInterval = getIntProp("fftInterval", 0);

  // check which statistics have to be computed at the current time step
  MBool computeStats = (statsInterval > 0 && globalTimeStep % statsInterval == 0);
  MBool computeSlipStats = (m_slipInterval > 0 && globalTimeStep % m_slipInterval == 0);
  MBool outputSlipStats = (m_saveSlipInterval > 0 && globalTimeStep % m_saveSlipInterval == 0);
  MBool computePdf = (pdfInterval > 0 && globalTimeStep % pdfInterval == 0);
  MBool computeAngles = (angleInterval > 0 && globalTimeStep % angleInterval == 0);
  MBool computeNearBody = (nearBodyInterval > 0 && globalTimeStep % nearBodyInterval == 0);
  MBool computeScatter = (scatterInterval > 0 && globalTimeStep % scatterInterval == 0);
  MBool computeFFT = (fftInterval > 0 && globalTimeStep % fftInterval == 0);

  // manual output time steps, overrides regular output intervals
  MBool forceOutput = false;
  if(m_forceFVMBStatistics.size() == 0 && Context::propertyExists("forceFVMBStatistics", 0)) {
    const MInt cnt = Context::propertyLength("forceFVMBStatistics", m_solverId);
    for(MInt k = 0; k < cnt; k++) {
      MInt ts = Context::getSolverProperty<MInt>("forceFVMBStatistics", m_solverId, AT_, k);
      m_forceFVMBStatistics.push_back(ts);
    }
  }
  for(MUint i = 0; i < m_forceFVMBStatistics.size(); i++) {
    if(globalTimeStep == m_forceFVMBStatistics[i]) forceOutput = true;
  }

  if(forceOutput == true) {
    computeStats = (statsInterval > 0);
    computeSlipStats = (m_slipInterval > 0);
    outputSlipStats = (m_saveSlipInterval > 0);
    computePdf = (pdfInterval > 0);
    computeAngles = (angleInterval > 0);
    computeNearBody = (nearBodyInterval > 0);
    computeScatter = (scatterInterval > 0);
    computeFFT = (fftInterval > 0);
  }

  // computeStats is required for further statistics
  if(computePdf || computeSlipStats || computeAngles || computeNearBody || computeScatter || computeFFT || force)
    computeStats = true;

  if(!computeStats) return;

  if(domainId() == 0) {
    cerr << globalTimeStep << " " << m_restartTimeStep << " "
         << "computeStats " << computeStats << " "
         << "computeSlipStats " << computeSlipStats << " "
         << "outputSlipStats " << outputSlipStats << " "
         << "computePdf " << computePdf << " "
         << "computeAngles " << computeAngles << " "
         << "computeNearBody " << computeNearBody << " "
         << "computeScatter " << computeScatter << " "
         << "computeFFT " << computeFFT << endl;
  }

  RECORD_TIMER_START(t_timertotal);
  leastSquaresReconstruction(); // update the slopes
  RECORD_TIMER_START(t_slip);   // t_slip contains all calls of computeNearBodyFluidVelocity()
  MInt noParticles = 0;
  if(m_noPointParticles > 0)
    noParticles = m_noPointParticlesLocal;
  else if(m_noEmbeddedBodies > 0)
    noParticles = m_noEmbeddedBodies;
  const MBool computeBodyVol = true;
  MFloatScratchSpace partVol(mMax(1, noParticles), AT_, "partVol");
  // Unified data access for Lagrangian point-particles / and embedded Bodies
  MFloat* vel = nullptr;
  MFloat* velGradient = nullptr;
  MFloat* quats = nullptr;
  MFloat* pvel = nullptr;
  MFloat* pvelDt1 = nullptr;
  MFloat* protVelHat = nullptr;
  MFloat* protVelHatDt1 = nullptr;
  MFloat* nearBodyState = nullptr;
  MFloat* pRadii = nullptr;
  MFloat* pTemperature = nullptr;
  const MInt noNearBodyState = 5;
  // memory nearBodyData
  MFloatScratchSpace velMem(mMax(1, m_noEmbeddedBodies) * nDim, AT_, "velMem");
  MFloatScratchSpace velGradMem(mMax(1, m_noEmbeddedBodies) * nDim * nDim, AT_, "velGradMem");
  MFloatScratchSpace pOmegaHat(mMax(1, noParticles) * nDim, AT_, "pOmegaHat");
  MFloatScratchSpace protVelHatMem(mMax(1, noParticles) * nDim, AT_, "protVelHatMem");
  MFloatScratchSpace protVelHatMemDt1(mMax(1, noParticles) * nDim, AT_, "protVelHatMemDt1");
  MFloatScratchSpace velShearHat(mMax(1, noParticles) * nDim, AT_, "velShearHat");
  MFloatScratchSpace particleFluidRotation(mMax(1, m_noEmbeddedBodies), nDim, AT_, "particleFluidRotation");
  MFloatScratchSpace nbStateMem(mMax(1, m_noEmbeddedBodies) * noNearBodyState, AT_, "nbStateMem");
  MFloatScratchSpace particleFluidPressure(mMax(1, noParticles), AT_, "particleFluidPressure");
  MIntScratchSpace nearestBodies((m_noPointParticles > 0 ? 1 : m_maxNearestBodies * a_noCells()), AT_, "nearestBodies");
  MFloatScratchSpace nearestDist((m_noPointParticles > 0 ? 1 : m_maxNearestBodies * a_noCells()), AT_, "nearestDist");
  MFloatScratchSpace nearestFac((m_noPointParticles > 0 ? 1 : m_maxNearestBodies * a_noCells()), AT_, "nearestFac");
  const MFloat maxDistConstruct = (m_noEmbeddedBodies <= 0 ? -1 : 5.0 * m_bodyDiameter[0]);
  MIntScratchSpace skipParticle(mMax(1, noParticles), AT_, "skipParticle");
  skipParticle.fill(0);
  if(m_noPointParticles > 0) {
    setParticleFluidVelocities(&(particleFluidPressure[0]));
    vel = &(m_particleVelocityFluid[0]);
    velGradient = &(m_particleVelocityGradientFluid[0]);
    quats = &(m_particleQuaternions[0]);
    pvel = &(m_particleVelocity[0]);
    pvelDt1 = &(m_particleVelocityDt1[0]);
    protVelHat = &(m_particleAngularVelocity[0]);
    protVelHatDt1 = &(m_particleAngularVelocityDt1[0]);
    pRadii = &(m_particleRadii[0]);
    pTemperature = &(m_particleTemperature[0]);
  } else if(m_noEmbeddedBodies > 0) {
    MInt maxBodyCnt = 0;
    nearestBodies.fill(-1);
    nearestDist.fill(numeric_limits<MFloat>::max());
    maxBodyCnt = constructDistance(maxDistConstruct, nearestBodies, nearestDist);
    if(maxBodyCnt > m_maxNearestBodies) {
      cerr << "constructDistance: maxBodyCnt " << maxBodyCnt << " exceeds m_maxNearestBodies " << m_maxNearestBodies
           << " computeNearBodyFluidVelocity will be affected in the statistics on domainId " << domainId() << endl;
    }
    const MFloat minDist = 2.0;
    const MFloat maxDist = minDist + 1.0;
    constexpr MFloat maxAngleVel = 0.0;
    constexpr MFloat maxAngleRot = 0.0;
    vector<MFloat> setup = {minDist, maxDist, maxAngleVel, maxAngleRot};
    if(computePdf || computeNearBody) {
      computeNearBodyFluidVelocity(nearestBodies, nearestDist, &velMem[0], &velGradMem[0], &particleFluidRotation[0],
                                   setup, &skipParticle[0], &nbStateMem[0], &particleFluidPressure[0], &nearestFac[0]);
    } else {
      computeNearBodyFluidVelocity(nearestBodies, nearestDist, &velMem[0], &velGradMem[0], &particleFluidRotation[0],
                                   setup, &skipParticle[0]);
    }
    quats = &(m_bodyQuaternion[0]);
    pvel = &(m_bodyVelocity[0]);
    pvelDt1 = &(m_bodyVelocityDt1[0]);
    protVelHat = &(protVelHatMem[0]);
    protVelHatDt1 = &(protVelHatMemDt1[0]);
    vel = &velMem[0];
    velGradient = &velGradMem[0];
    // fluid rotation is evaluated using velGradient, particleFluidRotation would be an alternative
    nearBodyState = &nbStateMem[0];
    pRadii = &(m_bodyRadii[0]);
    pTemperature = &(m_bodyTemperature[0]);
  }
  // Transform values for rotational dynamics from inertial frame into body frame of reference for fully-resolved
  // particles
  if(m_noEmbeddedBodies > 0) {
    for(MInt p = 0; p < noParticles; p++) {
      MFloat qiRotvel[3];
      MFloat qiRotvelDt1[3];
      MFloat qiRotFluid[3];
      MFloat qiShear[3];
      MFloat qbRotvel[3];
      MFloat qbRotvelDt1[3];
      MFloat qbRot[3];
      MFloat qbShear[3];
      for(MInt i = 0; i < nDim; i++) {
        MInt id0 = (i + 1) % 3;
        MInt id1 = (id0 + 1) % 3;
        qiRotFluid[i] = F1B2 * (velGradient[9 * p + 3 * id1 + id0] - velGradient[9 * p + 3 * id0 + id1]);
        qiShear[i] = F1B2 * (velGradient[9 * p + 3 * id1 + id0] + velGradient[9 * p + 3 * id0 + id1]);
        qiRotvel[i] = m_bodyAngularVelocity[3 * p + i];
        qiRotvelDt1[i] = m_bodyAngularVelocityDt1[3 * p + i];
      }
      MFloatScratchSpace R(3, 3, AT_, "R");
      computeRotationMatrix(R, &(quats[4 * p]));
      matrixVectorProduct(qbRot, R, qiRotFluid);
      matrixVectorProduct(qbShear, R, qiShear);
      matrixVectorProduct(qbRotvel, R, qiRotvel);
      matrixVectorProduct(qbRotvelDt1, R, qiRotvelDt1);
      for(MInt i = 0; i < nDim; i++) {
        pOmegaHat[p * nDim + i] = qbRot[i];
        velShearHat[p * nDim + i] = qbShear[i];
        protVelHat[p * nDim + i] = qbRotvel[i];
        protVelHatDt1[p * nDim + i] = qbRotvelDt1[i];
      }
    }
  } else {
    for(MInt p = 0; p < noParticles; p++) {
      for(MInt i = 0; i < nDim; i++) {
        MInt id0 = (i + 1) % 3;
        MInt id1 = (id0 + 1) % 3;
        pOmegaHat[p * nDim + i] = F1B2 * (velGradient[9 * p + 3 * id1 + id0] - velGradient[9 * p + 3 * id0 + id1]);
        velShearHat[p * nDim + i] = F1B2 * (velGradient[9 * p + 3 * id1 + id0] + velGradient[9 * p + 3 * id0 + id1]);
      }
    }
  }
  // Compute time-resolved particle-induced dissipation
  if(computeSlipStats) computeSlipStatistics(nearestBodies, nearestDist, maxDistConstruct);
  if(outputSlipStats) saveParticleSlipData();
  RECORD_TIMER_STOP(t_slip);

  const MFloat DX = (m_bbox[3] - m_bbox[0]);
  partVol.fill(F0);
  if(m_noEmbeddedBodies > 0) {
    if(computeBodyVol) {
      computeBodyVolume(partVol);
    } else {
      for(MInt b = 0; b < m_noEmbeddedBodies; b++) {
        partVol[b] = m_bodyVolume[b];
      }
    }
  } else {
    for(MInt p = 0; p < m_noPointParticlesLocal; p++) {
      partVol[p] = F4B3 * PI * m_particleRadii[3 * p] * m_particleRadii[3 * p + 1] * m_particleRadii[3 * p + 2];
    }
  }
  MIntScratchSpace leafCells(a_noCells(), AT_, "leafCells");
  MInt noLeafCells = 0;
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    if(a_isBndryGhostCell(cellId)) continue;
    if(a_isHalo(cellId)) continue;
    if(a_isPeriodic(cellId)) continue;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;
    if(!a_hasProperty(cellId, SolverCell::IsSplitChild) && c_noChildren(cellId) > 0) continue;
    if(!a_hasProperty(cellId, SolverCell::IsSplitChild) && a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(a_bndryId(cellId) < 0 && a_levelSetValuesMb(cellId, 0) < F0) cerr << "warn: neg LS " << endl;
    leafCells(noLeafCells++) = cellId;
  }
  RECORD_TIMER_START(t_states);
  vector<MFloat> eKinFlowDataMean(17, F0);
  MFloatScratchSpace meanState(4, AT_, "meanState");
  for(MInt stat = 0; stat < m_noMeanStatistics; stat++) {
    const MFloat refRadius = (noParticles > 0 ? pow(pRadii[0] * pRadii[1] * pRadii[2], F1B3) : 0);
    // gather fluid statistics
    for(MInt c = 0; c < noLeafCells; c++) {
      MInt cellId = leafCells(c);
      MFloat volume = a_cellVolume(cellId);
      if(volume < 1e-14) continue;
      if(stat > 0 && a_levelSetValuesMb(cellId, 0) < m_distThresholdStat[stat] * refRadius) continue;
      MFloat U2 = F0;
      MFloat U20 = F0;
      MFloat w2 = F0;
      MFloat s2 = F0;
      for(MInt i = 0; i < nDim; i++) {
        U2 += POW2(a_variable(cellId, CV->RHO_VV[i]) / a_variable(cellId, CV->RHO));
        U20 += POW2(a_oldVariable(cellId, CV->RHO_VV[i]) / a_oldVariable(cellId, CV->RHO));
        w2 += POW2(a_slope(cellId, PV->VV[(i + 1) % nDim], (i + 2) % nDim)
                   - a_slope(cellId, PV->VV[(i + 2) % nDim], (i + 1) % nDim));
        s2 += POW2(a_slope(cellId, PV->VV[(i + 1) % nDim], (i + 2) % nDim)
                   + a_slope(cellId, PV->VV[(i + 2) % nDim], (i + 1) % nDim));
      }
      MFloat T = sysEqn().temperature_ES(a_pvariable(cellId, PV->RHO), a_pvariable(cellId, PV->P));
      MFloat mue = SUTHERLANDLAW(T) / sysEqn().m_Re0;

      MFloat div = F0;
      for(MInt i = 0; i < nDim; i++) {
        div += a_slope(cellId, PV->VV[i], i);
      }
      eKinFlowDataMean[0] += F1B2 * volume * U2;
      eKinFlowDataMean[1] += F1B2 * volume * a_variable(cellId, CV->RHO) * U2;
      eKinFlowDataMean[2] += F1B2 * m_cellVolumesDt1[cellId] * U20;
      eKinFlowDataMean[3] += F1B2 * m_cellVolumesDt1[cellId] * a_oldVariable(cellId, CV->RHO) * U20;
      eKinFlowDataMean[4] += volume * fabs(div);
      eKinFlowDataMean[5] += volume * w2;
      for(MInt i = 0; i < nDim; i++) {
        for(MInt j = 0; j < nDim; j++) {
          eKinFlowDataMean[6] += volume * mue * (a_slope(cellId, PV->VV[i], j) + a_slope(cellId, PV->VV[j], i))
                                 * a_slope(cellId, PV->VV[i], j);
          eKinFlowDataMean[7] +=
              volume * F1B2 * mue * POW2(a_slope(cellId, PV->VV[i], j) + a_slope(cellId, PV->VV[j], i));
          eKinFlowDataMean[8] += volume * mue * a_slope(cellId, PV->VV[i], j) * a_slope(cellId, PV->VV[i], j);
        }
        eKinFlowDataMean[9] += volume * POW2(a_slope(cellId, PV->VV[i], i));
        eKinFlowDataMean[10] += volume * POW3(a_slope(cellId, PV->VV[i], i));
      }
      eKinFlowDataMean[11] += volume * mue;
      eKinFlowDataMean[12] += volume * a_variable(cellId, CV->RHO);
      eKinFlowDataMean[13] += T * volume;
      eKinFlowDataMean[14] += volume;
      eKinFlowDataMean[15] += volume * POW2(div);
      eKinFlowDataMean[16] += volume * POW2(a_variable(cellId, CV->RHO));
    }
    MPI_Allreduce(MPI_IN_PLACE, eKinFlowDataMean.data(), eKinFlowDataMean.size(), MPI_DOUBLE, MPI_SUM, mpiComm(), AT_,
                  "MPI_IN_PLACE", "eKinFlowDataMean[0]");

    // gather solid statistics
    vector<MFloat> eKinPartDataMean(25, F0);
    for(MInt p = 0; p < noParticles; p++) {
      eKinPartDataMean[0] += F1;
      eKinPartDataMean[1] += partVol[p];
      eKinPartDataMean[2] += pvel[p * nDim];
      eKinPartDataMean[3] += pvel[p * nDim + 1];
      eKinPartDataMean[4] += pvel[p * nDim + 2];
      eKinPartDataMean[5] += POW2(pvel[p * nDim]);
      eKinPartDataMean[6] += POW2(pvel[p * nDim + 1]);
      eKinPartDataMean[7] += POW2(pvel[p * nDim + 2]);
      eKinPartDataMean[8] += protVelHat[p * nDim + 0];
      eKinPartDataMean[9] += protVelHat[p * nDim + 1];
      eKinPartDataMean[10] += protVelHat[p * nDim + 2];
      eKinPartDataMean[11] += POW2(protVelHat[p * nDim + 0]);
      eKinPartDataMean[12] += POW2(protVelHat[p * nDim + 1]);
      eKinPartDataMean[13] += POW2(protVelHat[p * nDim + 2]);
      MFloatScratchSpace R(3, 3, AT_, "R");
      computeRotationMatrix(R, &(quats[4 * p]));
      // assuming zHat as major axis of ellipsoid which is fixed for point-particles and variable for fully resolved
      // fv_mb_cleanup
      MFloat tmp[3] = {F1, F0, F0};
      MFloat zHat[3];
      matrixVectorProductTranspose(zHat, R, tmp); // orientation of z-principal axis
      for(MInt i = 0; i < nDim; i++) {
        zHat[i] /= mMax(1e-12, sqrt(zHat[0] * zHat[0] + zHat[1] * zHat[1] + zHat[2] * zHat[2]));
      }
      eKinPartDataMean[14] += fabs(zHat[2]); // assuming z-axis is direction of anisotropy, e.g. direction of gravity
      MFloat diameter = F2 * pow(pRadii[3 * p] * pRadii[3 * p + 1] * pRadii[3 * p + 2], F1B3);
      MFloat Rep = F0;
      for(MInt i = 0; i < nDim; i++) {
        Rep += POW2(vel[3 * p + i] - pvel[3 * p + i]);
      }
      Rep = sqrt(Rep) * diameter * m_rhoInfinity * sysEqn().m_Re0 / sysEqn().m_muInfinity; // isothermal
      eKinPartDataMean[15] += Rep;
      eKinPartDataMean[16] += POW2(Rep);
      MFloat pmass = partVol[p] * m_densityRatio * m_rhoInfinity;
      eKinPartDataMean[17] += pmass;
      MFloat momI[3] = {F0, F0, F0};
      momI[0] = F1B5 * (POW2(pRadii[3 * p + 1]) + POW2(pRadii[3 * p + 2]));
      momI[1] = F1B5 * (POW2(pRadii[3 * p + 0]) + POW2(pRadii[3 * p + 2]));
      momI[2] = F1B5 * (POW2(pRadii[3 * p + 0]) + POW2(pRadii[3 * p + 1]));
      for(MInt i = 0; i < nDim; i++) {
        eKinPartDataMean[18] += partVol[p] * F1B2 * POW2(pvel[p * nDim + i]);
        eKinPartDataMean[19] += partVol[p] * F1B2 * momI[i] * POW2(protVelHat[p * nDim + i]);
        eKinPartDataMean[20] += partVol[p] * F1B2 * POW2(pvelDt1[p * nDim + i]);
        eKinPartDataMean[21] += partVol[p] * F1B2 * momI[i] * POW2(protVelHatDt1[p * nDim + i]);
      }
      MFloat vrel[3] = {F0, F0, F0};
      MFloat omegaRel[3] = {F0, F0, F0};
      for(MInt i = 0; i < nDim; i++) {
        vrel[i] = vel[nDim * p + i] - pvel[nDim * p + i];
        omegaRel[i] = pOmegaHat[i] - protVelHat[p * 3 + i];
      }
      if(m_noEmbeddedBodies > 0) {
        eKinPartDataMean[22] += (m_hydroForce[nDim * p + 0] * vrel[0] + m_hydroForce[nDim * p + 1] * vrel[1]
                                 + m_hydroForce[nDim * p + 2] * vrel[2]);
        eKinPartDataMean[23] += (m_bodyTorque[nDim * p + 0] * omegaRel[0] + m_bodyTorque[nDim * p + 1] * omegaRel[1]
                                 + m_bodyTorque[nDim * p + 2] * omegaRel[2]);
      } else {
        eKinPartDataMean[22] +=
            pmass
            * (m_particleAcceleration[nDim * p + 0] * vrel[0] + m_particleAcceleration[nDim * p + 1] * vrel[1]
               + m_particleAcceleration[nDim * p + 2] * vrel[2]);
        eKinPartDataMean[23] += F0; // no source terms because of particle rotation
      }
      eKinPartDataMean[24] += pTemperature[p];
    }
    if(m_noPointParticles > 0) {
      if(domainId() == 0) {
        MPI_Reduce(MPI_IN_PLACE, eKinPartDataMean.data(), eKinPartDataMean.size(), MPI_DOUBLE, MPI_SUM, 0, mpiComm(),
                   AT_, "MPI_IN_PLACE", "eKinPartDataMean");
      } else {
        MPI_Reduce(eKinPartDataMean.data(), eKinPartDataMean.data(), eKinPartDataMean.size(), MPI_DOUBLE, MPI_SUM, 0,
                   mpiComm(), AT_, "MPI_IN_PLACE", "eKinPartDataMean");
      }
    }

    const MFloat volF = eKinFlowDataMean[14];
    const MFloat fluidMass = eKinFlowDataMean[12];
    const MFloat volP = eKinPartDataMean[1];
    const MFloat totalMass = fluidMass + eKinPartDataMean[17];
    const MInt cnt = eKinPartDataMean[0];
    const MFloat partLinDiss = eKinPartDataMean[22] / POW3(DX);
    const MFloat partRotDiss = eKinPartDataMean[23] / POW3(DX);
    if(cnt != noParticles) {
      cerr << "Number of particles in statistics is wrong " << cnt << " " << m_noEmbeddedBodies << " "
           << m_noPointParticles << " " << noParticles << endl;
    }

    MFloat EkT = eKinFlowDataMean[1] + (eKinPartDataMean[18] + eKinPartDataMean[19]) * m_densityRatio * m_rhoInfinity;
    MFloat EkB = (eKinPartDataMean[18] + eKinPartDataMean[19]) / volP;

    for(MUint i = 0; i < eKinFlowDataMean.size(); i++) {
      eKinFlowDataMean[i] /= volF;
    }
    for(MUint i = 0; i < eKinPartDataMean.size(); i++) {
      eKinPartDataMean[i] /= cnt;
    }

    // store mean values for later statistics (e.g., nearBodyData)
    if(stat == 0) {
      meanState(0) = eKinFlowDataMean[0];                                         // Ek
      meanState(1) = EkT / totalMass;                                             // EkT
      meanState(2) = EkB;                                                         // Ekb
      meanState(3) = (5.0 * (sysEqn().m_muInfinity / sysEqn().m_Re0) * (eKinFlowDataMean[9] / F3)); // eps1
    }
    if(m_firstStats) {
      m_oldMeanState[stat][0] = meanState(0); // Ek
      m_oldMeanState[stat][1] = meanState(1); // EkT
      m_oldMeanState[stat][2] = meanState(2); // EkB
      m_oldMeanState[stat][3] = meanState(3); // eps1
    }
    if(domainId() == 0) {
      MFloat mue = eKinFlowDataMean[11];
      MFloat dudx = eKinFlowDataMean[9];
      MFloat eps4 = F5 * mue * dudx;
      MFloat skewness = (eKinFlowDataMean[10] / F3) / pow(dudx / F3, F3B2);
      MFloat eta = pow(mue, 0.75) / pow(eps4, 0.25);
      MFloat lambda = sqrt(F2B3 * eKinFlowDataMean[0]) / sqrt(dudx / F3);
      MFloat reLambda = lambda * sqrt(F2B3 * eKinFlowDataMean[0]) * eKinFlowDataMean[12] / mue;
      MFloat coupling = m_couplingRate / (volF + volP);
      MFloat* termVel = nullptr;
      MFloat defaultTermVel[3] = {F0, F0, F0};
      if(m_noPointParticles > 0 && m_particleRadii.size() > 0) {
        termVel = m_particleTerminalVelocity;
      } else if(m_noEmbeddedBodies > 0) {
        termVel = m_bodyTerminalVelocity;
      } else {
        termVel = defaultTermVel;
      }
      const MFloat taup = F2 * m_densityRatio * POW2(refRadius) / (9.0 * sysEqn().m_muInfinity / sysEqn().m_Re0);
      const MFloat epsRef = DX / (POW3(m_UInfinity));
      // gather value-header pairs
      vector<pair<string, double>> eKinOutput;
      eKinOutput.push_back(make_pair("ts", globalTimeStep));
      eKinOutput.push_back(make_pair("t", m_time));
      eKinOutput.push_back(make_pair("tf", m_physicalTime));
      eKinOutput.push_back(make_pair("Ek", eKinFlowDataMean[0] / POW2(m_UInfinity)));
      eKinOutput.push_back(make_pair("EkB", EkB / POW2(m_UInfinity)));
      eKinOutput.push_back(make_pair("EkT", EkT / (POW2(m_UInfinity) * totalMass)));
      eKinOutput.push_back(make_pair("-d(Ek)dt", -(meanState(0) - m_oldMeanState[stat][0]) * epsRef
                                                     / (timeStep() * m_dragOutputInterval)));
      eKinOutput.push_back(make_pair("-d(EkB)dt", -(meanState(2) - m_oldMeanState[stat][2]) * epsRef
                                                      / (timeStep() * m_dragOutputInterval)));
      eKinOutput.push_back(make_pair("-d(EkT)dt", -(meanState(1) - m_oldMeanState[stat][1]) * epsRef
                                                      / (timeStep() * m_dragOutputInterval)));
      eKinOutput.push_back(make_pair("divergence", eKinFlowDataMean[4] / m_UInfinity));
      eKinOutput.push_back(make_pair("divergenceRMS", sqrt(eKinFlowDataMean[15]) / m_UInfinity));
      eKinOutput.push_back(make_pair("enstrophy", eKinFlowDataMean[5]));
      eKinOutput.push_back(make_pair("eps", eKinFlowDataMean[6] * epsRef));
      eKinOutput.push_back(make_pair("eps2", eKinFlowDataMean[7] * epsRef));
      eKinOutput.push_back(make_pair("eps3", eKinFlowDataMean[8] * epsRef));
      eKinOutput.push_back(make_pair("eps4", eps4 * epsRef));
      eKinOutput.push_back(make_pair("skewness", -skewness));
      eKinOutput.push_back(make_pair("volF", volF / POW3(DX)));
      eKinOutput.push_back(make_pair("volP", volP / POW3(DX)));
      eKinOutput.push_back(make_pair("volDiff", (POW3(DX) - volF - volP) / POW3(DX)));
      eKinOutput.push_back(make_pair("Kolmogorov-scale", eta / DX));
      eKinOutput.push_back(make_pair("Taylor-scale", lambda / DX));
      eKinOutput.push_back(make_pair("ReLambda", reLambda));
      eKinOutput.push_back(make_pair("Interphase-Momentum-Exchange", coupling * epsRef));
      eKinOutput.push_back(make_pair("uPMean", eKinPartDataMean[2] / m_Ma));
      eKinOutput.push_back(make_pair("vPMean", eKinPartDataMean[3] / m_Ma));
      eKinOutput.push_back(make_pair("wPMean", eKinPartDataMean[4] / m_Ma));
      eKinOutput.push_back(make_pair("uPRMS", sqrt(eKinPartDataMean[5]) / m_Ma));
      eKinOutput.push_back(make_pair("vPRMS", sqrt(eKinPartDataMean[6]) / m_Ma));
      eKinOutput.push_back(make_pair("wPRMS", sqrt(eKinPartDataMean[7]) / m_Ma));
      eKinOutput.push_back(make_pair("OmegaxPMean", eKinPartDataMean[8]));
      eKinOutput.push_back(make_pair("OmegayPMean", eKinPartDataMean[9]));
      eKinOutput.push_back(make_pair("OmegazPMean", eKinPartDataMean[10]));
      eKinOutput.push_back(make_pair("OmegaxPRMS", sqrt(eKinPartDataMean[11])));
      eKinOutput.push_back(make_pair("OmegayPRMS", sqrt(eKinPartDataMean[12])));
      eKinOutput.push_back(make_pair("OmegazPRMS", sqrt(eKinPartDataMean[13])));
      eKinOutput.push_back(make_pair("thetaMean", eKinPartDataMean[14]));
      eKinOutput.push_back(make_pair("RepMean", eKinPartDataMean[15]));
      eKinOutput.push_back(make_pair("RepRMS", sqrt(eKinPartDataMean[16])));
      eKinOutput.push_back(make_pair("Stokes", taup * sqrt(F5 * dudx)));
      eKinOutput.push_back(make_pair("Froude", taup * POW2(termVel[2]) / mue));
      eKinOutput.push_back(make_pair("mueMean", mue / (sysEqn().m_muInfinity / sysEqn().m_Re0)));
      eKinOutput.push_back(make_pair("rhoMean", eKinFlowDataMean[12] / m_rhoInfinity));
      eKinOutput.push_back(make_pair("rhoRMS", sqrt(eKinFlowDataMean[16]) / m_rhoInfinity));
      eKinOutput.push_back(make_pair("TFluid", eKinFlowDataMean[13] / m_TInfinity));
      eKinOutput.push_back(make_pair("TPart", eKinPartDataMean[24] / m_TInfinity));
      eKinOutput.push_back(make_pair("part_lin_diss", partLinDiss * epsRef));
      eKinOutput.push_back(make_pair("part_rot_diss", partRotDiss * epsRef));
      // output as ASCII-file
      ofstream ofl;
      MString suffix = (stat > 0) ? "_D" + to_string(m_distThresholdStat[stat]) : "";
      suffix.erase(suffix.find_last_not_of('0') + 1, std::string::npos);
      suffix.erase(suffix.find_last_not_of('.') + 1, std::string::npos);
      // if first file access, make a backup of existing files and print the header
      if(globalTimeStep == 0 && m_firstStats) {
        rename(("kineticEnergy" + suffix + "_BAK1").c_str(), ("kineticEnergy" + suffix + "_BAK2").c_str());
        rename(("kineticEnergy" + suffix + "_BAK0").c_str(), ("kineticEnergy" + suffix + "_BAK1").c_str());
        rename(("kineticEnergy" + suffix + "_BAK").c_str(), ("kineticEnergy" + suffix + "_BAK0").c_str());
        rename(("kineticEnergy" + suffix).c_str(), ("kineticEnergy" + suffix + "_BAK").c_str());
        ofl.open(("kineticEnergy" + suffix).c_str(), ios_base::out | ios_base::trunc);
        ofl << "# "; // outcommented for gnuplot
        for(MUint i = 0; i < eKinOutput.size(); i++) {
          ofl << i + 1 << ":" << get<0>(eKinOutput[i]) << " ";
        }
        ofl << endl;
      } else {
        ofl.open(("kineticEnergy" + suffix).c_str(), ios_base::out | ios_base::app);
      }
      if(ofl.is_open() && ofl.good()) {
        for(MUint i = 0; i < eKinOutput.size(); i++) {
          ofl << get<1>(eKinOutput[i]) << " ";
        }
        ofl << endl;
        ofl.close();
      }
    }
    m_oldMeanState[stat][0] = meanState(0);
    m_oldMeanState[stat][1] = meanState(1);
    m_oldMeanState[stat][2] = meanState(2);
    m_oldMeanState[stat][3] = meanState(3);
  }
  RECORD_TIMER_STOP(t_states);

  // probability density function and orientation distribution function
  if(computePdf) {
    IF_CONSTEXPR(nDim == 2) mTerm(1, AT_, "computePdf not implemented for 2D!");
    RECORD_TIMER_START(t_odf);
    const MInt noSamples = 1;   // no temporal averaging
    const MInt thetaSize = 100; // noBins for odf and pdf
    const MFloat deltaRadius = F2 / ((MFloat)thetaSize);
    const MInt noDat = 64; // mutiples of 4!
    // two containers for angles in radians and in degrees
    MFloatScratchSpace angles(noDat, AT_, "angles");
    MFloatScratchSpace angles2(noDat, AT_, "angles2");
    MFloatScratchSpace thetaDensity(thetaSize, noDat, AT_, "thetaDensity");
    MFloatScratchSpace thetaDensity2(thetaSize, noDat, AT_, "thetaDensity2");
    MFloatScratchSpace thetaPoints(thetaSize, AT_, "thetaPoints");
    MFloatScratchSpace thetaPoints2(thetaSize, AT_, "thetaPoints2");
    MFloatScratchSpace thetaBounds(thetaSize + 1, AT_, "thetaBounds");
    MFloatScratchSpace thetaBounds2(thetaSize + 1, AT_, "thetaBounds2");
    angles.fill(F0);
    angles2.fill(F0);
    thetaDensity.fill(F0);
    thetaDensity2.fill(F0);
    thetaBounds(0) = F0;
    thetaBounds2(0) = -F1;
    for(MInt i = 0; i < thetaSize; i++) {
      MFloat theta0 = thetaBounds(i);
      MFloat theta1 = acos(F1 - ((MFloat)(i + 1)) * deltaRadius); // equal-area bins for angle output
      MFloat theta02 = thetaBounds2(i);
      MFloat theta12 = thetaBounds2(0) + ((MFloat)(i + 1)) * deltaRadius; // uniform for directional cosines
      thetaPoints(i) = F1B2 * (theta0 + theta1);
      thetaPoints2(i) = F1B2 * (theta02 + theta12);
      thetaBounds(i + 1) = theta1;
      thetaBounds2(i + 1) = theta12;
    }
    thetaBounds(thetaSize) = PI;
    thetaBounds2(thetaSize) = F1;
    for(MInt p = 0; p < noParticles; p++) {
      if(skipParticle(p)) continue;
      vector<MFloat> values;
      MFloat fdir[3] = {F0, F0, F0};
      MFloat wdir[3] = {F0, F0, F0};
      MFloat pdir[3] = {F0, F0, F0};
      MFloat rdir[3] = {F0, F0, F0};
      MFloat reldir[3] = {F0, F0, F0};
      for(MInt i = 0; i < nDim; i++) {
        fdir[i] = vel[nDim * p + i];
        wdir[i] = pOmegaHat[nDim * p + i];
        pdir[i] = pvel[nDim * p + i];
        rdir[i] = protVelHat[nDim * p + i];
        reldir[i] = vel[nDim * p + i] - pvel[nDim * p + i];
      }
      const MFloat ffabs = sqrt(POW2(fdir[0]) + POW2(fdir[1]) + POW2(fdir[2]));
      const MFloat wabs = sqrt(POW2(wdir[0]) + POW2(wdir[1]) + POW2(wdir[2]));
      const MFloat pabs = sqrt(POW2(pdir[0]) + POW2(pdir[1]) + POW2(pdir[2]));
      const MFloat rabs = sqrt(POW2(rdir[0]) + POW2(rdir[1]) + POW2(rdir[2]));
      const MFloat relabs = sqrt(POW2(reldir[0]) + POW2(reldir[1]) + POW2(reldir[2]));
      MFloatScratchSpace R(3, 3, AT_, "R");
      computeRotationMatrix(R, &(quats[4 * p]));
      MFloat q[3];
      // fv_mb_cleanup
      MFloat tmp[3] = {F1, F0, F0};
      matrixVectorProductTranspose(q, R, tmp); // orientation of z-principal axis in world space
      const MFloat qabs = sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]);
      for(MInt i = 0; i < nDim; i++) {
        fdir[i] /= mMax(1e-12, ffabs);
        wdir[i] /= mMax(1e-12, wabs);
        pdir[i] /= mMax(1e-12, pabs);
        rdir[i] /= mMax(1e-12, rabs);
        reldir[i] /= mMax(1e-12, relabs);
        q[i] /= mMax(1e-12, qabs);
      }
      matrixVectorProduct(tmp, R, fdir);
      values.push_back(q[0]);    // angle between major axis and x-axis
      values.push_back(q[1]);    // angle between major axis and y-axis
      values.push_back(q[2]);    // angle between major axis and z-axis
      values.push_back(tmp[2]);  // angle between major axis and flow direction
      values.push_back(wdir[2]); // angle between major axis and vorticity direction
      MFloat omegaVel = F0;      // angle between particle and fluid velocity
      MFloat omegaVort = F0;     // angle between particle and fluid velocity
      for(MInt i = 0; i < nDim; i++) {
        omegaVel += pdir[i] * fdir[i];
        omegaVort += rdir[i] * wdir[i];
      }
      values.push_back(omegaVel);
      values.push_back(omegaVort);
      values.push_back(pdir[0] * q[0] + pdir[1] * q[1] + pdir[2] * q[2]);
      values.push_back(reldir[0] * q[0] + reldir[1] * q[1] + reldir[2] * q[2]);
      if(m_noEmbeddedBodies > 0)
        values.push_back(q[0] * rdir[0] + q[1] * rdir[1] + q[2] * rdir[2]);
      else
        values.push_back(rdir[2]);

      MInt cnt = 0;
      for(MUint i = 0; i < values.size(); i++) {
        for(MInt j = 0; j < 4; j++) {
          angles[cnt] = acos(values[i]);
          angles2[cnt++] = values[i];
        }
      }

      const MFloat kernelWidth = 0.05;
      const MFloat kernelWidth2 = 0.02;
      const MFloat fac = F1 / (kernelWidth);
      const MFloat fac2 = F1 / (kernelWidth2);
      for(MInt j = 0; j < noDat; j++) {
        for(MInt i = 0; i < thetaSize; i++) {
          MInt ii = i;
          MInt ii2 = i;
          if(j % 4 > 1 && i >= thetaSize / 2) ii = thetaSize - i - 1; // symmetry in theta
          if(j % 4 > 1 && i < thetaSize / 2) ii2 = thetaSize - i - 1; // symmetry in theta
          if(j % 2 == 0) {
            if(angles[j] > thetaBounds(i) && angles[j] < thetaBounds(i + 1)) thetaDensity(ii, j) += F1; // bin counting
            if(angles2[j] > thetaBounds2(i) && angles2[j] < thetaBounds2(i + 1))
              thetaDensity2(ii2, j) += F1; // bin counting
          } else {
            MFloat DA = thetaBounds(thetaSize) - thetaBounds(0);
            MFloat DA2 = thetaBounds2(thetaSize) - thetaBounds2(0);
            MFloat t = fabs(angles[j] - thetaPoints(i)) / kernelWidth;
            t = mMin(t, fabs(angles[j] + DA - thetaPoints(i)) / kernelWidth); // symmetry in theta
            t = mMin(t, fabs(angles[j] - DA - thetaPoints(i)) / kernelWidth); // symmetry in theta
            MFloat t2 = fabs(angles2[j] - thetaPoints2(i)) / kernelWidth2;
            t2 = mMin(t2, fabs(angles2[j] + DA2 - thetaPoints2(i)) / kernelWidth2); // symmetry in theta
            t2 = mMin(t2, fabs(angles2[j] - DA2 - thetaPoints2(i)) / kernelWidth2); // symmetry in theta
            // Smoothing using Gaussian kernel
            thetaDensity(ii, j) += fac * (thetaBounds(i + 1) - thetaBounds(i)) * exp(-F1B2 * POW2(t)) / sqrt(F2 * PI);
            thetaDensity2(ii2, j) +=
                fac2 * (thetaBounds2(i + 1) - thetaBounds2(i)) * exp(-F1B2 * POW2(t2)) / sqrt(F2 * PI);
          }
        }
      }
    }
    if(m_noPointParticles > 0) {
      MPI_Allreduce(MPI_IN_PLACE, &thetaDensity[0], noDat * thetaSize, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_,
                    "MPI_IN_PLACE", "thetaDensity[0]");
      MPI_Allreduce(MPI_IN_PLACE, &thetaDensity2[0], noDat * thetaSize, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_,
                    "MPI_IN_PLACE", "thetaDensity2[0]");
    }
    MFloatScratchSpace sum(noDat, AT_, "sum");
    MFloatScratchSpace sum2(noDat, AT_, "sum2");
    sum.fill(F0);
    sum2.fill(F0);
    for(MInt i = 0; i < thetaSize; i++) {
      MFloat ang = thetaPoints(i);
      MFloat fac = sin(ang);
      MFloat fac2 = F1;
      for(MInt j = 0; j < noDat; j++) {
        sum[j] += fac * (thetaBounds(i + 1) - thetaBounds(i)) * thetaDensity(i, j);
        sum2[j] += fac2 * (thetaBounds2(i + 1) - thetaBounds2(i)) * thetaDensity2(i, j);
      }
    }
    for(MInt i = 0; i < thetaSize; i++) {
      for(MInt j = 0; j < noDat; j++) {
        thetaDensity(i, j) /= sum[j];
        thetaDensity2(i, j) /= sum2[j];
      }
    }

    if(domainId() == 0) {
      ofstream ofl;
      ofstream ofl2;
      ofl.open("angleDensity_00" + to_string(globalTimeStep), ios_base::out | ios_base::trunc);
      ofl2.open("angleDensityCos_00" + to_string(globalTimeStep), ios_base::out | ios_base::trunc);
      if(ofl.is_open() && ofl.good()) {
        ofl << "# average orientation distribution functions, sampled from time steps " << globalTimeStep - noSamples
            << " to " << globalTimeStep << " (time level " << m_time - (((MFloat)noSamples) * timeStep()) << " to "
            << m_time << ")" << endl;
        ofl2 << "# average orientation distribution functions (cosines), sampled from time steps "
             << globalTimeStep - noSamples << " to " << globalTimeStep << " (time level "
             << m_time - (((MFloat)noSamples) * timeStep()) << " to " << m_time << ")" << endl;
        ofl << "# 1: angle" << endl;
        ofl << "# 2: bin size" << endl;
        ofl << "# 3: no samples in bin" << endl;
        ofl << "# 4-7: alignment of particle symmetry axis with x-axis" << endl;
        ofl << "# 8-11: alignment of particle symmetry axis with y-axis" << endl;
        ofl << "# 12-15: alignment of particle symmetry axis with z-axis" << endl;
        ofl << "# 16-19: alignment of particle symmetry axis with flow direction" << endl;
        ofl << "# 20-23: alignment of particle symmetry axis with vorticity direction" << endl;
        ofl << "# 24-27: alignment of particle velocity with flow velocity" << endl;
        ofl << "# 28-31: alignment of particle angular velocity with fluid vorticity" << endl;
        ofl << "# 32-35: alignment of particle velocity vector with symmetry axis" << endl;
        ofl << "# 36-39: alignment of particle rotation vector with symmetry axis" << endl;
        ofl << "# 40-43: alignment of relative velocity vector with symmetry axis" << endl;
        for(MInt i = 0; i < thetaSize; i++) {
          ofl << thetaPoints(i) << " " << thetaBounds(i + 1) - thetaBounds(i) << " " << F0;
          ofl2 << thetaPoints2(i) << " " << thetaBounds2(i + 1) - thetaBounds2(i) << " " << F0;
          for(MInt j = 0; j < noDat; j++) {
            if(j % 4 > 1 && i >= thetaSize / 2)
              ofl << " nan"; // symmetry in theta
            else
              ofl << " " << thetaDensity(i, j);
            if(j % 4 > 1 && i < thetaSize / 2)
              ofl2 << " nan"; // symmetry in theta
            else
              ofl2 << " " << thetaDensity2(i, j);
          }
          ofl << endl;
          ofl2 << endl;
        }
        ofl.close();
        ofl2.close();
      }
    }

    RECORD_TIMER_STOP(t_odf);
    RECORD_TIMER_START(t_pdf);

    const MInt noPdfPoints = 100;
    // const MInt kernelSteps = 0; //no kernel smoothing
    const MInt kernelSteps = 5; // kernel smoothing
    // PF: Particle & Fluid
    // P: Particle
    const MInt noPdfsPF = 7;
    const MInt noPdfsP = 17;
    MFloatScratchSpace dataPointsPF(noPdfsPF, AT_, "dataPointsPF");
    MFloatScratchSpace pdfPointsPF(noPdfsPF, noPdfPoints, AT_, "pdfPointsPF");
    MFloatScratchSpace pdfBoundsPF(noPdfsPF, noPdfPoints + 1, AT_, "pdfBoundsPF");
    MFloatScratchSpace pdfValuesPFfluid(noPdfsPF, noPdfPoints, AT_, "pdfValuesPFfluid");
    MFloatScratchSpace pdfValuesPFparticle(noPdfsPF, noPdfPoints, AT_, "pdfValuesPFparticle");
    MFloatScratchSpace dataPointsP(noPdfsP, AT_, "dataPointsP");
    MFloatScratchSpace pdfPointsP(noPdfsP, noPdfPoints, AT_, "pdfPointsP");
    MFloatScratchSpace pdfBoundsP(noPdfsP, noPdfPoints + 1, AT_, "pdfBoundsP");
    MFloatScratchSpace pdfValuesP(noPdfsP, noPdfPoints, AT_, "pdfValuesP");
    MFloatScratchSpace meanValsPF(2, noPdfsPF, AT_, "meanValsPF");
    MFloatScratchSpace rmsValsPF(2, noPdfsPF, AT_, "rmsValsPF");
    MFloatScratchSpace sumValsPF(2, AT_, "sumValsPF");
    MFloatScratchSpace meanValsP(noPdfsP, AT_, "meanValsP");
    MFloatScratchSpace rmsValsP(noPdfsP, AT_, "rmsValsP");
    vector<MString> pdfTitle;
    dataPointsPF.fill(F0);
    pdfPointsPF.fill(F0);
    pdfBoundsPF.fill(F0);
    pdfValuesPFfluid.fill(F0);
    pdfValuesPFparticle.fill(F0);
    dataPointsP.fill(F0);
    pdfPointsP.fill(F0);
    pdfBoundsP.fill(F0);
    pdfValuesP.fill(F0);
    meanValsPF.fill(F0);
    rmsValsPF.fill(F0);
    meanValsP.fill(F0);
    rmsValsP.fill(F0);
    sumValsPF.fill(F0);
    MFloat sumValsP = F0;

    //------- Fluid values in the flow field and near the particle
    pdfBoundsPF(0, 0) = 0.0;
    pdfBoundsPF(0, noPdfPoints) = 200.0;
    pdfTitle.push_back("angular-velocity(particle-fluid)");
    pdfBoundsPF(1, 0) = 0.0;
    pdfBoundsPF(1, noPdfPoints) = 200.0;
    pdfTitle.push_back("strain-rate(particle-fluid)");
    pdfBoundsPF(2, 0) = 0.98;
    pdfBoundsPF(2, noPdfPoints) = 1.03;
    pdfTitle.push_back("pressure(particle-fluid)");
    pdfBoundsPF(3, 0) = 0.0;
    pdfBoundsPF(3, noPdfPoints) = 3.0;
    pdfTitle.push_back("velocity(particle-fluid)");

    pdfBoundsPF(4, 0) = -1.5;
    pdfBoundsPF(4, noPdfPoints) = 1.5;
    pdfTitle.push_back("velX(particle-fluid)");
    pdfBoundsPF(5, 0) = -1.5;
    pdfBoundsPF(5, noPdfPoints) = 1.5;
    pdfTitle.push_back("velY(particle-fluid)");
    pdfBoundsPF(6, 0) = -1.5;
    pdfBoundsPF(6, noPdfPoints) = 1.5;
    pdfTitle.push_back("velZ(particle-fluid)");
    //------- Particle-related values
    pdfBoundsP(0, 0) = 0.0;
    pdfBoundsP(0, noPdfPoints) = 3.0;
    pdfTitle.push_back("velocity(particle)");
    pdfBoundsP(1, 0) = 0.0;
    pdfBoundsP(1, noPdfPoints) = 150.0;
    pdfTitle.push_back("angular-velocity(particle)");
    pdfBoundsP(2, 0) = 0.0;
    pdfBoundsP(2, noPdfPoints) = 50.0;
    pdfTitle.push_back("particle-Reynolds-number");
    pdfBoundsP(3, 0) = -10.0;
    pdfBoundsP(3, noPdfPoints) = 100.0;
    pdfTitle.push_back("F_p");
    pdfBoundsP(4, 0) = -2.0;
    pdfBoundsP(4, noPdfPoints) = 30.0;
    pdfTitle.push_back("F*(U_p-v_p)");
    pdfBoundsP(5, 0) = -8.0;
    pdfBoundsP(5, noPdfPoints) = 20.0;
    pdfTitle.push_back("F*U_p");
    pdfBoundsP(6, 0) = -25.0;
    pdfBoundsP(6, noPdfPoints) = 2.0;
    pdfTitle.push_back("F*v_p");
    pdfBoundsP(7, 0) = -2.0;
    pdfBoundsP(7, noPdfPoints) = 10.0;
    pdfTitle.push_back("T_p");
    pdfBoundsP(8, 0) = -0.3;
    pdfBoundsP(8, noPdfPoints) = 0.3;
    pdfTitle.push_back("T_p*(O_p-w_p)");
    pdfBoundsP(9, 0) = -0.2;
    pdfBoundsP(9, noPdfPoints) = 0.2;
    pdfTitle.push_back("T_p*O_p");
    pdfBoundsP(10, 0) = -0.3;
    pdfBoundsP(10, noPdfPoints) = 0.3;
    pdfTitle.push_back("T_p*w_p");
    pdfBoundsP(11, 0) = -100.0;
    pdfBoundsP(11, noPdfPoints) = 100.0;
    pdfTitle.push_back("wHat_px");
    pdfBoundsP(12, 0) = -100.0;
    pdfBoundsP(12, noPdfPoints) = 100.0;
    pdfTitle.push_back("wHat_py");
    pdfBoundsP(13, 0) = -100.0;
    pdfBoundsP(13, noPdfPoints) = 100.0;
    pdfTitle.push_back("wHat_pz");
    pdfBoundsP(14, 0) = -100.0;
    pdfBoundsP(14, noPdfPoints) = 100.0;
    pdfTitle.push_back("OHat_px");
    pdfBoundsP(15, 0) = -100.0;
    pdfBoundsP(15, noPdfPoints) = 100.0;
    pdfTitle.push_back("OHat_py");
    pdfBoundsP(16, 0) = -100.0;
    pdfBoundsP(16, noPdfPoints) = 100.0;
    pdfTitle.push_back("OHat_pz");

    for(MInt i = 0; i < noPdfsPF; i++) {
      const MFloat DV = (pdfBoundsPF(i, noPdfPoints) - pdfBoundsPF(i, 0)) / ((MFloat)noPdfPoints);
      for(MInt j = 0; j < noPdfPoints; j++) {
        pdfBoundsPF(i, j + 1) = pdfBoundsPF(i, j) + DV;
        pdfPointsPF(i, j) = F1B2 * (pdfBoundsPF(i, j + 1) + pdfBoundsPF(i, j));
      }
    }
    for(MInt i = 0; i < noPdfsP; i++) {
      const MFloat DV = (pdfBoundsP(i, noPdfPoints) - pdfBoundsP(i, 0)) / ((MFloat)noPdfPoints);
      for(MInt j = 0; j < noPdfPoints; j++) {
        pdfBoundsP(i, j + 1) = pdfBoundsP(i, j) + DV;
        pdfPointsP(i, j) = F1B2 * (pdfBoundsP(i, j + 1) + pdfBoundsP(i, j));
      }
    }

    for(MInt c = 0; c < noLeafCells; c++) {
      MInt cellId = leafCells(c);
      MFloat volume = a_cellVolume(cellId) / grid().gridCellVolume(maxUniformRefinementLevel());
      MFloat vort = F0;
      MFloat strain = F0;
      MFloat velm = F0;
      for(MInt i = 0; i < nDim; i++) {
        MInt id0 = (i + 1) % 3;
        MInt id1 = (id0 + 1) % 3;
        vort += POW2(F1B2 * (a_slope(cellId, PV->VV[id1], id0) - a_slope(cellId, PV->VV[id0], id1)));
        for(MInt j = 0; j < nDim; j++) {
          strain += POW2(F1B2 * (a_slope(cellId, PV->VV[i], j) + a_slope(cellId, PV->VV[j], i)));
        }
        velm += POW2(a_pvariable(cellId, PV->VV[i]));
      }
      vort = sqrt(vort);
      strain = sqrt(strain);
      velm = sqrt(velm);
      MFloat pressure = a_pvariable(cellId, PV->P) / m_PInfinity;
      dataPointsPF(0) = vort * DX / m_UInfinity;
      dataPointsPF(1) = strain * DX / m_UInfinity;
      dataPointsPF(2) = pressure;
      dataPointsPF(3) = velm / m_UInfinity;
      dataPointsPF(4) = a_pvariable(cellId, PV->VV[0]) / m_UInfinity;
      dataPointsPF(5) = a_pvariable(cellId, PV->VV[1]) / m_UInfinity;
      dataPointsPF(6) = a_pvariable(cellId, PV->VV[2]) / m_UInfinity;
      const MFloat weight = volume;
      for(MInt i = 0; i < noPdfsPF; i++) {
        meanValsPF(0, i) += weight * dataPointsPF(i);
        rmsValsPF(0, i) += weight * POW2(dataPointsPF(i));
      }
      sumValsPF(0) += weight;

      for(MInt i = 0; i < noPdfsPF; i++) {
        const MFloat DV = (pdfBoundsPF(i, noPdfPoints) - pdfBoundsPF(i, 0)) / ((MFloat)noPdfPoints);
        MInt bin = (MInt)floor((dataPointsPF(i) - pdfBoundsPF(i, 0)) / DV);
        const MFloat kernelWidth = DV * ((MFloat)kernelSteps);
        const MFloat fac = F1 / (kernelWidth);
        if(kernelSteps == 0) {
          if(bin > -1 && bin < noPdfPoints) pdfValuesPFfluid(i, bin) += weight;
        } else {
          for(MInt j = bin - 5 * kernelSteps; j < bin + 5 * kernelSteps; j++) {
            if(j < 0 || j >= noPdfPoints) continue;
            MFloat t = fabs(dataPointsPF(i) - pdfPointsPF(i, j)) / DV;
            pdfValuesPFfluid(i, j) += fac * weight * exp(-F1B2 * POW2(t)) / sqrt(F2 * PI); // Gaussian kernel
          }
        }
      }
    }

    for(MInt p = 0; p < noParticles; p++) {
      if(skipParticle(p)) continue;
      // --- particle-fluid
      MFloat velRot = F0;
      MFloat shear = F0;
      MFloat velm = F0;
      for(MInt i = 0; i < nDim; i++) {
        velRot += POW2(pOmegaHat[p * nDim + i]);
        for(MInt j = 0; j < nDim; j++) {
          shear += POW2(velShearHat[p * nDim + i]);
        }
        velm += POW2(vel[3 * p + i]);
      }
      dataPointsPF(0) = sqrt(velRot) * DX / m_UInfinity;
      dataPointsPF(1) = sqrt(shear) * DX / m_UInfinity;
      dataPointsPF(2) = particleFluidPressure[p] / m_PInfinity;
      dataPointsPF(3) = sqrt(velm) / m_UInfinity;
      dataPointsPF(4) = vel[3 * p + 0] / m_UInfinity;
      dataPointsPF(5) = vel[3 * p + 1] / m_UInfinity;
      dataPointsPF(6) = vel[3 * p + 2] / m_UInfinity;
      for(MInt i = 0; i < noPdfsPF; i++) {
        const MFloat DV = (pdfBoundsPF(i, noPdfPoints) - pdfBoundsPF(i, 0)) / ((MFloat)noPdfPoints);
        MInt bin = (MInt)floor((dataPointsPF(i) - pdfBoundsPF(i, 0)) / DV);
        const MFloat kernelWidth = DV * ((MFloat)kernelSteps);
        const MFloat fac = F1 / (kernelWidth);
        if(kernelSteps == 0) {
          if(bin > -1 && bin < noPdfPoints) pdfValuesPFparticle(i, bin) += F1;
        } else {
          for(MInt j = bin - 5 * kernelSteps; j < bin + 5 * kernelSteps; j++) {
            if(j < 0 || j >= noPdfPoints) continue;
            MFloat t = fabs(dataPointsPF(i) - pdfPointsPF(i, j)) / DV;
            pdfValuesPFparticle(i, j) += fac * exp(-F1B2 * POW2(t)) / sqrt(F2 * PI); // Gaussian kernel
          }
        }
      }
      for(MInt i = 0; i < noPdfsPF; i++) {
        meanValsPF(1, i) += dataPointsPF(i);
        rmsValsPF(1, i) += POW2(dataPointsPF(i));
      }
      sumValsPF(1) += F1;
      // --- particle
      MFloat prot = F0;
      MFloat partvel = F0;
      for(MInt i = 0; i < nDim; i++) {
        partvel += POW2(pvel[3 * p + i]);
        prot += POW2(protVelHat[3 * p + i]);
      }
      dataPointsP(0) = sqrt(partvel) / m_UInfinity;
      dataPointsP(1) = sqrt(prot) * DX / m_UInfinity;
      MFloat Rep = F0;
      MFloat diameter = F2 * pow(pRadii[3 * p] * pRadii[3 * p + 1] * pRadii[3 * p + 2], F1B3);
      for(MInt i = 0; i < nDim; i++) {
        Rep += POW2(vel[nDim * p + i] - pvel[nDim * p + i]);
      }
      dataPointsP(2) = sqrt(Rep) * diameter * m_rhoInfinity * sysEqn().m_Re0 / sysEqn().m_muInfinity;
      MFloat pF = F0;
      MFloat pFUv = F0;
      MFloat pFU = F0;
      MFloat pFv = F0;
      MFloat pT = F0;
      MFloat pTOw = F0;
      MFloat pTO = F0;
      MFloat pTw = F0;
      vector<MFloat> pForce(3, F0);
      vector<MFloat> pTorqueHat(3, F0);
      MFloat q[3];
      MFloatScratchSpace R(3, 3, AT_, "R");
      computeRotationMatrix(R, &(quats[4 * p]));
      if(m_noEmbeddedBodies > 0) {
        matrixVectorProduct(q, R, &m_bodyTorque[nDim * p]);
        for(MInt i = 0; i < nDim; i++) {
          pForce[i] = m_hydroForce[nDim * p + i];
          pTorqueHat[i] = q[i];
        }
      } else { // point-particles
        const MFloat pmass = F4B3 * PI * m_particleRadii[3 * p] * m_particleRadii[3 * p + 1]
                             * m_particleRadii[3 * p + 2] * m_densityRatio * m_rhoInfinity;
        const MFloat Ix = F1B5 * (POW2(m_particleRadii[3 * p + 1]) + POW2(m_particleRadii[3 * p + 2])) * pmass;
        const MFloat Iy = F1B5 * (POW2(m_particleRadii[3 * p + 0]) + POW2(m_particleRadii[3 * p + 2])) * pmass;
        const MFloat Iz = F1B5 * (POW2(m_particleRadii[3 * p + 0]) + POW2(m_particleRadii[3 * p + 1])) * pmass;
        const MFloat momI[3] = {Ix, Iy, Iz};
        for(MInt i = 0; i < nDim; i++) {
          pForce[i] = pmass * m_particleAcceleration[nDim * p + i];
          pTorqueHat[i] = momI[i] * m_particleAngularAcceleration[3 * p + i];
          protVelHat[i] = protVelHat[p * 3 + i];
        }
      }
      for(MInt i = 0; i < nDim; i++) {
        pF += POW2(pForce[i]);
        pFUv += pForce[i] * (vel[nDim * p + i] - pvel[nDim * p + i]);
        pFU += pForce[i] * vel[nDim * p + i];
        pFv += pForce[i] * pvel[nDim * p + i];
        pT += POW2(pTorqueHat[i]);
        pTOw += pTorqueHat[i] * (pOmegaHat[p * 3 + i] - protVelHat[p * 3 + i]);
        pTO += pTorqueHat[i] * pOmegaHat[p * 3 + i];
        pTw += pTorqueHat[i] * protVelHat[p * 3 + i];
      }
      dataPointsP(3) = sqrt(pF) / (POW3(m_UInfinity) * POW2(diameter));
      dataPointsP(4) = pFUv / (POW3(m_UInfinity) * POW2(diameter));
      dataPointsP(5) = pFU / (POW3(m_UInfinity) * POW2(diameter));
      dataPointsP(6) = pFv / (POW3(m_UInfinity) * POW2(diameter));
      dataPointsP(7) = sqrt(pT) / (POW3(m_UInfinity) * POW2(diameter));
      dataPointsP(8) = pTOw / (POW3(m_UInfinity) * POW2(diameter));
      dataPointsP(9) = pTO / (POW3(m_UInfinity) * POW2(diameter));
      dataPointsP(10) = pTw / (POW3(m_UInfinity) * POW2(diameter));

      for(MInt i = 0; i < nDim; i++) {
        dataPointsP(11 + i) = protVelHat[p * nDim + i] * DX / m_UInfinity;
        dataPointsP(14 + i) = pOmegaHat[p * nDim + i] * DX / m_UInfinity;
      }
      for(MInt i = 0; i < noPdfsP; i++) {
        meanValsP(i) += dataPointsP(i);
        rmsValsP(i) += POW2(dataPointsP(i));
      }
      sumValsP += F1;

      for(MInt i = 0; i < noPdfsP; i++) {
        const MFloat DV = (pdfBoundsP(i, noPdfPoints) - pdfBoundsP(i, 0)) / ((MFloat)noPdfPoints);
        MInt bin = (MInt)floor((dataPointsP(i) - pdfBoundsP(i, 0)) / DV);
        const MFloat kernelWidth = DV * ((MFloat)kernelSteps);
        const MFloat fac = F1 / (kernelWidth);
        if(kernelSteps == 0) {
          if(bin > -1 && bin < noPdfPoints) pdfValuesP(i, bin) += F1;
        } else {
          for(MInt j = bin - 5 * kernelSteps; j < bin + 5 * kernelSteps; j++) {
            if(j < 0 || j >= noPdfPoints) continue;
            MFloat t = fabs(dataPointsP(i) - pdfPointsP(i, j)) / DV;
            pdfValuesP(i, j) += fac * exp(-F1B2 * POW2(t)) / sqrt(F2 * PI); // Gaussian kernel
          }
        }
      }
    }

    if(domainId() == 0) {
      MPI_Reduce(MPI_IN_PLACE, &meanValsPF[0], 2 * noPdfsPF, MPI_DOUBLE, MPI_SUM, 0, mpiComm(), AT_, "MPI_IN_PLACE",
                 "meanValsPF[0]");
      MPI_Reduce(MPI_IN_PLACE, &rmsValsPF[0], 2 * noPdfsPF, MPI_DOUBLE, MPI_SUM, 0, mpiComm(), AT_, "MPI_IN_PLACE",
                 "rmsValsPF[0]");
      MPI_Reduce(MPI_IN_PLACE, &sumValsPF[0], 2, MPI_DOUBLE, MPI_SUM, 0, mpiComm(), AT_, "MPI_IN_PLACE",
                 "sumValsPF[0]");
    } else {
      MPI_Reduce(&meanValsPF[0], &meanValsPF[0], 2 * noPdfsPF, MPI_DOUBLE, MPI_SUM, 0, mpiComm(), AT_, "MPI_IN_PLACE",
                 "meanValsPF[0]");
      MPI_Reduce(&meanValsPF[0], &rmsValsPF[0], 2 * noPdfsPF, MPI_DOUBLE, MPI_SUM, 0, mpiComm(), AT_, "MPI_IN_PLACE",
                 "rmsValsPF[0]");
      MPI_Reduce(&meanValsPF[0], &sumValsPF[0], 2, MPI_DOUBLE, MPI_SUM, 0, mpiComm(), AT_, "MPI_IN_PLACE",
                 "sumValsPF[0]");
    }

    if(m_noPointParticles > 0) {
      MPI_Reduce(MPI_IN_PLACE, &pdfValuesPFfluid[0], noPdfsPF * noPdfPoints, MPI_DOUBLE, MPI_SUM, 0, mpiComm(), AT_,
                 "MPI_IN_PLACE", "pdfValuesPFfluid[0]");
      MPI_Reduce(MPI_IN_PLACE, &pdfValuesPFparticle[0], noPdfsPF * noPdfPoints, MPI_DOUBLE, MPI_SUM, 0, mpiComm(), AT_,
                 "MPI_IN_PLACE", "pdfValuesPFparticle[0]");
      MPI_Reduce(MPI_IN_PLACE, &meanValsP[0], noPdfsP, MPI_DOUBLE, MPI_SUM, 0, mpiComm(), AT_, "MPI_IN_PLACE",
                 "meanValsP[0]");
      MPI_Reduce(MPI_IN_PLACE, &rmsValsP[0], noPdfsP, MPI_DOUBLE, MPI_SUM, 0, mpiComm(), AT_, "MPI_IN_PLACE",
                 "rmsValsP[0]");
      MPI_Reduce(MPI_IN_PLACE, &sumValsP, 1, MPI_DOUBLE, MPI_SUM, 0, mpiComm(), AT_, "MPI_IN_PLACE", "sumValsP[0]");
      MPI_Reduce(MPI_IN_PLACE, &pdfValuesP[0], noPdfsP * noPdfPoints, MPI_DOUBLE, MPI_SUM, 0, mpiComm(), AT_,
                 "MPI_IN_PLACE", "pdfValuesP[0]");
    }

    if(domainId() == 0) {
      for(MInt i = 0; i < noPdfsPF; i++) {
        meanValsPF(0, i) /= sumValsPF(0);
        meanValsPF(1, i) /= sumValsPF(1);
        rmsValsPF(0, i) = sqrt(rmsValsPF(0, i) / sumValsPF(0));
        rmsValsPF(1, i) = sqrt(rmsValsPF(1, i) / sumValsPF(1));
      }
      for(MInt i = 0; i < noPdfsP; i++) {
        meanValsP(i) /= sumValsP;
        rmsValsP(i) = sqrt(rmsValsP(i) / sumValsP);
      }

      MFloatScratchSpace nfacsPF(noPdfsPF, 2, AT_, "nfacsPF");
      MFloatScratchSpace nfacsP(noPdfsP, AT_, "nfacsP");
      for(MInt i = 0; i < noPdfsPF; i++) {
        MFloat sumv = F0;
        MFloat sumv2 = F0;
        for(MInt j = 0; j < noPdfPoints; j++) {
          sumv += (pdfBoundsPF(i, j + 1) - pdfBoundsPF(i, j)) * pdfValuesPFfluid(i, j);
          sumv2 += (pdfBoundsPF(i, j + 1) - pdfBoundsPF(i, j)) * pdfValuesPFparticle(i, j);
        }
        nfacsPF(i, 0) = sumv;
        nfacsPF(i, 1) = sumv2;
        for(MInt j = 0; j < noPdfPoints; j++) {
          pdfValuesPFfluid(i, j) /= sumv;
          pdfValuesPFparticle(i, j) /= sumv2;
        }
      }
      for(MInt i = 0; i < noPdfsP; i++) {
        MFloat sumv = F0;
        for(MInt j = 0; j < noPdfPoints; j++) {
          sumv += (pdfBoundsP(i, j + 1) - pdfBoundsP(i, j)) * pdfValuesP(i, j);
        }
        nfacsP(i) = sumv;
        for(MInt j = 0; j < noPdfPoints; j++) {
          pdfValuesP(i, j) /= sumv;
        }
      }
      ofstream ofl;
      ofl.open("pdf_00" + to_string(globalTimeStep), ios_base::out | ios_base::trunc);
      if(ofl.is_open() && ofl.good()) {
        // print header --------
        ofl << "# average pdfs, sampled at time step " << globalTimeStep << " (time level " << m_time << ")" << endl;
        ofl << "#particle-fluid meanVals: #fluid #particle-fluid: ";
        for(MInt i = 0; i < noPdfsPF; i++) {
          ofl << meanValsPF(0, i) << " " << meanValsPF(1, i) << " ";
        }
        ofl << endl;
        ofl << "#particle-fluid rmsVals: #fluid #particle-fluid: ";
        for(MInt i = 0; i < noPdfsPF; i++) {
          ofl << rmsValsPF(0, i) << " " << rmsValsPF(1, i) << " ";
        }
        ofl << endl;
        ofl << "#particle meanVals: ";
        for(MInt i = 0; i < noPdfsP; i++) {
          ofl << meanValsP(i) << " ";
        }
        ofl << endl;
        ofl << "#particle rmsVals: ";
        for(MInt i = 0; i < noPdfsP; i++) {
          ofl << rmsValsP(i) << " ";
        }
        ofl << endl;
        MInt cnt = 1;
        for(MUint i = 0; i < noPdfsPF; i++) {
          ofl << "#" << cnt++ << ":" << pdfTitle[i];
          ofl << ", " << cnt++ << ": pdf_fluid, ";
          ofl << cnt++ << ": pdf_particleFluid" << endl;
        }
        for(MUint i = noPdfsPF; i < pdfTitle.size(); i++) {
          ofl << "#" << cnt++ << ":" << pdfTitle[i];
          ofl << ", " << cnt++ << ": pdf_particle" << endl;
        }
        // print header -------- finished
        for(MInt j = 0; j < noPdfPoints; j++) {
          for(MInt i = 0; i < noPdfsPF; i++) {
            ofl << pdfPointsPF(i, j) << " " << pdfValuesPFfluid(i, j) << " " << pdfValuesPFparticle(i, j) << " ";
          }
          for(MInt i = 0; i < noPdfsP; i++) {
            ofl << pdfPointsP(i, j) << " " << pdfValuesP(i, j) << " ";
          }
          for(MInt i = 0; i < noPdfsPF; i++) {
            ofl << nfacsPF(i, 0) << " " << nfacsPF(i, 1) << " ";
          }
          for(MInt i = 0; i < noPdfsP; i++) {
            ofl << nfacsP(i) << " " << nfacsP(i) << " ";
          }
          ofl << endl;
        }
        ofl.close();
      }
    }
    RECORD_TIMER_STOP(t_pdf);
  }

  // near-particle statistics
  if(computeNearBody && m_noEmbeddedBodies > 0) {
    IF_CONSTEXPR(nDim == 2) mTerm(1, AT_, "computeNearBody not implemented for 2D!");
    RECORD_TIMER_START(t_near);

    // bodyDataScatter -> scatter plot
    constexpr MInt noDat2 = 26;
    const MInt noReClasses = (m_bodyTypeMb == 3 ? 6 : 1);
    MFloatScratchSpace ReClass(m_noEmbeddedBodies, AT_, "ReClass");
    MFloatScratchSpace ReClassBounds(noReClasses, AT_, "ReClassBounds");
    MFloatScratchSpace bodyDataScatter(m_noEmbeddedBodies, noDat2, AT_, "bodyDataScatter");
    MFloatScratchSpace bodyCnt(noReClasses, AT_, "bodyCnt");
    bodyDataScatter.fill(F0);
    bodyCnt.fill(F0);

    if(m_bodyTypeMb == 3) {
      ReClassBounds(0) = 0;
      ReClassBounds(1) = 10;
      ReClassBounds(2) = 40;
      ReClassBounds(3) = 50;
      ReClassBounds(4) = 80;
      ReClassBounds(5) = 90;
    }

    RECORD_TIMER_START(t_near_bodydat2);
    for(MInt p = 0; p < m_noEmbeddedBodies; p++) {
      MFloat diameter = F2 * pow(m_bodyRadii[3 * p] * m_bodyRadii[3 * p + 1] * m_bodyRadii[3 * p + 2], F1B3);
      MFloat vrel[3] = {F0, F0, F0};
      MFloat vdir[3] = {F0, F0, F0};
      MFloat vpdir[3] = {F0, F0, F0};
      MFloat vfdir[3] = {F0, F0, F0};
      MFloat omegaRel[3] = {F0, F0, F0};
      MFloat vrel_mag = F0;
      MFloat vp_mag = F0;
      MFloat vf_mag = F0;
      for(MInt i = 0; i < nDim; i++) {
        vrel[i] = vel[nDim * p + i] - pvel[nDim * p + i];
        vpdir[i] = pvel[nDim * p + i];
        vfdir[i] = vel[nDim * p + i];
        vrel_mag += POW2(vrel[i]);
        vp_mag += POW2(vpdir[i]);
        vf_mag += POW2(vfdir[i]);
      }
      vrel_mag = sqrt(vrel_mag);
      vp_mag = sqrt(vp_mag);
      vf_mag = sqrt(vf_mag);
      for(MInt i = 0; i < nDim; i++) {
        vdir[i] = vrel[i] / mMax(1e-12, vrel_mag);
        vpdir[i] /= mMax(1e-12, vp_mag);
        vfdir[i] /= mMax(1e-12, vf_mag);
      }
      MFloat q[3];
      // fv_mb_cleanup
      MFloat tmp[3] = {F1, F0, F0};
      MFloatScratchSpace R(3, 3, AT_, "R");
      computeRotationMatrix(R, &(quats[4 * p]));
      matrixVectorProductTranspose(q, R, tmp); // orientation of z-principal axis
      const MFloat qabs = sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]);
      for(MInt i = 0; i < nDim; i++)
        q[i] /= mMax(1e-12, qabs);
      MFloat Rep = vrel_mag * diameter * m_rhoInfinity * sysEqn().m_Re0 / sysEqn().m_muInfinity;
      MInt classId = -1;
      if(m_bodyTypeMb == 3) {
        MFloat aof = F0;
        for(MInt i = 0; i < nDim; i++) {
          aof += vdir[i] * q[i];
        }
        aof = acos(fabs(aof)) * 360.0 / (2.0 * PI);
        for(MInt i = 1; i < noReClasses; i++) {
          if(aof >= ReClassBounds(i - 1) && aof < ReClassBounds(i)) {
            classId = i;
            break;
          }
        }
        ReClass(p) = classId;
        bodyCnt[0] += F1;
        bodyCnt[classId] += F1;
      } else {
        classId = 0;
        ReClass(p) = classId;
        bodyCnt[0] += F1;
        bodyCnt[classId] += F1;
      }

      MFloat eps0 = F0;
      MFloat eps1 = F0;
      for(MInt i = 0; i < nDim; i++) {
        eps0 += 5.0 * (sysEqn().m_muInfinity / sysEqn().m_Re0) * POW2(velGradient[9 * p + 3 * i + i]);
        for(MInt j = 0; j < nDim; j++) {
          eps1 += (sysEqn().m_muInfinity / sysEqn().m_Re0)
                  * (velGradient[9 * p + 3 * i + j] + velGradient[9 * p + 3 * j + i]) * velGradient[9 * p + 3 * i + j];
        }
      }
      const MFloat epsRef = diameter / (POW3(m_UInfinity));
      MFloat wdir[3]{};
      MFloat pOmega[3]{};
      for(MInt i = 0; i < nDim; i++) {
        MInt id0 = (i + 1) % 3;
        MInt id1 = (id0 + 1) % 3;
        wdir[i] = F1B2 * (velGradient[9 * p + 3 * id1 + id0] - velGradient[9 * p + 3 * id0 + id1]);
        pOmega[i] = wdir[i];
      }
      for(MInt i = 0; i < 3; i++) {
        omegaRel[i] = wdir[i] - m_bodyAngularVelocity[p * 3 + i];
      }
      const MFloat wabs = sqrt(POW2(wdir[0]) + POW2(wdir[1]) + POW2(wdir[2]));
      for(MInt i = 0; i < nDim; i++) {
        wdir[i] /= mMax(1e-12, wabs);
      }

      MFloat tmp2[3]{};
      MFloat force_frs[3]{};
      for(MInt i = 0; i < nDim; i++) {
        tmp2[i] = m_hydroForce[nDim * p + i];
      }
      matrixVectorProduct(force_frs, R, tmp2);
      MFloat torque_frs[3];
      for(MInt i = 0; i < 3; i++) {
        tmp2[i] = m_bodyTorque[3 * p + i];
      }
      matrixVectorProduct(torque_frs, R, tmp2);

      MInt cnt = 0;
      bodyDataScatter(p, cnt++) = Rep;
      bodyDataScatter(p, cnt++) = sqrt(POW2(vrel[0]) + POW2(vrel[1]) + POW2(vrel[2])) / m_UInfinity;
      bodyDataScatter(p, cnt++) =
          sqrt(POW2(pvel[nDim * p + 0]) + POW2(pvel[nDim * p + 1]) + POW2(pvel[nDim * p + 2])) / m_UInfinity;
      bodyDataScatter(p, cnt++) =
          (pvel[nDim * p + 0] * vdir[0] + pvel[nDim * p + 1] * vdir[1] + pvel[nDim * p + 2] * vdir[2]) / m_UInfinity;
      bodyDataScatter(p, cnt++) =
          sqrt(POW2(vel[nDim * p + 0]) + POW2(vel[nDim * p + 1]) + POW2(vel[nDim * p + 2])) / m_UInfinity;
      bodyDataScatter(p, cnt++) =
          (vel[nDim * p + 0] * vdir[0] + vel[nDim * p + 1] * vdir[1] + vel[nDim * p + 2] * vdir[2]) / m_UInfinity;
      bodyDataScatter(p, cnt++) = sqrt(POW2(pOmega[0]) + POW2(pOmega[1]) + POW2(pOmega[2])) * diameter / m_UInfinity;
      bodyDataScatter(p, cnt++) =
          (pOmega[0] * vdir[0] + pOmega[1] * vdir[1] + pOmega[2] * vdir[2]) * diameter / m_UInfinity;
      bodyDataScatter(p, cnt++) = (vfdir[0] * vpdir[0] + vfdir[1] * vpdir[1] + vfdir[2] * vpdir[2]);
      bodyDataScatter(p, cnt++) = (vdir[0] * vpdir[0] + vdir[1] * vpdir[1] + vdir[2] * vpdir[2]);
      bodyDataScatter(p, cnt++) = (particleFluidPressure[p] - m_PInfinity) / (F1B2 * m_rhoInfinity * POW2(m_UInfinity));
      bodyDataScatter(p, cnt++) = eps0 * epsRef;
      bodyDataScatter(p, cnt++) = eps1 * epsRef;
      bodyDataScatter(p, cnt++) = nearBodyState[noNearBodyState * p + 0] * epsRef;
      bodyDataScatter(p, cnt++) = nearBodyState[noNearBodyState * p + 1] * epsRef;
      bodyDataScatter(p, cnt++) = nearBodyState[noNearBodyState * p + 2] * epsRef;
      bodyDataScatter(p, cnt++) = nearBodyState[noNearBodyState * p + 3] * epsRef;
      bodyDataScatter(p, cnt++) = nearBodyState[noNearBodyState * p + 4] * epsRef;
      bodyDataScatter(p, cnt++) = (m_hydroForce[nDim * p + 0] * vrel[0] + m_hydroForce[nDim * p + 1] * vrel[1]
                                   + m_hydroForce[nDim * p + 2] * vrel[2])
                                  / (POW3(m_UInfinity) * POW2(diameter));
      bodyDataScatter(p, cnt++) = (m_bodyTorque[3 * p + 0] * omegaRel[0] + m_bodyTorque[nDim * p + 1] * omegaRel[1]
                                   + m_bodyTorque[nDim * p + 2] * omegaRel[2])
                                  / (POW3(m_UInfinity) * POW2(diameter));
      bodyDataScatter(p, cnt++) = force_frs[0];
      bodyDataScatter(p, cnt++) = force_frs[1];
      bodyDataScatter(p, cnt++) = force_frs[2];
      bodyDataScatter(p, cnt++) = torque_frs[0];
      bodyDataScatter(p, cnt++) = torque_frs[1];
      bodyDataScatter(p, cnt++) = torque_frs[2];

      if(cnt != noDat2) mTerm(1, AT_, "data size mismatch.");
    }
    RECORD_TIMER_STOP(t_near_bodydat2);

    RECORD_TIMER_START(t_near_bodydat);
    // nearBodydata -> near-body flow pattern
    // define a local uniform grid around the particle for visualization
    const MFloat refRadius = m_maxBodyRadius;
    constexpr MInt noDat = 13;
    const MFloat dxm = 4.0;
    // const MFloat deltaR = mMin(drm, mMax(m_outerBandWidth[maxUniformRefinementLevel() + 1] / refRadius, 4.0));
    const MFloat deltaX =
        mMin(dxm, mMax(m_outerBandWidth[mMin(maxUniformRefinementLevel(), maxRefinementLevel() - 1)] / refRadius, 4.0));
    const MFloat dx =
        mMax(c_cellLengthAtLevel(maxRefinementLevel()), mMin(m_minBodyRadius / 4.0, m_maxBodyRadius / 8.0)) / refRadius;
    const MInt noPointsX = (MInt)((deltaX + 0.001 * dx) / dx);
    const MFloat deltaY = deltaX;
    const MInt noPointsY = noPointsX;
    const MFloat dy = dx;
    MFloatScratchSpace nearBodyData(noPointsX, noPointsY, noDat * noReClasses, AT_, "nearBodyData");
    MFloatScratchSpace bodySum(noPointsX, noPointsY, noReClasses, AT_, "bodySum");
    MFloatScratchSpace xPoints(noPointsX, AT_, "xPoints");
    MFloatScratchSpace xBounds(noPointsX + 1, AT_, "xBounds");
    MFloatScratchSpace yPoints(noPointsY, AT_, "yPoints");
    MFloatScratchSpace yBounds(noPointsY + 1, AT_, "yBounds");
    MFloatScratchSpace dat(noDat, AT_, "dat");
    MFloatScratchSpace K(3, 3, AT_, "K");
    const MInt dataSize0 = noPointsX * noPointsY * noReClasses;
    const MInt dataSize = noDat * dataSize0;
    nearBodyData.fill(F0);
    bodySum.fill(F0);

    xBounds(0) = (m_bodyTypeMb == 3) ? -F1B2 * deltaX : 0.0;
    for(MInt i = 0; i < noPointsX; i++) {
      xBounds(i + 1) = xBounds(i) + dx;
      xPoints(i) = F1B2 * (xBounds(i) + xBounds(i + 1));
    }
    yBounds(0) = (m_bodyTypeMb == 3) ? -F1B2 * deltaY : 0.0;
    for(MInt i = 0; i < noPointsY; i++) {
      yBounds(i + 1) = yBounds(i) + dy;
      yPoints(i) = F1B2 * (yBounds(i) + yBounds(i + 1));
    }

    for(MInt c = 0; c < noLeafCells; c++) {
      MInt cellId = leafCells(c);
      MFloat volume = F1; // no volume - weighting for nearBodyData
      if(volume < 1e-14) continue;
      if(a_level(cellId) <= maxUniformRefinementLevel()) continue;

      for(MInt set = m_startSet; set < m_noSets; set++) {
        if(a_associatedBodyIds(cellId, set) < 0) continue;
        // const MFloat dist0 = a_levelSetValuesMb(cellId, set);
        const MInt p = a_associatedBodyIds(cellId, set);
        const MInt q = m_internalBodyId[p];
        if(q < 0 || q >= m_noEmbeddedBodies) {
          cerr << "Warning: body id " << endl;
          continue;
        }
        if(skipParticle(q)) continue;
        const MInt classId = ReClass(q);
        if(classId < 0) continue;
        MFloat diameter = F2 * pow(m_bodyRadii[3 * q] * m_bodyRadii[3 * q + 1] * m_bodyRadii[3 * q + 2], F1B3);
        MFloat vrel[3] = {F0, F0, F0};
        MFloat vdir[3] = {F0, F0, F0};
        MFloat vrel_mag = F0;
        MFloat vmag = F0;
        MFloat r = F0;
        MFloat crossp[3] = {F0, F0, F0};
        MFloat crossp2[3] = {F0, F0, F0};
        MFloat symm[3];
        // fv_mb_cleanup
        MFloat tmp[3] = {F1, F0, F0};
        MFloat scnt = F0;
        MFloatScratchSpace R(3, 3, AT_, "R");
        computeRotationMatrix(R, &(quats[4 * q]));
        matrixVectorProductTranspose(symm, R, tmp); // orientation of z-principal axis
        for(MInt i = 0; i < nDim; i++) {
          vrel[i] = vel[nDim * q + i] - pvel[nDim * q + i];
          vrel_mag += POW2(vrel[i]);
          vmag += POW2(pvel[nDim * q + i]);
          scnt += POW2(symm[i]);
        }
        vmag = sqrt(vmag);
        vrel_mag = sqrt(vrel_mag);
        r = sqrt(r);
        scnt = sqrt(scnt);
        for(MInt i = 0; i < nDim; i++) {
          vdir[i] = vrel[i] / mMax(1e-14, vrel_mag);
          symm[i] = symm[i] / mMax(1e-14, scnt);
        }
        if(m_bodyTypeMb == 3) {
          MFloat minRad = mMin(mMin(m_bodyRadii[3 * p], m_bodyRadii[3 * p + 1]), m_bodyRadii[3 * p + 2]);
          r = (r - minRad) / minRad;
        } else {
          r = (r - m_bodyRadius[p]) / m_bodyRadius[p];
        }

        MFloat csm = F0;
        MFloat trans = F0;
        crossProduct(crossp, vdir, symm);
        for(MInt i = 0; i < nDim; i++) {
          csm += POW2(crossp[i]);
        }
        csm = sqrt(csm);
        for(MInt i = 0; i < nDim; i++) {
          crossp[i] = crossp[i] / mMax(1e-14, csm);
          trans += crossp[i] * (a_coordinate(cellId, i) - m_bodyCenter[nDim * p + i]);
        }
        crossProduct(crossp2, vdir, crossp);
        MFloat csm2 = F0;
        for(MInt i = 0; i < nDim; i++) {
          csm2 += POW2(crossp2[i]);
        }
        csm2 = sqrt(csm2);
        for(MInt i = 0; i < nDim; i++) {
          crossp2[i] = crossp2[i] / mMax(1e-14, csm2);
        }

        if(fabs(trans) > mMax(F2 * c_cellLengthAtLevel(maxRefinementLevel()), c_cellLengthAtCell(cellId))) {
          continue;
        }

        MInt idx = -1;
        MInt idy = -1;
        // Cartesian interpolation
        MFloat aof0 = F0;
        for(MInt i = 0; i < nDim; i++) {
          aof0 += vdir[i] * symm[i];
        }
        MFloat distx = F0;
        MFloat disty = F0;
        for(MInt i = 0; i < nDim; i++) {
          distx += (a_coordinate(cellId, i) - m_bodyCenter[nDim * p + i]) * vdir[i] / refRadius;
          disty += (a_coordinate(cellId, i) - m_bodyCenter[nDim * p + i]) * crossp2[i] / refRadius;
        }
        if(aof0 < F0) disty *= -F1;
        idx = (MInt)(distx / dx) + noPointsX / 2;
        idy = (MInt)(disty / dy) + noPointsY / 2;

        dat.fill(F0);
        if(idy < 0 || idx < 0 || idy >= noPointsY || idx >= noPointsX) {
          continue;
        }

        MInt idCnt = 0;
        MFloat vabs = F0;
        MFloat vabs2 = F0;
        for(MInt i = 0; i < nDim; i++) {
          vabs += POW2(a_pvariable(cellId, PV->VV[i]) - pvel[nDim * q + i]);
          vabs2 += POW2(a_pvariable(cellId, PV->VV[i]) - vel[nDim * q + i]);
        }
        vabs = sqrt(vabs);
        vabs2 = sqrt(vabs2);
        dat(idCnt++) = vabs / m_UInfinity;
        dat(idCnt++) = vabs / vmag;
        dat(idCnt++) = vabs2 / m_UInfinity;
        dat(idCnt++) = vabs2 / vrel_mag;
        MFloat cp = (a_pvariable(cellId, PV->P) - particleFluidPressure[q]);
        dat(idCnt++) = cp / (F1B2 * m_rhoInfinity * POW2(m_UInfinity));
        dat(idCnt++) = cp / (F1B2 * m_rhoInfinity * POW2(vrel_mag));

        MFloat vort[3]{};
        for(MInt i = 0; i < nDim; i++) {
          MInt id0 = (i + 1) % 3;
          MInt id1 = (id0 + 1) % 3;
          vort[i] = F1B2 * (a_slope(cellId, PV->VV[id1], id0) - a_slope(cellId, PV->VV[id0], id1));
        }

        MFloat U2 = F0;
        MFloat eps = F0;
        MFloat eps0 = F0;
        for(MInt i = 0; i < nDim; i++) {
          U2 += POW2(a_variable(cellId, CV->RHO_VV[i]) / a_variable(cellId, CV->RHO));
        }
        MFloat mue = sysEqn().m_muInfinity / sysEqn().m_Re0;
        MFloat Ek = F1B2 * U2;
        for(MInt i = 0; i < nDim; i++) {
          eps0 += 5.0 * mue * POW2(a_slope(cellId, PV->VV[i], i));
          for(MInt j = 0; j < nDim; j++) {
            eps +=
                mue * (a_slope(cellId, PV->VV[i], j) + a_slope(cellId, PV->VV[j], i)) * a_slope(cellId, PV->VV[i], j);
          }
        }
        const MFloat epsRef = diameter / (POW3(m_UInfinity));
        dat(idCnt++) = Ek / POW2(m_UInfinity);
        dat(idCnt++) = (Ek - meanState(0)) / POW2(m_UInfinity);
        dat(idCnt++) = eps * epsRef;
        dat(idCnt++) = eps0 * epsRef;
        dat(idCnt++) = (eps - meanState(3)) * epsRef;
        dat(idCnt++) = (eps0 - meanState(2)) * epsRef;
        dat(idCnt++) = (POW2(vort[0]) + POW2(vort[1]) + POW2(vort[2])) * diameter / m_UInfinity;
        if(idCnt != noDat) mTerm(1, AT_, "id mismatch.");

        for(MInt i = mMax(0, idx - 3); i < mMin(noPointsX, idx + 4); i++) {
          for(MInt j = mMax(0, idy - 3); j < mMin(noPointsY, idy + 4); j++) {
            const MFloat dist = sqrt(POW2((i - idx) * dx) + POW2((j - idy) * dy));
            const MFloat fac =
                exp(-F1B4 * POW2(dist)) * a_cellVolume(cellId) / grid().gridCellVolume(maxUniformRefinementLevel());
            for(MInt k = 0; k < noDat; k++) {
              nearBodyData(i, j, k) += fac * volume * dat(k);
            }
            bodySum(i, j, 0) += fac * volume;
            if(classId > 0) {
              for(MInt k = 0; k < noDat; k++) {
                nearBodyData(i, j, classId * noDat + k) += fac * volume * dat(k);
              }
              bodySum(i, j, classId) += fac * volume;
            }
          }
        }
      }
    }
    MPI_Allreduce(MPI_IN_PLACE, &nearBodyData[0], dataSize, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "nearBodyData[0]");
    MPI_Allreduce(MPI_IN_PLACE, &bodySum[0], dataSize0, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "bodySum[0]");

    for(MInt i = 0; i < noPointsX; i++) {
      for(MInt j = 0; j < noPointsY; j++) {
        for(MInt k = 0; k < noDat; k++) {
          for(MInt l = 0; l < noReClasses; l++) {
            if(bodySum(i, j, l) > F0) {
              nearBodyData(i, j, l * noDat + k) /= bodySum(i, j, l);
            }
          }
        }
      }
    }
    RECORD_TIMER_STOP(t_near_bodydat);
    RECORD_TIMER_START(t_near_output);
    // This output should be evantually generated via Netcdf
    if(domainId() == 0) {
      for(MInt l = 0; l < noReClasses; l++) {
        ofstream ofl;
        string suffix = (l > 0) ? "_class" + to_string(l) : "";
        ofl.open(("nearBodyData" + suffix + "_00" + to_string(globalTimeStep)).c_str(),
                 ios_base::out | ios_base::trunc);
        if(ofl.is_open() && ofl.good()) {
          ofl << "# mean near-body statistics at time step " << globalTimeStep << ", \n";
          ofl << "# average number of bodies in class: " << bodyCnt[l] << "\n";
          ofl << "# 1: lower bound x" << endl;
          ofl << "# 2: upper bound x" << endl;
          ofl << "# 3: x-Coordinate" << endl;
          ofl << "# 4: lower bound y" << endl;
          ofl << "# 5: upper bound y" << endl;
          ofl << "# 6: y-Coordinate" << endl;
          ofl << "# 7: sample weight" << endl;
          ofl << "# 8-9: relative velocity abs(u-v_p)" << endl;
          ofl << "# 12-13: relative velocity abs(u-U_p)" << endl;
          ofl << "# 14-15: cp" << endl;
          ofl << "# 16: Ek" << endl;
          ofl << "# 17: Ek - Ek_mean" << endl;
          ofl << "# 18: eps (isotropic)" << endl;
          ofl << "# 19: eps0" << endl;
          ofl << "# 20: eps - eps_mean (isotropic)" << endl;
          ofl << "# 21: eps0 - eps0_mean" << endl;
          ofl << "# 22: vorticity magnitude" << endl;
          ofl << endl;
          for(MInt i = 0; i < noPointsX; i++) {
            for(MInt j = 0; j < noPointsY; j++) {
              ofl << xBounds(i) << " " << xBounds(i + 1) << " " << xPoints(i) << " ";
              ofl << yBounds(j) << " " << yBounds(j + 1) << " " << yPoints(j) << " ";
              ofl << bodySum(i, j, l) << " ";
              if(bodySum(i, j, l) > F0) {
                for(MInt k = 0; k < noDat; k++) {
                  ofl << nearBodyData(i, j, l * noDat + k) << " ";
                }
              } else {
                for(MInt k = 0; k < noDat; k++) {
                  ofl << F0 << " " << F0 << " ";
                }
              }
              ofl << endl;
            }
            ofl << endl;
          }
        }
        ofl.close();
      }
    }
    // This output should be evantually generated via Netcdf
    if(domainId() == 0) {
      ofstream ofl;
      ofl.open("bodyData_00" + to_string(globalTimeStep), ios_base::out | ios_base::trunc);
      if(ofl.is_open() && ofl.good()) {
        ofl << "# body statistics at time step " << globalTimeStep << endl;
        ofl << "# 1: Re_p" << endl;
        ofl << "# 2: vel_rel abs" << endl;
        ofl << "# 3: vel_part abs" << endl;
        ofl << "# 4: vel_part inline" << endl;
        ofl << "# 5: vel_fluid abs" << endl;
        ofl << "# 6: vel_fluid inline" << endl;
        ofl << "# 7: vorticity abs" << endl;
        ofl << "# 8: cosine vorticity times vrel" << endl;
        ofl << "# 9: cosine vel fluid times vel part " << endl;
        ofl << "# 10: cosine rel vel times vel part " << endl;
        ofl << "# 11: c_p" << endl;
        ofl << "# 12: eps0" << endl;
        ofl << "# 13: eps1" << endl;
        ofl << "# 14: near-body eps 0.5 d_p" << endl;
        ofl << "# 15: near-body eps 1.0 d_p" << endl;
        ofl << "# 16: near-body eps 1.5 d_p" << endl;
        ofl << "# 17: near-body eps 2.0 d_p" << endl;
        ofl << "# 18: near-body eps 2.5 d_p" << endl;
        ofl << "# 19: F_p * (U_p - v_p)" << endl;
        ofl << "# 20: T_p * (O_p - o_p)" << endl;
        ofl << "# 21: FxHat" << endl;
        ofl << "# 22: FyHat" << endl;
        ofl << "# 23: FzHat" << endl;
        ofl << "# 24: TxHat" << endl;
        ofl << "# 25: TyHat" << endl;
        ofl << "# 26: TzHat" << endl;

        for(MInt p = 0; p < m_noEmbeddedBodies; p++) {
          for(MInt i = 0; i < noDat2; i++) {
            ofl << bodyDataScatter[noDat2 * p + i] << " ";
          }
          ofl << endl;
        }
        ofl.clear();
      }
      ofl.close();
    }
    RECORD_TIMER_STOP(t_near_output);
    RECORD_TIMER_STOP(t_near);
  }

  if(computeFFT) {
    RECORD_TIMER_START(t_fft);
    // fft-domain dimensions
    // this holds the size of the domain in number of cells on lowest level
    const MInt fftLevel = maxUniformRefinementLevel();
    if(fftLevel > maxUniformRefinementLevel()) mTerm(1, AT_, "Non-isotropic mesh is not implemented, yet");
    if(fftLevel < minLevel()) mTerm(1, AT_, "Parents missing for fftLevel < minLevel()");

    const MFloat dx = c_cellLengthAtLevel(fftLevel);
    const MFloat dxeps = 0.1 * dx;
    MInt nx = (m_bbox[3] - m_bbox[0] + dxeps) / dx;
    MInt ny = (m_bbox[4] - m_bbox[1] + dxeps) / dx;
    MInt nz = (m_bbox[5] - m_bbox[2] + dxeps) / dx;

    MFloatScratchSpace coupling(a_noCells(), nDim, AT_, "coupling");
    MFloatScratchSpace pVariables(a_noCells(), m_noPVars, AT_, "pVariables");
    MFloatScratchSpace cVariables(a_noCells(), m_noCVars, AT_, "cVariables");
    MFloatScratchSpace oldVariables(a_noCells(), m_noCVars, AT_, "oldVariables");
    MInt filterLvlLaplace = fftLevel;
    filterLvlLaplace = Context::getSolverProperty<MInt>("filterLvlLaplace", m_solverId, AT_, &filterLvlLaplace);

    MFloat couplingCheck = determineCoupling(coupling);
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      for(MInt i = 0; i < m_noPVars; i++) {
        pVariables(cellId, i) = a_pvariable(cellId, i);
      }
      for(MInt i = 0; i < m_noCVars; i++) {
        cVariables(cellId, i) = a_variable(cellId, i);
        oldVariables(cellId, i) = a_oldVariable(cellId, i);
      }
    }
    if(domainId() == 0)
      cerr << "coupling check " << couplingCheck << " " << m_couplingRate << " " << couplingCheck / (DX * DX * DX)
           << " " << m_couplingRate / (DX * DX * DX) << " " << DX * m_couplingRate / POW3(DX * m_UInfinity) << endl;

    // Apply volumetric filter
    if(maxRefinementLevel() != fftLevel) {
      for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
        if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;
        if(a_isPeriodic(cellId)) continue;
        if(a_bndryId(cellId) < -1) continue;
        if(a_isHalo(cellId)) continue;
        if(a_level(cellId) != fftLevel) continue;
        if(!a_hasProperty(cellId, SolverCell::IsSplitChild) && c_noChildren(cellId) > 0) {
          reduceData(cellId, &coupling(0), nDim, false);
          reduceData(cellId, &(pVariables(0, 0)), m_noPVars);
          reduceData(cellId, &(cVariables(0, 0)), m_noCVars);
          reduceData(cellId, &(oldVariables(0, 0)), m_noCVars);
        }
      }
    }

    MInt noLocDat = 0;
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      if(a_isHalo(cellId)) continue;
      if(a_isBndryGhostCell(cellId)) continue;
      if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
      if(a_level(cellId) != fftLevel) continue;
      noLocDat++;
    }
    MFloatScratchSpace velDat(noLocDat, 3 * nDim, AT_, "velDat");
    MIntScratchSpace velPos(noLocDat, AT_, "velPos");
    noLocDat = 0;
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      if(a_isHalo(cellId)) continue;
      if(a_isBndryGhostCell(cellId)) continue;
      if(a_level(cellId) != fftLevel) continue;
      if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
      MFloat actualCellLength = c_cellLengthAtCell(cellId);
      MInt xPos = floor((F1B2 * nx + (a_coordinate(cellId, 0) - F1B2 * (actualCellLength)) / dx) + 0.1);
      MInt yPos = floor((F1B2 * ny + (a_coordinate(cellId, 1) - F1B2 * (actualCellLength)) / dx) + 0.1);
      MInt zPos = floor((F1B2 * nz + (a_coordinate(cellId, 2) - F1B2 * (actualCellLength)) / dx) + 0.1);
      if(xPos > nx - 1 || xPos < 0 || yPos > ny - 1 || yPos < 0 || zPos > nz - 1 || zPos < 0) {
        cerr << "ERROR: wrong array position!" << endl;
        cerr << "pos=" << xPos << ", " << yPos << ", " << zPos << endl;
        cerr << "coorda = (" << a_coordinate(cellId, 0) << ", " << a_coordinate(cellId, 1) << ", "
             << a_coordinate(cellId, 2) << ")" << endl;
        cerr << "actuallength=" << actualCellLength << endl;
        cerr << "minlevel=" << minLevel() << ", maxLevel=" << maxLevel() << endl;
        cerr << "lenght on level0=" << c_cellLengthAtLevel(0) << endl;
        mTerm(1, AT_, "Wrong array position");
      }
      MInt pos = zPos + nz * (yPos + ny * xPos);
      for(MInt i = 0; i < nDim; i++) {
        velDat(noLocDat, i) = pVariables(cellId, PV->VV[i]) / m_UInfinity;
        velDat(noLocDat, nDim + i) = coupling(cellId, i) * DX / (grid().gridCellVolume(fftLevel) * POW2(m_UInfinity));
        MFloat u1 = cVariables(cellId, CV->RHO_VV[i]) / cVariables(cellId, CV->RHO);
        MFloat u0 = oldVariables(cellId, CV->RHO_VV[i]) / oldVariables(cellId, CV->RHO);
        velDat(noLocDat, 2 * nDim + i) = ((u1 - u0) / timeStep()) * DX / POW2(m_UInfinity);
      }
      if(m_noPointParticles > 0 && m_pointParticleTwoWayCoupling > 0) {
        for(MInt i = 0; i < nDim; i++) {
          velDat(noLocDat, nDim + i) =
              m_coupling[cellId][i] * (DX / (grid().gridCellVolume(fftLevel) * POW2(m_UInfinity)));
        }
      }
      velPos(noLocDat) = pos;
      noLocDat++;
    }

    maia::math::computeEnergySpectrum(velDat, velPos, 3 * nDim, noLocDat, nx, ny, nz,
                                      F1 / (sysEqn().m_Re0 * DX * m_UInfinity), mpiComm());

    RECORD_TIMER_STOP(t_fft);
  }

  m_firstStats = false;

  RECORD_TIMER_STOP(t_timertotal);
  DISPLAY_TIMER(t_timertotal);
}


template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::computeBodyVolume(MFloatScratchSpace& partVol) {
  TRACE();
  if(m_noEmbeddedBodies > 0) {
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      if(a_bndryId(cellId) < -1) continue;
      if(a_isHalo(cellId)) continue;
      if(a_isPeriodic(cellId)) continue;
      if(!a_hasProperty(cellId, SolverCell::IsSplitChild) && c_noChildren(cellId) > 0) continue;

      if(a_levelSetValuesMb(cellId, 0) < F0 || a_bndryId(cellId) >= m_noOuterBndryCells) {
        if(m_associatedBodyIds[IDX_LSSETMB(cellId, 0)] < 0
           || m_associatedBodyIds[IDX_LSSETMB(cellId, 0)] > m_noEmbeddedBodies + m_noPeriodicGhostBodies) {
          cerr << domainId() << ": negative body id B " << m_associatedBodyIds[IDX_LSSETMB(cellId, 0)] << " "
               << a_hasProperty(cellId, SolverCell::IsSplitCell) << " "
               << a_hasProperty(cellId, SolverCell::IsSplitChild) << endl;
          continue;
        }
        MInt bodyId = m_internalBodyId[m_associatedBodyIds[IDX_LSSETMB(cellId, 0)]];
        MFloat svol = grid().gridCellVolume(a_level(cellId));
        if(a_bndryId(cellId) > -1) svol -= a_cellVolume(cellId);
        partVol(bodyId) += svol;
        if(a_bndryId(cellId) < 0 && a_hasProperty(cellId, SolverCell::IsInactive)) a_cellVolume(cellId) = F0;
      }
    }
    MPI_Allreduce(MPI_IN_PLACE, &partVol[0], m_noEmbeddedBodies, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "partVol[0]");
    return;
  } else {
    cerr0 << "computeBodyVolume skipped since there are no Bodies." << endl;
    return;
  }
}


/**
 * \brief Mean parameters: near body data estimated by weighted filtering procedure
 * All parameters after "setup" can be replaced by nullptr, and will be excluded to safe comp.time
 * setup expects a vector with up to 4 values: minimal Distance, maximal Distance, maximal Angle (dotProduct relative
 * cell position with hydroForce) for velocity estimation, and maximal Angle for rotational velocity estimation
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::computeNearBodyFluidVelocity(
    const MIntScratchSpace& nearestBodies, const MFloatScratchSpace& nearestDist, MFloat* vel, MFloat* velGrad,
    MFloat* rotation, const vector<MFloat>& setup, MInt* skipBodies, MFloat* meanBodyState, MFloat* pressure,
    MFloat* velDt, MFloat* rotationDt, MFloat* nearestFac) {
  TRACE();

  if(m_noEmbeddedBodies == 0) return;

  const MFloat minDist = (setup.size() >= 1 ? setup[0] : 0.5) * m_bodyDiameter[0];
  const MFloat maxDist = (setup.size() >= 2 ? setup[1] : 4.0) * m_bodyDiameter[0];
  const MFloat maxAngleVel = (setup.size() >= 3 ? setup[2] : F0);
  const MFloat maxAngleRot = (setup.size() >= 4 ? setup[3] : F0);
  const MFloat sigma = (setup.size() >= 5 ? setup[2] : (maxDist - minDist) / 6.0);
  const MFloat D0 = (setup.size() >= 6 ? setup[3] : (maxDist + minDist) / F2); // distance for peak weight

  if(minDist > maxDist || maxAngleVel < -F1 || maxAngleRot < -F1) {
    cerr << "computeNearBodyFluidVelocity: wrong setup " << endl;
    return;
  }

  for(MInt b = 0; b < m_noEmbeddedBodies; b++) {
    for(MInt i = 0; i < nDim; i++) {
      vel[b * nDim + i] = F0;
      rotation[b * nDim + i] = F0;
      for(MInt j = 0; j < nDim; j++) {
        velGrad[b * nDim * nDim + i * nDim + j] = F0;
      }
    }
  }

  if(nearestFac != NULL) {
    std::fill_n(nearestFac, m_maxNearestBodies * a_noCells(), F0);
  }

  MFloatScratchSpace weights(m_noEmbeddedBodies, AT_, "weights");
  MFloatScratchSpace vel0((velDt || rotationDt || meanBodyState) ? m_noEmbeddedBodies : 1, nDim, AT_, "vel0");
  weights.fill(F0);
  vel0.fill(F0);

  vector<vector<MInt>> velCells(m_noEmbeddedBodies);
  vector<vector<MInt>> rotCells(m_noEmbeddedBodies);
  MInt noLeafCells = 0;
  MIntScratchSpace leafCells(a_noCells(), AT_, "leafCells");
  MIntScratchSpace skipBody(m_noEmbeddedBodies, AT_, "skipBody");

  {
    MInt cnt1 = 0;
    MInt cnt2 = 0;
    for(MInt bodyId = 0; bodyId < m_noEmbeddedBodies; bodyId++) {
      skipBody(bodyId) = 0;
      MFloat hydroForceAbs = F0;
      for(MInt i = 0; i < nDim; i++) {
        hydroForceAbs += POW2(m_hydroForce[bodyId * nDim + i]);
      }
      if(hydroForceAbs < 1e-12) {
        skipBody(bodyId) = 1;
        cnt1++;
      }
      if(m_bodyInCollision[bodyId] > 0) {
        skipBody(bodyId) = 1;
        cnt2++;
      }
    }
    m_log << "computeNearBodyFluidVelocities: noBodies skipped (small Body force): " << cnt1 << " collision: " << cnt2
          << " " << minDist / m_bodyDiameter[0] << " " << maxDist / m_bodyDiameter[0] << " " << maxAngleVel << endl;
  }

  MLong smallGradPhi = 0;
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    if(a_isBndryGhostCell(cellId)) continue;
    if(!a_hasProperty(cellId, SolverCell::IsSplitChild) && c_noChildren(cellId) > 0) continue;
    if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;
    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(a_hasProperty(cellId, SolverCell::IsSplitChild) ? a_hasProperty(getAssociatedInternalCell(cellId), Cell::IsHalo)
                                                       : a_hasProperty(cellId, Cell::IsHalo))
      continue;
    if(a_hasProperty(cellId, SolverCell::IsSplitChild) ? a_isPeriodic(getAssociatedInternalCell(cellId))
                                                       : a_isPeriodic(cellId))
      continue;
    leafCells(noLeafCells++) = cellId;
    for(MInt nb = 0; nb < m_maxNearestBodies; nb++) {
      const MInt bodyId0 = nearestBodies[m_maxNearestBodies * cellId + nb];
      if(bodyId0 < 0) continue;
      const MInt bodyId = m_internalBodyId[bodyId0];
      if(skipBody(bodyId)) continue;
      const MFloat phi = nearestDist[m_maxNearestBodies * cellId + nb];
      if(phi > minDist && phi < maxDist) {
        MFloat gradPhi[3] = {F0, F0, F0};
        if(a_hasProperty(cellId, SolverCell::IsSplitChild)) {
          cerr << "debug state splitChild in CNBFV 1"
               << " remove this message, if it was reached and everything went fine" << endl;
          MInt splitChildBndryId = a_bndryId(cellId);
          if(m_bndryCells->a[splitChildBndryId].m_noSrfcs > 1)
            cerr << "SplitChilds due to collision should not appear here." << endl;
          for(MInt i = 0; i < nDim; i++) {
            gradPhi[i] = m_fvBndryCnd->m_bndryCells->a[splitChildBndryId].m_srfcs[0]->m_normalVector[i];
          }
        } else {
          for(MInt i = 0; i < nDim; i++) {
            MInt n0 = (a_hasNeighbor(cellId, 2 * i, false) > 0) ? c_neighborId(cellId, 2 * i, false) : cellId;
            MInt n1 = (a_hasNeighbor(cellId, 2 * i + 1, false) > 0) ? c_neighborId(cellId, 2 * i + 1, false) : cellId;
            if(n0 > -1 && n1 > -1) {
              MInt nb0, nb1;
              for(nb0 = 0; nb0 < m_maxNearestBodies; nb0++) {
                if(nearestBodies[m_maxNearestBodies * n0 + nb0] == bodyId0) break;
              }
              for(nb1 = 0; nb1 < m_maxNearestBodies; nb1++) {
                if(nearestBodies[m_maxNearestBodies * n1 + nb1] == bodyId0) break;
              }
              if(nb0 < m_maxNearestBodies && nb1 < m_maxNearestBodies) {
                gradPhi[i] = (nearestDist[m_maxNearestBodies * n1 + nb1] - nearestDist[m_maxNearestBodies * n0 + nb0])
                             / (a_coordinate(n1, i) - a_coordinate(n0, i));
              }
            }
          }
        }
        MFloat distDotVelGuess = F0;
        MFloat gradPhiAbs = F0;
        MFloat hydroForceAbs = F0;
        for(MInt i = 0; i < nDim; i++) {
          distDotVelGuess += gradPhi[i] * m_hydroForce[bodyId * nDim + i];
          gradPhiAbs += POW2(gradPhi[i]);
          hydroForceAbs += POW2(m_hydroForce[bodyId * nDim + i]);
        }
        if(gradPhiAbs < 1e-12) {
          smallGradPhi++;
          continue;
        }
        MFloat angle = distDotVelGuess / sqrt(gradPhiAbs * hydroForceAbs);
        if(angle < maxAngleVel) {
          MFloat velWeight = a_cellVolume(cellId);
          MFloat distanceBasedWeight = F1 / sqrt(F2 * PI * POW2(sigma)) * exp(-POW2(phi - D0) / (F2 * POW2(sigma)));
          velWeight *= distanceBasedWeight;
          weights(bodyId) += velWeight;
          for(MInt i = 0; i < nDim; i++) {
            vel[bodyId * nDim + i] += velWeight * a_pvariable(cellId, PV->VV[i]);
          }
          if(nearestFac != NULL) {
            nearestFac[m_maxNearestBodies * cellId + nb] += velWeight;
          }
          velCells[bodyId].push_back(cellId);
          if(velDt || rotationDt || meanBodyState) {
            for(MInt i = 0; i < nDim; i++) {
              vel0(bodyId, i) += velWeight * a_oldVariable(cellId, CV->RHO_VV[i]) / a_oldVariable(cellId, CV->RHO);
            }
          }
        }
        if(distDotVelGuess / sqrt(gradPhiAbs * hydroForceAbs) < maxAngleRot) {
          rotCells[bodyId].push_back(cellId);
        }
      }
    }
  }

  MLong globalSmallGradPhi = 0;
  MPI_Reduce(&smallGradPhi, &globalSmallGradPhi, 1, MPI_LONG, MPI_SUM, 0, mpiComm(), AT_, "smallGradPhi",
             "globalSmallGradPhi");
  if(globalSmallGradPhi > 0) {
    m_log << "Skipping cells for nearBodyFluidVelocities (small gradPhi) " << globalSmallGradPhi << " "
          << minDist / m_bodyDiameter[0] << " " << maxDist / m_bodyDiameter[0] << " " << maxAngleVel << endl;
  }

  MPI_Allreduce(MPI_IN_PLACE, &vel[0], nDim * m_noEmbeddedBodies, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "vel[0]");
  MPI_Allreduce(MPI_IN_PLACE, &weights[0], m_noEmbeddedBodies, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "weights[0]");

  if(velDt || rotationDt || meanBodyState) {
    MPI_Allreduce(MPI_IN_PLACE, &vel0[0], nDim * m_noEmbeddedBodies, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_,
                  "MPI_IN_PLACE", "vel0[0]");
  }

  for(MInt b = 0; b < m_noEmbeddedBodies; b++) {
    if((weights(b) < 1e-10) && !skipBody(b)) {
      if(domainId() == 0)
        cerr << setprecision(12) << "Warning: near body velocity interpolation " << b << " " << weights(b) << " "
             << minDist / m_bodyDiameter[0] << " " << maxDist / m_bodyDiameter[0] << " " << maxAngleVel << endl;
      skipBody(b) = 1;
    }
    for(MInt i = 0; i < nDim; i++) {
      vel[b * nDim + i] /= mMax(1e-10, weights(b));
      if(velDt || rotationDt || meanBodyState) vel0(b, i) /= mMax(1e-10, weights(b));
    }
  }
  if(velDt) {
    for(MInt b = 0; b < m_noEmbeddedBodies; b++) {
      for(MInt i = 0; i < nDim; i++) {
        velDt[b * nDim + i] = vel0(b, i);
      }
    }
  }

  if(nearestFac != NULL) {
    for(MInt c = 0; c < noLeafCells; c++) {
      MInt cellId = leafCells(c);
      for(MInt nb = 0; nb < m_maxNearestBodies; nb++) {
        const MInt bodyId0 = nearestBodies[m_maxNearestBodies * cellId + nb];
        if(bodyId0 < 0) continue;
        const MInt bodyId = m_internalBodyId[bodyId0];
        nearestFac[m_maxNearestBodies * cellId + nb] /= weights(bodyId);
      }
    }
  }

  weights.fill(F0);
  for(MInt bodyId = 0; bodyId < m_noEmbeddedBodies; bodyId++) {
    for(auto const& cellId : rotCells[bodyId]) {
      MInt bodyId0 = -1;
      MFloat phi = F0;
      for(MInt nb = 0; nb < m_maxNearestBodies; nb++) {
        if(nearestBodies[m_maxNearestBodies * cellId + nb] > -1
           && m_internalBodyId[nearestBodies[m_maxNearestBodies * cellId + nb]] == bodyId) {
          bodyId0 = nearestBodies[m_maxNearestBodies * cellId + nb];
          phi = nearestDist[m_maxNearestBodies * cellId + nb];
          if(bodyId0 < 0)
            cerr << "bodyId not found " << bodyId0 << " bodyId " << bodyId << " domainId() " << domainId() << endl;
          MFloat gradPhi[3] = {F0, F0, F0};
          if(a_hasProperty(cellId, SolverCell::IsSplitChild)) {
            cerr << "debug state splitChild in CNBFV 2"
                 << " remove this message, if it was reached and everything went fine" << endl;
            MInt splitChildBndryId = a_bndryId(cellId);
            if(m_bndryCells->a[splitChildBndryId].m_noSrfcs > 1)
              cerr << "SplitChilds due to collision should not appear here." << endl;
            for(MInt i = 0; i < nDim; i++) {
              gradPhi[i] = m_fvBndryCnd->m_bndryCells->a[splitChildBndryId].m_srfcs[0]->m_normalVector[i];
            }
          } else {
            for(MInt i = 0; i < nDim; i++) {
              MInt n0 = (a_hasNeighbor(cellId, 2 * i, false) > 0) ? c_neighborId(cellId, 2 * i, false) : cellId;
              MInt n1 = (a_hasNeighbor(cellId, 2 * i + 1, false) > 0) ? c_neighborId(cellId, 2 * i + 1, false) : cellId;
              if(n0 == n1) cerr << "wrong neighbors" << endl;
              if(n0 > -1 && n1 > -1) {
                MInt nb0, nb1;
                for(nb0 = 0; nb0 < m_maxNearestBodies; nb0++) {
                  if(nearestBodies[m_maxNearestBodies * n0 + nb0] == bodyId0) break;
                }
                for(nb1 = 0; nb1 < m_maxNearestBodies; nb1++) {
                  if(nearestBodies[m_maxNearestBodies * n1 + nb1] == bodyId0) break;
                }
                if(nb0 < m_maxNearestBodies && nb1 < m_maxNearestBodies) {
                  gradPhi[i] = (nearestDist[m_maxNearestBodies * n1 + nb1] - nearestDist[m_maxNearestBodies * n0 + nb0])
                               / (a_coordinate(n1, i) - a_coordinate(n0, i));
                }
              }
            }
          }

          MFloat gradPhiAbs = F0;
          for(MInt i = 0; i < nDim; i++) {
            gradPhiAbs += POW2(gradPhi[i]);
          }
          if(gradPhiAbs < 1e-12) {
            continue;
          }
          MFloat rot[3]{};
          MFloat rot0[3]{};
          MFloat rad[3]{};
          MFloat rad0[3]{};
          MFloat vpr[3]{};
          MFloat vpr0[3]{};
          MFloat r2 = F0;
          MFloat r20 = F0;
          MFloat rotWeight = a_cellVolume(cellId);
          MFloat distanceBasedWeight = F1 / sqrt(F2 * PI * POW2(sigma)) * exp(-POW2(phi - D0) / (F2 * POW2(sigma)));
          rotWeight *= distanceBasedWeight;
          for(MInt i = 0; i < nDim; i++) {
            rad[i] = a_coordinate(cellId, i) - m_bodyCenter[bodyId0 * nDim + i];
            vpr[i] = a_pvariable(cellId, PV->VV[i]) - vel[bodyId * nDim + i];
            r2 += POW2(rad[i]);
            for(MInt j = 0; j < nDim; j++) {
              velGrad[bodyId * nDim * nDim + i * nDim + j] += rotWeight * a_slope(cellId, PV->VV[i], j);
            }
          }
          crossProduct(rot, rad, vpr);
          for(MInt i = 0; i < nDim; i++) {
            rotation[bodyId * nDim + i] += rotWeight * rot[i] / r2;
          }
          if(velDt || rotationDt || meanBodyState) {
            for(MInt i = 0; i < nDim; i++) {
              rad0[i] = a_coordinate(cellId, i)
                        - (m_bodyCenter[bodyId0 * nDim + i] + m_bodyCenterDt1[bodyId * nDim + i]
                           - m_bodyCenter[bodyId * nDim + i]);
              vpr0[i] = a_oldVariable(cellId, CV->RHO_VV[i]) / a_oldVariable(cellId, CV->RHO) - vel0(bodyId, i);
              r20 += POW2(rad0[i]);
            }
            crossProduct(rot0, rad0, vpr0);
          }
          if(rotationDt) {
            for(MInt i = 0; i < nDim; i++) {
              rotationDt[bodyId * nDim + i] += rotWeight * (rot0[i] / r20);
            }
          }
          weights(bodyId) += rotWeight;
        }
      }
    }
  }

  MPI_Allreduce(MPI_IN_PLACE, &weights[0], m_noEmbeddedBodies, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "weights[0]");
  MPI_Allreduce(MPI_IN_PLACE, &velGrad[0], nDim * nDim * m_noEmbeddedBodies, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_,
                "MPI_IN_PLACE", "velGrad[0]");
  MPI_Allreduce(MPI_IN_PLACE, &rotation[0], nDim * m_noEmbeddedBodies, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_,
                "MPI_IN_PLACE", "rotation[0]");
  if(rotationDt)
    MPI_Allreduce(MPI_IN_PLACE, &rotationDt[0], nDim * m_noEmbeddedBodies, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_,
                  "MPI_IN_PLACE", "rotationDt[0]");

  for(MInt b = 0; b < m_noEmbeddedBodies; b++) {
    if(domainId() == 0 && weights(b) < 1e-10 && !skipBody(b)) {
      cerr << setprecision(12) << "Warning: near body velocity gradient interpolation " << b << " " << weights(b) << " "
           << minDist / m_bodyDiameter[0] << " " << maxDist / m_bodyDiameter[0] << " " << maxAngleRot << endl;
    }
    for(MInt i = 0; i < nDim; i++) {
      rotation[b * nDim + i] /= mMax(1e-10, weights(b));
      for(MInt j = 0; j < nDim; j++) {
        velGrad[b * nDim * nDim + i * nDim + j] /= mMax(1e-10, weights(b));
      }
    }
  }

  if(rotationDt) {
    for(MInt b = 0; b < m_noEmbeddedBodies; b++) {
      for(MInt i = 0; i < nDim; i++) {
        rotationDt[b * nDim + i] /= mMax(1e-10, weights(b));
      }
    }
  }

  if(meanBodyState && pressure) {
    const MInt noNearBodyState = 5;
    weights.fill(F0);
    for(MInt b = 0; b < m_noEmbeddedBodies; b++) {
      pressure[b] = F0;
      for(MInt i = 0; i < noNearBodyState; i++) {
        meanBodyState[noNearBodyState * b + i] = F0;
      }
    }

    for(MInt c = 0; c < noLeafCells; c++) {
      MInt cellId = leafCells(c);
      for(MInt nb = 0; nb < m_maxNearestBodies; nb++) {
        const MInt bodyId0 = nearestBodies[m_maxNearestBodies * cellId + nb];
        if(bodyId0 < 0) continue;
        const MInt bodyId = m_internalBodyId[bodyId0];
        // if(skipBody(bodyId)) continue;
        const MFloat phi = nearestDist[m_maxNearestBodies * cellId + nb];
        MFloat weight = a_cellVolume(cellId);
        MFloat distanceBasedWeight = F1 / sqrt(F2 * PI * POW2(sigma)) * exp(-POW2(phi - D0) / (F2 * POW2(sigma)));
        weight *= distanceBasedWeight;
        pressure[bodyId] += weight * a_pvariable(cellId, PV->P);
        weights(bodyId) += weight;
        MFloat eps1 = F0;
        for(MInt i = 0; i < nDim; i++) {
          for(MInt j = 0; j < nDim; j++) {
            eps1 += F1B2 * (sysEqn().m_muInfinity / sysEqn().m_Re0)
                    * POW2(a_slope(cellId, PV->VV[i], j) + a_slope(cellId, PV->VV[j], i));
          }
        }

        if(phi < 0.5 * m_bodyDiameter[bodyId]) meanBodyState[noNearBodyState * bodyId] += a_cellVolume(cellId) * eps1;
        if(phi < 1.0 * m_bodyDiameter[bodyId])
          meanBodyState[noNearBodyState * bodyId + 1] += a_cellVolume(cellId) * eps1;
        if(phi < 1.5 * m_bodyDiameter[bodyId])
          meanBodyState[noNearBodyState * bodyId + 2] += a_cellVolume(cellId) * eps1;
        if(phi < 2.0 * m_bodyDiameter[bodyId])
          meanBodyState[noNearBodyState * bodyId + 3] += a_cellVolume(cellId) * eps1;
        if(phi < 2.5 * m_bodyDiameter[bodyId])
          meanBodyState[noNearBodyState * bodyId + 4] += a_cellVolume(cellId) * eps1;
      }
    }

    MPI_Allreduce(MPI_IN_PLACE, &weights[0], m_noEmbeddedBodies, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "weights[0]");
    MPI_Allreduce(MPI_IN_PLACE, &pressure[0], m_noEmbeddedBodies, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "pressure[0]");
    MPI_Allreduce(MPI_IN_PLACE, &meanBodyState[0], noNearBodyState * m_noEmbeddedBodies, MPI_DOUBLE, MPI_SUM, mpiComm(),
                  AT_, "MPI_IN_PLACE", "meanBodyState[0]");

    for(MInt b = 0; b < m_noEmbeddedBodies; b++) {
      if(domainId() == 0 && weights(b) < 1e-10 && !skipBody(b)) {
        cerr << "Warning: near body pressure interpolation " << b << " " << weights(b) / m_bodyVolume[b] << " "
             << minDist / m_bodyDiameter[0] << " " << maxDist / m_bodyDiameter[0] << " " << maxAngleVel << endl;
      }
      pressure[b] /= mMax(1e-10, weights(b));
    }
  }

  if(skipBodies) {
    MInt cnt = 0;
    for(MInt b = 0; b < m_noEmbeddedBodies; b++) {
      skipBodies[b] = skipBody(b);
      if(skipBody(b)) cnt++;
    }
    if(domainId() == 0 && cnt > 0 && globalTimeStep % m_dragOutputInterval == 0)
      m_log << "computeNearBodyFluidVelocities: noBodies skipped " << cnt << " (" << globalTimeStep << ")" << endl;
  }
}


/** \fn void FvMbCartesianSolverXD<nDim, SysEqn>::writeVtkErrorFile()
 * \brief write flow variables as XML VTK files
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::writeVtkErrorFile() {
  writeVtkXmlFiles("Q_ERR", "G_ERR", 0, 0);
}


/** \fn void FvMbCartesianSolverXD<nDim, SysEqn>::writeVtkXmlFiles()
 * \brief write flow variables as XML VTK files
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::writeVtkXmlFiles(const MString fileName, const MString GFileName,
                                                           MBool regularOutput, MBool diverged) {
  TRACE();

  VtkIo<nDim, SysEqn> VtkIo(this);

  const MBool correctCoords = m_fvBndryCnd->m_cellCoordinatesCorrected;
  if(correctCoords) m_fvBndryCnd->recorrectCellCoordinates();

  if(diverged) {
    m_haloCellOutput = true;
    m_vtuGeometryOutputExtended = true;
    m_vtuGlobalIdOutput = true;
    m_vtuDomainIdOutput = true;
    m_vtuLevelSetOutput = false;
    m_vtuVelocityGradientOutput = true;
  }
  restoreNeighbourLinks();
  IF_CONSTEXPR(nDim == 3) {
    if(true || regularOutput || noDomains() > 24) {
      extractPointIdsFromGrid(m_extractedCells, m_gridPoints, false, m_splitChildToSplitCell, m_vtuLevelThreshold,
                              m_vtuCoordinatesThreshold);
      if(m_vtuLevelThreshold < maxRefinementLevel()) reduceVariables();
      deleteNeighbourLinks();
      MInt noSolverSpecificVars = (m_vtuLevelSetOutput > 0 ? 1 : 0);
      MFloatScratchSpace levelSetOutput((noSolverSpecificVars > 0 ? a_noCells() : 1), AT_, "levelSetOutput");
      if(m_vtuLevelSetOutput) {
        noSolverSpecificVars = 1;
        for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
          levelSetOutput(cellId) = a_levelSetValuesMb(cellId, 0);
        }
      }
      MString fName;
      MString gName;
      if(!m_multipleFvSolver) {
        fName = m_solutionOutput + fileName + "_00" + to_string(globalTimeStep) + ".vtu";
        gName = m_solutionOutput + GFileName + "_00" + to_string(globalTimeStep) + ".vtp";
      } else {
        fName = m_solutionOutput + fileName + "_s" + to_string(solverId()) + "_00" + to_string(globalTimeStep) + ".vtu";
        gName =
            m_solutionOutput + GFileName + "_s" + to_string(solverId()) + "_00" + to_string(globalTimeStep) + ".vtp";
      }
      if(m_solutionDiverged && !m_multipleFvSolver) {
        fName = m_solutionOutput + fileName + "_diverged_00" + to_string(globalTimeStep) + ".vtu";
        gName = m_solutionOutput + GFileName + "_diverged_00" + to_string(globalTimeStep) + ".vtp";
      } else if(m_solutionDiverged) {
        fName = m_solutionOutput + fileName + "_s" + to_string(solverId()) + "_diverged_00" + to_string(globalTimeStep)
                + ".vtu";
        gName = m_solutionOutput + GFileName + "_s" + to_string(solverId()) + "_diverged_00" + to_string(globalTimeStep)
                + ".vtp";
      }
      if(domainId() == 0) {
        cerr << "Writing " << fName << " at time step " << globalTimeStep << "... ";
      }

      VtkIo.writeVtuOutputParallel(fName.c_str(), gName.c_str(), noSolverSpecificVars, levelSetOutput);

      cerr0 << "finished." << endl;
    } else {
      extractPointIdsFromGrid(m_extractedCells, m_gridPoints, true, m_splitChildToSplitCell);
      MString fName = m_solutionOutput + fileName + "_B" + to_string(domainId());
      MString gName = m_solutionOutput + GFileName + "_B" + to_string(domainId());
      if(diverged) fName += "_diverged";
      if(diverged) gName += "_diverged";
      fName += ".vtu";
      gName += ".vtp";
      cerr << endl << "Saving '" << fName << "' at time " << setprecision(6) << m_physicalTime << "...";
      writeVtkXmlOutput(fName.c_str(), (diverged || !regularOutput));
      writeGeometryToVtkXmlFile(gName.c_str());
      cerr << " finished." << endl;
    }
  }
  else {
    extractPointIdsFromGrid(m_extractedCells, m_gridPoints, m_haloCellOutput, m_splitChildToSplitCell);
    deleteNeighbourLinks();

    stringstream QName;
    QName << m_solutionOutput << "solver_data/" << fileName << "_B" << domainId();
    if(regularOutput) QName << "_00" << globalTimeStep;
    if(diverged) QName << "_diverged";
    QName << ".vtu";

    DEBUG_LOG("Rank " << domainId() << " saving '" << QName.str() << "' at time " << setprecision(6) << m_physicalTime
                      << "...");
    if(domainId() == 0)
      cerr << endl << "Saving '" << QName.str() << "' at time " << setprecision(6) << m_physicalTime << "...";

    writeVtkXmlOutput((QName.str()).c_str(), (diverged || !regularOutput));

    DEBUG_LOG(" finished (" << domainId() << ").");
    cerr0 << " finished." << endl;


    MInt noPolygons = 0;
    ScratchSpace<MInt> noPolys2(noDomains(), AT_, "noPolys2");
    MInt* noPolysGlobal = noPolys2.getPointer();
    IF_CONSTEXPR(nDim == 3 && m_vtuWriteGeometryFile) {
      stringstream GName;
      GName << m_solutionOutput << "solver_data/" << GFileName << "_B" << domainId();
      if(regularOutput) GName << "_00" << globalTimeStep;
      if(diverged) GName << "_diverged";
      GName << ".vtp";

      DEBUG_LOG("Rank " << domainId() << " saving '" << GName.str() << "' at time " << setprecision(6) << m_physicalTime
                        << "...");

      noPolygons = writeGeometryToVtkXmlFile(GName.str());

      DEBUG_LOG(" .. finished (" << domainId() << ").");
    }
    if(regularOutput) {
      ScratchSpace<MInt> noPolys(noDomains(), AT_, "noPolys");
      MInt* noPolysLocal = noPolys.getPointer();
      for(MInt c = 0; c < noDomains(); c++) {
        noPolysLocal[c] = 0;
      }
      noPolysLocal[domainId()] = noPolygons;
      MPI_Reduce(noPolysLocal, noPolysGlobal, noDomains(), MPI_INT, MPI_SUM, 0, mpiComm(), AT_, "noPolysLocal",
                 "noPolysGlobal");
    } else {
      noPolysGlobal[0] = noPolygons;
    }


    ScratchSpace<MInt> noLsMbCells(noDomains(), AT_, "noLsMbCells");
    if(noDomains() > 1)
      MPI_Gather(&m_noLsMbBndryCells, 1, MPI_INT, &(noLsMbCells[0]), 1, MPI_INT, 0, mpiComm(), AT_,
                 "m_noLsMbBndryCells", "(noLsMbCells[0])");


    if(domainId() == 0 && regularOutput) {
      //------ QOUT.pvd -------

      if(true) {
        DEBUG_LOG("Writing QOUT.pvd file...");

        MBool& firstCall = m_static_writeVtkXmlFiles_firstCall;
        if(firstCall) {
          if(fileExists("out/QOUT.pvd")) {
            rename("out/QOUT.pvd", "out/QOUT_BU.pvd");
          }
          if(fileExists("out/QOUT.pvd.tmp")) {
            remove("out/QOUT.pvd.tmp");
          }
          ofstream ofile("out/QOUT.pvd.tmp", ios_base::out | ios_base::trunc);
          if(ofile.is_open() && ofile.good()) {
            ofile << "<VTKFile type=\"Collection\" version=\"0.1\" byte_order=\"LittleEndian\">" << endl;
            ofile << "<Collection>" << endl;
            if(m_restart) {
              if(m_solutionTimeSteps.empty()) {
                for(MInt t = m_solutionOffset; t <= globalTimeStep; t += m_solutionInterval) {
                  for(MInt p = 0; p < noDomains(); p++) {
                    stringstream tmp;
                    tmp << "out/solver_data/" << fileName << "_B" << p << "_00" << t << ".vtu";
                    if(fileExists((tmp.str()).c_str())) {
                      ofile << "<DataSet part=\"" << p << "\" timestep=\"" << t << "\" file=\""
                            << "./solver_data/" << fileName << "_B" << p << "_00" << t << ".vtu\"/>" << endl;
                    }
                  }
                }
              } else {
                for(std::set<MInt>::iterator it = m_solutionTimeSteps.begin(); it != m_solutionTimeSteps.end(); it++) {
                  MInt t = *it;
                  for(MInt p = 0; p < noDomains(); p++) {
                    stringstream tmp;
                    tmp << "out/solver_data/" << fileName << "_B" << p << "_00" << t << ".vtu";
                    if(fileExists((tmp.str()).c_str())) {
                      ofile << "<DataSet part=\"" << p << "\" timestep=\"" << t << "\" file=\""
                            << "./solver_data/" << fileName << "_B" << p << "_00" << t << ".vtu\"/>" << endl;
                    }
                  }
                }
              }
            }
            ofile.close();
            ofile.clear();
          } else {
            cerr << "Error opening file out/QOUT.pvd.tmp" << endl;
          }
        }
        if(firstCall) {
          ofstream ofile("out/QOUT_all.pvd", ios_base::out | ios_base::trunc);
          if(ofile.is_open() && ofile.good()) {
            ofile << "<VTKFile type=\"Collection\" version=\"0.1\" byte_order=\"LittleEndian\">" << endl;
            ofile << "<Collection>" << endl;
            if(m_solutionTimeSteps.empty()) {
              MInt t = m_solutionOffset;
              MBool found = true;
              while(found) {
                for(MInt p = 0; p < noDomains(); p++) {
                  stringstream tmp;
                  tmp << "out/solver_data/" << fileName << "_B" << p << "_00" << t << ".vtu";
                  if(fileExists((tmp.str()).c_str())) {
                    ofile << "<DataSet part=\"" << p << "\" timestep=\"" << t << "\" file=\""
                          << "./solver_data/" << fileName << "_B" << p << "_00" << t << ".vtu\"/>" << endl;
                  } else {
                    found = false;
                  }
                }
                t += m_solutionInterval;
              }
            } else {
              std::set<MInt>::iterator it = m_solutionTimeSteps.begin();
              MInt t = *it;
              MBool found = true;
              while(found) {
                for(MInt p = 0; p < noDomains(); p++) {
                  stringstream tmp;
                  tmp << "out/solver_data/" << fileName << "_B" << p << "_00" << t << ".vtu";
                  if(fileExists((tmp.str()).c_str())) {
                    ofile << "<DataSet part=\"" << p << "\" timestep=\"" << t << "\" file=\""
                          << "./solver_data/" << fileName << "_B" << p << "_00" << t << ".vtu\"/>" << endl;
                  } else {
                    found = false;
                  }
                }
                it++;
              }
            }
            ofile << "</Collection>" << endl;
            ofile << "</VTKFile>" << endl;
            ofile.close();
            ofile.clear();
          } else {
            cerr << "Error opening file out/QOUT_all.pvd" << endl;
          }
        }
        ofstream ofile("out/QOUT.pvd.tmp", ios_base::out | ios_base::app);
        if(ofile.is_open() && ofile.good()) {
          for(MInt p = 0; p < noDomains(); p++) {
            ofile << "<DataSet part=\"" << p << "\" timestep=\"" << globalTimeStep << "\" file=\""
                  << "./solver_data/" << fileName << "_B" << p << "_00" << globalTimeStep << ".vtu\"/>" << endl;
          }
          ofile.close();
          ofile.clear();
        } else {
          cerr << "Error opening file out/QOUT.pvd.tmp" << endl;
        }

        if(fileExists("out/QOUT.pvd")) {
          remove("out/QOUT.pvd");
        }
        copyFile("out/QOUT.pvd.tmp", "out/QOUT.pvd");
        ofstream ofile2("out/QOUT.pvd", ios_base::out | ios_base::app);
        if(ofile2.is_open() && ofile2.good()) {
          ofile2 << "</Collection>" << endl;
          ofile2 << "</VTKFile>" << endl;
          ofile2.close();
        } else {
          cerr << "Error opening file out/QOUT.pvd" << endl;
        }
        firstCall = false;

        DEBUG_LOG("finished.");
      }


      //------ GEOM.pvd -------

      IF_CONSTEXPR(nDim == 3 && m_vtuWriteGeometryFile) {
        DEBUG_LOG("Writing GEOM.pvd file...");

        MBool& firstCall2 = m_static_writeVtkXmlFiles_firstCall2;
        if(firstCall2) {
          if(fileExists("out/GEOM.pvd")) {
            rename("out/GEOM.pvd", "out/GEOM_BU.pvd");
          }
          if(fileExists("out/GEOM.pvd.tmp")) {
            remove("out/GEOM.pvd.tmp");
          }
          ofstream ofile("out/GEOM.pvd.tmp", ios_base::out | ios_base::trunc);
          if(ofile.is_open() && ofile.good()) {
            ofile << "<VTKFile type=\"Collection\" version=\"0.1\" byte_order=\"LittleEndian\">" << endl;
            ofile << "<Collection>" << endl;
            if(m_restart) {
              if(m_solutionTimeSteps.empty()) {
                for(MInt t = m_solutionOffset; t <= globalTimeStep; t += m_solutionInterval) {
                  MInt cnt = 0;
                  for(MInt p = 0; p < noDomains(); p++) {
                    stringstream fn;
                    fn << "out/solver_data/" << GFileName << "_B" << p << "_00" << t;
                    if(fileExists((fn.str()).c_str())) {
                      ofile << "<DataSet part=\"" << cnt << "\" group=\"\" timestep=\"" << t << "\" file=\""
                            << "./solver_data/" << GFileName << "_B" << p << "_00" << t << ".vtp\"/>" << endl;
                      cnt++;
                    }
                  }
                }
              } else {
                for(std::set<MInt>::iterator it = m_solutionTimeSteps.begin(); it != m_solutionTimeSteps.end(); it++) {
                  MInt t = *it;
                  MInt cnt = 0;
                  for(MInt p = 0; p < noDomains(); p++) {
                    stringstream fn;
                    fn << "out/solver_data/" << GFileName << "_B" << p << "_00" << t;
                    if(fileExists((fn.str()).c_str())) {
                      ofile << "<DataSet part=\"" << cnt << "\" group=\"\" timestep=\"" << t << "\" file=\""
                            << "./solver_data/" << GFileName << "_B" << p << "_00" << t << ".vtp\"/>" << endl;
                      cnt++;
                    }
                  }
                }
              }
            }
            ofile.close();
            ofile.clear();
          } else {
            cerr << "Error opening file out/GEOM.pvd.tmp" << endl;
          }
        }
        if(firstCall2) {
          ofstream ofile("out/GEOM_all.pvd", ios_base::out | ios_base::trunc);
          if(ofile.is_open() && ofile.good()) {
            ofile << "<VTKFile type=\"Collection\" version=\"0.1\" byte_order=\"LittleEndian\">" << endl;
            ofile << "<Collection>" << endl;
            if(m_solutionTimeSteps.empty()) {
              MInt t = m_solutionOffset;
              MBool found = true;
              while(found) {
                MInt cnt = 0;
                for(MInt p = 0; p < noDomains(); p++) {
                  stringstream fn;
                  fn << "out/solver_data/" << GFileName << "_B" << p << "_00" << t << ".vtp";
                  if(fileExists((fn.str()).c_str())) {
                    ofile << "<DataSet part=\"" << cnt << "\" group=\"\" timestep=\"" << t << "\" file=\""
                          << "./solver_data/" << GFileName << "_B" << p << "_00" << t << ".vtp\"/>" << endl;
                    cnt++;
                  }
                }
                if(cnt == 0) {
                  found = false;
                }
                t += m_solutionInterval;
              }
            } else {
              std::set<MInt>::iterator it = m_solutionTimeSteps.begin();
              MInt t = *it;
              MBool found = true;
              while(found) {
                MInt cnt = 0;
                for(MInt p = 0; p < noDomains(); p++) {
                  stringstream fn;
                  fn << "out/solver_data/" << GFileName << "_B" << p << "_00" << t << ".vtp";
                  if(fileExists((fn.str()).c_str())) {
                    ofile << "<DataSet part=\"" << cnt << "\" group=\"\" timestep=\"" << t << "\" file=\""
                          << "./solver_data/" << GFileName << "_B" << p << "_00" << t << ".vtp\"/>" << endl;
                    cnt++;
                  }
                }
                if(cnt == 0) {
                  found = false;
                }
                it++;
              }
            }
            ofile << "</Collection>" << endl;
            ofile << "</VTKFile>" << endl;
            ofile.close();
            ofile.clear();
          } else {
            cerr << "Error opening file out/GEOM_all.pvd" << endl;
          }
        }
        ofstream ofile("out/GEOM.pvd.tmp", ios_base::out | ios_base::app);
        if(ofile.is_open() && ofile.good()) {
          MInt cnt = 0;
          for(MInt p = 0; p < noDomains(); p++) {
            if(noPolysGlobal[p] > 0) {
              ofile << "<DataSet part=\"" << cnt << "\" group=\"\" timestep=\"" << globalTimeStep << "\" file=\""
                    << "./solver_data/" << GFileName << "_B" << p << "_00" << globalTimeStep << ".vtp\"/>" << endl;
              cnt++;
            }
          }
          ofile.close();
          ofile.clear();
        } else {
          cerr << "Error opening file out/GEOM.pvd.tmp" << endl;
        }

        if(fileExists("out/GEOM.pvd")) {
          remove("out/GEOM.pvd");
        }
        copyFile("out/GEOM.pvd.tmp", "out/GEOM.pvd");
        ofstream ofile2("out/GEOM.pvd", ios_base::out | ios_base::app);
        if(ofile2.is_open() && ofile2.good()) {
          ofile2 << "</Collection>" << endl;
          ofile2 << "</VTKFile>" << endl;
          ofile2.close();
        } else {
          cerr << "Error opening file out/GEOM.pvd" << endl;
        }
        firstCall2 = false;

        DEBUG_LOG("finished.");
      }
    }


    if(domainId() == 0 && diverged) {
      // QOUT_diverged.pvd
      if(fileExists("out/QOUT_diverged.pvd")) {
        remove("out/QOUT_diverged.pvd");
      }
      ofstream ofile("out/QOUT_diverged.pvd", ios_base::out | ios_base::trunc);
      if(ofile.is_open() && ofile.good()) {
        ofile << "<VTKFile type=\"Collection\" version=\"0.1\" byte_order=\"LittleEndian\">" << endl;
        ofile << "<Collection>" << endl;
        for(MInt p = 0; p < noDomains(); p++) {
          stringstream tmp;
          tmp << "out/solver_data/" << fileName << "_B" << p << "_diverged.vtu";
          if(fileExists((tmp.str()).c_str())) {
            ofile << "<DataSet part=\"" << p << "\" timestep=\"" << globalTimeStep << "\" file=\""
                  << "./solver_data/" << fileName << "_B" << p << "_diverged.vtu\"/>" << endl;
          }
        }
        ofile << "</Collection>" << endl;
        ofile << "</VTKFile>" << endl;
        ofile.close();
        ofile.clear();
      } else {
        cerr << "Error opening file out/QOUT_diverged.pvd" << endl;
      }


      // GEOM_diverged.pvd
      if(fileExists("out/GEOM_diverged.pvd")) {
        remove("out/GEOM_diverged.pvd");
      }
      ofstream ofile2("out/GEOM_diverged.pvd", ios_base::out | ios_base::trunc);
      if(ofile2.is_open() && ofile2.good()) {
        ofile2 << "<VTKFile type=\"Collection\" version=\"0.1\" byte_order=\"LittleEndian\">" << endl;
        ofile2 << "<Collection>" << endl;
        for(MInt p = 0; p < noDomains(); p++) {
          if(noLsMbCells(p) > 0) {
            ofile2 << "<DataSet part=\"" << p << "\" timestep=\"" << globalTimeStep << "\" file=\""
                   << "./solver_data/" << GFileName << "_B" << p << "_diverged.vtp\"/>" << endl;
          }
        }
        ofile2 << "</Collection>" << endl;
        ofile2 << "</VTKFile>" << endl;
        ofile2.close();
        ofile2.clear();
      } else {
        cerr << "Error opening file out/GEOM_diverged.pvd" << endl;
      }
    }
  }

  if(correctCoords) m_fvBndryCnd->rerecorrectCellCoordinates();


  if(m_extractedCells) {
    delete m_extractedCells;
    m_extractedCells = nullptr;
  }
  if(m_gridPoints) {
    delete m_gridPoints;
    m_gridPoints = nullptr;
  }

  if(diverged) {
    const MInt noBytes = maxNoGridCells() * m_noCVars * sizeof(MFloat);
    MFloat* RESTRICT cVars = (MFloat*)(&(a_variable(0, 0)));
    MFloat* RESTRICT oCVars = (MFloat*)(&(a_oldVariable(0, 0)));
    memcpy(cVars, oCVars, noBytes);
    computePrimitiveVariables();
    cerr0 << "deactivate m_useNonSpecifiedRestartFile" << endl;
    m_useNonSpecifiedRestartFile = false;
    if((globalTimeStep % m_restartInterval) != 0 && globalTimeStep != m_restartTimeStep) {
      saveRestartFile(false);
    }
  }


  // point particle output
  if(m_noPointParticles > 0 && m_noPointParticles < 1000000) {
    MFloatScratchSpace partCoord(m_noPointParticles, nDim, AT_, "partCoord");
    MFloatScratchSpace partVel(m_noPointParticles, nDim, AT_, "partVel");
    MFloatScratchSpace partVelFluid(m_noPointParticles, nDim, AT_, "partVelFluid");
    MFloatScratchSpace partRadii(m_noPointParticles, nDim, AT_, "partVevRadii");
    MIntScratchSpace noPartData(noDomains(), AT_, "noPartData");
    MIntScratchSpace partDataOffsets(noDomains(), AT_, "partDataOffsets");
    noPartData(domainId()) = nDim * m_noPointParticlesLocal;
    MPI_Allreduce(MPI_IN_PLACE, &noPartData[0], noDomains(), MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "noPartData[0]");
    partDataOffsets[0] = 0;
    for(MInt i = 1; i < noDomains(); i++)
      partDataOffsets[i] = partDataOffsets[i - 1] + noPartData[i - 1];
    MPI_Gatherv(&m_particleCoords[0], noPartData(domainId()), MPI_DOUBLE, &partCoord[0], &noPartData[0],
                &partDataOffsets[0], MPI_DOUBLE, 0, mpiComm(), AT_, "m_particleCoords[0]", "partCoord[0]");
    MPI_Gatherv(&m_particleVelocity[0], noPartData(domainId()), MPI_DOUBLE, &partVel[0], &noPartData[0],
                &partDataOffsets[0], MPI_DOUBLE, 0, mpiComm(), AT_, "m_particleVelocity[0]", "partVel[0]");
    MPI_Gatherv(&m_particleVelocityFluid[0], noPartData(domainId()), MPI_DOUBLE, &partVelFluid[0], &noPartData[0],
                &partDataOffsets[0], MPI_DOUBLE, 0, mpiComm(), AT_, "m_particleVelocityFluid[0]", "partVelFluid[0]");
    MPI_Gatherv(&m_particleRadii[0], noPartData(domainId()), MPI_DOUBLE, &partRadii[0], &noPartData[0],
                &partDataOffsets[0], MPI_DOUBLE, 0, mpiComm(), AT_, "m_particleRadii[0]", "partRadii[0]");

    if(domainId() == 0) {
      typedef uint32_t uint_t;
      const char* const uIDataType = (std::is_same<uint_t, uint64_t>::value) ? "UInt64" : "UInt32";
      const char* const dataType = "Float32";
      ofstream ofl;
      const MString partFileName = m_solutionOutput + "PPOUT_00" + to_string(globalTimeStep) + ".vtp";
      ofl.open(partFileName.c_str(), ios_base::out | ios_base::trunc);
      if(ofl.is_open() && ofl.good()) {
        // VTKFile
        ofl << "<?xml version=\"1.0\"?>" << endl;
        ofl << "<VTKFile type=\"PolyData\" version=\"1.0\" byte_order=\"LittleEndian\" header_type=\"UInt64\">" << endl;
        ofl << "<PolyData>" << endl;

        // FieldData
        ofl << "<FieldData>" << endl;
        ofl << "<DataArray type=\"" << uIDataType
            << "\" Name=\"globalTimeStep\" format=\"ascii\" NumberOfTuples=\"1\" > " << globalTimeStep
            << " </DataArray>" << endl;
        ofl << "<DataArray type=\"" << dataType << "\" Name=\"time\" format=\"ascii\" NumberOfTuples=\"1\" > " << m_time
            << " </DataArray>" << endl;
        ofl << "<DataArray type=\"" << dataType << "\" Name=\"physicalTime\" format=\"ascii\" NumberOfTuples=\"1\" > "
            << m_physicalTime << " </DataArray>" << endl;
        ofl << "</FieldData>" << endl;

        // Dimensions
        ofl << "<Piece NumberOfPoints=\"" << m_noPointParticles << "\" NumberOfVerts=\"" << m_noPointParticles << "\">"
            << endl;

        //  Points
        ofl << "<Points>" << endl;
        ofl << setprecision(12);
        ofl << "<DataArray type=\"" << dataType << "\" NumberOfComponents=\"3\" format=\"ascii\">" << endl;
        for(MInt k = 0; k < m_noPointParticles; k++) {
          for(MInt i = 0; i < nDim; i++) {
            ofl << partCoord(k, i) << " ";
          }
          ofl << endl;
        }
        ofl << "</DataArray>" << endl;
        ofl << "</Points>" << endl;

        // Verts
        ofl << "<Verts>" << endl;
        ofl << "<DataArray type=\"" << uIDataType << "\" Name=\"connectivity\" format=\"ascii\">" << endl;
        for(MInt k = 0; k < m_noPointParticles; k++) {
          ofl << k << " ";
        }
        ofl << endl;
        ofl << "</DataArray>" << endl;
        ofl << "<DataArray type=\"" << uIDataType << "\" Name=\"offsets\" format=\"ascii\">" << endl;
        for(MInt k = 0; k < m_noPointParticles; k++) {
          ofl << k + 1 << " ";
        }
        ofl << endl;
        ofl << "</DataArray>" << endl;
        ofl << "</Verts>" << endl;

        // PointData
        ofl << "<PointData Scalars=\"scalars\">" << endl;
        ofl << "<DataArray type=\"" << dataType << "\" Name=\"velocity\" NumberOfComponents=\"3\" format=\"ascii\">"
            << endl;
        for(MInt k = 0; k < m_noPointParticles; k++) {
          for(MInt i = 0; i < nDim; i++) {
            ofl << partVel(k, i) << " ";
          }
          ofl << endl;
        }
        ofl << "</DataArray>" << endl;
        ofl << "<DataArray type=\"" << dataType << "\" Name=\"Re_p\" NumberOfComponents=\"1\" format=\"ascii\">"
            << endl;
        for(MInt k = 0; k < m_noPointParticles; k++) {
          MFloat diameter = F2 * pow(partRadii[3 * k] * partRadii[3 * k + 1] * partRadii[3 * k + 2], F1B3);
          MFloat Rep = F0;
          for(MInt i = 0; i < nDim; i++) {
            Rep += POW2(partVelFluid(k, i) - partVel(k, i));
          }
          Rep = sqrt(Rep) * diameter * m_rhoInfinity * sysEqn().m_Re0 / sysEqn().m_muInfinity;
          ofl << Rep << " ";
        }
        ofl << endl;
        ofl << "</DataArray>" << endl;
        ofl << "</PointData>" << endl;

        ofl << "</Piece>" << endl;
        ofl << "</PolyData>" << endl;
        ofl << "</VTKFile>" << endl;
        ofl.close();
        ofl.clear();
      } else {
        cerr << "ERROR! COULD NOT OPEN FILE " << partFileName << " for writing! (1)" << endl;
      }
    }
  }
}


/** void FvMbCartesianSolverXD<nDim, SysEqn>::readStlFile()
 * \brief read specified STL file
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::readStlFile(const MChar* fileName, MBool readNormals) {
  TRACE();

  string line;
  ifstream ifile;
  MBool isBinary = false;
  MFloat a[3];
  MFloat b[3];
  MFloat c[3];
  MInt noPoints;
  char cstr[100];
  string token;
  m_noSurfacePointSamples = 0;
  noPoints = 0;

  if(!fileExists(fileName)) {
    stringstream errorMessage;
    errorMessage << "Error: Unable to find file " << fileName << ". Quit." << endl;
    mTerm(1, AT_, errorMessage.str());
  } else if(isBinary) {
    cerr << "lacking binary stl code" << endl;
  } else {
    ifile.open(fileName);
    if(ifile.is_open()) {
      cerr << "Reading " << fileName << "... ";

      getline(ifile, line);
      strcpy(cstr, line.c_str());
      token = strtok(cstr, " ");
      if(token.compare(0, 5, "solid", 0, 5) != 0) {
        stringstream errorMessage;
        errorMessage << "Error 1 reading " << fileName << ". Quit." << endl;
        mTerm(1, AT_, errorMessage.str());
      }
      while(ifile.good()) {
        getline(ifile, line);
        if(line == "") continue;
        strcpy(cstr, line.c_str());
        token = strtok(cstr, " ");
        if(token.compare(0, 5, "facet", 0, 5) == 0) {
          if(noPoints >= m_maxNoSurfacePointSamples) {
            mTerm(1, AT_, "Increase m_maxNoSurfacePointSamples. Quit.");
          }

          // 1. obtain normals
          token = strtok(nullptr, " ");
          if(token.compare(0, 5, "normal", 0, 5) != 0) {
            stringstream errorMessage;
            errorMessage << "Error 2 reading " << fileName << ". Quit." << endl;
            mTerm(1, AT_, errorMessage.str());
          }
          if(readNormals) {
            token = strtok(nullptr, " ");
            m_sampleNormals[3 * noPoints] = atof(token.c_str());
            token = strtok(nullptr, " ");
            m_sampleNormals[3 * noPoints + 1] = atof(token.c_str());
            token = strtok(nullptr, " ");
            m_sampleNormals[3 * noPoints + 2] = atof(token.c_str());
          }

          // skip "outer loop"
          getline(ifile, line);

          // 2a. obtain point a
          getline(ifile, line);
          strcpy(cstr, line.c_str());
          token = strtok(cstr, " ");
          if(token.compare(0, 6, "vertex", 0, 6) != 0) {
            stringstream errorMessage;
            errorMessage << "Error 3 reading " << fileName << ". Quit." << endl;
            mTerm(1, AT_, errorMessage.str());
          }
          token = strtok(nullptr, " ");
          a[0] = atof(token.c_str());
          token = strtok(nullptr, " ");
          a[1] = atof(token.c_str());
          token = strtok(nullptr, " ");
          a[2] = atof(token.c_str());

          // 2b. obtain point b
          getline(ifile, line);
          strcpy(cstr, line.c_str());
          token = strtok(cstr, " ");
          if(token.compare(0, 6, "vertex", 0, 6) != 0) {
            stringstream errorMessage;
            errorMessage << "Error 4 reading " << fileName << ". Quit." << endl;
            mTerm(1, AT_, errorMessage.str());
          }
          token = strtok(nullptr, " ");
          b[0] = atof(token.c_str());
          token = strtok(nullptr, " ");
          b[1] = atof(token.c_str());
          token = strtok(nullptr, " ");
          b[2] = atof(token.c_str());

          // 2c. obtain point c
          getline(ifile, line);
          strcpy(cstr, line.c_str());
          token = strtok(cstr, " ");
          if(token.compare(0, 6, "vertex", 0, 6) != 0) {
            stringstream errorMessage;
            errorMessage << "Error 5 reading " << fileName << ". Quit." << endl;
            mTerm(1, AT_, errorMessage.str());
          }
          token = strtok(nullptr, " ");
          c[0] = atof(token.c_str());
          token = strtok(nullptr, " ");
          c[1] = atof(token.c_str());
          token = strtok(nullptr, " ");
          c[2] = atof(token.c_str());

          m_sampleCoordinates[3 * noPoints] = F1B3 * (a[0] + b[0] + c[0]);
          m_sampleCoordinates[3 * noPoints + 1] = F1B3 * (a[1] + b[1] + c[1]);
          m_sampleCoordinates[3 * noPoints + 2] = F1B3 * (a[2] + b[2] + c[2]);

          if(!readNormals) {
            for(MInt i = 0; i < 3; i++) {
              b[i] = b[i] - a[i];
              a[i] = c[i] - a[i];
            }
            crossProduct(c, b, a);
            MFloat tmp = F1 / sqrt(POW2(c[0]) + POW2(c[1]) + POW2(c[2]));

            m_sampleNormals[3 * noPoints] = c[0] * tmp;
            m_sampleNormals[3 * noPoints + 1] = c[1] * tmp;
            m_sampleNormals[3 * noPoints + 2] = c[2] * tmp;
          }

          // skip "endloop"
          getline(ifile, line);

          // skip "endfacet"
          getline(ifile, line);

          noPoints++;
        } else if(token.compare(0, 8, "endsolid", 0, 8) == 0) {
          cerr << "finished ";
          break;
        } else {
          stringstream errorMessage;
          errorMessage << "Error 6 reading " << fileName << ". Quit." << endl;
          mTerm(1, AT_, errorMessage.str());
        }
      }

      ifile.close();
    }
  }
  m_noSurfacePointSamples = noPoints;

  cerr << "(read " << m_noSurfacePointSamples << " samples)." << endl;
  cerr << "establishing sample neighborhood...";

  const MInt noNghbrs = m_maxNoSampleNghbrs;
  MFloat dist[10];
  MInt nghbrs[10];
  ASSERT(noNghbrs <= 10, "");
  MInt offset = 0;
  for(MInt p = 0; p < noPoints; p++) {
    for(MInt i = 0; i < noNghbrs; i++) {
      dist[i] = POW2(c_cellLengthAtLevel(0));
      nghbrs[i] = -1;
    }
    for(MInt q = 0; q < noPoints; q++) {
      if(p == q) continue;
      MFloat tmpDist = POW2(m_sampleCoordinates[3 * p] - m_sampleCoordinates[3 * q])
                       + POW2(m_sampleCoordinates[3 * p + 1] - m_sampleCoordinates[3 * q + 1])
                       + POW2(m_sampleCoordinates[3 * p + 2] - m_sampleCoordinates[3 * q + 2]);
      for(MInt i = 0; i < noNghbrs; i++) {
        if(tmpDist < dist[i]) {
          for(MInt j = noNghbrs - 1; j > i; j--) {
            if(nghbrs[j - 1] > -1) {
              nghbrs[j] = nghbrs[j - 1];
              dist[j] = dist[j - 1];
            }
          }
          dist[i] = tmpDist;
          nghbrs[i] = q;
          break;
        }
      }
    }
    for(MInt i = 0; i < noNghbrs; i++) {
      m_sampleNghbrs[offset + i] = nghbrs[i];
    }
    offset += noNghbrs;
    m_sampleNghbrOffsets[p] = offset;
  }

  cerr << "finished." << endl;
}


/** \fn void FvMbCartesianSolverXD<nDim, SysEqn>::logCell()
 * void FvMbCartesianSolverXD<nDim, SysEqn>::prepareRestart()
 * \brief check if a restart file should be written and prepare a restart
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
MBool FvMbCartesianSolverXD<nDim, SysEqn>::prepareRestart(MBool writeRestart, MBool& writeGridRestart) {
  TRACE();

  writeGridRestart = false;

  if(((globalTimeStep % m_restartInterval) == 0 && globalTimeStep > m_restartTimeStep) || writeRestart) {
    writeRestart = true;

    if(isActive() && m_deleteNeighbour) {
      restoreNeighbourLinks();
    }

    if(m_onlineRestartInterval > 0) {
      if(globalTimeStep == 0 && m_onlineRestartInterval < g_timeSteps) m_adaptationSinceLastRestart = true;
      if(globalTimeStep == 1 && m_onlineRestartInterval < g_timeSteps) m_adaptationSinceLastRestart = true;
      if(globalTimeStep % m_onlineRestartInterval == 0) m_adaptationSinceLastRestart = true;
    }

    if(m_forceRestartGrid) {
      m_adaptationSinceLastRestart = true;
      if(isActive() && m_recalcIds == nullptr) mAlloc(m_recalcIds, maxNoGridCells(), "m_recalcIds", -1, AT_);
    }

    if(m_adaptationSinceLastRestartBackup || m_adaptationSinceLastRestart) {
      writeGridRestart = true;
    }
  }

  if(grid().newMinLevel() > 0) {
    writeGridRestart = true;
  }

  // This needs to happen before the grid and variable-output. Thats why it had to be moved here
  // from saveRestartFile()!
  if(isActive() && m_useNonSpecifiedRestartFile && writeRestart) {
    if(domainId() == 0) {
      if(m_adaptationSinceLastRestart) {
        MString fileName = outputDir() + "restartGrid";
        fileName += ".Netcdf";
        MString fileNameBak = fileName + ".BAK";
#ifdef _MB_DEBUG_
        cerr << "rename " << fileName << " " << fileNameBak << endl;
#endif
        rename(fileName.c_str(), fileNameBak.c_str());
      }
      {
        MString fileName = outputDir() + "restartVariables";
        fileName += ".Netcdf";
        MString fileNameBak = fileName + ".BAK";
#ifdef _MB_DEBUG_
        cerr << "rename " << fileName << " " << fileNameBak << endl;
#endif
        rename(fileName.c_str(), fileNameBak.c_str());
      }
      {
        MString fileName = outputDir() + "restartBodyData";
        fileName += ".Netcdf";
        MString fileNameBak = fileName + ".BAK";
#ifdef _MB_DEBUG_
        cerr << "rename " << fileName << " " << fileNameBak << endl;
#endif
        rename(fileName.c_str(), fileNameBak.c_str());
      }
    }
    MPI_Barrier(mpiComm(), AT_);
  }

  if(isActive() && m_levelSetMb && writeRestart) {
    if(maxLevel() > minLevel()) {
      for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
        if(a_isBndryGhostCell(cellId)) continue;
        if(a_isHalo(cellId)) continue;
        if(a_level(cellId) != minLevel()) continue;
        reduceData(cellId, &a_pvariable(0, 0), PV->noVariables);
        if(grid().azimuthalPeriodicity()) {
          // Should this be done also for non-periodic cases?
          // Else, after restart CV are computed based on PV variables
          // In the running simulation PV, however, are simply overwritten to old value in computePV()
          reduceData(cellId, &a_variable(0, 0), CV->noVariables);
        }
      }
    }
  }

#if defined _MB_DEBUG_ || !defined NDEBUG
  if(isActive() && writeRestart) {
    if(domainId() == 0) {
      cerr << "Checking cells before writing restart-file... ";
    }
    for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
      for(MInt v = 0; v < CV->noVariables; v++) {
        if(std::isnan(a_variable(cellId, v)) && a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
          cerr << "Nan in variable when writing restart-File: " << cellId << " "
               << a_hasProperty(cellId, SolverCell::IsInactive) << endl;
        }
      }
    }
    cerr0 << "finished. " << endl;
  }
#endif

  return writeRestart;
}


/**
 * \fn void FvMbCartesianSolverXD<nDim, SysEqn>::reIntAfterRestart)
 * \brief re-init the solver after a restart file has been written
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::reIntAfterRestart(MBool doneRestart) {
  TRACE();

  if(doneRestart) {
    m_adaptationSinceLastRestart = false;
    m_adaptationSinceLastRestartBackup = false;
    if(isActive()) {
      deleteNeighbourLinks();
    }
  }
}


/**
 * \fn void FvMbCartesianSolverXD<nDim, SysEqn>::setCellWeights()
 * \brief set static cell weights for solver cells, which are used for the domain decomposition
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::setCellWeights(MFloat* solverCellWeight) {
  TRACE();

  const MInt noCellsGrid = grid().raw().treeb().size();
  const MInt offset = noCellsGrid * solverId();

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    if(a_isBndryGhostCell(cellId)) continue;
    if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
    if(a_hasProperty(cellId, SolverCell::IsSplitClone)) continue;
    assertValidGridCellId(cellId);
    const MInt gridCellId = grid().tree().solver2grid(cellId);
    const MInt id = gridCellId + offset;
    if(a_isHalo(cellId)) continue;
    if(c_noChildren(cellId) > 0) {
      solverCellWeight[id] = m_weightBaseCell * m_weightMulitSolverFactor;
      continue;
    }
    if(a_hasProperty(cellId, SolverCell::IsInactive)) {
      solverCellWeight[id] = m_weightLeafCell * m_weightMulitSolverFactor;
    } else {
      solverCellWeight[id] = m_weightActiveCell * m_weightMulitSolverFactor;
    }

    MFloat dist = fabs(a_levelSetValuesMb(cellId, 0));
    if(dist < 2 * grid().cellLengthAtLevel(maxRefinementLevel())) {
      solverCellWeight[id] += m_weightNearBndryCell * m_weightMulitSolverFactor;
    }
    if(a_bndryId(cellId) > -1 && c_isLeafCell(cellId)) {
      solverCellWeight[id] += m_weightBndryCell * m_weightMulitSolverFactor;
    }
  }
}


/**
 * \fn void FvMbCartesianSolverXD<nDim, SysEqn>::saveRestartFile()
 * \brief Saves the restart file
 * \author D. Hartmann, Update Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::saveRestartFile(const MBool writeBackup) {
  TRACE();

  FvCartesianSolverXD<nDim, SysEqn>::saveRestartFile(writeBackup);

  if(m_noEmbeddedBodies > 0) {
    saveBodyRestartFile(writeBackup);
  }
}


/**
 * \fn void FvMbCartesianSolverXD<nDim, SysEqn>::loadRestartFile()
 * \brief Loads the restart files
 * \author: D. Hartmann
 * \date May 24, 2006
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::loadRestartFile() {
  TRACE();

  FvCartesianSolverXD<nDim, SysEqn>::loadRestartFile();
  m_physicalTimeDt1 = m_physicalTime;

  updateInfinityVariables();

  m_log << "ok" << endl;
  m_log << "computing conservative variables... ";
  computeConservativeVariables();
  m_log << "ok" << endl;
  m_log << "restart at time step: " << globalTimeStep << " - solution time: " << m_time << endl;
  m_log << m_noSamples << " samples read" << endl;
  cerr0 << "finished restart at time step " << globalTimeStep << endl;
}


/**
 * \fn void FvMbCartesianSolverXD<nDim, SysEqn>::saveBodyRestartFile()
 * \brief save restart body file
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::saveBodyRestartFile(const MBool backup) {
  TRACE();

  if(globalTimeStep <= 0 || (m_restart && globalTimeStep <= m_restartTimeStep)) {
    cerr0 << "Not saving body-restart-data, as the cell volume might not have been created yet!" << endl;
    return;
  }

  // force calculation before writing the restartFile!
  if(!m_trackBodySurfaceData) computeBodySurfaceData();

  cerr0 << "writing body-restart-data for the fv-mb-solver... ";

  int64_t noMbCells = 0;
  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_isHalo(cellId)) continue;
    if(a_isPeriodic(cellId)) continue;
    if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
    noMbCells++;
  }

  int64_t noMbCellsGlobal = noMbCells;
  ScratchSpace<MPI_Offset> volOffsets(noDomains() + 1, AT_, "volOffsets");
  volOffsets(0) = 0;

  if(noDomains() > 1) {
    volOffsets(domainId() + 1) = (MPI_Offset)noMbCells;
    MPI_Allgather(&noMbCells, 1, MPI_INT64_T, &volOffsets[1], 1, MPI_INT64_T, mpiComm(), AT_, "noMbCells",
                  "volOffsets[1]");
    for(MInt d = 0; d < noDomains(); d++) {
      volOffsets(d + 1) += volOffsets(d);
    }
    noMbCellsGlobal = noMbCells;
    MPI_Allreduce(MPI_IN_PLACE, &noMbCellsGlobal, 1, MPI_INT64_T, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "noMbCellsGlobal");
    if(noMbCellsGlobal != volOffsets(noDomains())) mTerm(1, AT_, "Dimension mismatch.");
  }
  volOffsets(noDomains()) = (MPI_Offset)noMbCellsGlobal;

  // Azimuthal periodicity. Boundary cell volume of halo cells musst be saved!
  int64_t noAzimuthalMbCells = 0;
  int64_t noAzimuthalMbCellsGlobal = 0;
  ScratchSpace<MPI_Offset> volOffsetsAzimuthal(grid().azimuthalPeriodicity() ? (noDomains() + 1) : 1, AT_,
                                               "volOffsetsAzimuthal");
  if(grid().azimuthalPeriodicity()) {
    storeAzimuthalPeriodicData();
    noAzimuthalMbCells = m_azimuthalNearBoundaryBackup.size();
    noAzimuthalMbCellsGlobal = noAzimuthalMbCells;
    volOffsetsAzimuthal(0) = 0;
    if(noDomains() > 1) {
      volOffsetsAzimuthal(domainId() + 1) = (MPI_Offset)noAzimuthalMbCells;
      MPI_Allgather(&noAzimuthalMbCells, 1, MPI_INT64_T, &volOffsetsAzimuthal[1], 1, MPI_INT64_T, mpiComm(), AT_,
                    "noAzimuthalMbCells", "volOffsetsAzimuthal[1]");
      for(MInt d = 0; d < noDomains(); d++) {
        volOffsetsAzimuthal(d + 1) += volOffsetsAzimuthal(d);
      }
      noAzimuthalMbCellsGlobal = noAzimuthalMbCells;
      MPI_Allreduce(MPI_IN_PLACE, &noAzimuthalMbCellsGlobal, 1, MPI_INT64_T, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                    "noAzimuthalMbCellsGlobal");
      if(noAzimuthalMbCellsGlobal != volOffsetsAzimuthal(noDomains())) mTerm(1, AT_, "Dimension mismatch.");
    }
    volOffsetsAzimuthal(noDomains()) = (MPI_Offset)noAzimuthalMbCellsGlobal;
  }

  const MLong DOF = m_noEmbeddedBodies;
  const MLong DOF_TRANS = nDim * m_noEmbeddedBodies;
  const MLong DOF_ROT = 3 * m_noEmbeddedBodies;
  const MLong DOF_QUAT = 4 * m_noEmbeddedBodies;
  const MLong DOF_VOL = (MLong)noMbCellsGlobal;
  const MLong DOF_VOL_AZIMUTHAL = (MLong)noAzimuthalMbCellsGlobal;

  stringstream fn;
  fn.clear();
  if(backup) {
    fn << outputDir() << "restartBodyDataBackup_" << getIdentifier(m_multipleFvSolver) << globalTimeStep;
  } else {
    if(m_useNonSpecifiedRestartFile) {
      fn << outputDir() << "restartBodyData" << getIdentifier(m_multipleFvSolver, "_", "");
    } else {
      fn << outputDir() << "restartBodyData_" << getIdentifier(m_multipleFvSolver) << globalTimeStep;
    }
  }
  fn << ParallelIo::fileExt();

  MString fileName = fn.str();

  MLongScratchSpace bndryCellVolumesIds(noMbCells, AT_, "bndryCellVolumesIds");
  MFloatScratchSpace bndryCellVolumes(noMbCells, AT_, "bndryCellVolumes");
  MInt cnt = 0;
  if(grid().newMinLevel() < 0) {
    for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
      const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
      if(a_isHalo(cellId)) continue;
      if(a_isPeriodic(cellId)) continue;
      if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
      ASSERT(c_globalId(cellId) >= domainOffset(domainId())
                 && c_globalId(cellId) < domainOffset(domainId()) + noInternalCells(),
             "");
      bndryCellVolumesIds[cnt] = c_globalId(cellId);
      bndryCellVolumes[cnt] = a_cellVolume(cellId);
      if(bndryCellVolumesIds[cnt] >= domainOffset(noDomains())) {
        cerr << domainId() << ": index out of range " << bndryCellVolumes[cnt] << " " << domainOffset(noDomains())
             << " " << grid().noCellsGlobal() << " " << grid().bitOffset() << endl;
      }
      cnt++;
    }
  } else {
    vector<MInt> reOrderedCells;
    vector<MLong> newGlobalIds;
    cerr0 << "Updating globalIds for bodyRestartFile!" << endl;
    this->reOrderCellIds(reOrderedCells);
    // recompute the globalIds
    this->recomputeGlobalIds(reOrderedCells, newGlobalIds);

    // store bndryCellVolume and new globalId
    for(MUint id = 0; id < reOrderedCells.size(); id++) {
      const MInt cellId = reOrderedCells[id];
      if(a_isHalo(cellId)) continue;
      if(a_isPeriodic(cellId)) continue;
      if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
      const MInt bndryId = a_bndryId(cellId);
      if(bndryId < m_noOuterBndryCells) continue;
      bndryCellVolumesIds[cnt] = newGlobalIds[id];
      bndryCellVolumes[cnt] = a_cellVolume(cellId);
      cnt++;
    }
    ASSERT(cnt == noMbCells, "");
  }

  MLongScratchSpace azimuthalBndryCellVolumesIds(mMax(noAzimuthalMbCells, (int64_t)1), AT_,
                                                 "azimuthalndryCellVolumesIds");
  MFloatScratchSpace azimuthalBndryCellVolumes(mMax(noAzimuthalMbCells, (int64_t)1), AT_, "azimuthalndryCellVolumes");
  MFloatScratchSpace azimuthalBndryCellCoordinates(mMax(noAzimuthalMbCells * nDim, (int64_t)1), AT_,
                                                   "azimuthalndryCellCoordinates");
  if(grid().azimuthalPeriodicity()) {
    cnt = 0;
    for(auto it = m_azimuthalNearBoundaryBackup.begin(); it != m_azimuthalNearBoundaryBackup.end(); ++it) {
      MInt cellId = it->first;
      azimuthalBndryCellVolumesIds[cnt] = c_globalId(cellId);
      azimuthalBndryCellVolumes[cnt] = (it->second).first[nDim]; // cellVolume
      for(MInt d = 0; d < nDim; d++) {
        azimuthalBndryCellCoordinates[cnt * nDim + d] = (it->second).first[d];
      }
      cnt++;
    }
  }

  MFloatScratchSpace bodyRotation(m_noEmbeddedBodies, 3, AT_, "bodyRotation");
  for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
    getBodyRotation(k, &bodyRotation[3 * k]);
  }

  {
    map<MLong, MFloat> tmpVol;
    for(MInt i = 0; i < noMbCells; i++) {
      tmpVol.insert(make_pair(bndryCellVolumesIds[i], bndryCellVolumes[i]));
    }
    cnt = 0;
    for(map<MLong, MFloat>::iterator it = tmpVol.begin(); it != tmpVol.end(); it++) {
      bndryCellVolumesIds[cnt] = it->first;
      bndryCellVolumes[cnt] = it->second;
      cnt++;
    }

    if(grid().azimuthalPeriodicity()) {
      multimap<MLong, vector<MFloat>> tmpVolAzimuthal;
      for(MInt i = 0; i < noAzimuthalMbCells; i++) {
        vector<MFloat> tmpFloats(nDim + 1);
        for(MInt d = 0; d < nDim; d++) {
          tmpFloats[d] = azimuthalBndryCellCoordinates[i * nDim + d];
        }
        tmpFloats[nDim] = azimuthalBndryCellVolumes[i];
        tmpVolAzimuthal.insert(make_pair(azimuthalBndryCellVolumesIds[i], tmpFloats));
      }
      cnt = 0;
      for(multimap<MLong, vector<MFloat>>::iterator it = tmpVolAzimuthal.begin(); it != tmpVolAzimuthal.end(); it++) {
        azimuthalBndryCellVolumesIds[cnt] = it->first;
        for(MInt d = 0; d < nDim; d++) {
          azimuthalBndryCellCoordinates[cnt * nDim + d] = (it->second)[d];
        }
        azimuthalBndryCellVolumes[cnt] = (it->second)[nDim];
        cnt++;
      }
    }

    ParallelIo::size_type start = 0;
    ParallelIo::size_type count = 0;

    using namespace maia::parallel_io;
    ParallelIo parallelIo(fileName, PIO_REPLACE, mpiComm());

    // Creating file header.
    parallelIo.defineScalar(PIO_INT, "DOF");

    count = DOF;
    parallelIo.defineArray(PIO_FLOAT, "bodyTemperature", count);

    count = DOF_TRANS;
    parallelIo.defineArray(PIO_FLOAT, "bodyCenter", count);
    parallelIo.defineArray(PIO_FLOAT, "bodyVelocity", count);
    parallelIo.defineArray(PIO_FLOAT, "bodyAcceleration", count);
    parallelIo.defineArray(PIO_FLOAT, "bodyForce", count);

    count = DOF_ROT;
    parallelIo.defineArray(PIO_FLOAT, "bodyRotation", count);
    parallelIo.defineArray(PIO_FLOAT, "bodyAngularVelocity", count);
    parallelIo.defineArray(PIO_FLOAT, "bodyAngularAcceleration", count);
    parallelIo.defineArray(PIO_FLOAT, "bodyTorque", count);

    count = DOF_QUAT;
    parallelIo.defineArray(PIO_FLOAT, "bodyQuaternion", count);

    count = DOF_VOL;
    parallelIo.defineArray(PIO_LONG, "bndryCellVolumesIds", count);
    parallelIo.defineArray(PIO_FLOAT, "bndryCellVolumes", count);

    if(grid().azimuthalPeriodicity()) {
      count = DOF_VOL_AZIMUTHAL;
      parallelIo.defineArray(PIO_LONG, "azimuthalBndryCellVolumesIds", count);
      parallelIo.defineArray(PIO_FLOAT, "azimuthalBndryCellVolumes", count);
      count *= nDim;
      parallelIo.defineArray(PIO_FLOAT, "azimuthalBndryCellCoordinates", count);
    }

    parallelIo.writeScalar(DOF, "DOF");


    start = 0;
    count = DOF;
    parallelIo.setOffset(count, start);
    parallelIo.writeArray(m_bodyTemperature, "bodyTemperature");

    count = DOF_TRANS;
    parallelIo.setOffset(count, start);
    parallelIo.writeArray(m_bodyCenter, "bodyCenter");
    parallelIo.writeArray(m_bodyVelocity, "bodyVelocity");
    parallelIo.writeArray(m_bodyAcceleration, "bodyAcceleration");
    parallelIo.writeArray(m_bodyForce, "bodyForce");

    count = DOF_ROT;
    parallelIo.setOffset(count, start);
    parallelIo.writeArray(&bodyRotation[0], "bodyRotation");

    if(m_LsRotate && !m_constructGField) {
      // This can occur for multisolver where the lsSolver is inactive on some ranks
      MIntScratchSpace invalid(noDomains(), AT_, "invalid");
      invalid.fill(-1);
      MInt validRoot = -1;
      if(std::isnan(m_bodyAngularVelocity[0])) invalid[domainId()] = 1;
      MPI_Allreduce(MPI_IN_PLACE, invalid.getPointer(), noDomains(), MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                    "invalid");
      for(MInt d = 0; d < noDomains(); d++) {
        if(invalid[d] < 0) validRoot = d;
      }
      MPI_Bcast(&m_bodyAngularVelocity[0], m_noEmbeddedBodies * nDim, MPI_DOUBLE, validRoot, mpiComm(), AT_,
                "m_bodyAngularVelocity");
      MPI_Bcast(&m_bodyAngularAcceleration[0], m_noEmbeddedBodies * nDim, MPI_DOUBLE, validRoot, mpiComm(), AT_,
                "m_bodyAngularAcceleration");
    }

    parallelIo.writeArray(m_bodyAngularVelocity, "bodyAngularVelocity");
    parallelIo.writeArray(m_bodyAngularAcceleration, "bodyAngularAcceleration");
    parallelIo.writeArray(m_bodyTorque, "bodyTorque");

    count = DOF_QUAT;
    parallelIo.setOffset(count, start);
    parallelIo.writeArray(m_bodyQuaternion, "bodyQuaternion");

    start = volOffsets(domainId());
    count = noMbCells;
    parallelIo.setOffset(count, start);
    parallelIo.writeArray(bndryCellVolumesIds.begin(), "bndryCellVolumesIds");
    parallelIo.writeArray(bndryCellVolumes.begin(), "bndryCellVolumes");

    if(grid().azimuthalPeriodicity()) {
      start = volOffsetsAzimuthal(domainId());
      count = noAzimuthalMbCells;
      parallelIo.setOffset(count, start);
      parallelIo.writeArray(azimuthalBndryCellVolumesIds.begin(), "azimuthalBndryCellVolumesIds");
      parallelIo.writeArray(azimuthalBndryCellVolumes.begin(), "azimuthalBndryCellVolumes");
      start = volOffsetsAzimuthal(domainId()) * nDim;
      count = noAzimuthalMbCells * nDim;
      parallelIo.setOffset(count, start);
      parallelIo.writeArray(azimuthalBndryCellCoordinates.begin(), "azimuthalBndryCellCoordinates");
    }
  }

  if(domainId() == 0) cerr << "ok" << endl;
}


/**
 * \fn void FvMbCartesianSolverXD<nDim, SysEqn>::loadBodyRestartFile()
 * \brief load restart body file
 *        readMode = 0 : do not read the cellVolume from file (read only bodyData)
 *        readMode = 1 : read cell volume from file for all bndryCells
 *        readMode = 2 : read cell volume and store in array (bndryCells not yet created)
 *                       necessary for geometryChange at restart!
 *
 * \author Lennart Schneiders, Tim Wegmann (minor modifications)
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::loadBodyRestartFile(MInt readMode) {
  TRACE();

  if(m_noEmbeddedBodies == 0) return;

  stringstream fn;
  fn.clear();
  if(m_useNonSpecifiedRestartFile) {
    if(!m_multipleFvSolver) {
      fn << restartDir() << "restartBodyData";
    } else {
      fn << restartDir() << "restartBodyData_" << solverId();
    }
  } else {
    if(!m_multipleFvSolver) {
      fn << restartDir() << "restartBodyData_" << m_restartTimeStep;
    } else {
      fn << restartDir() << "restartBodyData_" << solverId() << "_" << m_restartTimeStep;
    }
  }
  fn << ParallelIo::fileExt();

  MString fileName = fn.str();

#ifdef _MB_DEBUG_
  MInt cnt = 0;
#endif

  const MLong DOF = m_noEmbeddedBodies;
  const MLong DOF_TRANS = nDim * m_noEmbeddedBodies;
  const MLong DOF_ROT = 3 * m_noEmbeddedBodies;
  const MLong DOF_QUAT = 4 * m_noEmbeddedBodies;

  if(domainId() == 0) {
    cerr << "loading body restart file " << fn.str() << " at " << globalTimeStep << "...";
  }

  int64_t noMbCells = 0;
  int64_t domainOffset0 = (int64_t)domainOffset(domainId() + 1);
  int64_t domainOffset1 = (int64_t)domainOffset(domainId());

  // check that the number of bndry-Cells in the file matches
  // the number of already created bndryCells
  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_isHalo(cellId)) continue;
    if(a_isPeriodic(cellId)) continue;
    if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
    domainOffset0 = mMin(domainOffset0, (int64_t)c_globalId(cellId));
    domainOffset1 = mMax(domainOffset1, (int64_t)c_globalId(cellId));
    noMbCells++;
  }
  domainOffset1++;
  domainOffset0 = mMax(domainOffset0, (int64_t)domainOffset(domainId()));
  domainOffset1 = mMin(domainOffset1, (int64_t)domainOffset(domainId() + 1));

  if(noMbCells == 0) {
    domainOffset0 = (int64_t)domainOffset(domainId());
    // NOTE: check the below, this makes hardly any sense!
    domainOffset1 = domainOffset0 + 1;
    if(readMode == 2) { // working version
      domainOffset1 = (int64_t)domainOffset(domainId() + 1);
    }
  }
  if(domainOffset0 > domainOffset1 || m_bodyTypeMb == 3) {
    domainOffset0 = (int64_t)domainOffset(domainId());
    domainOffset1 = (int64_t)domainOffset(domainId() + 1);
  }
  int64_t noMbCellsGlobal = noMbCells;

  if(noDomains() > 1) {
    noMbCellsGlobal = noMbCells;
    MPI_Allreduce(MPI_IN_PLACE, &noMbCellsGlobal, 1, MPI_INT64_T, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                  "noMbCellsGlobal");
  }

  using namespace maia::parallel_io;
  ParallelIo parallelIo(fileName, PIO_READ, mpiComm());

  ParallelIo::size_type size = 0;
  ParallelIo::size_type start = 0;
  ParallelIo::size_type count = 0;

  if(parallelIo.hasDataset("DOF")) {
    parallelIo.readScalar(&size, "DOF");
  } else {
    size = parallelIo.getArraySize("bodyTemperature");
  }

  if(size != DOF) {
    mTerm(1, AT_,
          "No embedded bodies mismatch in loadBodyRestartFile(): " + to_string(m_noEmbeddedBodies)
              + " != " + to_string(size) + ".");
  }

  size = parallelIo.getArraySize("bndryCellVolumesIds");

  if(noMbCellsGlobal > 0 && size != (MPI_Offset)noMbCellsGlobal && m_geometryChange == nullptr) {
    if(domainId() == 0) {
      cerr << "Warning: No boundary cells mismatch in loadBodyRestartFile(): " + to_string(noMbCellsGlobal)
                  + " != " + to_string(size) + ". Might be due to non-converged to fluid-structure iterations."
           << endl;
    }
  }
  const MLong DOF_VOL = size;

  // read body properties:
  count = DOF;
  parallelIo.setOffset(count, start);
  parallelIo.readArray(m_bodyTemperature, "bodyTemperature");

  count = DOF_TRANS;
  parallelIo.setOffset(count, start);
  parallelIo.readArray(m_bodyCenter, "bodyCenter");
  parallelIo.readArray(m_bodyVelocity, "bodyVelocity");
  parallelIo.readArray(m_bodyAcceleration, "bodyAcceleration");
  parallelIo.readArray(m_bodyForce, "bodyForce");

  count = DOF_ROT;
  parallelIo.setOffset(count, start);
  parallelIo.readArray(m_bodyAngularVelocity, "bodyAngularVelocity");
  parallelIo.readArray(m_bodyAngularAcceleration, "bodyAngularAcceleration");
  parallelIo.readArray(m_bodyTorque, "bodyTorque");

  count = DOF_QUAT;
  parallelIo.setOffset(count, start);
  parallelIo.readArray(m_bodyQuaternion, "bodyQuaternion");

  if(readMode == 2) {
    ASSERT(m_geometryChange != nullptr, "");
    if(domainId() == 0) {
      cerr << "Storing old bndryCell volume for geometryChange!" << endl;
    }
    m_oldGeomBndryCells.clear();
  }

  MInt mismatchCnt = 0;
  if(readMode > 0 && DOF_VOL > 0 && DOF_VOL < domainOffset(noDomains())) {
    MBool readVolStrided = false;
    if((readVolStrided || DOF_VOL <= noDomains()) && readMode != 2) {
      start = 0;
      count = DOF_VOL;
      if(readVolStrided) {
        MPI_Offset noSamples = (MPI_Offset)max(2, min((MInt)DOF_VOL, noDomains() / 2));
        MPI_Offset sampleWidth = ((MPI_Offset)(DOF_VOL - 1)) / (noSamples - 1);
        MLongScratchSpace sampledIds(noSamples, AT_, "sampledIds");
        start = 0;
        count = noSamples;
        parallelIo.setOffset(count, start);
        parallelIo.readArray(&sampledIds[0], "bndryCellVolumesIds", -1, sampleWidth);
        start = 0;
        count = 0;
        MPI_Offset end = DOF_VOL;
        for(MPI_Offset i = 0; i < noSamples; i++) {
          if(domainOffset0 >= sampledIds[i])
            start = i * sampleWidth;
          else
            break;
        }
        for(MPI_Offset i = noSamples - 1; i >= 0; i--) {
          if(domainOffset1 < sampledIds[i])
            end = i * sampleWidth;
          else
            break;
        }
        MInt diff = end - start;
        count = (diff > 0) ? (MPI_Offset)diff : 0;
      }
      MLongScratchSpace bndryCellVolumesIds(count + 1, AT_, "bndryCellVolumesIds");
      MFloatScratchSpace bndryCellVolumes(count + 1, AT_, "bndryCellVolumes");

      parallelIo.setOffset(count, start);
      parallelIo.readArray(&bndryCellVolumesIds[0], "bndryCellVolumesIds");
      parallelIo.readArray(&bndryCellVolumes[0], "bndryCellVolumes");

      MIntScratchSpace bndCells(domainOffset1 - domainOffset0 + 1, AT_, "bndCells");
      bndCells.fill(-1);
      for(MInt i = 0; i < count; i++) {
        if(bndryCellVolumesIds[i] < domainOffset0 || bndryCellVolumesIds[i] >= domainOffset1) {
          continue;
        }
        bndCells[bndryCellVolumesIds[i] - domainOffset0] = i;
      }
#ifdef _MB_DEBUG_
      cerr << domainId() << ": read " << bndCells.size() << " of " << DOF_VOL
           << " volume entries within domain offsets " << domainOffset0 << "-" << domainOffset1 << endl;
#endif

      mismatchCnt = 0;

      for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
        MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
        if(a_isHalo(cellId)) continue;

        if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
        if(c_globalId(cellId) < domainOffset0 || c_globalId(cellId) >= domainOffset1) continue;
        if(bndCells[c_globalId(cellId) - domainOffset0] > -1) {
          // const MInt i = it->second;
          MInt i = bndCells[c_globalId(cellId) - domainOffset0];
          a_cellVolume(cellId) = bndryCellVolumes[i];
          m_cellVolumesDt1[cellId] = bndryCellVolumes[i];
          if(m_dualTimeStepping) m_cellVolumesDt2[cellId] = bndryCellVolumes[i];
          a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
          m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume = bndryCellVolumes[i];

#ifdef _MB_DEBUG_
          if(a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId)) < F0
             || a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId)) > F1) {
            cerr << domainId() << ": warning volume fraction in loadBodyRestartFile() "
                 << a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId)) << " for cell " << cellId << endl;
          }
#endif
        } else {
          mismatchCnt++;
          a_cellVolume(cellId) = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume;
          m_cellVolumesDt1[cellId] = a_cellVolume(cellId);
          if(m_dualTimeStepping) m_cellVolumesDt2[cellId] = a_cellVolume(cellId);
          a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
#ifdef _MB_DEBUG_
          if(cnt < 20) {
            cerr << domainId() << ": Corresponding boundary id not found. "
                 << "Might be due to non-converged to fluid-structure iterations: /g " << c_globalId(cellId) << " /c "
                 << a_coordinate(cellId, 0) << " " << a_coordinate(cellId, 1) << " " << a_coordinate(cellId, 2)
                 << " /ls " << a_levelSetValuesMb(cellId, 0) / c_cellLengthAtCell(cellId) << " /v "
                 << m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume / grid().gridCellVolume(a_level(cellId)) << " "
                 << domainOffset0 << " " << domainOffset1 << endl;
            cnt++;
            if(cnt == 20) {
              cerr << domainId() << ": Exceeding 20, not reporting any more." << endl;
            }
          }
#endif
        }
      }
      MPI_Allreduce(MPI_IN_PLACE, &mismatchCnt, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "mismatchCnt");
      if(domainId() == 0) {
        cerr << "mismatch cnt: " << mismatchCnt << " out of " << DOF_VOL << endl;
      }

    } else {
      start = (DOF_VOL / noDomains()) * domainId();
      count = (domainId() == noDomains() - 1) ? DOF_VOL - start : (DOF_VOL / noDomains());

      MLongScratchSpace bndryCellVolumesIdsTmp(count, AT_, "bndryCellVolumesIdsTmp");
      MFloatScratchSpace bndryCellVolumesTmp(count, AT_, "bndryCellVolumesTmp");

      parallelIo.setOffset(count, start);
      parallelIo.readArray(&bndryCellVolumesIdsTmp[0], "bndryCellVolumesIds");
      parallelIo.readArray(&bndryCellVolumesTmp[0], "bndryCellVolumes");

      MIntScratchSpace sendCnt(noDomains(), AT_, "sendCnt");
      MIntScratchSpace recvCnt(noDomains(), AT_, "recvCnt");
      MIntScratchSpace recvOffsets(noDomains() + 1, AT_, "recvOffsets");
      MIntScratchSpace sendOffsets(noDomains(), AT_, "sendOffsets");
      sendCnt.fill(0);
      recvCnt.fill(0);
      recvOffsets.fill(0);
      sendOffsets.fill(-1);
      MInt nbDom = noDomains() / 2;
      MLong minId = std::numeric_limits<MLong>::max();
      MLong bitOffsetBuf = 0;
      for(MInt i = 0; i < count; i++) {
        minId = mMin(minId, bndryCellVolumesIdsTmp[i]);
      }
      if(minId < grid().bitOffset()) {
        bitOffsetBuf = grid().bitOffset();
      } else {
        bitOffsetBuf = 0;
      }

      for(MInt i = 0; i < count; i++) {
        bndryCellVolumesIdsTmp[i] += bitOffsetBuf;
      }
      for(MInt i = 0; i < count; i++) {
        if(bndryCellVolumesIdsTmp(i) >= domainOffset(noDomains())) {
          cerr << domainId() << ": index out of range " << bndryCellVolumesIdsTmp(i) << " " << domainOffset(noDomains())
               << " " << grid().noCellsGlobal() << " " << grid().bitOffset() << " " << bitOffsetBuf << endl;
          continue;
        }
        while(bndryCellVolumesIdsTmp(i) < domainOffset(nbDom) || bndryCellVolumesIdsTmp(i) >= domainOffset(nbDom + 1)) {
          if(bndryCellVolumesIdsTmp(i) < domainOffset(nbDom)) nbDom--;
          if(bndryCellVolumesIdsTmp(i) >= domainOffset(nbDom + 1)) nbDom++;
        }
        if(sendCnt(nbDom) == 0) sendOffsets[nbDom] = i;
        sendCnt(nbDom)++;
      }
      for(MInt i = 0; i < noDomains(); i++) {
        if(sendCnt(i) > 0 && sendOffsets[i] < 0) {
          cerr << domainId() << ": Warning send offset not set: " << i << endl;
        }
      }
      MPI_Alltoall(&sendCnt[0], 1, MPI_INT, &recvCnt[0], 1, MPI_INT, mpiComm(), AT_, "sendCnt[0]", "recvCnt[0]");
      MInt totalNoRecv = 0;
      recvOffsets[0] = 0;
      for(MInt i = 0; i < noDomains(); i++) {
        totalNoRecv += recvCnt(i);
        recvOffsets[i + 1] = recvOffsets[i] + recvCnt(i);
      }
      MLongScratchSpace bndryCellVolumesIds(mMax(1, totalNoRecv), AT_, "bndryCellVolumesIds");
      MFloatScratchSpace bndryCellVolumes(mMax(1, totalNoRecv), AT_, "bndryCellVolumes");
      ScratchSpace<MPI_Request> sendReq(noDomains(), AT_, "sendReq");
      sendReq.fill(MPI_REQUEST_NULL);
      MInt scnt = 0;
      for(MInt i = 0; i < noDomains(); i++) {
        if(sendCnt[i] == 0) continue;
        MPI_Issend(&(bndryCellVolumesIdsTmp[sendOffsets[i]]), sendCnt[i], MPI_LONG, i, 432, mpiComm(), &sendReq[scnt],
                   AT_, "(bndryCellVolumesIdsTmp[sendOffsets[i]])");
        scnt++;
      }
      for(MInt i = 0; i < noDomains(); i++) {
        if(recvCnt[i] == 0) continue;
        MPI_Recv(&(bndryCellVolumesIds[recvOffsets[i]]), recvCnt[i], MPI_LONG, i, 432, mpiComm(), MPI_STATUS_IGNORE,
                 AT_, "(bndryCellVolumesIds[recvOffsets[i]])");
      }
      if(scnt > 0) MPI_Waitall(scnt, &sendReq[0], MPI_STATUSES_IGNORE, AT_);
      sendReq.fill(MPI_REQUEST_NULL);
      scnt = 0;
      for(MInt i = 0; i < noDomains(); i++) {
        if(sendCnt[i] == 0) continue;
        MPI_Issend(&(bndryCellVolumesTmp[sendOffsets[i]]), sendCnt[i], MPI_DOUBLE, i, 433, mpiComm(), &sendReq[scnt],
                   AT_, "(bndryCellVolumesTmp[sendOffsets[i]])");
        scnt++;
      }
      for(MInt i = 0; i < noDomains(); i++) {
        if(recvCnt[i] == 0) continue;
        MPI_Recv(&(bndryCellVolumes[recvOffsets[i]]), recvCnt[i], MPI_DOUBLE, i, 433, mpiComm(), MPI_STATUS_IGNORE, AT_,
                 "(bndryCellVolumes[recvOffsets[i]])");
      }
      if(scnt > 0) MPI_Waitall(scnt, &sendReq[0], MPI_STATUSES_IGNORE, AT_);

      MIntScratchSpace bndCells(domainOffset1 - domainOffset0 + 1, AT_, "bndCells");
      bndCells.fill(-1);
      for(MInt i = 0; i < totalNoRecv; i++) {
        if(bndryCellVolumesIds[i] < domainOffset0 || bndryCellVolumesIds[i] >= domainOffset1) {
          continue;
        }
        bndCells[bndryCellVolumesIds[i] - domainOffset0] = i;
      }

      mismatchCnt = 0;

      if(readMode == 1) {
        for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
          const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
          if(a_isHalo(cellId)) continue;
          if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
          if(c_globalId(cellId) < domainOffset0 || c_globalId(cellId) >= domainOffset1) continue;
          const MInt i = bndCells[c_globalId(cellId) - domainOffset0];
          if(i > -1) {
            a_cellVolume(cellId) = bndryCellVolumes[i];
            m_cellVolumesDt1[cellId] = bndryCellVolumes[i];
            if(m_dualTimeStepping) m_cellVolumesDt2[cellId] = bndryCellVolumes[i];
            a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
            m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume = bndryCellVolumes[i];
#ifdef _MB_DEBUG_
            if(a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId)) < F0
               || a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId)) > F1) {
              cerr << domainId() << ": warning volume fraction in loadBodyRestartFile() "
                   << a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId)) << " for cell " << cellId << " "
                   << c_globalId(cellId) << endl;
            }
#endif
          } else {
            mismatchCnt++;
            a_cellVolume(cellId) = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume;
            m_cellVolumesDt1[cellId] = a_cellVolume(cellId);
            if(m_dualTimeStepping) m_cellVolumesDt2[cellId] = a_cellVolume(cellId);
            a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));

#ifdef _MB_DEBUG_
            if(mismatchCnt < 20) {
              cerr << domainId()
                   << ": Corresponding boundary id not found. Might be due to non-converged to fluid-structure "
                      "iterations: /g "
                   << c_globalId(cellId) << " /c " << a_coordinate(cellId, 0) << " " << a_coordinate(cellId, 1) << " "
                   << a_coordinate(cellId, 2) << " /v "
                   << m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume / grid().gridCellVolume(a_level(cellId)) << " "
                   << domainOffset0 << " " << domainOffset1 << endl;
              cnt++;
              if(cnt == 20) {
                cerr << domainId() << ": Exceeding 20, not reporting any more." << endl;
              }
            }
#endif
          }
        }

        MPI_Allreduce(MPI_IN_PLACE, &mismatchCnt, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "mismatchCnt");

        if(domainId() == 0) {
          cerr << "mismatch cnt: " << mismatchCnt << " out of " << DOF_VOL << endl;
        }

        // for large missmatch count assume complete irregularity and treat all cells as missmatched!
        if(mismatchCnt > 0.5 * DOF_VOL) {
          for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
            const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
            a_cellVolume(cellId) = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume;
            m_cellVolumesDt1[cellId] = a_cellVolume(cellId);
            if(m_dualTimeStepping) m_cellVolumesDt2[cellId] = a_cellVolume(cellId);
            a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
          }
        }

      } else { // read mode 2!

        // store volume from file in array,
        // which is then correctly keept during the forcedAdaptation
        // and set for the bndryCells which remain the same thoughout the geometryChange!
        for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
          const MInt i = bndCells[cellId];
          if(i > -1) {
            const MFloat volume = bndryCellVolumes[i];
            m_oldGeomBndryCells.insert(make_pair(cellId, volume));
          }
        }
      }
    }
  }

  // set volumes on halo cells
  exchangeData(&a_cellVolume(0), 1);

  // Read cellVolume of azimuthal halo cells
  if(grid().azimuthalPeriodicity() && readMode == 1) {
    size = parallelIo.getArraySize("azimuthalBndryCellVolumesIds");
    const MLong DOF_VOL_AZIMUTHAL = size;
    start = (DOF_VOL_AZIMUTHAL / noDomains()) * domainId();
    count = (domainId() == noDomains() - 1) ? DOF_VOL_AZIMUTHAL - start : (DOF_VOL_AZIMUTHAL / noDomains());

    MLongScratchSpace azimuthalBndryCellVolumesIdsTmp(count, AT_, "azimuthalBndryCellVolumesIdsTmp");
    MFloatScratchSpace azimuthalBndryCellVolumesTmp(count, AT_, "azimuthalBndryCellVolumesTmp");
    MFloatScratchSpace azimuthalBndryCellCoordinatesTmp(count * nDim, AT_, "azimuthalBndryCellCoordinatesTmp");

    parallelIo.setOffset(count, start);
    parallelIo.readArray(&azimuthalBndryCellVolumesIdsTmp[0], "azimuthalBndryCellVolumesIds");
    parallelIo.readArray(&azimuthalBndryCellVolumesTmp[0], "azimuthalBndryCellVolumes");
    parallelIo.setOffset(count * nDim, start * nDim);
    parallelIo.readArray(&azimuthalBndryCellCoordinatesTmp[0], "azimuthalBndryCellCoordinates");

    MIntScratchSpace sendCntAzimuthal(noDomains(), AT_, "sendCntAzimuthal");
    MIntScratchSpace recvCntAzimuthal(noDomains(), AT_, "recvCntAzimuthal");
    MIntScratchSpace recvOffsetsAzimuthal(noDomains() + 1, AT_, "recvOffsetsAzimuthal");
    MIntScratchSpace sendOffsetsAzimuthal(noDomains(), AT_, "sendOffsetsAzimuthal");
    sendCntAzimuthal.fill(0);
    recvCntAzimuthal.fill(0);
    recvOffsetsAzimuthal.fill(0);
    sendOffsetsAzimuthal.fill(-1);
    MInt nbDom = noDomains() / 2;
    MLong minId = std::numeric_limits<MLong>::max();
    MLong bitOffsetBuf = 0;
    for(MInt i = 0; i < count; i++) {
      minId = mMin(minId, azimuthalBndryCellVolumesIdsTmp[i]);
    }
    if(minId < grid().bitOffset()) {
      bitOffsetBuf = grid().bitOffset();
    } else {
      bitOffsetBuf = 0;
    }

    for(MInt i = 0; i < count; i++) {
      azimuthalBndryCellVolumesIdsTmp[i] += bitOffsetBuf;
    }
    for(MInt i = 0; i < count; i++) {
      if(azimuthalBndryCellVolumesIdsTmp(i) >= domainOffset(noDomains())) {
        cerr << domainId() << ": index out of range " << azimuthalBndryCellVolumesIdsTmp(i) << " "
             << domainOffset(noDomains()) << " " << grid().noCellsGlobal() << " " << grid().bitOffset() << " "
             << bitOffsetBuf << endl;
        continue;
      }
      while(azimuthalBndryCellVolumesIdsTmp(i) < domainOffset(nbDom)
            || azimuthalBndryCellVolumesIdsTmp(i) >= domainOffset(nbDom + 1)) {
        if(azimuthalBndryCellVolumesIdsTmp(i) < domainOffset(nbDom)) nbDom--;
        if(azimuthalBndryCellVolumesIdsTmp(i) >= domainOffset(nbDom + 1)) nbDom++;
      }
      if(sendCntAzimuthal(nbDom) == 0) sendOffsetsAzimuthal[nbDom] = i;
      sendCntAzimuthal(nbDom)++;
    }
    for(MInt i = 0; i < noDomains(); i++) {
      if(sendCntAzimuthal(i) > 0 && sendOffsetsAzimuthal[i] < 0) {
        cerr << domainId() << ": Warning send offset not set: " << i << endl;
      }
    }
    MPI_Alltoall(&sendCntAzimuthal[0], 1, MPI_INT, &recvCntAzimuthal[0], 1, MPI_INT, mpiComm(), AT_,
                 "sendCntAzimuthal[0]", "recvCntAzimuthal[0]");
    MInt totalNoRecv = 0;
    recvOffsetsAzimuthal[0] = 0;
    for(MInt i = 0; i < noDomains(); i++) {
      totalNoRecv += recvCntAzimuthal(i);
      recvOffsetsAzimuthal[i + 1] = recvOffsetsAzimuthal[i] + recvCntAzimuthal(i);
    }
    MLongScratchSpace azimuthalBndryCellVolumesIds(mMax(1, totalNoRecv), AT_, "azimuthalBndryCellVolumesIds");
    MFloatScratchSpace azimuthalBndryCellVolumes(mMax(1, totalNoRecv), AT_, "azimuthalBndryCellVolumes");
    MFloatScratchSpace azimuthalBndryCellCoordinates(mMax(1, nDim * totalNoRecv), AT_, "azimuthalBndryCellCoordinates");
    ScratchSpace<MPI_Request> sendReqAzimuthal(noDomains(), AT_, "sendReqAzimuthal");
    sendReqAzimuthal.fill(MPI_REQUEST_NULL);
    MInt scnt = 0;
    for(MInt i = 0; i < noDomains(); i++) {
      if(sendCntAzimuthal[i] == 0) continue;
      MPI_Issend(&(azimuthalBndryCellVolumesIdsTmp[sendOffsetsAzimuthal[i]]), sendCntAzimuthal[i], MPI_LONG, i, 432,
                 mpiComm(), &sendReqAzimuthal[scnt], AT_, "(azimuthalBndryCellVolumesIdsTmp[sendOffsetsAzimuthal[i]])");
      scnt++;
    }
    for(MInt i = 0; i < noDomains(); i++) {
      if(recvCntAzimuthal[i] == 0) continue;
      MPI_Recv(&(azimuthalBndryCellVolumesIds[recvOffsetsAzimuthal[i]]), recvCntAzimuthal[i], MPI_LONG, i, 432,
               mpiComm(), MPI_STATUS_IGNORE, AT_, "(azimuthalBndryCellVolumesIds[recvOffsets[i]])");
    }
    if(scnt > 0) MPI_Waitall(scnt, &sendReqAzimuthal[0], MPI_STATUSES_IGNORE, AT_);
    sendReqAzimuthal.fill(MPI_REQUEST_NULL);
    scnt = 0;
    for(MInt i = 0; i < noDomains(); i++) {
      if(sendCntAzimuthal[i] == 0) continue;
      MPI_Issend(&(azimuthalBndryCellVolumesTmp[sendOffsetsAzimuthal[i]]), sendCntAzimuthal[i], MPI_DOUBLE, i, 433,
                 mpiComm(), &sendReqAzimuthal[scnt], AT_, "(azimuthalBndryCellVolumesTmp[sendOffsetsAzimuthal[i]])");
      scnt++;
    }
    for(MInt i = 0; i < noDomains(); i++) {
      if(recvCntAzimuthal[i] == 0) continue;
      MPI_Recv(&(azimuthalBndryCellVolumes[recvOffsetsAzimuthal[i]]), recvCntAzimuthal[i], MPI_DOUBLE, i, 433,
               mpiComm(), MPI_STATUS_IGNORE, AT_, "(azimuthalBndryCellVolumes[recvOffsetsAzimuthal[i]])");
    }
    if(scnt > 0) MPI_Waitall(scnt, &sendReqAzimuthal[0], MPI_STATUSES_IGNORE, AT_);
    sendReqAzimuthal.fill(MPI_REQUEST_NULL);
    scnt = 0;
    for(MInt i = 0; i < noDomains(); i++) {
      if(sendCntAzimuthal[i] == 0) continue;
      MPI_Issend(&(azimuthalBndryCellCoordinatesTmp[nDim * sendOffsetsAzimuthal[i]]), nDim * sendCntAzimuthal[i],
                 MPI_DOUBLE, i, 434, mpiComm(), &sendReqAzimuthal[scnt], AT_,
                 "(azimuthalBndryCellCoordinatesTmp[nDim*sendOffsetsAzimuthal[i]])");
      scnt++;
    }
    for(MInt i = 0; i < noDomains(); i++) {
      if(recvCntAzimuthal[i] == 0) continue;
      MPI_Recv(&(azimuthalBndryCellCoordinates[nDim * recvOffsetsAzimuthal[i]]), nDim * recvCntAzimuthal[i], MPI_DOUBLE,
               i, 434, mpiComm(), MPI_STATUS_IGNORE, AT_,
               "(azimuthalBndryCellCoordinates[nDim*recvOffsetsAzimuthal[i]])");
    }
    if(scnt > 0) MPI_Waitall(scnt, &sendReqAzimuthal[0], MPI_STATUSES_IGNORE, AT_);

    multimap<MLong, vector<MFloat>> tmpVolAzimuthal;
    for(MInt i = 0; i < totalNoRecv; i++) {
      MLong cellId = azimuthalBndryCellVolumesIds[i];
      if(cellId >= domainOffset(domainId()) && cellId < domainOffset(domainId() + 1)) {
        vector<MFloat> tmpFloats(nDim + 1);
        for(MInt d = 0; d < nDim; d++) {
          tmpFloats[d] = azimuthalBndryCellCoordinates[i * nDim + d];
        }
        tmpFloats[nDim] = azimuthalBndryCellVolumes[i];
        tmpVolAzimuthal.insert(make_pair(cellId, tmpFloats));
      } else {
        cerr << "ERROR:" << domainId() << " " << cellId << " " << domainOffset(noDomains()) << " "
             << domainOffset(noDomains() + 1) << endl;
        mTerm(1, AT_, ": azimuthal data is broken.");
      }
    }
    MInt cnt = 0;
    MInt noFloatData = 3;
    MInt noIntData = 2;
    for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
      for(MInt j = 0; j < grid().noAzimuthalWindowCells(i); j++) {
        MInt cellId = grid().azimuthalWindowCell(i, j);
        if(tmpVolAzimuthal.count(c_globalId(cellId)) != 0) {
          MFloat cellLength = c_cellLengthAtCell(cellId);
          auto range = tmpVolAzimuthal.equal_range(c_globalId(cellId));
          for(auto it = range.first; it != range.second; ++it) {
            MBool isEqual = true;
            for(MInt d = 0; d < nDim; d++) {
              if(!approx((it->second)[d], this->m_azimuthalCartRecCoord[cnt * nDim + d],
                         m_azimuthalCornerEps * cellLength)) {
                isEqual = false;
              }
            }
            if(isEqual) {
              vector<MFloat> tmpF(noFloatData + nDim);
              vector<MUlong> tmpI(noIntData);
              tmpF[0] = this->m_azimuthalCartRecCoord[cnt * nDim];
              tmpF[1] = this->m_azimuthalCartRecCoord[cnt * nDim + 1];
              if(nDim == 3) {
                tmpF[2] = this->m_azimuthalCartRecCoord[cnt * nDim + 2];
              }
              tmpF[nDim] = (it->second)[nDim];     // cellVolume
              tmpF[nDim + 1] = (it->second)[nDim]; // cellVolume
              tmpF[nDim + 2] = 0;                  // swepVol

              tmpI[0] = 1;
              maia::fv::cell::BitsetType props = 0;
              props[maia::fv::cell::p(SolverCell::IsMovingBnd)] = true;
              props[maia::fv::cell::p(SolverCell::NearWall)] = true;
              tmpI[1] = props.to_ulong(); // cell properties
              m_azimuthalNearBoundaryBackup.insert(make_pair(cellId, make_pair(tmpF, tmpI)));

              continue;
            }
          }
        }
        cnt++;
      }
    }
    commAzimuthalPeriodicData();
  }

  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_isHalo(cellId)) {
      m_cellVolumesDt1[cellId] = a_cellVolume(cellId);
      if(m_dualTimeStepping) m_cellVolumesDt2[cellId] = a_cellVolume(cellId);
      a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
      if(mismatchCnt < 0.5 * DOF_VOL) {
        m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume = a_cellVolume(cellId);
      }
    }
  }

  cerr0 << "done" << endl;
}


/**
 * \fn void FvMbCartesianSolverXD<nDim, SysEqn>::setOldGeomBndryCellVolume()
 * \brief  set bndryCell volume from m_oldGeomBndryCells which is read from bodyRestartFile
 *         at initSolver and thus before the forcedAdaptation at the restart!
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::setOldGeomBndryCellVolume() {
  TRACE();

  MFloatScratchSpace oldVolumes(a_noCells(), 2, AT_, "oldVolumes");
  oldVolumes.fill(-1);

  for(auto it = m_oldGeomBndryCells.begin(); it != m_oldGeomBndryCells.end(); it++) {
    const MInt cellId = it->first;
    const MFloat vol = it->second;
    oldVolumes(cellId, 0) = vol;
  }

  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    oldVolumes(cellId, 1) = a_cellVolume(cellId);
  }

  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_isHalo(cellId)) continue;
    if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
    auto it0 = m_oldGeomBndryCells.find(cellId);
    if(it0 != m_oldGeomBndryCells.end()) {
      const MFloat vol = it0->second;
      m_oldGeomBndryCells.erase(it0);
      // only set volume from file, if it matches the current volume
      const MFloat volDif = fabs(a_cellVolume(cellId) - vol);
      if(volDif > 0.0001 * vol) {
        m_oldGeomBndryCells.insert(make_pair(cellId, -1));
      } else {
        a_cellVolume(cellId) = vol;
        m_cellVolumesDt1[cellId] = vol;
        if(m_dualTimeStepping) m_cellVolumesDt2[cellId] = vol;
        a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
        m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume = vol;
      }
    }
  }

  // set volumes on halo cells
  exchangeData(&a_cellVolume(0), 1);
  exchangeData(&oldVolumes[0], 2);

  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
    if(!a_isHalo(cellId)) continue;
    m_cellVolumesDt1[cellId] = a_cellVolume(cellId);
    if(m_dualTimeStepping) m_cellVolumesDt2[cellId] = a_cellVolume(cellId);
    a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
    // only update bndryCell-volume for oldGeomBndryCells
    if(oldVolumes(cellId, 0) > 0) {
      // check if the halo cell is in the list and remove the entry
      auto it0 = m_oldGeomBndryCells.find(cellId);
      if(it0 != m_oldGeomBndryCells.end()) m_oldGeomBndryCells.erase(it0);
      // only update for low volume difference
      const MFloat volDif = fabs(oldVolumes(cellId, 1) - oldVolumes(cellId, 0));
      if(volDif > 0.0001 * oldVolumes(cellId, 0)) {
        // add entry if volume differs greatly
        m_oldGeomBndryCells.insert(make_pair(cellId, -1));
      } else {
        m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume = oldVolumes(cellId, 0);
      }
    }
  }
}


/**
 * \fn void FvMbCartesianSolverXD<nDim, SysEqn>::saveBodySamples()
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::saveBodySamples() {
  TRACE();

  if(m_noEmbeddedBodies == 0) return;

  const MInt noNearBodyState = 5;
  MFloatScratchSpace particleFluidVel(m_noEmbeddedBodies, nDim, AT_, "particleFluidVel");
  MFloatScratchSpace particleFluidVelDt(m_noEmbeddedBodies, nDim, AT_, "particleFluidVelDt");
  MFloatScratchSpace particleFluidVelGrad(m_noEmbeddedBodies, nDim * nDim, AT_, "particleFluidVelGrad");
  MFloatScratchSpace particleFluidPressure(m_noEmbeddedBodies, AT_, "particleFluidPressure");
  MFloatScratchSpace particleFluidRotation(m_noEmbeddedBodies, nDim, AT_, "particleFluidRotation");
  MFloatScratchSpace particleFluidRotationDt(m_noEmbeddedBodies, nDim, AT_, "particleFluidRotationDt");
  MFloatScratchSpace particleFluidState(m_noEmbeddedBodies, noNearBodyState, AT_, "particleFluidState");
  MFloatScratchSpace bodyRotation(m_noEmbeddedBodies, 3, AT_, "bodyRotation");
  for(MInt k = 0; k < m_noEmbeddedBodies; k++) {
    getBodyRotation(k, &bodyRotation[3 * k]);
  }
  MFloat* vel = &(particleFluidVel[0]);
  MFloat* velDt = &(particleFluidVelDt[0]);
  MFloat* velGradient = &(particleFluidVelGrad[0]);
  MFloat* pressure = &(particleFluidPressure[0]);
  MFloat* rotation = &(particleFluidRotation[0]);
  MFloat* rotationDt = &(particleFluidRotationDt[0]);
  MFloat* state = &(particleFluidState[0]);

  MIntScratchSpace nearestBodies(m_maxNearestBodies * a_noCells(), AT_, "nearestBodies");
  MFloatScratchSpace nearestDist(m_maxNearestBodies * a_noCells(), AT_, "nearestDist");
  nearestBodies.fill(-1);
  nearestDist.fill(numeric_limits<MFloat>::max());
  const MFloat maxDist = 5.0 * m_bodyDiameter[0];
  MInt maxBodyCnt = constructDistance(maxDist, nearestBodies, nearestDist);
  if(maxBodyCnt > m_maxNearestBodies && domainId() == 0) {
    cerr << "constructDistance: maxBodyCnt " << maxBodyCnt << " exceeds m_maxNearestBodies " << m_maxNearestBodies
         << ". Retry with higher value." << endl;
  }

  computeNearBodyFluidVelocity(nearestBodies, nearestDist, vel, velGradient, rotation, vector<MFloat>(), nullptr, state,
                               pressure, velDt, rotationDt);

  const MLong DOF = m_noEmbeddedBodies;
  const MLong DOF_TRANS = nDim * m_noEmbeddedBodies;
  const MLong DOF_ROT = 3 * m_noEmbeddedBodies;
  const MLong DOF_QUAT = 4 * m_noEmbeddedBodies;
  const MLong DOF_GRAD = nDim * nDim * m_noEmbeddedBodies;
  const MLong DOF_STATE = (MLong)particleFluidState.size();

  MString fileName = outputDir() + "bodySamples_00" + to_string(globalTimeStep) + ParallelIo::fileExt();

  if(domainId() == 0) {
    ParallelIo::size_type count = 0;
    ParallelIo parallelIo(fileName, maia::parallel_io::PIO_REPLACE, MPI_COMM_SELF);

    parallelIo.defineScalar(maia::parallel_io::PIO_INT, "DOF");
    parallelIo.defineScalar(maia::parallel_io::PIO_FLOAT, "bodyDiameter");

    count = DOF;
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "bodyTemperature", count);
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "fluidPressure", count);

    count = DOF_TRANS;
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "bodyCenter", count);
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "bodyCenterDt1", count);
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "bodyVelocity", count);
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "bodyVelocityDt1", count);
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "bodyAcceleration", count);
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "bodyForce", count);
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "fluidVelocity", count);
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "fluidVelocityDt1", count);

    count = DOF_ROT;
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "bodyRotation", count);
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "bodyAngularVelocity", count);
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "bodyAngularVelocityDt1", count);
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "bodyAngularAcceleration", count);
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "bodyTorque", count);
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "fluidRotation", count);
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "fluidRotationDt1", count);

    count = DOF_QUAT;
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "bodyQuaternion", count);

    count = DOF_GRAD;
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "velocityGradient", count);

    count = DOF_STATE;
    parallelIo.defineArray(maia::parallel_io::PIO_FLOAT, "bodyState", count);


    parallelIo.writeScalar(DOF, "DOF");
    parallelIo.writeScalar(m_bodyDiameter[0], "bodyDiameter");

    count = DOF;
    parallelIo.setOffset(count, 0);
    parallelIo.writeArray(m_bodyTemperature, "bodyTemperature");
    parallelIo.writeArray(&(pressure[0]), "fluidPressure");

    count = DOF_TRANS;
    parallelIo.setOffset(count, 0);
    parallelIo.writeArray(m_bodyCenter, "bodyCenter");
    parallelIo.writeArray(m_bodyCenterDt1, "bodyCenterDt1");
    parallelIo.writeArray(&(m_bodyVelocity[0]), "bodyVelocity");
    parallelIo.writeArray(&(m_bodyVelocityDt1[0]), "bodyVelocityDt1");
    parallelIo.writeArray(&(m_bodyAcceleration[0]), "bodyAcceleration");
    parallelIo.writeArray(&(m_bodyForce[0]), "bodyForce");
    parallelIo.writeArray(&(vel[0]), "fluidVelocity");
    parallelIo.writeArray(&(velDt[0]), "fluidVelocityDt1");

    count = DOF_ROT;
    parallelIo.setOffset(count, 0);
    parallelIo.writeArray(&(bodyRotation[0]), "bodyRotation");
    parallelIo.writeArray(&(m_bodyAngularVelocity[0]), "bodyAngularVelocity");
    parallelIo.writeArray(&(m_bodyAngularVelocityDt1[0]), "bodyAngularVelocityDt1");
    parallelIo.writeArray(&(m_bodyAngularAcceleration[0]), "bodyAngularAcceleration");
    parallelIo.writeArray(&(m_bodyTorque[0]), "bodyTorque");
    parallelIo.writeArray(&(rotation[0]), "fluidRotation");
    parallelIo.writeArray(&(rotationDt[0]), "fluidRotationDt1");

    count = DOF_QUAT;
    parallelIo.setOffset(count, 0);
    parallelIo.writeArray(&(m_bodyQuaternion[0]), "bodyQuaternion");

    count = DOF_GRAD;
    parallelIo.setOffset(count, 0);
    parallelIo.writeArray(&(velGradient[0]), "velocityGradient");

    count = DOF_STATE;
    parallelIo.setOffset(count, 0);
    parallelIo.writeArray(&(state[0]), "bodyState");
  }
}


/**
 * \fn void FvMbCartesianSolverXD<nDim, SysEqn>::saveParticleSamples()
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::saveParticleSamples() {
  TRACE();

  if(m_noPointParticles == 0) return;

  MIntScratchSpace partOffsets(noDomains() + 1, AT_, "partOffsets");
  partOffsets(0) = 0;
  partOffsets(domainId() + 1) = m_noPointParticlesLocal;
  MPI_Allgather(&m_noPointParticlesLocal, 1, MPI_INT, &partOffsets[1], 1, MPI_INT, mpiComm(), AT_,
                "m_noPointParticlesLocal", "partOffsets[1]");
  for(MInt d = 0; d < noDomains(); d++)
    partOffsets(d + 1) += partOffsets(d);

  MFloatScratchSpace particleFluidPressure(m_noPointParticles, AT_, "particleFluidPressure");
  setParticleFluidVelocities(&(particleFluidPressure[0]));

  const MLong DOF = m_noPointParticles;
  const MLong DOF_LOC = m_noPointParticlesLocal;
  const MLong DOF_TRANS = nDim * m_noPointParticles;
  const MLong DOF_TRANS_LOC = nDim * m_noPointParticlesLocal;
  const MLong DOF_ROT = 3 * m_noPointParticles;
  const MLong DOF_ROT_LOC = 3 * m_noPointParticlesLocal;
  const MLong DOF_QUAT = 4 * m_noPointParticles;
  const MLong DOF_QUAT_LOC = 4 * m_noPointParticlesLocal;
  const MLong DOF_GRAD = nDim * nDim * m_noPointParticles;
  const MLong DOF_GRAD_LOC = nDim * nDim * m_noPointParticlesLocal;

  MString fileName = outputDir() + "partSamples_00" + to_string(globalTimeStep) + ParallelIo::fileExt();

  ParallelIo::size_type start = 0;
  ParallelIo::size_type count = 0;

  using namespace maia::parallel_io;
  ParallelIo parallelIo(fileName, PIO_REPLACE, mpiComm());

  // Creating file header.
  parallelIo.defineScalar(PIO_INT, "DOF");

  count = DOF;
  parallelIo.defineArray(PIO_FLOAT, "partFluidPressure", count);

  count = DOF_TRANS;
  parallelIo.defineArray(PIO_FLOAT, "partCenter", count);
  parallelIo.defineArray(PIO_FLOAT, "partVelocity", count);
  parallelIo.defineArray(PIO_FLOAT, "partAcceleration", count);
  parallelIo.defineArray(PIO_FLOAT, "partVelocityFluid", count);

  count = DOF_ROT;
  parallelIo.defineArray(PIO_FLOAT, "partAngularVelocity", count);
  parallelIo.defineArray(PIO_FLOAT, "partAngularAcceleration", count);

  count = DOF_QUAT;
  parallelIo.defineArray(PIO_FLOAT, "partQuaternion", count);

  count = DOF_GRAD;
  parallelIo.defineArray(PIO_FLOAT, "partVelocityGradientFluid", count);

  parallelIo.writeScalar(DOF, "DOF");

  start = (ParallelIo::size_type)(partOffsets(domainId()));
  count = (ParallelIo::size_type)DOF_LOC;
  parallelIo.setOffset(count, start);
  parallelIo.writeArray(&(particleFluidPressure[0]), "partFluidPressure");

  start = (ParallelIo::size_type)(nDim * partOffsets(domainId()));
  count = (ParallelIo::size_type)DOF_TRANS_LOC;
  parallelIo.setOffset(count, start);
  parallelIo.writeArray(m_particleCoords.data(), "partCenter");
  parallelIo.writeArray(m_particleVelocity.data(), "partVelocity");
  parallelIo.writeArray(m_particleAcceleration.data(), "partAcceleration");
  parallelIo.writeArray(m_particleVelocityFluid.data(), "partVelocityFluid");

  start = (ParallelIo::size_type)(3 * partOffsets(domainId()));
  count = (ParallelIo::size_type)DOF_ROT_LOC;
  parallelIo.setOffset(count, start);
  parallelIo.writeArray(m_particleAngularVelocity.data(), "partAngularVelocity");
  parallelIo.writeArray(m_particleAngularAcceleration.data(), "partAngularAcceleration");

  start = (ParallelIo::size_type)(4 * partOffsets(domainId()));
  count = (ParallelIo::size_type)DOF_QUAT_LOC;
  parallelIo.setOffset(count, start);
  parallelIo.writeArray(m_particleQuaternions.data(), "partQuaternion");

  start = (ParallelIo::size_type)(nDim * nDim * partOffsets(domainId()));
  count = (ParallelIo::size_type)DOF_GRAD_LOC;
  parallelIo.setOffset(count, start);
  parallelIo.writeArray(m_particleVelocityGradientFluid.data(), "partVelocityGradientFluid");
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
MString FvMbCartesianSolverXD<nDim, SysEqn>::printTime(const MFloat t) {
  stringstream time;
  time.str("");
  MFloat rem = t;
  if(rem > 86400.0) {
    const MFloat div = floor(rem / 86400.0);
    time << ((MInt)div) << " days, ";
    rem -= div * 86400.0;
  }
  if(rem > 3600.0) {
    const MFloat div = floor(rem / 3600.0);
    time << ((MInt)div) << " hours, ";
    rem -= div * 3600.0;
  }
  if(rem > 60.0) {
    const MFloat div = floor(rem / 60.0);
    time << ((MInt)div) << " mins, ";
    rem -= div * 60.0;
  }
  time << rem << " secs";
  const MString ret = time.str();
  return ret;
}


/**
 * \fn void FvMbCartesianSolverXD<nDim, SysEqn>::correctMasterSlaveSurfaces()
 * \brief Removes surfaces between master-slave pairs and
 * reassigns slave cell surfaces
 * required in order to make current MB branch version working
 * with "normal" boundaries
 *
 * @author: Claudia Guenther
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::correctMasterSlaveSurfaces() {
  TRACE();

  MInt cellId, bndryId, masterCellId;
  MInt noSurfaces = a_noSurfaces();
  MInt otherId[2] = {1, 0};

  for(MInt srfcId = 0; srfcId < noSurfaces; srfcId++) {
    for(MInt nghbrId = 0; nghbrId < 2; nghbrId++) {
      cellId = a_surfaceNghbrCellId(srfcId, nghbrId);
      if(a_bndryId(cellId) < 0) continue;

      bndryId = a_bndryId(cellId);
      // check whether the cell is a slave cell
      if(m_bndryCells->a[bndryId].m_linkedCellId == -1) continue;

      masterCellId = m_bndryCells->a[bndryId].m_linkedCellId;

      // check whether the other neighbor of the surface is the
      // master cell
      if(a_surfaceNghbrCellId(srfcId, otherId[nghbrId]) == masterCellId) {
      } else {
        // shift the Id to the master cell
        a_surfaceNghbrCellId(srfcId, nghbrId) = masterCellId;
      }
    }
  }
}


/**
 * void FvMbCartesianSolverXD<nDim, SysEqn>::checkCellState()
 * \brief checks the cell state of the inactive cells based on the nodal ls values
 * if a cell is inactive (levelSetValue < 0) but its nodal values are all positive, it
 * is set active again (important for sharp features)
 * \author Claudia Guenther
 * \date March 2011
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::checkCellState() {
  TRACE();

  for(MInt cnd = 0; cnd < m_noBndryCandidates; cnd++) {
    MInt cellId = m_bndryCandidates[cnd];

    MBool isGapCell = false;
    if(m_levelSet && m_closeGaps) {
      isGapCell = (a_hasProperty(cellId, SolverCell::IsGapCell));
    }
    MInt startSet = 0;
    MInt endSet = 1;
    if(m_complexBoundary && m_noLevelSetsUsedForMb > 1 && (!isGapCell)) {
      startSet = 1;
      endSet = m_noLevelSetsUsedForMb;
    }
    if(a_hasProperty(cellId, SolverCell::IsInactive) == false) {
      MInt minus = true;
      for(MInt node = 0; node < m_noCellNodes; node++) {
        if(m_candidateNodeValues[IDX_LSSETNODES(cnd, node, 0)] > 0) minus = false;
      }
      if(minus) {
        a_hasProperty(cellId, SolverCell::IsInactive) = true;
        a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = false;
        removeSurfaces(cellId);
      }
    } else {
      MInt plus = true;
      for(MInt node = 0; node < m_noCellNodes; node++) {
        for(MInt set = startSet; set < endSet; set++)
          if(m_candidateNodeValues[IDX_LSSETNODES(cnd, node, set)] <= 0) plus = false;
      }
      if(plus && c_isLeafCell(cellId)) {
        a_hasProperty(cellId, SolverCell::IsInactive) = false;
        a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = true;
        restoreSurfaces(cellId);
      }
    }
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
MBool FvMbCartesianSolverXD<nDim, SysEqn>::fileExists(const MChar* fileName) {
  struct stat buffer;
  return (stat(fileName, &buffer) == 0);
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
MInt FvMbCartesianSolverXD<nDim, SysEqn>::copyFile(const MChar* fromName, const MChar* toName) {
  if(!fileExists(fromName)) {
    cerr << "Could not copy file " << fromName << "." << endl;
    return -1;
  }
  if(fileExists(toName)) {
    remove(toName);
  }
  ifstream src(fromName);
  ofstream dst(toName);
  if(src.good() && dst.good()) {
    dst << src.rdbuf();
    dst.close();
    dst.clear();
    src.close();
    src.clear();
  } else {
    cerr << "Could not copy file " << fromName << " (2)." << endl;
    return -1;
  }
  return 0;
}


/**
 * \brief
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::writeStencil(const MInt bndryId) {
  TRACE();

#ifdef DOUBLE_PRECISION_OUTPUT
  const char* const dataType = "Float64";
#else
  const char* const dataType = "Float32";
#endif
  const char* const iDataType = "Int32";
  const char* const uIDataType = "UInt32";

  const MString fileName = "stencil_b" + to_string(bndryId) + "_D" + to_string(domainId()) + ".vtp";
  const MUint noPoints = m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.size();
  const MUint noLines = noPoints - 1;
  const MUint noSrfcs = m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs;
  const MUint noRecNghbrs = m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.size();
  for(MInt srfc = 0; srfc < mMin((signed)noRecNghbrs, (signed)noSrfcs); srfc++) {
    for(MInt v = 0; v < m_noPVars; v++) {
      a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[srfc], v) =
          m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[v];
    }
  }

  ofstream ofl;
  ofl.open(fileName.c_str(), ios_base::out | ios_base::trunc);

  if(ofl.is_open() && ofl.good()) {
    // VTKFile
    ofl << "<?xml version=\"1.0\"?>" << endl;
    ofl << "<VTKFile type=\"PolyData\" version=\"0.1\" byte_order=\"LittleEndian\">" << endl;
    ofl << "<PolyData>" << endl;

    // Dimensions
    ofl << "<Piece NumberOfPoints=\"" << noPoints << "\" NumberOfVerts=\"" << 1 << "\" NumberOfLines=\"" << noLines
        << "\">" << endl;

    // Points
    ofl << "<Points>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" NumberOfComponents=\"3\" format=\"ascii\">" << endl;
    for(MInt i = 0; i < nDim; i++) {
      ofl << a_coordinate(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[noSrfcs], i) << " ";
    }
    IF_CONSTEXPR(nDim == 2) ofl << "0.0 ";
    ofl << endl;
    for(MUint srfc = 0; srfc < noSrfcs; srfc++) {
      for(MInt i = 0; i < nDim; i++) {
        ofl << a_coordinate(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId, i) << " ";
      }
      IF_CONSTEXPR(nDim == 2) ofl << "0.0 ";
      ofl << endl;
    }
    for(MUint n = noSrfcs + 1; n < noPoints; n++) {
      MInt nghbrId = m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n];
      for(MInt i = 0; i < nDim; i++) {
        ofl << a_coordinate(nghbrId, i) << " ";
      }
      IF_CONSTEXPR(nDim == 2) ofl << "0.0 ";
      ofl << endl;
    }
    ofl << "</DataArray>" << endl;
    ofl << "</Points>" << endl;

    // Verts
    ofl << "<Verts>" << endl;
    ofl << "<DataArray type=\"" << iDataType << "\" Name=\"connectivity\" format=\"ascii\">" << endl;
    ofl << "0" << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << uIDataType << "\" Name=\"offsets\" format=\"ascii\">" << endl;
    ofl << "1" << endl;
    ofl << "</DataArray>" << endl;
    ofl << "</Verts>" << endl;

    // Lines
    ofl << "<Lines>" << endl;
    ofl << "<DataArray type=\"" << iDataType << "\" Name=\"connectivity\" format=\"ascii\">" << endl;
    for(MUint n = 0; n < noLines; n++) {
      ofl << "0 " << n + 1 << " ";
    }
    ofl << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << uIDataType << "\" Name=\"offsets\" format=\"ascii\">" << endl;
    for(MUint n = 0; n < noLines; n++) {
      ofl << 2 * (n + 1) << " ";
    }
    ofl << endl;
    ofl << "</DataArray>" << endl;
    ofl << "</Lines>" << endl;

    // CellData
    ofl << "<CellData Scalars=\"scalars\">" << endl;

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"weights0\" format=\"ascii\">" << endl;
    ofl << m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * noSrfcs] << " ";
    for(MUint srfc = 0; srfc < noSrfcs; srfc++)
      ofl << m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * srfc] << " ";
    for(MUint n = noSrfcs + 1; n < noPoints; n++)
      ofl << m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * n] << " ";
    ofl << endl;
    ofl << "</DataArray>" << endl;

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"weights1\" format=\"ascii\">" << endl;
    ofl << m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * noSrfcs + IPOW2(noSrfcs) - 1] << " ";
    for(MUint srfc = 0; srfc < noSrfcs; srfc++)
      ofl << m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * srfc + IPOW2(noSrfcs) - 1] << " ";
    for(MUint n = noSrfcs + 1; n < noPoints; n++)
      ofl << m_fvBndryCnd->m_bndryCell[bndryId].m_cellVarsRecConst[IPOW2(noSrfcs) * n + IPOW2(noSrfcs) - 1] << " ";
    ofl << endl;
    ofl << "</DataArray>" << endl;

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"weights\" format=\"ascii\">" << endl;
    ofl << m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_imagePointRecConst[noSrfcs] << " ";
    for(MUint n = 0; n < noSrfcs; n++)
      ofl << m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_imagePointRecConst[n] << " ";
    for(MUint n = noSrfcs + 1; n < noPoints; n++)
      ofl << m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_imagePointRecConst[n] << " ";
    ofl << endl;
    ofl << "</DataArray>" << endl;

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"u\" format=\"ascii\">" << endl;
    ofl << a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[noSrfcs], PV->U) << " ";
    for(MUint n = 0; n < noSrfcs; n++)
      ofl << a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n], PV->U) << " ";
    for(MUint n = noSrfcs + 1; n < noPoints; n++)
      ofl << a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n], PV->U) << " ";
    ofl << endl;
    ofl << "</DataArray>" << endl;

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"v\" format=\"ascii\">" << endl;
    ofl << a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[noSrfcs], PV->V) << " ";
    for(MUint n = 0; n < noSrfcs; n++)
      ofl << a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n], PV->V) << " ";
    for(MUint n = noSrfcs + 1; n < noPoints; n++)
      ofl << a_pvariable(m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n], PV->V) << " ";
    ofl << endl;
    ofl << "</DataArray>" << endl;

    ofl << "<DataArray type=\"" << iDataType << "\" Name=\"id\" format=\"ascii\">" << endl;
    ofl << noSrfcs << " ";
    for(MUint n = 0; n < noSrfcs; n++)
      ofl << n << " ";
    for(MUint n = noSrfcs + 1; n < noPoints; n++)
      ofl << n << " ";
    ofl << endl;
    ofl << "</DataArray>" << endl;
    ofl << "</CellData>" << endl;

    ofl << "</Piece>" << endl;
    ofl << "</PolyData>" << endl;

    ofl << "</VTKFile>" << endl;
    ofl.close();
    ofl.clear();
  } else {
    cerr << "ERROR! COULD NOT OPEN FILE " << fileName << " for writing! (3)" << endl;
  }
}


/// \brief Check for divergence in case we use _MB_DEBUG_ or debug.
/// \author Lennart Schneiders
template <MInt nDim, class SysEqn>
inline void FvMbCartesianSolverXD<nDim, SysEqn>::checkDiv() {
#if defined _MB_DEBUG_ || !defined NDEBUG
  // needs to be int for mpi
  MInt solutionDiverged = 0;
  MInt cnt = 0;

  for(MInt i = a_noCells(); i--;) {
    if(cnt >= 100) break;
    if(!a_hasProperty(i, SolverCell::IsActive)) continue;
    if(!a_hasProperty(i, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_isHalo(i)) continue;
    if(a_isBndryGhostCell(i)) continue;

    for(MInt v = 0; v < noVariables(); v++) {
      if(!(a_variable(i, v) >= F0 || a_variable(i, v) < F0) || std::isnan(a_variable(i, v))) {
        cerr << domainId() << ": LHSB " << c_globalId(i) << " " << a_bndryId(i) << " " << a_level(i) << " " << v << " "
             << a_variable(i, v) << " "
             << "cells[i].b_properties.to_string()"
             << " /v " << a_cellVolume(i) / grid().gridCellVolume(c_level(i)) << " "
             << m_cellVolumesDt1[i] / grid().gridCellVolume(c_level(i)) << " "
             << a_hasProperty(i, SolverCell::IsSplitCell) << " " << a_hasProperty(i, SolverCell::IsSplitChild) << " "
             << a_isPeriodic(i) << " " << a_coordinate(i, 0) << " " << a_coordinate(i, 1) << " "
             << a_coordinate(i, mMin(nDim - 1, 2)) << " " << a_levelSetValuesMb(i, 0) << " /v "
             << a_cellVolume(i) * a_FcellVolume(i) << " " << m_cellVolumesDt1[i] * a_FcellVolume(i) << endl;
        solutionDiverged = 1;
        cnt++;
      }
    }

    // setPrimitiveVariables(i);
    if(a_cellVolume(i) / grid().gridCellVolume(a_level(i)) > m_fvBndryCnd->m_volumeLimitWall) {
      if(a_pvariable(i, maia::fv::PrimitiveVariables<nDim>::RHO) < F0
         || a_pvariable(i, maia::fv::PrimitiveVariables<nDim>::P) < F0) {
        cerr << domainId() << ": LHSB(2) " << i << " " << c_globalId(i) << " " << a_bndryId(i) << " " << a_level(i)
             << " /r " << a_pvariable(i, maia::fv::PrimitiveVariables<nDim>::RHO) << " /p "
             << a_pvariable(i, maia::fv::PrimitiveVariables<nDim>::P) << " /v "
             << a_cellVolume(i) / grid().gridCellVolume(c_level(i)) << " "
             << m_cellVolumesDt1[i] / grid().gridCellVolume(c_level(i)) << " "
             << "cells[i].b_properties.to_string()"
             << " " << a_hasProperty(i, SolverCell::IsSplitCell) << " " << a_hasProperty(i, SolverCell::IsSplitChild)
             << " " << a_isPeriodic(i) << " " << a_coordinate(i, 0) << " " << a_coordinate(i, 1) << " "
             << a_coordinate(i, mMin(nDim - 1, 2)) << " /v " << a_cellVolume(i) * a_FcellVolume(i) << " "
             << m_cellVolumesDt1[i] * a_FcellVolume(i) << endl;
        solutionDiverged = 1;
        cnt++;
      }
    }
  }

  if(cnt >= 10) cerr << "More than 10 errors. Not reporting any more." << endl;
  if(solutionDiverged == 1) {
    cerr << "Solution diverged (LHSB) at solver " << domainId() << " " << globalTimeStep << " " << m_RKStep << endl;
    // writeVtkErrorFile();
  }

  MPI_Allreduce(MPI_IN_PLACE, &solutionDiverged, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                "solutionDiverged");
  if(solutionDiverged == 1) {
    writeVtkXmlFiles("QOUT", "GEOM", false, true);
    MPI_Barrier(mpiComm(), AT_);
    mTerm(1, "Solution diverged after LHSB handling.");
  }

#endif
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::determineCoupling(MFloatScratchSpace& coupling) {
  TRACE();

  coupling.fill(F0);
  const MInt noBCells = m_fvBndryCnd->m_bndryCells->size();
  MFloat couplingCheck = F0;

  for(MInt bndryId = m_noOuterBndryCells; bndryId < noBCells; bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;

    if(a_isHalo(cellId)) continue;
    if(a_isBndryGhostCell(cellId)) continue;
    if(!a_hasProperty(cellId, SolverCell::IsSplitChild) && c_noChildren(cellId) > 0) continue;
    if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;

    MFloatScratchSpace dummyPvariables(m_bndryCells->a[bndryId].m_noSrfcs, PV->noVariables, AT_, "dummyPvariables");
    for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area < 1e-14) continue;
      MFloat rhoSurface = F0;
      MFloat pSurface = F0;
      for(MInt s = 0; s < mMin((signed)m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.size(),
                               m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs);
          s++) {
        dummyPvariables(s, PV->P) = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[s]->m_primVars[PV->P];
        dummyPvariables(s, PV->RHO) = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[s]->m_primVars[PV->RHO];
      }
      for(MInt n = 0; n < (signed)m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds.size(); n++) {
        const MInt nghbrId = m_fvBndryCnd->m_bndryCell[bndryId].m_recNghbrIds[n];
        const MFloat nghbrPvariableP = (n < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs)
                                           ? dummyPvariables(n, PV->P)
                                           : a_pvariable(nghbrId, PV->P);
        const MFloat nghbrPvariableRho = (n < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs)
                                             ? dummyPvariables(n, PV->RHO)
                                             : a_pvariable(nghbrId, PV->RHO);
        rhoSurface +=
            m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst[n] * nghbrPvariableRho;
        pSurface += m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_imagePointRecConst[n] * nghbrPvariableP;
      }
      MFloat normal0[3] = {F0, F0, F0};
      for(MInt i = 0; i < nDim; i++) {
        normal0[i] = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
      }
      MFloat T = sysEqn().temperature_ES(rhoSurface, pSurface);
      MFloat mue = SUTHERLANDLAW(T);
      MFloat area = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
      for(MInt i = 0; i < nDim; i++) {
        const MFloat dp0 = -pSurface * normal0[i] * area;
        MFloat grad = m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[PV->VV[i]];
        for(MInt j = 0; j < nDim; j++)
          grad += F1B3 * normal0[i] * normal0[j]
                  * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_normalDeriv[PV->VV[j]];
        MFloat ds0 = mue * grad * area / sysEqn().m_Re0;
        coupling(cellId, i) -= (dp0 + ds0);
        couplingCheck -= (dp0 + ds0) * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]];
      }
    }
  }
  exchangeDataFV(&coupling[0], nDim, false);

  MPI_Allreduce(MPI_IN_PLACE, &couplingCheck, 1, MPI_DOUBLE, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "couplingCheck");
  return couplingCheck;
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::computeSlipStatistics(const MIntScratchSpace& nearestBodies,
                                                                const MFloatScratchSpace& nearestDist,
                                                                const MFloat maxDistConstructed) {
  TRACE();

  MInt noParticlesGlobal = mMax(m_noPointParticles, m_noEmbeddedBodies);
  if(noParticlesGlobal == 0) return;
  const MFloat DX = (m_bbox[nDim] - m_bbox[0]);
  const MFloat epsRef = DX / (POW3(m_UInfinity));
  MInt noParticles = mMax(m_noPointParticlesLocal, m_noEmbeddedBodies);
  MIntScratchSpace particleOffsets(noDomains() + 1, AT_, "particleOffsets");
  particleOffsets(0) = 0;

  for(MLong dom = 0; dom < noDomains(); dom++) {
    MLong tmpv = (((MLong)noParticlesGlobal) * (dom + 1)) / ((MLong)noDomains());
    if(tmpv > numeric_limits<MInt>::max()) mTerm(1, "MInt overflow");
    particleOffsets(dom + 1) = (MInt)tmpv;
  }
  if(m_noEmbeddedBodies > 0) noParticles = particleOffsets(domainId() + 1) - particleOffsets(domainId());

  // Memory for computeNearBodyFluidVelocity
  MFloatScratchSpace velMem(mMax(1, m_noEmbeddedBodies) * nDim, AT_, "velMem");
  MFloatScratchSpace velGradMem(mMax(1, m_noEmbeddedBodies) * nDim * nDim, AT_, "velGradMem");
  MFloatScratchSpace particleFluidRotationMem(mMax(1, m_noEmbeddedBodies), nDim, AT_, "particleFluidRotationMem");
  MIntScratchSpace skipBodies((m_noPointParticles > 0 ? 1 : m_noEmbeddedBodies), AT_, "skipBodies");
  // Memory for Lagrangian point-particles
  MFloatScratchSpace pointParticleForceMem(mMax(1, (m_noPointParticles > 0 ? noParticles : -1)), nDim, AT_,
                                           "pointParticleForceMem");
  MFloatScratchSpace pointParticleTorqueMem(mMax(1, (m_noPointParticles > 0 ? noParticles : -1)), nDim, AT_,
                                            "pointParticleTorqueMem");
  const MFloat distWidth = F1; // scaled with m_bodyDiameter[0]
  const MFloat minDistBound = 0.5;
  const MFloat maxDistBound = 2.5;
  const MFloat correctionBuffer = 1.0;
  const MFloat maxAngleBound = 0.5 + correctionBuffer;
  const MFloat minAngleBound = -0.5 + correctionBuffer;
  const MInt noAngleSetups = (m_noPointParticles > 0 ? 1 : 3);
  const MInt noDistSetups = (m_noPointParticles > 0 ? 1 : 3);
  struct gradRot {
    MFloat grad = F0;
    MFloat rotation = F0;
  };
  for(MInt i = 0; i < noAngleSetups; i++) {
    MFloat maxAngle = (maxAngleBound - minAngleBound) / mMax((MFloat)noAngleSetups - 1, F1) * i + minAngleBound;
    maxAngle -= correctionBuffer;
    if(m_noPointParticles > 0) maxAngle = 1.0;
    for(MInt j = 0; j < noDistSetups; j++) {
      MFloat* fluidVel = nullptr;
      MFloat* fluidVelGrad = nullptr;
      MFloat* fluidRotation = nullptr;
      MFloat* particleVelocity = nullptr;
      MFloat* particleAngularVelocity = nullptr;
      MFloat* particleQuaternion = nullptr;
      MFloat* particleForce = nullptr;
      MFloat* particleTorque = nullptr;
      MFloat minDist = F1;
      MFloat maxDist = F1;
      if(m_noEmbeddedBodies > 0) {
        minDist = (maxDistBound - minDistBound) / mMax((MFloat)noDistSetups - 1, F1) * j
                  + minDistBound; // distances are scaled with body diameter afterwards
        maxDist = minDist + distWidth;
        if(maxDist * m_bodyDiameter[0] > maxDistConstructed && domainId() == 0)
          cerr << "Warning slip statistics: maxDist " << maxDist << " exceeds maxDistConstructed " << maxDistConstructed
               << endl;
        vector<MFloat> setup = {minDist, maxDist, maxAngle, maxAngle}; // use the same angles for velocity and rotation
        fluidVel = &velMem[0];
        fluidVelGrad = &velGradMem[0];
        fluidRotation = &particleFluidRotationMem[0];
        particleVelocity = &m_bodyVelocity[0];
        particleAngularVelocity = &m_bodyAngularVelocity[0];
        particleQuaternion = &m_bodyQuaternion[0];
        particleForce = &m_hydroForce[0];
        particleTorque = &m_bodyTorque[0];
        computeNearBodyFluidVelocity(nearestBodies, nearestDist, &fluidVel[0], &fluidVelGrad[0], &fluidRotation[0],
                                     setup, &skipBodies[0]);
      } else if(m_noPointParticles > 0) {
        setParticleFluidVelocities();
        fluidVel = &(m_particleVelocityFluid[0]);
        fluidVelGrad = &(m_particleVelocityGradientFluid[0]);
        particleVelocity = &m_particleVelocity[0];
        particleAngularVelocity = &m_particleAngularVelocity[0];
        particleQuaternion = &m_particleQuaternions[0];
        for(MInt p = 0; p < noParticles; p++) {
          const MFloat pmass = F4B3 * PI * m_particleRadii[3 * p] * m_particleRadii[3 * p + 1]
                               * m_particleRadii[3 * p + 2] * m_densityRatio * m_rhoInfinity;
          const MFloat Ix = F1B5 * (POW2(m_particleRadii[3 * p + 1]) + POW2(m_particleRadii[3 * p + 2])) * pmass;
          const MFloat Iy = F1B5 * (POW2(m_particleRadii[3 * p + 0]) + POW2(m_particleRadii[3 * p + 2])) * pmass;
          const MFloat Iz = F1B5 * (POW2(m_particleRadii[3 * p + 0]) + POW2(m_particleRadii[3 * p + 1])) * pmass;
          const MFloat momI[3] = {Ix, Iy, Iz};
          for(MInt dim = 0; dim < nDim; dim++) {
            MInt id0 = (dim + 1) % 3;
            MInt id1 = (id0 + 1) % 3;
            pointParticleForceMem[nDim * p + dim] = pmass * m_particleAcceleration[nDim * p + dim];
            pointParticleTorqueMem[nDim * p + dim] = momI[dim] * m_particleAngularAcceleration[3 * p + dim];
            particleFluidRotationMem[nDim * p + dim] =
                F1B2 * (fluidVelGrad[9 * p + 3 * id1 + id0] - fluidVelGrad[9 * p + 3 * id0 + id1]);
          }
        }
        particleForce = &pointParticleForceMem[0];
        particleTorque = &pointParticleTorqueMem[0];
        fluidRotation = &particleFluidRotationMem[0];
      }

      //  Generate time resolved statistics using particle slip data here
      MInt cnt = 0;
      MFloat meanPartVel = F0;
      MFloat meanPartAngularVel = F0;
      MFloat Rep = F0;
      MFloat lin_diss = F0;
      MFloat FUf = F0;
      MFloat FVp = F0;
      gradRot nearParticleRot;
      gradRot rot_diss;
      gradRot meanOmega;
      gradRot meanOmegaRel;
      gradRot TOmegaF;
      MFloat TOmegaP = F0;
      for(MInt p = 0; p < noParticles; p++) {
        if(m_noEmbeddedBodies > 0) {
          p += particleOffsets(domainId());
          if(skipBodies[p]) continue;
        }
        const MFloat refRad =
            (m_noPointParticles > 0
                 ? pow(m_particleRadii[3 * p + 0] * m_particleRadii[3 * p + 1] * m_particleRadii[3 * p + 2], F1B3)
                 : pow(m_bodyRadii[nDim * p + 0] * m_bodyRadii[nDim * p + 1] * m_bodyRadii[nDim * p + 2], F1B3));
        const MFloat diameter = F2 * refRad;
        MFloat partVel = F0;
        MFloat partAngularVel = F0;
        MFloat omegaGrad = F0;
        MFloat omegaRotation = F0;
        MFloat omegaRelGrad = F0;
        MFloat meanOmegaRelRotation = F0;
        MFloat vrelAbs = F0;
        vector<MFloat> vrel(nDim);
        vector<gradRot> omegaRel(nDim);
        for(MInt dim = 0; dim < nDim; dim++) {
          vrel[dim] = fluidVel[nDim * p + dim] - particleVelocity[nDim * p + dim];
          vrelAbs += POW2(vrel[dim]);
          lin_diss += particleForce[nDim * p + dim] * vrel[dim];
          partVel += POW2(particleVelocity[nDim * p + dim]);
          FUf += particleForce[p * nDim + dim] * fluidVel[nDim * p + dim];
          FVp += particleForce[p * nDim + dim] * particleVelocity[nDim * p + dim];

          // rotationional dynamics
          MInt id0 = (dim + 1) % nDim;
          MInt id1 = (id0 + 1) % nDim;
          nearParticleRot.grad =
              F1B2
              * (fluidVelGrad[POW2(nDim) * p + nDim * id1 + id0] - fluidVelGrad[POW2(nDim) * p + nDim * id0 + id1]);
          nearParticleRot.rotation = fluidRotation[p * nDim + dim];
          omegaRel[dim].grad = nearParticleRot.grad - particleAngularVelocity[p * nDim + dim];
          omegaRel[dim].rotation = nearParticleRot.rotation - particleAngularVelocity[p * nDim + dim];
          rot_diss.grad += particleTorque[nDim * p + dim] * omegaRel[dim].grad;
          rot_diss.rotation += particleTorque[nDim * p + dim] * omegaRel[dim].rotation;
          omegaGrad += POW2(nearParticleRot.grad);
          omegaRotation += POW2(nearParticleRot.rotation);
          omegaRelGrad += POW2(omegaRel[dim].grad);
          meanOmegaRelRotation += POW2(omegaRel[dim].rotation);
          partAngularVel += POW2(particleAngularVelocity[p * nDim + dim]);
          TOmegaF.grad += particleTorque[nDim * p + dim] * nearParticleRot.grad;
          TOmegaF.rotation += particleTorque[nDim * p + dim] * nearParticleRot.rotation;
          TOmegaP += particleTorque[nDim * p + dim] * particleAngularVelocity[p * nDim + dim];
        }
        meanPartVel += sqrt(partVel);
        meanPartAngularVel += sqrt(partAngularVel);
        meanOmega.grad += sqrt(omegaGrad);
        meanOmega.rotation += sqrt(omegaRotation);
        meanOmegaRel.grad += sqrt(omegaRelGrad);
        meanOmegaRel.rotation += sqrt(meanOmegaRelRotation);
        Rep += sqrt(vrelAbs) * diameter * m_rhoInfinity * sysEqn().m_Re0 / sysEqn().m_muInfinity;
        cnt++;
      }

      vector<MFloat> communicateData = {lin_diss,
                                        FUf,
                                        FVp,
                                        rot_diss.grad,
                                        rot_diss.rotation,
                                        meanPartVel,
                                        Rep,
                                        meanOmega.grad,
                                        meanOmega.rotation,
                                        meanOmegaRel.grad,
                                        meanOmegaRel.rotation,
                                        meanPartAngularVel,
                                        TOmegaF.grad,
                                        TOmegaF.rotation,
                                        TOmegaP};
      MPI_Allreduce(MPI_IN_PLACE, &cnt, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "cnt");
      MPI_Allreduce(MPI_IN_PLACE, communicateData.data(), communicateData.size(), MPI_DOUBLE, MPI_SUM, mpiComm(), AT_,
                    "MPI_IN_PLACE", "communicateData.data()");
      MUint id = 0;
      lin_diss = (epsRef / POW3(DX)) * communicateData[id++];
      FUf = (epsRef / POW3(DX)) * communicateData[id++];
      FVp = (epsRef / POW3(DX)) * communicateData[id++];
      rot_diss.grad = (epsRef / POW3(DX)) * communicateData[id++];
      rot_diss.rotation = (epsRef / POW3(DX)) * communicateData[id++];
      meanPartVel = communicateData[id++] / (m_UInfinity * cnt);
      Rep = communicateData[id++];
      meanOmega.grad = (DX / (m_UInfinity * cnt)) * communicateData[id++];
      meanOmega.rotation = (DX / (m_UInfinity * cnt)) * communicateData[id++];
      meanOmegaRel.grad = (DX / (m_UInfinity * cnt)) * communicateData[id++];
      meanOmegaRel.rotation = (DX / (m_UInfinity * cnt)) * communicateData[id++];
      meanPartAngularVel = (DX / (m_UInfinity * cnt)) * communicateData[id++];
      TOmegaF.grad = (epsRef / POW3(DX)) * communicateData[id++];
      TOmegaF.rotation = (epsRef / POW3(DX)) * communicateData[id++];
      TOmegaP = (epsRef / POW3(DX)) * communicateData[id++];

      if(id != communicateData.size()) mTerm(1, AT_, "Communication messed up in slipStatistics;");
      if(domainId() == 0) {
        ofstream ofl;
        ofl.open("slipStatistics_angle_" + to_string(maxAngle) + "_minDist_" + to_string(minDist),
                 ios_base::out | ios_base::app);
        MString seperator = "     ";
        if(ofl.is_open() && ofl.good()) {
          if(!m_restart && m_printHeaderSlip) {
            ofl << "# 1:ts 2:time 3:physicalTime "
                << " 4:maxAngle 5:minDist 6:maxDist 7:noBodies "
                << " 8:Rep(m)"
                << " 9:linDiss(m)"
                << " 10:rotDiss(G) 11:rotDiss(R)"
                << " 12:meanOmega(G) 13:meanOmega(R)"
                << " 14:meanOmegaRel(G) 15:meanOmega(R)"
                << " 16:meanPartVel 17:meanPartAngularVal "
                << " 18:F*U_f(m)  19:F*v_P "
                << " 20:T*O_f(G) 21:T*O_f(R) 22:T*O_p "
                << " " << endl;
            m_printHeaderSlip = false;
          }
          ofl << globalTimeStep << " " << m_time << " " << m_physicalTime << seperator << " " << maxAngle << " "
              << minDist << " " << maxDist << " " << cnt << seperator << " " << Rep / MFloat(cnt) << " " << lin_diss
              << " " << rot_diss.grad << " " << rot_diss.rotation << " " << meanOmega.grad << " " << meanOmega.rotation
              << " " << meanOmegaRel.grad << " " << meanOmegaRel.rotation << " " << meanPartVel << " "
              << meanPartAngularVel << " " << FUf << " " << FVp << " " << TOmegaF.grad << " " << TOmegaF.rotation << " "
              << TOmegaP << endl;
          ofl.close();
        }
      }

      if(m_saveSlipInterval > 0) {
        MInt noTimeStepsSaved = m_slipDataTimeSteps.size();
        for(MInt p = 0; p < noParticles; p++) {
          MInt globalPId = p + particleOffsets(domainId());
          if(i == 0 && j == 0) {
            for(MInt dim = 0; dim < nDim; dim++) {
              m_slipDataParticleVel[nDim * noParticles * noTimeStepsSaved + p * nDim + dim] =
                  (!(skipBodies[globalPId] == 1) ? particleVelocity[globalPId * nDim + dim] : -1234);
              m_slipDataParticleForce[nDim * noParticles * noTimeStepsSaved + p * nDim + dim] =
                  (!(skipBodies[globalPId] == 1) ? particleForce[globalPId * nDim + dim] : -1234);
              m_slipDataParticlePosition[nDim * noParticles * noTimeStepsSaved + p * nDim + dim] =
                  m_bodyCenter[globalPId * nDim + dim];
            }
            for(MInt dim = 0; dim < 4; dim++) {
              m_slipDataParticleQuaternion[4 * noParticles * noTimeStepsSaved + p * 4 + dim] =
                  (!(skipBodies[globalPId] == 1) ? particleQuaternion[globalPId * 4 + dim] : -1234);
            }
            for(MInt dim = 0; dim < nDim; dim++) {
              m_slipDataParticleAngularVel[nDim * noParticles * noTimeStepsSaved + p * nDim + dim] =
                  (!(skipBodies[globalPId] == 1) ? particleAngularVelocity[globalPId * nDim + dim] : -1234);
              m_slipDataParticleTorque[nDim * noParticles * noTimeStepsSaved + p * nDim + dim] =
                  (!(skipBodies[globalPId] == 1) ? particleTorque[globalPId * nDim + dim] : -1234);
            }
          }
          for(MInt dim = 0; dim < nDim; dim++) {
            m_slipDataParticleFluidVel[noTimeStepsSaved * noParticles * nDim * m_noDistSetups * m_noAngleSetups
                                       + p * m_noDistSetups * m_noAngleSetups * nDim + i * nDim * m_noDistSetups
                                       + j * nDim + dim] =
                (!(skipBodies[globalPId] == 1) ? fluidVel[globalPId * nDim + dim] : -1234);
            m_slipDataParticleFluidVelRot[noTimeStepsSaved * noParticles * nDim * m_noDistSetups * m_noAngleSetups
                                          + p * m_noDistSetups * m_noAngleSetups * nDim + i * nDim * m_noDistSetups
                                          + j * nDim + dim] =
                (!(skipBodies[globalPId] == 1) ? fluidRotation[globalPId * nDim + dim] : -1234);
          }
          for(MInt dim = 0; dim < POW2(nDim); dim++) {
            m_slipDataParticleFluidVelGrad[noTimeStepsSaved * noParticles * POW2(nDim) * m_noDistSetups
                                               * m_noAngleSetups
                                           + p * m_noDistSetups * m_noAngleSetups * POW2(nDim)
                                           + i * POW2(nDim) * m_noDistSetups + j * POW2(nDim) + dim] =
                (!(skipBodies[globalPId] == 1) ? fluidVelGrad[globalPId * POW2(nDim) + dim] : -1234);
          }
        }
      }
    }
  }
  if(m_saveSlipInterval > 0) {
    m_slipDataTimeSteps.push_back(globalTimeStep);
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::saveParticleSlipData() {
  TRACE();

  MInt noTimeStepsSaved = m_slipDataTimeSteps.size();
  if(noTimeStepsSaved == 0) return;
  MInt noLocalParticles = m_particleOffsets[domainId() + 1] - m_particleOffsets[domainId()];
  MInt noGlobalParticles = m_noEmbeddedBodies;
  MInt noSetups = m_noAngleSetups * m_noDistSetups;
  MFloatScratchSpace outputParticleVel(mMax(1, noLocalParticles) * nDim * noTimeStepsSaved, AT_, "outputParticleVel");
  MFloatScratchSpace outputParticleAngularVel(mMax(1, noLocalParticles) * nDim * noTimeStepsSaved, AT_,
                                              "outputParticleAngularVel");
  MFloatScratchSpace outputParticleQuaternion(mMax(1, noLocalParticles) * 4 * noTimeStepsSaved, AT_,
                                              "outputParticleQuaternion");
  MFloatScratchSpace outputVel(mMax(1, noLocalParticles) * nDim * noTimeStepsSaved * noSetups, AT_, "outputVel");
  MFloatScratchSpace outputVelGrad(mMax(1, noLocalParticles) * POW2(nDim) * noTimeStepsSaved * noSetups, AT_,
                                   "outputVelGrad");
  MFloatScratchSpace outputParticleFluidRotation(mMax(1, noLocalParticles) * nDim * noTimeStepsSaved * noSetups, AT_,
                                                 "outputParticleFluidRotation");
  MFloatScratchSpace outputParticleForce(mMax(1, noLocalParticles) * nDim * noTimeStepsSaved, AT_,
                                         "outputParticleForce");
  MFloatScratchSpace outputParticleTorque(mMax(1, noLocalParticles) * nDim * noTimeStepsSaved, AT_,
                                          "outputParticleTorque");
  MFloatScratchSpace outputParticlePosition(mMax(1, noLocalParticles) * nDim * noTimeStepsSaved, AT_,
                                            "outputParticlePosition");
  MIntScratchSpace outputCollision(mMax(1, noLocalParticles) * noTimeStepsSaved, AT_, "outputCollision");
  outputParticleVel.fill(F0);
  outputParticleAngularVel.fill(F0);
  outputParticleQuaternion.fill(-F1);
  outputVel.fill(F0);
  outputVelGrad.fill(F0);
  outputParticleFluidRotation.fill(F0);
  outputParticleForce.fill(F0);
  outputParticlePosition.fill(F0);
  outputParticleTorque.fill(F0);
  outputCollision.fill(0);

  MIntScratchSpace localToGlobal(mMax(1, noLocalParticles) * noTimeStepsSaved, AT_, "localToGlobal");
  MIntScratchSpace particleGlobalId(mMax(1, noLocalParticles), AT_, "particleGlobalId");
  for(MInt p = 0; p < noLocalParticles; p++) {
    particleGlobalId(p) = p + m_particleOffsets[domainId()];
  }
  for(MInt ts = 0; ts < noTimeStepsSaved; ts++) {
    for(MInt p = 0; p < noLocalParticles; p++) {
      localToGlobal(ts * noLocalParticles + p) = ts * noGlobalParticles + particleGlobalId(p);
    }
  }
  MIntScratchSpace dataOffsets(noDomains() + 1, AT_, "dataOffsets");
  for(MLong dom = 0; dom < noDomains() + 1; dom++) {
    dataOffsets(dom) = noTimeStepsSaved * m_particleOffsets[dom];
  }

  maia::mpi::communicateGlobalyOrderedData(&m_slipDataParticleVel[0], noLocalParticles * noTimeStepsSaved,
                                           noGlobalParticles * noTimeStepsSaved, 1, nDim, noDomains(), domainId(),
                                           mpiComm(), localToGlobal, dataOffsets, outputParticleVel);
  maia::mpi::communicateGlobalyOrderedData(&m_slipDataParticleAngularVel[0], noLocalParticles * noTimeStepsSaved,
                                           noGlobalParticles * noTimeStepsSaved, 1, nDim, noDomains(), domainId(),
                                           mpiComm(), localToGlobal, dataOffsets, outputParticleAngularVel);
  maia::mpi::communicateGlobalyOrderedData(&m_slipDataParticleQuaternion[0], noLocalParticles * noTimeStepsSaved,
                                           noGlobalParticles * noTimeStepsSaved, 1, 4, noDomains(), domainId(),
                                           mpiComm(), localToGlobal, dataOffsets, outputParticleQuaternion);
  maia::mpi::communicateGlobalyOrderedData(&m_slipDataParticleFluidVel[0], noLocalParticles * noTimeStepsSaved,
                                           noGlobalParticles * noTimeStepsSaved, 1, nDim * noSetups, noDomains(),
                                           domainId(), mpiComm(), localToGlobal, dataOffsets, outputVel);
  maia::mpi::communicateGlobalyOrderedData(&m_slipDataParticleFluidVelGrad[0], noLocalParticles * noTimeStepsSaved,
                                           noGlobalParticles * noTimeStepsSaved, 1, POW2(nDim) * noSetups, noDomains(),
                                           domainId(), mpiComm(), localToGlobal, dataOffsets, outputVelGrad);
  maia::mpi::communicateGlobalyOrderedData(
      &m_slipDataParticleFluidVelRot[0], noLocalParticles * noTimeStepsSaved, noGlobalParticles * noTimeStepsSaved, 1,
      nDim * noSetups, noDomains(), domainId(), mpiComm(), localToGlobal, dataOffsets, outputParticleFluidRotation);
  maia::mpi::communicateGlobalyOrderedData(&m_slipDataParticleForce[0], noLocalParticles * noTimeStepsSaved,
                                           noGlobalParticles * noTimeStepsSaved, 1, nDim, noDomains(), domainId(),
                                           mpiComm(), localToGlobal, dataOffsets, outputParticleForce);
  maia::mpi::communicateGlobalyOrderedData(&m_slipDataParticlePosition[0], noLocalParticles * noTimeStepsSaved,
                                           noGlobalParticles * noTimeStepsSaved, 1, nDim, noDomains(), domainId(),
                                           mpiComm(), localToGlobal, dataOffsets, outputParticlePosition);
  maia::mpi::communicateGlobalyOrderedData(&m_slipDataParticleTorque[0], noLocalParticles * noTimeStepsSaved,
                                           noGlobalParticles * noTimeStepsSaved, 1, nDim, noDomains(), domainId(),
                                           mpiComm(), localToGlobal, dataOffsets, outputParticleTorque);
  maia::mpi::communicateGlobalyOrderedData(&m_slipDataParticleCollision[0], noLocalParticles * noTimeStepsSaved,
                                           noGlobalParticles * noTimeStepsSaved, 1, 1, noDomains(), domainId(),
                                           mpiComm(), localToGlobal, dataOffsets, outputCollision);

  MLongScratchSpace totalOffsetsDOF(noDomains() + 1, AT_, "totalOffsetsDOF_TRANS");
  MLongScratchSpace totalOffsetsDOF_TRANS(noDomains() + 1, AT_, "totalOffsetsDOF_TRANS");
  MLongScratchSpace totalOffsetsDOF_QUAT(noDomains() + 1, AT_, "totalOffsetsDOF_QUAT");
  MLongScratchSpace totalOffsetsDOF_ROT(noDomains() + 1, AT_, "totalOffsetsDOF_ROT");
  MLongScratchSpace totalOffsetsDOF_GRAD_Fluid(noDomains() + 1, AT_, "totalOffsetsDOF_GRAD_Fluid");
  MLongScratchSpace totalOffsetsDOF_TRANS_Fluid(noDomains() + 1, AT_, "totalOffsetsDOF_TRANS_Fluid");
  MLongScratchSpace totalOffsetsDOF_ROT_Fluid(noDomains() + 1, AT_, "totalOffsetsDOF_ROT_Fluid");
  for(MLong dom = 0; dom < noDomains() + 1; dom++) {
    totalOffsetsDOF(dom) = dataOffsets(dom);
    totalOffsetsDOF_QUAT(dom) = dataOffsets(dom) * 4;
    totalOffsetsDOF_TRANS(dom) = dataOffsets(dom) * nDim;
    totalOffsetsDOF_ROT(dom) = dataOffsets(dom) * nDim;
    totalOffsetsDOF_TRANS_Fluid(dom) = dataOffsets(dom) * nDim * noSetups;
    totalOffsetsDOF_ROT_Fluid(dom) = dataOffsets(dom) * nDim * noSetups;
    totalOffsetsDOF_GRAD_Fluid(dom) = dataOffsets(dom) * POW2(nDim) * noSetups;
  }
  const ParallelIo::size_type DOF = totalOffsetsDOF(domainId() + 1) - totalOffsetsDOF(domainId());
  const ParallelIo::size_type DOF_start = totalOffsetsDOF(domainId());
  const ParallelIo::size_type DOF_QUAT = totalOffsetsDOF_QUAT(domainId() + 1) - totalOffsetsDOF_QUAT(domainId());
  const ParallelIo::size_type DOF_QUAT_start = totalOffsetsDOF_QUAT(domainId());
  const ParallelIo::size_type DOF_TRANS = totalOffsetsDOF_TRANS(domainId() + 1) - totalOffsetsDOF_TRANS(domainId());
  const ParallelIo::size_type DOF_TRANS_start = totalOffsetsDOF_TRANS(domainId());
  const ParallelIo::size_type DOF_ROT = totalOffsetsDOF_ROT(domainId() + 1) - totalOffsetsDOF_ROT(domainId());
  const ParallelIo::size_type DOF_ROT_start = totalOffsetsDOF_ROT(domainId());
  const ParallelIo::size_type DOF_TRANS_Fluid =
      totalOffsetsDOF_TRANS_Fluid(domainId() + 1) - totalOffsetsDOF_TRANS_Fluid(domainId());
  const ParallelIo::size_type DOF_TRANS_Fluid_start = totalOffsetsDOF_TRANS_Fluid(domainId());
  const ParallelIo::size_type DOF_ROT_Fluid =
      totalOffsetsDOF_ROT_Fluid(domainId() + 1) - totalOffsetsDOF_ROT_Fluid(domainId());
  const ParallelIo::size_type DOF_ROT_Fluid_start = totalOffsetsDOF_ROT_Fluid(domainId());
  const ParallelIo::size_type DOF_GRAD_Fluid =
      totalOffsetsDOF_GRAD_Fluid(domainId() + 1) - totalOffsetsDOF_GRAD_Fluid(domainId());
  const ParallelIo::size_type DOF_GRAD_Fluid_start = totalOffsetsDOF_GRAD_Fluid(domainId());
  stringstream fn;
  fn.clear();
  fn << outputDir() << "correlationData_" << to_string(globalTimeStep);
  fn << ParallelIo::fileExt();
  MString fileName = fn.str();
  ParallelIo::size_type start = 0;
  ParallelIo::size_type count = 0;
  if(ParallelIo::fileExists(fileName, mpiComm()) && domainId() == 0) {
    stringstream fn2;
    fn2 << outputDir() << "correlationData_" << to_string(globalTimeStep);
    fn2 << ParallelIo::fileExt();
    time_t now = std::time(0);
    tm* ltm = localtime(&now);
    fn2 << "_" << ltm->tm_year << "_" << ltm->tm_mon << "_" << ltm->tm_mday << "_" << ltm->tm_hour << "_" << ltm->tm_min
        << "_" << ltm->tm_sec;
    MString fileName2 = fn2.str();
    rename(fileName.c_str(), fileName2.c_str());
  }

  using namespace maia::parallel_io;
  ParallelIo parallelIo(fileName, PIO_REPLACE, mpiComm());

  count = m_slipDataTimeSteps.size();
  parallelIo.defineArray(PIO_INT, "slipDataTimeSteps", count);

  count = totalOffsetsDOF(noDomains());
  parallelIo.defineArray(PIO_INT, "bodyInCollision", count);

  count = totalOffsetsDOF_TRANS(noDomains());
  parallelIo.defineArray(PIO_FLOAT, "particleVelocity", count);
  parallelIo.defineArray(PIO_FLOAT, "particleForce", count);
  parallelIo.defineArray(PIO_FLOAT, "particlePosition", count);

  count = totalOffsetsDOF_ROT(noDomains());
  parallelIo.defineArray(PIO_FLOAT, "particleAngularVelocity", count);
  parallelIo.defineArray(PIO_FLOAT, "particleTorque", count);

  count = totalOffsetsDOF_QUAT(noDomains());
  parallelIo.defineArray(PIO_FLOAT, "particleQuaternion", count);

  count = totalOffsetsDOF_TRANS_Fluid(noDomains());
  parallelIo.defineArray(PIO_FLOAT, "particleFluidVel", count);

  count = totalOffsetsDOF_ROT_Fluid(noDomains());
  parallelIo.defineArray(PIO_FLOAT, "particleFluidVelRot", count);

  count = totalOffsetsDOF_GRAD_Fluid(noDomains());
  parallelIo.defineArray(PIO_FLOAT, "particleFluidVelGrad", count);

  start = 0;
  count = m_slipDataTimeSteps.size();
  parallelIo.setOffset(count, start);
  parallelIo.writeArray(&m_slipDataTimeSteps[0], "slipDataTimeSteps");

  start = DOF_start;
  count = DOF;
  parallelIo.setOffset(count, start);
  parallelIo.writeArray(&outputCollision[0], "bodyInCollision");

  start = DOF_TRANS_start;
  count = DOF_TRANS;
  parallelIo.setOffset(count, start);
  parallelIo.writeArray(&outputParticleVel[0], "particleVelocity");
  parallelIo.writeArray(&outputParticleForce[0], "particleForce");
  parallelIo.writeArray(&outputParticlePosition[0], "particlePosition");

  start = DOF_ROT_start;
  count = DOF_ROT;
  parallelIo.setOffset(count, start);
  parallelIo.writeArray(&outputParticleAngularVel[0], "particleAngularVelocity");
  parallelIo.writeArray(&outputParticleTorque[0], "particleTorque");

  start = DOF_QUAT_start;
  count = DOF_QUAT;
  parallelIo.setOffset(count, start);
  parallelIo.writeArray(&outputParticleQuaternion[0], "particleQuaternion");

  start = DOF_TRANS_Fluid_start;
  count = DOF_TRANS_Fluid;
  parallelIo.setOffset(count, start);
  parallelIo.writeArray(&outputVel[0], "particleFluidVel");

  start = DOF_ROT_Fluid_start;
  count = DOF_ROT_Fluid;
  parallelIo.setOffset(count, start);
  parallelIo.writeArray(&outputParticleFluidRotation[0], "particleFluidVelRot");

  start = DOF_GRAD_Fluid_start;
  count = DOF_GRAD_Fluid;
  parallelIo.setOffset(count, start);
  parallelIo.writeArray(&outputVelGrad[0], "particleFluidVelGrad");

  m_slipDataTimeSteps.clear();
  MInt dim = 1;
  for(MInt i = 0; i < dim * m_noSlipDataOutputs; i++) {
    m_slipDataParticleCollision[i] = -5;
  }
  dim = 4;
  for(MInt i = 0; i < dim * m_noSlipDataOutputs; i++) {
    m_slipDataParticleQuaternion[i] = -F1;
  }
  dim = nDim;
  for(MInt i = 0; i < dim * m_noSlipDataOutputs; i++) {
    m_slipDataParticleAngularVel[i] = -F1;
    m_slipDataParticleTorque[i] = -F1;
  }
  for(MInt i = 0; i < dim * m_noSlipDataOutputs * noSetups; i++) {
    m_slipDataParticleFluidVelRot[i] = -F1;
  }
  dim = nDim;
  for(MInt i = 0; i < dim * m_noSlipDataOutputs; i++) {
    m_slipDataParticleVel[i] = -F1;
    m_slipDataParticleForce[i] = -F1;
    m_slipDataParticlePosition[i] = -F1;
  }
  for(MInt i = 0; i < dim * m_noSlipDataOutputs * noSetups; i++) {
    m_slipDataParticleFluidVel[i] = -F1;
  }
  dim = POW2(nDim);
  for(MInt i = 0; i < dim * m_noSlipDataOutputs * noSetups; i++) {
    m_slipDataParticleFluidVelGrad[i] = -F1;
  }
}


/**
 * \brief step before the solver solution Step
 * \author anyone
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::preSolutionStep(const MInt mode) {
  TRACE();

  ASSERT(m_levelSetMb, "Wrong Function call, only for m_levelSetMb! Otherwise use preTimeStep in fvsolver.cpp");

  RECORD_TIMER_START(m_timers[Timers::PreTime]);

  reInitSolutionStep(mode);
  writeListOfActiveFlowCells();

  RECORD_TIMER_STOP(m_timers[Timers::PreTime]);
}


/**
 * \brief step after the solver solution Step
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
MBool FvMbCartesianSolverXD<nDim, SysEqn>::postSolutionStep() {
  TRACE();

  RECORD_TIMER_START(m_timers[Timers::PostTime]);
  RECORD_TIMER_START(m_timers[Timers::PostSolu]);

  MBool convergence = false;

  /// RESIDUAL
  RECORD_TIMER_START(m_timers[Timers::ResidualMb]);
  convergence = this->maxResidual();
  RECORD_TIMER_STOP(m_timers[Timers::ResidualMb]);

  /// Surface Forces:
  RECORD_TIMER_START(m_timers[Timers::SurfaceForces]);
  this->computeBoundarySurfaceForces();
  RECORD_TIMER_STOP(m_timers[Timers::SurfaceForces]);

  /// Structure correction step:
  ///-> eventually, level-set update has to be included here for FSI computations with
  /// "real" level set
  RECORD_TIMER_START(m_timers[Timers::LevelSetCorr]);
  convergence = mMin(convergence, constructGFieldCorrector());
  RECORD_TIMER_STOP(m_timers[Timers::LevelSetCorr]);


  RECORD_TIMER_STOP(m_timers[Timers::PostSolu]);
  RECORD_TIMER_STOP(m_timers[Timers::PostTime]);

  return convergence;
}


/**
 * \brief  Checks a couple of important properties and variables of halo-cells
 *
 * mode = 0 : default mode
 * mode = 1 : in reinitAfterAdaptation, here IsInactive is not set correctly yet.
 * mode = 2 : only check gap-properties
 * mode = 3 : skip cellVolumesDt1 check
 *
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::checkHaloCells(MInt mode) {
  TRACE();

  const MFloat eps0 = 1e-12;
  const MInt noChecks = 11;
  MFloatScratchSpace cellCheck(a_noCells(), noChecks, AT_, "cellCheck");
  cellCheck.fill(std::numeric_limits<MFloat>::max());

  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    cellCheck(cellId, 0) = F1;
    cellCheck(cellId, 1) = a_cellVolume(cellId);
    cellCheck(cellId, 2) = m_cellVolumesDt1[cellId];
    cellCheck(cellId, 3) = (MFloat)a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel);
    cellCheck(cellId, 4) = (MFloat)a_hasProperty(cellId, SolverCell::IsInactive);
    cellCheck(cellId, 5) = a_levelSetValuesMb(cellId, 0);
    cellCheck(cellId, 6) = (MFloat)a_isGapCell(cellId);
    cellCheck(cellId, 7) = (MFloat)a_wasGapCell(cellId);
    cellCheck(cellId, 8) = (MFloat)a_hasProperty(cellId, SolverCell::NearWall);
    cellCheck(cellId, 9) = (MFloat)a_bndryId(cellId) > -1 ? 1 : -1;
    cellCheck(cellId, 10) = (MFloat)a_hasProperty(cellId, SolverCell::WasInactive);
  }

  exchangeData(&cellCheck(0), noChecks);

  for(MInt cellId = noInternalCells(); cellId < a_noCells(); cellId++) {
    if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
    if(a_isBndryGhostCell(cellId)) continue;
    // Azimuthal periodic window/halo cells are not identical in the sense of the cartesian grid!
    if(grid().azimuthalPeriodicity() && a_isPeriodic(cellId)) continue;

    ASSERT((MInt)cellCheck(cellId, 0) == 1, to_string(a_isHalo(cellId)));

    if(mode == 2) {
      if((MInt)cellCheck(cellId, 6) != a_isGapCell(cellId)) {
        cerr << domainId() << ": ERR7 checkHaloCells " << globalTimeStep << " " << c_globalId(cellId) << endl;
      }

      if((MInt)cellCheck(cellId, 7) != a_wasGapCell(cellId)) {
        cerr << domainId() << ": ERR7 checkHaloCells " << globalTimeStep << " " << cellId << endl;
      }
      continue;
    }


    if(fabs(cellCheck(cellId, 1) - a_cellVolume(cellId)) > eps0) {
      cerr << domainId() << ": ERR1 checkHaloCells " << cellId << " " << c_globalId(cellId) << " "
           << a_hasProperty(cellId, SolverCell::IsSplitCell) << " " << a_hasProperty(cellId, SolverCell::IsSplitChild)
           << " " << a_isHalo(cellId) << " " << a_isWindow(cellId) << " " << a_level(cellId) << " "
           << a_cellVolume(cellId) << " " << cellCheck(cellId, 1) << " "
           << (cellCheck(cellId, 1) - grid().gridCellVolume(a_level(cellId))) / grid().gridCellVolume(a_level(cellId))
           << " "
           << (a_cellVolume(cellId) - grid().gridCellVolume(a_level(cellId))) / grid().gridCellVolume(a_level(cellId))
           << " " << fabs(cellCheck(cellId, 1) - a_cellVolume(cellId)) / grid().gridCellVolume(a_level(cellId)) << endl;
    }
    if(fabs(cellCheck(cellId, 2) - m_cellVolumesDt1[cellId]) > eps0 && mode != 3) {
      cerr << domainId() << ": ERR2 checkHaloCells " << globalTimeStep << " " << c_globalId(cellId) << " "
           << m_cellVolumesDt1[cellId] << " " << cellCheck(cellId, 2) << " " << c_isLeafCell(cellId) << endl;
    }
    if((MInt)cellCheck(cellId, 3) != a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
      cerr << domainId() << ": ERR3 checkHaloCells " << globalTimeStep << " " << cellId << endl;
    }

    if(fabs(cellCheck(cellId, 5) - a_levelSetValuesMb(cellId, 0)) > eps0) {
      cerr << domainId() << ": ERR5 checkHaloCells " << globalTimeStep << " " << cellId << endl;
    }

    if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;

    if(mode != 1) {
      if((MInt)cellCheck(cellId, 4) != a_hasProperty(cellId, SolverCell::IsInactive)) {
        cerr << domainId() << ": ERR4 checkHaloCells " << globalTimeStep << " " << cellId << endl;
      }
    }

    if((MInt)cellCheck(cellId, 6) != a_isGapCell(cellId)) {
      cerr << domainId() << ": ERR6 checkHaloCells " << globalTimeStep << " " << cellId << endl;
    }

    if((MInt)cellCheck(cellId, 7) != a_wasGapCell(cellId)) {
      cerr << domainId() << ": ERR7 checkHaloCells " << globalTimeStep << " " << cellId << endl;
    }
    if((MInt)cellCheck(cellId, 8) != a_hasProperty(cellId, SolverCell::NearWall)) {
      cerr << domainId() << ": ERR8 checkHaloCells " << globalTimeStep << " " << cellId << endl;
    }
    const MInt isbndry = a_bndryId(cellId) > -1 ? 1 : -1;
    if((MInt)cellCheck(cellId, 9) != isbndry) {
      cerr << domainId() << ": ERR9 checkHaloCells " << globalTimeStep << " " << cellId << endl;
    }

    if(mode != 3) {
      if((MInt)cellCheck(cellId, 10) != a_hasProperty(cellId, SolverCell::WasInactive)) {
        cerr << domainId() << ": ERR10 checkHaloCells " << globalTimeStep << " " << cellId << endl;
      }
    }
  }
}


/**
 * \brief sets the global-Trigger m_gapOpened, to determine if Gap-Cells are opened!
 *        old and incorrect version!!!!
 *        use m_gapInitMethod = 1 or 2 instead!!
 * \author Claudia Guenter, cleanup Tim Wegmann
 *
 *
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::setGapOpened() {
  TRACE();

  ASSERT(m_gapInitMethod == 0, "");
  if(!m_closeGaps) return;

  exchangeGapInfo();

  ASSERT(!m_gapOpened, "");
  ASSERT(m_levelSet, "");

  // set the m_gapOpened-property and initialize emerging-Gap-Cells!
  const MFloat eps = sqrt(nDim) * c_cellLengthAtLevel(m_lsCutCellBaseLevel);

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    if(a_isBndryGhostCell(cellId)) continue;
    // if ( a_isHalo( cellId ) ) continue;
    if(!a_hasProperty(cellId, SolverCell::WasGapCell)) continue;
    if(a_level(cellId) != maxRefinementLevel()) continue;
    if(!a_hasProperty(cellId, SolverCell::WasInactive)) continue;
    if(a_hasProperty(cellId, SolverCell::IsGapCell)) continue;

    if(a_levelSetValuesMb(cellId, 0) < -eps) continue;

    // for all cells with: WasGapCell, WasInactive, !IsGapCell and small ls-values!
    // would be more accurate to use the cornerLs-Values instead of eps-approach!

    // set variables to initial value, which will be corrected later in initEmergingGapCells()!
    a_variable(cellId, CV->RHO) = m_rhoInfinity;
    a_variable(cellId, CV->RHO_E) = m_rhoEInfinity;
    a_variable(cellId, CV->RHO_VV[0]) = F0;
    a_variable(cellId, CV->RHO_VV[1]) = F0;
    IF_CONSTEXPR(nDim == 3) a_variable(cellId, CV->RHO_VV[2]) = F0;
    a_pvariable(cellId, PV->RHO) = m_rhoInfinity;
    a_pvariable(cellId, PV->U) = F0;
    a_pvariable(cellId, PV->V) = F0;
    IF_CONSTEXPR(nDim == 3) a_pvariable(cellId, PV->W) = F0;
    a_pvariable(cellId, PV->P) = m_PInfinity;

    cerr << domainId() << ": old gap cell activated at timeStep " << globalTimeStep << ":  cellId " << cellId << " "
         << c_globalId(cellId) << " lvsVal: " << a_levelSetValuesMb(cellId, 0)
         << " inactive: " << a_hasProperty(cellId, SolverCell::IsInactive) << endl;

    m_gapOpened = true;
  }

  MInt gapOpened = (MInt)m_gapOpened;
  MPI_Allreduce(MPI_IN_PLACE, &gapOpened, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "gapOpened");
  m_gapOpened = (MBool)gapOpened;

  if(domainId() == 0 && m_gapOpened) {
    cerr << "Gap Opening Initialized at timestep " << globalTimeStep << endl;
  }
}


/**
 * \brief determines Gap-state, and organises GapCells
 * \author Tim Wegmann
 *
 *
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::gapHandling() {
  TRACE();

  ASSERT(m_levelSet && m_closeGaps, "");
  ASSERT(m_gapInitMethod > 0, "");

  m_gapCellExchangeInit = false;

  m_gapCellId.clear();
  m_gapCellId.resize(a_noCells());
  for(MInt i = 0; i < a_noCells(); i++)
    m_gapCellId[i] = -1;

  // return early if no gapCells were found!
  if(m_noneGapRegions) return;

  ASSERT(m_initGapCell, "");

  // set gapCellId
  for(MUint it = 0; it < m_gapCells.size(); it++) {
    const MInt cellId = m_gapCells[it].cellId;
    m_gapCellId[cellId] = (MInt)it;
  }

  // check if any gap opens
  MBool anyGapOpening = false;
  for(MInt region = 0; region < m_noGapRegions; region++) {
    if(m_gapState[region] == 2) anyGapOpening = true;
  }

  // NOTE: split-childs are not yet added as gapCells as a region cann't be found for them immedeatly.
  //       However, splitcells are still added and used for the interpolation!
  //       Split-childs will be handeled at the end!

  // b) categorise Gap-Cells

  // 1) during initGapClosure:
  // Types:
  // 2  - body-shadowed gap-Cell    :
  // 3  - gap-shadowed internalCell : delete surfaces
  // 4  - gap-shadowed Bndry-Cell   : delete surface, remove from oldBndry-Cell-List, set gridVolume
  // 5  - Bndry-Cell                : correct Bndry-Velocity, and cellVolumes
  // 6  - emerging bndryCell        : correct Bndry-Velocity, and cellVolumes
  // 7  - new Gap-BndryCell         : correct Bndry-Velocity, and cellVolumes
  // 8  - internal-Cell             :
  // 9  - emerging internal Cell    :
  // 99 - new body-bndry-Cell       :

  // NOTE: for now mass during initGapClosure is lost!
  //      This mass-loss needs to be approximated!
  //      Or alternatevly the mass can be redistributed towards sourrounding cells

  MInt outInfo1 = 1;
  MInt outInfo2 = 1;
  for(MInt region = 0; region < m_noGapRegions; region++) {
    if(m_gapState[region] != -2) continue;
    for(MUint it = 0; it < m_gapCells.size(); it++) {
      MInt regionId = m_gapCells[it].region;
      if(regionId != region) continue;
      MInt cellId = m_gapCells[it].cellId;

      // all Gap-Cells in that region (including Halo-Cells!)
      // if(a_level(cellId) != maxRefinementLevel()) continue;
      if(a_level(cellId) < m_lsCutCellMinLevel || !c_isLeafCell(cellId)) continue;

      ASSERT(!a_wasGapCell(cellId), "");
      ASSERT(m_gapCells[it].status == 0, "");
      MInt flowCornerBodySet = 0;
      MInt flowCorner = 0;
      MInt bodyId = a_associatedBodyIds(cellId, 0);
      MInt bodySet = m_bodyToSetTable[bodyId];

      MInt cndId = m_bndryCandidateIds[cellId];


      if(cndId < 0) {
        if(a_levelSetValuesMb(cellId, bodySet) > F0) {
          flowCornerBodySet = m_noCellNodes;
        } else {
          flowCornerBodySet = 0;
        }
        if(a_levelSetValuesMb(cellId, 0) > F0) {
          flowCorner = m_noCellNodes;
        } else {
          flowCorner = 0;
        }
      } else {
        for(MInt node = 0; node < m_noCellNodes; node++) {
          if(m_candidateNodeValues[IDX_LSSETNODES(cndId, node, bodySet)] > F0) flowCornerBodySet++;
          if(m_candidateNodeValues[IDX_LSSETNODES(cndId, node, 0)] > F0) flowCorner++;
        }
      }


      if(a_hasProperty(cellId, SolverCell::WasInactive)) {
        // TODO labels:FVMB use a_isBndryCell and IsInactive to differe here!
        //      check if flowCorner are even nevessary!
        if(flowCorner == m_noCellNodes) {
          cerr << "UnExpected GapCell (1) at initGapClosure! " << c_globalId(cellId) << " " << a_isBndryCell(cellId)
               << " " << a_hasProperty(cellId, SolverCell::IsInactive) << " " << cndId << endl;
        } else if(flowCorner > 0 && flowCorner < m_noCellNodes) {
          // new bndry-Cell (was body-shadowed before)
          m_gapCells[it].status = 99;
        } else { // flowCorner == 0
          // body-shadowed Gap-Cell
          m_gapCells[it].status = 2;
        }

      } else { // wasActive
        if(flowCorner == m_noCellNodes) {
          auto it1 = m_oldBndryCells.find(cellId);
          if(it1 != m_oldBndryCells.end()) {
            // emerging internal-Cell due to body-movement
            m_gapCells[it].status = 9;
          } else {
            // internal-Gap-Cell
            m_gapCells[it].status = 8;
          }


        } else if(flowCorner > 0 && flowCorner < m_noCellNodes) {
          if(flowCornerBodySet == 0) {
            // emerging-Bndry-Cell
            m_gapCells[it].status = 6;
          } else if(flowCornerBodySet == m_noCellNodes) {
            // new Gap-Bndry-Cell
            m_gapCells[it].status = 7;
          } else { // flowCornerBodySet > 0 && flowCornerBodySet < m_noCellNodes
            // bndry-Cell
            m_gapCells[it].status = 5;
          }


        } else { // flowCorner == 0 (wasActive but will be inactive!)

          auto it1 = m_oldBndryCells.find(cellId);
          if(it1 != m_oldBndryCells.end()) {
            // gap-Shadowed Bndry-Cell
            m_gapCells[it].status = 4;
            if(outInfo2) {
              cerr << "--> Deleting oldBndryCells shadowed by the Gap in region " << regionId << endl;
              outInfo2 = 0;
            }
            removeSurfaces(cellId);
            m_oldBndryCells.erase(it1);
            a_cellVolume(cellId) = grid().gridCellVolume(a_level(cellId));
            a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
            m_cellVolumesDt1[cellId] = grid().gridCellVolume(a_level(cellId));
            if(m_dualTimeStepping) m_cellVolumesDt2[cellId] = grid().gridCellVolume(a_level(cellId));
            for(MInt v = 0; v < m_noFVars; v++) {
              a_rightHandSide(cellId, v) = F0;
              m_rhs0[cellId][v] = F0;
            }

          } else {
            // gap-Shadowed InternalCell
            m_gapCells[it].status = 3;
            if(outInfo1) {
              cerr << "--> Deleting Gap-Shadowed Cells in region " << regionId << endl;
              outInfo1 = 0;
            }
            removeSurfaces(cellId);
            ASSERT(fabs(grid().gridCellVolume(a_level(cellId)) - a_cellVolume(cellId)) < 0.00001, "");
            for(MInt v = 0; v < m_noFVars; v++) {
              a_rightHandSide(cellId, v) = F0;
              m_rhs0[cellId][v] = F0;
            }
          }
        }
      }
    }
  }

  // 2) during gap-Shrinking
  // 30 : internal gap-Cell
  // 31 : gap or body-shadowed gapCell
  // 32 : new gap Bndry-Cell which used to be inactive (with lost gap-status)
  // 33 : new gap Bndry-Cell which used to be inactive (also wasGapCell)
  // 34 : gap-Bndry-Cell was bndryCell before
  // 35 : gap-Bndry-Cell was internal Cell before
  for(MInt region = 0; region < m_noGapRegions; region++) {
    if(m_gapState[region] != -1) continue;
    for(MUint it = 0; it < m_gapCells.size(); it++) {
      const MInt regionId = m_gapCells[it].region;
      if(regionId != region) continue;
      const MInt cellId = m_gapCells[it].cellId;
      const MInt status = m_gapCells[it].status;

      if(status == 1) {
        // only inactive Cells may loose their gap-property during gap-shrinking!
        /*
        MInt flowCorner = 0;
        MInt cndId = m_bndryCandidateIds[ cellId ];
        if(cndId < 0) {
          if(a_levelSetValuesMb(cellId, 0) > F0) {
            flowCorner = m_noCellNodes;
          } else {
            flowCorner = 0;
          }
        } else {
          for ( MInt node = 0; node < m_noCellNodes; node++ ) {
            if(m_candidateNodeValues[ IDX_LSSETNODES(cndId, node, 0) ] > F0) flowCorner++;
          }
        }
        if(flowCorner > 0) {
          cerr << "CAUTION: Gap-Cell-Loss during shrinking " << c_globalId(cellId) << " "
               << a_levelSetValuesMb(cellId, 0)  << " " << -eps << " "
               << a_hasProperty(cellId, SolverCell::WasInactive) << endl;
        }
        */
      } else {
        // is GapCell and might be gap-Cell before

        if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
        if(a_isBndryGhostCell(cellId)) continue;

        // if(a_level(cellId) != maxRefinementLevel()) continue;
        if(a_level(cellId) < m_lsCutCellMinLevel || !c_isLeafCell(cellId)) continue;

        MInt flowCornerBodySet = 0;
        MInt flowCorner = 0;
        MInt bodyId = a_associatedBodyIds(cellId, 0);
        MInt bodySet = m_bodyToSetTable[bodyId];

        MInt cndId = m_bndryCandidateIds[cellId];


        if(cndId < 0) {
          if(a_levelSetValuesMb(cellId, bodySet) > F0) {
            flowCornerBodySet = m_noCellNodes;
          } else {
            flowCornerBodySet = 0;
          }
          if(a_levelSetValuesMb(cellId, 0) > F0) {
            flowCorner = m_noCellNodes;
          } else {
            flowCorner = 0;
          }
        } else {
          for(MInt node = 0; node < m_noCellNodes; node++) {
            if(m_candidateNodeValues[IDX_LSSETNODES(cndId, node, bodySet)] > F0) flowCornerBodySet++;
            if(m_candidateNodeValues[IDX_LSSETNODES(cndId, node, 0)] > F0) flowCorner++;
          }
        }

        if(flowCorner == m_noCellNodes) {
          // internal Gap-Cell
          m_gapCells[it].status = 30;


        } else if(flowCorner == 0) {
          // gap-or Body-shadowed Gap-Cell
          m_gapCells[it].status = 31;

        } else { // Bndry-Cell

          if(a_hasProperty(cellId, SolverCell::WasInactive)) {
            // new Bndry-Cell

            if(flowCornerBodySet == 8) {
              // new Gap-Bndry-Cell

            } else {
              // new body-Bndry-Cell
            }
          } else {
            // old Bndry-Cell
          }
        }
      }
    }
  }

  // 3) during gap-Widening
  // Types:
  // 10 : internal gap-Cell
  // 11 : gap or body-shadowed gapCell
  // 12 : new gap Bndry-Cell which used to be inactive (with lost gap-status)
  // 13 : new gap Bndry-Cell which used to be inactive (also wasGapCell)
  // 14 : gap-Bndry-Cell was bndryCell before
  // 15 : gap-Bndry-Cell was internal Cell before
  // 16 : new small gap Bndry-Cell with wasinactive neighbors (-> can't be linked easyly!)

  vector<MInt> partialGapOpened;
  vector<MInt> fullyGapOpened;
  vector<MInt> fullyGapBndry;
  for(MInt region = 0; region < m_noGapRegions; region++) {
    partialGapOpened.push_back(0);
    fullyGapOpened.push_back(0);
    fullyGapBndry.push_back(0);
    if(m_gapState[region] != 3) continue;
    for(MUint it = 0; it < m_gapCells.size(); it++) {
      MInt regionId = m_gapCells[it].region;
      if(regionId != region) continue;
      MInt cellId = m_gapCells[it].cellId;

      MInt status = m_gapCells[it].status;

      if(status == 0) {
        /*
        //only inactive Cells may gain gap-property during gap-widening!
        MInt flowCorner = 0;
        MInt cndId = m_bndryCandidateIds[ cellId ];
        if(cndId < 0) {
          if(a_levelSetValuesMb(cellId, 0) > F0) {
            flowCorner = m_noCellNodes;
          } else {
            flowCorner = 0;
          }
        } else {
          for ( MInt node = 0; node < m_noCellNodes; node++ ) {
            if(m_candidateNodeValues[ IDX_LSSETNODES(cndId, node, 0) ] > F0) flowCorner++;
          }
        }
        if(flowCorner > 0) {
          cerr << "CAUTION: Gap-Cell-Gain during widening " << c_globalId(cellId) << " "
               << a_levelSetValuesMb(cellId, 0)  << " " << -eps << " "
               << a_hasProperty(cellId, SolverCell::WasInactive) << endl;
        }

        */
      } else {
        // a cell which lost its Gap-status or a remains a gapCell
        // now-check if it will be:
        // - an internalCell (only if the cell !wasInactive before),
        // - an inactive Cell (so still shadowed by a body)
        // - an active bndryCell
        //   (then the Cell needs to be initialised by Cell-linking or its former bndryCell-status)

        if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
        if(a_isBndryGhostCell(cellId)) continue;
        // if(a_level(cellId) != maxRefinementLevel() ) continue;
        if(a_level(cellId) < m_lsCutCellMinLevel || !c_isLeafCell(cellId)) continue;

        MInt flowCornerBodySet = 0;
        MInt flowCorner = 0;
        MInt bodyId = a_associatedBodyIds(cellId, 0);
        MInt bodySet = m_bodyToSetTable[bodyId];

        MInt cndId = m_bndryCandidateIds[cellId];


        if(cndId < 0) {
          if(a_levelSetValuesMb(cellId, bodySet) > F0) {
            flowCornerBodySet = m_noCellNodes;
          } else {
            flowCornerBodySet = 0;
          }
          if(a_levelSetValuesMb(cellId, 0) > F0) {
            flowCorner = m_noCellNodes;
          } else {
            flowCorner = 0;
          }
        } else {
          for(MInt node = 0; node < m_noCellNodes; node++) {
            if(m_candidateNodeValues[IDX_LSSETNODES(cndId, node, bodySet)] > F0) flowCornerBodySet++;
            if(m_candidateNodeValues[IDX_LSSETNODES(cndId, node, 0)] > F0) flowCorner++;
          }
        }


        if(flowCorner == m_noCellNodes) {
          // internal gap-Cell


          if(a_hasProperty(cellId, SolverCell::WasInactive)) {
            // if the call was inactive before and is suddenly a completely emergerd cell,
            // fullyGapOpening has occoured, this is only possible
            // if the cell looses its gap-Status!
            // ASSERT(status == 1, "");
            if(status != 1) {
              cerr << "Incorrect status " << c_globalId(cellId) << a_hasProperty(cellId, SolverCell::WasInactive) << " "
                   << a_hasProperty(cellId, SolverCell::IsInactive) << " " << a_isGapCell(cellId) << " "
                   << a_wasGapCell(cellId) << endl;
            }
            m_gapCells[it].status = 21;
            fullyGapOpened[region]++;

          } else {
            // the cell was an active cell before!
            m_gapCells[it].status = 10;
          }


        } else if(flowCorner == 0) {
          // the cell should be inactive
          // but can be either body or gap-shadowed
          ASSERT(a_hasProperty(cellId, SolverCell::IsInactive), "");
          m_gapCells[it].status = 11;
          if(status == 1) ASSERT(flowCornerBodySet == 0, "");

        } else {
          // a gap-bndry-Cell which has lost its Gap-status or is still a Gap-Cell

          if(a_hasProperty(cellId, SolverCell::WasInactive)) {
            // a gap or body-shadowed Cell has become a new gap-bndry-Cell
            // needs to be linked to a master-Cell and thus initialised!
            if(status == 1) {
              m_gapCells[it].status = 22;
              fullyGapBndry[region]++;
            } else { // status -1
              m_gapCells[it].status = 13;

              // check for partial gap-opening:
              MInt masterId = -1;
              MFloat maxVolActive = F0;
              MInt noInternalNghbrs = 0;
              const MInt rootId = cellId;
              for(MInt dir = 0; dir < m_noDirs; dir++) {
                if(!checkNeighborActive(rootId, dir) || a_hasNeighbor(rootId, dir) == 0) continue;
                const MInt nghbrId = c_neighborId(rootId, dir);
                if(nghbrId < 0) continue;
                if(!a_isHalo(nghbrId)) noInternalNghbrs++;
                if(a_hasProperty(nghbrId, SolverCell::WasInactive)) continue;
                if(a_hasProperty(nghbrId, SolverCell::IsSplitCell)) continue;
                if(a_hasProperty(nghbrId, SolverCell::IsSplitChild)) continue;
                if(a_cellVolume(nghbrId) > maxVolActive) {
                  masterId = nghbrId;
                  maxVolActive = a_cellVolume(nghbrId);
                }
              }
              if(masterId > -1) continue;
              if(a_isHalo(cellId) && noInternalNghbrs == 0) continue;
              if(a_isHalo(cellId) && a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;

              m_gapCells[it].status = 16;
              partialGapOpened[region]++;
            }

          } else {
            // check if it used to be bndry-Cell before
            auto it1 = m_oldBndryCells.find(cellId);
            if(it1 != m_oldBndryCells.end()) {
              // cell was also a bndry-Cell before
              m_gapCells[it].status = 14;
            } else {
              // former internal Cell
              m_gapCells[it].status = 15;
            }
          }
        }
      }
    }
  }

  // partial gap-opening occours if
  // a) a new bndry-Cell emerges which does not have an active neighbor!

  MPI_Allreduce(MPI_IN_PLACE, &partialGapOpened[0], m_noGapRegions, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "partialGapOpened[0]");
  MPI_Allreduce(MPI_IN_PLACE, &fullyGapOpened[0], m_noGapRegions, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "fullyGapOpened[0]");
  MPI_Allreduce(MPI_IN_PLACE, &fullyGapBndry[0], m_noGapRegions, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "fullyGapBndry[0]");

  MBool anyPartialGapOpened = false;
  for(MInt region = 0; region < m_noGapRegions; region++) {
    if(partialGapOpened[region] > 0) {
      anyPartialGapOpened = true;
      break;
    }
  }

  MBool anyFullyGapOpened = false;
  for(MInt region = 0; region < m_noGapRegions; region++) {
    if(fullyGapOpened[region] > 0) {
      anyFullyGapOpened = true;
      break;
    }
  }

  if(anyPartialGapOpened) {
    for(MInt region = 0; region < m_noGapRegions; region++) {
      if(domainId() == 0 && partialGapOpened[region] && !fullyGapOpened[region]) {
        cerr << "Partial Gap Opening at region " << region << " with " << partialGapOpened[region] << " Cells." << endl;
      }
    }

    initGapCellExchange();

    for(MInt region = 0; region < m_noGapRegions; region++) {
      if(!partialGapOpened[region]) continue;
      if(fullyGapOpened[region]) continue;
      for(MUint it = 0; it < m_gapCells.size(); it++) {
        const MInt regionId = m_gapCells[it].region;
        if(regionId != region) continue;
        const MInt cellId = m_gapCells[it].cellId;
        const MInt status = m_gapCells[it].status;

        if(status != 16) continue;

        MInt largestNeighbor = checkNeighborActivity(cellId);

        if(largestNeighbor >= 0) {
          MInt largestNeighborGapCellId = m_gapCellId[largestNeighbor];
          m_gapCells[largestNeighborGapCellId].status = 17;
          // trigger reverse exchange!
          if(a_isHalo(largestNeighbor)) {
            m_gapCells[largestNeighborGapCellId].status = -99;
          }
        }
      }
    }

    gapCellExchange(1);
  }


  // 4) during initGapOpening
  // Types:
  // 21: arising gap-Cell          :  interpolate variables, wasInactive = false, restoreSurfaces,
  // 22: new body-Bndry-Cell       :  interpolate variables ,
  //                                  link to !wasInactive neighbor,
  //                                  insert in oldBndryCells, dalta-Function for cell velocity
  // 23: old Gap-Bndry-Cell        :  delete from oldBndry-Cell, set oldCellVolume to current-Volume,
  //                                  reset rhs0
  // 24: gap-bndry-Cel             :  cellVolumes as in first TimeStep
  // 25: internal gap-Cell         :
  // 26: body-shadowed gap-Cell    :
  // 27: bndry-Cell/was internal   :
  // 28: new body-Bndry-Cell       : interpolate variables , wasInactive = false,
  //     (former 22)                 insert in oldBndryCells,
  // 29: large new body-Bndry-Cell : interpolate variables , wasInactive = false,
  //     (former 22)
  // 99: submerging bndry-cell     : delte from oldBndryCells without mass-Redistribution
  //                                 and reset as inactive cell

  // NOTE: currently arising gap-Cells and new body-Bndry-Cells are initialised by linear-Interpolation
  //      between the cell-staates on both sides of the gap.
  //      Additionally mass is added to the system though volume increase for oldGap-Bndry-Cells!
  //      This initialised mass can be weight against the lost mass in initGapClosure!

  vector<MInt> noArisingGapCells;
  vector<MInt> noArisingGapCellsHalo;
  vector<MInt> noNewBndryCells;
  vector<MInt> noNewBndryCellsHalo;

  vector<MInt> interpolationCells;

  for(MInt region = 0; region < m_noGapRegions; region++) {
    noArisingGapCells.push_back(0);
    noArisingGapCellsHalo.push_back(0);
    noNewBndryCells.push_back(0);
    noNewBndryCellsHalo.push_back(0);
    if(m_gapState[region] != 2) continue;
    for(MUint it = 0; it < m_gapCells.size(); it++) {
      const MInt regionId = m_gapCells[it].region;
      if(regionId != region) continue;
      const MInt cellId = m_gapCells[it].cellId; // all previous Gap-Cells in that region

      // if(a_isHalo(cellId)) continue;
      // if(a_hasProperty( cellId, SolverCell::IsSplitChild)) continue;
      if(a_isBndryGhostCell(cellId)) continue;
      ASSERT(a_level(cellId) == maxRefinementLevel(), "");
      // at gap opening, all previous gap cells should be reined to the highest Level!
      if(a_level(cellId) != maxRefinementLevel()) continue;

      ASSERT(!a_isGapCell(cellId), "");
      ASSERT(m_gapCells[it].status == 1, "");
      // G0 now coinsides with the set of the according body!

      MInt flowCorner = 0;
      MInt bodyId = a_associatedBodyIds(cellId, 0);
      MInt bodySet = m_bodyToSetTable[bodyId];

      MInt cndId = m_bndryCandidateIds[cellId];

      if(cndId < 0) {
        if(a_levelSetValuesMb(cellId, bodySet) > F0) {
          flowCorner = m_noCellNodes;
        } else {
          flowCorner = 0;
        }
      } else {
        for(MInt node = 0; node < m_noCellNodes; node++) {
          if(m_candidateNodeValues[IDX_LSSETNODES(cndId, node, bodySet)] > F0) flowCorner++;
        }
      }

      if(a_hasProperty(cellId, SolverCell::WasInactive)) {
        if(flowCorner == m_noCellNodes) {
          // arising gap-Cell
          m_gapCells[it].status = 21;
          if(a_isHalo(cellId)) {
            noArisingGapCellsHalo[region]++;
          } else {
            noArisingGapCells[region]++;
          }

        } else if(flowCorner == 0) {
          // body-shadowed gap-Cell
          m_gapCells[it].status = 26;

        } else {
          // will be bndry-Cell
          if(a_isHalo(cellId)) {
            noNewBndryCellsHalo[region]++;
          } else {
            noNewBndryCells[region]++;
          }
          m_gapCells[it].status = 22;
        }


      } else { // was active

        auto it1 = m_oldBndryCells.find(cellId);
        if(it1 != m_oldBndryCells.end()) {
          if(flowCorner == m_noCellNodes) {
            // will be internal-Cell
            // old-Gap-bndry-Cell
            m_gapCells[it].status = 23;

            // delete former bndry-Cell
            //--> releasing mass into the fluid
            // shall be treated just as if the cell had been an internal-Cell before!
            for(MInt v = 0; v < m_noFVars; v++) {
              a_rightHandSide(cellId, v) = F0;
              m_rhs0[cellId][v] = F0;
            }

            if(m_dualTimeStepping) m_cellVolumesDt2[cellId] = grid().gridCellVolume(a_level(cellId));
            a_cellVolume(cellId) = grid().gridCellVolume(a_level(cellId));
            a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
            m_cellVolumesDt1[cellId] = grid().gridCellVolume(a_level(cellId));
            m_oldBndryCells.erase(it1);

          } else if(flowCorner == 0) {
            // submerging bndry-cell
            // will be inactive cell, was bndry-Cell
            m_gapCells[it].status = 99;

            // delete former bndry-Cell
            //--> releasing mass into the fluid
            // shall be treated just as if the cell had been an internal-Cell before!
            for(MInt v = 0; v < m_noFVars; v++) {
              a_rightHandSide(cellId, v) = F0;
              m_rhs0[cellId][v] = F0;
            }
            removeSurfaces(cellId);

            if(m_dualTimeStepping) m_cellVolumesDt2[cellId] = grid().gridCellVolume(a_level(cellId));
            a_cellVolume(cellId) = grid().gridCellVolume(a_level(cellId));
            a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
            m_cellVolumesDt1[cellId] = grid().gridCellVolume(a_level(cellId));
            m_oldBndryCells.erase(it1);


          } else {
            // gap-bndry-cell
            m_gapCells[it].status = 24;
            // handeled regularly as emerging cell!
          }

        } else { // not a old Bndry-Cell

          // TODO labels:FVMB use a_isBndryCell and IsInactive to differe here!
          if(flowCorner == m_noCellNodes) {
            // will be internal-Cell
            // gap-internal-cell
            m_gapCells[it].status = 25;

          } else if(flowCorner == 0) {
            cerr << "UnExpected GapCell (2) at initGapOpening! " << c_globalId(cellId) << endl;

          } else {
            // was internal, will be bndry-Cell
            // cerr << "UnExpected GapCell (3) at initGapOpening! " << c_globalId(cellId) << endl;
            m_gapCells[it].status = 27;
          }
        }
      }
    }
  }

  MPI_Allreduce(MPI_IN_PLACE, &noArisingGapCells[0], m_noGapRegions, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "noArisingGapCells[0]");
  MPI_Allreduce(MPI_IN_PLACE, &noNewBndryCells[0], m_noGapRegions, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "noNewBndryCells[0]");
  MPI_Allreduce(MPI_IN_PLACE, &noArisingGapCellsHalo[0], m_noGapRegions, MPI_INT, MPI_SUM, mpiComm(), AT_,
                "MPI_IN_PLACE", "noArisingGapCellsHalo[0]");
  MPI_Allreduce(MPI_IN_PLACE, &noNewBndryCellsHalo[0], m_noGapRegions, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "noNewBndryCellsHalo[0]");

  // c) special Treatment if any Gap Opens:
  //   meaning either gapState 2 or fullyGapOpening during gap-Widening!
  if(anyGapOpening || anyFullyGapOpened) {
    for(MInt region = 0; region < m_noGapRegions; region++) {
      if(m_gapState[region] == 2 && domainId() == 0) {
        cerr << "Number of Arising-Gap-Cells " << noArisingGapCells[region] << " in region " << region << endl;
        cerr << "Number of new-Bndry-Cells " << noNewBndryCells[region] << " in region " << region << endl;
      } else if(domainId() == 0 && m_gapState[region] == 3) {
        cerr << "Number of Fully arising-Gap-Cells " << fullyGapOpened[region] << " in region " << region << endl;
        cerr << "Number of new-Bndry-Cells " << fullyGapBndry[region] << " in region " << region << endl;
      }
    }

    initGapCellExchange();

    // 2) init arising GapCells and new Bndry-Cells
    for(MInt region = 0; region < m_noGapRegions; region++) {
      if(m_gapState[region] != 2 && !fullyGapOpened[region]) continue;
      for(MUint it = 0; it < m_gapCells.size(); it++) {
        const MInt regionId = m_gapCells[it].region;
        if(regionId != region) continue;
        const MInt cellId = m_gapCells[it].cellId;
        const MInt status = m_gapCells[it].status;

        if(status == 21) {
          if(!a_isHalo(cellId)) {
            interpolationCells.push_back(cellId);
          }

          // these are all arings-Gap-Cells:
          //(sudden change towards internal Cells)
          // they need to be initialised before the cell-linking
          ASSERT(!a_hasProperty(cellId, SolverCell::IsInactive), "");

          // 1) restore all surfaces
          restoreSurfaces(cellId);

          // 2) init with the infinity-variables!

          a_pvariable(cellId, PV->RHO) = m_rhoInfinity;
          a_pvariable(cellId, PV->U) = F0;
          a_pvariable(cellId, PV->V) = F0;
          IF_CONSTEXPR(nDim == 3) a_pvariable(cellId, PV->W) = F0;
          a_pvariable(cellId, PV->P) = m_PInfinity;

          // 3) set the correct Volume
          a_cellVolume(cellId) = grid().gridCellVolume(a_level(cellId));
          m_cellVolumesDt1[cellId] = grid().gridCellVolume(a_level(cellId));
          a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));

          // 4) initialise rightHandSide
          for(MInt v = 0; v < m_noFVars; v++) {
            a_rightHandSide(cellId, v) = F0;
            m_rhs0[cellId][v] = F0;
          }

          // 5) treat as if the cell would have been active before
          //   this way, no special Linking is necessary!
          //   and small bndry-cells can be linked to the large arising Gap-Cells
          //   -> less checkNeighborActive!
          ASSERT(a_hasProperty(cellId, SolverCell::WasInactive), "");
          a_hasProperty(cellId, SolverCell::WasInactive) = false;

        } else if(status == 22) {
          if(!a_isHalo(cellId)) {
            interpolationCells.push_back(cellId);
          }

          ASSERT(!a_hasProperty(cellId, SolverCell::IsInactive), "");
          // 1) init with the infinity-variables!

          a_pvariable(cellId, PV->RHO) = m_rhoInfinity;
          a_pvariable(cellId, PV->U) = F0;
          a_pvariable(cellId, PV->V) = F0;
          IF_CONSTEXPR(nDim == 3) a_pvariable(cellId, PV->W) = F0;
          a_pvariable(cellId, PV->P) = m_PInfinity;

          // 2) initialise rightHandSide
          for(MInt v = 0; v < m_noFVars; v++) {
            a_rightHandSide(cellId, v) = F0;
            m_rhs0[cellId][v] = F0;
          }
        }
      }
    }

    // for security/backup reasons!
    gapCellExchange(1);

    // 3) interpolate primativeVariables for arising GapCells and new bndry-Cells
    //   status 21,22
    vector<MInt> noIterations;
    for(MInt region = 0; region < m_noGapRegions; region++) {
      noIterations.push_back(0);
      noIterations[region] = noArisingGapCells[region] + (MInt)(noNewBndryCells[region] / IPOW2(nDim))
                             + fullyGapOpened[region] + fullyGapBndry[region];
      noIterations[region] = mMax(noIterations[region], 100);
    }

    MPI_Allreduce(MPI_IN_PLACE, &noIterations[0], m_noGapRegions, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE",
                  "noIterations[0]");

    for(MInt region = 0; region < m_noGapRegions; region++) {
      if(m_gapState[region] != 2 && !fullyGapOpened[region]) continue;
#if defined _MB_DEBUG_ || !defined NDEBUG
      if(domainId() == 0) {
        cerr << "Starting to iterate for region: " << region << " with " << noIterations[region] << " Iterations! "
             << endl;
      }
#endif
      // iterate over the global number of arisingGapCells
      for(MInt loop = 0; loop < noIterations[region]; loop++) {
        for(MUint i = 0; i < interpolationCells.size(); i++) {
          const MInt cellId = interpolationCells[i];
          const MInt it = m_gapCellId[cellId];
          ASSERT(it >= 0, "");
          const MInt regionId = m_gapCells[it].region;
          if(regionId != region) continue;
          const MInt status = m_gapCells[it].status;

          ASSERT(status == 21 || status == 22, "");
          ASSERT(!a_isHalo(cellId), "");

          // all-arising gap-cells in the region:
          MInt noNghbrs = 0;
          MFloat pVariables[5] = {F0, F0, F0, F0, F0};

          for(MInt dir = 0; dir < m_noDirs; dir++) {
            if(!checkNeighborActive(cellId, dir) || a_hasNeighbor(cellId, dir) == 0) continue;
            MInt nghbrId = c_neighborId(cellId, dir);
            if(nghbrId < 0) continue;
            ASSERT(!a_hasProperty(nghbrId, SolverCell::IsInactive), "");
            if(!a_wasGapCell(nghbrId) && a_hasProperty(nghbrId, SolverCell::WasInactive)) continue;

            /*
            if(!a_wasGapCell(nghbrId)) {
              //TODO labels:FVMB change to ASSERT!
              if(loop == 0) {
                cerr << "Interpolation from not-gap-Cell -> Strange "
                     << a_hasProperty(nghbrId, SolverCell::IsInactive)
                     << a_hasProperty(nghbrId, SolverCell::WasInactive)
                     << a_isBndryCell(nghbrId) << " " << c_globalId(cellId) << endl;
              }
              if(!a_hasProperty(cellId, SolverCell::IsInactive) &&
                 !a_hasProperty(cellId, SolverCell::WasInactive)) {
                cerr << "CAUTION: Interpolation-Cell has a active Neighbor which was not a Gap-Cell "
                     << c_globalId(cellId) << " " << c_globalId(nghbrId) << endl;
              }
              continue;
            }
            */
            MInt nghbrGapId = m_gapCellId[nghbrId];
            if(nghbrGapId >= 0) {
              // if the neighbor is a gap-cell further checks can be done:

              MInt nghbrStatus = m_gapCells[nghbrGapId].status;
              // avoid inactive-neighbors
              if(nghbrStatus == 26) continue;

              // skip gap-bndry-cells and only use internal cells for interpolation!
              if(nghbrStatus == 23 || nghbrStatus == 24) {
                // gap-bndry-Cell
                //-> find avtive gap-Cell be going one Step further in the same direction!
                if(!checkNeighborActive(nghbrId, dir) || a_hasNeighbor(nghbrId, dir) == 0) continue;
                nghbrId = c_neighborId(nghbrId, dir);
                if(nghbrId < 0) continue;
                nghbrGapId = m_gapCellId[nghbrId];
                nghbrStatus = m_gapCells[nghbrGapId].status;

                if(nghbrStatus == 23) {
                  // going another Step further
                  if(!checkNeighborActive(nghbrId, dir) || a_hasNeighbor(nghbrId, dir) == 0) continue;
                  nghbrId = c_neighborId(nghbrId, dir);
                  if(nghbrId < 0) continue;
                  nghbrGapId = m_gapCellId[nghbrId];
                  nghbrStatus = m_gapCells[nghbrGapId].status;
                }
              }

              // skip gap-bndry-cells and only use internal cells for interpolation!
              if(nghbrStatus == 10 || nghbrStatus == 14) {
                // gap-bndry-Cell
                //-> find avtive gap-Cell be going one Step further in the same direction!
                if(!checkNeighborActive(nghbrId, dir) || a_hasNeighbor(nghbrId, dir) == 0) continue;
                nghbrId = c_neighborId(nghbrId, dir);
                if(nghbrId < 0) continue;
                nghbrGapId = m_gapCellId[nghbrId];
                nghbrStatus = m_gapCells[nghbrGapId].status;

                if(nghbrStatus == 10) {
                  // going another Step further
                  if(!checkNeighborActive(nghbrId, dir) || a_hasNeighbor(nghbrId, dir) == 0) continue;
                  nghbrId = c_neighborId(nghbrId, dir);
                  if(nghbrId < 0) continue;
                  nghbrGapId = m_gapCellId[nghbrId];
                  nghbrStatus = m_gapCells[nghbrGapId].status;
                }
              }
              if(nghbrStatus == 26) continue;

              if(m_gapState[region] == 2 && a_wasGapCell(nghbrId) && nghbrStatus != 25 && nghbrStatus != 21
                 && nghbrStatus != 23 && nghbrStatus != 22 && nghbrStatus != 24) {
                cerr << "Caution: using strange neighbor for interpolation: " << c_globalId(cellId) << " " << status
                     << " " << c_globalId(nghbrId) << " " << a_wasGapCell(nghbrId) << " "
                     << a_hasProperty(nghbrId, SolverCell::WasInactive) << " " << nghbrStatus << endl;
              } else if(m_gapState[region] == 3 && a_wasGapCell(nghbrId) && nghbrStatus != 21 && nghbrStatus != 22
                        && nghbrStatus != 10 && nghbrStatus != 14) {
                cerr << "Caution: using strange neighbor for interpolation: " << c_globalId(cellId) << " " << status
                     << " " << c_globalId(nghbrId) << " " << a_wasGapCell(nghbrId) << " "
                     << a_hasProperty(nghbrId, SolverCell::WasInactive) << " " << nghbrStatus << endl;
              }
            }

            if(a_hasProperty(nghbrId, SolverCell::IsInactive)) continue;

            ASSERT(!a_hasProperty(nghbrId, SolverCell::IsInactive), "");
            if(!a_wasGapCell(nghbrId) && a_hasProperty(nghbrId, SolverCell::WasInactive)) continue;

            // only use former internal-Cells for interpolation!
            auto it1 = m_oldBndryCells.find(nghbrId);
            if(it1 != m_oldBndryCells.end()) continue;


            noNghbrs++;
            pVariables[0] += a_pvariable(nghbrId, PV->RHO);
            pVariables[1] += a_pvariable(nghbrId, PV->P);
            pVariables[2] += a_pvariable(nghbrId, PV->U);
            pVariables[3] += a_pvariable(nghbrId, PV->V);
            IF_CONSTEXPR(nDim == 3) pVariables[4] += a_pvariable(nghbrId, PV->W);

            // if(!a_isHalo(cellId) && loop == 0)
            //  cerr << "Neighbors of Arising Gap-Cell " << c_globalId(cellId) << " "
            //       << c_globalId(nghbrId) << " status " << nghbrStatus << endl;
          }
          if(noNghbrs > 0) {
            a_pvariable(cellId, PV->RHO) = pVariables[0] / noNghbrs;
            a_pvariable(cellId, PV->P) = pVariables[1] / noNghbrs;
            a_pvariable(cellId, PV->U) = pVariables[2] / noNghbrs;
            a_pvariable(cellId, PV->V) = pVariables[3] / noNghbrs;
            IF_CONSTEXPR(nDim == 3) a_pvariable(cellId, PV->W) = pVariables[4] / noNghbrs;
          }
        }

        gapCellExchange(0);
      }
    }

    // 2) set wasInactive to false for large bndry-Cells
    //   some cells with status 22 are changed to status 29!
    //   (bndry-Cells outside the small-Cell-Treatment and thus should be stable)
    //   -> the smaller neighboring cells can be linked to them esier!

    for(MInt region = 0; region < m_noGapRegions; region++) {
      if(m_gapState[region] != 2) continue;
      for(MUint it = 0; it < m_gapCells.size(); it++) {
        MInt regionId = m_gapCells[it].region;
        if(regionId != region) continue;
        MInt cellId = m_gapCells[it].cellId;
        MInt status = m_gapCells[it].status;

        if(status != 22) continue;

        if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_volume / grid().gridCellVolume(a_level(cellId)) > 0.5) {
          a_hasProperty(cellId, SolverCell::WasInactive) = false;
          m_oldBndryCells.insert(make_pair(cellId, F0));
          m_gapCells[it].status = 29;
        }
        if(noArisingGapCells[region] == 0 && fullyGapOpened[region] == 0) {
          // if only bndry-cells are arising: (this means that gapWidth < cellLength)
          if(m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_volume / grid().gridCellVolume(a_level(cellId))
             > (0.5 * 0.5)) {
            a_hasProperty(cellId, SolverCell::WasInactive) = false;
            m_oldBndryCells.insert(make_pair(cellId, F0));
            m_gapCells[it].status = 29;
          }
        }
      }
    }


    // 4) set conservativeVariables of Gap-Cells
    //   and set wasInactive accoring to checkNeighborActivity for bndry-Cells
    for(MInt region = 0; region < m_noGapRegions; region++) {
      if(m_gapState[region] != 2) continue;
      for(MUint it = 0; it < m_gapCells.size(); it++) {
        MInt regionId = m_gapCells[it].region;
        if(regionId != region) continue;
        MInt cellId = m_gapCells[it].cellId;
        MInt status = m_gapCells[it].status;

        if(status != 21 && status != 22 && status != 29) continue;

        setConservativeVariables(cellId);

        // init oldVariable
        for(MInt varId = 0; varId < CV->noVariables; varId++) {
          a_oldVariable(cellId, varId) = a_variable(cellId, varId);
        }

        if(status != 21) {
          //= bndry-Cells
          // status == 22 or 29
          // activate further neighbors which have small cells with wasInactive
          MInt largestNeighbor = checkNeighborActivity(cellId);
          if(largestNeighbor > 0) {
            MInt largestNeighborGapCellId = m_gapCellId[largestNeighbor];
            m_gapCells[largestNeighborGapCellId].status = 28;
            if(a_isHalo(largestNeighbor)) {
              m_gapCells[largestNeighborGapCellId].status = -99;
            }
          }
        }
      }
    }

    gapCellExchange(1);


    // 5) match Cell-types at initGapOpening and estimate total-mass-loss
    /*

       for(MInt region = 0; region < m_noGapRegions; region++) {
         if(m_gapState[region] != 2) continue;
         for(MUint it = 0; it < m_gapCells.size(); it++){
           MInt regionId = m_gapCells[it].region;
           if(regionId != region) continue;
           MInt cellId = m_gapCells[it].cellId;
           MInt status = m_gapCells[it].status;

           if(a_isHalo(cellId)) continue;

           //find the status of the cell at initGapClosure
           MUint it1 = m_gapCellsBackup.size();
           for( MUint it2 = 0; it2 < m_gapCellsBackup.size(); it2++){
             if(m_gapCellsBackup[it2].cellId == cellId ) {
             it1 = it2;
             break;
             }
           }

           if(it1 == m_gapCellsBackup.size()) {
             //cerr << "WasGapCell at initGapOpening not found in gapCellBackup " << c_globalId(cellId)
             //     << " " << status << endl;
             continue;
           }
           MInt oldstatus = m_gapCellsBackup[it1].status;


           if(status == 21 && oldstatus != 4) {
             cerr << "Arising-Gap-Cell doesn't match gap-shadowed Cell " << c_globalId(cellId) << " "
                  << oldstatus << endl;

           } else if (status == 26 && oldstatus != 9) {
             cerr << "Body-shadowed Gap-Cells not matching " << c_globalId(cellId) << " "
                  << oldstatus << endl;
           } else if (status == 23 && oldstatus != 7) {
             cerr << "Gap-Bndry-Cells not matching " << c_globalId(cellId) << " " << oldstatus << endl;
           } else if(status == 22 && oldstatus != 5) {
             cerr << "Body-Bndry-Cells not matching " <<  c_globalId(cellId) << " " << oldstatus << endl;
           }

         }
       }
    */
  }


  // now add splitChilds and set the correct Gap-state, region and status
  // for initGapopening, also update the changes from the splitCell to the splitChilds!
  MInt noGapSplitChild = 0;
  for(MUint sc = 0; sc < m_splitCells.size(); sc++) {
    const MInt cellId = m_splitCells[sc];
    if(m_gapCellId[cellId] < 0) continue;
    for(MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) {
      const MInt splitChildId = m_splitChilds[sc][ssc];
      a_isGapCell(splitChildId) = a_isGapCell(cellId);
      a_wasGapCell(splitChildId) = a_wasGapCell(cellId);
      if(a_isGapCell(splitChildId) || a_wasGapCell(splitChildId)) {
        noGapSplitChild++;
        const MInt region = m_gapCells[m_gapCellId[cellId]].region;
        const MInt status = m_gapCells[m_gapCellId[cellId]].status;
        const MInt body1 = m_gapCells[m_gapCellId[cellId]].bodyIds[0];
        const MInt body2 = m_gapCells[m_gapCellId[cellId]].bodyIds[1];
        const MInt gapId = m_gapCells.size();
        m_gapCells.emplace_back(splitChildId, region, status, body1, body2);
        m_gapCellId[splitChildId] = gapId;
        a_hasProperty(splitChildId, SolverCell::WasInactive) = a_hasProperty(cellId, SolverCell::WasInactive);

        if(region > m_noGapRegions) continue;
        // for initGapOpening: update splitchilds variables based on splitcell-values:
        if(m_gapState[region] == 2) {
          for(MInt var = 0; var < m_noCVars; var++) {
            a_variable(splitChildId, var) = a_variable(cellId, var);
            a_oldVariable(splitChildId, var) = a_variable(cellId, var);
          }
          for(MInt var = 0; var < m_noPVars; var++) {
            a_pvariable(splitChildId, var) = a_pvariable(cellId, var);
          }
          for(MInt var = 0; var < m_noFVars; var++) {
            a_rightHandSide(splitChildId, var) = a_rightHandSide(cellId, var);
            m_rhs0[splitChildId][var] = m_rhs0[cellId][var];
          }
        } else if(m_gapState[region] == -2) {
          // for initGapClosure: remove splitchilds Surfaces
          a_hasProperty(splitChildId, SolverCell::IsInactive) = a_hasProperty(cellId, SolverCell::IsInactive);
          for(MInt v = 0; v < m_noFVars; v++) {
            a_rightHandSide(splitChildId, v) = a_rightHandSide(cellId, v);
            m_rhs0[splitChildId][v] = m_rhs0[cellId][v];
          }
          if(!a_hasProperty(splitChildId, SolverCell::WasInactive)
             && a_hasProperty(splitChildId, SolverCell::IsInactive)) {
            removeSurfaces(cellId);
          }
        }
      }
    }
  }
  MPI_Allreduce(MPI_IN_PLACE, &noGapSplitChild, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "noGapSplitChild");

#if defined _MB_DEBUG_ || !defined NDEBUG
  if(domainId() == 0 && anyGapOpening) cerr << " Finished gap-Handling" << endl;
#endif

  if(noGapSplitChild > 0) {
    initGapCellExchange();
    gapCellExchange(1);

#if defined _MB_DEBUG_ || !defined NDEBUG
    if(domainId() == 0) {
      cerr << "Number of Gap-Split-Childs " << noGapSplitChild << endl;
    }
#endif
  }
}


/**
 * \brief determines Gap-state, and organises GapCells
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::checkGapCells() {
  TRACE();

  ASSERT(m_levelSet && m_closeGaps, "");
  ASSERT(m_gapInitMethod > 0, "");

  // const MFloat eps = sqrt( nDim ) * c_cellLengthAtLevel(m_lsCutCellBaseLevel);

  // general Checks in all cases:
  for(MInt region = 0; region < m_noGapRegions; region++) {
    for(MUint it = 0; it < m_gapCells.size(); it++) {
      const MInt regionId = m_gapCells[it].region;
      if(regionId != region) continue;
      const MInt cellId = m_gapCells[it].cellId;
      const MInt status = m_gapCells[it].status;

      ASSERT(a_cellVolume(cellId) > 0, "");

      if(a_cellVolume(cellId) > grid().gridCellVolume(a_level(cellId))) {
        const MInt globalId = cellId < c_noCells() ? c_globalId(cellId) : -1;
        cerr << "Large Volume " << globalId << " " << status << endl;
      }

      // ASSERT(m_cellVolumesDt1[ cellId ] > 0 , "");
      if(m_cellVolumesDt1[cellId] < 0) {
        const MInt globalId = cellId < c_noCells() ? c_globalId(cellId) : -1;
        cerr << "Negative Dt-Volume " << globalId << " " << status << " "
             << m_cellVolumesDt1[cellId] / grid().gridCellVolume(a_level(cellId)) << endl;
      }

      if(m_cellVolumesDt1[cellId] > grid().gridCellVolume(a_level(cellId))) {
        const MInt globalId = cellId < c_noCells() ? c_globalId(cellId) : -1;
        cerr << "Large Dt-Volume " << globalId << " " << status << " "
             << m_cellVolumesDt1[cellId] / grid().gridCellVolume(a_level(cellId)) << endl;
      }
    }
  }

  // current bndry-cells are checked in updateGapBoundaryCells!

  // during gapClosure
  for(MInt region = 0; region < m_noGapRegions; region++) {
    if(m_gapState[region] != -2) continue;
    for(MUint it = 0; it < m_gapCells.size(); it++) {
      const MInt regionId = m_gapCells[it].region;
      if(regionId != region) continue;
      const MInt cellId = m_gapCells[it].cellId;
      const MInt status = m_gapCells[it].status;
      if(status == 3 || status == 4) {
        ASSERT(a_hasProperty(cellId, SolverCell::IsInactive), "");
        for(MInt dir = 0; dir < m_noDirs; dir++) {
          ASSERT(m_cellSurfaceMapping[cellId][dir] == -1, "");
        }
        auto it1 = m_oldBndryCells.find(cellId);
        ASSERT(it1 == m_oldBndryCells.end(), "");
      } else if(status == 5 || status == 6 || status == 7) {
        ASSERT(a_isBndryCell(cellId), "");

      } else if(status == 8 || status == 9) {
        ASSERT(!a_hasProperty(cellId, SolverCell::IsInactive), "");
        ASSERT(!a_isBndryCell(cellId), "");
        ASSERT(abs(a_cellVolume(cellId) - grid().gridCellVolume(a_level(cellId))) < 0.000001, "");
      } else if(status == 2) {
        ASSERT(a_hasProperty(cellId, SolverCell::IsInactive), "");
      }
    }
  }

  // during gap widening
  for(MInt region = 0; region < m_noGapRegions; region++) {
    if(m_gapState[region] != 3) continue;
    for(MUint it = 0; it < m_gapCells.size(); it++) {
      const MInt regionId = m_gapCells[it].region;
      if(regionId != region) continue;
      const MInt cellId = m_gapCells[it].cellId;
      const MInt status = m_gapCells[it].status;

      ASSERT((status >= 10 && status < 18) || (status == 0 /*&& a_levelSetValuesMb(cellId, 0) < -eps*/)
                 || (status == 21 || status == 22 || status == 28 || status == 29),
             to_string(status));

      // check that all active cells either are a bndry-Cell or were active before
      if(!a_hasProperty(cellId, SolverCell::IsInactive) && !a_isBndryCell(cellId)) {
        ASSERT(!a_hasProperty(cellId, SolverCell::WasInactive), "");
      }

      if(status == 10)
        ASSERT(a_cellVolume(cellId) - grid().gridCellVolume(a_level(cellId)) < 0.00001, to_string(c_globalId(cellId)));

      if(status != 11) {
        if(a_cellVolume(cellId) < 0 || m_cellVolumesDt1[cellId] < 0) {
          cerr << "Volume-Error in gap-Cell " << c_globalId(cellId) << " " << status << " "
               << a_hasProperty(cellId, SolverCell::IsInactive) << " " << a_isHalo(cellId) << endl;
        }
      }

      if(status == 12 || status == 13) {
        if(a_isHalo(cellId)) {
          /*
          auto it1 = m_linkedHaloCells.find( cellId );
          if(it1 == m_linkedHaloCells.end()) {
          cerr << "CAUTION: unable to link Halo-gap BndryCell during Gap-Widening " << c_globalId(cellId)
               << " " << status << " " << a_hasProperty(cellId, SolverCell::IsInactive)
               << " " << a_isBndryCell(cellId) << " " << a_hasProperty(cellId, SolverCell::WasInactive)
               << " " << a_isHalo(cellId)
               << endl;
          }
          */
        } else if(!a_hasProperty(cellId, SolverCell::IsSplitChild)) {
          if(!a_hasProperty(cellId, SolverCell::IsTempLinked)) {
            cerr << "CAUTION: unable to link gap BndryCell during Gap-Widening " << c_globalId(cellId) << " " << status
                 << " " << a_hasProperty(cellId, SolverCell::IsInactive) << " " << a_isBndryCell(cellId) << " "
                 << a_hasProperty(cellId, SolverCell::WasInactive) << " " << a_isHalo(cellId) << endl;
          }
        }

      } else if(status == 14 || status == 15) {
        if(a_cellVolume(cellId) < 0 || a_cellVolume(cellId) > grid().gridCellVolume(a_level(cellId))) {
          // cerr << "Invalid Volume " << c_globalId(cellId) << " " << status
          //      << " " << a_isHalo(cellId) << " " << a_cellVolume(cellId) << " "
          //      << a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) << " "
          //      << a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId)) << endl;
        }
      }
    }
  }

  // during gap opening
  for(MInt region = 0; region < m_noGapRegions; region++) {
    if(m_gapState[region] != 2) continue;
    for(MUint it = 0; it < m_gapCells.size(); it++) {
      const MInt regionId = m_gapCells[it].region;
      if(regionId != region) continue;
      const MInt cellId = m_gapCells[it].cellId;
      const MInt status = m_gapCells[it].status;

      ASSERT(((status > 20 && status <= 29) || status == 99 || status == 98), to_string(status));

      if(status == 21) {
        if(a_cellVolume(cellId) > grid().gridCellVolume(a_level(cellId))
           || a_cellVolume(cellId) < grid().gridCellVolume(a_level(cellId))) {
          cerr << "Incorrect Cell-Volume of arising Gap-Cell" << c_globalId(cellId) << " " << a_cellVolume(cellId)
               << " " << grid().gridCellVolume(a_level(cellId)) << endl;
        }

        // surface-check
        ASSERT(!a_hasProperty(cellId, SolverCell::IsInactive), "");

        if(a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
        for(MInt dir = 0; dir < m_noDirs; dir++) {
          MInt srfcId = m_cellSurfaceMapping[cellId][dir];
          MInt nghbrId = c_neighborId(cellId, dir);
          if(nghbrId < 0) continue;
          if(a_isHalo(cellId) && a_isHalo(nghbrId)) continue;
          if(srfcId < 0) {
            cerr << "CAUTION: Arising-Gap-Cell is missing surfaces " << c_globalId(cellId) << " " << dir << " "
                 << a_levelSetValuesMb(cellId, 0) << " " << a_isHalo(cellId) << " "
                 << a_hasProperty(cellId, SolverCell::IsNotGradient) << endl;
          }
        }
      } else if(status == 22 && false) {
        if(!a_isHalo(cellId)) {
          if(!a_hasProperty(cellId, SolverCell::IsTempLinked)) {
            cerr << "CAUTION: unable to link gap BndryCell during initGapOpening " << c_globalId(cellId) << " "
                 << status << " " << a_hasProperty(cellId, SolverCell::IsInactive) << " " << a_isBndryCell(cellId)
                 << " " << a_hasProperty(cellId, SolverCell::WasInactive) << " " << a_isHalo(cellId) << endl;
          }
        }
      }
    }
  }

  // during gap shrinking
  for(MInt region = 0; region < m_noGapRegions; region++) {
    if(m_gapState[region] != -1) continue;
    for(MUint it = 0; it < m_gapCells.size(); it++) {
      MInt regionId = m_gapCells[it].region;
      if(regionId != region) continue;
      MInt cellId = m_gapCells[it].cellId;

      if(!a_isBndryCell(cellId)) continue;
      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
      if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;

      if(a_wasGapCell(cellId) && !a_isGapCell(cellId)) continue;

      MInt bndryId = a_bndryId(cellId);
      if(bndryId < -1) continue;
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        for(MInt i = 0; i < nDim; i++) {
          ASSERT(abs(m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]]) < 0.00000001, "");
        }
        MInt ghostCellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_ghostCellId;
        if(ghostCellId < 0) continue;
      }
    }
  }

  // checkGapHaloCells:
  const MInt noChecks = 4;
  MFloatScratchSpace cellCheck(a_noCells(), noChecks, AT_, "cellCheck");
  cellCheck.fill(std::numeric_limits<MFloat>::max());

  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    cellCheck(cellId, 0) = (MFloat)a_isGapCell(cellId);
    cellCheck(cellId, 1) = (MFloat)a_wasGapCell(cellId);
    cellCheck(cellId, 2) = -F1;
    cellCheck(cellId, 3) = -F1;
    if(a_isGapCell(cellId) || a_wasGapCell(cellId)) {
      const MInt region = m_gapCells[m_gapCellId[cellId]].region;
      const MInt status = m_gapCells[m_gapCellId[cellId]].status;
      cellCheck(cellId, 2) = (MFloat)region;
      cellCheck(cellId, 3) = (MFloat)status;
    }
  }

  exchangeDataFV(&cellCheck(0), noChecks);

  for(MInt cellId = noInternalCells(); cellId < a_noCells(); cellId++) {
    if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
    if((MInt)cellCheck(cellId, 0) != a_isGapCell(cellId)) {
      cerr << domainId() << ": ERR0 checkGapHaloCells " << globalTimeStep << " " << c_globalId(cellId) << endl;
    }
    if((MInt)cellCheck(cellId, 1) != a_wasGapCell(cellId)) {
      cerr << domainId() << ": ERR1 checkGapHaloCells " << globalTimeStep << " " << c_globalId(cellId) << endl;
    }
    MInt region = -1;
    MInt status = -1;
    if(a_isGapCell(cellId) || a_wasGapCell(cellId)) {
      region = m_gapCells[m_gapCellId[cellId]].region;
      status = m_gapCells[m_gapCellId[cellId]].status;
    }

    if((MInt)cellCheck(cellId, 2) != region) {
      cerr << domainId() << ": ERR2 checkGapHaloCells " << globalTimeStep << " " << c_globalId(cellId) << endl;
    }
    if((MInt)cellCheck(cellId, 3) != status) {
      cerr << domainId() << ": ERR3 checkGapHaloCells " << globalTimeStep << " " << c_globalId(cellId) << endl;
    }
  }
}


/**
 * \brief set the gapCellId for gapInitMethod = 0, otherwise handeled in gapHandling!
 * \author Tim Wegmann
 *
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::setGapCellId() {
  TRACE();

  ASSERT(m_gapInitMethod == 0, "");

  m_gapCellId.clear();
  m_gapCellId.resize(a_noCells());
  for(MInt i = 0; i < a_noCells(); i++)
    m_gapCellId[i] = -1;

  for(MUint it = 0; it < m_gapCells.size(); it++) {
    const MInt cellId = m_gapCells[it].cellId;
    m_gapCellId[cellId] = (MInt)it;
  }

  for(MUint sc = 0; sc < m_splitCells.size(); sc++) {
    const MInt cellId = m_splitCells[sc];
    if(m_gapCellId[cellId] < 0) continue;
    for(MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) {
      const MInt splitChildId = m_splitChilds[sc][ssc];
      if(a_isGapCell(splitChildId) || a_wasGapCell(splitChildId)) {
        const MInt gapId = m_gapCells.size();
        const MInt region = m_gapCells[m_gapCellId[cellId]].region;
        const MInt status = m_gapCells[m_gapCellId[cellId]].status;
        const MInt body1 = m_gapCells[m_gapCellId[cellId]].bodyIds[0];
        const MInt body2 = m_gapCells[m_gapCellId[cellId]].bodyIds[1];
        m_gapCells.emplace_back(splitChildId, region, status, body1, body2);
        m_gapCellId[splitChildId] = gapId;
      }
    }
  }
}


/**
 * \brief set the velocity at gap-Boundary-Cells
 *        due to the irregular movement of the gap-surface during widening and shrinking
 *        the velocity and the volumes needs to be adapted
 * \author Tim Wegmann
 *
 *
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::updateGapBoundaryCells() {
  TRACE();

  ASSERT(m_levelSet && m_closeGaps, "");
  ASSERT(m_gapInitMethod > 0, "");

  // during initGapClosure
  for(MInt region = 0; region < m_noGapRegions; region++) {
    if(m_gapState[region] != -2) continue;

    // easy-first try: static initialisation:
    // sweptVolume = sweptVolumeDt = 0
    // cellVolume  = cellVolumeDt  = bndry-Cell-volume
    // velocity    = 0

    for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
      const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
      if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
      const MInt gapCellId = m_gapCellId[cellId];
      if(gapCellId < 0) continue;
      const MInt regionId = m_gapCells[gapCellId].region;
      if(regionId != region) continue;

      const MInt status = m_gapCells[gapCellId].status;

      // do cell-Volume update based on split-cell volumes
      if(a_hasProperty(cellId, SolverCell::IsSplitChild)) {
        for(MInt v = 0; v < m_noFVars; v++) {
          a_rightHandSide(cellId, v) = F0;
          m_rhs0[cellId][v] = F0;
        }
        m_sweptVolumeDt1[bndryId] = 0;
        m_sweptVolume[bndryId] = 0;
        for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
          for(MInt i = 0; i < nDim; i++) {
            m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] = 0;
          }
        }
        continue;
      }
      // change to ASSERT!
      if(status != 5 && status != 6 && status != 7 && status != 99) {
        cerr << "UnExpected Bndry-Cell-Status (1) " << c_globalId(cellId) << " " << status << endl;
      }

      // all active gap-bndry-Cells, now reseted:
      a_cellVolume(cellId) = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume;
      m_cellVolumesDt1[cellId] = a_cellVolume(cellId);
      m_sweptVolumeDt1[bndryId] = 0;
      m_sweptVolume[bndryId] = 0;
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        for(MInt i = 0; i < nDim; i++) {
          m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] = 0;
        }
      }
      for(MInt v = 0; v < m_noFVars; v++) {
        a_rightHandSide(cellId, v) = F0;
        m_rhs0[cellId][v] = F0;
      }
    }
  }

  // during gap-widening or shrinking
  for(MInt region = 0; region < m_noGapRegions; region++) {
    if(m_gapState[region] != 3 && m_gapState[region] != -1) continue;

    // easy-first try: static initialisation:
    // sweptVolume = sweptVolumeDt = 0
    // cellVolume  = cellVolumeDt  = bndry-Cell-volume
    // velocity    = 0

    for(MUint it = 0; it < m_gapCells.size(); it++) {
      const MInt regionId = m_gapCells[it].region;
      if(regionId != region) continue;
      const MInt cellId = m_gapCells[it].cellId;
      const MInt status = m_gapCells[it].status;

      if(!a_isBndryCell(cellId)) continue;
      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
      if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;

      if(a_wasGapCell(cellId) && !a_isGapCell(cellId)) continue;

      // do this on split-Child-basis
      // if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;

      MInt bndryId = a_bndryId(cellId);
      if(bndryId < -1) continue;

      // do cell-Volume update based on split-cell volumes
      if(a_hasProperty(cellId, SolverCell::IsSplitChild)) {
        for(MInt v = 0; v < m_noFVars; v++) {
          a_rightHandSide(cellId, v) = F0;
          m_rhs0[cellId][v] = F0;
        }
        m_sweptVolumeDt1[bndryId] = 0;
        m_sweptVolume[bndryId] = 0;
        for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
          for(MInt i = 0; i < nDim; i++) {
            m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] = 0;
          }
        }
        continue;
      }

      a_cellVolume(cellId) = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume;
      m_cellVolumesDt1[cellId] = a_cellVolume(cellId);
      m_sweptVolumeDt1[bndryId] = 0;
      m_sweptVolume[bndryId] = 0;
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        for(MInt i = 0; i < nDim; i++) {
          m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] = 0;
        }
      }

      // for partial-Gap-Opening:
      // largestNeighbor of a new small gap Cell
      if(status == 17) {
        MFloat dV = F0;
        MFloat dt = timeStep(true);

        for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
          MFloat area = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
          for(MInt i = 0; i < nDim; i++) {
            MFloat nml = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
            dV -= dt * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] * nml * area;
          }
        }

        MFloat cellVolume = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume;

        if(dV > cellVolume) {
          dV = cellVolume;
          // get<2>(m_gapCells[gapCellId]) = 99;
        }

        m_sweptVolume[bndryId] = dV;
        m_sweptVolumeDt1[bndryId] = dV;

        // reduce bndry-Cell velocity to fit the boundary-Condition!
        MFloat delta = maia::math::deltaFun(m_volumeFraction[bndryId], F0, F1);
        for(MInt i = 0; i < nDim; i++) {
          a_pvariable(cellId, PV->VV[i]) =
              delta * a_pvariable(cellId, PV->VV[i])
              + (F1 - delta) * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->VV[i]];
        }
        setConservativeVariables(cellId);
        for(MInt varId = 0; varId < CV->noVariables; varId++) {
          a_oldVariable(cellId, varId) = a_variable(cellId, varId);
        }
      }

      // Plan-B: estimate the interface-velocity based on the volume-change!
      /*
      //compute the surface-velocity based on the volume-change of the cell
      MFloat vol = m_fvBndryCnd->m_bndryCells->a[ bndryId ].m_volume;
      MFloat volDt1 = m_cellVolumesDt1[ cellId ];

      auto it1 = m_oldBndryCells.find( cellId );
      if(a_hasProperty(cellId, SolverCell::WasInactive)) {
        cerr << "WasInactive " << m_cellVolumesDt1[ cellId ]/grid().gridCellVolume( a_level(cellId) ) << endl;
      } else if(it1 != m_oldBndryCells.end()) {
        cerr << "WasBndryCell " << m_cellVolumesDt1[ cellId ]/grid().gridCellVolume( a_level(cellId) )
             << " " << m_sweptVolumeDt1[a_bndryId( cellId )] << endl;
      } else {
        cerr << "WasActive " << m_cellVolumesDt1[ cellId ]/grid().gridCellVolume( a_level(cellId) ) << endl;
      }

      MFloat dV = vol - volDt1;
      MFloat dt = timeStep(true);
      MFloat sign = (dV > 0) ? 1.0 : -1.0;

      for( MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++){
        MFloat area = m_fvBndryCnd->m_bndryCells->a[ bndryId ].m_srfcs[srfc]->m_area;
        MFloat absVel =  abs(dV / (area * dt));
        for( MInt i=0; i<nDim; i++ ) {
         MFloat nml = m_fvBndryCnd->m_bndryCells->a[ bndryId ].m_srfcs[srfc]->m_normalVector[ i ];

         MFloat velocity = sign * absVel *nml;
         m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] = velocity;

         cerr << globalTimeStep << " " << c_globalId(cellId) << " "
              << vol /grid().gridCellVolume( a_level(cellId) )  << " "
              << volDt1 / grid().gridCellVolume( a_level(cellId) )  << " " << i << " " << velocity
              << " " << nml << " " <<  m_sweptVolumeDt1[a_bndryId( cellId )] << endl;

        }
      }
      */
    }
  }

  // during initGapOpening (handeled in updateCellVolumeGCL! )

  // easy-first try: just as upon-restart
  // sweptVolume   = sweptVolumeDt = dV
  // cellVolume    = bndry-Cell-volume
  // cellVolumeDt1 = cellVolume - deltaVolume
  // velocity      = body-velocity

  for(MInt region = 0; region < m_noGapRegions; region++) {
    if(m_gapState[region] != 2) continue;

    // Plan-A

    for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
      MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
      MInt gapCellId = m_gapCellId[cellId];
      if(gapCellId < 0) continue;

      const MInt regionId = m_gapCells[gapCellId].region;
      if(regionId != region) continue;

      ASSERT(a_wasGapCell(cellId), "");

      // do this on split-Child-basis
      if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;

      MInt status = m_gapCells[gapCellId].status;

      if(status == 27) {
        // wasInternal Cell before
        // treated regularly
        continue;
      }

      if(status != 22 && status != 24 && status != 28 && status != 29) {
        cerr << "UnExpected Bndry-Cell-Status (2) " << c_globalId(cellId) << " " << status << endl;
      }

      MFloat dV = F0;
      MFloat dt = timeStep(true);

      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        MFloat area = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
        for(MInt i = 0; i < nDim; i++) {
          MFloat nml = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
          dV -= dt * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] * nml * area;
        }
      }

      MFloat cellVolume = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume;

      if(dV > cellVolume) {
        dV = cellVolume;
        // gap-Cells, for which dV needs to be limited!
        m_gapCells[gapCellId].status = 98;
      }

      m_sweptVolume[bndryId] = dV;
      m_sweptVolumeDt1[bndryId] = dV;


      if(status == 22 || status == 28 || status == 29) {
        // reduce velocity in the cells to fit the boundary-Condition!
        // as the values are interpolated from non-boundary cells, this is necessary for all
        // new bndry-cells!
        MFloat delta = maia::math::deltaFun(m_volumeFraction[bndryId], F0, F1);
        for(MInt i = 0; i < nDim; i++) {
          a_pvariable(cellId, PV->VV[i]) =
              delta * a_pvariable(cellId, PV->VV[i])
              + (F1 - delta) * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->VV[i]];
        }
        setConservativeVariables(cellId);
        for(MInt varId = 0; varId < CV->noVariables; varId++) {
          a_oldVariable(cellId, varId) = a_variable(cellId, varId);
        }
      }
    }

    gapCellExchange(1);


    // Plan-B: static initialisation:
    //        not working!
    /*
    for(MUint it = 0; it < m_gapCells.size(); it++){
      MInt regionId = m_gapCells[it].region;
      if(regionId != region) continue;
      MInt cellId = m_gapCells[it].cellId;

      if(!a_isBndryCell(cellId)) continue;
      if(!a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) continue;
      if (a_hasProperty( cellId , SolverCell::IsInactive ) ) continue;


      MInt bndryId = a_bndryId( cellId );
      if(bndryId < -1 ) continue;

      a_cellVolume( cellId ) = m_fvBndryCnd->m_bndryCells->a[ bndryId ].m_volume;
      m_cellVolumesDt1[ cellId ] = a_cellVolume( cellId );
      m_sweptVolumeDt1[bndryId] = 0;
      m_sweptVolume[bndryId] = 0;
      for( MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++){
        for( MInt i=0; i<nDim; i++ ) {
          m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] = 0;
        }
      }
    }

    gapCellExchange(1);
    */
    /*
         if(status == 24 ) {
           //a bndry-Cell which was active before

           MInt bndryId = a_bndryId( cellId );
           if(bndryId < -1 ) continue;

           MFloat cellVolumes = m_fvBndryCnd->m_bndryCells->a[ bndryId ].m_volume;
           MFloat deltaVol = cellVolumes - m_cellVolumesDt1[ cellId ];
           MFloat sweptVolume = (deltaVol - (F1-m_RKalpha[ m_noRKSteps-2 ]) * m_sweptVolumeDt1[ bndryId ]) /
       m_RKalpha[ m_noRKSteps-2 ]; MFloat velocity = F0; MFloat dt = timeStep(true); MFloat noSurfaces = 0;
           MFloat surfaceVel = F0;

           for( MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++ ){

             surfaceVel = F0;
             for( MInt i = 0; i<nDim; i++) {
               surfaceVel += m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]];
             }
             //if(surfaceVel > 0 ) {
               noSurfaces++;
               MFloat area = m_fvBndryCnd->m_bndryCells->a[ bndryId ].m_srfcs[srfc]->m_area;
               velocity -= sweptVolume / (dt*area);
            // }
           }
           velocity = velocity / noSurfaces;

           cerr << "Velocity calculation: " << c_globalId(cellId) << " " << velocity << " "
                <<  m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->VV[0]] << " "
                << m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->VV[1]] << " "
                << m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->VV[2]] << " "
                << surfaceVel << endl;

    */
  }


  // g0-region-velocity:
  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    MInt gapCellId = m_gapCellId[cellId];
    if(gapCellId < 0) continue;

    const MInt regionId = m_gapCells[gapCellId].region;
    if(regionId != m_noGapRegions) continue;

    MFloat vel[3];
    for(MInt i = 0; i < nDim; i++) {
      vel[i] = m_gapCells[gapCellId].surfaceVelocity[i];
    }

    MFloat dV = 0;
    const MFloat dt = timeStep(true);
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      const MFloat area = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
      for(MInt i = 0; i < nDim; i++) {
        m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] = vel[i];
        //= 0;
        const MFloat nml = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
        dV -= dt * vel[i] * nml * area;
      }
    }
    if(dV * 100 / 5 > grid().gridCellVolume(a_level(cellId))) {
      cerr << "Large Volume change in G0-region cell! " << dV << " " << dV / m_cellVolumesDt1[cellId] << endl;
    }
  }

  // update-Split-childs based on split-cell volumes

  for(MUint sc = 0; sc < m_splitCells.size(); sc++) {
    const MInt cellId = m_splitCells[sc];
    if(m_gapCellId[cellId] > -1) continue;
    MFloat cvol = F0;
    for(MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) {
      const MInt splitChildId = m_splitChilds[sc][ssc];
      MFloat vol = m_fvBndryCnd->m_bndryCells->a[a_bndryId(splitChildId)].m_volume;
      cvol += vol;
      a_cellVolume(splitChildId) = vol * a_cellVolume(cellId);
      m_cellVolumesDt1[splitChildId] = vol * m_cellVolumesDt1[cellId];
    }
    cvol = mMax(1e-15, cvol);
    for(MUint ssc = 0; ssc < m_splitChilds[sc].size(); ssc++) {
      const MInt splitChildId = m_splitChilds[sc][ssc];
      a_cellVolume(splitChildId) /= cvol;
      m_cellVolumesDt1[splitChildId] /= cvol;
    }
  }
}


/**
 * \brief Links bndryCells
 * \author Lennart Schneiders, extension to triple-Links Update Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::linkBndryCells() {
  TRACE();

  if(!m_levelSetMb) return;

  ASSERT(m_temporarilyLinkedCells.size() < 1, "");

  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    a_hasProperty(cellId, SolverCell::IsTempLinked) = false;
  }

  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(!a_hasProperty(cellId, SolverCell::WasInactive)) continue;
    // a) new boundary cell: was inactive before and is !inactive
    //   -> emerging BndryCells will be linked

    // only link the split parent cell!!
    if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;

    // avoid double-linking
    if(a_hasProperty(cellId, SolverCell::IsTempLinked)) continue;

    // initialise oldVariable, will be resetted below!
    for(MInt v = 0; v < m_noCVars; v++) {
      a_oldVariable(cellId, v) = F0;
    }

    // old-version is not linking gapCells!
    if(m_levelSet && m_closeGaps && m_gapInitMethod == 0 && a_hasProperty(cellId, SolverCell::WasGapCell)
       && !a_hasProperty(cellId, SolverCell::IsGapCell)) {
      continue;
    }

    // Ensure that azimuthal cells are not linked. Otherwise exchange is needed
    // Here azimuthal halos are skipped. They are not used in the time step integration
    // anyway
    if(grid().azimuthalPeriodicity() && a_isPeriodic(cellId)) continue;

    // masterId is the the neighbour to the boundary-cell with the largest cell-volume!
    MInt masterId = -1;
    MInt tripleLink = -1;
    MFloat maxVol = F0;
    MInt noInternalNghbrs = 0;
    MInt noWasActiveNghbrs = 0;
    const MInt rootId = cellId;
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      if(!checkNeighborActive(rootId, dir) || a_hasNeighbor(rootId, dir) == 0) continue;
      const MInt nghbrId = c_neighborId(rootId, dir);
      if(nghbrId < 0) continue;
      if(!a_isHalo(nghbrId)) noInternalNghbrs++;
      if(a_hasProperty(nghbrId, SolverCell::WasInactive)) continue;
      noWasActiveNghbrs++;
      if(a_hasProperty(nghbrId, SolverCell::IsSplitCell)) continue;
      if(a_hasProperty(nghbrId, SolverCell::IsSplitChild)) continue;
      if(a_cellVolume(nghbrId) > maxVol) {
        masterId = nghbrId;
        maxVol = a_cellVolume(nghbrId);
      }
    }


    if(a_isHalo(cellId) && noInternalNghbrs == 0) continue;
    if(masterId > -1 && a_isHalo(cellId) && a_isHalo(masterId)) continue;

    // linking the master-cell and the boundary-cell
    //-> copying the masters-variables into the boundary-cell!
    if(masterId > -1) {
      m_temporarilyLinkedCells.push_back(make_tuple(cellId, masterId, tripleLink));
      a_hasProperty(cellId, SolverCell::IsTempLinked) = true;
      for(MInt v = 0; v < m_noCVars; v++) {
        a_variable(cellId, v) = a_variable(masterId, v);
        a_oldVariable(cellId, v) = a_oldVariable(masterId, v);
      }
      for(MInt v = 0; v < m_noPVars; v++) {
        a_pvariable(cellId, v) = a_pvariable(masterId, v);
      }

    } else { // no-master found

      // special treatment for the linking of gapCells
      /*
      if ( m_levelSet && m_closeGaps && m_gapInitMethod > 0) {
        // use levelSet value for masterId determination, so that the same linking is achived on
        // all ranks!
        MFloat lsValue = -99;
        if(m_gapCellId[cellId] > -1){
          if(m_gapCells[m_gapCellId[cellId]].status == 22 && false) {
            // 1: for initGapOpening
            // a) try linking new bndry-Cells(type 22) with arising gap-Cells(type21) in a double-link
            for ( MInt dir = 0; dir < m_noDirs; dir++ ) {
              if ( !checkNeighborActive (cellId , dir) || a_hasNeighbor(cellId, dir) == 0 )
                continue;
              MInt nghbrId = c_neighborId( cellId ,  dir );
              if ( nghbrId < 0 ) continue;
              if ( a_hasProperty( nghbrId ,  SolverCell::IsSplitCell ) ) continue;
              if ( a_hasProperty( nghbrId ,  SolverCell::IsSplitChild ) ) continue;
              if(m_gapCellId[nghbrId] > -1){
                if(m_gapCells[m_gapCellId[nghbrId]].status == 21) {
                  if(a_levelSetValuesMb(nghbrId, 0) > lsValue) {
                    masterId = nghbrId;
                    lsValue = a_levelSetValuesMb(nghbrId, 0);
                    ASSERT(abs(a_cellVolume(masterId) - grid().gridCellVolume(a_level(cellId))) < 0.00001, "");
                  }
                }
              }
            }
            m_temporarilyLinkedCells.push_back( make_tuple(cellId,masterId, tripleLink) );
            a_hasProperty( cellId ,  SolverCell::IsTempLinked ) = true;
            for ( MInt v = 0; v < m_noVars; v++ ) {
              a_variable( cellId ,  v ) = a_variable( masterId ,  v );
              a_oldVariable( cellId ,  v ) = a_oldVariable( masterId ,  v );
              a_pvariable( cellId ,  v ) =a_pvariable( masterId ,  v );
            }

            if(masterId < 0 ) {
              //b) if this is not working create a triple-link
              //   so first find the direct neighbor with the largest cellVolume
              //   and second, its masterId which should be an arising gap-Cell and
              //   finish by creating the triple-link !
              maxVol = F0;
              lsValue = -99;
              //cerr << "Searching neighbor for " << c_globalId(cellId) << endl;
              for ( MInt dir = 0; dir < m_noDirs; dir++ ) {
                if ( !checkNeighborActive (cellId , dir) || a_hasNeighbor(cellId, dir) == 0 )
                  continue;
                MInt nghbrId = c_neighborId( cellId ,  dir );
                if ( nghbrId < 0 ) continue;
                if ( a_hasProperty( nghbrId ,  SolverCell::IsSplitCell ) ) continue;
                if ( a_hasProperty( nghbrId ,  SolverCell::IsSplitChild ) ) continue;
                if ( a_cellVolume( nghbrId ) > maxVol ) {
                  tripleLink = nghbrId;
                  maxVol = a_cellVolume( nghbrId );
                }
              }
              if(tripleLink > 0) {
                if(a_isHalo(tripleLink)) {

                }


                //cerr << " Using neighbor " << c_globalId(tripleLink) << endl;
                if(a_hasProperty( tripleLink ,  SolverCell::IsTempLinked )) {
                  //tripleLink already has a singe-link
                  MUint it = m_temporarilyLinkedCells.size();
                  for( MUint it2 = 0; it2 < m_temporarilyLinkedCells.size(); it2++){
                    if(get<0>(m_temporarilyLinkedCells[it2]) == tripleLink ) {
                    it = it2;
                    break;
                    }
                  }
                  ASSERT(it < m_temporarilyLinkedCells.size(), "");
                  masterId = get<1>(m_temporarilyLinkedCells[it]);
                  //cerr << " Reusing masterId " << c_globalId(masterId) << endl;
                  //replace the masterId, and link the two smaller cells with each other!
                  m_temporarilyLinkedCells.erase(m_temporarilyLinkedCells.begin()+it);
                  m_temporarilyLinkedCells.push_back( make_tuple(cellId,masterId, tripleLink) );
                  a_hasProperty( cellId ,  SolverCell::IsTempLinked ) = true;
                  for ( MInt v = 0; v < m_noVars; v++ ) {
                    a_variable( cellId ,  v ) = a_variable( masterId ,  v );
                    a_oldVariable( cellId ,  v ) = a_oldVariable( masterId ,  v );
                    a_pvariable( cellId ,  v ) =a_pvariable( masterId ,  v );
                  }

                } else {
                  // tipleCellId doesn't have a link on this domain yet
                  // now, due the same procedure from the top
                  // So firt try to find the largest wasactive neighbor,
                  // and othwise the gapCell-Neigbor with the largest ls-Value
                  lsValue = -99;
                  maxVol = F0;
                  for ( MInt dir = 0; dir < m_noDirs; dir++ ) {
                    if ( !checkNeighborActive (rootId ,  dir) || a_hasNeighbor( rootId ,  dir ) == 0 ) continue;
                    const MInt nghbrId = c_neighborId( rootId ,  dir );
                    if ( nghbrId < 0 ) continue;
                    if ( a_hasProperty( nghbrId , SolverCell::WasInactive ) ) continue;
                    if ( a_hasProperty( nghbrId ,  SolverCell::IsSplitCell ) ) continue;
                    if ( a_hasProperty( nghbrId ,  SolverCell::IsSplitChild ) ) continue;
                    if ( a_cellVolume( nghbrId ) > maxVol ) {
                      masterId = nghbrId;
                      maxVol = a_cellVolume( nghbrId );
                    }
                  }
                  if (masterId < 0) {
                    for ( MInt dir = 0; dir < m_noDirs; dir++ ) {
                      if ( !checkNeighborActive (cellId , dir) || a_hasNeighbor(cellId, dir) == 0 )
                        continue;
                      MInt nghbrId = c_neighborId( tripleLink ,  dir );
                      if ( nghbrId < 0 ) continue;
                      if ( a_hasProperty( nghbrId ,  SolverCell::IsSplitCell ) ) continue;
                      if ( a_hasProperty( nghbrId ,  SolverCell::IsSplitChild ) ) continue;
                      if(m_gapCellId[nghbrId] > -1){
                        if(m_gapCells[m_gapCellId[nghbrId]].status == 21) {
                          if(a_levelSetValuesMb(nghbrId, 0) > lsValue) {
                            masterId = nghbrId;
                            lsValue = a_levelSetValuesMb(nghbrId, 0);
                            ASSERT(abs(a_cellVolume(masterId) - grid().gridCellVolume(a_level(cellId))) < 0.00001, "");
                          }
                        }
                      }
                    }
                  }
                  if(masterId < 0) {
                    cerr << "WTF, still no master found?! " << endl;
                  }
                  //cerr << " Using masterId " << c_globalId(masterId) << endl;
                  if( a_isHalo( cellId ) && a_isHalo(masterId) && a_isHalo(tripleLink)) continue;
                  m_temporarilyLinkedCells.push_back( make_tuple(cellId,masterId, tripleLink) );
                  a_hasProperty( cellId ,  SolverCell::IsTempLinked ) = true;
                  a_hasProperty( tripleLink ,  SolverCell::IsTempLinked ) = true;
                  for ( MInt v = 0; v < m_noVars; v++ ) {
                    a_variable( cellId ,  v ) = a_variable( masterId ,  v );
                    a_oldVariable( cellId ,  v ) = a_oldVariable( masterId ,  v );
                    a_pvariable( cellId ,  v ) =a_pvariable( masterId ,  v );

                    a_variable(tripleLink,  v ) = a_variable( masterId ,  v );
                    a_oldVariable(tripleLink,  v ) = a_oldVariable( masterId ,  v );
                    a_pvariable(tripleLink,  v ) =a_pvariable( masterId ,  v );
                  }
                }
              }
            }

          } else if (m_gapCells[m_gapCellId[cellId]].status == 13) {
             cerr << "Unlinked new bndry-Cell " << c_globalId(cellId) << endl;
             continue;

            cerr << "Searching neighbor for " << c_globalId(cellId) << endl;
            // 2: for partial gapOpening at gapWidening
            // this is nesessary for new bndry-cells, where only the diagonal neighbor wasactive before
            // in order to avoid triple-linking the cells without a direct neighbor that wasactive
            // are linked to a neighbor that was inactive before!
            maxVol = F0;
            MInt largestNeighbor = F0;
            for ( MInt dir = 0; dir < m_noDirs; dir++ ) {
              if ( !checkNeighborActive (cellId , dir) || a_hasNeighbor(cellId, dir) == 0 )
                continue;
              MInt nghbrId = c_neighborId( cellId ,  dir );
              if ( nghbrId < 0 ) continue;
              if ( a_hasProperty( nghbrId ,  SolverCell::IsSplitCell ) ) continue;
              if ( a_hasProperty( nghbrId ,  SolverCell::IsSplitChild ) ) continue;
              if ( a_cellVolume( nghbrId ) > maxVol ) {
                largestNeighbor = nghbrId;
                maxVol = a_cellVolume( nghbrId );
              }
            }
            //must have at least on acvive neighbor
            ASSERT(largestNeighbor > 0, "");
            //if the largest neighbor would have been active before, a regular link would have
            // been possible
            ASSERT(a_hasProperty(largestNeighbor, SolverCell::WasInactive), "");

            if(a_hasProperty( largestNeighbor ,  SolverCell::IsTempLinked )) {


            }


            if(masterId > 0) {
              cerr << "Creating single-link" << endl;
              cerr << "Found unlinked neighbor " << c_globalId(masterId) << endl;
              tripleLink = -1;
              if ( masterId > -1 && a_isHalo( cellId ) && a_isHalo(masterId) ) continue;
              m_temporarilyLinkedCells.push_back( make_tuple(cellId,masterId, tripleLink) );
              a_hasProperty( cellId ,  SolverCell::IsTempLinked ) = true;
              for ( MInt v = 0; v < m_noVars; v++ ) {
                a_variable( cellId ,  v ) = a_variable( masterId ,  v );
                a_oldVariable( cellId ,  v ) = a_oldVariable( masterId ,  v );
                a_pvariable( cellId ,  v ) =a_pvariable( masterId ,  v );
              }
            } else if(masterId < 0 && tripleLink > -1 ) {
              cerr << "Creating triple-Link" << endl;
              cerr << " Using neighbor " << c_globalId(tripleLink) << endl;
              if(a_hasProperty( tripleLink ,  SolverCell::IsTempLinked )) {
                //tripleLink already has a singe-link
                MUint it = m_temporarilyLinkedCells.size();
                for( MUint it2 = 0; it2 < m_temporarilyLinkedCells.size(); it2++){
                  if(get<0>(m_temporarilyLinkedCells[it2]) == tripleLink ) {
                  it = it2;
                  break;
                  }
                }
                if(it == m_temporarilyLinkedCells.size()){
                  cerr << "tripleLink is already part of a triple Link " << endl;
                }
                masterId = get<1>(m_temporarilyLinkedCells[it]);
                cerr << " Reusing masterId " << c_globalId(masterId) << endl;
                m_temporarilyLinkedCells.erase(m_temporarilyLinkedCells.begin()+it );
                m_temporarilyLinkedCells.push_back( make_tuple(cellId,masterId, tripleLink) );
                a_hasProperty( cellId ,  SolverCell::IsTempLinked ) = true;
                for ( MInt v = 0; v < m_noVars; v++ ) {
                  a_variable( cellId ,  v ) = a_variable( masterId ,  v );
                  a_oldVariable( cellId ,  v ) = a_oldVariable( masterId ,  v );
                  a_pvariable( cellId ,  v ) =a_pvariable( masterId ,  v );
                }

              } else {
                //tipleCellId doesn't have a link yet
                maxVol = F0;
                for ( MInt dir = 0; dir < m_noDirs; dir++ ) {
                  if ( !checkNeighborActive (tripleLink , dir) ||
                      a_hasNeighbor(tripleLink, dir) == 0 ) continue;
                  MInt nghbrId = c_neighborId( tripleLink ,  dir );
                  if ( nghbrId < 0 ) continue;
                  if ( a_hasProperty( nghbrId , SolverCell::WasInactive ) ) continue;
                  if ( a_hasProperty( nghbrId ,  SolverCell::IsSplitCell ) ) continue;
                  if ( a_hasProperty( nghbrId ,  SolverCell::IsSplitChild ) ) continue;
                    if ( a_cellVolume( nghbrId ) > maxVol ) {
                      masterId = nghbrId;
                      maxVol = a_cellVolume( nghbrId );
                    }
                  }
                  if(masterId > 0) {
                    cerr << " Using masterId " << c_globalId(masterId) << endl;
                    if( a_isHalo( cellId ) && a_isHalo(masterId) && a_isHalo(tripleLink)) continue;
                    m_temporarilyLinkedCells.push_back( make_tuple(cellId,masterId, tripleLink) );
                    a_hasProperty( cellId ,  SolverCell::IsTempLinked ) = true;
                    a_hasProperty(tripleLink,  SolverCell::IsTempLinked ) = true;
                    for ( MInt v = 0; v < m_noVars; v++ ) {
                      a_variable( cellId ,  v ) = a_variable( masterId ,  v );
                      a_oldVariable( cellId ,  v ) = a_oldVariable( masterId ,  v );
                      a_pvariable( cellId ,  v ) =a_pvariable( masterId ,  v );

                      a_variable(tripleLink,  v ) = a_variable( masterId ,  v );
                      a_oldVariable(tripleLink,  v ) = a_oldVariable( masterId ,  v );
                      a_pvariable(tripleLink,  v ) =a_pvariable( masterId ,  v );
                    }
                  }
                }
              }


            }
        }



      }
      */
      if(masterId < 0) {
        cerr << domainId() << " Still no temporary master found for emerged cell " << cellId << " "
             << c_globalId(cellId) << " " << a_isHalo(cellId) << " " << a_isWindow(cellId) << " "
             << a_hasProperty(cellId, SolverCell::IsNotGradient) << " " << noInternalNghbrs << " " << noWasActiveNghbrs
             << " " << a_hasProperty(cellId, SolverCell::IsSplitChild) << " " << a_levelSetValuesMb(cellId, 0) << " "
             << a_hasProperty(cellId, SolverCell::IsGapCell) << " " << a_hasProperty(cellId, SolverCell::WasGapCell)
             << " "
             << m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_volume / grid().gridCellVolume(a_level(cellId))
             << " " << a_hasProperty(cellId, SolverCell::IsInactive) << endl;
        if(m_closeGaps && m_gapCellId[cellId] > 0)
          cerr << m_gapCellId[cellId] << " " << m_gapCells[m_gapCellId[cellId]].status << endl;
      }
    }

    // the second-halo-layer is not linked!
    if(masterId < 0) {
      ASSERT(a_isHalo(cellId), "");
      ASSERT(a_hasProperty(cellId, SolverCell::IsNotGradient), "");
    }

    // Do not use azimuthal halo cell as master because azimuthal halos are skipped
    // further above.
    if(grid().azimuthalPeriodicity() && a_isPeriodic(masterId)) {
      if(tripleLink >= 0) {
        mTerm(1, AT_, "Triple link with azimuthalPeriodicity");
      }
      continue;
    }


    // create linkedHalo- and -Window-Cells list
    // a) for single-links
    if(tripleLink < 0 && masterId > -1 && a_isHalo(cellId) != a_isHalo(masterId)) {
      if(c_globalId(cellId) < 0 || c_globalId(masterId) < 0) {
        cerr << domainId() << ": GID " << cellId << " " << masterId << " " << c_globalId(cellId) << " "
             << c_globalId(masterId) << " " << a_isPeriodic(cellId) << " " << a_isPeriodic(masterId) << endl;
      }
      ASSERT(c_globalId(cellId) > -1 && c_globalId(masterId) > -1, "");
      if(a_isHalo(cellId)) {
        ASSERT(a_isWindow(masterId), "");
        MInt ndom = grid().findNeighborDomainId(c_globalId(cellId));
        MInt idx = grid().domainIndex(ndom);
        ASSERT(neighborDomain(idx) == ndom, "");
        m_linkedHaloCells[idx].push_back(cellId);
        m_linkedWindowCells[idx].push_back(masterId);
      } else {
        // masterId is Halo-Cell
        ASSERT(a_isHalo(masterId), "");
        ASSERT(a_isWindow(cellId), "");
        MInt ndom = grid().findNeighborDomainId(c_globalId(masterId));
        MInt idx = grid().domainIndex(ndom);
        ASSERT(neighborDomain(idx) == ndom, "");
        m_linkedHaloCells[idx].push_back(masterId);
        m_linkedWindowCells[idx].push_back(cellId);
      }

    } // b) for triple-links
    else if(tripleLink > -1 && masterId > -1
            && (a_isHalo(cellId) != a_isHalo(tripleLink) || a_isHalo(tripleLink) != a_isHalo(masterId))) {
      // if one of the linked Cells is a halo-Cell and the others are not!
      // if they are all halo-Cells, the link is handeled on the other rank!

      ASSERT(c_globalId(cellId) > -1 && c_globalId(masterId) > -1 && c_globalId(tripleLink), "");
      // split triple-problmen in multiple single-link problems:
      // single link between: - tripleLink and masterId
      //                      - tripleLink and cellId

      MInt ndom11 = grid().findNeighborDomainId(c_globalId(tripleLink));
      MInt ndom22 = grid().findNeighborDomainId(c_globalId(cellId));
      MInt ndom33 = grid().findNeighborDomainId(c_globalId(masterId));

      cerr << domainId() << "Parallel Triple-Link Halo-Cells: " << c_globalId(cellId) << " " << c_globalId(tripleLink)
           << " " << c_globalId(masterId) << " " << a_isHalo(cellId) << " " << a_isHalo(tripleLink) << " "
           << a_isHalo(masterId) << " Domains " << ndom22 << " " << ndom11 << " " << ndom33 << endl;


      if(a_isHalo(tripleLink) && !a_isHalo(masterId)) {
        ASSERT(a_isWindow(masterId), "");
        MInt ndom = grid().findNeighborDomainId(c_globalId(tripleLink));
        MInt idx = grid().domainIndex(ndom);
        ASSERT(neighborDomain(idx) == ndom, "");
        m_linkedHaloCells[idx].push_back(tripleLink);
        m_linkedWindowCells[idx].push_back(masterId);

      } else if(a_isHalo(masterId) && !a_isHalo(tripleLink)) {
        ASSERT(a_isWindow(tripleLink), "");
        MInt ndom = grid().findNeighborDomainId(c_globalId(masterId));
        MInt idx = grid().domainIndex(ndom);
        ASSERT(neighborDomain(idx) == ndom, "");
        m_linkedHaloCells[idx].push_back(masterId);
        m_linkedWindowCells[idx].push_back(tripleLink);
      }

      if(a_isHalo(tripleLink) && !a_isHalo(cellId)) {
        ASSERT(a_isWindow(cellId), "");
        MInt ndom = grid().findNeighborDomainId(c_globalId(tripleLink));
        MInt idx = grid().domainIndex(ndom);
        ASSERT(neighborDomain(idx) == ndom, "");
        m_linkedHaloCells[idx].push_back(tripleLink);
        m_linkedWindowCells[idx].push_back(cellId);

      } else if(!a_isHalo(tripleLink) && a_isHalo(cellId)) {
        ASSERT(a_isWindow(tripleLink), "");
        MInt ndom = grid().findNeighborDomainId(c_globalId(cellId));
        MInt idx = grid().domainIndex(ndom);
        ASSERT(neighborDomain(idx) == ndom, "");
        m_linkedHaloCells[idx].push_back(cellId);
        m_linkedWindowCells[idx].push_back(tripleLink);
      }

      if(a_isHalo(masterId) && !a_isHalo(cellId)) {
      } else if(!a_isHalo(masterId) && a_isHalo(cellId)) {
      }
    }
  }

  // sort by globalId to synchronize order across domains
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    sort(m_linkedHaloCells[i].begin(), m_linkedHaloCells[i].end(),
         [this](const MInt& a, const MInt& b) { return c_globalId(a) < c_globalId(b); });
    sort(m_linkedWindowCells[i].begin(), m_linkedWindowCells[i].end(),
         [this](const MInt& a, const MInt& b) { return c_globalId(a) < c_globalId(b); });
  }
}


/**
 * \brief ckecks that a new bndry-Cell has at least one neighbor which was active before
 *        if this is not the case, the largest neighbor of the cell is initialised and set
 *        to wasactive
 *
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
MInt FvMbCartesianSolverXD<nDim, SysEqn>::checkNeighborActivity(MInt cellId) {
  TRACE();

  ASSERT(cellId >= 0, "");

  if(!a_hasProperty(cellId, SolverCell::WasInactive)) return -1;
  if(a_hasProperty(cellId, SolverCell::IsInactive)) return -2;

  MInt masterId = -1;
  MInt largestNeighbor = -1;
  MFloat maxVol = F0;
  MFloat maxVolActive = F0;
  MInt noInternalNghbrs = 0;
  for(MInt dir = 0; dir < m_noDirs; dir++) {
    if(!checkNeighborActive(cellId, dir) || a_hasNeighbor(cellId, dir) == 0) continue;
    const MInt nghbrId = c_neighborId(cellId, dir);
    if(nghbrId < 0) continue;
    if(a_hasProperty(nghbrId, SolverCell::IsSplitCell)) continue;
    if(a_hasProperty(nghbrId, SolverCell::IsSplitChild)) continue;
    if(a_cellVolume(nghbrId) > maxVolActive && !a_hasProperty(nghbrId, SolverCell::WasInactive)) {
      masterId = nghbrId;
      maxVolActive = a_cellVolume(nghbrId);
    }
    if(a_cellVolume(nghbrId) > maxVol) {
      largestNeighbor = nghbrId;
      maxVol = a_cellVolume(nghbrId);
    }
  }

  if(masterId > -1) return -1;
  if(a_isHalo(cellId) && noInternalNghbrs == 0) return -1;

  ASSERT(a_hasProperty(largestNeighbor, SolverCell::WasInactive), "");
  ASSERT(largestNeighbor > 0, "");

  // reverse the further search!
  if(a_cellVolume(largestNeighbor) < a_cellVolume(cellId)) {
    MInt backup = cellId;
    cellId = largestNeighbor;
    largestNeighbor = backup;
  }

  /*
  cerr << "New small gap-bndry cell is " << c_globalId(cellId)
       << " with volume "
       << m_fvBndryCnd->m_bndryCells->a[ a_bndryId( cellId ) ].m_volume /grid().gridCellVolume(a_level(cellId)) << "
  "
       << a_isHalo(cellId) << " "
       << a_hasProperty( cellId, Cell::IsWindow )
       << " largestNeighbor is " << c_globalId(largestNeighbor)
       << " with volume " << m_fvBndryCnd->m_bndryCells->a[ a_bndryId( largestNeighbor )
  ].m_volume/grid().gridCellVolume(a_level(largestNeighbor)) << " "
       << a_isHalo(largestNeighbor) << " "
       << a_hasProperty( largestNeighbor, Cell::IsWindow ) << " "
       << domainId()
       << endl;
  */

  ASSERT(a_wasGapCell(largestNeighbor) || a_isGapCell(largestNeighbor), "");


  // initialise the largest-Neighbor for partial-gap-opening!
  const MInt region = m_gapCells[m_gapCellId[cellId]].region;
  ASSERT(region > -1 && region < m_noGapRegions, "");
  if(m_gapState[region] != 2) {
    // find a neighbor of the largestneighbor which was active before and initialise
    // the largetsNeighbor before the linking

    // find a sourringding cell of the largestNeighbor
    // which was active before and initialise the largestNeighbor with its values


    // if ( a_isHalo( cellId ) && a_isHalo(largestNeighbor) ) return -1;

    // return if the largestNeighbor is on the secondHalo-layer
    // and thus might not find a masterId as it might be on a different rank!
    if(a_isHalo(largestNeighbor) && a_hasProperty(largestNeighbor, SolverCell::IsNotGradient)) {
      return -1;
    }

    maxVol = F0;
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      if(!checkNeighborActive(largestNeighbor, dir) || a_hasNeighbor(largestNeighbor, dir) == 0) continue;
      MInt nghbrId = c_neighborId(largestNeighbor, dir);
      if(nghbrId < 0) continue;
      if(a_hasProperty(nghbrId, SolverCell::WasInactive)) continue;
      if(a_cellVolume(nghbrId) > maxVol) {
        masterId = nghbrId;
        maxVol = a_cellVolume(nghbrId);
      }
    }

    if(masterId > -1) {
      for(MInt v = 0; v < m_noCVars; v++) {
        a_variable(largestNeighbor, v) = a_variable(masterId, v);
        a_oldVariable(largestNeighbor, v) = a_oldVariable(masterId, v);
      }
      for(MInt v = 0; v < m_noPVars; v++) {
        a_pvariable(largestNeighbor, v) = a_pvariable(masterId, v);
      }
      for(MInt v = 0; v < m_noFVars; v++) {
        a_rightHandSide(largestNeighbor, v) = F0;
        m_rhs0[largestNeighbor][v] = F0;
      }
    } else {
      // the largest neighbor does not have an neighbor who was active before and
      // can thus not be initialised!
      //=> new search for a different neighbor!
      // a) initialise neighbor with infinity variables
      // b) retry neighbor search from cellId to find any neighboring cell which
      //   has an active neighbor!
      cerr << a_isHalo(largestNeighbor) << " " << a_isHalo(cellId) << endl;
      mTerm(1, AT_, "Even the largest neighbor is inactive!");
    }
  }


  if(a_isHalo(largestNeighbor)) {
    cerr << "Caution changing cell-property of a Halo-Cell! " << endl;
    // mark this cell and change the window-Cell accordingly!
  }

  a_hasProperty(largestNeighbor, SolverCell::WasInactive) = false;
  m_oldBndryCells.insert(make_pair(largestNeighbor, F0));


  return largestNeighbor;
}


/**
 * \brief creates the gap-cell exchange communicators
 *        based on initializeMaxLevelExchange
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::initGapCellExchange() {
  TRACE();

#if defined _MB_DEBUG_ || !defined NDEBUG
  exchangeGapInfo();
  checkHaloCells(2);
#endif

  if(m_gapCellExchangeInit) return;
  m_gapCellExchangeInit = true;

  if(noNeighborDomains() == 0) return;

  for(MInt i = 0; i < noNeighborDomains(); i++) {
    m_gapWindowCells[i].clear();
    m_gapHaloCells[i].clear();
  }

  ScratchSpace<MInt> isGap(a_noCells(), AT_, "isGap");
  isGap.fill(0);

  // 1) setup Gap-exchange:
  // for all Gap-Cells which are/were gapCells

  // a) set noExchangeWindowCells and exchangeWindowCells
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    ASSERT(m_gapHaloCells[i].size() == 0, "");
    for(MInt j = 0; j < noHaloCells(i); j++) {
      MInt cellId = haloCellId(i, j);
      if(a_wasGapCell(cellId) || a_isGapCell(cellId)) {
        m_gapHaloCells[i].push_back(cellId);
        isGap(cellId) = 1;
      }
    }
  }

  MUint recvSize = maia::mpi::getBufferSize(grid().windowCells());
  ScratchSpace<MInt> recvBuffer(mMax(1u, recvSize), AT_, "recvBuffer");
  maia::mpi::reverseExchangeData(grid().neighborDomains(), grid().haloCells(), grid().windowCells(), mpiComm(),
                                 &isGap[0], &recvBuffer[0]);


  recvSize = 0;
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    ASSERT(m_gapWindowCells[i].size() == 0, "");
    for(MInt j = 0; j < noWindowCells(i); j++) {
      MInt cellId = windowCellId(i, j);
      if(recvBuffer[recvSize]) {
        ASSERT(a_isGapCell(cellId) || a_wasGapCell(cellId), "");
        m_gapWindowCells[i].push_back(cellId);
      }
      recvSize++;
    }
  }

// verify exchange:
#if defined _MB_DEBUG_ || !defined NDEBUG

  MPI_Status statusMpi;
  ScratchSpace<MInt> check(a_noCells(), AT_, "isOnMaxLevel");
  check.fill(0);

  for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
    check[cellId] = 1;
    if(a_isGapCell(cellId)) check[cellId] = 2;
    if(a_wasGapCell(cellId)) check[cellId] = 3;
    if(a_isGapCell(cellId) && a_wasGapCell(cellId)) check[cellId] = 4;
  }

  // gather
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    if(m_gapWindowCells[i].empty()) continue;
    MInt sendBufferCounter = 0;
    for(MInt j = 0; j < (signed)m_gapWindowCells[i].size(); j++) {
      MInt cellId = m_gapWindowCells[i][j];
      m_sendBuffers[i][sendBufferCounter] = (MFloat)check[cellId];
      sendBufferCounter++;
    }
  }


  // send
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    if(m_gapWindowCells[i].empty()) continue;
    MInt bufSize = m_gapWindowCells[i].size();
    MPI_Issend(m_sendBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &g_mpiRequestMb[i], AT_,
               "m_sendBuffers[i]");
  }

  // receive
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    if(m_gapHaloCells[i].empty()) continue;
    MInt bufSize = m_gapHaloCells[i].size();
    MPI_Recv(m_receiveBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &statusMpi, AT_,
             "m_receiveBuffers[i]");
  }
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    MPI_Wait(&g_mpiRequestMb[i], &statusMpi, AT_);
  }

  // scatter
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    if(m_gapHaloCells[i].empty()) continue;
    MInt receiveBufferCounter = 0;
    for(MInt j = 0; j < (signed)m_gapHaloCells[i].size(); j++) {
      MInt cellId = m_gapHaloCells[i][j];
      check[cellId] = (MInt)m_receiveBuffers[i][receiveBufferCounter];
      receiveBufferCounter++;
    }
  }

  for(MInt cellId = noInternalCells(); cellId < a_noCells(); cellId++) {
    if(a_hasProperty(cellId, SolverCell::IsSplitChild)) continue;
    if(a_isGapCell(cellId) && !a_wasGapCell(cellId))
      ASSERT(check[cellId] == 2, "");
    else if(a_wasGapCell(cellId) && !a_isGapCell(cellId))
      ASSERT(check[cellId] == 3, "");
    else if(a_isGapCell(cellId) && a_wasGapCell(cellId))
      ASSERT(check[cellId] == 4, "");
    else
      ASSERT(check[cellId] == 0, "");
  }


#endif
}


/**
 * \brief exchanges variables and wasInactive for gapCells
 * \author Tim Wegmann
 *
 * mode = 0 : only exchanges pvariables
 * else     : exchanges pvariables, oldVariable, wasInactive, status
 *          : and setConservativeVariables!
 *
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::gapCellExchange(MInt mode) {
  TRACE();

  ASSERT(m_gapCellExchangeInit, "");
  if(noNeighborDomains() == 0) return;

  MPI_Status statusMpi;

  if(mode == 0) { // exchange of pvariables only

    // gather
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_gapWindowCells[i].empty()) continue;
      MInt sendBufferCounter = 0;
      for(MInt j = 0; j < (signed)m_gapWindowCells[i].size(); j++) {
        MInt cellId = m_gapWindowCells[i][j];
        memcpy((void*)&m_sendBuffers[i][sendBufferCounter], (void*)&a_pvariable(cellId, 0),
               m_dataBlockSize * sizeof(MFloat));
        sendBufferCounter += m_dataBlockSize;
      }
    }

    // send
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_gapWindowCells[i].empty()) continue;
      MInt bufSize = m_gapWindowCells[i].size() * m_dataBlockSize;
      MPI_Issend(m_sendBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &g_mpiRequestMb[i], AT_,
                 "m_sendBuffers[i]");
    }

    // receive
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_gapHaloCells[i].empty()) continue;
      MInt bufSize = m_gapHaloCells[i].size() * m_dataBlockSize;
      MPI_Recv(m_receiveBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &statusMpi, AT_,
               "m_receiveBuffers[i]");
    }
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      MPI_Wait(&g_mpiRequestMb[i], &statusMpi, AT_);
    }

    // scatter
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_gapHaloCells[i].empty()) continue;
      MInt receiveBufferCounter = 0;
      for(MInt j = 0; j < (signed)m_gapHaloCells[i].size(); j++) {
        MInt cellId = m_gapHaloCells[i][j];
        memcpy((void*)&a_pvariable(cellId, 0), (void*)&m_receiveBuffers[i][receiveBufferCounter],
               m_dataBlockSize * sizeof(MFloat));
        receiveBufferCounter += m_dataBlockSize;
      }
    }

  } else { // exchange wasInactive, call gapCellExchange(0), oldVariables and status

    // exchange wasInactive
    {
      MInt reverseExchange = 0;

      /////////exchange of wasInactive
      // NOTE: if the halo-Cell has status -99
      //       (meaning that the halo-Cell is the only active neighbor for a gapCell on a rank)
      //       then a reverse exchange is triggered
      //       and the according-window-Cell is updated based on the haloCell state!

      // gather
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(m_gapWindowCells[i].empty()) continue;
        MInt sendBufferCounter = 0;
        for(MInt j = 0; j < (signed)m_gapWindowCells[i].size(); j++) {
          MInt cellId = m_gapWindowCells[i][j];
          m_sendBuffers[i][sendBufferCounter] = -F1;
          if(a_hasProperty(cellId, SolverCell::WasInactive)) {
            m_sendBuffers[i][sendBufferCounter] = F1;
          }
          sendBufferCounter++;
        }
      }


      // send
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(m_gapWindowCells[i].empty()) continue;
        MInt bufSize = m_gapWindowCells[i].size();
        MPI_Issend(m_sendBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &g_mpiRequestMb[i], AT_,
                   "m_sendBuffers[i]");
      }

      // receive
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(m_gapHaloCells[i].empty()) continue;
        MInt bufSize = m_gapHaloCells[i].size();
        MPI_Recv(m_receiveBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &statusMpi, AT_,
                 "m_receiveBuffers[i]");
      }
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        MPI_Wait(&g_mpiRequestMb[i], &statusMpi, AT_);
      }

      // scatter
      for(MInt i = 0; i < noNeighborDomains(); i++) {
        if(m_gapHaloCells[i].empty()) continue;
        MInt receiveBufferCounter = 0;
        for(MInt j = 0; j < (signed)m_gapHaloCells[i].size(); j++) {
          const MInt cellId = m_gapHaloCells[i][j];
          const MInt status = m_gapCells[m_gapCellId[cellId]].status;
          if(status == -99) {
            reverseExchange = 1;
            receiveBufferCounter++;
            continue;
          }
          if(m_receiveBuffers[i][receiveBufferCounter] > 0) {
            a_hasProperty(cellId, SolverCell::WasInactive) = true;
          } else {
            a_hasProperty(cellId, SolverCell::WasInactive) = false;
          }
          receiveBufferCounter++;
        }
      }

      MPI_Allreduce(MPI_IN_PLACE, &reverseExchange, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                    "reverseExchange");

      if(reverseExchange > 0) {
        // reverse exchange on grid window+halo-cells

        vector<MInt> updatedWindowCells;

        // gather
        for(MInt i = 0; i < noNeighborDomains(); i++) {
          if(m_gapHaloCells[i].empty()) continue;
          MInt sendBufferCounter = 0;
          for(MInt j = 0; j < (signed)m_gapHaloCells[i].size(); j++) {
            MInt cellId = m_gapHaloCells[i][j];
            m_sendBuffers[i][sendBufferCounter] = -1.0;
            if(m_gapCells[m_gapCellId[cellId]].status == -99) {
              ASSERT(a_hasProperty(cellId, SolverCell::WasInactive) == false, "");
              m_sendBuffers[i][sendBufferCounter] = 2.0;
            }
            sendBufferCounter++;
          }
        }

        // send
        for(MInt i = 0; i < noNeighborDomains(); i++) {
          if(m_gapHaloCells[i].empty()) continue;
          MInt bufSize = m_gapHaloCells[i].size();
          MPI_Issend(m_sendBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &g_mpiRequestMb[i], AT_,
                     "m_sendBuffers[i]");
        }

        // receive
        for(MInt i = 0; i < noNeighborDomains(); i++) {
          if(m_gapWindowCells[i].empty()) continue;
          MInt bufSize = m_gapWindowCells[i].size();
          MPI_Recv(m_receiveBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &statusMpi, AT_,
                   "m_receiveBuffers[i]");
        }
        for(MInt i = 0; i < noNeighborDomains(); i++) {
          MPI_Wait(&g_mpiRequestMb[i], &statusMpi, AT_);
        }

        // scatter
        for(MInt i = 0; i < noNeighborDomains(); i++) {
          if(m_gapWindowCells[i].empty()) continue;
          MInt receiveBufferCounter = 0;
          for(MInt j = 0; j < (signed)m_gapWindowCells[i].size(); j++) {
            MInt cellId = m_gapWindowCells[i][j];
            if(m_receiveBuffers[i][receiveBufferCounter] > 1) {
              updatedWindowCells.push_back(cellId);
            }
            receiveBufferCounter++;
          }
        }

        // update cell-variables in the window-Cell:
        for(MUint i = 0; i < updatedWindowCells.size(); i++) {
          MInt cellId = updatedWindowCells[i];
          cerr << "Updating Window-Cell " << c_globalId(cellId) << endl;
          MInt masterId = -1;
          MFloat maxVol = F0;
          const MInt rootId = cellId;
          for(MInt dir = 0; dir < m_noDirs; dir++) {
            if(!checkNeighborActive(rootId, dir) || a_hasNeighbor(rootId, dir) == 0) continue;
            const MInt nghbrId = c_neighborId(rootId, dir);
            if(nghbrId < 0) continue;
            if(a_hasProperty(nghbrId, SolverCell::WasInactive)) continue;
            if(a_hasProperty(nghbrId, SolverCell::IsSplitCell)) continue;
            if(a_hasProperty(nghbrId, SolverCell::IsSplitChild)) continue;
            if(a_cellVolume(nghbrId) > maxVol) {
              masterId = nghbrId;
              maxVol = a_cellVolume(nghbrId);
            }
          }
          if(masterId > -1) {
            // update variables only if the cell has a valid master!
            // for narror gaps it is possible, that cellId does not have
            // a fully emerging neighbor!
            for(MInt v = 0; v < m_noCVars; v++) {
              a_variable(cellId, v) = a_variable(masterId, v);
              a_oldVariable(cellId, v) = a_oldVariable(masterId, v);
            }
            for(MInt v = 0; v < m_noPVars; v++) {
              a_pvariable(cellId, v) = a_pvariable(masterId, v);
            }
          }
          for(MInt v = 0; v < m_noFVars; v++) {
            a_rightHandSide(cellId, v) = F0;
            m_rhs0[cellId][v] = F0;
          }
          a_hasProperty(cellId, SolverCell::WasInactive) = false;
          MInt gapCellId = m_gapCellId[cellId];
          MInt region = m_gapCells[gapCellId].region;
          ASSERT(region > -1 && region < m_noGapRegions, " ");
          if(m_gapState[region] == 3) {
            m_gapCells[gapCellId].status = 17;
          } else {
            m_gapCells[gapCellId].status = 28;
          }
        }

        // re-reverse exchange
        // now, that a window-Cell has been updated,
        // halo-Cells on other ranks need to be updated as well!

        // gather
        for(MInt i = 0; i < noNeighborDomains(); i++) {
          if(m_gapWindowCells[i].empty()) continue;
          MInt sendBufferCounter = 0;
          for(MInt j = 0; j < (signed)m_gapWindowCells[i].size(); j++) {
            MInt cellId = m_gapWindowCells[i][j];
            m_sendBuffers[i][sendBufferCounter] = -F1;
            if(a_hasProperty(cellId, SolverCell::WasInactive)) {
              m_sendBuffers[i][sendBufferCounter] = F1;
            }
            sendBufferCounter++;
          }
        }


        // send
        for(MInt i = 0; i < noNeighborDomains(); i++) {
          if(m_gapWindowCells[i].empty()) continue;
          MInt bufSize = m_gapWindowCells[i].size();
          MPI_Issend(m_sendBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &g_mpiRequestMb[i], AT_,
                     "m_sendBuffers[i]");
        }

        // receive
        for(MInt i = 0; i < noNeighborDomains(); i++) {
          if(m_gapHaloCells[i].empty()) continue;
          MInt bufSize = m_gapHaloCells[i].size();
          MPI_Recv(m_receiveBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &statusMpi, AT_,
                   "m_receiveBuffers[i]");
        }
        for(MInt i = 0; i < noNeighborDomains(); i++) {
          MPI_Wait(&g_mpiRequestMb[i], &statusMpi, AT_);
        }

        // scatter
        for(MInt i = 0; i < noNeighborDomains(); i++) {
          if(m_gapHaloCells[i].empty()) continue;
          MInt receiveBufferCounter = 0;
          for(MInt j = 0; j < (signed)m_gapHaloCells[i].size(); j++) {
            MInt cellId = m_gapHaloCells[i][j];
            if(m_receiveBuffers[i][receiveBufferCounter] > 0) {
              a_hasProperty(cellId, SolverCell::WasInactive) = true;
            } else {
              a_hasProperty(cellId, SolverCell::WasInactive) = false;
            }
            receiveBufferCounter++;
          }
        }
      }

    } // exchange of wasInactive

    // exchange of pVariables
    gapCellExchange(0);

    // exchange of oldVariables

    // gather
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_gapWindowCells[i].empty()) continue;
      MInt sendBufferCounter = 0;
      for(MInt j = 0; j < (signed)m_gapWindowCells[i].size(); j++) {
        MInt cellId = m_gapWindowCells[i][j];
        memcpy((void*)&m_sendBuffers[i][sendBufferCounter], (void*)&a_oldVariable(cellId, 0),
               m_dataBlockSize * sizeof(MFloat));
        sendBufferCounter += m_dataBlockSize;
      }
    }

    // send
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_gapWindowCells[i].empty()) continue;
      MInt bufSize = m_gapWindowCells[i].size() * m_dataBlockSize;
      MPI_Issend(m_sendBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &g_mpiRequestMb[i], AT_,
                 "m_sendBuffers[i]");
    }

    // receive
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_gapHaloCells[i].empty()) continue;
      MInt bufSize = m_gapHaloCells[i].size() * m_dataBlockSize;
      MPI_Recv(m_receiveBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &statusMpi, AT_,
               "m_receiveBuffers[i]");
    }
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      MPI_Wait(&g_mpiRequestMb[i], &statusMpi, AT_);
    }

    // scatter
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_gapHaloCells[i].empty()) continue;
      MInt receiveBufferCounter = 0;
      for(MInt j = 0; j < (signed)m_gapHaloCells[i].size(); j++) {
        MInt cellId = m_gapHaloCells[i][j];
        memcpy((void*)&a_oldVariable(cellId, 0), (void*)&m_receiveBuffers[i][receiveBufferCounter],
               m_dataBlockSize * sizeof(MFloat));
        receiveBufferCounter += m_dataBlockSize;
      }
    }

    // exchange gap-status:

    // gather
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_gapWindowCells[i].empty()) continue;
      MInt sendBufferCounter = 0;
      for(MInt j = 0; j < (signed)m_gapWindowCells[i].size(); j++) {
        MInt cellId = m_gapWindowCells[i][j];
        MInt gapCellId = m_gapCellId[cellId];
        m_sendBuffers[i][sendBufferCounter] = (MFloat)m_gapCells[gapCellId].status;
        sendBufferCounter++;
      }
    }


    // send
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_gapWindowCells[i].empty()) continue;
      MInt bufSize = m_gapWindowCells[i].size();
      MPI_Issend(m_sendBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &g_mpiRequestMb[i], AT_,
                 "m_sendBuffers[i]");
    }

    // receive
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_gapHaloCells[i].empty()) continue;
      MInt bufSize = m_gapHaloCells[i].size();
      MPI_Recv(m_receiveBuffers[i], bufSize, MPI_DOUBLE, neighborDomain(i), 0, mpiComm(), &statusMpi, AT_,
               "m_receiveBuffers[i]");
    }
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      MPI_Wait(&g_mpiRequestMb[i], &statusMpi, AT_);
    }

    // scatter
    for(MInt i = 0; i < noNeighborDomains(); i++) {
      if(m_gapHaloCells[i].empty()) continue;
      MInt receiveBufferCounter = 0;
      for(MInt j = 0; j < (signed)m_gapHaloCells[i].size(); j++) {
        MInt cellId = m_gapHaloCells[i][j];
        MInt gapCellId = m_gapCellId[cellId];
        m_gapCells[gapCellId].status = (MInt)m_receiveBuffers[i][receiveBufferCounter];
        receiveBufferCounter++;
      }
    }
  }
}


/**
 * \brief Performs the solutionStep of the FVMB solver
 *        the loop over the different RK-steps is done in the execution-recipe
 * \author Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
MBool FvMbCartesianSolverXD<nDim, SysEqn>::solutionStep() {
  TRACE();

  NEW_TIMER_GROUP_STATIC(tg_solutionStep, "solution step");
  NEW_TIMER_STATIC(t_solutionStep, "time integration", tg_solutionStep);
  NEW_SUB_TIMER_STATIC(t_timeIntegration, "time integration", t_solutionStep);
  NEW_SUB_TIMER_STATIC(t_lhs, "lhs", t_timeIntegration);
  NEW_SUB_TIMER_STATIC(t_lhsBnd, "lhsBnd", t_timeIntegration);
  NEW_SUB_TIMER_STATIC(t_rhs, "rhs", t_timeIntegration);
  NEW_SUB_TIMER_STATIC(t_rhsBnd, "rhsBnd", t_timeIntegration);

  RECORD_TIMER_START(t_solutionStep);
  RECORD_TIMER_START(t_timeIntegration);

  // finish previous RK step for inter-leafed non-blocking
  if(g_splitMpiComm && m_splitMpiCommRecv) {
    RECORD_TIMER_START(t_lhsBnd);
    this->lhsBndFinish();
    RECORD_TIMER_STOP(t_lhsBnd);

    RECORD_TIMER_START(t_rhs);
    this->rhs();
    RECORD_TIMER_STOP(t_rhs);

    RECORD_TIMER_START(t_rhsBnd);
    this->rhsBnd();
    RECORD_TIMER_STOP(t_rhsBnd);
  }
  // Receive data in the next substep
  m_splitMpiCommRecv = true;

  /// LHS computation: Navier-Stokes integration step
  /// timeStep update is also done here
  RECORD_TIMER_START(t_lhs);
  MBool timeStepCompleted = this->solverStep();
  RECORD_TIMER_STOP(t_lhs);

  /// LHS Boundary Condition: set boundary conditions and exchange data
  RECORD_TIMER_START(t_lhsBnd);
  this->lhsBnd();
  RECORD_TIMER_STOP(t_lhsBnd);

  if(!g_splitMpiComm) {
    /// RHS computation:
    RECORD_TIMER_START(t_rhs);
    this->rhs();
    RECORD_TIMER_STOP(t_rhs);

    /// RHS Boundary Condition (boundary treatment):
    RECORD_TIMER_START(t_rhsBnd);
    this->rhsBnd();
    RECORD_TIMER_STOP(t_rhsBnd);
  }

  RECORD_TIMER_STOP(t_timeIntegration);
  RECORD_TIMER_STOP(t_solutionStep);

  return timeStepCompleted;
}


/**
 * \brief Performs the preTimeStep of the FVMB solver
 * \author Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::preTimeStep() {
  TRACE();

  RECORD_TIMER_START(m_timers[Timers::PreTime]);

  if(!grid().wasAdapted()) {
    // If the mesh was adaped,
    // these calls have already been made in prepareAdaptation
    advanceTimeStep();

    if(m_constructGField) {
      constructGFieldPredictor();
    } else if(!m_LsMovement) {
      updateBodyProperties();
    }
  }

  // stop timer here, they are re-started in preSolutionStep for iterative runs
  RECORD_TIMER_STOP(m_timers[Timers::PreTime]);
  if(grid().wasAdapted()) {
    if(!isMultilevel() || isMultilevelPrimary()) {
      preSolutionStep(0);
    }
  } else {
    preSolutionStep();
  }
  RECORD_TIMER_START(m_timers[Timers::PreTime]);

  if(m_localTS) {
    const MInt interval = !m_multilevel ? 500 : 100;
    if(globalTimeStep == (m_restartTimeStep + 1) || grid().wasAdapted() || globalTimeStep % interval == 0) {
      for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
        if(!m_fvBndryCnd->m_smallCellRHSCorrection) {
          // Q-SCC requires the same time-step in all neighboring small cells!
          a_localTimeStep(cellId) = timeStep() * IPOW2(maxLevel() - a_level(cellId));
        } else {
          a_localTimeStep(cellId) = computeTimeStepEulerDirectional(cellId);
        }
      }
    }
  }

  // TODO labels: FVMB This looks like something that should have been done in the postAdaptation/Balance functions...
  if(grid().wasAdapted() || grid().wasBalanced()) {
    initCutOffBoundaryCondition();
  }

  constexpr MBool dbg = false;
  if constexpr(dbg) {
    if(globalTimeStep == (m_restartTimeStep + 1)) {
      // count how many cells have a certain volume
      const MInt noVolSteps = 20;
      ScratchSpace<MInt> volumes(noVolSteps, AT_, "volumes");
      volumes.fill(0);
      const MFloat deltaVol = F1 / noVolSteps;

      // write cell-volume output
      for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
        if(a_isHalo(cellId)) continue;
        if(a_isBndryGhostCell(cellId)) continue;
        if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;
        if(!a_isBndryCell(cellId)) continue;

        const MFloat vFrac = a_cellVolume(cellId) / grid().gridCellVolume(a_level(cellId));
        const MInt pos = floor(vFrac / deltaVol);
        /* if(pos > noVolSteps - 1) continue; */
        volumes(pos)++;
      }

      // Add from different ranks
      MPI_Allreduce(MPI_IN_PLACE, &volumes(0), noVolSteps, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE", "volumes");

      // Write the file
      if(domainId() == 0) {
        FILE* datei;
        struct stat buffer;
        std::string name = "Volumes_" + to_string(solverId());
        const char* cstr = name.c_str();
        if(stat(cstr, &buffer) == 0) {
          rename(cstr, "Volumes_BAK");
        }
        datei = fopen(cstr, "w");
        fprintf(datei, "%s", "# 1:volLower 2:volUpper 3:count \n");
        for(MInt i = 0; i < noVolSteps; i++) {
          const MFloat volLimit1 = i * deltaVol;
          const MFloat volLimit2 = i * deltaVol + deltaVol;
          fprintf(datei, "%.8g", volLimit1);
          fprintf(datei, " %.8g", volLimit2);
          fprintf(datei, " %d", volumes(i));
          fprintf(datei, "\n");
        }
        fclose(datei);
      }
    }
  }

  m_splitMpiCommRecv = false;

  FvCartesianSolverXD<nDim, SysEqn>::preTimeStep();

  RECORD_TIMER_STOP(m_timers[Timers::PreTime]);
}


/**
 * \brief Performs the postTimeStep of the FVMB solver
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::postTimeStep() {
  TRACE();

  RECORD_TIMER_START(m_timers[Timers::PostTime]);

  // finish last RK-step for inter-leaved non-blocking
  if(g_splitMpiComm && m_splitMpiCommRecv) {
    this->lhsBndFinish();
    m_splitMpiCommRecv = false;

    this->rhs();

    this->rhsBnd();
  }


  // NOTE: meaning base or instrastep execution recipe!
  if(m_maxIterations == 1) {
    RECORD_TIMER_STOP(m_timers[Timers::PostTime]);
    postSolutionStep();
    RECORD_TIMER_START(m_timers[Timers::PostTime]);
  }

  m_forceAdaptation = adaptationTrigger();


  if(isMultilevelLowestSecondary()) {
    prepareNextTimeStep();
  }

  RECORD_TIMER_STOP(m_timers[Timers::PostTime]);
}


/**
 * \brief This function creats the bodyTree for analytical LevelSets.
 * \author Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::initAnalyticalLevelSet() {
  TRACE();

  ASSERT(m_constructGField, "Wrong function to call for m_constructGField = false!");

  m_complexBoundary = Context::getSolverProperty<MBool>("complexBoundaryForMb", m_solverId, AT_, &m_complexBoundary);

  m_buildCollectedLevelSetFunction = Context::getSolverProperty<MBool>("buildCollectedLevelSetFunction", m_solverId,
                                                                       AT_, &m_buildCollectedLevelSetFunction);

  // necessary Dat from the fvmb-solver:

  MInt noPeriodicDirs = 0;
  for(MInt dir = 0; dir < nDim; dir++) {
    if(grid().periodicCartesianDir(dir)) noPeriodicDirs++;
  }

  if(m_complexBoundary) {
    mAlloc(m_bodyToSetTable, m_noEmbeddedBodies, "m_bodyToSetTable", 0, AT_);
    mAlloc(m_noBodiesInSet, m_noLevelSetsUsedForMb, "m_noBodiesInSet", 0, AT_);
    mAlloc(m_setToBodiesTable, m_noLevelSetsUsedForMb, m_noEmbeddedBodies, "m_setToBodiesTable", 0, AT_);

    if(!m_buildCollectedLevelSetFunction) {
      m_noSets = 1;
      m_startSet = 0;
      for(MInt i = 0; i < m_noEmbeddedBodies; i++) {
        m_bodyToSetTable[i] = 0;
        m_setToBodiesTable[0][m_noBodiesInSet[0]] = i;
        m_noBodiesInSet[0]++;
      }
    } else if(m_buildCollectedLevelSetFunction) {
      m_startSet = 1;
      m_noSets = mMin(m_noLevelSetsUsedForMb, m_noEmbeddedBodies + m_startSet);
      if(m_noSets > m_noLevelSetsUsedForMb)
        mTerm(1, AT_, "Too many bodies for mode 1, m_noSets would be higher than m_noLevelSetsUsedForMb!");
      for(MInt i = 0; i < m_noEmbeddedBodies; i++) {
        MInt id = m_startSet + i % (m_noLevelSetsUsedForMb - 1);
        m_bodyToSetTable[i] = id;
        m_setToBodiesTable[id][m_noBodiesInSet[id]] = i;
        m_noBodiesInSet[id]++;
      }
      m_noBodiesInSet[0] = 0;
      for(MInt i = 0; i < m_noEmbeddedBodies; i++) {
        m_setToBodiesTable[0][m_noBodiesInSet[0]] = i;
        m_noBodiesInSet[0]++;
      }
    }

    if((m_maxNoEmbeddedBodiesPeriodic > m_noEmbeddedBodies) /*|| ( m_noBodiesInSet == nullptr )*/) {
      if(!m_buildCollectedLevelSetFunction) mTerm(1, AT_, "This case is unknown.");
      mDeallocate(m_bodyToSetTable);
      mDeallocate(m_noBodiesInSet);
      mDeallocate(m_setToBodiesTable);
      mAlloc(m_bodyToSetTable, m_maxNoEmbeddedBodiesPeriodic, "m_bodyToSetTable", 0, AT_);
      mAlloc(m_noBodiesInSet, m_noLevelSetsUsedForMb, "m_noBodiesInSet", 0, AT_);
      mAlloc(m_setToBodiesTable, m_noLevelSetsUsedForMb, m_maxNoEmbeddedBodiesPeriodic, "m_setToBodiesTable", 0, AT_);

      for(MInt i = 0; i < m_noLevelSetsUsedForMb; i++) {
        for(MInt j = 0; j < m_maxNoEmbeddedBodiesPeriodic; j++)
          m_setToBodiesTable[i][j] = 0;
        m_noBodiesInSet[i] = 0;
      }
      m_noBodiesInSet[0] = 0;
      for(MInt i = 0; i < m_noEmbeddedBodies; i++) {
        m_setToBodiesTable[0][m_noBodiesInSet[0]] = i;
        m_bodyToSetTable[i] = 0;
        m_noBodiesInSet[0]++;
      }
      m_startSet = 1;
      m_noSets = mMin(m_noLevelSetsUsedForMb, m_noEmbeddedBodies + m_startSet);
      if(m_noSets > m_noLevelSetsUsedForMb)
        mTerm(1, AT_, "Too many bodies for mode 0, m_noSets would be higher than m_noLevelSetsUsedForMb!");
      for(MInt i = 0; i < m_noLevelSetsUsedForMb; i++) {
        for(MInt j = 0; j < m_maxNoEmbeddedBodiesPeriodic; j++)
          m_setToBodiesTable[i][j] = 0;
        m_noBodiesInSet[i] = 0;
      }
      for(MInt i = 0; i < m_noEmbeddedBodies; i++) {
        MInt id = m_startSet + i % (m_noLevelSetsUsedForMb - 1);
        m_bodyToSetTable[i] = id;
        m_setToBodiesTable[id][m_noBodiesInSet[id]] = i;
        m_noBodiesInSet[id]++;
      }
      m_noBodiesInSet[0] = 0;
      for(MInt i = 0; i < m_noEmbeddedBodies; i++) {
        m_setToBodiesTable[0][m_noBodiesInSet[0]] = i;
        m_noBodiesInSet[0]++;
      }
    }
  } else {
    if(m_bodyToSetTable == nullptr) mAlloc(m_bodyToSetTable, m_maxNoEmbeddedBodiesPeriodic, "m_bodyToSetTable", 0, AT_);
    if(m_noBodiesInSet == nullptr) mAlloc(m_noBodiesInSet, m_noLevelSetsUsedForMb, "m_noBodiesInSet", 0, AT_);
    if(m_setToBodiesTable == nullptr)
      mAlloc(m_setToBodiesTable, m_noLevelSetsUsedForMb, m_maxNoEmbeddedBodiesPeriodic, "m_noBodiesInSet", 0, AT_);
    m_noSets = 1;
    m_startSet = 0;
    for(MInt i = 0; i < m_noLevelSetsUsedForMb; i++) {
      for(MInt j = 0; j < m_maxNoEmbeddedBodiesPeriodic; j++)
        m_setToBodiesTable[i][j] = 0;
      m_noBodiesInSet[i] = 0;
    }
    m_noBodiesInSet[0] = 0;
    for(MInt i = 0; i < m_noEmbeddedBodies; i++) {
      m_setToBodiesTable[0][m_noBodiesInSet[0]] = i;
      m_bodyToSetTable[i] = 0;
      m_noBodiesInSet[0]++;
    }
  }

  if(m_noSets > 0 && domainId() == 0) {
    m_log << " m_noSets: " << m_noSets << endl;
    m_log << " start set: " << m_startSet << endl;
    m_log << " m_bodyToSetTable: ";
    for(MInt i = 0; i < mMin(m_noEmbeddedBodies, 10); i++)
      m_log << " " << m_bodyToSetTable[i];
    m_log << endl;
    m_log << " m_noBodiesInSet: ";
    for(MInt i = 0; i < m_noLevelSetsUsedForMb; i++)
      m_log << " " << m_noBodiesInSet[i];
    m_log << endl;
    m_log << " m_setToBodiesTable: ";
    for(MInt i = 0; i < m_noLevelSetsUsedForMb; i++) {
      m_log << " s" << i << ": ";
      for(MInt j = 0; j < m_noBodiesInSet[i]; j++)
        m_log << " " << m_setToBodiesTable[i][j];
    }
    m_log << endl;
  }
}


/** \brief Updates the member-variables in the geometry-intersection class
 *  \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::updateGeometry() {
  TRACE();

  m_geometryIntersection->m_noEmbeddedBodies = m_noEmbeddedBodies;
  m_geometryIntersection->m_noLevelSetsUsedForMb = m_noLevelSetsUsedForMb;
  m_geometryIntersection->m_bodyToSetTable = m_bodyToSetTable;
  m_geometryIntersection->m_setToBodiesTable = m_setToBodiesTable;
  m_geometryIntersection->m_noBodiesInSet = m_noBodiesInSet;
}


/** \brief Updates the old Variables, the body positions and the increases the time
 *  \author Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::prepareNextTimeStep() {
  TRACE();

  advanceSolution();
  advanceBodies();
}


/**
 * \brief Initializes the solver
 *
 * mode = -1: default argument, call in the initialisation process
 * mode =  0: reinit after mesh adaptation
 * mode =  1: reinit after balance
 *
 * \author Lennart Schneiders, Update Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::initSolutionStep(MInt mode) {
  TRACE();

  NEW_TIMER_GROUP(t_initTimer, "initSolutionStep");
  NEW_TIMER(t_timertotal, "initSolutionStep", t_initTimer);
  NEW_SUB_TIMER(t_init, "init", t_timertotal);
  NEW_SUB_TIMER(t_createBnd, "createBoundaryCells", t_timertotal);
  NEW_SUB_TIMER(t_initBnd, "initBoundaryCells", t_timertotal);
  NEW_SUB_TIMER(t_stencil, "buildStencil", t_timertotal);
  NEW_SUB_TIMER(t_surfaces, "createSurfaces", t_timertotal);
  NEW_SUB_TIMER(t_initSurfaces, "initSurfaces", t_timertotal);
  NEW_SUB_TIMER(t_finalize, "finalize", t_timertotal);
  RECORD_TIMER_START(t_timertotal);
  RECORD_TIMER_START(t_init);

  grid().updateGridInfo();
  if(m_fvBndryCnd->m_cellCoordinatesCorrected) m_fvBndryCnd->recorrectCellCoordinates();

  MBool& frstrn = m_static_initSolutionStep_frstrn;
  if(mode == -1) {
    // should only be called once!
    ASSERT(frstrn, "");
    ASSERT(!m_onlineRestart, "");
  } else if(mode == 1) {
    ASSERT(m_onlineRestart, "");
  } else {
    ASSERT(!m_onlineRestart, "");
  }
  frstrn = false;

  if(!m_restart && mode < 1) {
    if(m_constructGField && m_bodyTypeMb) {
      constructGField();
    }
    m_bndryGhostCellsOffset = a_noCells();
  }

  exchangeLevelSetData();
  setCellProperties();

  RECORD_TIMER_STOP(t_init);
  RECORD_TIMER_START(t_createBnd);

  setLevelSetMbCellProperties();

  IF_CONSTEXPR(nDim == 3) {
    if(m_noPointParticles > 0) {
      initBodyProperties();
    }
  }

  // initialise cell-volume for all cells for firstRun
  // do not reset cellVolumes at balance, the volume has been exchanged!
  if(mode < 1) {
    computeCellVolumes();
  }

  // generates the outer-boundary-Cells
  generateBndryCells();
  m_noOuterBndryCells = m_fvBndryCnd->m_bndryCells->size();
  IF_CONSTEXPR(nDim == 3) { checkCells(); }

  for(MInt bndryId = 0; bndryId < m_noOuterBndryCells; bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    a_cellVolume(cellId) = m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume;
    m_cellVolumesDt1[cellId] = a_cellVolume(cellId);
    if(m_dualTimeStepping) m_cellVolumesDt2[cellId] = a_cellVolume(cellId);
    a_FcellVolume(cellId) = F1 / mMax(m_volumeThreshold, a_cellVolume(cellId));
    m_sweptVolume[bndryId] = F0;
    m_sweptVolumeDt1[bndryId] = F0;
  }
  // NOTE: m_cellVolumesDt1 is set correctly for all cells below!

  if(m_restart) {
    if(m_dualTimeStepping) {
      for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
        for(MInt varId = 0; varId < CV->noVariables; varId++) {
          a_dt2Variable(cellId, varId) = a_variable(cellId, varId);
          a_dt1Variable(cellId, varId) = a_variable(cellId, varId);
        }
      }
    }
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      for(MInt varId = 0; varId < CV->noVariables; varId++) {
        a_oldVariable(cellId, varId) = a_variable(cellId, varId);
      }
    }
  }


  // shift cell center of boundary cells
  m_fvBndryCnd->correctCellCoordinates();

  // MULTILEVEL
  // correct (xyz)cc and body surfaces of coarse boundary cells
  // requires that small and master cells are not yet merged!
  m_fvBndryCnd->correctCoarseBndryCells();
  m_fvBndryCnd->m_smallBndryCells->setSize(0);

  RECORD_TIMER_STOP(t_createBnd);
  RECORD_TIMER_START(t_initBnd);

  if(m_fvBndryCnd->m_cellMerging) {
    // detects small cells and identifies a master cell for each
    // merges master and small cell(s)
    m_fvBndryCnd->detectSmallBndryCells();
    m_log << "Connecting master and slave cells...";
    m_fvBndryCnd->mergeCells();
    m_log << "ok" << endl;
  } else {
    m_fvBndryCnd->setBCTypes();
    m_fvBndryCnd->setNearBoundaryRecNghbrs();
    m_fvBndryCnd->computeImagePointRecConst();
    if(m_fvBndryCnd->m_smallCellRHSCorrection) {
      m_fvBndryCnd->initSmallCellRHSCorrection();
    } else {
      m_fvBndryCnd->initSmallCellCorrection();
    }
  }


  // write out centerline data
  if(m_writeOutData) {
    cerr << "Writing out center line data" << endl;
    stringstream fileNameCL;
    fileNameCL << "centerlineData";
    fileNameCL << "_" << domainId();
    writeCenterLineVel((fileNameCL.str()).c_str());
    mTerm(0, AT_);
  }

  RECORD_TIMER_STOP(t_initBnd);

  RECORD_TIMER_START(t_surfaces);
  m_log << "create initial surfaces...";
  createInitialSrfcs();
  m_initialSurfacesOffset = a_noSurfaces();
  m_log << "ok" << endl;
  RECORD_TIMER_STOP(t_surfaces);

  RECORD_TIMER_START(t_stencil);
  setOuterBoundaryGhostCells();
  setOuterBoundarySurfaces();
  m_noOuterBoundarySurfaces = m_fvBndryCnd->m_noBoundarySurfaces;

  m_log << "Tagging cells needed for the surface flux computation...";
  tagCellsNeededForSurfaceFlux();
  m_log << "ok" << endl;

  // TODO labels:FVMB Check if this is necessary in 2D; Testcases pass also if setUpwindCoefficient() is not
  //      called here

  IF_CONSTEXPR(nDim == 2) {
    m_log << "Setting upwind coefficient...";
    setUpwindCoefficient(); // overrides value of restoreSurfaces()
    m_log << "ok" << endl;
  }

  m_log << "Computing plane vectors...";
  m_fvBndryCnd->computePlaneVectors();
  m_log << "ok" << endl;

  setCellProperties();
  if(m_useCentralDifferencingSlopes) {
    determineStructuredCells();
  }

  m_log << "Initializing the least-squares reconstruction...";
  // builds the least-squares stencil and computes the LS constants
  for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
    a_hasProperty(cellId, SolverCell::IsActive) = true;
  }
  if(m_fvBndryCnd->m_cellMerging) {
    // set the neighbor arrays m_storeNghbrIds, m_identNghbrIds
    findNghbrIds();
    buildLeastSquaresStencilSimple();
    mDeallocate(m_storeNghbrIds);
    mDeallocate(m_identNghbrIds);
  }
  m_log << "ok" << endl;

  // used for solution output!
  IF_CONSTEXPR(nDim == 3) {
    if(m_extractedCells != nullptr) {
      delete m_extractedCells;
      m_extractedCells = nullptr;
    } else if(m_gridPoints != nullptr) {
      delete m_gridPoints;
      m_gridPoints = nullptr;
    }
  }

  m_log << "Initializing the viscous flux computation...";
  initViscousFluxComputation();
  m_log << "ok" << endl;

  // initialize the reconstruction scheme for the boundary and ghost cells
  if(m_fvBndryCnd->m_cellMerging) {
    m_log << "Initializing boundary conditions...";
    findNghbrIds();
    m_fvBndryCnd->initBndryCnds();
    mDeallocate(m_storeNghbrIds);
    mDeallocate(m_identNghbrIds);
    m_log << "ok" << endl;
  } else {
    m_fvBndryCnd->setBCTypes();
  }

  // initCutOffBoundaryCondition();

#ifndef NDEBUG
  // NOTE: at this point cellVolumeDt1 is not correct on halo-cells, but set correctly below!
  checkHaloCells(3);
#endif

  m_log << "Computing reconstruction constants...";
  // Computes the reconstruction constants for each cell
  computeReconstructionConstants();
  m_log << "ok" << endl;
  RECORD_TIMER_STOP(t_stencil);

  if(grid().azimuthalPeriodicity()) {
    initAzimuthalReconstruction();
    computeAzimuthalReconstructionConstants();
    MUint noWindows = maia::mpi::getBufferSize(grid().azimuthalWindowCells());
    m_azimuthalWasNearBndryIds.clear();
    m_azimuthalWasNearBndryIds.assign(noWindows, -1);
    if(mode == 1) cutOffBoundaryCondition();
  }
  RECORD_TIMER_START(t_initSurfaces);
  initializeMaxLevelExchange();

#if defined _MB_DEBUG_ || !defined NDEBUG
  // In debug mode exhange() calls maxResidual(), which fails if RHS
  // is not set to 0 during init call (contains nans otherwise)
  resetRHS();
#endif

  if(grid().azimuthalPeriodicity()) {
    if(mode == 1) {
      for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
        // computePV() is called during loadBalance but RHO is 0 for these cells therefore computePV() results in nans.
        for(MInt v = 0; v < PV->noVariables; v++) {
          if(!(a_pvariable(cellId, v) >= F0 || a_pvariable(cellId, v) < F0) || std::isnan(a_pvariable(cellId, v))) {
            if(a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel)) {
              mTerm(1, "This should only occur for non-leaf cells!");
            }
            a_pvariable(cellId, v) = F0;
          }
        }
      }
    }
    exchangeAll(); // Just so that halo cells on lower levels do not contain nans.
  } else {
    exchange();
  }

  computeCellSurfaceDistanceVectors();

  // reset m_bndryCandidateIds
  m_bndryCandidateIds.clear();
  for(MInt i = 0; i < m_bndryGhostCellsOffset; i++) {
    m_bndryCandidateIds.push_back(-1);
  }
  m_bndryCandidates.clear();
  m_noBndryCandidates = 0;

  MBool found = false;
  for(MInt bc = 0; bc < m_fvBndryCnd->m_noBndryCndIds; bc++) {
    if(m_fvBndryCnd->m_bndryCndIds[bc] == m_movingBndryCndId) found = true;
  }
  if(!found) {
    m_fvBndryCnd->m_bndryCndIds[m_fvBndryCnd->m_noBndryCndIds] = m_movingBndryCndId;
    m_fvBndryCnd->m_noBndryCndIds++;
    m_vtuGeometryOutput.insert(m_movingBndryCndId);
    m_log << "Added moving boundary condition " << m_movingBndryCndId << endl;
  }
  m_fvBndryCnd->createBndryCndHandler();

  for(MInt i = 0; i < a_noCells(); i++) {
    a_hasProperty(i, SolverCell::NearWall) = false;
  }

  // Is the following really necessary? Testcases seem to also work without
  IF_CONSTEXPR(nDim == 2) {
    m_fvBndryCnd->recorrectCellCoordinates();
    const MFloat signStencil[4][2] = {{-F1, -F1}, {F1, -F1}, {-F1, F1}, {F1, F1}};
    MFloat tmpPoint[nDim];
    for(MInt bndryId = 0; bndryId < m_bndryCells->size(); bndryId++) {
      MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
      for(MInt p = 0; p < m_noCellNodes; p++) {
        for(MInt i = 0; i < nDim; i++) {
          tmpPoint[i] = a_coordinate(cellId, i) + signStencil[p][i] * F1B2 * c_cellLengthAtLevel(a_level(cellId));
        }
        m_pointIsInside[bndryId][IDX_LSSETMB(p, 0)] = m_geometry->pointIsInside(tmpPoint);
      }
    }
    m_fvBndryCnd->rerecorrectCellCoordinates();
  }

  MBool& firstRun = m_static_initSolutionStep_firstRun;
  if(m_restart) firstRun = true;
  if(firstRun) {
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      m_cellVolumesDt1[cellId] = a_cellVolume(cellId);
      if(m_dualTimeStepping) m_cellVolumesDt2[cellId] = a_cellVolume(cellId);
    }
    firstRun = false;
  }

  RECORD_TIMER_STOP(t_initSurfaces);
  RECORD_TIMER_START(t_finalize);

#ifndef NDEBUG
  m_log << "_________________________________________________________________" << endl << endl;
  m_log << "Grid summary after clean initialization:" << endl;
  m_log << "_________________________________________________________________" << endl << endl;
  m_log << setfill(' ');
  m_log << "number of cells                 " << setw(7) << a_noCells() << endl;
  m_log << "number of surfaces              " << setw(7) << a_noSurfaces() << endl;
  m_log << "number of small cells           " << setw(7) << m_fvBndryCnd->m_smallBndryCells->size() << endl;
  m_log << "minimum grid level              " << setw(7) << minLevel() << endl;
  m_log << "maximum grid level              " << setw(7) << maxLevel() << endl << endl;
  m_log << "level | total no cells | no of leaf cells | ghost cells" << endl;

  MInt total = 0, leaf = 0, ghost = 0;
  for(MInt level = maxLevel(); level >= minLevel(); level--) {
    total = 0;
    leaf = 0;
    ghost = 0;
    for(MInt cellId = 0; cellId < a_noCells(); cellId++) {
      if(a_isBndryGhostCell(cellId)) {
        if(a_level(cellId) == level) {
          total++;
          leaf++;
          ghost++;
        }
      } else if(a_level(cellId) == level) {
        total++;
        if(c_isLeafCell(cellId)) {
          leaf++;
        }
      }
    }
    m_log << setfill(' ');
    m_log << setw(3) << level << "  " << setw(12) << total << "  " << setw(16) << leaf << "  " << setw(14) << ghost
          << endl;
  }

  // check domain boundaries
  MInt noCells = noInternalCells();
  MFloat cellLength = NAN;
  MFloat maxC[3] = {-10000.0, -10000.0, -10000.0};
  MFloat minC[3] = {10000.0, 10000.0, 10000.0};
  for(MInt c = 0; c < noCells; c++) {
    if(!a_hasProperty(c, SolverCell::IsOnCurrentMGLevel)) continue;
    if(a_isHalo(c)) continue;
    if(a_isPeriodic(c)) continue;
    cellLength = c_cellLengthAtCell(c);
    for(MInt i = 0; i < nDim; i++) {
      maxC[i] = mMax(maxC[i], a_coordinate(c, i) + F1B2 * cellLength);
      minC[i] = mMin(minC[i], a_coordinate(c, i) - F1B2 * cellLength);
    }
  }
  m_log << "_________________________________________________________________" << endl << endl;

  m_log << "Physical domain boundaries: " << endl;
  m_log << "min (x,y" << (nDim == 3 ? ",z): (" : "): (") << minC[0] << "," << minC[1];
  IF_CONSTEXPR(nDim == 3) m_log << "," << minC[2];
  m_log << ")" << endl;
  m_log << "max (x,y" << (nDim == 3 ? ",z): (" : "): (") << maxC[0] << "," << maxC[1];
  IF_CONSTEXPR(nDim == 3) m_log << "," << maxC[2];
  m_log << ")" << endl;

  m_log << "_________________________________________________________________" << endl << endl;
#endif

  m_log << "Process " << domainId() << " finished FV-MB initialization at time step " << globalTimeStep << endl;

  if(domainId() == 0 || domainId() == noDomains() - 1)
    cerr << "Process " << domainId() << " finished FV-MB initialization at time step " << globalTimeStep << endl;

  m_log << endl << endl;

  RECORD_TIMER_STOP(t_finalize);
  RECORD_TIMER_STOP(t_timertotal);
  DISPLAY_TIMER(t_timertotal);
}


/**
 * \brief computes the left and right states of primitive variables at the surfaces
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::computeSurfaceValues(MInt NotUsed(timerId)) {
  TRACE();

  const MInt noSrfcs = a_noSurfaces();
  const MInt surfaceVarMemory = m_surfaceVarMemory;
  const MInt slopeMemory = m_slopeMemory;
  auto* surfaceVar = (MFloat*)(&(a_surfaceVariable(0, 0, 0)));
  auto* cellSlopes = (MFloat*)(&(a_slope(0, 0, 0)));
  auto* dx = (MFloat*)(&(a_surfaceDeltaX(0, 0)));

#ifdef _MB_DEBUG_
  MInt blk = -1;
  MInt sfc = 22564;
#endif

  MInt va0 = surfaceVarMemory * noSrfcs;
  MInt va1 = va0 + m_noPVars;
  MInt i = 2 * nDim * noSrfcs;
  for(MInt srfcId = noSrfcs; srfcId--;) {
    va0 -= surfaceVarMemory;
    va1 -= surfaceVarMemory;
    i -= 2 * nDim;

    {
      MInt nghbr0 = a_surfaceNghbrCellId(srfcId, 0);
      MInt nghbr1 = a_surfaceNghbrCellId(srfcId, 1);

      MInt sl0 = nghbr0 * slopeMemory;
      MInt sl1 = nghbr1 * slopeMemory;

      for(MInt varId = 0; varId < m_noPVars; varId++) {
//#define _MINMOD_LIMITER_
#ifdef _MINMOD_LIMITER_
        IF_CONSTEXPR(nDim == 2) {
          mTerm(1, "This part has never been used in 2D. If you know it is working properly remove this!");
        }
        MFloat vmin0 = 9999.9;
        MFloat vmax0 = -9999.9;
        MFloat vmin1 = 9999.9;
        MFloat vmax1 = -9999.9;
        MFloat phi0 = F1;
        MFloat phi1 = F1;
        if(a_surfaceBndryCndId(srfcId) < 0) {
          for(MInt dir = 0; dir < m_noDirs; dir++) {
            if(a_hasNeighbor(nghbr0, dir) > 0) {
              MInt nghbrId = c_neighborId(nghbr0, dir);
              if(!a_hasProperty(nghbrId, SolverCell::IsOnCurrentMGLevel)) continue;

              vmax0 = mMax(vmax0, a_pvariable(nghbrId, varId));
            }
            if(a_hasNeighbor(nghbr1, dir) > 0) {
              MInt nghbrId = c_neighborId(nghbr1, dir);
              if(!a_hasProperty(nghbrId, SolverCell::IsOnCurrentMGLevel)) continue;
              vmin1 = mMin(vmin1, a_pvariable(nghbrId, varId));
              vmax1 = mMax(vmax1, a_pvariable(nghbrId, varId));
            }
          }
          for(MInt dir = 0; dir < m_noDirs; dir++) {
            if(a_hasNeighbor(nghbr0, dir) > 0) {
              MInt nghbrId = c_neighborId(nghbr0, dir);
              if(!a_hasProperty(nghbrId, SolverCell::IsOnCurrentMGLevel)) continue;
              MFloat dv = F0;
              for(MInt j = 0; j < nDim; j++) {
                dv += (a_coordinate(nghbrId, j) - a_coordinate(nghbr0, j)) * a_slope(nghbr0, varId, j);
              }
              if(a_pvariable(nghbr0, varId) + dv < vmin0 || a_pvariable(nghbr0, varId) + dv > vmax0) {
                phi0 = mMin(phi0, mMax(F0, (a_pvariable(nghbrId, varId) - a_pvariable(nghbr0, varId)) / dv));
              }
            }
            if(a_hasNeighbor(nghbr1, dir) > 0) {
              MInt nghbrId = c_neighborId(nghbr1, dir);
              if(!a_hasProperty(nghbrId, SolverCell::IsOnCurrentMGLevel)) continue;
              MFloat dv = F0;
              for(MInt j = 0; j < nDim; j++) {
                dv += (a_coordinate(nghbrId, j) - a_coordinate(nghbr1, j)) * a_slope(nghbr1, varId, j);
              }
              if(a_pvariable(nghbr1, varId) + dv < vmin1 || a_pvariable(nghbr1, varId) + dv > vmax1) {
                phi1 = mMin(phi1, mMax(F0, (a_pvariable(nghbrId, varId) - a_pvariable(nghbr1, varId)) / dv));
              }
            }
          }
        }
        surfaceVar[va0 + varId] = a_pvariable(nghbr0, varId);
        surfaceVar[va0 + varId] += phi0 * std::inner_product(&cellSlopes[sl0], &cellSlopes[sl0] + nDim, &dx[i], 0);
        surfaceVar[va1 + varId] = a_pvariable(nghbr1, varId);
        surfaceVar[va1 + varId] +=
            phi1 * std::inner_product(&cellSlopes[sl1], &cellSlopes[sl1] + nDim, &dx[i + nDim], 0);

#else
        surfaceVar[va0 + varId] =
            std::inner_product(&cellSlopes[sl0], &cellSlopes[sl0] + nDim, &dx[i], a_pvariable(nghbr0, varId));
        surfaceVar[va1 + varId] =
            std::inner_product(&cellSlopes[sl1], &cellSlopes[sl1] + nDim, &dx[i + nDim], a_pvariable(nghbr1, varId));
#endif

#ifdef _MB_DEBUG_
        if(blk > -1 && domainId() == blk && srfcId == sfc) {
          cerr << "svalues @" << globalTimeStep << "/" << m_RKStep << " /s " << srfcId << " /n " << nghbr0 << " "
               << nghbr1 << " /var " << varId << " " << surfaceVar[va0 + varId] << " " << surfaceVar[va1 + varId]
               << " /cvar " << a_pvariable(nghbr0, varId) << " " << a_pvariable(nghbr1, varId) << " /sl0 "
               << cellSlopes[sl0] << " " << cellSlopes[sl0 + 1] << " " << cellSlopes[sl0 + 2] << " /sl1 "
               << cellSlopes[sl1] << " " << cellSlopes[sl1 + 1] << " " << cellSlopes[sl1 + 2] << " /dx0 " << dx[i]
               << " " << dx[i + 1] << " " << dx[i + 2] << " /dx1 " << dx[i + 3] << " " << dx[i + 4] << " " << dx[i + 5]
               << endl;
        }
#endif
        sl0 += nDim;
        sl1 += nDim;
      }

#ifdef _MB_DEBUG_
      if((surfaceVar[va0 + PV->P] < F0) || (surfaceVar[va1 + PV->P] < F0)) {
        m_log << globalTimeStep << "/" << m_RKStep << " negative pressure: " << srfcId << " " << nghbr0 << " " << nghbr1
              << " / " << surfaceVar[va0 + PV->P] << " " << surfaceVar[va1 + PV->P] << " " << a_pvariable(nghbr0, PV->P)
              << " " << a_pvariable(nghbr1, PV->P) << " / " << a_isHalo(nghbr0) << " " << a_isHalo(nghbr1) << " / "
              << a_level(nghbr0) << " " << a_level(nghbr1) << endl;
        const MInt offset0 = nDim * m_cells.noRecNghbrs() * nghbr0;
        for(MInt n = a_noReconstructionNeighbors(nghbr0); n--;) {
          m_log << srfcId << " recvals0: " << n << ":" << a_reconstructionNeighborId(nghbr0, n) << "("
                << m_reconstructionConstants[offset0 + n * nDim + 0] << "/"
                << m_reconstructionConstants[offset0 + n * nDim + 1] << "/"
                << m_reconstructionConstants[offset0 + n * nDim + 2] << "#"
                << a_pvariable(a_reconstructionNeighborId(nghbr0, n), PV->P) << "="
                << a_isHalo(a_reconstructionNeighborId(nghbr0, n)) << ") " << endl;
        }
        const MInt offset1 = nDim * m_cells.noRecNghbrs() * nghbr1;
        for(MInt n = a_noReconstructionNeighbors(nghbr1); n--;) {
          m_log << srfcId << " recvals1: " << n << ":" << a_reconstructionNeighborId(nghbr1, n) << "("
                << m_reconstructionConstants[offset1 + n * nDim + 0] << "/"
                << m_reconstructionConstants[offset1 + n * nDim + 1] << "/"
                << m_reconstructionConstants[offset1 + n * nDim + 2] << "#"
                << a_pvariable(a_reconstructionNeighborId(nghbr1, n), PV->P) << "="
                << a_isHalo(a_reconstructionNeighborId(nghbr1, n)) << ") " << endl;
        }
      }
#endif
    }
  }

  IF_CONSTEXPR(nDim == 3) {
    for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        for(MInt k = 0; k < nDim; k++) {
          MInt srfcId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcVariables[srfc]->m_srfcId[k];
          if(srfcId < 0) continue;
          for(MInt var = 0; var < m_noPVars; var++) {
            a_surfaceVariable(srfcId, 0, var) =
                m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[var];
            a_surfaceVariable(srfcId, 1, var) =
                m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[var];
          }
        }
      }
    }
  }
}


/**
 * \brief computes the left and right states of primitive variables at the surfaces
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::computeSurfaceValuesLimited(MInt NotUsed(timerId)) {
  TRACE();

  const MInt noSrfcs = a_noSurfaces();
  const MInt surfaceVarMemory = m_surfaceVarMemory;
  const MInt slopeMemory = m_slopeMemory;
  const MFloat eps = 1e-10 * m_rhoInfinity;
  auto* surfaceVar = (MFloat*)(&(a_surfaceVariable(0, 0, 0)));
  auto* cellSlopes = (MFloat*)(&(a_slope(0, 0, 0)));
  auto* dx = (MFloat*)(&(a_surfaceDeltaX(0, 0)));

  ScratchSpace<MFloat> phi(m_noSlopes * a_noCells(), AT_, "phi");
  for(MInt cellId = a_noCells(); cellId--;) {
    for(MInt j = 0; j < m_noSlopes; j++) {
      phi.p[cellId * m_noSlopes + j] = F0;
    }

    // if ( a_coordinate( cellId , 0) < m_bodyCenter[0] ) continue; //expansion smoothing for piston testcase
    if(a_hasProperty(cellId, SolverCell::IsNotGradient)) continue;
    if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
    if(a_bndryId(cellId) < -1) continue;

    for(MInt j = 0; j < nDim; j++) {
      if((!checkNeighborActive(cellId, 2 * j) || a_hasNeighbor(cellId, 2 * j) == 0)
         || (!checkNeighborActive(cellId, 2 * j + 1) || a_hasNeighbor(cellId, 2 * j + 1) == 0))
        continue;
      MInt n0 = c_neighborId(cellId, 2 * j);
      MInt n1 = c_neighborId(cellId, 2 * j + 1);
      ASSERT(n0 > -1 && n1 > -1 && n0 < a_noCells() && n1 < a_noCells(), "");
      for(MInt v = 0; v < m_noPVars; v++) {
        MFloat f =
            (a_pvariable(n1, v) - a_pvariable(cellId, v)) / (a_pvariable(cellId, v) - a_pvariable(n0, v) + m_eps);
        phi.p[cellId * m_noSlopes + v * nDim + j] = mMax(F0, mMin(F1, f)); // minmod
        // phi.p[ cellId*m_noSlopes + v*nDim + j ] = mMax( F0, mMin( F2, f ) ); //Osher
        // phi.p[ cellId*m_noSlopes + v*nDim + j ] = mMax( F0, mMax( mMin( F2, f ), mMin( F1, F2*f ) ) );
        // //superbee phi.p[ cellId*m_noSlopes + v*nDim + j ] = ( POW2(f) + f ) / ( POW2(f) + F1 ); //vanAlbada phi.p[
        // cellId*m_noSlopes + v*nDim + j ] = ( fabs(f) + f ) / ( fabs(f) + F1 ); //vanLeer phi.p[ cellId*m_noSlopes +
        // v*nDim + j ] = mMax( F0, mMax( mMin( F1, f ), mMin( F1, F1*f ) ) ); //Sweby phi.p[
        // cellId*m_noSlopes + v*nDim + j ] = mMax( F0, mMax( mMin( 1.5*f, F1 ), mMin( f, 1.5 ) ) );
        // //Sweby@beta=1.5 phi.p[ cellId*m_noSlopes + v*nDim + j ] = mMax( F0, mMax( mMin( F2*f, F1 ),
        // mMin( f, F2 ) ) ); //Sweby@beta=2 phi.p[ cellId*m_noSlopes + v*nDim + j ]
        // = 1.5*(POW2(f)+f)/(POW2(f)+f+F1); //ospre phi.p[ cellId*m_noSlopes + v*nDim + j ] = mMax( F0, mMin(
        // mMin( F2*f, F2 ), 0.5*(F1+f) ) );
        // //monotonized central phi.p[ cellId*m_noSlopes + v*nDim + j ] = mMax( F0, mMin( mMin( F2*f,
        // 0.25+0.75*f
        // ), mMin( F2, 0.75+0.25*f ) ) ); //UMIST

        // if ( a_coordinate( cellId , 0) < m_bodyCenter[0] ) phi.p[ cellId*m_noSlopes + v*nDim + j ] = F1;
        // if ( a_coordinate( cellId , 0) < m_bodyCenter[0] ) phi.p[ cellId*m_noSlopes + v*nDim + j ] = ( POW2(f) + f )
        // / ( POW2(f) + F1 ); //vanAlbada if ( j != 0 ) phi.p[ cellId*m_noSlopes + v*nDim + j ] = F0;
      }
    }
  }
  // if(globalTimeStep<20)phi.fill(F0);
  // phi.fill(F0);

  MInt va0 = surfaceVarMemory * noSrfcs;
  MInt va1 = va0 + m_noPVars;
  MInt i = 2 * nDim * noSrfcs;
  for(MInt srfcId = noSrfcs; srfcId--;) {
    va0 -= surfaceVarMemory;
    va1 -= surfaceVarMemory;
    i -= 2 * nDim;

    // if ( m_isActiveSurface[ srfcId ] ) {
    {
      MInt nghbr0 = a_surfaceNghbrCellId(srfcId, 0);
      MInt nghbr1 = a_surfaceNghbrCellId(srfcId, 1);

      MInt sl0 = nghbr0 * slopeMemory;
      MInt sl1 = nghbr1 * slopeMemory;

      for(MInt varId = 0; varId < m_noPVars; varId++) {
        surfaceVar[va0 + varId] = a_pvariable(nghbr0, varId);
        for(MInt dim = 0; dim < nDim; ++dim)
          surfaceVar[va0 + varId] +=
              phi.p[m_noSlopes * nghbr0 + nDim * varId + dim] * cellSlopes[sl0 + dim] * dx[i + dim];

        surfaceVar[va1 + varId] = a_pvariable(nghbr1, varId);
        for(MInt dim = 0; dim < nDim; ++dim)
          surfaceVar[va1 + varId] +=
              phi.p[m_noSlopes * nghbr1 + nDim * varId + dim] * cellSlopes[sl1 + dim] * dx[i + nDim + dim];

        sl0 += nDim;
        sl1 += nDim;
      }
      surfaceVar[va0 + PV->RHO] = mMax(eps, surfaceVar[va0 + PV->RHO]);
      surfaceVar[va1 + PV->RHO] = mMax(eps, surfaceVar[va1 + PV->RHO]);
      surfaceVar[va0 + PV->P] = mMax(eps, surfaceVar[va0 + PV->P]);
      surfaceVar[va1 + PV->P] = mMax(eps, surfaceVar[va1 + PV->P]);
    }
  }
}


/**
 * \brief correct surfaces intersected by the moving boundary
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::correctSrfcsMb() {
  TRACE();

  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      MInt srfcId = m_cellSurfaceMapping[cellId][dir];
      if(srfcId > -1) {
        updateCellSurfaceDistanceVector(srfcId);
      }
    }
  }
}


//#define AUSMPWP
//#define AUSMPLUS
#define SUBSONIC

/** \brief AUSM ( Advection Upwind Splitting Method ) by M.Liou and C.Steffens.
 *        "A New Flux Splitting Scheme", JCP 107, 23 - 39 (1993)
 *        Set of variables: u, v, rho, p
 *
 * Computes the convective flux.
 *
 * \author Daniel Hartmann
 * \note edited by Lennart Schneiders (31.10.2011)
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::Ausm() {
  TRACE();

  const MUint noPVars = PV->noVariables;
  const MUint noFluxVars = FV->noVariables;
  const MUint surfaceVarMemory = 2 * noPVars;

  MFloat* const RESTRICT fluxes = ALIGNED_MF(&a_surfaceFlux(0, 0));
  const MInt noSurfaces = a_noSurfaces();
  const MInt noData = m_surfaceVarMemory;
  auto* RESTRICT surfArea = &a_surfaceArea(0);
  auto* RESTRICT var = (MFloat*)(&(a_surfaceVariable(0, 0, 0)));

  MFloat* const RESTRICT surfaceVars = ALIGNED_F(&a_surfaceVariable(0, 0, 0));


  // 1) surface variable correction/centralization
  if(m_centralizeSurfaceVariables > 0) {
    for(MInt srfcId = 0; srfcId < noSurfaces; srfcId++) {
      const MInt orientation = a_surfaceOrientation(srfcId);
      const MUint offset = srfcId * surfaceVarMemory;
      MFloat* const RESTRICT leftVars = ALIGNED_F(surfaceVars + offset);
      MFloat* const RESTRICT rightVars = ALIGNED_F(leftVars + noPVars);

      MInt levelFac = -1;
      if(m_centralizeSurfaceVariables == 5) {
        const MInt nghbr0 = a_surfaceNghbrCellId(srfcId, 0);
        const MInt nghbr1 = a_surfaceNghbrCellId(srfcId, 1);
        const MInt level = mMax(a_level(nghbr0), a_level(nghbr1));
        levelFac = (MFloat)((maxRefinementLevel() - level) / (maxRefinementLevel() - maxUniformRefinementLevel()));
      }
      switch(m_centralizeSurfaceVariables) {
        case 1: {
          sysEqn().template centralizeSurfaceVariables<1>(leftVars, rightVars, orientation, levelFac);
          break;
        }
        case 2: {
          sysEqn().template centralizeSurfaceVariables<2>(leftVars, rightVars, orientation, levelFac);
          break;
        }
        case 3: {
          sysEqn().template centralizeSurfaceVariables<3>(leftVars, rightVars, orientation, levelFac);
          break;
        }
        case 4: {
          sysEqn().template centralizeSurfaceVariables<4>(leftVars, rightVars, orientation, levelFac);
          break;
        }
        case 5: {
          sysEqn().template centralizeSurfaceVariables<5>(leftVars, rightVars, orientation, levelFac);
          break;
        }
        default: {
          mTerm(1, AT_, "centralizeSurfaceVariables mode not implemented!");
          break;
        }
      }
    }
  }

  // 2) surface flux computation
  this->m_static_computeSurfaceValuesLimitedSlopesMan_checkedBndryCndIds = true;
  this->m_static_computeSurfaceValuesLimitedSlopesMan_correctWallBndryFluxes = false;

  // all surface variables updated, now lets compute the fluxes
  Base::Ausm();

  // correct all wall boundary surfaces
  for(MInt bs = 0; bs < m_fvBndryCnd->m_noBoundarySurfaces; bs++) {
    MInt srfcId = m_fvBndryCnd->m_boundarySurfaces[bs];
    if(a_surfaceBndryCndId(srfcId) == 3003) {
      const MInt offset = noData * srfcId;
      const MInt orientation = a_surfaceOrientation(srfcId);
      const MFloat area = surfArea[srfcId];
      const MFloat* leftVars = var + offset;
      const MFloat* rightVars = leftVars + noPVars;
      const MUint fluxOffset = srfcId * noFluxVars;
      MFloat* const RESTRICT flux = fluxes + fluxOffset;
      sysEqn().AusmBndryCorrection(orientation, area, leftVars, rightVars, flux);
    }
  }

  applyALECorrection();
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::checkCentroidDiff(MInt srfcId1, MInt srfcId2) {
  MFloat xDiff = F0;

  for(MInt i = 0; i < nDim; i++) {
    MFloat diff = a_surfaceCoordinate(srfcId1, i) - a_surfaceCoordinate(srfcId2, i);
    xDiff += (diff * diff);
  }

  return sqrt(xDiff);
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
MFloat FvMbCartesianSolverXD<nDim, SysEqn>::checkAreaDiff(MInt srfcId1, MInt srfcId2) {
  return fabs(a_surfaceArea(srfcId1) - a_surfaceArea(srfcId2));
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::CsgPlane::insertCoplanarPolygon(
    FvMbCartesianSolverXD<nDim, SysEqn>::CsgPolygon* polygon,
    std::vector<FvMbCartesianSolverXD<nDim, SysEqn>::CsgPolygon>* coplanarFront,
    std::vector<FvMbCartesianSolverXD<nDim, SysEqn>::CsgPolygon>* coplanarBack) const {
  ASSERT2(!(std::isnan(polygon->plane.normal.xx[0])), "");

  (this->normal.dot((polygon->plane.normal)) > F0 ? coplanarFront : coplanarBack)->push_back(*polygon);
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::CsgPlane::splitPolygon(
    FvMbCartesianSolverXD<nDim, SysEqn>::CsgPolygon* polygon,
    std::vector<FvMbCartesianSolverXD<nDim, SysEqn>::CsgPolygon>* coplanarFront,
    std::vector<FvMbCartesianSolverXD<nDim, SysEqn>::CsgPolygon>* coplanarBack,
    std::vector<FvMbCartesianSolverXD<nDim, SysEqn>::CsgPolygon>* front,
    std::vector<FvMbCartesianSolverXD<nDim, SysEqn>::CsgPolygon>* back) const {
  const MInt COPLANAR = 0;
  const MInt FRONT = 1;
  const MInt BACK = 2;
  const MInt SPANNING = 3;

  MInt polygonType = 0;
  std::vector<MInt> types;

  // test normals for equivalence
  MBool normalsEqual = false;
  IF_CONSTEXPR(nDim == 3) {
    if(abs(abs(this->normal.xx[0]) - abs(polygon->plane.normal.xx[0])) < MFloatEps
       && abs(abs(this->normal.xx[1]) - abs(polygon->plane.normal.xx[1])) < MFloatEps
       && abs(abs(this->normal.xx[2]) - abs(polygon->plane.normal.xx[2])) < MFloatEps)
      normalsEqual = true;
  }

  MBool coplanarVertex = false;
  for(MInt i = 0; (unsigned)i < polygon->vertices.size(); i++) {
    MFloat t = this->normal.dot((polygon->vertices[i].pos)) - this->w;
    MInt type = (t < -eps) ? BACK : (t > eps) ? FRONT : COPLANAR;
    polygonType |= type;
    types.push_back(type);
    IF_CONSTEXPR(nDim == 3) {
      if(type == 0) coplanarVertex = true;
    }
  }
  ASSERT2(!(std::isnan(polygon->plane.normal.xx[0])), "");

  // Only in 3D the if-clause can result in true
  if(normalsEqual && coplanarVertex) polygonType = COPLANAR;

  switch(polygonType) {
    case COPLANAR:
      (this->normal.dot((polygon->plane.normal)) > F0 ? coplanarFront : coplanarBack)->push_back(*polygon);
      break;
    case FRONT:
      front->push_back(*polygon);
      break;
    case BACK:
      back->push_back(*polygon);
      break;
    case SPANNING: {
      std::vector<CsgVertex> f;
      std::vector<CsgVertex> b;
      IF_CONSTEXPR(nDim == 2) {
        MInt i = 0;
        MInt j = 1;
        MInt ti = types[i], tj = types[j];
        CsgVertex vi = polygon->vertices[i];
        CsgVertex vj = polygon->vertices[j];
        if(ti != BACK) f.push_back(vi);
        if(ti != FRONT) b.push_back(ti != BACK ? vi.clone() : vi);
        if((ti | tj) == SPANNING) {
          MFloat t = (this->w - this->normal.dot((vi.pos))) / this->normal.dot(vj.pos.minus((vi.pos)));
          CsgVertex v = vi.interpolate(&vj, t);
          f.push_back(v);
          b.push_back(v.clone());
        }
        if(tj != BACK) f.push_back(vj);
        if(tj != FRONT) b.push_back(tj != BACK ? vj.clone() : vj);
      }
      else IF_CONSTEXPR(nDim == 3) {
        for(MInt i = 0; (unsigned)i < polygon->vertices.size(); i++) {
          MInt j = (i + 1) % polygon->vertices.size();
          MInt ti = types[i], tj = types[j];
          CsgVertex vi = polygon->vertices[i];
          CsgVertex vj = polygon->vertices[j];
          if(ti != BACK) f.push_back(vi);
          if(ti != FRONT) b.push_back(ti != BACK ? vi.clone() : vi);
          if((ti | tj) == SPANNING) {
            MFloat t = (this->w - this->normal.dot((vi.pos))) / this->normal.dot(vj.pos.minus((vi.pos)));
            CsgVertex v = vi.interpolate(&vj, t);
            f.push_back(v);
            b.push_back(v.clone());
          }
        }
      }
      if(f.size() >= nDim)
        front->push_back(
            CsgPolygon(f, polygon->setIndex, polygon->faceId, polygon->faceType, polygon->bodyId, polygon->plane));
      if(b.size() >= nDim)
        back->push_back(
            CsgPolygon(b, polygon->setIndex, polygon->faceId, polygon->faceType, polygon->bodyId, polygon->plane));
    } break;
    default:
      break;
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::CsgNode::build(std::vector<CsgPolygon> _polygons) {
  if(_polygons.empty()) return;
  MInt polygonStartIndex = nDim == 3 ? 0 : 1;
  if(!planeValid) {
    this->plane = _polygons[0].plane.clone();
    planeValid = true;
    IF_CONSTEXPR(nDim == 3) {
      this->polygons.push_back(_polygons[0]);
      polygonStartIndex = 1;
    }
  }
  std::vector<CsgPolygon> _front;
  std::vector<CsgPolygon> _back;
  IF_CONSTEXPR(nDim == 2) { this->plane.insertCoplanarPolygon(&_polygons[0], &this->polygons, &this->polygons); }
  for(MInt i = polygonStartIndex; (unsigned)i < _polygons.size(); i++) {
    this->plane.splitPolygon(&_polygons[i], &this->polygons, &this->polygons, &_front, &_back);
  }
  if(_front.size() != 0u) {
    if(!this->front) // check if nullptr
      this->front = new CsgNode();
    this->front->build(_front);
  }
  if(_back.size() != 0u) {
    if(!this->back) this->back = new CsgNode();
    this->back->build(_back);
  }
}


/**
 * \brief Test a face (MarchingCubes helper routine)
 * receives MAIA face
 * if face>0 return true if the face contains a part of the surface
 */
template <MInt nDim, class SysEqn>
MBool FvMbCartesianSolverXD<nDim, SysEqn>::test_face(MInt cndId, MInt face, MInt set) {
  const MInt faceCornerMapping[6][4] = {{2, 6, 4, 0}, {1, 5, 7, 3}, {0, 4, 5, 1},
                                        {3, 7, 6, 2}, {2, 3, 1, 0}, {6, 7, 5, 4}};

  MFloat A = m_candidateNodeValues[IDX_LSSETNODES(cndId, faceCornerMapping[face][0], set)];
  MFloat B = m_candidateNodeValues[IDX_LSSETNODES(cndId, faceCornerMapping[face][1], set)];
  MFloat C = m_candidateNodeValues[IDX_LSSETNODES(cndId, faceCornerMapping[face][2], set)];
  MFloat D = m_candidateNodeValues[IDX_LSSETNODES(cndId, faceCornerMapping[face][3], set)];

  MFloat testSum = A * C - B * D;
  if(fabs(testSum) < m_eps) return true;
  return A * testSum >= F0; // A being negative inverts signs
}


/**
 * \brief compute various integrations over projection of face
 * \author
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 2, _*>>
void FvMbCartesianSolverXD<nDim, SysEqn>::compProjectionIntegrals(polyCutCell* cutCell, std::vector<polyEdge2D>* edges,
                                                                  const std::vector<polyVertex>* vertices, MInt A,
                                                                  MInt B, MFloat* P) {
  MFloat P1 = F0, Pa = F0, Pb = F0;

  for(MInt i = 0; (unsigned)i < (*cutCell).faces_edges.size(); i++) {
    MInt edge = (*cutCell).faces_edges[i];
    MInt vertex0, vertex1;
    vertex0 = (*edges)[edge].vertices[0];
    vertex1 = (*edges)[edge].vertices[1];
    MFloat a0 = (*vertices)[vertex0].coordinates[A];
    MFloat b0 = (*vertices)[vertex0].coordinates[B];
    MFloat a1 = (*vertices)[vertex1].coordinates[A];
    MFloat b1 = (*vertices)[vertex1].coordinates[B];
    MFloat da = a1 - a0;
    MFloat db = b1 - b0;
    MFloat a0_2 = a0 * a0;
    MFloat b0_2 = b0 * b0;

    MFloat C1 = a1 + a0;
    MFloat Ca = a1 * C1 + a0_2;
    MFloat Cb = b1 * (b1 + b0) + b0_2;

    P1 += db * C1;
    Pa += db * Ca;
    Pb += da * Cb;

    (*edges)[edge].center[A] = a0 + F1B2 * da;
    (*edges)[edge].center[B] = b0 + F1B2 * db;
    (*edges)[edge].area = sqrt(da * da + db * db);
  }

  P[0] = P1 / 2.0;
  P[1] = Pa / 6.0;
  P[2] = Pb / -6.0;
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 2, _*>>
void FvMbCartesianSolverXD<nDim, SysEqn>::compFaceIntegrals(polyCutCell* cutCell, std::vector<polyEdge2D>* edges,
                                                            const std::vector<polyVertex>* vertices, MInt A, MInt B) {
  MFloat P[3];

  compProjectionIntegrals(cutCell, edges, vertices, A, B, P);

  MFloat area = P[0];
  if(area > 1e3 * m_eps) {
    cutCell->volume = area;
    cutCell->center[A] = P[1] / area;
    cutCell->center[B] = P[2] / area;
  } else if(area > F0) {
    cutCell->volume = area;
    P[1] = F0;
    P[2] = F0;
    for(MInt i = 0; (unsigned)i < (*cutCell).faces_edges.size(); i++) {
      MInt edge = (*cutCell).faces_edges[i];
      MInt vertex0 = (*edges)[edge].vertices[0];
      P[1] += (*vertices)[vertex0].coordinates[0];
      P[2] += (*vertices)[vertex0].coordinates[1];
    }
    P[1] /= (*cutCell).faces_edges.size();
    P[2] /= (*cutCell).faces_edges.size();
    cutCell->center[A] = P[1];
    cutCell->center[B] = P[2];
  } else {
    cutCell->volume = F0;
    P[1] = F0;
    P[2] = F0;
    for(MInt i = 0; (unsigned)i < (*cutCell).faces_edges.size(); i++) {
      MInt edge = (*cutCell).faces_edges[i];
      MInt vertex0 = (*edges)[edge].vertices[0];
      P[1] += (*vertices)[vertex0].coordinates[0];
      P[2] += (*vertices)[vertex0].coordinates[1];
    }
    P[1] /= (*cutCell).faces_edges.size();
    P[2] /= (*cutCell).faces_edges.size();
    cutCell->center[A] = P[1];
    cutCell->center[B] = P[2];
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 2, _*>>
void FvMbCartesianSolverXD<nDim, SysEqn>::compVolumeIntegrals(std::vector<polyCutCell>* cutCells,
                                                              std::vector<polyEdge2D>* edges,
                                                              const std::vector<polyVertex>* vertices) {
  MInt A = 0, B = 1;

  for(MInt cC = 0; (unsigned)cC < cutCells->size(); cC++) {
    polyCutCell* cutCell = &(*cutCells)[cC];

    compFaceIntegrals(cutCell, edges, vertices, A, B);
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvMbCartesianSolverXD<nDim, SysEqn>::checkNormalVectors() {
  const MInt noCells = m_fvBndryCnd->m_bndryCells->size();

  for(MInt bndryId = m_noOuterBndryCells; bndryId < noCells; bndryId++) {
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId < 0) {
        mTerm(1, AT_, "error in createCutFaceMb(): m_bndryCndId not set: " + to_string(bndryId));
      }
      MFloat test = F0;
      for(MInt i = 0; i < nDim; i++) {
        test += POW2(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i]);
      }
      if(fabs(test - F1) > 0.1) {
        MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
#ifdef _MB_DEBUG_
        cerr << domainId() << ": bad normal vector corrected, n^2=" << test << ", timestep= " << globalTimeStep
             << ", cell " << cellId << " " << bndryId << " " << srfc << " " << c_globalId(cellId)
             << " /p15=" << a_isHalo(cellId) << " /n "
             << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[0] << " "
             << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[1] << " "
             << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[2] << " /a "
             << m_fvBndryCnd->m_bndryCell[bndryId].m_srfcs[srfc]->m_area << " /v "
             << m_fvBndryCnd->m_bndryCells->a[bndryId].m_volume / grid().gridCellVolume(a_level(cellId)) << " /c "
             << m_bndryCells->a[bndryId].m_coordinates[0] << " " << m_bndryCells->a[bndryId].m_coordinates[1] << " "
             << m_bndryCells->a[bndryId].m_coordinates[2] << " /s "
             << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[0] << " "
             << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[1] << " "
             << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_coordinates[2] << endl;
#endif
        MFloat nablaPhi[3] = {F1, F1, F1};
        MFloat nablaAbs = F0;
        for(MInt i = 0; i < nDim; i++) {
          MInt n0 = (a_hasNeighbor(cellId, 2 * i) > 0) ? c_neighborId(cellId, 2 * i) : cellId;
          MInt n1 = (a_hasNeighbor(cellId, 2 * i + 1) > 0) ? c_neighborId(cellId, 2 * i + 1) : cellId;
          if(n0 != n1) {
            nablaPhi[i] = (a_levelSetValuesMb(n1, 0) - a_levelSetValuesMb(n0, 0))
                          / mMax(1e-14, a_coordinate(n1, i) - a_coordinate(n0, i));
          }
          nablaAbs += POW2(nablaPhi[i]);
        }
        nablaAbs = sqrt(nablaAbs);
        for(MInt i = 0; i < nDim; i++) {
          nablaPhi[i] /= nablaAbs;
          m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i] = nablaPhi[i];
        }
#ifdef _MB_DEBUG_
        cerr << domainId() << ": corrected " << POW2(nablaAbs) << " /n "
             << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[0] << " "
             << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[1] << " "
             << m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[2] << endl;
        // m_fvBndryCnd->writeStlFileOfCell(cellId,("out/cell_"+to_string(c_globalId(cellId))+"_"+to_string(globalTimeStep)+".stl").c_str());
#endif
      } else {
        test = sqrt(test);
        for(MInt i = 0; i < nDim; i++) {
          m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i] /= test;
        }
      }
    }
  }
}


/**
 * \fn void FvMbCartesianSolverXD<nDim, SysEqn>::writeVtkXmlOutput()
 * \brief write flow variables as XML VTK
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 2, _*>>
void FvMbCartesianSolverXD<nDim, SysEqn>::writeVtkXmlOutput(const MString& fileName, MBool debugOutput) {
  TRACE();

  if(m_complexBoundary) return writeVtkXmlOutput_MGC(fileName);

  ASSERT(debugOutput || true, "");

  MInt noCells = 1;
  MInt noPoints = 1;

  /*! \page propertiesFVMB
    \section writePointData
    <code>MFloat FvMbSolver2D::writeVtkXmlOutput::writePointData</code>\n
    default = <code>0</code>\n
    Triggers wether point (vertex-centered) or cell (cell-centered) data is written to the output file.\n
    Possible values are:
    <ul>
    <li>0: deactivated</li>
    <li>1: activated</li>
    </ul>
    Keywords: <i>FINITE VOLUME, MOVING BOUNDARY, VTK</i>
  */
  MBool writePointData = false;
  writePointData = Context::getSolverProperty<MBool>("writePointData", solverId(), AT_, &writePointData);

#ifdef _MB_DEBUG_
  MBool sensorOutput = m_adaptation;
#endif
  MBool QThresholdOutput = true;
  MBool entropyChangeOutput = true;


  const MInt baseCellType = 8;
  const MInt polyCellType = 7;

  MInt cellId, ghostCellId, counter;


  const string dataType64 = "Float64";
#ifdef DOUBLE_PRECISION_OUTPUT
  const string dataType = "Float64";
#else
  const string dataType = "Float32";
#endif
  const string iDataType = "Int32";
  const string uIDataType = "UInt32";
  const string uI8DataType = "UInt8";
  const string uI16DataType = "UInt16";

  MUint uinumber;
#ifdef DOUBLE_PRECISION_OUTPUT
  MFloat fnumber;
  typedef MFloat flt;
#else
  using flt = float;
#endif

  if(noDomains() == 1) {
    cerr << "extracted";
    cerr << "(" << m_extractedCells->size() << ")...";
  }

  noPoints = m_gridPoints->size();
  MInt noExtractedCells = m_extractedCells->size();
  noCells = noExtractedCells;

  // 4 node ids for each direction
  const MInt ltable[4][3] = {{2, 3}, {0, 2}, {1, 0}, {3, 1}};
  const MInt pointOrder[4] = {0, 1, 3, 2};
  const MInt dirOrder[4] = {2, 1, 3, 0};
  const MInt reverseDir[4] = {1, 0, 3, 2};

  MInt centerId;

  ScratchSpace<MInt> cellTypes(noExtractedCells, AT_, "cellTypes");
  ScratchSpace<MInt> polyIds(noExtractedCells, AT_, "polyIds");
  ScratchSpace<MInt> reverseMapping(a_noCells(), AT_, "reverseMapping");
  ScratchSpace<MInt> cutPointIds(m_noDirs * m_fvBndryCnd->m_bndryCells->size(), AT_, "cutPointIds");

  MInt noPolyCells;

  // integrity check 1
  for(MInt c = 0; c < noExtractedCells; c++) {
    cellId = m_extractedCells->a[c].m_cellId;
    for(MInt k = 0; k < m_noCellNodes; k++) {
      MInt pid = m_extractedCells->a[c].m_pointIds[k];
      if(pid < 0 || pid >= noPoints) {
        mTerm(1, AT_,
              "Error A in FvMbSolver2D::writeVtkXmlOutput(..). Quit. " + to_string(cellId) + " " + to_string(k) + " "
                  + to_string(pid));
      }
    }
  }

  for(MInt i = 0; i < m_noDirs * m_fvBndryCnd->m_bndryCells->size(); i++) {
    cutPointIds.p[i] = -1;
  }

  if(noDomains() == 1) {
    cerr << "prepare...";
  }
  for(MInt c = 0; c < a_noCells(); c++) {
    reverseMapping.p[c] = -1;
  }
  for(MInt c = 0; c < noExtractedCells; c++) {
    reverseMapping.p[m_extractedCells->a[c].m_cellId] = c;
  }

  MBool isPolyCell;
  noPolyCells = 0;

  for(MInt c = 0; c < noExtractedCells; c++) {
    cellId = m_extractedCells->a[c].m_cellId;
    cellTypes.p[c] = baseCellType;
    polyIds.p[c] = -1;
    isPolyCell = false;
    if(a_bndryId(cellId) > -1) {
      isPolyCell = true;
    } else {
      for(MInt i = 0; i < m_noDirs; i++) {
        if(a_hasNeighbor(cellId, i) > 0) {
          if(c_noChildren(c_neighborId(cellId, i)) > 0) {
            isPolyCell = true;
            MInt nghbrId = c_neighborId(cellId, i);
            if(nghbrId < 0) continue;
            for(MInt j = 0; j < m_noCellNodes; j++) {
              MInt childId = c_childId(nghbrId, j);
              if(reverseMapping.p[childId] < 0) {
                isPolyCell = false;
              }
            }
          }
        }
      }
    }
    if(isPolyCell) {
      cellTypes.p[c] = polyCellType;
      polyIds.p[c] = noPolyCells;
      noPolyCells++;
    }
  }

  MBool isPolyFace;
  MInt eCell, nghbrId;
  const MInt maxNoExtraPoints = 8;
  const MInt maxNoPolyCells = noPolyCells;
  ScratchSpace<MInt> polyCellLink(maxNoPolyCells, AT_, "polyCellLink");
  ScratchSpace<MInt> extraPoints(maxNoPolyCells * maxNoExtraPoints, AT_, "extraPoints");
  ScratchSpace<MInt> noExtraPoints(maxNoPolyCells, AT_, "noExtraPoints");
  ScratchSpace<MInt> noInternalPoints(maxNoPolyCells, AT_, "noInternalPoints");
  MInt offset, pointCount;

  for(MInt c = 0; c < noExtractedCells; c++) {
    if(cellTypes.p[c] == polyCellType) {
      polyCellLink.p[polyIds.p[c]] = c;
    }
  }

  const MInt noInternalGridPoints = m_gridPoints->size();

  for(MInt pc = 0; pc < noPolyCells; pc++) {
    eCell = polyCellLink.p[pc];
    cellId = m_extractedCells->a[eCell].m_cellId;
    noInternalPoints.p[pc] = m_noCellNodes;
    noExtraPoints.p[pc] = 0;

    // a) cut cells at the boundary
    if(a_bndryId(cellId) > -1) {
      MInt bndryId = a_bndryId(cellId);

      noInternalPoints.p[pc] = 0;

      for(MInt i = 0; i < m_noDirs; i++) {
        MInt p = pointOrder[i];
        MInt dir = dirOrder[i];

        // 0. determine internal vertices
        if(!m_pointIsInside[bndryId][IDX_LSSETMB(p, 0)]) {
          extraPoints.p[pc * maxNoExtraPoints + noExtraPoints.p[pc]] = m_extractedCells->a[eCell].m_pointIds[p];
          noExtraPoints.p[pc]++;
        }

        // 1. add cut points
        for(MInt cp = 0; cp < m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cp++) {
          if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cp] == dir) {
            MInt gridPointId = -1;
            if(a_hasNeighbor(cellId, dir) > 0) {
              if(a_bndryId(c_neighborId(cellId, dir)) > -1) {
                gridPointId = cutPointIds.p[m_noDirs * a_bndryId(c_neighborId(cellId, dir)) + reverseDir[dir]];
                if(gridPointId > -1) {
                  m_gridPoints->a[gridPointId].m_cellIds[m_gridPoints->a[gridPointId].m_noAdjacentCells] = cellId;
                  m_gridPoints->a[gridPointId].m_noAdjacentCells++;
                }
              }
            }
            if(gridPointId >= noPoints) {
              mTerm(1, AT_, "Error 0 in FvMbSolver3D::writeVtkXmlOutput(..). Quit.");
            }
            if(gridPointId < 0) {
              gridPointId = m_gridPoints->size();
              m_gridPoints->append();
              noPoints++;
              m_gridPoints->a[gridPointId].m_noAdjacentCells = 1;
              m_gridPoints->a[gridPointId].m_cellIds[0] = cellId;
              for(MInt j = 0; j < nDim; j++) {
                m_gridPoints->a[gridPointId].m_coordinates[j] =
                    m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_srfcs[0]->m_cutCoordinates[cp][j];
              }
            }
            cutPointIds.p[m_noDirs * bndryId + dir] = gridPointId;

            extraPoints.p[pc * maxNoExtraPoints + noExtraPoints.p[pc]] = gridPointId;
            noExtraPoints.p[pc]++;
          }
        }
      }
    }
    // b) cells at fine/coarse mesh interfaces
    else {
      noInternalPoints.p[pc] = 0;

      for(MInt i = 0; i < m_noDirs; i++) {
        MInt p = pointOrder[i];
        MInt dir = dirOrder[i];

        extraPoints.p[pc * maxNoExtraPoints + noExtraPoints.p[pc]] = m_extractedCells->a[eCell].m_pointIds[p];
        noExtraPoints.p[pc]++;

        isPolyFace = false;
        if(a_hasNeighbor(cellId, dir) > 0) {
          nghbrId = c_neighborId(cellId, dir);
          if(c_noChildren(nghbrId) > 0) {
            isPolyFace = true;
            for(MInt child = 0; child < m_noCellNodes; child++) {
              if(!childCode[dir][child]) continue;
              MInt childId = c_childId(nghbrId, child);
              if(childId < 0) {
                isPolyFace = false;
              }
              if(reverseMapping.p[childId] < 0) {
                isPolyFace = false;
              }
            }
          }
        }

        if(isPolyFace) {
          // store four faces (polygon numbering!)
          nghbrId = reverseMapping.p[c_childId(c_neighborId(cellId, dir), ltable[i][0])];
          if(nghbrId < 0) {
            cerr << "=== VTK XML ERROR LOG === " << domainId() << endl;
            cerr << endl
                 << cellId << " " << a_bndryId(cellId) << " " << c_childId(c_neighborId(cellId, dir), ltable[i][0])
                 << endl;
            cerr << endl << a_noCells() << " " << a_noCells() << " " << dir << " " << ltable[i][0] << endl;
            cerr << a_levelSetValuesMb(cellId, 0) << " " << a_hasProperty(cellId, SolverCell::IsInactive) << endl;
            cerr << "props: " << a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) << " " << a_isHalo(cellId) << " "
                 << a_hasProperty(cellId, SolverCell::IsNotGradient) << " "
                 << a_hasProperty(c_neighborId(cellId, dir), SolverCell::IsOnCurrentMGLevel) << " "
                 << a_hasProperty(c_childId(c_neighborId(cellId, dir), ltable[i][0]), SolverCell::IsOnCurrentMGLevel)
                 << endl;
            cerr << endl
                 << cellId << " " << c_neighborId(cellId, dir) << " "
                 << c_childId(c_neighborId(cellId, dir), ltable[i][0]) << " / " << a_level(cellId) << " "
                 << a_level(c_neighborId(cellId, dir)) << " "
                 << a_level(c_childId(c_neighborId(cellId, dir), ltable[i][0])) << " / " << c_noChildren(cellId) << " "
                 << c_noChildren(c_neighborId(cellId, dir)) << " "
                 << c_noChildren(c_childId(c_neighborId(cellId, dir), ltable[i][0])) << endl;
            cerr << c_childId(c_neighborId(cellId, dir), 0) << " " << c_childId(c_neighborId(cellId, dir), 1) << " "
                 << c_childId(c_neighborId(cellId, dir), 2) << " " << c_childId(c_neighborId(cellId, dir), 3) << endl;
            cerr << a_coordinate(c_neighborId(cellId, dir), 0) << " " << a_coordinate(c_neighborId(cellId, dir), 1)
                 << endl;
            for(MInt j = 0; j < m_noCellNodes; j++) {
              cerr << a_hasProperty(c_childId(c_neighborId(cellId, dir), j), SolverCell::IsInactive) << " ";
            }
            cerr << endl;
            for(MInt j = 0; j < m_noCellNodes; j++) {
              cerr << a_hasProperty(c_childId(c_neighborId(cellId, dir), j), SolverCell::IsOnCurrentMGLevel) << " ";
            }
            cerr << endl;
            mTerm(1, AT_, "Error 1 in FvMbSolver2D::writeVtkXmlOutput(..). Quit.");
          }
          centerId = m_extractedCells->a[nghbrId].m_pointIds[ltable[i][1]];
          extraPoints.p[pc * maxNoExtraPoints + noExtraPoints.p[pc]] = centerId;
          noExtraPoints.p[pc]++;

          if(m_gridPoints->a[centerId].m_noAdjacentCells < m_noCellNodes) {
            m_gridPoints->a[centerId].m_cellIds[m_gridPoints->a[centerId].m_noAdjacentCells] = cellId;
            m_gridPoints->a[centerId].m_noAdjacentCells++;
          } else {
            cerr << endl << cellId << " / ";
            for(MInt c = 0; c < m_gridPoints->a[centerId].m_noAdjacentCells; c++)
              cerr << m_gridPoints->a[centerId].m_cellIds[c] << " ";
            cerr << endl;
            mTerm(1, AT_, "Error 2 in FvMbSolver2D::writeVtkXmlOutput(..). Quit.");
          }
        }
      }
    }
  }

  pointCount = 0;
  for(MInt c = 0; c < noExtractedCells; c++) {
    MInt pc = polyIds.p[c];
    if(pc > -1) {
      pointCount += noInternalPoints.p[pc];
      pointCount += noExtraPoints.p[pc];
    } else {
      pointCount += m_noCellNodes;
    }
  }

  MInt qDataSize = 2;
  if(QThresholdOutput) qDataSize++;
  ScratchSpace<MFloat> qData(qDataSize, a_noCells(), AT_, "qData");
  MFloat gradU[2][2];
  for(MInt c = 0; c < noExtractedCells; c++) {
    cellId = m_extractedCells->a[c].m_cellId;

    for(MInt i = 0; i < nDim; i++) {
      for(MInt j = 0; j < nDim; j++) {
        gradU[i][j] = a_slope(cellId, PV->VV[i], j) * m_referenceLength / m_UInfinity;
      }
    }
    MFloat omega = F1B2 * (gradU[1][0] - gradU[0][1]);
    MFloat omega2 = POW2(omega);
    MFloat S2 = 0;
    for(MInt i = 0; i < nDim; i++) {
      for(MInt j = 0; j < nDim; j++) {
        S2 += POW2(F1B2 * (gradU[i][j] + gradU[j][i]));
      }
    }
    MFloat Q = F1B2 * (omega2 / S2 - F1);
    qData(0, cellId) = Q;
    qData(1, cellId) = omega;
    if(QThresholdOutput) qData(2, cellId) = F1B2 * ((omega2 / mMax(m_eps, S2)) - F1);
  }


  // GATHER
  if(noDomains() == 1) {
    cerr << "gather...";
  }

  // points
  ScratchSpace<flt> points(3 * noPoints, AT_, "points");
  for(MInt p = 0; p < noPoints; p++) {
    for(MInt i = 0; i < nDim; i++) {
      points.p[3 * p + i] = (flt)m_gridPoints->a[p].m_coordinates[i];
    }
    points.p[3 * p + 2] = (flt)F0;
  }

  // connectivity
  ScratchSpace<MUint> connectivity(pointCount, AT_, "connectivity");
  counter = 0;
  for(MInt c = 0; c < noExtractedCells; c++) {
    MInt pc = polyIds.p[c];
    if(pc > -1) {
      for(MInt p = 0; p < noExtraPoints.p[pc]; p++) {
        connectivity.p[counter] = (MUint)extraPoints.p[pc * maxNoExtraPoints + p];
        counter++;
      }
    } else {
      for(MInt p = 0; p < m_noCellNodes; p++) {
        connectivity.p[counter] = (MUint)m_extractedCells->a[c].m_pointIds[p];
        counter++;
      }
    }
  }
  if(counter != pointCount) {
    mTerm(1, AT_, "E1");
  }

  // offsets
  ScratchSpace<MUint> offsets(noCells, AT_, "offsets");
  counter = 0;
  for(MInt c = 0; c < noExtractedCells; c++) {
    MInt pc = polyIds.p[c];
    if(pc > -1)
      counter += noInternalPoints.p[pc] + noExtraPoints.p[pc];
    else
      counter += m_noCellNodes;

    offsets.p[c] = (MUint)counter;
  }

  // types
  ScratchSpace<unsigned char> types(noCells, AT_, "types");
  for(MInt c = 0; c < noExtractedCells; c++) {
    types.p[c] = (unsigned char)cellTypes.p[c];
  }

  // cellIds
  ScratchSpace<MInt> cellIds(noCells, AT_, "cellIds");
  for(MInt c = 0; c < noExtractedCells; c++) {
    cellIds.p[c] = m_extractedCells->a[c].m_cellId;
  }

  // vtkGhostLevels
  const MInt noCh = (m_haloCellOutput) ? noCells : 1;
  ScratchSpace<unsigned char> vtkGhostLevels(noCh, AT_, "vtkGhostLevels");
  if(m_haloCellOutput) {
    for(MInt c = 0; c < noExtractedCells; c++) {
      vtkGhostLevels.p[c] = (unsigned char)0;
      if(a_isHalo(m_extractedCells->a[c].m_cellId)) vtkGhostLevels.p[c] = (unsigned char)1;
      if(a_hasProperty(m_extractedCells->a[c].m_cellId, SolverCell::IsNotGradient))
        vtkGhostLevels.p[c] = (unsigned char)2;
    }
  }

#ifdef _MB_DEBUG_

  // bndryIds
  ScratchSpace<MInt> bndryIds(noCells, AT_, "bndryIds");
  for(MInt c = 0; c < noExtractedCells; c++) {
    bndryIds.p[c] = a_bndryId(m_extractedCells->a[c].m_cellId);
    if(bndryIds.p[c] < 0 && a_hasProperty(m_extractedCells->a[c].m_cellId, SolverCell::IsInactive)) bndryIds.p[c] = -3;
  }

  // drho_dt
  ScratchSpace<MFloat> drho_dt(noCells, AT_, "drho_dt");
  for(MInt c = 0; c < noExtractedCells; c++) {
    drho_dt.p[c] =
        a_FcellVolume(m_extractedCells->a[c].m_cellId) * a_rightHandSide(m_extractedCells->a[c].m_cellId, CV->RHO);
  }

  // drhou_dt
  ScratchSpace<MFloat> drhou_dt(noCells, AT_, "drhou_dt");
  for(MInt c = 0; c < noExtractedCells; c++) {
    drhou_dt.p[c] = a_rightHandSide(m_extractedCells->a[c].m_cellId, CV->RHO_U);
  }

  // levelSetFunction
  ScratchSpace<flt> levelSetFunction(noCells, AT_, "levelSetFunction");
  for(MInt c = 0; c < noExtractedCells; c++) {
    levelSetFunction.p[c] = (flt)a_levelSetValuesMb(m_extractedCells->a[c].m_cellId, 0);
  }
#endif

  // additional cellData/pointData
  MInt asize = noCells;
  if(writePointData) {
    asize = noPoints;
  }

  ScratchSpace<flt> pressure(asize, AT_, "pressure");
  ScratchSpace<flt> velocity(3 * asize, AT_, "velocity");
  ScratchSpace<flt> density(asize, AT_, "density");
  ScratchSpace<flt> vorticity(asize, AT_, "vorticity");
  ScratchSpace<flt> Qcriterion(asize, AT_, "Qcriterion");
  const MInt dSSize = entropyChangeOutput ? asize : 1;
  ScratchSpace<flt> dS(dSSize, AT_, "dS");
#ifdef _MB_DEBUG_
  ScratchSpace<flt> rhoE(asize, AT_, "rhoE");
  const MInt qtSize = QThresholdOutput ? asize : 1;
  ScratchSpace<flt> QThreshold(qtSize, AT_, "QThreshold");
#endif

  MFloat tmp;
  MFloat weights[m_noCellNodes];
  if(writePointData) {
    for(MInt p = 0; p < noInternalGridPoints; p++) {
      for(MInt n = 0; n < m_gridPoints->a[p].m_noAdjacentCells; n++) {
        weights[n] = F0;
      }
      tmp = F0;
      for(MInt n = 0; n < m_gridPoints->a[p].m_noAdjacentCells; n++) {
        cellId = m_gridPoints->a[p].m_cellIds[n];
        if(a_bndryId(cellId) > -1) {
          weights[n] =
              F1
              / (sqrt(POW2(a_coordinate(cellId, 0) + m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_coordinates[0]
                           - m_gridPoints->a[p].m_coordinates[0])
                      + POW2(a_coordinate(cellId, 1) + m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_coordinates[1]
                             - m_gridPoints->a[p].m_coordinates[1])));
          tmp += weights[n];
        } else {
          weights[n] = F1
                       / (sqrt(POW2(a_coordinate(cellId, 0) - m_gridPoints->a[p].m_coordinates[0])
                               + POW2(a_coordinate(cellId, 1) - m_gridPoints->a[p].m_coordinates[1])));
          tmp += weights[n];
        }
      }
      for(MInt n = 0; n < m_gridPoints->a[p].m_noAdjacentCells; n++) {
        weights[n] /= tmp;
      }

      pressure.p[p] = (flt)F0;
      density.p[p] = (flt)F0;
      vorticity.p[p] = (flt)F0;
      Qcriterion.p[p] = (flt)F0;
      if(entropyChangeOutput) dS.p[p] = (flt)F0;
      for(MInt i = 0; i < nDim; i++) {
        velocity.p[3 * p + i] = (flt)F0;
      }
      velocity.p[3 * p + 2] = (flt)F0;
#ifdef _MB_DEBUG_
      rhoE.p[p] = (flt)F0;
      if(QThresholdOutput) QThreshold.p[p] = (flt)F0;
#endif
      for(MInt n = 0; n < m_gridPoints->a[p].m_noAdjacentCells; n++) {
        cellId = m_gridPoints->a[p].m_cellIds[n];
        pressure.p[p] += (flt)weights[n] * a_pvariable(cellId, PV->P);
        density.p[p] += (flt)weights[n] * a_pvariable(cellId, PV->RHO);
        // vorticity.p[ p ] += (flt)weights[ n ] * a_slope( cellId ,  0 ,  0 );
        vorticity.p[p] += (flt)weights[n] * qData(1, cellId);
        // Qcriterion.p[ p ] += (flt)weights[ n ] * a_slope( cellId ,  2 ,  0 );
        Qcriterion.p[p] += (flt)weights[n] * qData(0, cellId);
        if(entropyChangeOutput) dS.p[p] += (flt)weights[n] * (entropy(cellId) - m_SInfinity) / m_SInfinity;
        for(MInt i = 0; i < nDim; i++) {
          velocity.p[3 * p + i] += (flt)weights[n] * a_pvariable(cellId, PV->VV[i]);
        }
#ifdef _MB_DEBUG_
        rhoE.p[p] += (flt)weights[n] * a_variable(cellId, CV->RHO_E);
        if(QThresholdOutput) QThreshold.p[p] += (flt)weights[n] * qData(2, cellId);
#endif
      }
    }
    for(MInt p = noInternalGridPoints; p < noPoints; p++) {
      for(MInt n = 0; n < m_gridPoints->a[p].m_noAdjacentCells; n++) {
        weights[n] = F0;
      }
      tmp = F0;
      for(MInt n = 0; n < m_gridPoints->a[p].m_noAdjacentCells; n++) {
        cellId = m_gridPoints->a[p].m_cellIds[n];
        if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
        if(a_bndryId(cellId) < 0) continue;
        weights[n] = F1
                     / (sqrt(POW2(m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_srfcs[0]->m_coordinates[0]
                                  - m_gridPoints->a[p].m_coordinates[0])
                             + POW2(m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_srfcs[0]->m_coordinates[1]
                                    - m_gridPoints->a[p].m_coordinates[1])));
        tmp += weights[n];
      }
      for(MInt n = 0; n < m_gridPoints->a[p].m_noAdjacentCells; n++) {
        weights[n] /= tmp;
      }
      pressure.p[p] = (flt)F0;
      density.p[p] = (flt)F0;
      vorticity.p[p] = (flt)F0;
      Qcriterion.p[p] = (flt)F0;
      if(entropyChangeOutput) dS.p[p] = (flt)F0;
      for(MInt i = 0; i < nDim; i++) {
        velocity.p[3 * p + i] = (flt)F0;
      }
      velocity.p[3 * p + 2] = F0;
#ifdef _MB_DEBUG_
      rhoE.p[p] = (flt)F0;
      if(QThresholdOutput) QThreshold.p[p] = (flt)F0;
#endif
      for(MInt n = 0; n < m_gridPoints->a[p].m_noAdjacentCells; n++) {
        cellId = m_gridPoints->a[p].m_cellIds[n];
        if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
        if(a_bndryId(cellId) < 0) continue;
        ghostCellId = m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_srfcVariables[0]->m_ghostCellId;
        if(a_bndryId(cellId) < m_noOuterBndryCells) {
          MFloat pb = F1B2 * (a_pvariable(cellId, PV->P) + a_pvariable(ghostCellId, PV->P));
          MFloat rhob = F1B2 * (a_pvariable(cellId, PV->RHO) + a_pvariable(ghostCellId, PV->RHO));
          pressure.p[p] += (flt)weights[n] * pb;
          density.p[p] += (flt)weights[n] * rhob;
          vorticity.p[p] += (flt)weights[n] * qData(1, cellId);  // a_slope( cellId ,  0 ,  0 );
          Qcriterion.p[p] += (flt)weights[n] * qData(0, cellId); // a_slope( cellId ,  2 ,  0 );
          MFloat SG = sysEqn().entropy(pb, rhob);
          if(entropyChangeOutput) dS.p[p] += (flt)weights[n] * (SG - m_SInfinity) / m_SInfinity;
          for(MInt i = 0; i < nDim; i++) {
            velocity.p[3 * p + i] +=
                (flt)weights[n] * F1B2 * (a_pvariable(cellId, PV->VV[i]) + a_pvariable(ghostCellId, PV->VV[i]));
          }
#ifdef _MB_DEBUG_
          rhoE.p[p] += (flt)weights[n] * a_variable(cellId, CV->RHO_E);
          if(QThresholdOutput) QThreshold.p[p] += (flt)weights[n] * qData(2, cellId);
#endif
        } else {
          MInt bndryId = a_bndryId(cellId);
          pressure.p[p] += (flt)weights[n] * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->P];
          density.p[p] += (flt)weights[n] * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->RHO];
          vorticity.p[p] += (flt)weights[n] * qData(1, cellId);  // a_slope( cellId ,  0 ,  0 );
          Qcriterion.p[p] += (flt)weights[n] * qData(0, cellId); // a_slope( cellId ,  2 ,  0 );
          MFloat SG = sysEqn().entropy(m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->P],
                                       m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->RHO]);
          if(entropyChangeOutput) dS.p[p] += (flt)weights[n] * (SG - m_SInfinity) / m_SInfinity;
          for(MInt i = 0; i < nDim; i++) {
            velocity.p[3 * p + i] +=
                (flt)weights[n] * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->VV[i]];
          }
#ifdef _MB_DEBUG_
          rhoE.p[p] += (flt)weights[n] * a_variable(cellId, CV->RHO_E);
          if(QThresholdOutput) QThreshold.p[p] += (flt)weights[n] * qData(2, cellId);
#endif
        }
      }
    }
  } else {
    for(MInt c = 0; c < noExtractedCells; c++) {
      cellId = m_extractedCells->a[c].m_cellId;
      pressure.p[c] = (flt)a_pvariable(cellId, PV->P);
      density.p[c] = (flt)a_pvariable(cellId, PV->RHO);
      vorticity.p[c] = (flt)qData(1, cellId);  // a_slope( cellId ,  0 ,  0 ) ;
      Qcriterion.p[c] = (flt)qData(0, cellId); // a_slope( cellId ,  2 ,  0 ) ;
      if(entropyChangeOutput) dS.p[c] = (flt)(entropy(cellId) - m_SInfinity) / m_SInfinity;
      for(MInt i = 0; i < nDim; i++) {
        velocity.p[3 * c + i] = (flt)a_pvariable(cellId, PV->VV[i]);
      }
      velocity.p[3 * c + 2] = (flt)F0;
#ifdef _MB_DEBUG_
      rhoE.p[c] = (flt)a_variable(cellId, CV->RHO_E);
      if(QThresholdOutput) QThreshold.p[c] = (flt)qData(2, cellId);
#endif
    }
  }

  // WRITE
  if(domainId() == 0) {
    cerr << "write...";
  }

  ofstream ofl;
  ofl.open(fileName.c_str(), ios_base::out | ios_base::trunc);
  if(ofl.is_open() && ofl.good()) {
    offset = 0;

    // VTKFile
    ofl << "<?xml version=\"1.0\"?>" << endl;
    ofl << "<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">" << endl;
    ofl << "<UnstructuredGrid>" << endl;


    // FieldData
    ofl << "<FieldData>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"time\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_time << "\" RangeMax=\"" << m_time << "\">" << endl;
    ofl << m_time << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType
        << "\" Name=\"physicalTime\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\"" << m_physicalTime
        << "\" RangeMax=\"" << m_physicalTime << "\">" << endl;
    ofl << m_physicalTime << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"timeStep\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << timeStep() << "\" RangeMax=\"" << timeStep() << "\">" << endl;
    ofl << timeStep() << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << iDataType
        << "\" Name=\"globalTimeStep\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\"" << globalTimeStep
        << "\" RangeMax=\"" << globalTimeStep << "\">" << endl;
    ofl << globalTimeStep << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"Ma\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_Ma << "\" RangeMax=\"" << m_Ma << "\">" << endl;
    ofl << m_Ma << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"Re\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_Re << "\" RangeMax=\"" << m_Re << "\">" << endl;
    ofl << m_Re << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"Pr\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_Pr << "\" RangeMax=\"" << m_Pr << "\">" << endl;
    ofl << m_Pr << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"gamma\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_gamma << "\" RangeMax=\"" << m_gamma << "\">" << endl;
    ofl << m_gamma << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"CFL\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_cfl << "\" RangeMax=\"" << m_cfl << "\">" << endl;
    ofl << m_cfl << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"uInf\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_UInfinity << "\" RangeMax=\"" << m_UInfinity << "\">" << endl;
    ofl << m_UInfinity << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"vInf\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_VInfinity << "\" RangeMax=\"" << m_VInfinity << "\">" << endl;
    ofl << m_VInfinity << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"pInf\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_PInfinity << "\" RangeMax=\"" << m_PInfinity << "\">" << endl;
    ofl << m_PInfinity << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"rhoInf\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_rhoInfinity << "\" RangeMax=\"" << m_rhoInfinity << "\">" << endl;
    ofl << m_rhoInfinity << endl;
    ofl << "</DataArray>" << endl;
    ofl << "</FieldData>" << endl;

    // Dimensions
    ofl << "<Piece NumberOfPoints=\"" << noPoints << "\" NumberOfCells=\"" << noCells << "\">" << endl;

    // Points
    ofl << "<Points>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" NumberOfComponents=\"3\" format=\"appended\" offset=\"" << offset
        << "\"/>" << endl;
    offset += points.m_memsize + sizeof(MUint);
    ofl << "</Points>" << endl;

    //  Cells
    ofl << "<Cells>" << endl;
    ofl << "<DataArray type=\"" << uIDataType << "\" Name=\"connectivity\" format=\"appended\" offset=\"" << offset
        << "\"/>" << endl;
    offset += connectivity.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << uIDataType << "\" Name=\"offsets\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += offsets.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << uI8DataType << "\" Name=\"types\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += types.m_memsize + sizeof(MUint);

    ofl << "</Cells>" << endl;

    //  CellData/PointData
    ofl << "<CellData Scalars=\"scalars\">" << endl;

    ofl << "<DataArray type=\"" << iDataType << "\" Name=\"cellIds\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += cellIds.m_memsize + sizeof(MUint);

    if(m_haloCellOutput) {
      ofl << "<DataArray type=\"" << uI8DataType << "\" Name=\"vtkGhostLevels\" format=\"appended\" offset=\"" << offset
          << "\"/>" << endl;
      offset += vtkGhostLevels.m_memsize + sizeof(MUint);
    }

#ifdef _MB_DEBUG_

    ofl << "<DataArray type=\"" << iDataType << "\" Name=\"bndryIds\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += bndryIds.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << dataType64 << "\" Name=\"drho_dt\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += drho_dt.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << dataType64 << "\" Name=\"drhou_dt\" format=\"appended\" offset=\"" << offset
        << "\"/>" << endl;
    offset += drhou_dt.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"levelSetFunction\" format=\"appended\" offset=\"" << offset
        << "\"/>" << endl;
    offset += levelSetFunction.m_memsize + sizeof(MUint);

    if(sensorOutput) {
      ofl << "<DataArray type=\"" << dataType << "\" Name=\"tauC\" format=\"appended\" offset=\"" << offset << "\"/>"
          << endl;
      offset += tauC.m_memsize + sizeof(MUint);
      ofl << "<DataArray type=\"" << dataType << "\" Name=\"tauE\" format=\"appended\" offset=\"" << offset << "\"/>"
          << endl;
      offset += tauE.m_memsize + sizeof(MUint);
    }

#endif

    if(writePointData) {
      ofl << "</CellData>" << endl;
      ofl << "<PointData Scalars=\"scalars\">" << endl;
    }

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"pressure\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += pressure.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << dataType
        << "\" Name=\"velocity\" NumberOfComponents=\"3\" format=\"appended\" offset=\"" << offset << "\"/>" << endl;
    offset += velocity.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"density\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += density.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"vorticity\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += vorticity.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"Qcriterion\" format=\"appended\" offset=\"" << offset
        << "\"/>" << endl;
    offset += Qcriterion.m_memsize + sizeof(MUint);

    if(entropyChangeOutput) {
      ofl << "<DataArray type=\"" << dataType << "\" Name=\"dS\" format=\"appended\" offset=\"" << offset << "\"/>"
          << endl;
      offset += dS.m_memsize + sizeof(MUint);
    }

#ifdef _MB_DEBUG_

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"rhoE\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += rhoE.m_memsize + sizeof(MUint);

    if(QThresholdOutput) {
      ofl << "<DataArray type=\"" << dataType << "\" Name=\"QThreshold\" format=\"appended\" offset=\"" << offset
          << "\"/>" << endl;
      offset += QThreshold.m_memsize + sizeof(MUint);
    }

#endif
    if(writePointData) {
      ofl << "</PointData>" << endl;
    } else {
      ofl << "</CellData>" << endl;
    }

    ofl << "</Piece>" << endl;
    ofl << "</UnstructuredGrid>" << endl;


    // AppendedData
    ofl << "<AppendedData encoding=\"raw\">" << endl;
    ofl << "_";
    ofl.close();
    ofl.clear();
  } else {
    cerr << "ERROR! COULD NOT OPEN FILE " << fileName << " for writing! (1)" << endl;
  }
  ofl.open(fileName.c_str(), ios_base::out | ios_base::app | ios_base::binary);
  if(ofl.is_open() && ofl.good()) {
    // point coordinates
    uinumber = (MUint)points.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(MUint));
    ofl.write(reinterpret_cast<const char*>(points.getPointer()), uinumber);

    // connectivity
    uinumber = (MUint)connectivity.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(MUint));
    ofl.write(reinterpret_cast<const char*>(connectivity.getPointer()), uinumber);

    // offsets
    uinumber = (MUint)offsets.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(offsets.getPointer()), uinumber);

    // cell types
    uinumber = (MUint)types.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(types.getPointer()), uinumber);

    // cellIds
    uinumber = (MUint)cellIds.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(cellIds.getPointer()), uinumber);

    // vtkGhostLevels
    if(m_haloCellOutput) {
      uinumber = (MUint)vtkGhostLevels.m_memsize;
      ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
      ofl.write(reinterpret_cast<const char*>(vtkGhostLevels.getPointer()), uinumber);
    }

#ifdef _MB_DEBUG_

    // bndryIds
    uinumber = (MUint)bndryIds.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(bndryIds.getPointer()), uinumber);

    // drho_dt
    uinumber = (MUint)drho_dt.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(drho_dt.getPointer()), uinumber);

    // drhou_dt
    uinumber = (MUint)drhou_dt.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(drhou_dt.getPointer()), uinumber);

    // levelSetFunction
    uinumber = (MUint)levelSetFunction.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(levelSetFunction.getPointer()), uinumber);

    // tauC / tauE
    if(sensorOutput) {
      uinumber = (MUint)tauC.m_memsize;
      ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
      ofl.write(reinterpret_cast<const char*>(tauC.getPointer()), uinumber);
      uinumber = (MUint)tauE.m_memsize;
      ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
      ofl.write(reinterpret_cast<const char*>(tauE.getPointer()), uinumber);
    }

#endif

    // pressure
    uinumber = (MUint)pressure.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(pressure.getPointer()), uinumber);

    // velocity
    uinumber = (MUint)velocity.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(velocity.getPointer()), uinumber);

    // density
    uinumber = (MUint)density.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(density.getPointer()), uinumber);

    // vorticity
    uinumber = (MUint)vorticity.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(vorticity.getPointer()), uinumber);

    // Qcriterion
    uinumber = (MUint)Qcriterion.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(Qcriterion.getPointer()), uinumber);

    if(entropyChangeOutput) {
      // dS
      uinumber = (MUint)dS.m_memsize;
      ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
      ofl.write(reinterpret_cast<const char*>(dS.getPointer()), uinumber);
    }

#ifdef _MB_DEBUG_
    // rhoE
    uinumber = (MUint)rhoE.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(rhoE.getPointer()), uinumber);

    if(QThresholdOutput) {
      // QThreshold
      uinumber = (MUint)QThreshold.m_memsize;
      ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
      ofl.write(reinterpret_cast<const char*>(QThreshold.getPointer()), uinumber);
    }

#endif

    ofl.close();
    ofl.clear();
  } else {
    cerr << "ERROR! COULD NOT OPEN FILE " << fileName << " for writing! (2)" << endl;
  }

  ofl.open(fileName.c_str(), ios_base::out | ios_base::app);
  if(ofl.is_open() && ofl.good()) {
    ofl << endl;
    ofl << "</AppendedData>" << endl;

    ofl << "</VTKFile>" << endl;
    ofl.close();
    ofl.clear();
  } else {
    cerr << "ERROR! COULD NOT OPEN FILE " << fileName << " for writing! (3)" << endl;
  }
}


/**
 * \brief write flow variables as XML VTK
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvMbCartesianSolverXD<nDim, SysEqn>::writeVtkXmlOutput(const MString& /*fileName*/, MBool /*debugOutput*/) {}


/**
 * \brief write flow variables as XML VTK
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 2, _*>>
void FvMbCartesianSolverXD<nDim, SysEqn>::writeVtkXmlOutput_MGC(const MString& fileName) {
  TRACE();

  MInt noCells = 1;
  MInt noPoints = 1;

  MBool writePointData = false;
  writePointData = Context::getSolverProperty<MBool>("writePointData", solverId(), AT_, &writePointData);

#ifdef _MB_DEBUG_
  MBool sensorOutput = m_adaptation;
#endif
  MBool QThresholdOutput = true;
  MBool entropyChangeOutput = true;

  const MInt baseCellType = 8;
  const MInt polyCellType = 7;
  MInt cellId, ghostCellId, counter;

  const string dataType64 = "Float64";
#ifdef DOUBLE_PRECISION_OUTPUT
  const string dataType = "Float64";
#else
  const string dataType = "Float32";
#endif
  const string iDataType = "Int32";
  const string uIDataType = "UInt32";
  const string uI8DataType = "UInt8";
  const string uI16DataType = "UInt16";

  MUint uinumber;
#ifdef DOUBLE_PRECISION_OUTPUT
  MFloat fnumber;
  typedef MFloat flt;
#else
  //   float fnumber;
  typedef float flt;
#endif

  if(noDomains() == 1) {
    cerr << "extracted";
    cerr << "(" << m_extractedCells->size() << ")...";
  }

  noPoints = m_gridPoints->size();
  MInt noExtractedCells = m_extractedCells->size();
  noCells = noExtractedCells;

  // 4 node ids for each direction
  const MInt ltable[4][3] = {{2, 3}, {0, 2}, {1, 0}, {3, 1}};
  const MInt pointOrder[4] = {0, 1, 3, 2};
  const MInt dirOrder[4] = {2, 1, 3, 0};
  const MInt reverseDir[4] = {1, 0, 3, 2};

  MInt centerId;

  ScratchSpace<MInt> cellTypes(noExtractedCells, AT_, "cellTypes");
  ScratchSpace<MInt> polyIds(noExtractedCells, AT_, "polyIds");
  ScratchSpace<MInt> reverseMapping(a_noCells(), AT_, "reverseMapping");
  ScratchSpace<MInt> cutPointIds(2 * m_noDirs * m_fvBndryCnd->m_bndryCells->size(), AT_, "cutPointIds");

  MInt noPolyCells;

  // integrity check 1
  for(MInt c = 0; c < noExtractedCells; c++) {
    cellId = m_extractedCells->a[c].m_cellId;
    for(MInt k = 0; k < m_noCellNodes; k++) {
      MInt pid = m_extractedCells->a[c].m_pointIds[k];
      if(pid < 0 || pid >= noPoints) {
        mTerm(1, AT_,
              "Error A in FvMbSolver2D::writeVtkXmlOutput_MGC(..). Quit. " + to_string(cellId) + " " + to_string(k)
                  + " " + to_string(pid));
      }
    }
  }

  for(MInt i = 0; i < 2 * m_noDirs * m_fvBndryCnd->m_bndryCells->size(); i++) {
    cutPointIds.p[i] = -1;
  }

  if(noDomains() == 1) {
    cerr << "prepare...";
  }
  for(MInt c = 0; c < a_noCells(); c++) {
    reverseMapping.p[c] = -1;
  }
  for(MInt c = 0; c < noExtractedCells; c++) {
    reverseMapping.p[m_extractedCells->a[c].m_cellId] = c;
  }

  MBool isPolyCell;
  noPolyCells = 0;

  for(MInt c = 0; c < noExtractedCells; c++) {
    cellId = m_extractedCells->a[c].m_cellId;
    cellTypes.p[c] = baseCellType;
    polyIds.p[c] = -1;
    isPolyCell = false;
    if(a_bndryId(cellId) > -1) {
      isPolyCell = true;
    } else {
      for(MInt i = 0; i < m_noDirs; i++) {
        if(checkNeighborActive(cellId, i) && a_hasNeighbor(cellId, i) > 0) {
          if(c_noChildren(c_neighborId(cellId, i)) > 0) {
            isPolyCell = true;
            MInt nghbrId = c_neighborId(cellId, i);
            if(nghbrId < 0) continue;
            for(MInt j = 0; j < m_noCellNodes; j++) {
              MInt childId = c_childId(nghbrId, j);
              if(reverseMapping.p[childId] < 0) {
                isPolyCell = false;
              }
            }
          }
        }
      }
    }
    if(isPolyCell) {
      cellTypes.p[c] = polyCellType;
      polyIds.p[c] = noPolyCells;
      noPolyCells++;
    }
  }

  MBool isPolyFace;
  MInt eCell, nghbrId;
  const MInt maxNoExtraPoints = 8;
  const MInt maxNoPolyCells = noPolyCells;
  ScratchSpace<MInt> polyCellLink(maxNoPolyCells, AT_, "polyCellLink");
  ScratchSpace<MInt> extraPoints(maxNoPolyCells * maxNoExtraPoints, AT_, "extraPoints");
  ScratchSpace<MInt> noExtraPoints(maxNoPolyCells, AT_, "noExtraPoints");
  ScratchSpace<MInt> noInternalPoints(maxNoPolyCells, AT_, "noInternalPoints");
  MInt offset, pointCount;

  for(MInt c = 0; c < noExtractedCells; c++) {
    if(cellTypes.p[c] == polyCellType) {
      polyCellLink.p[polyIds.p[c]] = c;
    }
  }


  const MInt noInternalGridPoints = m_gridPoints->size();
  const MInt maxPointsXD = 12;

  for(MInt pc = 0; pc < noPolyCells; pc++) {
    eCell = polyCellLink.p[pc];
    cellId = m_extractedCells->a[eCell].m_cellId;
    noInternalPoints.p[pc] = m_noCellNodes;
    noExtraPoints.p[pc] = 0;

    // a) cut cells at the boundary
    if(a_bndryId(cellId) > -1) {
      if(a_bndryId(cellId) < m_noOuterBndryCells) {
        MInt bndryId = a_bndryId(cellId);

        noInternalPoints.p[pc] = 0;

        for(MInt i = 0; i < m_noDirs; i++) {
          MInt p = pointOrder[i];
          MInt dir = dirOrder[i];

          // 0. determine internal vertices
          if(!m_pointIsInside[bndryId][IDX_LSSETMB(p, 0)]) {
            extraPoints.p[pc * maxNoExtraPoints + noExtraPoints.p[pc]] = m_extractedCells->a[eCell].m_pointIds[p];
            noExtraPoints.p[pc]++;
          }

          // 1. add cut points
          for(MInt cp = 0; cp < m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cp++) {
            if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cp] == dir) {
              MInt gridPointId = -1;
              if(checkNeighborActive(cellId, dir) && a_hasNeighbor(cellId, dir) > 0) {
                if(a_bndryId(c_neighborId(cellId, dir)) > -1) {
                  gridPointId = cutPointIds.p[m_noDirs * a_bndryId(c_neighborId(cellId, dir)) + reverseDir[dir]];
                  if(gridPointId > -1) {
                    m_gridPoints->a[gridPointId].m_cellIds[m_gridPoints->a[gridPointId].m_noAdjacentCells] = cellId;
                    m_gridPoints->a[gridPointId].m_noAdjacentCells++;
                  }
                }
              }
              if(gridPointId >= noPoints) {
                mTerm(1, AT_, "Error 0 in FvMbSolver3D::writeVtkXmlOutput(..). Quit.");
              }
              if(gridPointId < 0) {
                gridPointId = m_gridPoints->size();
                m_gridPoints->append();
                noPoints++;
                m_gridPoints->a[gridPointId].m_noAdjacentCells = 1;
                m_gridPoints->a[gridPointId].m_cellIds[0] = cellId;
                for(MInt j = 0; j < nDim; j++) {
                  m_gridPoints->a[gridPointId].m_coordinates[j] =
                      m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_srfcs[0]->m_cutCoordinates[cp][j];
                }
              }
              cutPointIds.p[m_noDirs * bndryId + dir] = gridPointId;

              extraPoints.p[pc * maxNoExtraPoints + noExtraPoints.p[pc]] = gridPointId;
              noExtraPoints.p[pc]++;
            }
          }
        }
      } else {
        MInt bndryId = a_bndryId(cellId);
        noInternalPoints.p[pc] = 0;
        for(MInt f = 0; f < m_noCutCellFaces[bndryId]; f++) {
          for(MInt fp = 0; fp < m_noCutFacePoints[bndryId][f]; fp++) {
            MInt point = m_cutFacePointIds[bndryId][maxPointsXD * f + fp];
            if(point < m_noCellNodes) { // is grid point
              extraPoints.p[pc * maxNoExtraPoints + noExtraPoints.p[pc]] = m_extractedCells->a[eCell].m_pointIds[point];
              noExtraPoints.p[pc]++;
            } else { // is cut point
              point -= m_noCellNodes;
              // first try: just add cut point!
              MInt gridPointId = m_gridPoints->size();
              m_gridPoints->append();
              noPoints++;
              m_gridPoints->a[gridPointId].m_noAdjacentCells = 1;
              m_gridPoints->a[gridPointId].m_cellIds[0] = cellId;

              // find right cut point:
              MInt previousCutPoints = -1;
              MInt pointFound = false;
              for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
                for(MInt cp = 0; cp < m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_noCutPoints; cp++) {
                  previousCutPoints++;
                  if(previousCutPoints == point) {
                    for(MInt j = 0; j < nDim; j++) {
                      m_gridPoints->a[gridPointId].m_coordinates[j] =
                          m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_srfcs[srfc]->m_cutCoordinates[cp][j];
                    }
                    pointFound = true;
                    break;
                  }
                }
                if(pointFound) break;
              }
              extraPoints.p[pc * maxNoExtraPoints + noExtraPoints.p[pc]] = gridPointId;
              noExtraPoints.p[pc]++;
            }
          }
        }
      }
    }
    // b) cells at fine/coarse mesh interfaces
    else {
      noInternalPoints.p[pc] = 0;

      for(MInt i = 0; i < m_noDirs; i++) {
        MInt p = pointOrder[i];
        MInt dir = dirOrder[i];

        extraPoints.p[pc * maxNoExtraPoints + noExtraPoints.p[pc]] = m_extractedCells->a[eCell].m_pointIds[p];
        noExtraPoints.p[pc]++;

        isPolyFace = false;
        if(checkNeighborActive(cellId, dir) && a_hasNeighbor(cellId, dir) > 0) {
          nghbrId = c_neighborId(cellId, dir);
          if(c_noChildren(nghbrId) > 0) {
            isPolyFace = true;
            for(MInt child = 0; child < m_noCellNodes; child++) {
              if(!childCode[dir][child]) continue;
              MInt childId = c_childId(nghbrId, child);
              if(childId < 0) {
                isPolyFace = false;
              }
              if(reverseMapping.p[childId] < 0) {
                isPolyFace = false;
              }
            }
          }
        }

        if(isPolyFace) {
          // store four faces (polygon numbering!)
          nghbrId = reverseMapping.p[c_childId(c_neighborId(cellId, dir), ltable[i][0])];
          if(nghbrId < 0) {
            cerr << "=== VTK XML ERROR LOG === " << domainId() << endl;
            cerr << endl
                 << cellId << " " << a_bndryId(cellId) << " " << c_childId(c_neighborId(cellId, dir), ltable[i][0])
                 << endl;
            cerr << endl << a_noCells() << " " << dir << " " << ltable[i][0] << endl;
            cerr << a_levelSetValuesMb(cellId, 0) << " " << a_hasProperty(cellId, SolverCell::IsInactive) << endl;
            cerr << "props: " << a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) << " " << a_isHalo(cellId) << " "
                 << a_hasProperty(cellId, SolverCell::IsNotGradient) << " "
                 << a_hasProperty(c_neighborId(cellId, dir), SolverCell::IsOnCurrentMGLevel) << " "
                 << a_hasProperty(c_childId(c_neighborId(cellId, dir), ltable[i][0]), SolverCell::IsOnCurrentMGLevel)
                 << endl;
            cerr << endl
                 << cellId << " " << c_neighborId(cellId, dir) << " "
                 << c_childId(c_neighborId(cellId, dir), ltable[i][0]) << " / " << a_level(cellId) << " "
                 << a_level(c_neighborId(cellId, dir)) << " "
                 << a_level(c_childId(c_neighborId(cellId, dir), ltable[i][0])) << " / " << c_noChildren(cellId) << " "
                 << c_noChildren(c_neighborId(cellId, dir)) << " "
                 << c_noChildren(c_childId(c_neighborId(cellId, dir), ltable[i][0])) << endl;
            cerr << c_childId(c_neighborId(cellId, dir), 0) << " " << c_childId(c_neighborId(cellId, dir), 1) << " "
                 << c_childId(c_neighborId(cellId, dir), 2) << " " << c_childId(c_neighborId(cellId, dir), 3) << endl;
            cerr << a_coordinate(c_neighborId(cellId, dir), 0) << " " << a_coordinate(c_neighborId(cellId, dir), 1)
                 << endl;
            for(MInt j = 0; j < m_noCellNodes; j++) {
              cerr << a_hasProperty(c_childId(c_neighborId(cellId, dir), j), SolverCell::IsInactive) << " ";
            }
            cerr << endl;
            for(MInt j = 0; j < m_noCellNodes; j++) {
              cerr << a_hasProperty(c_childId(c_neighborId(cellId, dir), j), SolverCell::IsOnCurrentMGLevel) << " ";
            }
            cerr << endl;
            mTerm(1, AT_, "Error 1 in FvMbSolver2D::writeVtkXmlOutput_MGC(..). Quit.");
          }
          centerId = m_extractedCells->a[nghbrId].m_pointIds[ltable[i][1]];
          extraPoints.p[pc * maxNoExtraPoints + noExtraPoints.p[pc]] = centerId;
          noExtraPoints.p[pc]++;

          if(m_gridPoints->a[centerId].m_noAdjacentCells < m_noCellNodes) {
            m_gridPoints->a[centerId].m_cellIds[m_gridPoints->a[centerId].m_noAdjacentCells] = cellId;
            m_gridPoints->a[centerId].m_noAdjacentCells++;
          } else {
            cerr << endl << cellId << " / ";
            for(MInt c = 0; c < m_gridPoints->a[centerId].m_noAdjacentCells; c++)
              cerr << m_gridPoints->a[centerId].m_cellIds[c] << " ";
            cerr << endl;
            mTerm(1, AT_, "Error 2 in FvMbSolver2D::writeVtkXmlOutput_MGC(..). Quit.");
          }
        }
      }
    }
  }

  pointCount = 0;
  for(MInt c = 0; c < noExtractedCells; c++) {
    MInt pc = polyIds.p[c];
    if(pc > -1) {
      pointCount += noInternalPoints.p[pc];
      pointCount += noExtraPoints.p[pc];
    } else {
      pointCount += m_noCellNodes;
    }
  }

  MInt qDataSize = 2;
  if(QThresholdOutput) qDataSize++;
  ScratchSpace<MFloat> qData(qDataSize, a_noCells(), AT_, "qData");
  MFloat gradU[2][2];
  for(MInt c = 0; c < noExtractedCells; c++) {
    cellId = m_extractedCells->a[c].m_cellId;

    for(MInt i = 0; i < nDim; i++) {
      for(MInt j = 0; j < nDim; j++) {
        gradU[i][j] = a_slope(cellId, PV->VV[i], j) * m_referenceLength / m_UInfinity;
      }
    }
    MFloat omega = F1B2 * (gradU[1][0] - gradU[0][1]);
    MFloat omega2 = POW2(omega);
    MFloat S2 = 0;
    for(MInt i = 0; i < nDim; i++) {
      for(MInt j = 0; j < nDim; j++) {
        S2 += POW2(F1B2 * (gradU[i][j] + gradU[j][i]));
      }
    }
    MFloat Q = F1B2 * (omega2 - S2);
    qData(0, cellId) = Q;
    qData(1, cellId) = omega;
    if(QThresholdOutput) qData(2, cellId) = F1B2 * ((omega2 / mMax(m_eps, S2)) - F1);
  }

  // GATHER
  if(noDomains() == 1) {
    cerr << "gather...";
  }

  // points
  ScratchSpace<flt> points(3 * noPoints, AT_, "points");
  for(MInt p = 0; p < noPoints; p++) {
    for(MInt i = 0; i < nDim; i++) {
      points.p[3 * p + i] = (flt)m_gridPoints->a[p].m_coordinates[i];
    }
    points.p[3 * p + 2] = (flt)F0;
  }

  // connectivity
  ScratchSpace<MUint> connectivity(pointCount, AT_, "connectivity");
  counter = 0;
  for(MInt c = 0; c < noExtractedCells; c++) {
    MInt pc = polyIds.p[c];
    if(pc > -1) {
      for(MInt p = 0; p < noExtraPoints.p[pc]; p++) {
        connectivity.p[counter] = (MUint)extraPoints.p[pc * maxNoExtraPoints + p];
        counter++;
      }
    } else {
      for(MInt p = 0; p < m_noCellNodes; p++) {
        connectivity.p[counter] = (MUint)m_extractedCells->a[c].m_pointIds[p];
        counter++;
      }
    }
  }

  if(counter != pointCount) {
    mTerm(1, AT_, "E1");
  }

  // offsets
  ScratchSpace<MUint> offsets(noCells, AT_, "offsets");
  counter = 0;
  for(MInt c = 0; c < noExtractedCells; c++) {
    MInt pc = polyIds.p[c];
    if(pc > -1)
      counter += noInternalPoints.p[pc] + noExtraPoints.p[pc];
    else
      counter += m_noCellNodes;

    offsets.p[c] = (MUint)counter;
  }

  // types
  ScratchSpace<unsigned char> types(noCells, AT_, "types");
  for(MInt c = 0; c < noExtractedCells; c++) {
    types.p[c] = (unsigned char)cellTypes.p[c];
  }

  // cellIds
  ScratchSpace<MInt> cellIds(noCells, AT_, "cellIds");
  for(MInt c = 0; c < noExtractedCells; c++) {
    cellIds.p[c] = c_globalId(m_extractedCells->a[c].m_cellId);
  }

  // vtkGhostLevels
  const MInt noCh = (m_haloCellOutput) ? noCells : 1;
  ScratchSpace<unsigned char> vtkGhostLevels(noCh, AT_, "vtkGhostLevels");
  if(m_haloCellOutput) {
    for(MInt c = 0; c < noExtractedCells; c++) {
      vtkGhostLevels.p[c] = (unsigned char)0;
      if(a_isHalo(m_extractedCells->a[c].m_cellId)) vtkGhostLevels.p[c] = (unsigned char)1;
      if(a_hasProperty(m_extractedCells->a[c].m_cellId, SolverCell::IsNotGradient))
        vtkGhostLevels.p[c] = (unsigned char)2;
    }
  }

#ifdef _MB_DEBUG_

  // bndryIds
  ScratchSpace<MInt> bndryIds(noCells, AT_, "bndryIds");
  for(MInt c = 0; c < noExtractedCells; c++) {
    bndryIds.p[c] = a_bndryId(m_extractedCells->a[c].m_cellId);
    if(bndryIds.p[c] < 0 && a_hasProperty(m_extractedCells->a[c].m_cellId, SolverCell::IsInactive)) bndryIds.p[c] = -3;
  }

  // drho_dt
  ScratchSpace<MFloat> drho_dt(noCells, AT_, "drho_dt");
  for(MInt c = 0; c < noExtractedCells; c++) {
    drho_dt.p[c] =
        a_FcellVolume(m_extractedCells->a[c].m_cellId) * a_rightHandSide(m_extractedCells->a[c].m_cellId, CV->RHO);
  }

  // drhou_dt
  ScratchSpace<MFloat> drhou_dt(noCells, AT_, "drhou_dt");
  for(MInt c = 0; c < noExtractedCells; c++) {
    drhou_dt.p[c] =
        a_FcellVolume(m_extractedCells->a[c].m_cellId) * a_rightHandSide(m_extractedCells->a[c].m_cellId, CV->RHO_U);
  }

  // levelSetFunction
  ScratchSpace<flt> levelSetFunction(noCells, AT_, "levelSetFunction");
  for(MInt c = 0; c < noExtractedCells; c++) {
    levelSetFunction.p[c] = (flt)a_levelSetValuesMb(m_extractedCells->a[c].m_cellId, 0);
  }

  // volume
  ScratchSpace<flt> volume(noCells, AT_, "volume");
  for(MInt c = 0; c < noExtractedCells; c++) {
    volume.p[c] = (flt)a_cellVolume(m_extractedCells->a[c).m_cellId]
                  / grid().gridCellVolume(a_level(m_extractedCells->a[c].m_cellId));
  }

  // spongeFac
  ScratchSpace<flt> spongeFac(noCells, AT_, "spongeFac");
  for(MInt c = 0; c < noExtractedCells; c++) {
    spongeFac.p[c] = (flt)a_spongeFactor(m_extractedCells->a[c].m_cellId);
  }

  const MInt sensorSize = sensorOutput ? noCells : 1;
  ScratchSpace<flt> tauC(sensorSize, AT_, "tauC");
  ScratchSpace<flt> tauE(sensorSize, AT_, "tauE");
  if(sensorOutput) {
    for(MInt c = 0; c < noExtractedCells; c++) {
      tauC.p[c] = (flt)m_tauC[m_extractedCells->a[c].m_cellId];
      tauE.p[c] = (flt)m_tauE[m_extractedCells->a[c].m_cellId];
    }
  }
#endif

  // additional cellData/pointData
  MInt asize = noCells;
  if(writePointData) {
    asize = noPoints;
  }
  ScratchSpace<flt> pressure(asize, AT_, "pressure");
  ScratchSpace<flt> velocity(3 * asize, AT_, "velocity");
  ScratchSpace<flt> density(asize, AT_, "density");
  ScratchSpace<flt> vorticity(asize, AT_, "vorticity");
  ScratchSpace<flt> Qcriterion(asize, AT_, "Qcriterion");
  const MInt dSSize = entropyChangeOutput ? asize : 1;
  ScratchSpace<flt> dS(dSSize, AT_, "dS");
#ifdef _MB_DEBUG_
  ScratchSpace<flt> rhoE(asize, AT_, "rhoE");
  const MInt qtSize = QThresholdOutput ? asize : 1;
  ScratchSpace<flt> QThreshold(qtSize, AT_, "QThreshold");
#endif

  MFloat tmp;
  MFloat weights[m_noCellNodes];
  if(writePointData) {
    for(MInt p = 0; p < noInternalGridPoints; p++) {
      for(MInt n = 0; n < m_gridPoints->a[p].m_noAdjacentCells; n++) {
        weights[n] = F0;
      }
      tmp = F0;
      for(MInt n = 0; n < m_gridPoints->a[p].m_noAdjacentCells; n++) {
        cellId = m_gridPoints->a[p].m_cellIds[n];
        if(a_bndryId(cellId) > -1) {
          weights[n] =
              F1
              / (sqrt(POW2(a_coordinate(cellId, 0) + m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_coordinates[0]
                           - m_gridPoints->a[p].m_coordinates[0])
                      + POW2(a_coordinate(cellId, 1) + m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_coordinates[1]
                             - m_gridPoints->a[p].m_coordinates[1])));
          tmp += weights[n];
        } else {
          weights[n] = F1
                       / (sqrt(POW2(a_coordinate(cellId, 0) - m_gridPoints->a[p].m_coordinates[0])
                               + POW2(a_coordinate(cellId, 1) - m_gridPoints->a[p].m_coordinates[1])));
          tmp += weights[n];
        }
      }
      for(MInt n = 0; n < m_gridPoints->a[p].m_noAdjacentCells; n++) {
        weights[n] /= tmp;
      }

      pressure.p[p] = (flt)F0;
      density.p[p] = (flt)F0;
      vorticity.p[p] = (flt)F0;
      Qcriterion.p[p] = (flt)F0;
      if(entropyChangeOutput) dS.p[p] = (flt)F0;
      for(MInt i = 0; i < nDim; i++) {
        velocity.p[3 * p + i] = (flt)F0;
      }
      velocity.p[3 * p + 2] = (flt)F0;
#ifdef _MB_DEBUG_
      rhoE.p[p] = (flt)F0;
      if(QThresholdOutput) QThreshold.p[p] = (flt)F0;
#endif
      for(MInt n = 0; n < m_gridPoints->a[p].m_noAdjacentCells; n++) {
        cellId = m_gridPoints->a[p].m_cellIds[n];
        pressure.p[p] += (flt)weights[n] * a_pvariable(cellId, PV->P);
        density.p[p] += (flt)weights[n] * a_pvariable(cellId, PV->RHO);
        vorticity.p[p] += (flt)weights[n] * qData(1, cellId);  // a_slope( cellId ,  0 ,  0 );
        Qcriterion.p[p] += (flt)weights[n] * qData(0, cellId); // a_slope( cellId ,  2 ,  0 );
        if(entropyChangeOutput) dS.p[p] += (flt)weights[n] * (entropy(cellId) - m_SInfinity) / m_SInfinity;
        for(MInt i = 0; i < nDim; i++) {
          velocity.p[3 * p + i] += (flt)weights[n] * a_pvariable(cellId, PV->VV[i]);
        }
#ifdef _MB_DEBUG_
        rhoE.p[p] += (flt)weights[n] * a_variable(cellId, CV->RHO_E);
        if(QThresholdOutput) QThreshold.p[p] += (flt)weights[n] * qData(2, cellId);
#endif
      }
    }
    for(MInt p = noInternalGridPoints; p < noPoints; p++) {
      for(MInt n = 0; n < m_gridPoints->a[p].m_noAdjacentCells; n++) {
        weights[n] = F0;
      }
      tmp = F0;
      for(MInt n = 0; n < m_gridPoints->a[p].m_noAdjacentCells; n++) {
        cellId = m_gridPoints->a[p].m_cellIds[n];
        if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
        if(a_bndryId(cellId) < 0) continue;
        weights[n] = F1
                     / (sqrt(POW2(m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_srfcs[0]->m_coordinates[0]
                                  - m_gridPoints->a[p].m_coordinates[0])
                             + POW2(m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_srfcs[0]->m_coordinates[1]
                                    - m_gridPoints->a[p].m_coordinates[1])));
        tmp += weights[n];
      }
      for(MInt n = 0; n < m_gridPoints->a[p].m_noAdjacentCells; n++) {
        weights[n] /= tmp;
      }
      pressure.p[p] = (flt)F0;
      density.p[p] = (flt)F0;
      vorticity.p[p] = (flt)F0;
      Qcriterion.p[p] = (flt)F0;
      if(entropyChangeOutput) dS.p[p] = (flt)F0;
      for(MInt i = 0; i < nDim; i++) {
        velocity.p[3 * p + i] = (flt)F0;
      }
      velocity.p[3 * p + 2] = F0;
#ifdef _MB_DEBUG_
      rhoE.p[p] = (flt)F0;
      if(QThresholdOutput) QThreshold.p[p] = (flt)F0;
#endif
      for(MInt n = 0; n < m_gridPoints->a[p].m_noAdjacentCells; n++) {
        cellId = m_gridPoints->a[p].m_cellIds[n];
        if(a_hasProperty(cellId, SolverCell::IsInactive)) continue;
        if(a_bndryId(cellId) < 0) continue;
        ghostCellId = m_fvBndryCnd->m_bndryCells->a[a_bndryId(cellId)].m_srfcVariables[0]->m_ghostCellId;
        if(a_bndryId(cellId) < m_noOuterBndryCells) {
          MFloat pb = F1B2 * (a_pvariable(cellId, PV->P) + a_pvariable(ghostCellId, PV->P));
          MFloat rhob = F1B2 * (a_pvariable(cellId, PV->RHO) + a_pvariable(ghostCellId, PV->RHO));
          pressure.p[p] += (flt)weights[n] * pb;
          density.p[p] += (flt)weights[n] * rhob;
          vorticity.p[p] += (flt)weights[n] * qData(1, cellId);  // a_slope( cellId ,  0 ,  0 );
          Qcriterion.p[p] += (flt)weights[n] * qData(0, cellId); // a_slope( cellId ,  2 ,  0 );
          MFloat SG = sysEqn().entropy(pb, rhob);
          if(entropyChangeOutput) dS.p[p] += (flt)weights[n] * (SG - m_SInfinity) / m_SInfinity;
          for(MInt i = 0; i < nDim; i++) {
            velocity.p[3 * p + i] +=
                (flt)weights[n] * F1B2 * (a_pvariable(cellId, PV->VV[i]) + a_pvariable(ghostCellId, PV->VV[i]));
          }
#ifdef _MB_DEBUG_
          rhoE.p[p] += (flt)weights[n] * a_variable(cellId, CV->RHO_E);
          if(QThresholdOutput) QThreshold.p[p] += (flt)weights[n] * qData(2, cellId);
#endif
        } else {
          MInt bndryId = a_bndryId(cellId);
          pressure.p[p] += (flt)weights[n] * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->P];
          density.p[p] += (flt)weights[n] * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->RHO];
          vorticity.p[p] += (flt)weights[n] * qData(1, cellId);  // a_slope( cellId ,  0 ,  0 );
          Qcriterion.p[p] += (flt)weights[n] * qData(0, cellId); // a_slope( cellId ,  2 ,  0 );
          MFloat SG = sysEqn().entropy(m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->P],
                                       m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->RHO]);
          if(entropyChangeOutput) dS.p[p] += (flt)weights[n] * (SG - m_SInfinity) / m_SInfinity;
          for(MInt i = 0; i < nDim; i++) {
            velocity.p[3 * p + i] +=
                (flt)weights[n] * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[0]->m_primVars[PV->VV[i]];
          }
#ifdef _MB_DEBUG_
          rhoE.p[p] += (flt)weights[n] * a_variable(cellId, CV->RHO_E);
          if(QThresholdOutput) QThreshold.p[p] += (flt)weights[n] * qData(2, cellId);
#endif
        }
      }
    }
  } else {
    for(MInt c = 0; c < noExtractedCells; c++) {
      cellId = m_extractedCells->a[c].m_cellId;
      pressure.p[c] = (flt)a_pvariable(cellId, PV->P);
      density.p[c] = (flt)a_pvariable(cellId, PV->RHO);
      vorticity.p[c] = (flt)qData(1, cellId);  // a_slope( cellId ,  0 ,  0 ) ;
      Qcriterion.p[c] = (flt)qData(0, cellId); // a_slope( cellId ,  2 ,  0 ) ;
      if(entropyChangeOutput) dS.p[c] = (flt)(entropy(cellId) - m_SInfinity) / m_SInfinity;
      for(MInt i = 0; i < nDim; i++) {
        velocity.p[3 * c + i] = (flt)a_pvariable(cellId, PV->VV[i]);
      }
      velocity.p[3 * c + 2] = (flt)F0;
#ifdef _MB_DEBUG_
      rhoE.p[c] = (flt)a_variable(cellId, CV->RHO_E);
      if(QThresholdOutput) QThreshold.p[c] = (flt)qData(2, cellId);
#endif
    }
  }

  // WRITE
  if(domainId() == 0) {
    cerr << "write...";
  }

  ofstream ofl;
  ofl.open(fileName.c_str(), ios_base::out | ios_base::trunc);
  if(ofl.is_open() && ofl.good()) {
    offset = 0;

    // VTKFile
    ofl << "<?xml version=\"1.0\"?>" << endl;
    ofl << "<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">" << endl;
    ofl << "<UnstructuredGrid>" << endl;

    // FieldData
    ofl << "<FieldData>" << endl;

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"time\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_time << "\" RangeMax=\"" << m_time << "\">" << endl;
    ofl << m_time << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType
        << "\" Name=\"physicalTime\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\"" << m_physicalTime
        << "\" RangeMax=\"" << m_physicalTime << "\">" << endl;
    ofl << m_physicalTime << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"timeStep\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << timeStep() << "\" RangeMax=\"" << timeStep() << "\">" << endl;
    ofl << timeStep() << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << iDataType
        << "\" Name=\"globalTimeStep\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\"" << globalTimeStep
        << "\" RangeMax=\"" << globalTimeStep << "\">" << endl;
    ofl << globalTimeStep << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"Ma\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_Ma << "\" RangeMax=\"" << m_Ma << "\">" << endl;
    ofl << m_Ma << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"Re\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_Re << "\" RangeMax=\"" << m_Re << "\">" << endl;
    ofl << m_Re << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"Pr\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_Pr << "\" RangeMax=\"" << m_Pr << "\">" << endl;
    ofl << m_Pr << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"gamma\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_gamma << "\" RangeMax=\"" << m_gamma << "\">" << endl;
    ofl << m_gamma << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"CFL\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_cfl << "\" RangeMax=\"" << m_cfl << "\">" << endl;
    ofl << m_cfl << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"uInf\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_UInfinity << "\" RangeMax=\"" << m_UInfinity << "\">" << endl;
    ofl << m_UInfinity << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"vInf\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_VInfinity << "\" RangeMax=\"" << m_VInfinity << "\">" << endl;
    ofl << m_VInfinity << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"pInf\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_PInfinity << "\" RangeMax=\"" << m_PInfinity << "\">" << endl;
    ofl << m_PInfinity << endl;
    ofl << "</DataArray>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"rhoInf\" format=\"ascii\" NumberOfTuples=\"1\" RangeMin=\""
        << m_rhoInfinity << "\" RangeMax=\"" << m_rhoInfinity << "\">" << endl;
    ofl << m_rhoInfinity << endl;
    ofl << "</DataArray>" << endl;
    ofl << "</FieldData>" << endl;

    // Dimensions
    ofl << "<Piece NumberOfPoints=\"" << noPoints << "\" NumberOfCells=\"" << noCells << "\">" << endl;

    // Points
    ofl << "<Points>" << endl;
    ofl << "<DataArray type=\"" << dataType << "\" NumberOfComponents=\"3\" format=\"appended\" offset=\"" << offset
        << "\"/>" << endl;
    offset += points.m_memsize + sizeof(MUint);
    ofl << "</Points>" << endl;

    // Cells
    ofl << "<Cells>" << endl;

    ofl << "<DataArray type=\"" << uIDataType << "\" Name=\"connectivity\" format=\"appended\" offset=\"" << offset
        << "\"/>" << endl;
    offset += connectivity.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << uIDataType << "\" Name=\"offsets\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += offsets.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << uI8DataType << "\" Name=\"types\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += types.m_memsize + sizeof(MUint);

    ofl << "</Cells>" << endl;

    // CellData/PointData
    ofl << "<CellData Scalars=\"scalars\">" << endl;

    ofl << "<DataArray type=\"" << iDataType << "\" Name=\"cellIds\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += cellIds.m_memsize + sizeof(MUint);

    if(m_haloCellOutput) {
      ofl << "<DataArray type=\"" << uI8DataType << "\" Name=\"vtkGhostLevels\" format=\"appended\" offset=\"" << offset
          << "\"/>" << endl;
      offset += vtkGhostLevels.m_memsize + sizeof(MUint);
    }

#ifdef _MB_DEBUG_
    ofl << "<DataArray type=\"" << iDataType << "\" Name=\"bndryIds\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += bndryIds.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << dataType64 << "\" Name=\"drho_dt\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += drho_dt.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << dataType64 << "\" Name=\"drhou_dt\" format=\"appended\" offset=\"" << offset
        << "\"/>" << endl;
    offset += drhou_dt.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"levelSetFunction\" format=\"appended\" offset=\"" << offset
        << "\"/>" << endl;
    offset += levelSetFunction.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"volume\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += volume.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"spongeFactor\" format=\"appended\" offset=\"" << offset
        << "\"/>" << endl;
    offset += spongeFac.m_memsize + sizeof(MUint);

    if(sensorOutput) {
      ofl << "<DataArray type=\"" << dataType << "\" Name=\"tauC\" format=\"appended\" offset=\"" << offset << "\"/>"
          << endl;
      offset += tauC.m_memsize + sizeof(MUint);
      ofl << "<DataArray type=\"" << dataType << "\" Name=\"tauE\" format=\"appended\" offset=\"" << offset << "\"/>"
          << endl;
      offset += tauE.m_memsize + sizeof(MUint);
    }

#endif

    if(writePointData) {
      ofl << "</CellData>" << endl;
      ofl << "<PointData Scalars=\"scalars\">" << endl;
    }

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"pressure\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += pressure.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << dataType
        << "\" Name=\"velocity\" NumberOfComponents=\"3\" format=\"appended\" offset=\"" << offset << "\"/>" << endl;
    offset += velocity.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"density\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += density.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"vorticity\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += vorticity.m_memsize + sizeof(MUint);

    ofl << "<DataArray type=\"" << dataType << "\" Name=\"Qcriterion\" format=\"appended\" offset=\"" << offset
        << "\"/>" << endl;
    offset += Qcriterion.m_memsize + sizeof(MUint);

    if(entropyChangeOutput) {
      ofl << "<DataArray type=\"" << dataType << "\" Name=\"dS\" format=\"appended\" offset=\"" << offset << "\"/>"
          << endl;
      offset += dS.m_memsize + sizeof(MUint);
    }

#ifdef _MB_DEBUG_
    ofl << "<DataArray type=\"" << dataType << "\" Name=\"rhoE\" format=\"appended\" offset=\"" << offset << "\"/>"
        << endl;
    offset += rhoE.m_memsize + sizeof(MUint);

    if(QThresholdOutput) {
      ofl << "<DataArray type=\"" << dataType << "\" Name=\"QThreshold\" format=\"appended\" offset=\"" << offset
          << "\"/>" << endl;
      offset += QThreshold.m_memsize + sizeof(MUint);
    }

#endif

    if(writePointData) {
      ofl << "</PointData>" << endl;
    } else {
      ofl << "</CellData>" << endl;
    }

    ofl << "</Piece>" << endl;
    ofl << "</UnstructuredGrid>" << endl;

    ofl << "<AppendedData encoding=\"raw\">" << endl;
    ofl << "_";
    ofl.close();
    ofl.clear();
  } else {
    cerr << "ERROR! COULD NOT OPEN FILE " << fileName << " for writing! (1)" << endl;
  }
  ofl.open(fileName.c_str(), ios_base::out | ios_base::app | ios_base::binary);

  if(ofl.is_open() && ofl.good()) {
    // point coordinates
    uinumber = (MUint)points.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(MUint));
    ofl.write(reinterpret_cast<const char*>(points.getPointer()), uinumber);

    // connectivity
    uinumber = (MUint)connectivity.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(MUint));
    ofl.write(reinterpret_cast<const char*>(connectivity.getPointer()), uinumber);

    // offsets
    uinumber = (MUint)offsets.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(offsets.getPointer()), uinumber);

    // cell types
    uinumber = (MUint)types.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(types.getPointer()), uinumber);

    // cellIds
    uinumber = (MUint)cellIds.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(cellIds.getPointer()), uinumber);

    // vtkGhostLevels
    if(m_haloCellOutput) {
      uinumber = (MUint)vtkGhostLevels.m_memsize;
      ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
      ofl.write(reinterpret_cast<const char*>(vtkGhostLevels.getPointer()), uinumber);
    }

#ifdef _MB_DEBUG_
    // bndryIds
    uinumber = (MUint)bndryIds.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(bndryIds.getPointer()), uinumber);

    // drho_dt
    uinumber = (MUint)drho_dt.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(drho_dt.getPointer()), uinumber);

    // drhou_dt
    uinumber = (MUint)drhou_dt.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(drhou_dt.getPointer()), uinumber);

    // levelSetFunction
    uinumber = (MUint)levelSetFunction.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(levelSetFunction.getPointer()), uinumber);

    // volume
    uinumber = (MUint)volume.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(volume.getPointer()), uinumber);

    // spongeFac
    uinumber = (MUint)spongeFac.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(spongeFac.getPointer()), uinumber);

    // tauC / tauE
    if(sensorOutput) {
      uinumber = (MUint)tauC.m_memsize;
      ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
      ofl.write(reinterpret_cast<const char*>(tauC.getPointer()), uinumber);
      uinumber = (MUint)tauE.m_memsize;
      ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
      ofl.write(reinterpret_cast<const char*>(tauE.getPointer()), uinumber);
    }

#endif

    // pressure
    uinumber = (MUint)pressure.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(pressure.getPointer()), uinumber);

    // velocity
    uinumber = (MUint)velocity.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(velocity.getPointer()), uinumber);

    // density
    uinumber = (MUint)density.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(density.getPointer()), uinumber);

    // vorticity
    uinumber = (MUint)vorticity.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(vorticity.getPointer()), uinumber);

    // Qcriterion
    uinumber = (MUint)Qcriterion.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(Qcriterion.getPointer()), uinumber);

    // dS
    if(entropyChangeOutput) {
      uinumber = (MUint)dS.m_memsize;
      ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
      ofl.write(reinterpret_cast<const char*>(dS.getPointer()), uinumber);
    }

#ifdef _MB_DEBUG_

    // rhoE
    uinumber = (MUint)rhoE.m_memsize;
    ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
    ofl.write(reinterpret_cast<const char*>(rhoE.getPointer()), uinumber);

    if(QThresholdOutput) {
      uinumber = (MUint)QThreshold.m_memsize;
      ofl.write(reinterpret_cast<const char*>(&uinumber), sizeof(uinumber));
      ofl.write(reinterpret_cast<const char*>(QThreshold.getPointer()), uinumber);
    }

#endif

    ofl.close();
    ofl.clear();
  } else {
    cerr << "ERROR! COULD NOT OPEN FILE " << fileName << " for writing! (2)" << endl;
  }

  ofl.open(fileName.c_str(), ios_base::out | ios_base::app);
  if(ofl.is_open() && ofl.good()) {
    ofl << endl;
    ofl << "</AppendedData>" << endl;

    ofl << "</VTKFile>" << endl;
    ofl.close();
    ofl.clear();
  } else {
    cerr << "ERROR! COULD NOT OPEN FILE " << fileName << " for writing! (3)" << endl;
  }
}


/**
 * \brief Writes VTK file for the embedded geometry
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 2, _*>>
MInt FvMbCartesianSolverXD<nDim, SysEqn>::writeGeometryToVtkXmlFile(const MString& fileName) {
  TRACE();

  ofstream ofl;
  ofl.open(fileName.c_str());

  if(ofl.is_open() && ofl.good()) {
    ofl << "<?xml version=\"1.0\"?>" << endl;
    ofl << R"(<VTKFile type="PolyData" version="0.1")" << endl;
    ofl << "<PolyData>" << endl;
    ofl << "<Piece NumberOfPoints=\"" << 0 << "\" NumberOfCells=\"" << 0 << "\">" << endl;
    ofl << "</Piece>" << endl;
    ofl << "</PolyData>" << endl;
    ofl << "</VTKFile>" << endl;
    ofl.close();
    ofl.clear();
    return 0;
  }
  return 0;
}


/**
 * \brief Writes VTK file for the embedded geometry
 * \author Lennart Schneiders
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
MInt FvMbCartesianSolverXD<nDim, SysEqn>::writeGeometryToVtkXmlFile(const MString& /*fileName*/) {
  return -1;
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 2, _*>>
void FvMbCartesianSolverXD<nDim, SysEqn>::writeVTKFileOfCell(MInt cellId, const std::vector<polyEdge2D>* edges,
                                                             const std::vector<polyVertex>* vertices, MInt set) {
  const MChar* fileName = "cell_";
  stringstream fileName2;
  fileName2 << fileName << cellId << "_s" << set << "_D" << domainId() << ".vtk";
  ofstream ofl;
  ofl.open((fileName2.str()).c_str(), ofstream::trunc);

  if(ofl) {
    // set fixed floating point output
    ofl.setf(ios::fixed);
    ofl.precision(7);

    ofl << "# vtk DataFile Version 3.0" << endl
        << "MAIAD cutsurface file" << endl
        << "ASCII" << endl
        << endl
        << "DATASET UNSTRUCTURED_GRID" << endl
        << endl;

    ofl << "POINTS " << (*vertices).size() << " float" << endl;

    for(MInt v = 0; (unsigned)v < (*vertices).size(); v++) {
      for(MInt i = 0; i < nDim; i++)
        ofl << (*vertices)[v].coordinates[i] << " ";
      ofl << F0 << " ";
      ofl << endl;
    }

    ofl << endl;
    MInt numPoints = 0;
    MInt noEdges = (*edges).size();
    numPoints += noEdges * 2;
    ofl << "CELLS " << noEdges << " " << noEdges + numPoints << endl;


    for(MInt i = 0; i < noEdges; i++) {
      unsigned noVerts = 2;
      ofl << noVerts << " ";
      ofl << (*edges)[i].vertices[0] << " ";
      ofl << (*edges)[i].vertices[1] << " ";
      ofl << endl;
    }
    ofl << endl;

    ofl << "CELL_TYPES " << noEdges << endl;
    for(MInt i = 0; i < noEdges; i++) {
      ofl << 3 << endl;
    }

    ofl.close();
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 2, _*>>
void FvMbCartesianSolverXD<nDim, SysEqn>::writeVTKFileOfCutCell(MInt cellId, std::vector<polyCutCell>* cutCells,
                                                                const std::vector<polyEdge2D>* edges,
                                                                const std::vector<polyVertex>* vertices, MInt set) {
  const MChar* fileName = "cutCell_";
  stringstream fileName2;
  fileName2 << fileName << cellId << "_s" << set << "_D" << domainId() << ".vtk";
  ofstream ofl;
  ofl.open((fileName2.str()).c_str(), ofstream::trunc);

  if(ofl) {
    // set fixed floating point output
    ofl.setf(ios::fixed);
    ofl.precision(7);

    ofl << "# vtk DataFile Version 3.0" << endl
        << "MAIAD cutsurface file" << endl
        << "ASCII" << endl
        << endl
        << "DATASET UNSTRUCTURED_GRID" << endl
        << endl;

    ofl << "POINTS " << (*vertices).size() << " float" << endl;

    for(MInt v = 0; (unsigned)v < (*vertices).size(); v++) {
      for(MInt i = 0; i < nDim; i++)
        ofl << (*vertices)[v].coordinates[i] << " ";
      ofl << F0 << " ";
      ofl << endl;
    }

    ofl << endl;
    MInt numPoints = 0;
    MInt noEdges = 0;
    for(MInt c = 0; (unsigned)c < (*cutCells).size(); c++) {
      MInt noEdgesCC = (*cutCells)[c].faces_edges.size();
      numPoints += noEdgesCC * 2;
      noEdges += noEdgesCC;
    }
    ofl << "CELLS " << noEdges << " " << noEdges + numPoints << endl;


    for(MInt c = 0; (unsigned)c < (*cutCells).size(); c++) {
      for(MInt i = 0; (unsigned)i < (*cutCells)[c].faces_edges.size(); i++) {
        MInt edge = (*cutCells)[c].faces_edges[i];
        unsigned noVerts = 2;
        ofl << noVerts << " ";
        ofl << (*edges)[edge].vertices[0] << " ";
        ofl << (*edges)[edge].vertices[1] << " ";
        ofl << endl;
      }
      ofl << endl;
    }
    ofl << endl;

    ofl << "CELL_TYPES " << noEdges << endl;
    for(MInt i = 0; i < noEdges; i++) {
      ofl << 3 << endl;
    }

    ofl << endl;
    ofl << "CELL_DATA " << noEdges << endl;
    ofl << "FIELD FieldData " << 2 << endl;
    ofl << "cutCell"
        << " " << 1 << " " << noEdges << " "
        << "int" << endl;
    for(MInt c = 0; (unsigned)c < (*cutCells).size(); c++) {
      for(MInt f = 0; (unsigned)f < (*cutCells)[c].faces_edges.size(); f++) {
        MInt edge = (*cutCells)[c].faces_edges[f];
        ofl << (*edges)[edge].cutCell << " ";
      }
    }
    ofl << endl;
    ofl << "bodyId"
        << " " << 1 << " " << noEdges << " "
        << "int" << endl;
    for(MInt c = 0; (unsigned)c < (*cutCells).size(); c++) {
      for(MInt f = 0; (unsigned)f < (*cutCells)[c].faces_edges.size(); f++) {
        MInt edge = (*cutCells)[c].faces_edges[f];
        ofl << (*edges)[edge].bodyId << " ";
      }
    }
    ofl << endl;

    ofl.close();
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 2, _*>>
void FvMbCartesianSolverXD<nDim, SysEqn>::outputPolyData(const MInt cellId, const std::vector<polyCutCell>* cutCells,
                                                         const std::vector<polyEdge2D>* edges,
                                                         const std::vector<polyVertex>* vertices, MInt set) {
  const MChar* fileName = "polyData_";
  stringstream fileName2;
  fileName2 << fileName << cellId << "_s" << set << "_D" << domainId();
  ofstream ofl;
  ofl.open((fileName2.str()).c_str(), ofstream::trunc);

  if(ofl) {
    // set fixed floating point output
    ofl.setf(ios::fixed);
    ofl.precision(7);

    ofl << "VERTICES:" << endl;
    for(MInt v = 0; (unsigned)v < (*vertices).size(); v++) {
      ofl << v << ": " << endl;
      ofl << "coordinates: " << (*vertices)[v].coordinates[0] << " " << (*vertices)[v].coordinates[1] << endl;
      ofl << "pointId: " << (*vertices)[v].pointId;
      ofl << ", pointType: " << (*vertices)[v].pointType << endl;
      ofl << "edges: ";
      for(MInt e = 0; (unsigned)e < (*vertices)[v].edges.size(); e++)
        ofl << (*vertices)[v].edges[e] << " ";
      ofl << endl << endl;
    }

    ofl << endl << "EDGES:" << endl;
    for(MInt e = 0; (unsigned)e < (*edges).size(); e++) {
      ofl << e << ": " << endl;
      ofl << "vertices: " << (*edges)[e].vertices[0] << " " << (*edges)[e].vertices[1] << endl;
      ofl << "edgeId: " << (*edges)[e].edgeId;
      ofl << ", edgeType: " << (*edges)[e].edgeType;
      ofl << ", bodyId: " << (*edges)[e].bodyId;
      ofl << ", cutCell: " << (*edges)[e].cutCell << endl;
      ofl << "area: " << (*edges)[e].area << endl;
      ofl << "center: " << (*edges)[e].center[0] << " " << (*edges)[e].center[1] << endl;
      ofl << "normal: " << (*edges)[e].normal[0] << " " << (*edges)[e].normal[1] << endl;
      ofl << "w: " << (*edges)[e].w << endl;
      ofl << endl << endl;
    }

    ofl << endl << "CUT CELLS:" << endl;
    for(MInt c = 0; (unsigned)c < (*cutCells).size(); c++) {
      ofl << c << ": " << endl;
      ofl << "volume: " << (*cutCells)[c].volume << endl;
      ofl << "center: " << (*cutCells)[c].center[0] << " " << (*cutCells)[c].center[1] << endl;
      ofl << "cartesianCell: " << (*cutCells)[c].cartesianCell << endl;
      ofl << "edges: ";
      for(MInt f = 0; (unsigned)f < (*cutCells)[c].faces_edges.size(); f++)
        ofl << (*cutCells)[c].faces_edges[f] << " ";
      ofl << endl << endl;
    }

    ofl.close();
  }
}


/**
 * \brief
 * \author
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
void FvMbCartesianSolverXD<nDim, SysEqn>::outputPolyData(const MInt cellId, const std::vector<polyCutCell>* cutCells,
                                                         const std::vector<polyFace>* faces,
                                                         const std::vector<polyEdge3D>* edges,
                                                         const std::vector<polyVertex>* vertices, MInt set) {
  const MChar* fileName = "polyData_";
  stringstream fileName2;
  fileName2 << fileName << cellId << "_s" << set << "_D" << domainId();
  ofstream ofl;
  ofl.open((fileName2.str()).c_str(), ofstream::trunc);

  if(ofl) {
    // set fixed floating point output
    ofl.setf(ios::fixed);
    ofl.precision(20);

    ofl << "VERTICES:" << endl;
    for(MInt v = 0; (unsigned)v < (*vertices).size(); v++) {
      ofl << v << ": " << endl;
      ofl << "coordinates: " << (*vertices)[v].coordinates[0] << " " << (*vertices)[v].coordinates[1] << " "
          << (*vertices)[v].coordinates[2] << endl;
      ofl << "pointId: " << (*vertices)[v].pointId;
      ofl << ", pointType: " << (*vertices)[v].pointType << endl;
      ofl << "surfaceIdentificators: ";
      for(std::set<MInt>::iterator it = (*vertices)[v].surfaceIdentificators.begin();
          it != (*vertices)[v].surfaceIdentificators.end();
          it++)
        ofl << *it << " ";
      ofl << endl;
      ofl << "edges: ";
      for(MInt e = 0; (unsigned)e < (*vertices)[v].edges.size(); e++)
        ofl << (*vertices)[v].edges[e] << " ";
      ofl << endl << endl;
    }

    ofl << endl << "EDGES:" << endl;
    for(MInt e = 0; (unsigned)e < (*edges).size(); e++) {
      ofl << e << ": " << endl;
      ofl << "vertices: " << (*edges)[e].vertices[0] << " " << (*edges)[e].vertices[1] << endl;
      ofl << "faces: " << (*edges)[e].face[0] << " " << (*edges)[e].face[1] << endl;
      ofl << "edgeId: " << (*edges)[e].edgeId;
      ofl << ", edgeType: " << (*edges)[e].edgeType << endl;
      ofl << endl << endl;
    }

    ofl << endl << "FACES:" << endl;
    for(MInt f = 0; (unsigned)f < (*faces).size(); f++) {
      ofl << f << ": " << endl;
      ofl << "area: " << (*faces)[f].area << endl;
      ofl << "center: " << (*faces)[f].center[0] << " " << (*faces)[f].center[1] << " " << (*faces)[f].center[2]
          << endl;
      ofl << "normal: " << (*faces)[f].normal[0] << " " << (*faces)[f].normal[1] << " " << (*faces)[f].normal[2]
          << endl;
      ofl << "w: " << (*faces)[f].w << endl;
      ofl << "faceId: " << (*faces)[f].faceId;
      ofl << ", faceType: " << (*faces)[f].faceType << endl;
      ofl << "bodyId: " << (*faces)[f].bodyId << endl;
      ofl << "setIndex: " << (*faces)[f].tmpSetIndex << endl;
      ofl << "cutCell: " << (*faces)[f].cutCell << endl;
      ofl << "edges: ";
      for(MInt e = 0; (unsigned)e < (*faces)[f].edges.size(); e++)
        ofl << (*faces)[f].edges[e].first << ", dir " << (*faces)[f].edges[e].second << " ";
      ofl << endl << endl;
    }

    ofl << endl << "CUT CELLS:" << endl;
    for(MInt c = 0; (unsigned)c < (*cutCells).size(); c++) {
      ofl << c << ": " << endl;
      ofl << "volume: " << (*cutCells)[c].volume << endl;
      ofl << "center: " << (*cutCells)[c].center[0] << " " << (*cutCells)[c].center[1] << " "
          << (*cutCells)[c].center[2] << endl;
      ofl << "cartesianCell: " << (*cutCells)[c].cartesianCell << endl;
      ofl << "faces: ";
      for(MInt f = 0; (unsigned)f < (*cutCells)[c].faces_edges.size(); f++)
        ofl << (*cutCells)[c].faces_edges[f] << " ";
      ofl << endl << endl;
    }

    ofl.close();
  }
}


/**
 * \brief determines the geometric cut-cell data
 * \author Claudia Guenther
 * \date 30.07.2013
 * computes the following moving boundary cell member variables:
 *  - m_srfcs[0]->m_area
 *  - m_srfcs[0]->m_coordinates
 *  - m_srfcs[0]->m_volume
 *  - m_srfcs[0]->m_normalVector
 *  - m_noNonFluidsSideIds
 *  - m_externalFaces
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 2, _*>>
void FvMbCartesianSolverXD<nDim, SysEqn>::createCutFaceMb_MGC() {
  TRACE();

  MInt& bodyFaceJoinMode = m_static_createCutFaceMb_MGC_bodyFaceJoinMode;
  MFloat& maxA = m_static_createCutFaceMb_MGC_maxA;
  MBool& first = m_static_createCutFaceMb_MGC_first;
  if(first) {
    bodyFaceJoinMode = Context::getSolverProperty<MInt>("bodyFaceJoinMode", solverId(), AT_, &bodyFaceJoinMode);
    maxA = Context::getSolverProperty<MFloat>("bodyFaceJoinCriterion", solverId(), AT_, &maxA);
    first = false;
  }

  const MInt faceOrder[4] = {2, 1, 3, 0};
  const MFloat signStencil[8][3] = {{-F1, -F1, -F1}, {F1, -F1, -F1}, {-F1, F1, -F1}, {F1, F1, -F1},
                                    {-F1, -F1, F1},  {F1, -F1, F1},  {-F1, F1, F1},  {F1, F1, F1}};
  const MInt edgeCornerCode[4][2] = {{2, 0}, {1, 3}, {0, 1}, {3, 2}};

  const MInt maxNoSets = 6;
  ASSERT2(m_noLevelSetsUsedForMb < maxNoSets, "");
  MIntScratchSpace outcode_set(m_noLevelSetsUsedForMb, AT_, "outcode_set");
  MIntScratchSpace noCutPointsFromSet(m_noLevelSetsUsedForMb, AT_, "noCutPointsFromSet");
  MIntScratchSpace cutSetPointers(m_noLevelSetsUsedForMb, AT_, "cutSetPointers");

  const MInt maxNoVertices = 25;
  const MInt maxNoEdges = 25;

  stack<MInt> multiEdgeStack;
  std::vector<polyVertex> vertices[maxNoSets];
  std::vector<polyEdge2D> edges[maxNoSets];
  std::vector<polyCutCell> cutCells;

  std::vector<CsgPolygon> csg_polygons;
  std::vector<CsgVertex> csg_vertices;
  std::vector<Csg> csg;
  std::vector<CsgPolygon> result;
  std::vector<polyVertex> vertices_result;
  stack<MInt> edgeStack;
  std::vector<MInt> faceVertices;

  MIntScratchSpace multiEdgeConnection(maxNoEdges, AT_, "multiEdgeConnection");
  MIntScratchSpace vertices_renamed(2, maxNoVertices, AT_, "vertices_renamed");
  MIntScratchSpace bodyFaces(maxNoEdges, AT_, "bodyFaces");
  MFloatScratchSpace normalDotProduct(maxNoEdges, maxNoEdges, AT_, "normalDotProduct"); // stores 1 - n1*n2 -> in [0;2]
  MIntScratchSpace pointEdgeId(2 * m_noEdges, AT_, "pointEdgeId");
  MIntScratchSpace newCutPointId(maxNoVertices, AT_, "newCutPointId");
  MBoolScratchSpace isPartOfBodySurface(maxNoVertices, AT_, "isPartOfBodySurface");
  MIntScratchSpace tmp_Edges(maxNoEdges, AT_, "tmp_Edges");
  MIntScratchSpace vertexCutCellPointer(maxNoEdges, AT_, "vertexCutCellPointer");

  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    FvBndryCell<2, SysEqn>* bndryCell = &m_fvBndryCnd->m_bndryCells->a[bndryId];
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    const MInt cndId = m_bndryCandidateIds[cellId];
    ASSERT(cndId > -1, "");

    for(MInt f = 0; f < m_noDirs; f++) {
      bndryCell->m_externalFaces[f] = false;
    }

    if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints == 0) {
      cerr << "** fvmbsolver2d ERROR" << endl;
      cerr << "boundary cell " << bndryId << endl;
      cerr << a_coordinate(cellId, 0) << " " << a_coordinate(cellId, 1) << endl;
      cerr << " -> number of cut points is zero" << endl;
      continue;
    }

    if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints % 2 != 0) {
      cerr << "** fvmbsolver2d ERROR" << endl;
      cerr << "boundary cell " << bndryId << endl;
      cerr << a_coordinate(cellId, 0) << " " << a_coordinate(cellId, 1) << endl;
      cerr << " -> number of cut points uneven" << endl;
      continue;
    }

    const MFloat cellLength0 = c_cellLengthAtLevel(a_level(cellId));
    const MFloat cellHalfLength = F1B2 * cellLength0;

    // reset some variables
    for(MInt s = 0; s < m_noLevelSetsUsedForMb; s++) {
      vertices[s].clear();
      edges[s].clear();
      cutSetPointers[s] = -1;
      noCutPointsFromSet[s] = 0;
    }
    cutCells.clear();

    MBool isGapCell = false;
    if(m_levelSet && m_closeGaps) {
      isGapCell = (a_hasProperty(cellId, SolverCell::IsGapCell));
    }
    MInt startSet = 0;
    MInt endSet = 1;
    if(m_complexBoundary && m_noLevelSetsUsedForMb > 1 && (!isGapCell)) {
      startSet = 1;
      endSet = m_noLevelSetsUsedForMb;
    } else if(m_complexBoundary && m_noLevelSetsUsedForMb > 1 && (isGapCell)) {
      startSet = 0;
      endSet = 1;
    }

    // preprocess cut points - find out which level set functions contain relevant cut points
    // if no relevant cut points are present -> don't cut the cell with the set
    MInt noCutSets = 0;
    MBool isCompletelyOutside = false;
    for(MInt s = startSet; s < endSet; s++) {
      // 1.1. get In/Outcode of the corners of the voxel
      // 0 -> Corner is outside Fluid Domain
      // 1 -> Corner is inside Fluid Domain or on Boundary
      unsigned char outcode = 0;
      for(MInt c = 0; c < m_noCorners; c++) {
        MBool currentOutcode = (!m_pointIsInside[bndryId][IDX_LSSETMB(c, s)]);
        if(currentOutcode) outcode = outcode | (1 << c);
      }
      outcode_set[s] = outcode;
      if(outcode == 0) isCompletelyOutside = true;
    }
    for(MInt cutPoint = 0; cutPoint < bndryCell->m_srfcs[0]->m_noCutPoints; cutPoint++) {
      ASSERT(bndryCell->m_srfcs[0]->m_bodyId[cutPoint] > -1
                 && bndryCell->m_srfcs[0]->m_bodyId[cutPoint] < m_noEmbeddedBodies,
             "bodyId out of bounds " + to_string(cellId) + " " + to_string(cutPoint) + " "
                 + to_string(bndryCell->m_srfcs[0]->m_bodyId[cutPoint]));
      MInt set = 0;
      if(m_complexBoundary && m_noLevelSetsUsedForMb > 1 && (!isGapCell))
        set = m_bodyToSetTable[bndryCell->m_srfcs[0]->m_bodyId[cutPoint]];
      ASSERT(set > -1 && set < m_noLevelSetsUsedForMb, "set out of bounds " + to_string(cellId) + " "
                                                           + to_string(cutPoint) + " " + to_string(set) + " "
                                                           + to_string(bndryCell->m_srfcs[0]->m_bodyId[cutPoint]));
      noCutPointsFromSet[set]++;
    }
    for(MInt set = startSet; set < endSet; set++) {
      if(noCutPointsFromSet[set] && !isCompletelyOutside) {
        cutSetPointers[set] = noCutSets++;
      }
    }

    // computation of cuts with individual sets
    for(MInt set = startSet; set < endSet; set++) {
      MInt setIndex = cutSetPointers[set];
      if(setIndex < 0) continue;
      MInt bodyId = a_associatedBodyIds(cellId, set);
      if(bodyId < 0) continue;

      // store all cut points in a separate array
      // and prepare all vertices for polyeder/polygon datastructure
      // vertices = cut points and fluid corners of the cell
      MInt cutPoints[4] = {-1, -1, -1, -1};
      MInt cutPointToVertexMap[4] = {-1, -1, -1, -1};
      MInt noCutPoints = 0;
      for(MInt cutPoint = 0; cutPoint < bndryCell->m_srfcs[0]->m_noCutPoints; cutPoint++) {
        if(m_complexBoundary && m_noLevelSetsUsedForMb > 1 && (!isGapCell))
          if(m_bodyToSetTable[bndryCell->m_srfcs[0]->m_bodyId[cutPoint]] != set) continue;
        noCutPoints++;
        cutPoints[bndryCell->m_srfcs[0]->m_cutEdge[cutPoint]] = cutPoint;
        vertices[setIndex].push_back(polyVertex(bndryCell->m_srfcs[0]->m_cutCoordinates[cutPoint], cutPoint, 1));
        cutPointToVertexMap[cutPoint] = vertices[setIndex].size() - 1;
      }
      MInt cornerToVertexMap[4] = {-1, -1, -1, -1};
      for(MInt c = 0; c < m_noCorners; c++) {
        if(!m_pointIsInside[bndryId][IDX_LSSETMB(c, set)]) {
          MFloat tmp_coords[2];
          for(MInt i = 0; i < nDim; i++)
            tmp_coords[i] = a_coordinate(cellId, i) + signStencil[c][i] * cellHalfLength;
          vertices[setIndex].push_back(polyVertex(tmp_coords, c, 0));
          cornerToVertexMap[c] = vertices[setIndex].size() - 1;
        }
      }

      // 1. find correct marching cubes state and substate -> including disambiguation

      // 1.1. get In/Outcode of the corners of the voxel
      // 0 -> Corner is outside Fluid Domain
      // 1 -> Corner is inside Fluid Domain or on Boundary
      MInt outcode = outcode_set[set];

      // 1.2. determine Case and check if case is implemented
      MInt currentCase = (MInt)cases2D[outcode][0];
      MInt currentSubCase = (MInt)cases2D[outcode][1];
      MInt subConfig = 0;
      // 1.2 determine ambiguous cells
      if(!caseStates2D[currentCase]) { // ambiguous case -> disambiguate
        MBool centerIsFluid = test_face(cndId, 4, set);
        if((centerIsFluid && currentSubCase == 1) || (!centerIsFluid && currentCase == 0)) subConfig = 1;
      }
      // 1.3. decide which tiling should be used, how many triangles are to be created for the cut face(s), etc.
      MInt noLines = 0;
      const MInt* tilingPointer = nullptr;
      noLines = noEdges2D[currentCase];
      switch(currentCase) {
        case 0:
          break;

        case 1:
          tilingPointer = tiling1_2D[currentSubCase];
          break;
        case 2:
          tilingPointer = tiling2_2D[currentSubCase];
          break;
        case 3: {
          if(subConfig == 0)
            tilingPointer = tiling3_A_2D[currentSubCase];
          else
            tilingPointer = tiling3_B_2D[currentSubCase];
          break;
        }
        default:
          mTerm(1, AT_, "invalid MC case, how could this happen? exiting...");
          break;
      }

      // 2. build edges  for body surfaces -> MC
      for(MInt t = 0; t < noLines; t++) {
        // create a new edge
        MInt p[2];
        MInt cutEdge0 = tilingPointer[t * 2 + 0];
        MInt cutEdge1 = tilingPointer[t * 2 + 1];
        MInt p0 = cutPoints[cutEdge0];
        MInt p1 = cutPoints[cutEdge1];
        p[0] = cutPointToVertexMap[p0];
        p[1] = cutPointToVertexMap[p1];
        MInt newEdge = edges[setIndex].size();
        MInt edgeType = 2;
        MInt edgeId = -1;
        edges[setIndex].push_back(polyEdge2D(p[0], p[1], edgeId, edgeType, bodyId));
        vertices[setIndex][p[0]].edges.push_back(newEdge);
        vertices[setIndex][p[1]].edges.push_back(newEdge);

        // compute normal of edge:
        computeNormal(vertices[setIndex][p[0]].coordinates, vertices[setIndex][p[1]].coordinates,
                      edges[setIndex][newEdge].normal, edges[setIndex][newEdge].w);
      }

      // 3. prepare basic edges -> between two inside corner vertices or between a corner vertex and a cut point
      for(MInt e = 0; e < m_noEdges; e++) {
        MInt edge = faceOrder[e];
        MBool p0Fluid = !m_pointIsInside[bndryId][IDX_LSSETMB(edgeCornerCode[edge][0], set)];
        MBool p1Fluid = !m_pointIsInside[bndryId][IDX_LSSETMB(edgeCornerCode[edge][1], set)];
        if(p0Fluid && p1Fluid) { // created a full Cartesian edge
          MInt v0 = cornerToVertexMap[edgeCornerCode[edge][0]];
          MInt v1 = cornerToVertexMap[edgeCornerCode[edge][1]];
          edges[setIndex].push_back(polyEdge2D(v0, v1, edge, 0, -1));
          vertices[setIndex][v0].edges.push_back(edges[setIndex].size() - 1);
          vertices[setIndex][v1].edges.push_back(edges[setIndex].size() - 1);
          computeNormal(vertices[setIndex][v0].coordinates, vertices[setIndex][v1].coordinates,
                        edges[setIndex][edges[setIndex].size() - 1].normal,
                        edges[setIndex][edges[setIndex].size() - 1].w);
        } else if(p0Fluid) { // create a cut edge from p0 to cut point
          MInt v0 = cornerToVertexMap[edgeCornerCode[edge][0]];
          MInt v1 = cutPointToVertexMap[cutPoints[edge]];
          edges[setIndex].push_back(polyEdge2D(v0, v1, edge, 1, -1));
          vertices[setIndex][v0].edges.push_back(edges[setIndex].size() - 1);
          vertices[setIndex][v1].edges.push_back(edges[setIndex].size() - 1);
          computeNormal(vertices[setIndex][v0].coordinates, vertices[setIndex][v1].coordinates,
                        edges[setIndex][edges[setIndex].size() - 1].normal,
                        edges[setIndex][edges[setIndex].size() - 1].w);
        } else if(p1Fluid) { // create a cut edge from cut point to p1
          MInt v0 = cutPointToVertexMap[cutPoints[edge]];
          MInt v1 = cornerToVertexMap[edgeCornerCode[edge][1]];
          edges[setIndex].push_back(polyEdge2D(v0, v1, edge, 1, -1));
          vertices[setIndex][v0].edges.push_back(edges[setIndex].size() - 1);
          vertices[setIndex][v1].edges.push_back(edges[setIndex].size() - 1);
          computeNormal(vertices[setIndex][v0].coordinates, vertices[setIndex][v1].coordinates,
                        edges[setIndex][edges[setIndex].size() - 1].normal,
                        edges[setIndex][edges[setIndex].size() - 1].w);
        } // else create no edge since edge is fully located outside
      }
    }

    // 4.a combine polygons that are computed with different sets to one polygon
    // set up the CSG datastructure for each polygon
    //     MBool error = false;
    const MInt startSetIndex = 0;
    MInt referenceSet = startSet;
    for(MInt set = startSet; set < endSet; set++) {
      if(cutSetPointers[set] > -1) {
        referenceSet = set;
        break;
      }
    }
    for(MInt set = referenceSet + 1; set < endSet; set++) {
      MInt setIndex = cutSetPointers[set];
      if(setIndex < 0) continue;
      csg.clear();
      csg_polygons.clear();

      for(MInt e = 0; (unsigned)e < edges[startSetIndex].size(); e++) {
        csg_vertices.clear();
        MInt vertex0 = edges[startSetIndex][e].vertices[0];
        MInt vertex1 = edges[startSetIndex][e].vertices[1];
        csg_vertices.push_back(
            CsgVertex(CsgVector(vertices[startSetIndex][vertex0].coordinates), vertex0, startSetIndex));
        csg_vertices.push_back(
            CsgVertex(CsgVector(vertices[startSetIndex][vertex1].coordinates), vertex1, startSetIndex));
        csg_polygons.push_back(CsgPolygon(csg_vertices, startSetIndex, edges[startSetIndex][e].edgeId,
                                          edges[startSetIndex][e].edgeType, edges[startSetIndex][e].bodyId));
      }
      csg.push_back(Csg(csg_polygons));

      csg_polygons.clear();
      for(MInt e = 0; (unsigned)e < edges[setIndex].size(); e++) {
        csg_vertices.clear();
        MInt vertex0 = edges[setIndex][e].vertices[0];
        MInt vertex1 = edges[setIndex][e].vertices[1];
        csg_vertices.push_back(CsgVertex(CsgVector(vertices[setIndex][vertex0].coordinates), vertex0, setIndex));
        csg_vertices.push_back(CsgVertex(CsgVector(vertices[setIndex][vertex1].coordinates), vertex1, setIndex));
        csg_polygons.push_back(CsgPolygon(csg_vertices, setIndex, edges[setIndex][e].edgeId,
                                          edges[setIndex][e].edgeType, edges[setIndex][e].bodyId));
      }
      csg.push_back(Csg(csg_polygons));

      // call intersect
      result.clear();
      result = csg[0].intersect(csg[1]);
      vertices_result.clear();

      // post process vertices, edges, faces:
      // first: regenerate polyVertices (unique vertices) vector
      for(MInt i = 0; i < 2; i++)
        for(MInt j = 0; j < maxNoVertices; j++)
          vertices_renamed(i, j) = -1;

      MInt noVertices = 0;
      for(MInt p = 0; (unsigned)p < result.size(); p++) {
        for(MInt v = 0; (unsigned)v < result[p].vertices.size(); v++) {
          ASSERT(result[p].vertices.size() <= (unsigned)maxNoVertices, "");
          MInt vertexId = result[p].vertices[v].vertexId;
          MInt vertexSetIndex = result[p].vertices[v].setIndex;
          if(vertexId > -1) { // vertex corresponds to an existing vertex
            if(vertices_renamed(vertexSetIndex, vertexId) == -1) {
              // check if vertex has been added to vertices_result vector
              MBool vertexFound = false;
              MInt vertexIndex = -1;
              for(MInt i = 0; (unsigned)i < vertices_result.size(); i++) {
                if(vertices_result[i].pointType != 3) continue;
                MFloat coord_diff = F0;
                coord_diff += (result[p].vertices[v].pos.xx[0] - vertices_result[i].coordinates[0])
                              * (result[p].vertices[v].pos.xx[0] - vertices_result[i].coordinates[0]);
                coord_diff += (result[p].vertices[v].pos.xx[1] - vertices_result[i].coordinates[1])
                              * (result[p].vertices[v].pos.xx[1] - vertices_result[i].coordinates[1]);

                if(coord_diff < m_eps * 10) {
                  vertexFound = true;
                  vertexIndex = i;
                  break;
                }
              }
              if(vertexFound) {
                vertices_renamed(vertexSetIndex, vertexId) = vertexIndex;
              } else {
                vertices_renamed(vertexSetIndex, vertexId) = noVertices;
                vertices_result.push_back(polyVertex(vertices[vertexSetIndex][vertexId].pointId,
                                                     vertices[vertexSetIndex][vertexId].pointType));
                vertices_result[noVertices].coordinates[0] = vertices[vertexSetIndex][vertexId].coordinates[0];
                vertices_result[noVertices].coordinates[1] = vertices[vertexSetIndex][vertexId].coordinates[1];
                noVertices++;
              }
            }
            result[p].vertices[v].vertexId = vertices_renamed(vertexSetIndex, vertexId);
            result[p].vertices[v].setIndex = -1;
          }
        }
      }
      for(MInt p = 0; (unsigned)p < result.size(); p++) {
        for(MInt v = 0; (unsigned)v < result[p].vertices.size(); v++) {
          MInt vertexId = result[p].vertices[v].vertexId;
          if(vertexId == -1) { // remaining vertices...
            // check if vertex has been added to vertices_result vector
            MBool vertexFound = false;
            MInt vertexIndex = -1;
            for(MInt i = 0; (unsigned)i < vertices_result.size(); i++) {
              MFloat coord_diff = F0;
              coord_diff += (result[p].vertices[v].pos.xx[0] - vertices_result[i].coordinates[0])
                            * (result[p].vertices[v].pos.xx[0] - vertices_result[i].coordinates[0]);
              coord_diff += (result[p].vertices[v].pos.xx[1] - vertices_result[i].coordinates[1])
                            * (result[p].vertices[v].pos.xx[1] - vertices_result[i].coordinates[1]);

              if(coord_diff < m_eps * 10) {
                vertexFound = true;
                vertexIndex = i;
                break;
              }
            }
            if(vertexFound) {
              result[p].vertices[v].vertexId = vertexIndex;
              result[p].vertices[v].setIndex = -1;
            } else {
              vertices_result.push_back(polyVertex(-1, 3));
              vertices_result[noVertices].coordinates[0] = result[p].vertices[v].pos.xx[0];
              vertices_result[noVertices].coordinates[1] = result[p].vertices[v].pos.xx[1];
              result[p].vertices[v].vertexId = noVertices;
              result[p].vertices[v].setIndex = -1;
              noVertices++;
            }
          }
        }
      }

      vertices[startSetIndex].swap(vertices_result);
      vertices_result.clear();
      edges[startSetIndex].clear();
      // second: regenerate edges and faces vectors (unique edges)
      MInt noFaces = 0;
      MInt noEdges = 0;
      for(MInt p = 0; (unsigned)p < result.size(); p++) {
        MInt bId = result[p].bodyId;
        MInt eId = result[p].faceId;
        MInt eType = result[p].faceType;

        // add edges
        for(MInt v = 0; (unsigned)v < result[p].vertices.size() - 1; v++) {
          MInt j = (v + 1) % result[p].vertices.size();
          MInt vertexId = result[p].vertices[v].vertexId;
          MInt vertexIdNext = result[p].vertices[j].vertexId;
          MBool edgeFound = false;
          for(MInt e = 0; (unsigned)e < edges[startSetIndex].size(); e++) {
            MInt v0 = edges[startSetIndex][e].vertices[0];
            MInt v1 = edges[startSetIndex][e].vertices[1];
            if(vertexId == v0 && vertexIdNext == v1) {
              edgeFound = true;
              break;
            } else if(vertexId == v1 && vertexIdNext == v0) {
              edgeFound = true;
              break;
            }
          }
          if(!edgeFound) {
            edges[startSetIndex].push_back(polyEdge2D(vertexId, vertexIdNext, eId, eType, bId));
            vertices[startSetIndex][vertexId].edges.push_back(noEdges);
            vertices[startSetIndex][vertexIdNext].edges.push_back(noEdges);
            edges[startSetIndex][noEdges].normal[0] = result[p].plane.normal.xx[0];
            edges[startSetIndex][noEdges].normal[1] = result[p].plane.normal.xx[1];
            edges[startSetIndex][noEdges].w = -result[p].plane.w;
            noEdges++;
          }
        }
        noFaces++;
      }
      // TODO labels:FVMB change CSG routine such that it works with the present datastructure!
    }

    // debug: test, if each vertex has exactly 2 edges:
    for(MInt v = 0; (unsigned)v < vertices[startSetIndex].size(); v++) {
      if(vertices[startSetIndex][v].edges.size() == 2) continue;
      cerr << " Error on cell " << cellId << ". Cell has vertex with not 2 edges... " << v << "/"
           << vertices[startSetIndex][v].edges.size() << endl;
      writeVTKFileOfCell(cellId, &edges[startSetIndex], &vertices[startSetIndex], startSetIndex);
      outputPolyData(cellId, &cutCells, &edges[startSetIndex], &vertices[startSetIndex], startSetIndex);
      ASSERT(vertices[startSetIndex][v].edges.size() == 2, "");
    }

    // 4. b compose cell
    if(edges[startSetIndex].size() == 0) {
      cutCells.push_back(polyCutCell(bndryId, &a_coordinate(cellId, 0)));
    }
    for(MInt edgeCounter = 0; (unsigned)edgeCounter < edges[startSetIndex].size(); edgeCounter++) {
      if(edges[startSetIndex][edgeCounter].cutCell > -1) continue;
      edgeStack.push(edgeCounter);
      MInt currentCutCell = cutCells.size();
      cutCells.push_back(polyCutCell(bndryId, &a_coordinate(cellId, 0)));
      edges[startSetIndex][edgeCounter].cutCell = currentCutCell;
      cutCells[currentCutCell].faces_edges.push_back(edgeCounter);
      while(!edgeStack.empty()) {
        MInt currentEdge = edgeStack.top();
        edgeStack.pop();
        MInt vertex = edges[startSetIndex][currentEdge].vertices[1];
        MInt otherEdge = vertices[startSetIndex][vertex].edges[0];
        if(otherEdge == currentEdge) otherEdge = vertices[startSetIndex][vertex].edges[1];
        if(edges[startSetIndex][otherEdge].cutCell == -1) {
          cutCells[currentCutCell].faces_edges.push_back(otherEdge);
          edges[startSetIndex][otherEdge].cutCell = currentCutCell;
          edgeStack.push(otherEdge);
        }
      }
    }

    // 5. compute  polyhedron(polyhedra)
    compVolumeIntegrals(&cutCells, &edges[startSetIndex], &vertices[startSetIndex]);

    // 5.1. if required, join cut surfaces if their normal vectors are similar enough

    // 6. relate polyhedron(polyhedra) quantities to Cartesian cell quantities -> finish cell
    // 6.0. Currently: Split cells and split Cartesian surfaces are not allowed -> check here!
    if(cutCells.size() > 1) {
      cerr << "split cell detected. These are not implemented in MB framework yet. cell " << cellId << endl;
      writeVTKFileOfCell(cellId, &edges[startSetIndex], &vertices[startSetIndex], startSetIndex);
      outputPolyData(cellId, &cutCells, &edges[startSetIndex], &vertices[startSetIndex], startSetIndex);
      mTerm(1, AT_, "split cell detected. These are not implemented in MB framework yet. exiting...");
      continue;
    }
    MInt noFacesPerCartesianFace[6] = {0, 0, 0, 0};
    MInt noBodySurfaces = 0;
    for(MInt e = 0; (unsigned)e < cutCells[0].faces_edges.size(); e++) {
      MInt edge = cutCells[0].faces_edges[e];
      if(edges[startSetIndex][edge].edgeType == 0 || edges[startSetIndex][edge].edgeType == 1)
        noFacesPerCartesianFace[edges[startSetIndex][edge].edgeId]++;
      else
        noBodySurfaces++;
    }
    for(MInt i = 0; i < m_noDirs; i++) {
      if(noFacesPerCartesianFace[i] > 1) {
        cerr << "split face detected. These are not implemented in MB framework yet. cell " << cellId << ", face " << i
             << endl;
        writeVTKFileOfCell(cellId, &edges[startSetIndex], &vertices[startSetIndex], startSetIndex);
        writeVTKFileOfCutCell(cellId, &cutCells, &edges[startSetIndex], &vertices[startSetIndex], startSetIndex);
        outputPolyData(cellId, &cutCells, &edges[startSetIndex], &vertices[startSetIndex], startSetIndex);
        mTerm(1, AT_, " split face detected. These are not implemented in MB framework yet. exiting...");
        continue;
      }
    }
    if(noBodySurfaces > FvBndryCell<2, SysEqn>::m_maxNoSurfaces) {
      cerr << "more than FvBndryCell<2,SysEqn>::m_maxNoSurfaces cut surfaces detected for a cell. This is not "
              "implemented "
              "in MB framework yet. cell "
           << cellId << endl;
      writeVTKFileOfCell(cellId, &edges[startSetIndex], &vertices[startSetIndex], startSetIndex);
      writeVTKFileOfCutCell(cellId, &cutCells, &edges[startSetIndex], &vertices[startSetIndex], startSetIndex);
      outputPolyData(cellId, &cutCells, &edges[startSetIndex], &vertices[startSetIndex], startSetIndex);
      mTerm(1, AT_,
            " more than 3 cut surfaces detected for a cell. This is not implemented in MB framework yet. "
            "exiting...");
      continue;
    }


    // 6.1. set bndry cell and surface properties
    // deactivate cells with no faces
    if(cutCells[0].faces_edges.size() == 0) {
      a_hasProperty(cellId, SolverCell::IsInactive) = true;
      a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel) = false;
      cutCells[0].volume = F0;
      cutCells[0].center[0] = a_coordinate(cellId, 0);
      cutCells[0].center[1] = a_coordinate(cellId, 1);
    }

    ASSERT(!(cutCells[0].volume < F0), "");
    ASSERT(!(std::isnan(cutCells[0].volume)), "");
    ASSERT(!(std::isnan(cutCells[0].center[0])), "");
    ASSERT(!(std::isnan(cutCells[0].center[1])), "");
    ASSERT(!(std::isinf(cutCells[0].volume)), "");
    ASSERT(!(std::isinf(cutCells[0].center[0])), "");
    ASSERT(!(std::isinf(cutCells[0].center[1])), "");

    // non fluid sides:
    for(MInt f = 0; f < m_noDirs; f++) {
      if(noFacesPerCartesianFace[f] == 0) { // non fluid face
        bndryCell->m_externalFaces[f] = true;
        MInt srfcId = m_cellSurfaceMapping[cellId][f];
        if(srfcId > -1) {
          a_surfaceArea(srfcId) = F0;
          //          m_isActiveSurface[ srfcId ] = false;
          deleteSurface(srfcId);
        }
        bndryCell->m_associatedSrfc[f] = -1;
        m_cutFaceArea[bndryId][f] = F0;

        MInt nghbrId = c_neighborId(cellId, f);
        MInt nghbrBndryId = -1;
        if(nghbrId > -1) nghbrBndryId = a_bndryId(nghbrId);

        if(nghbrBndryId > -1) {
          m_bndryCells->a[nghbrBndryId].m_associatedSrfc[m_revDir[f]] = -1;
          m_cutFaceArea[nghbrBndryId][m_revDir[f]] = F0;
        }
      }
    }
    // before reassigning cut points, store the relevant information

    ASSERT(vertices[startSetIndex].size() <= (unsigned)maxNoVertices, "");
    for(MInt cp = 0; cp < maxNoVertices; cp++)
      newCutPointId[cp] = -1;
    for(MInt i = 0; (unsigned)i < vertices[startSetIndex].size(); i++)
      isPartOfBodySurface[i] = false;
    for(MInt e = 0; e < 2 * m_noEdges; e++) {
      pointEdgeId[e] = bndryCell->m_srfcs[0]->m_cutEdge[e];
    }
    noBodySurfaces = 0;
    bndryCell->m_volume = cutCells[0].volume;
    for(MInt i = 0; i < nDim; i++)
      bndryCell->m_coordinates[i] = cutCells[0].center[i] - a_coordinate(cellId, i);
    for(MInt f = 0; (unsigned)f < cutCells[0].faces_edges.size(); f++) {
      MInt edge = cutCells[0].faces_edges[f];
      ASSERT(!(edges[startSetIndex][edge].area < F0), "");
      ASSERT(!(std::isnan(edges[startSetIndex][edge].area)), "");
      ASSERT(!(std::isnan(edges[startSetIndex][edge].center[0])), "");
      ASSERT(!(std::isnan(edges[startSetIndex][edge].center[1])), "");
      ASSERT(!(std::isinf(edges[startSetIndex][edge].area)), "");
      ASSERT(!(std::isinf(edges[startSetIndex][edge].center[0])), "");
      ASSERT(!(std::isinf(edges[startSetIndex][edge].center[1])), "");

      if(edges[startSetIndex][edge].edgeType > 1) { // body surface
        typename FvBndryCell<2, SysEqn>::BodySurface* bodySurface = bndryCell->m_srfcs[noBodySurfaces];
        bodySurface->m_area = edges[startSetIndex][edge].area;
        for(MInt i = 0; i < nDim; i++) {
          bodySurface->m_coordinates[i] = edges[startSetIndex][edge].center[i];
          bodySurface->m_normalVector[i] = edges[startSetIndex][edge].normal[i];
        }
        bodySurface->m_noCutPoints = 2;
        bodySurface->m_bndryCndId = m_movingBndryCndId;
        for(MInt cp = 0; (unsigned)cp < 2; cp++) {
          MInt vertex = edges[startSetIndex][edge].vertices[cp];
          isPartOfBodySurface[vertex] = true;
          MInt cutPointId = vertices[startSetIndex][vertex].pointId;
          newCutPointId[vertex] = cp;
          vertices[startSetIndex][vertex].cartSrfcId = noBodySurfaces;
          for(MInt i = 0; i < nDim; i++)
            bodySurface->m_cutCoordinates[cp][i] = vertices[startSetIndex][vertex].coordinates[i];
          if(cutPointId > -1) {
            bodySurface->m_cutEdge[cp] = pointEdgeId[cutPointId];
            bodySurface->m_bodyId[cp] = edges[startSetIndex][edge].bodyId;
          } else {
            bodySurface->m_cutEdge[cp] = -1;
            bodySurface->m_bodyId[cp] = edges[startSetIndex][edge].bodyId;
          }
        }
        noBodySurfaces++;
      } else { // Cartesian face
        MInt dirId = edges[startSetIndex][edge].edgeId;
        MInt srfcId = m_cellSurfaceMapping[cellId][dirId];

        if(srfcId > -1) {
          for(MInt i = 0; i < nDim; i++) {
            a_surfaceCoordinate(srfcId, i) = edges[startSetIndex][edge].center[i];
          }
          a_surfaceArea(srfcId) = edges[startSetIndex][edge].area;
          bndryCell->m_associatedSrfc[dirId] = srfcId;
        }
        m_cutFaceArea[bndryId][dirId] = edges[startSetIndex][edge].area;

        MInt nghbrId = c_neighborId(cellId, dirId);
        MInt nghbrBndryId = -1;
        if(nghbrId > -1) nghbrBndryId = a_bndryId(nghbrId);
        if(nghbrBndryId > -1) {
          m_bndryCells->a[nghbrBndryId].m_associatedSrfc[m_revDir[dirId]] = srfcId;
          m_cutFaceArea[nghbrBndryId][m_revDir[dirId]] = edges[startSetIndex][edge].area;
        }
      } // end else
    }

    bndryCell->m_noSrfcs = (MInt)noBodySurfaces;

    for(MInt srfc = 0; srfc < m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId = m_movingBndryCndId;
    }


    // transfer poly information to to output variables m_cutFacePointIds etc.
    m_noCutCellFaces[bndryId] = 0;
    const MInt maxPointsXD = 12;
    for(MInt c = 0; (unsigned)c < cutCells.size(); c++) {
      MInt nccf = m_noCutCellFaces[bndryId];
      m_noCutFacePoints[bndryId][nccf] = 0;
      for(MInt f = 0; (unsigned)f < cutCells[c].faces_edges.size(); f++) {
        MInt edge = cutCells[c].faces_edges[f];
        MInt vertex = edges[startSetIndex][edge].vertices[0];
        if(vertices[startSetIndex][vertex].pointType == 0) {
          m_cutFacePointIds[bndryId][maxPointsXD * nccf + m_noCutFacePoints[bndryId][nccf]] =
              vertices[startSetIndex][vertex].pointId;
          m_noCutFacePoints[bndryId][nccf]++;
        } else {
          if(!isPartOfBodySurface[vertex]) continue;
          MInt numCutPointsPreviousFaces = 0;
          for(MInt srfc = 0; srfc < vertices[startSetIndex][vertex].cartSrfcId; srfc++) {
            numCutPointsPreviousFaces += m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_noCutPoints;
          }
          MInt cp = numCutPointsPreviousFaces + newCutPointId[vertex];
          m_cutFacePointIds[bndryId][maxPointsXD * nccf + m_noCutFacePoints[bndryId][nccf]] = m_noCellNodes + (cp);
          m_noCutFacePoints[bndryId][nccf]++;
        }
      }
      m_noCutCellFaces[bndryId]++;
    }
  }
}


/** \page sensorsFVMB
 *
 *  \section patch Patch
 *
 *  This sensor triggers the refinement of predefined patches.<br>
 *  Special treatment for engine simulations.<br>
 *  Property: <code>PATCH</code>
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::sensorPatch(std::vector<std::vector<MFloat>>& sensors,
                                                      std::vector<std::bitset<64>>& sensorCellFlag,
                                                      std::vector<MFloat>& sensorWeight, MInt sensorOffset, MInt sen) {
  if(!m_engineSetup || !m_closeGaps) {
    this->patchRefinement(sensors, sensorCellFlag, sensorWeight, sensorOffset, sen);
  } else {
    // patch refinement only for certain crankAngles
    const MFloat cad = this->crankAngle(m_physicalTime, 0);

    // define crank angles for which the patch is necesary
    const MFloat duration = 5;
    if(m_forceNoGaps == 2
       && ((cad > m_gapAngleOpen[0] && cad < m_gapAngleOpen[0] + duration) || // first Opening
           (cad > m_gapAngleClose[0] - duration && cad < m_gapAngleClose[0])  // first Closure
           )) {
      if(domainId() == 0) {
        cerr << "Setting sensor Patch-refinement for current CA!" << endl;
      }

      this->patchRefinement(sensors, sensorCellFlag, sensorWeight, sensorOffset, sen);

      const MInt valveBodyId = 2;
      const MInt bodySet = m_bodyToSetTable[valveBodyId];
      for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
        const MInt gridCellId = grid().tree().solver2grid(cellId);
        if(sensors[sensorOffset + sen][gridCellId] > 0) {
          const MFloat valveDist = a_levelSetValuesMb(cellId, bodySet);
          if(fabs(valveDist) < 0.06757) continue;
          sensors[sensorOffset + sen][gridCellId] = 0;
          sensorCellFlag[gridCellId][sensorOffset + sen] = 0;
        }
        if(a_wasGapCell(cellId)) {
          sensors[sensorOffset + sen][gridCellId] = 1;
          sensorCellFlag[gridCellId][sensorOffset + sen] = 1;
        }
      }
    } else {
      if(domainId() == 0) {
        cerr << "Surpressing Patch-refinement for current CA!" << endl;
      }
    }
  }
}


/**
 * \brief correct old-BndryCells which are no-longer leaf-Cells after the adaptation
 *        NOTE: mas-conservative update, as before the mass of the coarse Cell was distributed
 *              upon all childs. Now that we know which childs will be avtive,
 *              the mass must be distributed to just the active cells!
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::correctRefinedBndryCell() {
  TRACE();

  vector<MInt> deletedBndryCells;
  vector<MInt> bndryChilds;
  std::map<MInt, MFloat> childBndryCells;
  std::map<MInt, MFloat> haloBndryCells;

  MInt noRefOldBndryCells = m_refOldBndryCells.size();
  MPI_Allreduce(MPI_IN_PLACE, &noRefOldBndryCells, 1, MPI_INT, MPI_SUM, mpiComm(), AT_, "MPI_IN_PLACE",
                "noRefOldBndryCells");

  if(noRefOldBndryCells == 0) return;

  m_log << "Correcting newly refined BndryCells after adaptation ...";

  // NOTE: noChildren on non-leaf-Level cells may differ between window-and halo cells!!!
  MIntScratchSpace noRelevantChilds(a_noCells(), AT_, "noRelevantChilds");
  noRelevantChilds.fill(-1);

  vector<MInt> refOldBndryCellsNew;

  for(MInt it = 0; it < (signed)m_refOldBndryCells.size(); it++) {
    const MInt cellId = m_refOldBndryCells[it];
    ASSERT(c_isLeafCell(cellId), "");

    if(a_hasProperty(cellId, SolverCell::IsInactive)) {
      // treat inactive oldBndryCells as if they were inactive before!
      a_hasProperty(cellId, SolverCell::WasInactive) = true;
      m_cellVolumesDt1[cellId] = grid().gridCellVolume(a_level(cellId));
      for(MInt v = 0; v < m_noFVars; v++) {
        m_rhs0[cellId][v] = 0;
      }
      auto it1 = m_oldBndryCells.find(cellId);
      m_oldBndryCells.erase(it1);
    } else {
      if(!a_isBndryCell(cellId)) {
        // treat uncut oldBndryCells as if they were active before!
        a_hasProperty(cellId, SolverCell::WasInactive) = false;
        m_cellVolumesDt1[cellId] = grid().gridCellVolume(a_level(cellId));
        for(MInt v = 0; v < m_noFVars; v++) {
          m_rhs0[cellId][v] = 0;
        }
        auto it1 = m_oldBndryCells.find(cellId);
        m_oldBndryCells.erase(it1);
      } else {
        // oldBndryCell is also newBndryCell
        a_hasProperty(cellId, SolverCell::WasInactive) = false;
        // save bndryCells to update m_refOldBndryCells with bndryCells which remain
        // bndryCells!
        refOldBndryCellsNew.push_back(cellId);
        if(a_isHalo(cellId)) continue;
        // count other BndryCells from the same parent!
        MInt noBndryCellChilds = 0;
        const MInt parent = c_parentId(cellId);
        for(MInt childId = 0; childId < IPOW2(nDim); childId++) {
          const MInt child = c_childId(parent, childId);
          if(child == -1) continue;
          if(a_isBndryCell(child)) noBndryCellChilds++;
        }
        ASSERT(noBndryCellChilds > 0, ""); // atleast the cellId
        noRelevantChilds(cellId) = noBndryCellChilds;
        // for mass-conservity the rhs0 parent (oldBndryCell) value must be split evenly
        // between all newBndryCells, as the values in all other cells are resetted!
        // setting the old Volume/sweptVolume based on currecnt values as in firstRHS
        // reduces pressure waves!
        // NOTE: as the boundaryVelocity is not set yet, the value will be updated in
        //      correctRefinedBndryCellVolume later!
        for(MInt v = 0; v < m_noFVars; v++) {
          m_rhs0[cellId][v] = m_rhs0[parent][v] / noBndryCellChilds;
        }
      }
    }
  }

  exchangeData(&noRelevantChilds[0],
               1); // Skip azimuthal exchange since infromation on azimuthal windows and halos is not the same

  for(MInt cellId = noInternalCells(); cellId < c_noCells(); cellId++) {
    ASSERT(a_isHalo(cellId), "");
    if(!a_isBndryCell(cellId)) continue;
    auto it = std::find(m_refOldBndryCells.begin(), m_refOldBndryCells.end(), cellId);
    if(it != m_refOldBndryCells.end()) {
      MInt noBndryCellChilds = noRelevantChilds(cellId);
      const MInt parent = c_parentId(cellId);
      for(MInt v = 0; v < m_noFVars; v++) {
        m_rhs0[cellId][v] = m_rhs0[parent][v] / noBndryCellChilds;
      }
    }
  }

  m_refOldBndryCells.clear();

  // now add old bndryCells which will remain bndryCell!
  for(MInt it = 0; it < (signed)refOldBndryCellsNew.size(); it++) {
    const MInt cellId = refOldBndryCellsNew[it];
    m_refOldBndryCells.push_back(cellId);
  }

  m_log << " Finished" << endl;
}


/**
 * \brief correct BndryCells volume of bndryCells which were a bndryCell on a coarser level before
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::correctRefinedBndryCellVolume() {
  TRACE();

  for(MInt it = 0; it < (signed)m_refOldBndryCells.size(); it++) {
    const MInt cellId = m_refOldBndryCells[it];
    ASSERT(c_isLeafCell(cellId), "");
    ASSERT(a_isBndryCell(cellId), "");

    MFloat dV = F0;
    MFloat dt = timeStep(true);
    const MInt bndryId = a_bndryId(cellId);
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      MFloat area = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
      for(MInt i = 0; i < nDim; i++) {
        MFloat nml = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
        dV -= dt * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] * nml * area;
      }
    }
    const MFloat deltaVol = m_RKalpha[m_noRKSteps - 2] * dV + (F1 - m_RKalpha[m_noRKSteps - 2]) * dV;

    // old values are set based on the current values!
    // not exactly mass-conservative, but reduces pressure problems at the newly refined bndry!
    m_cellVolumesDt1[cellId] = mMax(m_volumeThreshold, a_cellVolume(cellId) - deltaVol);
    m_sweptVolumeDt1[bndryId] = dV;

    auto it1 = m_oldBndryCells.find(cellId);
    ASSERT(it1 != m_oldBndryCells.end(), "");
    m_oldBndryCells.erase(it1);
    m_oldBndryCells.insert(make_pair(cellId, dV));
  }
  m_refOldBndryCells.clear();
}


/**
 * \brief correct BndryCells volume of bndryCells which were a bndryCell on a coarser level before
 * \author Tim Wegmann
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::correctCoarsenedBndryCellVolume() {
  TRACE();

  for(auto it = m_coarseOldBndryCells.begin(); it != m_coarseOldBndryCells.end(); it++) {
    const MInt cellId = *it;
    ASSERT(c_isLeafCell(cellId), "");

    if(a_isBndryCell(cellId)) {
      MFloat dV = F0;
      MFloat dt = timeStep(true);
      const MInt bndryId = a_bndryId(cellId);
      for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
        MFloat area = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area;
        for(MInt i = 0; i < nDim; i++) {
          MFloat nml = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_normalVector[i];
          dV -= dt * m_fvBndryCnd->m_bndryCell[bndryId].m_srfcVariables[srfc]->m_primVars[PV->VV[i]] * nml * area;
        }
      }

      // old values are set based on the current values!
      // not exactly mass-conservative, but reduces pressure problems at the newly refined bndry!
      const MFloat deltaVol = m_RKalpha[m_noRKSteps - 2] * dV + (F1 - m_RKalpha[m_noRKSteps - 2]) * dV;
      m_cellVolumesDt1[cellId] = mMax(m_volumeThreshold, a_cellVolume(cellId) - deltaVol);
      m_sweptVolumeDt1[bndryId] = dV;

      auto it1 = m_oldBndryCells.find(cellId);
      ASSERT(it1 != m_oldBndryCells.end(), "");
      m_oldBndryCells.erase(it1);
      m_oldBndryCells.insert(make_pair(cellId, dV));
    }
  }

  m_coarseOldBndryCells.clear();
}


/**
 * \brief determines the geometric cut-cell data
 * \author Claudia Guenther
 */
template <MInt nDim, class SysEqn>
template <class _, std::enable_if_t<nDim == 3, _*>>
ATTRIBUTES1(ATTRIBUTE_NO_AUTOVEC)
void FvMbCartesianSolverXD<nDim, SysEqn>::createCutFaceMb_MGC() {
  TRACE();

  // returns the dir in which the cutPoint on the edge is not 1 or -1
  const MInt DOFStencil[12] = {1, 1, 0, 0, 1, 1, 0, 0, 2, 2, 2, 2};
  NEW_SUB_TIMER_STATIC(tCutFace_00, "cutFaceNew_00", m_tCutGroup);
  RECORD_TIMER_START(tCutFace_00);

  using CC = CutCell<nDim>;
  std::vector<CC> cutCellData;

  std::vector<MInt> cutCellIdMapping;
  cutCellIdMapping.resize(a_noCells());
  for(MInt i = 0; i < a_noCells(); i++) {
    cutCellIdMapping[i] = -1;
  }

  cutCellData.reserve((signed)m_fvBndryCnd->m_bndryCells->size() - m_noOuterBndryCells);
  // plus 1 percent for split cells?

  MInt cnt = 0;
  ASSERT(m_noLevelSetsUsedForMb <= CC::maxNoSets, "");
  const MInt faceCornerMapping[6][4] = {{2, 6, 4, 0}, {1, 5, 7, 3}, {0, 4, 5, 1},
                                        {3, 7, 6, 2}, {2, 3, 1, 0}, {6, 7, 5, 4}};
  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    const MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    cutCellData.emplace_back();
    cutCellData[cnt].cellId = cellId;
    cutCellData[cnt].isGapCell = false;
    cutCellIdMapping[cellId] = cnt;
    if(m_levelSet && m_closeGaps) {
      cutCellData[cnt].isGapCell = (a_hasProperty(cellId, SolverCell::IsGapCell));
    }
    ASSERT(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints <= CC::maxNoCutPoints, "");
    cutCellData[cnt].noCutPoints = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints;
    for(MInt cp = 0; cp < m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_noCutPoints; cp++) {
      const MInt cutEdge = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cp];
      const MInt nonZeroDir = DOFStencil[cutEdge];

      for(MInt k = 0; k < nDim; k++) {
        MFloat cutCoordinate = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cp][k];
        // NOTE: scaling cut-coordinate to the range of -1,1!
        if(m_geometryIntersection->m_scaledCutCell) {
          const MFloat cellLength = c_cellLengthAtLevel(a_cutCellLevel(cellId));
          const MFloat cellHalfLength = F1B2 * cellLength;
          cutCoordinate = (cutCoordinate - a_coordinate(cellId, k)) / cellHalfLength;

          if(k != nonZeroDir) {
            // cutCoordinate should be F1 or -F1!
            if(cutCoordinate > F0) {
              cutCoordinate = F1;
            } else {
              cutCoordinate = -F1;
            }
          } else {
            // cut Coordinate should be between (-F1 + 20 * m_eps)  and (F1 - 20 * m_eps)
            if(cutCoordinate > F1 - 20 * m_eps) cutCoordinate = F1 - 20 * m_eps;
            if(cutCoordinate < -F1 + 20 * m_eps) cutCoordinate = -F1 + 20 * m_eps;
          }
        }
        cutCellData[cnt].cutPoints[cp][k] = cutCoordinate;
      }


      cutCellData[cnt].cutBodyIds[cp] = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_bodyId[cp];
      cutCellData[cnt].cutEdges[cp] = m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_cutEdge[cp];
    }
    MInt cndId = m_bndryCandidateIds[cellId];
    if(cndId < 0) mTerm(1, AT_, "error: cell is not a bndryCandidate!");
    for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
      cutCellData[cnt].associatedBodyIds[set] = a_associatedBodyIds(cellId, set);
      for(MInt k = 0; k < CC::noCorners; k++) {
        if(!m_candidateNodeSet[cndId * m_noCellNodes + k]) cerr << "Warning: node not set!" << endl;
        cutCellData[cnt].cornerIsInsideGeometry[set][k] = m_pointIsInside[bndryId][IDX_LSSETMB(k, set)];
      }
      for(MInt k = 0; k < CC::noFaces; k++) {
        MFloat phi = F0;
        for(MInt j = 0; j < 4; j++) {
          phi += F1B4 * m_candidateNodeValues[IDX_LSSETNODES(cndId, faceCornerMapping[k][j], set)];
        }
        cutCellData[cnt].faceCentroidIsInsideGeometry[set][k] = (phi < F0);
      }
    }
    cnt++;
  }

  const MUint noCutCells = cutCellData.size();

  // debug-output:
  // check that the cut-edges, match with the according corner ls-values!
  MBool debugOutput = false;
  if(debugOutput && domainId() == 302 && globalTimeStep == -1) {
    MInt cutCellId = 10;
    MInt neighborCutCellId = 30;
    MInt neighbrId = cutCellData[neighborCutCellId].cellId;

    MInt cellId = cutCellData[cutCellId].cellId;
    MInt cndId = m_bndryCandidateIds[cellId];

    cerr << "Found " << cutCellData[cutCellId].noCutPoints << " Cut-Points for CellId " << cellId << endl;
    cerr << "Cut edges are: " << endl;
    for(MInt cp = 0; cp < cutCellData[cutCellId].noCutPoints; cp++) {
      cerr << " Cut-Point " << cp << " " << cutCellData[cutCellId].cutEdges[cp] << endl;
    }

    cerr << "Corner-values are: " << endl;
    for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
      for(MInt k = 0; k < CC::noCorners; k++) {
        cerr << set << " " << m_candidateNodeValues[IDX_LSSETNODES(cndId, k, set)];
      }
      cerr << endl;
    }

    cerr << "Found " << cutCellData[neighborCutCellId].noCutPoints << " Cut-Points for neighborCutCellId " << neighbrId
         << endl;
    cerr << "Cut edges are: " << endl;
    for(MInt cp = 0; cp < cutCellData[neighborCutCellId].noCutPoints; cp++) {
      cerr << " Cut-Point " << cp << " " << cutCellData[neighborCutCellId].cutEdges[cp] << endl;
    }

    MInt nghbrCndId = m_bndryCandidateIds[neighbrId];

    cerr << "Corner-values are: " << endl;
    for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
      for(MInt k = 0; k < CC::noCorners; k++) {
        cerr << set << " " << m_candidateNodeValues[IDX_LSSETNODES(nghbrCndId, k, set)];
      }
      cerr << endl;
    }
  }

  // Performe Cut-Cell-Checks:
  for(MUint cutc = 0; cutc < noCutCells; cutc++) {
    // 1) Have at least nDim Cut-Cells
    if(cutCellData[cutc].noCutPoints < nDim) {
      mTerm(1, AT_, "CutCell with less than nDim CutPoints");
    }
    ASSERT(cutCellData[cutc].cellId == m_fvBndryCnd->m_bndryCells->a[cutc + m_noOuterBndryCells].m_cellId, "");

    MInt startSet = 0;
    MInt endSet = 1;
    if(m_complexBoundary && (!cutCellData[cutc].isGapCell)) {
      startSet = 1;
      endSet = m_noLevelSetsUsedForMb;
    }

    // 2) cornerIsInsideGeometry must fit with the corner LS-value!
    MInt cndId = m_bndryCandidateIds[cutCellData[cutc].cellId];
    for(MInt set = startSet; set < endSet; set++) {
      for(MInt k = 0; k < CC::noCorners; k++) {
        if(cutCellData[cutc].cornerIsInsideGeometry[set][k]) {
          ASSERT(m_candidateNodeValues[IDX_LSSETNODES(cndId, k, set)] < F0, "");
        } else {
          ASSERT(m_candidateNodeValues[IDX_LSSETNODES(cndId, k, set)] > F0,
                 "ERROR in " + to_string(domainId()) + " " + to_string(cutCellData[cutc].cellId) + " "
                     + to_string(c_globalId(cutCellData[cutc].cellId)) + " " + to_string(k) + " "
                     + to_string(m_candidateNodeValues[IDX_LSSETNODES(cndId, k, set)]));
        }
      }
    }
  }

  const MInt maxNoVertices = 300;
  const MInt noBndryCells = m_fvBndryCnd->m_bndryCells->size();
  MIntScratchSpace splitFaceCellIds(m_fvBndryCnd->m_maxNoBndryCells, AT_, "splitFaceCellIds");
  for(MInt c = 0; c < m_fvBndryCnd->m_maxNoBndryCells; c++)
    splitFaceCellIds[c] = -1;
  MIntScratchSpace splitCellIds(noBndryCells, AT_, "splitCellIds");
  std::vector<cellWithSplitFace> splitFaceCells;
  MIntScratchSpace surfaceIdentificatorCounters(m_noDirs + m_noEmbeddedBodies, AT_, "surfaceIdentificatorCounters");
  MIntScratchSpace cellSurfaceMapping_backup(m_noDirs, AT_, "cellSurfaceMapping_backup");
  MIntScratchSpace splitCellList(CC::maxSplitCells, AT_, "splitCellList");

  const MFloat signStencil[8][3] = {{-F1, -F1, -F1}, {F1, -F1, -F1}, {-F1, F1, -F1}, {F1, F1, -F1},
                                    {-F1, -F1, F1},  {F1, -F1, F1},  {-F1, F1, F1},  {F1, F1, F1}};

  const MInt faceCornerCode[6][4] = {{0, 2, 6, 4}, // in MAIA
                                     {3, 1, 5, 7}, {1, 0, 4, 5}, {2, 3, 7, 6}, {0, 1, 3, 2}, {5, 4, 6, 7}};

  RECORD_TIMER_STOP(tCutFace_00);

  m_geometryIntersection->computeCutFaces(cutCellData, FvBndryCell<nDim, SysEqn>::m_maxNoSurfaces, m_tCutGroup);

  // debugging-Output:
  debugOutput = false;
  MInt debugTimeStep = -1; // 33
  MInt debugDomainId = 302;
  MInt debugCellId = 23192;
  MInt debugNeighborId = 23160;
  MInt debugDir = 4;
  MInt reverseDir = m_revDir[debugDir];
  MInt debugSrfcId = m_cellSurfaceMapping[debugCellId][debugDir];

  if(debugOutput && globalTimeStep == debugTimeStep && domainId() == debugDomainId) {
    MInt debugCutCellId = -1;
    MInt debugNeighborCutCellId = -1;

    ASSERT(m_cellSurfaceMapping[debugCellId][debugDir], "");

    cerr << "Debug-Surface-Id is " << debugSrfcId << " with " << endl;
    cerr << "Surface-Neighbor-0 " << a_surfaceNghbrCellId(debugSrfcId, 0) << endl;
    cerr << "Surface-Neighbor-1 " << a_surfaceNghbrCellId(debugSrfcId, 1) << endl;

    if(debugSrfcId > -1) {
      if(a_surfaceNghbrCellId(debugSrfcId, 0) == debugCellId) {
        debugNeighborId = a_surfaceNghbrCellId(debugSrfcId, 1);
      } else {
        debugNeighborId = a_surfaceNghbrCellId(debugSrfcId, 0);
      }
    }

    for(MUint cutc = 0; cutc < noCutCells; cutc++) {
      if(cutCellData[cutc].cellId == debugNeighborId) {
        cerr << "Neighbor CutCellId " << cutc << endl;
        debugNeighborCutCellId = cutc;
      }
      if(cutCellData[cutc].cellId == debugCellId) {
        cerr << "Cell CutCellId " << cutc << endl;
        debugCutCellId = cutc;
      }
    }

    MInt cellSet = a_associatedBodyIds(debugCellId, 0);
    MInt neighborSet = a_associatedBodyIds(debugNeighborId, 0);

    cerr << "Cell-Set: " << cellSet;
    cerr << "Neighbor-Set: " << neighborSet;

    if(debugCutCellId > -1) {
      cerr << "Cell-CutCellInfo " << cutCellData[debugCutCellId].cellId << " has "
           << cutCellData[debugCutCellId].noSplitChilds << " SplitChilds and "
           << cutCellData[debugCutCellId].noFacesPerCartesianDir[debugDir] << " Faces in the debug-Direction!"
           << "The ls-vales of the face are: " << endl;
      for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
        for(MInt corner = 0; corner < 4; corner++) {
          cerr << set << " " << setprecision(16)
               << m_candidateNodeValues[IDX_LSSETNODES(m_bndryCandidateIds[debugCellId],
                                                       faceCornerCode[debugDir][corner], set)];
        }
        cerr << endl;
      }
    }

    if(debugNeighborCutCellId) {
      cerr << "Neighbor-CutCellInfo " << cutCellData[debugNeighborCutCellId].cellId << " has "
           << cutCellData[debugNeighborCutCellId].noSplitChilds << " SplitChilds and "
           << cutCellData[debugNeighborCutCellId].noFacesPerCartesianDir[reverseDir]
           << " Faces in the reverse-debug-Direction!"
           << "The ls-vales of the face are: " << endl;
      for(MInt set = 0; set < m_noLevelSetsUsedForMb; set++) {
        for(MInt corner = 0; corner < 4; corner++) {
          cerr << set << " " << setprecision(16)
               << m_candidateNodeValues[IDX_LSSETNODES(m_bndryCandidateIds[debugNeighborId],
                                                       faceCornerCode[reverseDir][corner], set)];
        }
        cerr << endl;
      }
    }
    cerr << "Coordiantes: " << a_coordinate(debugCellId, 0) << " " << a_coordinate(debugCellId, 1) << " "
         << a_coordinate(debugCellId, 2) << endl;
    cerr << "Coordinates2: " << a_coordinate(debugNeighborId, 0) << " " << a_coordinate(debugNeighborId, 1) << " "
         << a_coordinate(debugNeighborId, 2) << endl;
  }


  NEW_SUB_TIMER_STATIC(tCutFace_8, "cutFaceNew_8", m_tCutGroup);
  NEW_SUB_TIMER_STATIC(tCutFace_9, "cutFaceNew_9", m_tCutGroup);
  NEW_SUB_TIMER_STATIC(tCutFace_10, "cutFaceNew_10", m_tCutGroup);

  RECORD_TIMER_START(tCutFace_8);

  // a) add split-childs to the fvmb-cell-collector
  for(MUint cutc = 0; cutc < noCutCells; cutc++) {
    const MInt cellId = cutCellData[cutc].cellId;
    const MInt bndryId = a_bndryId(cellId);
    MInt noSplitChildren = cutCellData[cutc].noSplitChilds;

    MInt splitCellId = -1;
    if(noSplitChildren > 1) {
      // uses newst splitCell-Version:
      splitCellId = createSplitCell(cellId, noSplitChildren);
      for(MInt sc = 0; sc < noSplitChildren; sc++) {
        MUint splitcutc = cutCellData[cutc].splitChildIds[sc];

        MInt splitChildId = m_splitChilds[splitCellId][sc];
        cutCellData[splitcutc].cellId = splitChildId;
      }
    }
    splitCellIds(bndryId) = splitCellId;
  }

  // update coordinate and length of the scaled cutCell:
  if(m_geometryIntersection->m_scaledCutCell) {
    for(MUint cutc = 0; cutc < cutCellData.size(); cutc++) {
      const MInt cellId = cutCellData[cutc].cellId;
      const MInt bndryId = a_bndryId(cellId);
      const MFloat cellLength = c_cellLengthAtLevel(a_cutCellLevel(cellId));
      const MFloat cellHalfLength = F1B2 * cellLength;

      for(MInt cpId = 0; cpId < cutCellData[cutc].noCutPoints; cpId++) {
        for(MInt i = 0; i < nDim; i++) {
          cutCellData[cutc].cutPoints[cpId][i] =
              cutCellData[cutc].cutPoints[cpId][i] * cellHalfLength + a_coordinate(cellId, i);

          ASSERT(fabs(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[0]->m_cutCoordinates[cpId][i]
                      - cutCellData[cutc].cutPoints[cpId][i])
                     < 0.00000001,
                 "");
        }
      }

      cutCellData[cutc].volume = cutCellData[cutc].volume * POW3(cellHalfLength);
      if(cutCellData[cutc].volume < m_eps) cutCellData[cutc].volume = m_eps;

      // NOTE: the volumetricCentroid is the distance to the cartesian Cell center
      //      and not to the origin!
      for(MInt i = 0; i < nDim; i++) {
        cutCellData[cutc].volumetricCentroid[i] = cutCellData[cutc].volumetricCentroid[i] * cellHalfLength;
      }

      for(MInt bs = 0; bs < cutCellData[cutc].noBoundarySurfaces; bs++) {
        for(MInt i = 0; i < nDim; i++) {
          cutCellData[cutc].boundarySurfaceCentroid[bs][i] =
              cutCellData[cutc].boundarySurfaceCentroid[bs][i] * cellHalfLength + a_coordinate(cellId, i);
        }
        cutCellData[cutc].boundarySurfaceArea[bs] = cutCellData[cutc].boundarySurfaceArea[bs] * POW2(cellHalfLength);

        if(cutCellData[cutc].boundarySurfaceArea[bs] < m_eps) cutCellData[cutc].boundarySurfaceArea[bs] = m_eps;
      }


      for(MInt cs = 0; cs < cutCellData[cutc].noCartesianSurfaces; cs++) {
        for(MInt i = 0; i < nDim; i++) {
          cutCellData[cutc].cartFaceCentroid[cs][i] =
              cutCellData[cutc].cartFaceCentroid[cs][i] * cellHalfLength + a_coordinate(cellId, i);
        }
        cutCellData[cutc].cartFaceArea[cs] = cutCellData[cutc].cartFaceArea[cs] * POW2(cellHalfLength);

        if(cutCellData[cutc].cartFaceArea[cs] < m_eps) cutCellData[cutc].cartFaceArea[cs] = m_eps;
      }

      for(MInt aId = 0; aId < cutCellData[cutc].noAdditionalVertices; aId++) {
        for(MInt i = 0; i < nDim; i++) {
          cutCellData[cutc].additionalVertices[aId][i] =
              cutCellData[cutc].additionalVertices[aId][i] * cellHalfLength + a_coordinate(cellId, i);
        }
      }
    }
  }


  // b) convert data back from the geometry-intersection class to the old bndryCell class!
  for(MUint cutc = 0; cutc < cutCellData.size(); cutc++) {
    // MInt bndryId = cutCellData[cutc].cutCellId;
    const MInt cellId = cutCellData[cutc].cellId;
    const MInt bndryId = a_bndryId(cellId);
    MInt splitParentId = cutCellData[cutc].splitParentId;
    MInt noSplitChilds = cutCellData[cutc].noSplitChilds;
    FvBndryCell<nDim, SysEqn>* bndryCell = &m_fvBndryCnd->m_bndryCells->a[bndryId];
    if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId != cutCellData[cutc].cellId) {
      cerr << domainId() << ": diff0 " << cutc << " " << noSplitChilds << " " << splitParentId << " "
           << m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId << " " << cutCellData[cutc].cellId << endl;
      continue;
    }
    bndryCell->m_volume = cutCellData[cutc].volume;
    for(MInt i = 0; i < nDim; i++) {
      bndryCell->m_coordinates[i] = cutCellData[cutc].volumetricCentroid[i];
    }
    MInt noSrfcs = cutCellData[cutc].noBoundarySurfaces;
    bndryCell->m_noSrfcs = noSrfcs;
    for(MInt bs = 0; bs < noSrfcs; bs++) {
      typename FvBndryCell<3, SysEqn>::BodySurface* bodySurface = bndryCell->m_srfcs[bs];
      for(MInt i = 0; i < nDim; i++) {
        bodySurface->m_coordinates[i] = cutCellData[cutc].boundarySurfaceCentroid[bs][i];
        bodySurface->m_normalVector[i] = cutCellData[cutc].boundarySurfaceNormal[bs][i];
      }
      bodySurface->m_area = cutCellData[cutc].boundarySurfaceArea[bs];

      cutCellData[cutc].boundarySurfaceBndryCndId[bs] = m_movingBndryCndId;

      bodySurface->m_bndryCndId = cutCellData[cutc].boundarySurfaceBndryCndId[bs];
      bodySurface->m_bodyId[0] = cutCellData[cutc].boundarySurfaceBodyId[bs];

      for(MInt f = 0; f < 2 * nDim; f++) {
        bndryCell->m_externalFaces[f] = cutCellData[cutc].externalFaces[f];
      }
      for(MInt c = 0; c < IPOW2(nDim); c++) {
        m_pointIsInside[bndryId][IDX_LSSETMB(c, 0)] = cutCellData[cutc].cornerIsInsideGeometry[0][c];
      }
    }
  }

  for(MUint cutc = 0; cutc < noCutCells; cutc++) {
    // MInt bndryId = cutCellData[cutc].cutCellId;
    const MInt cellId = cutCellData[cutc].cellId;
    const MInt bndryId = a_bndryId(cellId);
    FvBndryCell<nDim, SysEqn>* bndryCell = &m_fvBndryCnd->m_bndryCells->a[bndryId];
    const MFloat cellLength0 = c_cellLengthAtLevel(a_level(cellId));
    const MFloat cellHalfLength = F1B2 * cellLength0;
    MInt noSplitChildren = cutCellData[cutc].noSplitChilds;
    MInt splitCellId = splitCellIds(bndryId);


    // c) create a cellSurfaceMapping_backup and the splitCellList
    //   CAUTION: set noSplitChildren to 1 for all regular cells!
    for(MInt dir = 0; dir < m_noDirs; dir++) {
      cellSurfaceMapping_backup[dir] = m_cellSurfaceMapping[cellId][dir];
    }

    if(noSplitChildren > 1) {
      ASSERT(splitCellId > -1, "");
      for(MInt sc = 0; sc < noSplitChildren; sc++) {
        splitCellList[sc] = cutCellData[cutc].splitChildIds[sc];
      }
    } else {
      noSplitChildren = 1;
      splitCellList[0] = cutc;
    }

    // d) reset the cellSurfaceMapping and
    //    delete all surfaces for neighboring cells with splitChildren
    //    othweise reset the surface-neighbors between a regular cutCell
    //    and a cell with splitChilds
    if(noSplitChildren > 1) {
      for(MInt f = 0; f < m_noDirs; f++) {
        bndryCell->m_associatedSrfc[f] = -2;
        // if a cell with splitChildren has existing surfaces, they will be corrected later
        MInt srfcId = m_cellSurfaceMapping[cellId][f];
        if(srfcId > -1) {
          MInt nghbr0 = a_surfaceNghbrCellId(srfcId, 0);
          MInt nghbr1 = a_surfaceNghbrCellId(srfcId, 1);

          if(debugOutput && globalTimeStep == debugTimeStep && domainId() == debugDomainId && srfcId == debugSrfcId) {
            cerr << "Accesing Debug-surface! Nghbrs are : " << nghbr0 << " " << nghbr1 << "Due to " << noSplitChildren
                 << "splitChilds at CutCellId " << cellId << endl;
          }

          if(nghbr0 == cellId) {
            a_surfaceNghbrCellId(srfcId, 0) = -2;
            nghbr0 = -2;
          } else if(nghbr1 == cellId) {
            a_surfaceNghbrCellId(srfcId, 1) = -2;
            nghbr1 = -2;
          }

          // if other neighbor of surface is already non-existent, delete the surface
          if(nghbr0 < 0 && nghbr1 < 0) {
            a_surfaceArea(srfcId) = F0;
            //            m_isActiveSurface[ srfcId ] = false;
            deleteSurface(srfcId);
          }
          m_cellSurfaceMapping[cellId][f] = -2;
        }
      }
    }

    // e) now going over all Cut-Cells
    //  - once for regular CutCells     : noSplitChildren = 1 and cutCellId = cutc
    //  - once for each SplitChild for Split-Cells : cutCellId = splitChildIds
    for(MInt sc = 0; sc < noSplitChildren; sc++) {
      MInt splitChildId = cellId;
      MInt scBndryId = bndryId;
      FvBndryCell<nDim, SysEqn>* scBndryCell = &m_fvBndryCnd->m_bndryCells->a[scBndryId];
      if(splitCellId > -1) {
        splitChildId = m_splitChilds[splitCellId][sc];
        scBndryId = a_bndryId(splitChildId);
        scBndryCell = &m_fvBndryCnd->m_bndryCells->a[scBndryId];
      }
      ASSERT(scBndryId > -1, " ");

      MInt cutCellId = splitCellList[sc];
      if(noSplitChildren == 1) ASSERT(cutCellId == (MInt)cutc, "");
      ASSERT(cutCellData[cutCellId].cellId == splitChildId, "");


      // f) for all SplitChilds which have multiple-faces in any cartesian direction:
      for(MInt i = 0; i < m_noDirs; i++) {
        if(cutCellData[cutCellId].noFacesPerCartesianDir[i] > 1) {
          //--RELOC2--

          a_hasProperty(cellId, SolverCell::HasSplitFace) = true;
          // prepare cell/surfaces
          MInt id = splitFaceCellIds[scBndryId];
          if(id < 0) {
            id = splitFaceCells.size();
            splitFaceCells.push_back(cellWithSplitFace(splitChildId));
            splitFaceCellIds[scBndryId] = id;
          }
          cellWithSplitFace* scsCell = &splitFaceCells[id];
          scsCell->splitFaces.push_back(splitCartesianFace(i));

          bndryCell->m_associatedSrfc[i] = -2;
          // if cell has existing surfaces, they should not point to this cell anymore. Will be corrected later
          // if other neighbor of surface is already non-existent, delete the surface
          MInt srfcId = m_cellSurfaceMapping[splitChildId][i];
          if(srfcId > -1) {
            MInt nghbr0 = a_surfaceNghbrCellId(srfcId, 0);
            MInt nghbr1 = a_surfaceNghbrCellId(srfcId, 1);

            if(debugOutput && globalTimeStep == debugTimeStep && domainId() == debugDomainId && srfcId == debugSrfcId) {
              cerr << "Accesing Debug-surface! Nghbrs are : " << nghbr0 << " " << nghbr1 << "with CutCellId"
                   << cutCellId << "due to " << cutCellData[cutCellId].noFacesPerCartesianDir[i]
                   << " faces in direction " << i << endl;
            }

            if(nghbr0 == splitChildId) {
              a_surfaceNghbrCellId(srfcId, 0) = -2;
              nghbr0 = -2;
            } else if(nghbr1 == splitChildId) {
              a_surfaceNghbrCellId(srfcId, 1) = -2;
              nghbr1 = -2;
            }
            if(nghbr0 < 0 && nghbr1 < 0) {
              a_surfaceArea(srfcId) = F0;
              //              m_isActiveSurface[ srfcId ] = false;
              deleteSurface(srfcId);
            }
            m_cellSurfaceMapping[splitChildId][i] = -2;
          }
        }
      }

      // g) Remove surfaces which do not have any cartesian or boundary-surfaces and set the Cells
      //   inactive!
      if(cutCellData[cutCellId].noCartesianSurfaces == 0 && cutCellData[cutCellId].noBoundarySurfaces == 0) {
        a_hasProperty(splitChildId, SolverCell::IsInactive) = true;
        a_hasProperty(splitChildId, SolverCell::IsOnCurrentMGLevel) = false;
        removeSurfaces(splitChildId);
      }


      // h) Remove surfaces of active-Cells where only part of the Cell has non-fluid faces:
      for(MInt f = 0; f < m_noDirs; f++) {
        if(cutCellData[cutCellId].noFacesPerCartesianDir[f] == 0) { // non fluid face
          scBndryCell->m_externalFaces[f] = true;
          //          cutCellData[cutCellId].externalFaces[f] = true;
          if(splitCellId < 0) {
            MInt srfcId = m_cellSurfaceMapping[cellId][f];

            if(debugOutput && globalTimeStep == debugTimeStep && domainId() == debugDomainId && srfcId == debugSrfcId
               && srfcId > -1) {
              cerr << "Deleting surface " << srfcId << " on accord of " << cellId << " with zero faces in direction "
                   << f << " is externalFace instead " << cutCellData[cutCellId].externalFaces[f] << endl;

              cerr << "Cell is an original SplitCell: " << splitCellId << " with "
                   << cutCellData[cutCellId].noSplitChilds << " # of SplitChildren and "
                   << cutCellData[cutCellId].noCartesianSurfaces << " Totalfaces. " << endl;
            }

            if(srfcId > -1) {
              a_surfaceArea(srfcId) = F0;
              deleteSurface(srfcId);
            }
            bndryCell->m_associatedSrfc[f] = -1;
            m_cutFaceArea[bndryId][f] = F0;

            MInt nghbrId = c_neighborId(cellId, f);
            MInt nghbrBndryId = -1;
            if(nghbrId > -1) nghbrBndryId = a_bndryId(nghbrId);
            if(nghbrBndryId > -1) {
              m_bndryCells->a[nghbrBndryId].m_associatedSrfc[m_revDir[f]] = -1;
              m_cutFaceArea[nghbrBndryId][m_revDir[f]] = F0;
            }
          }
        }
      }

      //--RELOC4--
      for(MInt srf = 0; srf < cutCellData[cutCellId].noCartesianSurfaces; srf++) {
        MInt dirId = cutCellData[cutCellId].cartFaceDir[srf];
        // MInt spaceId = dirId/2;
        MInt srfcId = m_cellSurfaceMapping[splitChildId][dirId];
        // for regular cells the cellSurfaceMapping should be intakt!

        if(cutCellData[cutCellId].noFacesPerCartesianDir[dirId] > 1) {
          // for multiple faces in this direction;
          MInt sfCellId = splitFaceCellIds[scBndryId];
          cellWithSplitFace* sfCell = &splitFaceCells[sfCellId];
          // search the right split surface of ssCell:
          MInt sf = -1;
          for(MInt s = 0; (unsigned)s < sfCell->splitFaces.size(); s++) {
            MInt sfDir = sfCell->splitFaces[s].direction;
            if(sfDir == dirId) { // found it!
              sf = s;
              break;
            }
          }
          ASSERT(sf > -1, "");
          ASSERT(srfcId < 0, "");
          // check if a surface should be generated! Don't create surfaces:
          // - between two halo cells
          // - if the cell doesn't have a neighbor in that direction (at the last halo-layer!)
          MBool createSrfc = true;
          if(a_isHalo(cellId)) {
            if(a_hasNeighbor(cellId, dirId)) {
              if(a_isHalo(c_neighborId(cellId, dirId))) {
                createSrfc = false;
              }
            } else {
              createSrfc = false;
            }
          }
          if(createSrfc) {
            srfcId = getNewSurfaceId();
            createSurfaceSplit(srfcId, cellId, splitChildId, dirId);
            sfCell->splitFaces[sf].srfcIds.push_back(srfcId);
            m_cellSurfaceMapping[splitChildId][dirId] = -2; // indicate split surface
          }
        } else if(splitCellId > -1) {
          // for a split cell, but no split surface in this direction
          ASSERT(srfcId < 0, "");
          // check if a surface should be generated! Don't create surfaces:
          // - between two halo cells
          // - if the cell doesn't have a neighbor in that direction (at the last halo-layer!)
          MBool createSrfc = true;
          if(a_isHalo(cellId)) {
            if(a_hasNeighbor(cellId, dirId)) {
              MInt nghbrTmp = c_neighborId(cellId, dirId);
              if(a_isHalo(nghbrTmp)) {
                createSrfc = false;
              }
            } else {
              createSrfc = false;
            }
          }
          if(createSrfc) {
            srfcId = getNewSurfaceId();
            createSurfaceSplit(srfcId, cellId, splitChildId, dirId);
            m_cellSurfaceMapping[splitChildId][dirId] = srfcId;
          }
        }

        if(srfcId > -1) {
          // update surface area and coordinate for regular cells!
          for(MInt i = 0; i < nDim; i++) {
            a_surfaceCoordinate(srfcId, i) = cutCellData[cutCellId].cartFaceCentroid[srf][i];
          }
          a_surfaceArea(srfcId) = cutCellData[cutCellId].cartFaceArea[srf];

          if(cutCellData[cutCellId].noFacesPerCartesianDir[dirId] == 1) {
            // do not set this for split faces
            scBndryCell->m_associatedSrfc[dirId] = srfcId;
          }
        } else { // srfcId < -1
          if(a_hasNeighbor(cellId, dirId) > 0 && (!a_isHalo(cellId))) {
            ASSERT(a_level(cellId) == a_level(c_neighborId(cellId, dirId)), "");

            // at the level jump the cell-surface-mapping may be broken!
            // check that the surface from the neighbor child is correct!
            if(!c_isLeafCell(c_neighborId(cellId, dirId))) {
              const MInt nghbrId = c_neighborId(cellId, dirId);
              ASSERT(c_noChildren(nghbrId) > 0, "");
              MBool foundNgbrSrfc = false;
              for(MInt child = 0; child < m_noCellNodes; child++) {
                if(!childCode[dirId][child]) continue;
                const MInt childId = c_childId(nghbrId, child);
                if(childId < 0) continue;
                if(a_hasProperty(childId, SolverCell::IsInactive)) continue;
                if(a_hasProperty(childId, SolverCell::IsNotGradient)) continue;
                if(a_isHalo(cellId) && a_isHalo(childId)) continue;
                srfcId = m_cellSurfaceMapping[childId][m_revDir[dirId]];
                if(srfcId < 0) {
                  if(cutCellIdMapping[childId] > 0
                     && cutCellData[cutCellIdMapping[childId]].noFacesPerCartesianDir[m_revDir[dirId]] > 0) {
                    // meaning that the neighbor child has a cartesian-surface,
                    // the cellSurfaceMapping has just not been updated yet!
                    foundNgbrSrfc = true;
                    break;
                  } else {
                    // meaning that the neighbor child does not have a cartesian face in the
                    // matching direction and a broken cellSurfaceMapping!
                    // cerr << "Incorrect surface at level-jump" << c_globalId(cellId) << " " << c_globalId(childId)
                    //     << " dir " << dirId << " lvls " << a_level(cellId) << " " << a_level(childId) << " ngb "
                    //     << c_globalId(nghbrId) << endl;
                    // cerr << cutCellData[cutCellId].noFacesPerCartesianDir[dirId] << " "
                    //     << cutCellData[cutCellIdMapping[childId]].noFacesPerCartesianDir[m_revDir[dirId]] << endl;
                  }
                } else {
                  foundNgbrSrfc = true;
                  break;
                }
              }
              if(foundNgbrSrfc) continue;
            }

            if(cutCellData[cutCellId].cartFaceArea[srf] < m_eps * 10 && !cutCellData[cutCellId].externalFaces[dirId]) {
              cerr << " TS " << globalTimeStep << " d " << domainId() << " c " << cellId
                   << " has small surface inconsistency which is ignored!" << endl;
              // removing cartisan surface from cell:
              continue;
            }

            if(splitCellId <= -1 && cutCellData[cutCellId].noFacesPerCartesianDir[dirId] == 1) {
              cerr << "ERROR, Found a Cell which is not a splitCell, has one faces in the current direction, yet the "
                      "Cell-Surface-Mapping is broken!"
                   << endl;
            }
            cerr << "Debug-Setting: " << endl;
            cerr << "- debugTimeStep   = " << globalTimeStep << endl;
            cerr << "- debugDomainId   = " << domainId() << endl;
            cerr << "- debugCellId     = " << cellId << endl;
            cerr << "- debugNeighborId = " << c_neighborId(cellId, dirId) << endl;
            cerr << "- debugDir        = " << dirId << endl;

            cerr << "Surf-Area is " << cutCellData[cutCellId].cartFaceArea[srf] << endl;

            cerr << " domain " << domainId() << " cellId " << cellId << " (" << c_globalId(cellId) << ")  CutCellId "
                 << cutCellId << " splitchildId " << splitChildId << " has no surface in dir " << dirId << endl;

            cerr << "However the cell has " << cutCellData[cutCellId].noFacesPerCartesianDir[dirId]
                 << " Faces in the current direction! "
                 << " And other Faces: " << cutCellData[cutCellId].noFacesPerCartesianDir[0] << " "
                 << cutCellData[cutCellId].noFacesPerCartesianDir[1] << cutCellData[cutCellId].noFacesPerCartesianDir[2]
                 << " " << cutCellData[cutCellId].noFacesPerCartesianDir[3] << " "
                 << cutCellData[cutCellId].noFacesPerCartesianDir[4] << " "
                 << cutCellData[cutCellId].noFacesPerCartesianDir[5] << " " << endl;

            cerr << "Instead the cell has an external-Face (Solid) in the direction: "
                 << cutCellData[cutCellId].externalFaces[dirId] << endl;

            cerr << "Cell is an original SplitCell: " << splitCellId << " with " << cutCellData[cutCellId].noSplitChilds
                 << " # of SplitChildren and " << cutCellData[cutCellId].noCartesianSurfaces << " Totalfaces. " << endl;

            cerr << "The corner-ls-values of the considered Cell-Face are: " << endl;
            for(MInt corner = 0; corner < 4; corner++) {
              cerr << " " << setprecision(16)
                   << m_candidateNodeValues[IDX_LSSETNODES(m_bndryCandidateIds[cellId], faceCornerCode[dirId][corner],
                                                           0)];
            }
            cerr << endl;

            cerr << " Current Mapping is " << m_cellSurfaceMapping[splitChildId][dirId] << endl;

            cerr << " Nghbr-Id is: " << c_neighborId(cellId, dirId) << " (" << c_globalId(c_neighborId(cellId, dirId))
                 << "( nghbr is inactive: " << a_hasProperty(c_neighborId(cellId, dirId), SolverCell::IsInactive)
                 << endl;

            cerr << " Cell is " << a_hasProperty(cellId, SolverCell::IsGapCell) << " GapCell and the neighbor is "
                 << a_hasProperty(c_neighborId(cellId, dirId), SolverCell::IsGapCell) << " Gap-Cell." << endl;
            cerr << "Complete corner ls-values: " << endl;
            for(MInt corner = 0; corner < 8; corner++) {
              cerr << " " << setprecision(16)
                   << m_candidateNodeValues[IDX_LSSETNODES(m_bndryCandidateIds[cellId], corner, 0)];
            }
            cerr << endl;

            // this should not happen!
            // the surface should either: have already been delete or
            //       the mapping should not have been destroyed!
            mTerm(1, AT_, "This was not supposed to happen - where is my surface?!?");
            // continue;
          } else
            continue;
        }

        m_cutFaceArea[a_bndryId(splitChildId)][dirId] = cutCellData[cutCellId].cartFaceArea[srf];

        MInt nghbrId = a_surfaceNghbrCellId(srfcId, dirId % 2);
        MInt nghbrBndryId = -1;
        if(splitCellId < 0 && cutCellData[cutCellId].noFacesPerCartesianDir[dirId] == 1) {
          if(nghbrId > -1) nghbrBndryId = a_bndryId(nghbrId);

          if(nghbrBndryId > -1) {
            m_bndryCells->a[nghbrBndryId].m_associatedSrfc[m_revDir[dirId]] = srfcId;
          }
        } else {
          nghbrId = c_neighborId(cellId, dirId);
          if(nghbrId > -1) nghbrBndryId = a_bndryId(nghbrId);
        }
      }


      //--RELOC6--
      // remove face stream and use below data directly!
      MBool needFaceStream = false;
      if(a_hasProperty(splitChildId, SolverCell::HasSplitFace) || cutCellData[cutCellId].noBoundarySurfaces > 1
         || cutCellData[cutCellId].noAdditionalVertices > 0)
        needFaceStream = true;

      needFaceStream = true;

      // if ( m_fvBndryCnd->m_bndryCell[ scBndryId ].m_faceStream.size() > 0 ) { //needFaceStream
      if(needFaceStream) {
        m_fvBndryCnd->m_bndryCell[scBndryId].m_faceVertices.clear();
        m_fvBndryCnd->m_bndryCell[scBndryId].m_faceStream.resize(cutCellData[cutCellId].noTotalFaces);
        MInt vertexMap[maxNoVertices];
        fill_n(vertexMap, maxNoVertices, -1);
        MInt fcnt = 0;
        for(MInt faceType = 1; faceType >= 0; faceType--) { // body faces first
          for(MInt f = 0; f < cutCellData[cutCellId].noTotalFaces; f++) {
            if((faceType == 0) && (cutCellData[cutCellId].allFacesBodyId[f] > -1)) continue;
            if((faceType == 1) && (cutCellData[cutCellId].allFacesBodyId[f] < 0)) continue;
            m_fvBndryCnd->m_bndryCell[scBndryId].m_faceStream[fcnt].resize(0);
            for(MInt p = 0; p < cutCellData[cutCellId].allFacesNoPoints[f]; p++) {
              MInt pointId = cutCellData[cutCellId].allFacesPointIds[f][p];
              ASSERT(pointId > -1 && pointId < maxNoVertices, "");
              if(vertexMap[pointId] < 0) {
                vertexMap[pointId] = (signed)m_fvBndryCnd->m_bndryCell[scBndryId].m_faceVertices.size() / nDim;
                if(pointId < CC::noCorners) {
                  for(MInt i = 0; i < nDim; i++) {
                    m_fvBndryCnd->m_bndryCell[scBndryId].m_faceVertices.push_back(
                        a_coordinate(cellId, i) + signStencil[pointId][i] * cellHalfLength);
                  }
                } else if(pointId < CC::noCorners + CC::maxNoCutPoints) {
                  MInt cpId = pointId - CC::noCorners;
                  for(MInt i = 0; i < nDim; i++) {
                    m_fvBndryCnd->m_bndryCell[scBndryId].m_faceVertices.push_back(cutCellData[cutc].cutPoints[cpId][i]);
                  }
                } else {
                  MInt aId = pointId - CC::noCorners - CC::maxNoCutPoints;
                  ASSERT(aId < cutCellData[cutCellId].noAdditionalVertices, "");
                  for(MInt i = 0; i < nDim; i++) {
                    m_fvBndryCnd->m_bndryCell[scBndryId].m_faceVertices.push_back(
                        cutCellData[cutCellId].additionalVertices[aId][i]);
                  }
                }
              }
              ASSERT(fcnt < cutCellData[cutCellId].noTotalFaces, "");
              m_fvBndryCnd->m_bndryCell[scBndryId].m_faceStream[fcnt].push_back(vertexMap[pointId]);
            }
            fcnt++;
          }
        }
      }

    } // end noCartesianSurfaces-loop

    //--REV_RELOC--
    // set external faces of split parent cell
    if(splitCellId > -1) {
      for(MInt dir = 0; dir < m_noDirs; dir++) {
        // if( noFacesPerCartesianFaceAll[ dir ] == 0 ){
        if(cutCellData[cutc].noFacesPerCartesianDir[dir] == 0) {
          bndryCell->m_externalFaces[dir] = true;
          //          cutCellData[cutc].externalFaces[dir] = true;
          MInt srfcId = cellSurfaceMapping_backup[dir];
          if(srfcId > -1) {
            a_surfaceArea(srfcId) = F0;
            deleteSurface(srfcId);
          }
        }
      }
      bndryCell->m_srfcs[0]->m_noCutPoints = 0;
    }
  }

  RECORD_TIMER_STOP(tCutFace_8);
  RECORD_TIMER_START(tCutFace_9);

  // Finalize: Adjust connectivity of split cells and split faces and their neighbors!
  // first a small check - all surfaces attached to a split cell should point to -1 or -2
  // all surfaces attachted to a split Cartesian surface should also point to -1 or -2,
  // anything else is wrong!
  MInt noSplitCells = m_splitCells.size();
  for(MInt sc = 0; sc < noSplitCells; sc++) {
    MInt scId = m_splitCells[sc];
    MInt scBndryId = a_bndryId(scId);
    for(MInt d = 0; d < m_noDirs; d++) {
      if(m_cellSurfaceMapping[scId][d] > -1) mTerm(1, AT_, "splitParent cell has a valid surface attached to it...");
      if(m_fvBndryCnd->m_bndryCells->a[scBndryId].m_associatedSrfc[d] > -1)
        mTerm(1, AT_, "splitParent cell has a valid surface attached to its boundary cell...");
    }
    // now check split children
    for(MInt ssc = 0; (unsigned)ssc < m_splitChilds[sc].size(); ssc++) {
      MInt splitChildId = m_splitChilds[sc][ssc];
      MInt splitChildBndryId = a_bndryId(splitChildId);
      for(MInt d = 0; d < m_noDirs; d++) {
        MInt srfcId = m_cellSurfaceMapping[splitChildId][d];
        if(srfcId > -1) {
          MInt nghbr0 = a_surfaceNghbrCellId(srfcId, 0);
          MInt nghbr1 = a_surfaceNghbrCellId(srfcId, 1);
          if(m_fvBndryCnd->m_bndryCells->a[splitChildBndryId].m_associatedSrfc[d] != srfcId)
            mTerm(1, AT_, "splitChild cell no consistent surface information...");
          if(nghbr0 == splitChildId) {
            if(nghbr1 > -1) mTerm(1, AT_, "splitChild cell has a surface with a valid neighbor attached to it...");
          } else if(nghbr1 == splitChildId) {
            if(nghbr0 > -1) mTerm(1, AT_, "splitChild cell has a surface with a valid neighbor attached to it...");
          } else
            mTerm(1, AT_, "splitChild cell has a surface attached to it which does not point to the cell itself...");
        } else { // this side should be either a non-fluid side or a split face! do not check now, let's check....
          MBool suspicious = true;
          if(m_fvBndryCnd->m_bndryCells->a[splitChildBndryId].m_externalFaces[d]) {
            suspicious = false;
            break;
          }
          if(a_isHalo(splitChildId)) {
            suspicious = false;
            break;
          }
          // if still suspicious, check split face state...
          if(!suspicious) continue;
          MInt sfId = splitFaceCellIds[splitChildBndryId];
          if(sfId > -1) {
            cellWithSplitFace* sfCell = &splitFaceCells[sfId];
            for(MInt sff = 0; (unsigned)sff < sfCell->splitFaces.size(); sff++) {
              splitCartesianFace* splitFace = &sfCell->splitFaces[sff];
              MInt dir = splitFace->direction;
              if(dir == d) {
                suspicious = false;
                break;
              }
            }
          }
          if(suspicious)
            mTerm(1, AT_,
                  "split cell child has a fluid side which is not split but has no valid surface attached to it!");
        }
      }
    }
  }

  // check that the split face has no surface attached to it and
  // is not otherwise connected to any other cell!
  MInt noSplitFaceCells = splitFaceCells.size();
  for(MInt sf = 0; sf < noSplitFaceCells; sf++) {
    cellWithSplitFace* sfCell = &splitFaceCells[sf];
    MInt sfId = sfCell->cellId;
    MInt sfBndryId = a_bndryId(sfId);
    MInt noSplitFaces = sfCell->splitFaces.size();
    for(MInt sff = 0; sff < noSplitFaces; sff++) {
      splitCartesianFace* splitFace = &sfCell->splitFaces[sff];
      MInt dir = splitFace->direction;
      MInt srfcId = m_cellSurfaceMapping[sfId][dir];
      if(srfcId > -1) mTerm(1, AT_, "split face has a valid surface attached to it...");
      if(m_fvBndryCnd->m_bndryCells->a[sfBndryId].m_associatedSrfc[dir] > -1)
        mTerm(1, AT_, "split face has a valid surface attached to its boundary cell...");
      for(MInt srfc = 0; (unsigned)srfc < splitFace->srfcIds.size(); srfc++) {
        srfcId = splitFace->srfcIds[srfc];
        if(srfcId < 0) mTerm(1, AT_, "split face part has no surface attached to it...");
        MInt nghbr0 = a_surfaceNghbrCellId(srfcId, 0);
        MInt nghbr1 = a_surfaceNghbrCellId(srfcId, 1);
        if(nghbr0 == sfId) {
          if(nghbr1 > -1) mTerm(1, AT_, "splitface has a surface with a valid neighbor attached to it...");
        } else if(nghbr1 == sfId) {
          if(nghbr0 > -1) mTerm(1, AT_, "splitface has a surface with a valid neighbor attached to it...");
        } else
          mTerm(1, AT_, "splitface has a surface attached to it which does not point to the cell itself...");
      }
    }
  }

  // connect all split faces to other split faces or split cells...
  for(MInt sf = 0; sf < noSplitFaceCells; sf++) {
    cellWithSplitFace* sfCell = &splitFaceCells[sf];
    const MInt sfId = sfCell->cellId;
    const MBool cellIsSplitChild = a_hasProperty(sfId, SolverCell::IsSplitChild);
    const MInt noSplitFaces = sfCell->splitFaces.size();

    const MFloat maxXdiff = 1e-4 * c_cellLengthAtLevel(a_cutCellLevel(sfId));
    const MFloat maxAdiff =
        1e-4 * c_cellLengthAtLevel(a_cutCellLevel(sfId)) * c_cellLengthAtLevel(a_cutCellLevel(sfId));

    for(MInt sff = 0; sff < noSplitFaces; sff++) {
      splitCartesianFace* splitFace = &sfCell->splitFaces[sff];
      MInt dir = splitFace->direction;
      for(MInt srfc = 0; (unsigned)srfc < splitFace->srfcIds.size(); srfc++) {
        MInt srfcId = splitFace->srfcIds[srfc];
        ASSERT(srfcId > -1, "");
        MInt srfcNeighbor = a_surfaceNghbrCellId(srfcId, dir % 2);
        if(srfcNeighbor > -1) // surface has already been corrected, continue...
          continue;
        // otherwise, we have to find the correct neigbor... first, find the Cartesian neighbor
        MInt nghbrId = -1;
        if(cellIsSplitChild) {
          MInt splitParent = getAssociatedInternalCell(sfId);
          nghbrId = c_neighborId(splitParent, dir);
        } else {
          nghbrId = c_neighborId(sfId, dir);
        }
        ASSERT(nghbrId > -1, "");
        ASSERT(a_bndryId(nghbrId) > -1, "");
        // cartesian neighbor must be split cell, have split surfaces, or both
        // so run over all split childs and check their (split) surfaces
        MInt splitChildIdN = nghbrId;
        MInt noSubCellsN = 1;
        MInt splitCellIdN = -1;
        if(a_hasProperty(nghbrId, SolverCell::IsSplitCell)) {
          splitCellIdN = splitCellIds[a_bndryId(nghbrId)];
          noSubCellsN = m_splitChilds[splitCellIdN].size();
        }
        MFloat minXDiff = std::numeric_limits<float>::max();
        MInt bestFitSrfc = -1;
        MInt bestFitCell = -1;
        MInt* bestFitSplitFacePart = (MInt*)nullptr;

        for(MInt count = 0; count < noSubCellsN; count++) {
          if(splitCellIdN > -1) {
            splitChildIdN = m_splitChilds[splitCellIdN][count];
          }

          MInt srfcIdNghbr = m_cellSurfaceMapping[splitChildIdN][m_revDir[dir]];
          if(srfcIdNghbr > -1) { // neighbor has no split surface in this direction...
            MFloat xDiff = checkCentroidDiff(srfcId, srfcIdNghbr);
            if(xDiff < minXDiff) {
              minXDiff = xDiff;
              bestFitSrfc = srfcIdNghbr;
              bestFitCell = splitChildIdN;
              bestFitSplitFacePart = (MInt*)nullptr;
            }
          } else {
            MInt splitFaceCellNghbrId = splitFaceCellIds[a_bndryId(splitChildIdN)];
            if(splitFaceCellNghbrId < 0) continue;
            for(MInt sfn = 0; (unsigned)sfn < splitFaceCells[splitFaceCellNghbrId].splitFaces.size(); sfn++) {
              if(m_revDir[dir] == splitFaceCells[splitFaceCellNghbrId].splitFaces[sfn].direction) {
                for(MInt s = 0; (unsigned)s < splitFaceCells[splitFaceCellNghbrId].splitFaces[sfn].srfcIds.size();
                    s++) {
                  srfcIdNghbr = splitFaceCells[splitFaceCellNghbrId].splitFaces[sfn].srfcIds[s];
                  ASSERT(srfcIdNghbr > -1, "");
                  MFloat xDiff = checkCentroidDiff(srfcId, srfcIdNghbr);
                  if(xDiff < minXDiff) {
                    minXDiff = xDiff;
                    bestFitSrfc = srfcIdNghbr;
                    bestFitCell = splitChildIdN;
                    bestFitSplitFacePart = &splitFaceCells[splitFaceCellNghbrId].splitFaces[sfn].srfcIds[s];
                  }
                }
              }
            }
          }
        }

        // ensure that we found at least one matching surface and set everything else accordingly...
        if(bestFitSrfc < 0) mTerm(1, AT_, "did not find a matching surface at all...");
        MFloat aDiff = checkAreaDiff(srfcId, bestFitSrfc);
        if(minXDiff > maxXdiff || aDiff > maxAdiff) {
          cerr << " [" << domainId() << "] - split surface connection - "
               << " sfId: " << sfId << " nghbr: " << nghbrId
               << " aDiff: " << aDiff / POW2(c_cellLengthAtLevel(a_cutCellLevel(sfId)))
               << " minXDiff: " << minXDiff / c_cellLengthAtLevel(a_cutCellLevel(sfId)) << " " << a_isHalo(sfId) << " "
               << noSplitFaceCells << " " << noSubCellsN << endl;
          cerr << sfId << " -> " << a_surfaceArea(srfcId) << " / "
               << " / " << a_surfaceCoordinate(srfcId, 0) - a_coordinate(sfId, 0) << " "
               << a_surfaceCoordinate(srfcId, 1) - a_coordinate(sfId, 1) << " "
               << a_surfaceCoordinate(srfcId, 2) - a_coordinate(sfId, 2) << " / " << a_coordinate(sfId, 0) << " "
               << a_coordinate(sfId, 1) << " " << a_coordinate(sfId, 2) << endl;
          cerr << sfId << " => " << a_surfaceArea(bestFitSrfc) << " / " << a_associatedBodyIds(bestFitCell, 0) << " / "
               << a_surfaceCoordinate(bestFitSrfc, 0) - a_coordinate(sfId, 0) << " "
               << a_surfaceCoordinate(bestFitSrfc, 1) - a_coordinate(sfId, 1) << " "
               << a_surfaceCoordinate(bestFitSrfc, 2) - a_coordinate(sfId, 2) << " / " << a_coordinate(bestFitCell, 0)
               << " " << a_coordinate(bestFitCell, 1) << " " << a_coordinate(bestFitCell, 2) << endl;
          mTerm(1, AT_, "split cell connection failed");
        }

        // ok, can connect surface and delete nghbrSrfc
        a_surfaceNghbrCellId(srfcId, dir % 2) = bestFitCell;
        a_surfaceNghbrCellId(bestFitSrfc, dir % 2) = -1;
        a_surfaceArea(bestFitSrfc) = F0;
        //        m_isActiveSurface[ bestFitSrfc ] = false;
        deleteSurface(bestFitSrfc);
        if(bestFitSplitFacePart == (MInt*)nullptr) {
          m_cellSurfaceMapping[bestFitCell][m_revDir[dir]] = srfcId;
          ASSERT(a_bndryId(bestFitCell) > -1, " ");
          m_fvBndryCnd->m_bndryCells->a[a_bndryId(bestFitCell)].m_associatedSrfc[m_revDir[dir]] = srfcId;
        } else {
          *bestFitSplitFacePart = srfcId;
        }
      }
    }
  }

  // now run over all split cells and try to connect them to neighboring cells if they do not have a split face in the
  // respective direction! all split faces have already been connected, thus only split cell/split cell and split cell/
  // regular cell connections have to be established!
  for(MInt sc = 0; sc < noSplitCells; sc++) {
    const MInt scId = m_splitCells[sc];

    const MFloat maxXdiff = 1e-4 * c_cellLengthAtLevel(a_cutCellLevel(scId));
    const MFloat maxAdiff =
        1e-4 * c_cellLengthAtLevel(a_cutCellLevel(scId)) * c_cellLengthAtLevel(a_cutCellLevel(scId));

    for(MInt ssc = 0; (unsigned)ssc < m_splitChilds[sc].size(); ssc++) {
      MInt splitChildId = m_splitChilds[sc][ssc];
      for(MInt dir = 0; dir < m_noDirs; dir++) {
        MInt srfcId = m_cellSurfaceMapping[splitChildId][dir];
        if(srfcId > -1) {
          MInt srfcNeighbor = a_surfaceNghbrCellId(srfcId, dir % 2);
          if(srfcNeighbor > -1) // surface has already been corrected, continue...
            continue;

          MInt nghbrId = c_neighborId(scId, dir);
          if(nghbrId < 0) mTerm(1, AT_, "split cell has no valid neighbor in direction of cut surface...");
          // two  possibilities - nghbrId can be normal cell (easy), or split cell (a bit more difficult)
          // find the correct connectivity to the neighbor, set cellsurfacemapping and associatedsrfc, and delete other
          // surface...
          MInt splitChildIdN = nghbrId;
          MInt noSubCellsN = 1;
          MInt splitCellIdN = -1;
          if(a_hasProperty(nghbrId, SolverCell::IsSplitCell)) {
            splitCellIdN = splitCellIds[a_bndryId(nghbrId)];
            noSubCellsN = m_splitChilds[splitCellIdN].size();
          }
          MFloat minXDiff = std::numeric_limits<float>::max();
          MInt bestFitSrfc = -1;
          MInt bestFitCell = -1;

          for(MInt count = 0; count < noSubCellsN; count++) {
            if(splitCellIdN > -1) {
              splitChildIdN = m_splitChilds[splitCellIdN][count];
            }
            MInt srfcIdNghbr = m_cellSurfaceMapping[splitChildIdN][m_revDir[dir]];
            if(srfcIdNghbr > -1) { // neighbor has a valid surface in this direction (no non-fluid side)
              MFloat xDiff = checkCentroidDiff(srfcId, srfcIdNghbr);
              if(xDiff < minXDiff) {
                minXDiff = xDiff;
                bestFitSrfc = srfcIdNghbr;
                bestFitCell = splitChildIdN;
              }
            }
          }

          // ensure that we found at least one matching surface and set everything else accordingly...
          if(bestFitSrfc < 0) mTerm(1, AT_, "did not find a matching surface at all...");
          MFloat aDiff = checkAreaDiff(srfcId, bestFitSrfc);
          if(minXDiff > maxXdiff || aDiff > maxAdiff) {
            cerr << domainId() << ": split " << splitChildId << " " << splitCellIdN << " " << splitChildIdN << " "
                 << nghbrId << " " << dir << " " << m_cellSurfaceMapping[splitChildId][dir] << " "
                 << m_cellSurfaceMapping[splitChildIdN][m_revDir[dir]] << " " << srfcNeighbor << endl;
            cerr << " [" << domainId() << "] - split cell connection - "
                 << " splitChildId: " << splitChildId << " nghbr: " << splitChildIdN << " aDiff: " << aDiff << " ("
                 << maxAdiff << ") minXDiff: " << minXDiff << " (" << maxXdiff << ")" << endl;
            cerr << a_coordinate(scId, 0) << " " << a_coordinate(scId, 1) << " " << a_coordinate(scId, 2) << " "
                 << endl;
            cerr << a_level(scId) << " " << a_isHalo(scId) << " " << endl;
            mTerm(1, AT_, "split cell connection failed (2)");
          }

          // ok, can connect surface and delete nghbrSrfc
          a_surfaceNghbrCellId(srfcId, dir % 2) = bestFitCell;
          a_surfaceNghbrCellId(bestFitSrfc, dir % 2) = -1;
          a_surfaceArea(bestFitSrfc) = F0;
          //          m_isActiveSurface[ bestFitSrfc ] = false;
          deleteSurface(bestFitSrfc);
          m_cellSurfaceMapping[bestFitCell][m_revDir[dir]] = srfcId;
          if(a_bndryId(bestFitCell) > -1) {
            m_fvBndryCnd->m_bndryCells->a[a_bndryId(bestFitCell)].m_associatedSrfc[m_revDir[dir]] = srfcId;
          }
        }
      }
    }
  }

  // Final check - all surfaces attached to a split cell or to a split surface should have two valid neighbors
  for(MInt sc = 0; sc < noSplitCells; sc++) {
    MInt scId = m_splitCells[sc];
    MInt scBndryId = a_bndryId(scId);
    for(MInt d = 0; d < m_noDirs; d++) {
      if(m_cellSurfaceMapping[scId][d] > -1)
        mTerm(1, AT_, "splitParent cell has a valid surface attached to it after split connection...");
      if(m_fvBndryCnd->m_bndryCells->a[scBndryId].m_associatedSrfc[d] > -1)
        mTerm(1, AT_, "splitParent cell has a valid surface attached to its boundary cell after split connection...");
    }
    // now check split children
    for(MInt ssc = 0; (unsigned)ssc < m_splitChilds[sc].size(); ssc++) {
      MInt splitChildId = m_splitChilds[sc][ssc];
      MInt splitChildBndryId = a_bndryId(splitChildId);
      for(MInt d = 0; d < m_noDirs; d++) {
        MInt srfcId = m_cellSurfaceMapping[splitChildId][d];
        if(srfcId > -1) {
          MInt nghbr0 = a_surfaceNghbrCellId(srfcId, 0);
          MInt nghbr1 = a_surfaceNghbrCellId(srfcId, 1);
          if(m_fvBndryCnd->m_bndryCells->a[splitChildBndryId].m_associatedSrfc[d] != srfcId)
            mTerm(1, AT_, "splitChild cell no consistent surface information...");
          if(nghbr0 == splitChildId) {
            if(nghbr1 < 0)
              mTerm(1, AT_,
                    "splitChild cell has a surface with no valid neighbor attached to it after split connection...");
          } else if(nghbr1 == splitChildId) {
            if(nghbr0 < 0)
              mTerm(1, AT_,
                    "splitChild cell has a surface with no valid neighbor attached to it after split connection...");
          } else
            mTerm(1, AT_,
                  "splitChild cell has a surface attached to it which does not point to the cell itself after split "
                  "connection...");
        } else { // this side should be either a non-fluid side or a split face! do not check now, let's check....
          MBool suspicious = true;
          if(m_fvBndryCnd->m_bndryCells->a[splitChildBndryId].m_externalFaces[d] || a_isHalo(scId)) {
            suspicious = false;
            break;
          }
          // if still suspicious, check split face state...
          if(!suspicious) continue;
          MInt sfId = splitFaceCellIds[splitChildBndryId];
          if(sfId > -1) {
            cellWithSplitFace* sfCell = &splitFaceCells[sfId];
            for(MInt sff = 0; (unsigned)sff < sfCell->splitFaces.size(); sff++) {
              splitCartesianFace* splitFace = &sfCell->splitFaces[sff];
              MInt dir = splitFace->direction;
              if(dir == d) {
                suspicious = false;
                break;
              }
            }
          }
          if(suspicious)
            mTerm(1, AT_,
                  "split cell child has a fluid side which is not split but has no valid surface attached to it "
                  "after split connection!");
        }
      }
    }
  }
  for(MInt sf = 0; sf < noSplitFaceCells; sf++) {
    cellWithSplitFace* sfCell = &splitFaceCells[sf];
    MInt sfId = sfCell->cellId;
    MInt sfBndryId = a_bndryId(sfId);
    MInt noSplitFaces = sfCell->splitFaces.size();
    for(MInt sff = 0; sff < noSplitFaces; sff++) {
      splitCartesianFace* splitFace = &sfCell->splitFaces[sff];
      MInt dir = splitFace->direction;
      MInt srfcId = m_cellSurfaceMapping[sfId][dir];
      if(srfcId > -1) mTerm(1, AT_, "split face has a valid surface attached to it after split connection...");
      if(m_fvBndryCnd->m_bndryCells->a[sfBndryId].m_associatedSrfc[dir] > -1)
        mTerm(1, AT_, "split face has a valid surface attached to its boundary cell after split connection...");
      for(MInt srfc = 0; (unsigned)srfc < splitFace->srfcIds.size(); srfc++) {
        srfcId = splitFace->srfcIds[srfc];
        if(srfcId < 0) mTerm(1, AT_, "split face part has no surface attached to it after split connection...");
        MInt nghbr0 = a_surfaceNghbrCellId(srfcId, 0);
        MInt nghbr1 = a_surfaceNghbrCellId(srfcId, 1);
        if(nghbr0 == sfId) {
          if(nghbr1 < 0)
            mTerm(1, AT_, "splitface has a surface with no valid neighbor attached to it after split connection...");
        } else if(nghbr1 == sfId) {
          if(nghbr0 < 0)
            mTerm(1, AT_, "splitface has a surface with a valid neighbor attached to it after split connection...");
        } else
          mTerm(1, AT_,
                "splitface has a surface attached to it which does not point to the cell itself after split "
                "connection...");
      }
    }
  }

  RECORD_TIMER_STOP(tCutFace_9);
  RECORD_TIMER_START(tCutFace_10);

  compactSurfaces();

  // repeat final check: run over all surfaces and check if they have two valid neighbors if they are active!
  for(MInt srfcId = 0; srfcId < a_noSurfaces(); srfcId++) {
    MInt nghbr0 = a_surfaceNghbrCellId(srfcId, 0);
    MInt nghbr1 = a_surfaceNghbrCellId(srfcId, 1);
    if((nghbr0 < 0 || nghbr1 < 0)) { //&& m_isActiveSurface[srfcId] )
      cerr << nghbr0 << " " << nghbr1 << " " << m_freeSurfaceIndices.count(srfcId) << endl;
      mTerm(1, "active surface has not two neighbors 4...", AT_);
    }
  }

  for(MInt bndryId = m_noOuterBndryCells; bndryId < m_fvBndryCnd->m_bndryCells->size(); bndryId++) {
    MInt cellId = m_fvBndryCnd->m_bndryCells->a[bndryId].m_cellId;
    if(a_hasProperty(cellId, SolverCell::IsSplitCell)) continue;
    for(MInt srfc = 0; srfc < m_bndryCells->a[bndryId].m_noSrfcs; srfc++) {
      if(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_bndryCndId < 0) {
        mTerm(1, AT_,
              "error in createCutFaceMb_MGC(): m_bndryCndId not set: " + to_string(cellId) + " " + to_string(bndryId)
                  + " " + to_string(m_fvBndryCnd->m_bndryCell[bndryId].m_srfcs[srfc]->m_bndryCndId) + "/"
                  + to_string(m_fvBndryCnd->m_bndryCells->a[bndryId].m_noSrfcs) + " "
                  + to_string(m_fvBndryCnd->m_bndryCells->a[bndryId].m_srfcs[srfc]->m_area));
      }
    }
  }

  checkNormalVectors();

  RECORD_TIMER_STOP(tCutFace_10);
}


/**
 * \brief Rebuild azimuthal reconstruction constants for moving boundary cells
 * \author Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::buildAdditionalAzimuthalReconstructionStencil(MInt mode) {
  TRACE();

  MFloat recCoord[3];
  if(mode == 0) {
    for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
      for(MUint j = 0; j < m_azimuthalMaxLevelWindowCells[i].size(); j++) {
        MInt offset = m_azimuthalMaxLevelWindowMap[i][j];
        MInt cellId = m_azimuthalMaxLevelWindowCells[i][j];
        if(m_azimuthalWasNearBndryIds[offset] <= -1) {
          continue;
        }
        for(MInt d = 0; d < nDim; d++) {
          recCoord[d] = m_azimuthalCutRecCoord[offset * nDim + d];
        }
        rebuildAzimuthalReconstructionConstants(cellId, offset, recCoord, mode);
      }
    }
  } else if(mode == 1) {
    for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
      for(MUint j = 0; j < m_azimuthalMaxLevelWindowCells[i].size(); j++) {
        MInt offset = m_azimuthalMaxLevelWindowMap[i][j];
        MInt cellId = m_azimuthalMaxLevelWindowCells[i][j];
        if(m_azimuthalWasNearBndryIds[offset] > -1) {
          for(MInt d = 0; d < nDim; d++) {
            recCoord[d] = m_azimuthalCutRecCoord[offset * nDim + d];
          }
          rebuildAzimuthalReconstructionConstants(cellId, offset, recCoord, mode);
          MInt noNghbrIds = m_noAzimuthalReconstNghbrs[offset];
          MBool rebuild = false;
          for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
            MInt recId = m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst + nghbr];
            if(a_bndryId(recId) > -1) {
              rebuild = true;
              break;
            }
          }
          if(!rebuild) {
            // If stencil does not contain bndry cells, reconstruction constants do not have to be recomputed
            m_azimuthalWasNearBndryIds[offset] = -1;
          }
        }
      }
    }
  }
}

/**
 * \brief Reset former azimuthal nearBoundaryCells
 * \author Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::updateAzimuthalNearBoundaryExchange() {
  TRACE();

  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MUint j = 0; j < m_azimuthalMaxLevelWindowCells[i].size(); j++) {
      MInt cellId = m_azimuthalMaxLevelWindowCells[i][j];
      MInt offset = m_azimuthalMaxLevelWindowMap[i][j];
      MInt noNghbrIds = m_noAzimuthalReconstNghbrs[offset];
      MBool rebuild = false;
      for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
        MInt recId = m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst + nghbr];
        if(a_bndryId(recId) > -1) {
          rebuild = true;
          break;
        }
      }
      if(a_levelSetValuesMb(cellId, 0) <= F0 && m_azimuthalHaloActive[offset]) {
        rebuild = true;
      }
      if(rebuild) {
        // Rebuild reconstruction constants if stencil contains bndry cells
        m_azimuthalWasNearBndryIds[offset] = cellId;
      } else {
        if(m_azimuthalWasNearBndryIds[offset] > -1) {
          // Reset reconstruction constants if stencil does not contain bndry cells anymore
          m_azimuthalWasNearBndryIds[offset] = cellId;
        } else {
          // Else keep old reconstruction constants
          m_azimuthalWasNearBndryIds[offset] = -1;
        }
      }
    }
  }
}

/**
 * \brief Update reconstruction coordinate for azimuthal halo cells on max level
 *        This is done because of moving boundary
 * \author Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::updateAzimuthalMaxLevelRecCoords() {
  TRACE();

  if(grid().noAzimuthalNeighborDomains() == 0) return;

  MUint rcvSize = maia::mpi::getBufferSize(m_azimuthalMaxLevelWindowCells);
  MFloatScratchSpace windowData(rcvSize * (nDim + 1), AT_, "windowData");
  windowData.fill(0);
  MUint sndSize = maia::mpi::getBufferSize(m_azimuthalMaxLevelHaloCells);
  MFloatScratchSpace haloData(sndSize * (nDim + 1), AT_, "haloData");
  haloData.fill(0);

  MInt sndCnt = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MUint j = 0; j < m_azimuthalMaxLevelHaloCells[i].size(); j++) {
      MInt cellId = m_azimuthalMaxLevelHaloCells[i][j];
      for(MInt d = 0; d < nDim; d++) {
        haloData[sndCnt++] = a_coordinate(cellId, d);
      }
      haloData[sndCnt++] = (MFloat)a_hasProperty(cellId, SolverCell::IsOnCurrentMGLevel);
    }
  }

  maia::mpi::exchangeBuffer(grid().azimuthalNeighborDomains(), m_azimuthalMaxLevelWindowCells,
                            m_azimuthalMaxLevelHaloCells, mpiComm(), haloData.getPointer(), windowData.getPointer(),
                            nDim + 1);

  MFloat angle = grid().azimuthalAngle();
  MFloat recCoord[3];
  MInt rcvCnt = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MUint j = 0; j < m_azimuthalMaxLevelWindowCells[i].size(); j++) {
      MInt offset = m_azimuthalMaxLevelWindowMap[i][j];
      for(MInt d = 0; d < nDim; d++) {
        recCoord[d] = windowData[rcvCnt++];
      }

      MInt side = m_azimuthalBndrySide[offset];
      grid().rotateCartesianCoordinates(recCoord, (side * angle));

      for(MInt d = 0; d < nDim; d++) {
        m_azimuthalCutRecCoord[offset * nDim + d] = recCoord[d];
      }
      m_azimuthalHaloActive[offset] = (MInt)windowData[rcvCnt++];
    }
  }

  MInt offset = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MInt j = 0; j < grid().noAzimuthalWindowCells(i); j++) {
      MInt cellId = grid().azimuthalWindowCell(i, j);
      if(m_azimuthalHaloActive[offset] > 0) {
        // m_azimuthalWasNearBndryIds[offset] = cellId;
      } else {
        m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst] = cellId;
        m_noAzimuthalReconstNghbrs[offset] = 1;
        m_azimuthalRecConsts[offset * m_maxNoAzimuthalRecConst] = F1;
        m_azimuthalWasNearBndryIds[offset] = -1;
      }
      offset++;
    }
  }
}


/** \brief Compute the reconstruction constants for azimuthal periodic exchange using a weighted least squares
 * approached solved via singular value decomposition - Derieved form
 * FvCartesianSolverXD::computeReconstructionConstantsSVD() \author Thomas Hoesgen
 */
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::computeAzimuthalReconstructionConstants(MInt mode) {
  TRACE();

  MFloat recCoord[nDim];

  MInt offset = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MInt j = 0; j < grid().noAzimuthalWindowCells(i); j++) {
      MInt cellId = grid().azimuthalWindowCell(i, j);

      if(a_levelSetValuesMb(cellId, 0) < F0) {
        m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst] = cellId;
        m_noAzimuthalReconstNghbrs[offset] = 1;
        m_azimuthalRecConsts[offset * m_maxNoAzimuthalRecConst] = F1;
        offset++;
        continue;
      }

      std::copy_n(&m_azimuthalCutRecCoord[offset * nDim], nDim, &recCoord[0]);

      rebuildAzimuthalReconstructionConstants(cellId, offset, recCoord, mode);

      offset++;
    }
  }

  for(MUint i = 0; i < m_azimuthalRemappedNeighborDomains.size(); i++) {
    for(MUint j = 0; j < m_azimuthalRemappedWindowCells[i].size(); j++) {
      MInt cellId = m_azimuthalRemappedWindowCells[i][j];

      if(a_levelSetValuesMb(cellId, 0) < F0) {
        m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst] = cellId;
        m_noAzimuthalReconstNghbrs[offset] = 1;
        m_azimuthalRecConsts[offset * m_maxNoAzimuthalRecConst] = F1;
        continue;
      }

      std::copy_n(&m_azimuthalCutRecCoord[offset * nDim], nDim, &recCoord[0]);

      rebuildAzimuthalReconstructionConstants(cellId, offset, recCoord, mode);

      offset++;
    }
  }
}

/// \brief
/// Stored azimuthal periodic data from halo rank on window rank
/// \author Thomas Hoesgen
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::storeAzimuthalPeriodicData(MInt mode) {
  TRACE();

  m_azimuthalNearBoundaryBackup.clear();
  if(grid().noAzimuthalNeighborDomains() > 0) {
    MInt noFloatData = (mode == 0 ? m_noFloatDataAdaptation : m_noFloatDataBalance);
    MInt noIntData = m_noLongData;

    MUint sndSize = maia::mpi::getBufferSize(grid().azimuthalWindowCells());
    MFloatScratchSpace windowFData(sndSize * noFloatData, AT_, "windowIData");
    windowFData.fill(-1.0);
    ScratchSpace<MUlong> windowIData(sndSize * noIntData, AT_, "windowIData");
    windowIData.fill(0);
    MUint rcvSize = maia::mpi::getBufferSize(grid().azimuthalHaloCells());
    MFloatScratchSpace haloFData(rcvSize * noFloatData, AT_, "haloFData");
    haloFData.fill(-1.0);
    ScratchSpace<MUlong> haloIData(rcvSize * noIntData, AT_, "haloIData");
    haloIData.fill(0);

    MInt sndCnt = 0;
    for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
      for(MInt j = 0; j < grid().noAzimuthalHaloCells(i); j++) {
        MInt cellId = grid().azimuthalHaloCell(i, j);
        if(m_oldBndryCells.count(cellId) != 0 || mode == 1) {
          auto it = m_oldBndryCells.find(cellId);
          haloFData[sndCnt * noFloatData] = a_cellVolume(cellId);
          haloFData[sndCnt * noFloatData + 1] = m_cellVolumesDt1[cellId];
          haloFData[sndCnt * noFloatData + 2] = it != m_oldBndryCells.end() ? it->second : F0;
          if(mode == 1) {
            for(MInt v = 0; v < CV->noVariables; v++) {
              haloFData[sndCnt * noFloatData + 3 + v] = a_variable(cellId, v);
            }
          }

          haloIData[sndCnt * noIntData] = (unsigned)m_oldBndryCells.count(cellId);
          haloIData[sndCnt * noIntData + 1] = (a_properties(cellId)).to_ulong();
        }

        sndCnt++;
      }
    }

    // Exchange
    maia::mpi::exchangeBuffer(grid().azimuthalNeighborDomains(), grid().azimuthalWindowCells(),
                              grid().azimuthalHaloCells(), mpiComm(), haloFData.getPointer(), windowFData.getPointer(),
                              noFloatData);
    maia::mpi::exchangeBuffer(grid().azimuthalNeighborDomains(), grid().azimuthalWindowCells(),
                              grid().azimuthalHaloCells(), mpiComm(), haloIData.getPointer(), windowIData.getPointer(),
                              noIntData);

    MInt rcvCnt = 0;
    for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
      for(MInt j = 0; j < grid().noAzimuthalWindowCells(i); j++) {
        MInt cellId = grid().azimuthalWindowCell(i, j);
        if(windowIData[rcvCnt * noIntData] > 0 || mode == 1) {
          MBool isEqual = false;
          MLong gCellId = cellId;
          if(mode == 1) gCellId = c_globalId(cellId);
          if(m_azimuthalNearBoundaryBackup.count(gCellId) > 0) {
            MFloat recCoord[nDim];
            MFloat cellLength = c_cellLengthAtCell(cellId);
            auto range = m_azimuthalNearBoundaryBackup.equal_range(gCellId);
            for(auto it = range.first; it != range.second; ++it) {
              for(MInt d = 0; d < nDim; d++) {
                recCoord[d] = (it->second).first[d];
              }
              if(approx(this->m_azimuthalCartRecCoord[rcvCnt * nDim + 0], recCoord[0],
                        (m_azimuthalCornerEps * cellLength))
                 && approx(this->m_azimuthalCartRecCoord[rcvCnt * nDim + 1], recCoord[1],
                           (m_azimuthalCornerEps * cellLength))
                 && approx(this->m_azimuthalCartRecCoord[rcvCnt * nDim + (nDim - 1)], recCoord[nDim - 1],
                           (m_azimuthalCornerEps * cellLength))) {
                isEqual = true;
              }
            }
          }
          if(isEqual) {
            rcvCnt++;
            continue;
          }

          vector<MFloat> tmpF(mMax(noFloatData + nDim, nDim + 3));
          vector<MUlong> tmpI(noIntData);
          tmpF[0] = this->m_azimuthalCartRecCoord[rcvCnt * nDim];
          tmpF[1] = this->m_azimuthalCartRecCoord[rcvCnt * nDim + 1];
          if(nDim == 3) {
            tmpF[2] = this->m_azimuthalCartRecCoord[rcvCnt * nDim + 2];
          }
          tmpF[nDim] = windowFData[rcvCnt * noFloatData];         // cellVol
          tmpF[nDim + 1] = windowFData[rcvCnt * noFloatData + 1]; // cellVolDt1
          tmpF[nDim + 2] = windowFData[rcvCnt * noFloatData + 2]; // sweptVol

          if(mode == 1) {
            for(MInt v = 0; v < CV->noVariables; v++) {
              tmpF[nDim + 3 + v] = windowFData[rcvCnt * noFloatData + 3 + v]; // a_variables
            }
          }

          tmpI[0] = windowIData[rcvCnt * noIntData];     // oldBndryCnt
          tmpI[1] = windowIData[rcvCnt * noIntData + 1]; // cell properties

          m_azimuthalNearBoundaryBackup.insert(make_pair(gCellId, make_pair(tmpF, tmpI)));
        }

        rcvCnt++;
      }
    }
  }

#ifndef NDEBUG
  MInt cntMax = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MInt j = 0; j < grid().noAzimuthalWindowCells(i); j++) {
      MInt cellId = grid().azimuthalWindowCell(i, j);
      MLong gCellId = cellId;
      if(mode == 1) gCellId = c_globalId(cellId);
      if(cntMax < (signed)m_azimuthalNearBoundaryBackup.count(gCellId))
        cntMax = m_azimuthalNearBoundaryBackup.count(gCellId);
      if(mode == 0 && m_azimuthalNearBoundaryBackup.count(gCellId) > 2) {
        MFloat recCoord[nDim];
        auto range = m_azimuthalNearBoundaryBackup.equal_range(gCellId);
        for(auto it = range.first; it != range.second; ++it) {
          for(MInt d = 0; d < nDim; d++) {
            recCoord[d] = (it->second).first[d];
          }
          cerr << "W:" << domainId() << " " << cellId << "/" << c_globalId(cellId) << " " << gCellId << " "
               << c_level(cellId) << " " << mode << " " << m_azimuthalNearBoundaryBackup.count(gCellId) << " " << j
               << "/" << grid().noAzimuthalWindowCells(i) << " " << grid().azimuthalNeighborDomain(i) << " "
               << c_coordinate(cellId, 0) << " " << c_coordinate(cellId, 1) << " " << c_coordinate(cellId, 2) << " "
               << recCoord[0] << " " << recCoord[1] << " " << recCoord[nDim - 1] << endl;
        }
      }
    }
  }
  MPI_Allreduce(MPI_IN_PLACE, &cntMax, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "cntMax");
  if(domainId() == 0) cerr << "cntMax: " << cntMax << endl;
#endif
}

/// \brief
/// Send stored azimuthal periodic data from window to halo
/// \author Thomas Hoesgen
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::commAzimuthalPeriodicData(MInt mode) {
  TRACE();

  if(grid().noAzimuthalNeighborDomains() == 0) return;

  MInt noFloatData = (mode == 0 ? m_noFloatDataAdaptation : m_noFloatDataBalance);
  MInt noIntData = m_noLongData;

  MUint sndSize = maia::mpi::getBufferSize(grid().azimuthalWindowCells());
  MFloatScratchSpace windowFData(sndSize * noFloatData, AT_, "windowFData");
  windowFData.fill(-1.0);
  ScratchSpace<MUlong> windowIData(sndSize * noIntData, AT_, "windowIData");
  windowFData.fill(0);
  MUint rcvSize = maia::mpi::getBufferSize(grid().azimuthalHaloCells());
  MFloatScratchSpace haloFData(rcvSize * noFloatData, AT_, "haloFData");
  haloFData.fill(-1.0);
  ScratchSpace<MUlong> haloIData(rcvSize * noIntData, AT_, "haloIData");
  haloIData.fill(0);

  MInt sndCnt = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MInt j = 0; j < grid().noAzimuthalWindowCells(i); j++) {
      MInt cellId = grid().azimuthalWindowCell(i, j);
      MLong gCellId = cellId;
      if(mode == 1) gCellId = c_globalId(cellId);
      if(m_azimuthalNearBoundaryBackup.count(gCellId) != 0) {
        MFloat recCoord[nDim];
        for(MInt d = 0; d < nDim; d++) {
          recCoord[d] = this->m_azimuthalCartRecCoord[sndCnt * nDim + d];
        }
        MFloat cellLength = c_cellLengthAtCell(cellId);
        MFloat tmp[nDim];
        auto range = m_azimuthalNearBoundaryBackup.equal_range(gCellId);
        for(auto it = range.first; it != range.second; ++it) {
          for(MInt d = 0; d < nDim; d++) {
            tmp[d] = (it->second).first[d];
          }
          MBool isEqual = true;
          for(MInt d = 0; d < nDim; d++) {
            if(!approx(tmp[d], recCoord[d], 0.01 * cellLength)) isEqual = false;
          }
          if(isEqual) {
            ASSERT((it->second).second[0] > 0 || mode == 1, "WRONG!");
            windowFData[sndCnt * noFloatData] = (it->second).first[nDim];         // cellVolume
            windowFData[sndCnt * noFloatData + 1] = (it->second).first[nDim + 1]; // cellVolumeDt1
            windowFData[sndCnt * noFloatData + 2] = (it->second).first[nDim + 2]; // sweptVolume
            if(mode == 1) {
              for(MInt v = 0; v < CV->noVariables; v++) {
                windowFData[sndCnt * noFloatData + 3 + v] = (it->second).first[nDim + 3 + v];
              }
            }

            windowIData[sndCnt * noIntData] = (it->second).second[0];     // oldBndryCnt
            windowIData[sndCnt * noIntData + 1] = (it->second).second[1]; // cell properties

            break;
          }
        }
      }

      sndCnt++;
    }
  }

  m_azimuthalNearBoundaryBackup.clear();

  // Exchange
  maia::mpi::exchangeBuffer(grid().azimuthalNeighborDomains(), grid().azimuthalHaloCells(),
                            grid().azimuthalWindowCells(), mpiComm(), windowFData.getPointer(), haloFData.getPointer(),
                            noFloatData);
  maia::mpi::exchangeBuffer(grid().azimuthalNeighborDomains(), grid().azimuthalHaloCells(),
                            grid().azimuthalWindowCells(), mpiComm(), windowIData.getPointer(), haloIData.getPointer(),
                            noIntData);

  MInt rcvCnt = 0;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MInt j = 0; j < grid().noAzimuthalHaloCells(i); j++) {
      MInt cellId = grid().azimuthalHaloCell(i, j);

      if(mode == 1) {
        maia::fv::cell::BitsetType props = (haloIData[rcvCnt * noIntData + 1]);
        a_hasProperty(cellId, SolverCell::WasInactive) = props[maia::fv::cell::p(SolverCell::WasInactive)];
      } else {
        if(a_levelSetValuesMb(cellId, 0) < F0) {
          a_hasProperty(cellId, SolverCell::WasInactive) = true;
        } else {
          a_hasProperty(cellId, SolverCell::WasInactive) = false;
        }
      }
      a_hasProperty(cellId, SolverCell::WasGapCell) = false;
      if(m_closeGaps) mTerm(1, AT_, "AzimuthalPer adaptation not working with gap closing!");

      if(mode == 1) {
        for(MInt v = 0; v < CV->noVariables; v++) {
          a_variable(cellId, v) = haloFData[rcvCnt * noFloatData + 3 + v];
          a_oldVariable(cellId, v) = a_variable(cellId, v);
        }
        setPrimitiveVariables(cellId);
      }
      if(haloIData[rcvCnt * noIntData] > 0) {
        a_cellVolume(cellId) = haloFData[rcvCnt * noFloatData];
        m_cellVolumesDt1[cellId] = haloFData[rcvCnt * noFloatData + 1];

        m_oldBndryCells.insert(make_pair(cellId, haloFData[rcvCnt * noFloatData + 2]));

        maia::fv::cell::BitsetType props = (haloIData[rcvCnt * noIntData + 1]);
        a_hasProperty(cellId, SolverCell::IsMovingBnd) = props[maia::fv::cell::p(SolverCell::IsMovingBnd)];
        a_hasProperty(cellId, SolverCell::NearWall) = props[maia::fv::cell::p(SolverCell::NearWall)];
        a_hasProperty(cellId, SolverCell::IsInactive) = props[maia::fv::cell::p(SolverCell::IsInactive)];
        a_hasProperty(cellId, SolverCell::WasInactive) = a_hasProperty(cellId, SolverCell::WasInactive);
        a_hasProperty(cellId, SolverCell::WasGapCell) = props[maia::fv::cell::p(SolverCell::WasGapCell)];
      } else {
        a_cellVolume(cellId) = grid().gridCellVolume(a_level(cellId));
        m_cellVolumesDt1[cellId] = grid().gridCellVolume(a_level(cellId));
      }

      if((a_level(cellId) >= m_lsCutCellMinLevel)
         && a_levelSetValuesMb(cellId, 0) > m_maxBndryLayerDistances[maxRefinementLevel()][0]
         && a_levelSetValuesMb(cellId, 0) < m_maxBndryLayerDistances[maxRefinementLevel()][1] && c_isLeafCell(cellId)) {
        vector<MFloat> tmp(max(m_noCVars + m_noFVars, 0) + 1);
        tmp[0] = m_cellVolumesDt1[cellId];
        for(MInt v = 0; v < m_noCVars; v++) {
          tmp[1 + v] = std::numeric_limits<MFloat>::lowest();
        }
        for(MInt v = 0; v < m_noFVars; v++) {
          tmp[1 + m_noCVars + v] = std::numeric_limits<MFloat>::lowest();
        }
        m_nearBoundaryBackup.insert(make_pair(cellId, tmp));
      }

      rcvCnt++;
    }
  }
}

/// \brief Change local into global ids.
///
/// \author Thomas Hoesgen
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::localToGlobalIds() {
  TRACE();

  // Nothing to do if solver is not active
  if(!isActive()) {
    return;
  }

  if(grid().azimuthalPeriodicity()) {
    MInt noFloatData = m_azimuthalNearBoundaryBackupMaxCount * (nDim + m_noFloatDataBalance);
    MInt noLongData = m_azimuthalNearBoundaryBackupMaxCount * m_noLongDataBalance;
    mAlloc(m_azimuthalNearBoundaryBackupBalFloat, maxNoGridCells() * noFloatData,
           "m_azimuthalNearBoundaryBackupBalFloat", AT_);
    mAlloc(m_azimuthalNearBoundaryBackupBalLong, maxNoGridCells() * noLongData, "m_azimuthalNearBoundaryBackupBalLong",
           AT_);

    m_azimuthalRecConstSet = false;
    m_azimuthalNearBndryInit = false;
    storeAzimuthalPeriodicData(1);

    MInt maxCount = 0;
    for(MInt cellId = 0; cellId < c_noCells(); cellId++) {
      MInt gCellId = c_globalId(cellId);
      if((MInt)m_azimuthalNearBoundaryBackup.count(gCellId) > maxCount) {
        maxCount = (MInt)m_azimuthalNearBoundaryBackup.count(gCellId);
      }
    }
    MPI_Allreduce(MPI_IN_PLACE, &maxCount, 1, MPI_INT, MPI_MAX, mpiComm(), AT_, "MPI_IN_PLACE", "maxCount");
    if(maxCount > m_azimuthalNearBoundaryBackupMaxCount) {
      mTerm(1, "This is a problem! " + to_string(maxCount) + " " + to_string(m_azimuthalNearBoundaryBackupMaxCount));
    }

    for(MInt cellId = 0; cellId < noInternalCells(); cellId++) {
      MInt gCellId = c_globalId(cellId);
      for(MInt i = 0; i < noLongData; i++) {
        m_azimuthalNearBoundaryBackupBalLong[cellId * noLongData + i] = -1;
      }
      for(MInt i = 0; i < noFloatData; i++) {
        m_azimuthalNearBoundaryBackupBalFloat[cellId * noFloatData + i] = -1;
      }
      if(m_azimuthalNearBoundaryBackup.count(gCellId) != 0) {
        MInt indexL = 0;
        MInt indexF = 0;
        auto range = m_azimuthalNearBoundaryBackup.equal_range(gCellId);
        for(auto it_ = range.first; it_ != range.second; ++it_) {
          m_azimuthalNearBoundaryBackupBalLong[cellId * noLongData + indexL++] = (MUlong)gCellId;
          m_azimuthalNearBoundaryBackupBalLong[cellId * noLongData + indexL++] = (MUlong)(it_->second).second[0];
          m_azimuthalNearBoundaryBackupBalLong[cellId * noLongData + indexL++] = (MUlong)(it_->second).second[1];

          for(MInt f = 0; f < (nDim + m_noFloatDataBalance); f++) {
            m_azimuthalNearBoundaryBackupBalFloat[cellId * noFloatData + indexF++] = (it_->second).first[f];
          }
        }
      }
    }
  }
}

/// \brief Create exchange for all window/halo cells which are used for the azimuthal periodic interpolation
///
/// \author Thomas Hoesgen
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::initAzimuthalLinkedHaloExc() {
  TRACE();

  set<MInt> needsExc;
  for(MInt i = 0; i < grid().noAzimuthalNeighborDomains(); i++) {
    for(MUint j = 0; j < m_azimuthalMaxLevelWindowCells[i].size(); j++) {
      MInt offset = m_azimuthalMaxLevelWindowMap[i][j];
      MInt noNghbrIds = m_noAzimuthalReconstNghbrs[offset];
      for(MInt nghbr = 0; nghbr < noNghbrIds; nghbr++) {
        MInt recId = m_azimuthalReconstNghbrIds[offset * m_maxNoAzimuthalRecConst + nghbr];
        if(a_isHalo(recId)) {
          needsExc.insert(recId);
        }
      }
    }
  }

  m_azimuthalLinkedHaloCells.resize(noNeighborDomains());
  m_azimuthalLinkedWindowCells.resize(noNeighborDomains());

  for(MInt i = 0; i < noNeighborDomains(); i++) {
    m_azimuthalLinkedHaloCells[i].clear();
    m_azimuthalLinkedWindowCells[i].clear();
  }

  MUint sndSize = maia::mpi::getBufferSize(grid().haloCells());
  MIntScratchSpace haloBuff(sndSize, AT_, "haloBuff");
  haloBuff.fill(0);
  MUint rcvSize = maia::mpi::getBufferSize(grid().windowCells());
  MIntScratchSpace windowBuff(rcvSize, AT_, "windowBuff");
  windowBuff.fill(0);

  MInt sndCnt = 0;
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    for(MInt j = 0; j < m_noMaxLevelHaloCells[i]; j++) {
      const MInt haloCell = m_maxLevelHaloCells[i][j];
      if(needsExc.find(haloCell) != needsExc.end()) {
        haloBuff[sndCnt] = 1;
        m_azimuthalLinkedHaloCells[i].push_back(haloCell);
      } else {
        haloBuff[sndCnt] = 0;
      }
      sndCnt++;
    }
  }

  ScratchSpace<MPI_Request> sndReq(noNeighborDomains(), AT_, "sndReq");
  ScratchSpace<MPI_Request> rcvReq(noNeighborDomains(), AT_, "rcvReq");
  MInt rcvOffset = 0;
  MInt sndOffset = 0;
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    MPI_Irecv(&windowBuff[rcvOffset], m_noMaxLevelWindowCells[i], MPI_INT, neighborDomain(i), 2, mpiComm(), &rcvReq[i],
              AT_, "windowBuff[rcvOffset]");
    rcvOffset += m_noMaxLevelWindowCells[i];
  }
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    MPI_Isend(&haloBuff[sndOffset], m_noMaxLevelHaloCells[i], MPI_INT, neighborDomain(i), 2, mpiComm(), &sndReq[i], AT_,
              "haloBuff[i]");
    sndOffset += m_noMaxLevelHaloCells[i];
  }
  MPI_Waitall(noNeighborDomains(), &rcvReq[0], MPI_STATUSES_IGNORE, AT_);
  MPI_Waitall(noNeighborDomains(), &sndReq[0], MPI_STATUSES_IGNORE, AT_);

  MInt rcvCnt = 0;
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    for(MInt j = 0; j < m_noMaxLevelWindowCells[i]; j++) {
      MInt windowCell = m_maxLevelWindowCells[i][j];
      if(windowBuff[rcvCnt] > 0) {
        m_azimuthalLinkedWindowCells[i].push_back(windowCell);
      }
      rcvCnt++;
    }
  }
}

/// \brief Create exchange for all window/halo cells which are used for the azimuthal periodic interpolation
///
/// \author Thomas Hoesgen
template <MInt nDim, class SysEqn>
void FvMbCartesianSolverXD<nDim, SysEqn>::exchangeLinkedHaloCellsForAzimuthalReconstruction() {
  TRACE();

  MUint sndSize = maia::mpi::getBufferSize(m_azimuthalLinkedWindowCells);
  MFloatScratchSpace windowData(sndSize * m_noCVars, AT_, "windowData");
  windowData.fill(0);
  MUint rcvSize = maia::mpi::getBufferSize(m_azimuthalLinkedHaloCells);
  MFloatScratchSpace haloData(rcvSize * m_noCVars, AT_, "haloData");
  haloData.fill(0);

  MInt sndCnt = 0;
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    for(MInt j = 0; j < (signed)m_azimuthalLinkedWindowCells[i].size(); j++) {
      MInt cellId = m_azimuthalLinkedWindowCells[i][j];
      std::copy_n(&a_variable(cellId, 0), m_noCVars, &windowData[sndCnt]);
      sndCnt += m_noCVars;
    }
  }

  // Exchange
  maia::mpi::exchangeBuffer(grid().neighborDomains(), m_azimuthalLinkedHaloCells, m_azimuthalLinkedWindowCells,
                            mpiComm(), windowData.getPointer(), haloData.getPointer(), m_noCVars);

  // Extract
  MInt rcvCnt = 0;
  for(MInt i = 0; i < noNeighborDomains(); i++) {
    for(MInt j = 0; j < (signed)m_azimuthalLinkedHaloCells[i].size(); j++) {
      MInt cellId = m_azimuthalLinkedHaloCells[i][j];
      std::copy_n(&haloData[rcvCnt], m_noCVars, &a_variable(cellId, 0));
      rcvCnt += m_noCVars;
    }
  }
}
